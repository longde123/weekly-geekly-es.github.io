<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÅÔ∏è üïì ü§≤ API pour lesquelles il vaut enfin la peine de passer de Java 8. Partie 1 üà≤ üç™ ‚ÜòÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java 8 est de loin la version la plus populaire de Java et le restera pendant un certain temps. Cependant, depuis lors, cinq nouvelles versions de Jav...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API pour lesquelles il vaut enfin la peine de passer de Java 8. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485750/"><p>  Java 8 est de loin la version la plus populaire de Java et le restera pendant un certain temps.  Cependant, depuis lors, cinq nouvelles versions de Java ont d√©j√† √©t√© publi√©es (9, 10, 11, 12, 13) et bient√¥t un autre Java 14. Ces nouvelles versions auront √©norm√©ment de nouvelles fonctionnalit√©s.  Par exemple, si vous comptez dans les JEP, 141 au total ont √©t√© impl√©ment√©s: </p><br><ul><li>  99 dans <a href="https://openjdk.java.net/projects/jdk9/" rel="nofollow">JDK 9</a> </li><li>  12 en <a href="https://openjdk.java.net/projects/jdk/10/" rel="nofollow">JDK 10</a> </li><li>  17 dans <a href="https://openjdk.java.net/projects/jdk/11/" rel="nofollow">JDK 11</a> </li><li>  8 en <a href="https://openjdk.java.net/projects/jdk/12/" rel="nofollow">JDK 12</a> </li><li>  5 dans <a href="https://openjdk.java.net/projects/jdk/13/" rel="nofollow">JDK 13</a> </li><li>  (+14 √† <a href="https://openjdk.java.net/projects/jdk/14/" rel="nofollow">JDK 14</a> ) </li></ul><br><p>  Cependant, dans cette s√©rie d'articles, il n'y aura pas de liste s√®che des PEC.  Au lieu de cela, je veux juste parler des API int√©ressantes qui sont apparues dans les nouvelles versions.  Chaque article contiendra 10 API.  Dans le choix et l'ordre de ces API, il n'y aura pas de logique et de r√©gularit√© sp√©cifiques.  Ce ne sera que 10 API al√©atoires, pas TOP 10 et sans trier de l'API la plus importante √† la moins importante.  Commen√ßons. </p><a name="habracut"></a><br>
<h3>  1. M√©thodes <code>Objects.requireNonNullElse()</code> et <code>Objects.requireNonNullElseGet()</code> </h3><br><h4>  Introduit dans: Java 9 </h4><br><p>  Nous commen√ßons notre liste avec deux m√©thodes tr√®s simples mais tr√®s utiles dans la classe <code>java.util.Objects</code> : <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Objects.html" rel="nofollow">requireNonNullElse()</a></code> et <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Objects.html" rel="nofollow">requireNonNullElseGet()</a></code> .  Ces m√©thodes vous permettent de renvoyer l'objet transmis, s'il n'est pas <code>null</code> , et s'il l'est, renvoyez l'objet par d√©faut.  Par exemple: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCoder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Charset charset; MyCoder(Charset charset) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.charset = Objects.requireNonNullElse( charset, StandardCharsets.UTF_8); } }</code> </pre> <br><p>  <code>requireNonNullElseGet()</code> n'est rien de plus qu'une version paresseuse de <code>requireNonNullElse()</code> .  Cela peut √™tre utile si le calcul de l'argument par d√©faut est co√ªteux: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCoder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Charset charset; MyCoder(Charset charset) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.charset = Objects.requireNonNullElseGet( charset, MyCoder::defaultCharset); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Charset </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultCharset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// long operation... } }</span></span></code> </pre> <br><p>  Oui, bien s√ªr, dans les deux cas, on pourrait facilement se passer de ces fonctions, par exemple, en utilisant l'op√©rateur ternaire habituel ou en <code>Optional</code> , mais en utilisant toujours une fonction sp√©ciale, le code est un peu plus court et plus propre.  Et si vous utilisez l'importation statique et √©crivez simplement <code>requireNonNullElse()</code> au lieu d' <code>Objects.requireNonNullElse()</code> , alors le code peut √™tre r√©duit encore plus. </p><br><br><h3>  2. M√©thodes d'usine renvoyant des collections immuables </h3><br><h4>  Introduit dans: Java 9 </h4><br><p>  Si les deux m√©thodes pr√©c√©dentes ne sont que des cosm√©tiques, les m√©thodes d'usine de collecte statique peuvent vraiment r√©duire consid√©rablement le code et m√™me am√©liorer sa s√©curit√©.  Ce sont les m√©thodes suivantes <a href="https://openjdk.java.net/jeps/269" rel="nofollow">introduites</a> dans Java 9: </p><br><ul><li>  <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/List.html" rel="nofollow">List.of(E... elements)</a></code> (et surcharges) </li><li>  <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Set.html" rel="nofollow">Set.of(E... elements)</a></code> (et surcharges) </li><li>  <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Map.html" rel="nofollow">Map.of(K k1, V v1, K k2, V v2, ...)</a></code> (et surcharges) </li><li> <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Map.html" rel="nofollow">Map.ofEntries(Entry&lt;? extends K, ? extends V&gt;... entries)</a></code> </li> </ul><br><p>  √Ä la m√™me liste, vous pouvez ajouter la <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Map.html" rel="nofollow">Map.entry(K k, V v)</a></code> qui l'accompagne, qui cr√©e une <code>Entry</code> partir de la cl√© et de la valeur, ainsi que des m√©thodes de copie des collections <a href="https://minijug.ru/unmodifiable_collections_enhancements_in_java_10.html" rel="nofollow">apparues</a> dans Java 10: </p><br><ul><li> <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/List.html" rel="nofollow">List.copyOf(Collection&lt;? extends E&gt; coll)</a></code> </li> <li> <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Set.html" rel="nofollow">Set.copyOf(Collection&lt;? extends E&gt; coll)</a></code> </li> <li> <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Map.html" rel="nofollow">Map.copyOf(Map&lt;? extends K,‚Äã? extends V&gt; map)</a></code> </li> </ul><br><p>  Les m√©thodes de fabrique statique vous permettent de cr√©er une collection immuable et de l'initialiser en une seule action: </p><br><pre> <code class="java hljs">List&lt;String&gt; imageExtensions = List.of(<span class="hljs-string"><span class="hljs-string">"bmp"</span></span>, <span class="hljs-string"><span class="hljs-string">"jpg"</span></span>, <span class="hljs-string"><span class="hljs-string">"png"</span></span>, <span class="hljs-string"><span class="hljs-string">"gif"</span></span>);</code> </pre> <br><p>  Si vous n'utilisez pas de biblioth√®ques tierces, un code similaire dans Java 8 semble beaucoup plus lourd: </p><br><pre> <code class="java hljs">List&lt;String&gt; imageExtensions = Collections.unmodifiableList( Arrays.asList(<span class="hljs-string"><span class="hljs-string">"bmp"</span></span>, <span class="hljs-string"><span class="hljs-string">"jpg"</span></span>, <span class="hljs-string"><span class="hljs-string">"png"</span></span>, <span class="hljs-string"><span class="hljs-string">"gif"</span></span>));</code> </pre> <br><p>  Et dans le cas de <code>Set</code> ou <code>Map</code> c'est encore plus triste, car il n'y a pas d'analogues de <code>Arrays.asList()</code> pour <code>Set</code> et <code>Map</code> . </p><br><p>  Une telle lourdeur incite de nombreuses personnes qui √©crivent en Java 8 √† abandonner compl√®tement les collections immuables et utilisent toujours les <code>ArrayList</code> , <code>HashSet</code> et <code>HashMap</code> , m√™me lorsque le sens des collections immuables est n√©cessaire.  En cons√©quence, cela rompt le concept d'immuable par d√©faut et r√©duit la s√©curit√© du code. </p><br><p>  Si vous effectuez enfin une mise √† niveau √† partir de Java 8, alors travailler avec des collections immuables devient beaucoup plus facile et plus agr√©able gr√¢ce aux m√©thodes d'usine. </p><br><br><h3>  3. <code>Files.readString()</code> et <code>Files.writeString()</code> </h3><br><h4>  Introduit dans: Java 11 </h4><br><p>  Java a toujours √©t√© connu pour son introduction tranquille de m√©thodes pr√™tes √† l'emploi pour des op√©rations fr√©quentes.  Par exemple, pour l'une des op√©rations de programmation les plus populaires, la lecture d'un fichier, il n'y a pas eu pendant longtemps de m√©thode toute faite.  Seulement 15 ans apr√®s la sortie de Java 1.0, NIO est apparu, o√π la m√©thode <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html" rel="nofollow">Files.readAllBytes()</a></code> √©t√© introduite pour lire le fichier dans un tableau d'octets. </p><br><p>  Mais cela n'√©tait pas encore suffisant, car les gens doivent souvent travailler avec des fichiers texte et pour cela, vous devez lire les cha√Ænes du fichier, pas les octets.  Par cons√©quent, dans Java 8, la m√©thode <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html" rel="nofollow">Files.readAllLines()</a></code> √©t√© ajout√©e, renvoyant une <code>List&lt;String&gt;</code> . </p><br><p>  Cependant, cela ne suffisait pas, car les gens demandaient √† quel point il √©tait facile de lire l'int√©gralit√© du fichier sur une seule ligne.  En cons√©quence, pour compl√©ter l'image dans Java 11, la m√©thode <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html" rel="nofollow">Files.readString()</a></code> tant attendue a √©t√© <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html" rel="nofollow">Files.readString()</a></code> , fermant ainsi d√©finitivement cette question.  √âtonnamment, si une m√©thode similaire √©tait pr√©sente dans de nombreuses autres langues d√®s le d√©but, Java a mis plus de 20 ans √† le faire. </p><br><p>  Avec <code>readString()</code> bien s√ªr, la <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html" rel="nofollow">writeString()</a></code> sym√©trique <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html" rel="nofollow">writeString()</a></code> a √©galement √©t√© introduite.  Ces m√©thodes ont √©galement des surcharges qui vous permettent de sp√©cifier un jeu de <code>Charset</code> .  Ensemble, tout cela rend le travail avec des fichiers texte extr√™mement pratique.  Un exemple: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/**        */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reencodeFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path path, Charset from, Charset to)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ String content = Files.readString(path, from); Files.writeString(path, content, to); }</code> </pre> <br><br><h3>  4. <code>Optional.ifPresentOrElse()</code> et <code>Optional.stream()</code> </h3><br><h4>  Introduit dans: Java 9 </h4><br><p>  Lorsque <code>Optional</code> est apparu dans Java 8, ils ne disposaient pas d'un moyen pratique pour effectuer deux actions diff√©rentes, selon qu'il a une valeur ou non.  En cons√©quence, les gens doivent recourir √† la cha√Æne habituelle <code>isPresent()</code> et <code>get()</code> : </p><br><pre> <code class="java hljs">Optional&lt;String&gt; opt = ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opt.isPresent()) { log.info(<span class="hljs-string"><span class="hljs-string">"Value = "</span></span> + opt.get()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { log.error(<span class="hljs-string"><span class="hljs-string">"Empty"</span></span>); }</code> </pre> <br><p>  Ou vous pouvez toujours esquiver de cette fa√ßon: </p><br><pre> <code class="java hljs">Optional&lt;String&gt; opt = ... opt.ifPresent(str -&gt; log.info(<span class="hljs-string"><span class="hljs-string">"Value = "</span></span> + str)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opt.isEmpty()) { log.error(<span class="hljs-string"><span class="hljs-string">"Empty"</span></span>); }</code> </pre> <br><p>  Les deux options ne sont pas parfaites.  Mais, √† partir de Java 9, cela peut √™tre fait avec √©l√©gance en utilisant la m√©thode <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Optional.html" rel="nofollow">Optional.ifPresentOrElse()</a></code> : </p><br><pre> <code class="java hljs">Optional&lt;String&gt; opt = ... opt.ifPresentOrElse( str -&gt; log.info(<span class="hljs-string"><span class="hljs-string">"Value = "</span></span> + str), () -&gt; log.error(<span class="hljs-string"><span class="hljs-string">"Empty"</span></span>));</code> </pre> <br><p>  Une autre nouvelle m√©thode int√©ressante dans Java 9 est <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Optional.html" rel="nofollow">Optional.stream()</a></code> , qui renvoie un <code>Stream</code> partir d'un √©l√©ment si la valeur est pr√©sente, et un <code>Stream</code> vide si ce n'est pas le cas.  Une telle m√©thode peut √™tre tr√®s utile dans les cha√Ænes avec <code>flatMap()</code> .  Par exemple, dans cet exemple, il est tr√®s simple d'obtenir une liste de tous les num√©ros de t√©l√©phone d'une entreprise: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Employee</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Optional&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPhoneNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Department</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">List&lt;Employee&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEmployees</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Company</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">List&lt;Department&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDepartments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-function">Set&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAllPhoneNumbers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getDepartments() .stream() .flatMap(d -&gt; d.getEmployees().stream()) .flatMap(e -&gt; e.getPhoneNumber().stream()) .collect(Collectors.toSet()); } }</code> </pre> <br><p>  En Java 8, vous devez √©crire quelque chose comme: </p><br><pre> <code class="plaintext hljs">e -&gt; e.getPhoneNumber().map(Stream::of).orElse(Stream.empty())</code> </pre> <br><p>  Il semble volumineux et peu lisible. </p><br><br><h3>  5. <code>Process.pid()</code> , <code>Process.info()</code> et <code>ProcessHandle</code> </h3><br><h4>  Introduit dans: Java 9 </h4><br><p>  Si vous pouvez toujours g√©rer sans les API pr√©c√©dentes, le remplacement de la m√©thode <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Process.html" rel="nofollow">Process.pid()</a></code> dans Java 8 sera assez probl√©matique, en particulier multiplateforme.  Cette m√©thode renvoie l'ID de processus natif: </p><br><pre> <code class="java hljs">Process process = Runtime.getRuntime().exec(<span class="hljs-string"><span class="hljs-string">"java -version"</span></span>); System.out.println(process.pid());</code> </pre> <br><p>  En utilisant la m√©thode <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Process.html" rel="nofollow">Process.info()</a></code> , vous pouvez √©galement trouver des informations utiles suppl√©mentaires sur le processus.  Il renvoie un objet de type <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.Info.html" rel="nofollow">ProcessHandle.Info</a></code> .  Voyons ce qu'il nous retourne pour le processus ci-dessus: </p><br><pre> <code class="java hljs">Process process = Runtime.getRuntime().exec(<span class="hljs-string"><span class="hljs-string">"java -version"</span></span>); ProcessHandle.Info info = process.info(); System.out.println(<span class="hljs-string"><span class="hljs-string">"PID = "</span></span> + process.pid()); System.out.println(<span class="hljs-string"><span class="hljs-string">"User = "</span></span> + info.user()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Command = "</span></span> + info.command()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Args = "</span></span> + info.arguments().map(Arrays::toString)); System.out.println(<span class="hljs-string"><span class="hljs-string">"Command Line = "</span></span> + info.commandLine()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Start Time = "</span></span> + info.startInstant()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Total Time = "</span></span> + info.totalCpuDuration());</code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">PID = 174 User = Optional[orionll] Command = Optional[/usr/lib/jvm/java-13-openjdk-amd64/bin/java] Args = Optional[[-version]] Command Line = Optional[/usr/lib/jvm/java-13-openjdk-amd64/bin/java -version] Start Time = Optional[2020-01-24T05:54:25.680Z] Total Time = Optional[PT0.01S]</code> </pre> <br><p>  Que faire si le processus n'a pas √©t√© d√©marr√© √† partir du processus Java actuel?  Pour cela, <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.html" rel="nofollow">ProcessHandle</a></code> vient √† la <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.html" rel="nofollow">ProcessHandle</a></code> .  Par exemple, obtenons toutes les m√™mes informations pour le processus en cours en utilisant la m√©thode <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.html" rel="nofollow">ProcessHandle.current()</a></code> : </p><br><pre> <code class="java hljs">ProcessHandle handle = ProcessHandle.current(); ProcessHandle.Info info = handle.info(); System.out.println(<span class="hljs-string"><span class="hljs-string">"PID = "</span></span> + handle.pid()); System.out.println(<span class="hljs-string"><span class="hljs-string">"User = "</span></span> + info.user()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Command = "</span></span> + info.command()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Args = "</span></span> + info.arguments().map(Arrays::toString)); System.out.println(<span class="hljs-string"><span class="hljs-string">"Command Line = "</span></span> + info.commandLine()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Start Time = "</span></span> + info.startInstant()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Total Time = "</span></span> + info.totalCpuDuration());</code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">PID = 191 User = Optional[orionll] Command = Optional[/usr/lib/jvm/java-13-openjdk-amd64/bin/java] Args = Optional[[Main.java]] Command Line = Optional[/usr/lib/jvm/java-13-openjdk-amd64/bin/java Main.java] Start Time = Optional[2020-01-24T05:59:17.060Z] Total Time = Optional[PT1.56S]</code> </pre> <br><p>  Pour obtenir un <code>ProcessHandle</code> pour n'importe quel processus par son PID, vous pouvez utiliser la m√©thode <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.html" rel="nofollow">ProcessHandle.of()</a></code> (il retournera <code>Optional.empty</code> si le processus n'existe pas). </p><br><p>  Il existe √©galement de nombreuses autres m√©thodes int√©ressantes dans <code>ProcessHandle</code> , par exemple <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.html" rel="nofollow">ProcessHandle.allProcesses()</a></code> . </p><br><br><h3>  6. M√©thodes de <code>String</code> : <code>isBlank()</code> , <code>strip()</code> , <code>stripLeading()</code> , <code>stripTrailing()</code> , <code>repeat()</code> et <code>lines()</code> </h3><br><h4>  Introduit dans: Java 11 </h4><br><p>  Une montagne enti√®re de m√©thodes utiles pour les cha√Ænes est apparue dans Java 11. </p><br><p>  La m√©thode <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.isBlank()</a></code> vous permet de savoir si une cha√Æne se compose uniquement d'espaces: </p><br><pre> <code class="java hljs">System.out.println(<span class="hljs-string"><span class="hljs-string">" \n\r\t"</span></span>.isBlank()); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br><p>  Les <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.stripLeading()</a></code> , <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.stripTrailing()</a></code> et <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.strip()</a></code> suppriment les espaces blancs au d√©but d'une ligne, √† la fin d'une ligne ou aux deux extr√©mit√©s: </p><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">" \tHello, world!\t\n"</span></span>; String str1 = str.stripLeading(); <span class="hljs-comment"><span class="hljs-comment">// "Hello, world!\t\n" String str2 = str.stripTrailing(); // " \tHello, world!" String str3 = str.strip(); // "Hello, world!"</span></span></code> </pre> <br><p>  Notez que <code>String.strip()</code> pas identique √† <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.trim()</a></code> : le second supprime uniquement les caract√®res dont le code est inf√©rieur ou √©gal √† U + 0020, et le premier supprime √©galement les espaces d'Unicode: </p><br><pre> <code class="java hljs">System.out.println(<span class="hljs-string"><span class="hljs-string">"str\u2000"</span></span>.strip()); <span class="hljs-comment"><span class="hljs-comment">// "str" System.out.println("str\u2000".trim()); // "str\u2000"</span></span></code> </pre> <br><br><p>  La m√©thode <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.repeat()</a></code> concat√®ne la cha√Æne elle-m√™me <code>n</code> fois: </p><br><pre> <code class="java hljs">System.out.print(<span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span>.repeat(<span class="hljs-number"><span class="hljs-number">3</span></span>));</code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">Hello, world! Hello, world! Hello, world!</code> </pre> <br><p>  Enfin, la m√©thode <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.lines()</a></code> d√©compose la cha√Æne en lignes.  Au revoir <code>String.split()</code> , avec lequel les gens confondent constamment, quel argument utiliser pour cela, soit <code>"\n"</code> , soit <code>"\r"</code> ou <code>"\n\r"</code> (en fait, il est pr√©f√©rable d'utiliser r√©guli√®rement expression <code>"\R"</code> , qui couvre toutes les combinaisons).  De plus, <code>String.lines()</code> peut souvent √™tre plus efficace car il renvoie des lignes paresseusement. </p><br><pre> <code class="java hljs">System.out.println(<span class="hljs-string"><span class="hljs-string">"line1\nline2\nline3\n"</span></span> .lines() .map(String::toUpperCase) .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)));</code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">LINE1 LINE2 LINE3</code> </pre> <br><br><h3>  7. <code>String.indent()</code> </h3><br><h4>  Apparu dans: Java 12 </h4><br><p>  Diluons notre histoire avec quelque chose de nouveau qui est apparu r√©cemment.  Meet: la m√©thode <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.indent()</a></code> , qui augmente (ou diminue) l'indentation de chaque ligne d'une ligne donn√©e de la valeur sp√©cifi√©e.  Par exemple: </p><br><pre> <code class="java hljs">String body = <span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;Title&lt;/h1&gt;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"&lt;p&gt;Hello, world!&lt;/p&gt;"</span></span>; System.out.println(<span class="hljs-string"><span class="hljs-string">"&lt;html&gt;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" &lt;body&gt;\n"</span></span> + body.indent(<span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-string"><span class="hljs-string">" &lt;/body&gt;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"&lt;/html&gt;"</span></span>);</code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">&lt;html&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Hello, world!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;</code> </pre> <br><p>  Notez que pour la derni√®re ligne, <code>String.indent()</code> lui-m√™me ins√©r√© le <code>String.indent()</code> ligne, nous n'avons donc pas eu √† ajouter <code>'\n'</code> apr√®s <code>body.indent(4)</code> . </p><br><p>  Bien s√ªr, une telle m√©thode sera plus int√©ressante en combinaison avec des <a href="https://minijug.ru/text_blocks.html" rel="nofollow">blocs de texte</a> lorsqu'ils deviendront stables, mais rien ne nous emp√™che de l'utiliser d√®s maintenant sans aucun bloc de texte. </p><br><br><h3>  8. M√©thodes de <code>Stream</code> : <code>takeWhile()</code> , <code>dropWhile()</code> , <code>iterate()</code> avec un pr√©dicat et <code>ofNullable()</code> </h3><br><h4>  Introduit dans: Java 9 </h4><br><p>  <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Stream.html" rel="nofollow">Stream.takeWhile()</a></code> est similaire √† <code>Stream.limit()</code> , mais restreint <code>Stream</code> non pas par quantit√©, mais par pr√©dicat.  Un tel besoin de programmation appara√Æt tr√®s souvent.  Par exemple, si nous devons obtenir toutes les entr√©es du journal pour l'ann√©e en cours: </p><br><pre> <code class="plaintext hljs">[ { "date" : "2020-01-27", "text" : "..." }, { "date" : "2020-01-25", "text" : "..." }, { "date" : "2020-01-22", "text" : "..." }, { "date" : "2020-01-17", "text" : "..." }, { "date" : "2020-01-11", "text" : "..." }, { "date" : "2020-01-02", "text" : "..." }, { "date" : "2019-12-30", "text" : "..." }, { "date" : "2019-12-27", "text" : "..." }, ... ]</code> </pre> <br><p>  <code>Stream</code> enregistrements est presque sans fin, donc <code>filter()</code> ne peut pas √™tre utilis√©.  Puis <code>takeWhile()</code> vient √† la <code>takeWhile()</code> : </p><br><pre> <code class="plaintext hljs">getNotesStream() .takeWhile(note -&gt; note.getDate().getYear() == 2020);</code> </pre> <br><p>  Et si nous voulons obtenir des enregistrements pour 2019, nous pouvons utiliser <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Stream.html" rel="nofollow">dropWhile()</a></code> : </p><br><pre> <code class="plaintext hljs">getNotesStream() .dropWhile(note -&gt; note.getDate().getYear() == 2020) .takeWhile(note -&gt; note.getDate().getYear() == 2019);</code> </pre> <br><p>  Dans Java 8, <code>Stream.iterate()</code> ne pouvait g√©n√©rer qu'un <code>Stream</code> infini.  Mais en Java 9, cette m√©thode a une <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Stream.html" rel="nofollow"></a></code> qui prend un pr√©dicat.  Gr√¢ce √† cela, de nombreuses boucles <code>for</code> peuvent d√©sormais √™tre remplac√©es par <code>Stream</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java 8 for (int i = 1; i &lt; 100; i *= 2) { System.out.println(i); }</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java 9+ IntStream .iterate(1, i -&gt; i &lt; 100, i -&gt; i * 2) .forEach(System.out::println);</span></span></code> </pre> <br><p>  Ces deux versions impriment tous les degr√©s d'une √©galit√© qui ne d√©passent pas <code>100</code> : </p><br><pre> <code class="plaintext hljs">1 2 4 8 16 32 64</code> </pre> <br><p>  Soit dit en passant, le dernier code pourrait √™tre r√©√©crit en utilisant <code>takeWhile()</code> : </p><br><pre> <code class="plaintext hljs">IntStream .iterate(1, i -&gt; i * 2) .takeWhile(i -&gt; i &lt; 100) .forEach(System.out::println);</code> </pre> <br><p>  Cependant, l'option avec l' <code>iterate()</code> trois arguments <code>iterate()</code> est toujours plus propre (et IntelliJ IDEA <a href="https://youtrack.jetbrains.com/issue/IDEA-214960" rel="nofollow">sugg√®re de la</a> corriger). </p><br><p>  Enfin, <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Stream.html" rel="nofollow">Stream.ofNullable()</a></code> renvoie un <code>Stream</code> avec un √©l√©ment s'il n'est pas <code>null</code> et un <code>Stream</code> vide s'il est <code>null</code> .  Cette m√©thode est parfaite dans l'exemple ci-dessus avec les t√©l√©phones d'entreprise si <code>getPhoneNumber()</code> retournera une <code>String</code> nullable au lieu de <code>Optional&lt;String&gt;</code> : </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Employee</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPhoneNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Department</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">List&lt;Employee&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEmployees</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Company</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">List&lt;Department&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDepartments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-function">Set&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAllPhoneNumbers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getDepartments() .stream() .flatMap(d -&gt; d.getEmployees().stream()) .flatMap(e -&gt; Stream.ofNullable(e.getPhoneNumber())) .collect(Collectors.toSet()); } }</code> </pre> <br><br><h3>  9. <code>Predicate.not()</code> </h3><br><h4>  Apparu dans: Java 11 </h4><br><p>  Cette m√©thode n'apporte rien de fondamentalement nouveau et est plus esth√©tique que fondamentale.  N√©anmoins, la possibilit√© de raccourcir l√©g√®rement le code est toujours tr√®s agr√©able.  En utilisant <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/function/Predicate.html" rel="nofollow">Predicate.not()</a></code> lambdas qui ont une n√©gation peuvent √™tre remplac√©s par des r√©f√©rences de m√©thode: </p><br><pre> <code class="plaintext hljs">Files.lines(path) .filter(str -&gt; !str.isEmpty()) .forEach(System.out::println);</code> </pre> <br><p>  Et maintenant en utilisant <code>not()</code> : </p><br><pre> <code class="plaintext hljs">Files.lines(path) .filter(not(String::isEmpty)) .forEach(System.out::println);</code> </pre> <br><p>  Oui, les √©conomies ne sont pas si √©normes, et si vous utilisez <code>s -&gt; !s.isEmpty()</code> , alors le nombre de caract√®res, au contraire, devient plus grand.  Mais m√™me dans ce cas, je pr√©f√®re toujours la deuxi√®me option, car elle est plus d√©clarative et n'utilise pas de variable, ce qui signifie que l'espace de noms n'est pas encombr√©. </p><br><br><h3>  10. Nettoyant </h3><br><h4>  Apparu dans: Java 9 </h4><br><p>  Je veux terminer l'histoire d'aujourd'hui avec une nouvelle API int√©ressante qui est apparue dans Java 9 et sert √† nettoyer les ressources avant qu'elles ne soient √©limin√©es par le garbage collector.  <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ref/Cleaner.html" rel="nofollow">Cleaner</a></code> est un remplacement s√ªr de la m√©thode <code>Object.finalize()</code> , elle-m√™me devenue obsol√®te dans Java 9. </p><br><p>  En utilisant <code>Cleaner</code> vous pouvez enregistrer un nettoyage de ressource qui se produira si vous avez oubli√© de le faire explicitement (par exemple, vous avez oubli√© d'appeler la m√©thode <code>close()</code> ou vous n'avez pas utilis√© <code>try-with-resources</code> ).  Voici un exemple de ressource abstraite pour laquelle une action de nettoyage est enregistr√©e dans le constructeur: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resource</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Closeable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Cleaner CLEANER = Cleaner.create(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Cleaner.Cleanable cleanable; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Resource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ cleanable = CLEANER.register(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, () -&gt; { <span class="hljs-comment"><span class="hljs-comment">//   // (,  ) }); } @Override public void close() { cleanable.clean(); } }</span></span></code> </pre> <br><p>  Dans le bon sens, les utilisateurs devraient cr√©er une telle ressource dans le bloc <code>try</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Resource()) { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  Cependant, il peut y avoir des utilisateurs qui oublient de le faire et √©crivent simplement <code>var resource = new Resource()</code> .  Dans de tels cas, le nettoyage ne sera pas effectu√© imm√©diatement, mais sera appel√© plus tard dans l'un des cycles de collecte des ordures suivants.  C‚Äôest mieux que rien. </p><br><p>  Si vous voulez mieux √©tudier <code>Cleaner</code> et d√©couvrir pourquoi vous ne devriez jamais utiliser <code>finalize()</code> , alors je vous recommande d'√©couter <a href="https://www.youtube.com/watch%3Fv%3DK5IctLPem0c" rel="nofollow">mon expos√©</a> sur ce sujet. </p><br><br><h3>  Conclusion </h3><br><p>  Java ne s'arr√™te pas et se d√©veloppe progressivement.  Pendant que vous √™tes assis sur Java 8, avec chaque version, il y a de plus en plus de nouvelles API int√©ressantes.  Aujourd'hui, nous avons examin√© 10 de ces API.  Et vous pouvez tous les utiliser si vous d√©cidez enfin de migrer de Java 8. </p><br><p>  La prochaine fois, nous examinerons 10 nouvelles API suppl√©mentaires. </p><br>  <i>Si vous ne voulez pas sauter la partie suivante, je vous recommande de vous abonner √† <a href="https://tlg.name/miniJUG" rel="nofollow">ma cha√Æne Telegram</a> , o√π je publie √©galement des nouvelles Java.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485750/">https://habr.com/ru/post/fr485750/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485738/index.html">Security Week 05: vuln√©rabilit√©s critiques des dispositifs m√©dicaux</a></li>
<li><a href="../fr485740/index.html">The Standoff at PHDays: participez √† la bataille anniversaire des hackers et des d√©fenseurs</a></li>
<li><a href="../fr485742/index.html">Comment nous avons cr√©√© le r√©pertoire d'adresses de Rostelecom</a></li>
<li><a href="../fr485744/index.html">Intelligence - la capacit√© d'un objet √† adapter son comportement √† l'environnement afin de pr√©server (survivre)</a></li>
<li><a href="../fr485748/index.html">Cha√Ænage facultatif, union avec null et comment ils modifient notre approche de l'√©criture de code</a></li>
<li><a href="../fr485758/index.html">G√©ant modulaire avec contr√¥le en ligne, ainsi que des claviers textiles et tricot√©s Joe Paradiso</a></li>
<li><a href="../fr485764/index.html">React Token Auth</a></li>
<li><a href="../fr485768/index.html">Tendances Web 2020 √† essayer</a></li>
<li><a href="../fr485770/index.html">Pol√©mique incorrecte</a></li>
<li><a href="../fr485772/index.html">Du bureau au centre de donn√©es virtuel - comment nous sommes pass√©s √† la virtualisation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>