<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆🏿 🚗 ◻️ Klasifikasi gambar tulisan tangan. Laporkan dalam Yandex 🕡 🔪 👠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa bulan yang lalu, kolega kami dari Google mengadakan kontes di Kaggle untuk membuat classifier untuk gambar yang diterima di game terkenal "Qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Klasifikasi gambar tulisan tangan. Laporkan dalam Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/440666/">  Beberapa bulan yang lalu, kolega kami dari Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengadakan</a> kontes di Kaggle untuk membuat classifier untuk gambar yang diterima di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">game</a> terkenal "Quick, Draw!".  Tim, di mana pengembang Yandex Roman Vlasov berpartisipasi, mengambil tempat keempat dalam kompetisi.  Pada sesi pelatihan mesin Januari, Roman berbagi ide timnya, implementasi akhir dari classifier, dan praktik menarik dari para pesaing. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HO8ymjF-UTw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Halo semuanya!  Nama saya Roma Vlasov, hari ini saya akan ceritakan tentang Cepat, Draw!  Tantangan Pengakuan Doodle. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/hw/xb/vc/hwxbvcwdjtsmvlzi9q9zly8khwe.jpeg"><br><br>  Ada lima orang di tim kami.  Saya bergabung dengannya tepat di depan tenggat waktu penggabungan.  Kami tidak beruntung, kami sedikit terguncang, tetapi kami dinaungi oleh uang, dan mereka dari posisi emas.  Dan kami mengambil tempat keempat terhormat. <br><br>  (Selama kompetisi, tim mengamati diri mereka di peringkat, yang dibentuk sesuai dengan hasil yang ditunjukkan pada satu bagian dari kumpulan data yang diusulkan. Peringkat akhir, pada gilirannya, dibentuk pada bagian lain dari dataset. Hal ini dilakukan agar para peserta kompetisi tidak menyesuaikan algoritma mereka dengan data tertentu. Oleh karena itu, di final, ketika beralih di antara peringkat, posisi "goyang" sedikit (dari goyang Inggris - mengocok): pada data lain dan hasilnya mungkin berbeda. Tim Roman pertama di tiga besar.  AU troika - adalah uang, peringkat uang zona, karena hanya tiga lokasi pertama mengandalkan hadiah Setelah " 'tim shake APA sudah berada di tempat keempat dengan cara yang sama tim lain kehilangan kemenangan, posisi emas -... Ed) .. <br><br><img src="https://habrastorage.org/webt/4x/zs/9d/4xzs9dipspiteybhjdudb9kdj7g.jpeg"><br><br>  Kompetisi ini juga penting karena Yevgeny Babakhnin menerima grandmaster untuknya, Ivan Sosin - master, Roman Solovyov tetap menjadi grandmaster, Alex Parinov menerima master, saya menjadi ahli, dan sekarang saya sudah menjadi master. <br><br><img src="https://habrastorage.org/webt/fy/-v/gv/fy-vgvzvgssn2kmnn3slpjajo5a.jpeg"><br><br>  Apa ini Cepat, Draw?  Ini adalah layanan dari Google.  Google bertujuan untuk mempopulerkan AI dan dengan layanan ini ingin menunjukkan cara kerja jaringan saraf.  Anda pergi ke sana, klik Ayo menggambar, dan halaman baru muncul di mana Anda diberitahu: menggambar zigzag, Anda memiliki 20 detik untuk melakukan ini.  Anda mencoba menggambar zig-zag dalam 20 detik, seperti di sini, misalnya.  Jika semuanya berhasil untuk Anda, jaringan mengatakan itu zig-zag dan Anda melanjutkan.  Hanya ada enam gambar seperti itu. <br><br>  Jika jaringan dari Google tidak dapat mengenali apa yang Anda gambar, tanda silang ditempatkan pada tugas tersebut.  Nanti saya akan memberi tahu Anda apa yang akan berarti di masa depan apakah gambar itu diakui oleh jaringan atau tidak. <br><br>  Layanan ini mengumpulkan sejumlah besar pengguna, dan semua gambar yang digambar pengguna dicatat. <br><br><img src="https://habrastorage.org/webt/ni/kl/on/niklonrxxlfht_gy0u4yzg3k5og.jpeg"><br><br>  Itu mungkin untuk mengumpulkan hampir 50 juta gambar.  Dari sini, kereta dan tanggal ujian untuk kompetisi kami dibentuk.  Omong-omong, jumlah data dalam tes dan jumlah kelas tidak sia-sia.  Saya akan membicarakannya nanti. <br><br>  Format data adalah sebagai berikut.  Ini bukan hanya gambar RGB, tetapi, secara umum, log dari semua yang dilakukan pengguna.  Word adalah target kami, kode negara adalah tempat asal orat-oret, timestamp adalah waktu.  Label yang dikenali hanya menunjukkan apakah jaringan dari Google mengenali gambar atau tidak.  Dan menggambar itu sendiri adalah suatu urutan, perkiraan dari kurva yang digambar pengguna dengan titik-titik.  Dan timing.  Ini adalah waktu dari awal menggambar gambar. <br><br><img src="https://habrastorage.org/webt/xw/_y/zw/xw_yzwjp5d8osd1ejay6gcncywu.jpeg"><br><br>  Data disajikan dalam dua format.  Ini adalah format pertama, dan yang kedua disederhanakan.  Mereka melihat penentuan waktu dari sana dan mendekati set poin ini dengan set poin yang lebih kecil.  Untuk melakukan ini, mereka menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Douglas-Pecker</a> .  Anda memiliki satu set besar poin yang hanya mendekati garis lurus, tetapi Anda sebenarnya dapat memperkirakan garis ini hanya dengan dua poin.  Ini adalah gagasan algoritma. <br><br>  Data didistribusikan sebagai berikut.  Semuanya seragam, tetapi ada beberapa outlier.  Ketika kami memecahkan masalah, kami tidak melihatnya.  Yang utama adalah bahwa tidak ada kelas yang benar-benar sedikit, kami tidak perlu melakukan sampler tertimbang dan oversampling data. <br><br><img src="https://habrastorage.org/webt/cp/_z/8y/cp_z8ydmx3m7gaptzpm9pvfglvu.jpeg"><br><br>  Seperti apa gambarnya?  Ini adalah kelas pesawat dan contoh darinya diberi label diakui dan tidak dikenali.  Rasio mereka di suatu tempat 1 hingga 9. Seperti yang Anda lihat, datanya cukup berisik.  Saya akan menyarankan bahwa ini adalah pesawat.  Jika Anda melihat tidak dikenali, dalam banyak kasus itu hanya noise.  Seseorang bahkan mencoba menulis "pesawat terbang", tetapi ternyata dalam bahasa Prancis. <br><br>  Sebagian besar peserta hanya mengambil kisi-kisi, memberikan data dari urutan garis ini sebagai gambar RGB, dan melemparkannya ke jaringan.  Saya melukis dengan cara yang sama: saya mengambil palet warna, saya melukis garis pertama dengan satu warna, yang berada di awal palet ini, yang terakhir, dengan yang lain, yang berada di ujung palet, dan di antara mereka di mana-mana diinterpolasi di palet ini.  Omong-omong, ini memberikan hasil yang lebih baik daripada jika Anda menggambar seperti pada slide pertama - hanya hitam. <br><br>  Anggota tim lainnya, seperti Ivan Sosin, mencoba pendekatan menggambar yang sedikit berbeda.  Dengan satu saluran, ia hanya menggambar gambar abu-abu, dengan saluran lain, ia menggambar setiap stroke dengan gradien dari awal hingga akhir, dari 32 hingga 255, dan saluran ketiga menggambar gradien dalam semua stroke dari 32 hingga 255. <br><br>  Hal lain yang menarik adalah bahwa Alex Parinov melemparkan informasi ke jaringan melalui kode negara. <br><br><img src="https://habrastorage.org/webt/wm/z0/iw/wmz0iw6jp4sxzqm2z3zqtafkhbo.jpeg"><br><br>  Metrik yang digunakan dalam kompetisi adalah Mean Average Precision.  Apa inti dari metrik ini untuk kompetisi?  Anda dapat memberikan tiga prediktor, dan jika ketiga prediktor ini tidak benar, maka Anda mendapatkan 0. Jika ada yang benar, maka urutannya diperhitungkan.  Dan hasil untuk target akan dianggap sebagai 1, dibagi dengan urutan prediksi Anda.  Misalnya, Anda membuat tiga prediksi, dan yang pertama adalah yang benar, maka Anda membagi 1 dengan 1 dan mendapatkan 1. Jika prediktor itu benar dan urutannya 2, maka 1 dibagi dengan 2, Anda mendapatkan 0,5.  Baik, dll <br><br><img src="https://habrastorage.org/webt/ar/fm/7k/arfm7knnnynq6iekr-ykcnxvdr8.jpeg"><br><br>  Dengan preprocessing data - cara menggambar dan sebagainya - kami memutuskan sedikit.  Arsitektur apa yang kami gunakan?  Kami mencoba menggunakan arsitektur yang berani seperti PNASNet, SENet, dan sudah arsitektur klasik seperti SE-Res-NeXt, mereka semakin memasuki kompetisi baru.  Ada juga ResNet dan DenseNet. <br><br><img src="https://habrastorage.org/webt/rr/4p/ku/rr4pkuestkfvwxz4l-7absymotq.jpeg"><br><br><img src="https://habrastorage.org/webt/yz/4z/9_/yz4z9_fybssrwzh3recxexbrkbg.jpeg"><br><br><img src="https://habrastorage.org/webt/hw/eg/p9/hwegp98dpudcisrhvfbqx-92648.jpeg"><br><br>  Bagaimana kami mengajarkan ini?  Semua model yang kami ambil, kami ambil sendiri pra-dilatih di imagenet.  Meskipun ada banyak data, 50 juta gambar, tetapi tetap saja, jika Anda mengambil jaringan yang sudah terlatih pada imagenet, itu menunjukkan hasil yang lebih baik daripada jika Anda hanya melatihnya dari awal. <br><br>  Teknik pelatihan apa yang kami gunakan?  Ini adalah Cosing Annealing dengan Warm Restarts, saya akan membicarakannya nanti.  Ini adalah teknik yang saya gunakan di hampir semua kompetisi terakhir saya, dan dengan mereka ternyata cukup baik untuk melatih jaring, untuk mencapai minimum yang baik. <br><br><img src="https://habrastorage.org/webt/9v/ch/ht/9vchht1fyo2sahp7bbxv7nnks3a.jpeg"><br><br>  Selanjutnya Kurangi Tingkat Belajar di Dataran Tinggi.  Anda mulai melatih jaringan, menetapkan tingkat pembelajaran tertentu, lalu mempelajarinya, kemudian kerugian Anda secara bertahap menyatu ke beberapa nilai tertentu.  Anda memeriksa ini, misalnya, lebih dari sepuluh era, kerugian belum berubah.  Anda mengurangi tingkat belajar Anda dengan beberapa nilai dan terus belajar.  Sekali lagi turun sedikit, konvergen pada minimum tertentu, dan lagi Anda menurunkan tingkat belajar, dan sebagainya, sampai jaringan Anda akhirnya konvergen. <br><br>  Teknik menarik lebih lanjut: Jangan membusuk tingkat belajar, menambah ukuran batch.  Ada artikel dengan nama yang sama.  Saat Anda melatih jaringan, Anda tidak perlu mengurangi tingkat pembelajaran, Anda bisa menambah ukuran bets. <br><br>  Teknik ini, omong-omong, digunakan oleh Alex Parinov.  Dia mulai dengan batch yang sama dengan 408, dan ketika jaringan datang ke dataran tinggi, dia hanya menggandakan ukuran batch, dll. <br><br>  Sebenarnya, saya tidak ingat berapa nilai ukuran bets yang dicapai, tetapi yang menarik, ada tim di Kaggle yang menggunakan teknik yang sama, ukuran bets mereka sekitar 10.000. Omong-omong, kerangka kerja modern untuk pembelajaran mendalam, seperti PyTorch, misalnya, memungkinkan Anda melakukan ini dengan sangat sederhana.  Anda menghasilkan batch Anda dan mengirimkannya ke jaringan tidak seperti itu, secara keseluruhan, tetapi membaginya menjadi potongan-potongan sehingga sesuai dengan kartu video Anda, menghitung gradien, dan setelah menghitung gradien untuk seluruh batch, Anda memperbarui skala. <br><br>  Omong-omong, ukuran bets besar masih masuk dalam kompetisi ini, karena datanya cukup berisik, dan ukuran bets besar membantu Anda untuk lebih akurat memperkirakan gradien. <br><br>  Pseudo-dabbing juga digunakan, sebagian besar digunakan oleh Roman Soloviev.  Dia mengambil sampel di suatu tempat di setengah data dari tes, dan pada batch tersebut dia melatih grid. <br><br>  Ukuran gambar berperan, tetapi faktanya Anda memiliki banyak data, Anda perlu berlatih untuk waktu yang lama, dan jika ukuran gambar Anda cukup besar, maka Anda akan berlatih untuk waktu yang sangat lama.  Tapi ini tidak membawa terlalu banyak ke dalam kualitas classifier akhir Anda, jadi itu layak menggunakan trade-off.  Dan mereka mencoba hanya gambar-gambar yang ukurannya tidak terlalu besar. <br><br>  Bagaimana semuanya belajar?  Pada awalnya, foto-foto ukuran kecil diambil, beberapa era dijalankan, mereka dengan cepat butuh waktu.  Kemudian gambar besar diberikan, jaringan belajar, lalu bahkan lebih, bahkan lebih untuk tidak melatihnya dari awal dan tidak menghabiskan banyak waktu. <br><br>  Tentang pengoptimal.  Kami menggunakan SGD dan Adam.  Dengan cara ini, dimungkinkan untuk mendapatkan model tunggal, yang memberikan kecepatan 0,941-0,956 pada papan peringkat publik, yang cukup bagus. <br><br>  Jika Anda memasang model dengan beberapa cara, maka Anda mendapatkan suatu tempat 0,951.  Jika Anda menerapkan teknik lain, maka Anda akan mendapatkan kecepatan terakhir di papan publik 0,954, seperti yang kami terima.  Tetapi lebih lanjut tentang itu nanti.  Selanjutnya, saya akan memberi tahu Anda bagaimana kami merakit model, dan bagaimana kecepatan akhir seperti itu dicapai. <br><br>  Selanjutnya saya ingin berbicara tentang Cosing Annealing dengan Warm Restarts atau Stochastic Gradient Descent dengan Warm Restart.  Secara kasar, pada prinsipnya, Anda dapat tetap menggunakan optimizer, tetapi intinya adalah ini: jika Anda hanya melatih satu jaringan dan secara bertahap konvergen ke minimum, maka semuanya baik-baik saja, Anda akan mendapatkan satu jaringan, ia membuat kesalahan tertentu, tetapi Anda bisa mengajarinya sedikit berbeda.  Anda akan menetapkan beberapa tingkat pembelajaran awal, dan secara bertahap menurunkannya sesuai dengan rumus ini.  Anda meremehkannya, jaringan Anda mencapai batas minimum tertentu, kemudian Anda menghemat bobot, dan sekali lagi menetapkan tingkat pembelajaran, yang pada awal pelatihan, dengan demikian dari minimum ini naik ke suatu tempat, dan sekali lagi meremehkan tingkat pembelajaran Anda. <br><br>  Dengan demikian, Anda dapat mengunjungi beberapa posisi terendah sekaligus, di mana Anda akan mengalami kerugian plus atau minus yang sama.  Tetapi kenyataannya adalah bahwa jaringan dengan bobot ini akan memberikan kesalahan berbeda pada kencan Anda.  Dengan rata-rata, Anda akan mendapatkan perkiraan tertentu, dan kecepatan Anda akan lebih tinggi. <br><br><img src="https://habrastorage.org/webt/ra/5d/mz/ra5dmzx9mcelguiqckvaihllrkc.jpeg"><br><br>  Tentang bagaimana kami merakit model kami.  Di awal presentasi, saya berkata untuk memperhatikan jumlah data dalam tes dan jumlah kelas.  Jika Anda menambahkan 1 ke jumlah target dalam set tes dan membaginya dengan jumlah kelas, Anda mendapatkan nomor 330, dan ada tertulis tentang ini di forum - bahwa kelas-kelas dalam tes seimbang.  Ini bisa digunakan. <br><br>  Berdasarkan ini, Roman Solovyov menemukan metrik, kami menyebutnya Skor Proksi, yang berkorelasi cukup baik dengan leaderboard.  Intinya adalah: Anda membuat prediksi, mengambil top-1 dari prediksi Anda dan menghitung jumlah objek untuk setiap kelas.  Kurangi 330 dari setiap nilai dan tambahkan nilai absolut yang dihasilkan. <br><br>  Nilai-nilai seperti itu ternyata.  Ini membantu kami untuk tidak melakukan leaderboard pengujian, tetapi untuk memvalidasi secara lokal dan memilih koefisien untuk ansambel kami. <br><br>  Dengan ansambel Anda bisa mendapatkan kecepatan seperti itu.  Apa lagi yang harus dilakukan?  Misalkan Anda menggunakan informasi bahwa kelas dalam tes Anda seimbang. <br><br>  Perimbangannya berbeda.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh salah satunya</a> adalah penyeimbang dari orang-orang yang memenangkan tempat pertama. <br><br>  Apa yang kita lakukan  Penyeimbangan kami cukup sederhana, diusulkan oleh Evgeny Babakhnin.  Kami pertama-tama menyortir prediksi kami berdasarkan 1 teratas dan kandidat terpilih dari mereka - sehingga jumlah kelas tidak melebihi 330. Namun untuk beberapa kelas, ternyata ada yang kurang memprediksi dari 330. Oke, mari kita urutkan berdasarkan atas-2 dan 3 teratas, dan juga memilih kandidat. <br><br>  Apa perbedaan antara balancing kami dengan balancing?  Mereka menggunakan pendekatan berulang, mengambil kelas yang paling populer dan mengurangi kemungkinan untuk kelas ini dengan sejumlah kecil - sampai kelas ini menjadi bukan yang paling populer.  Mereka mengambil kelas paling populer berikutnya.  Jadi lebih jauh dan diturunkan sampai jumlah semua kelas menjadi sama. <br><br>  Semua orang menggunakan pendekatan plus atau minus untuk melatih jaringan, tetapi tidak semua orang menggunakan penyeimbangan.  Menggunakan balancing, Anda bisa menjadi emas, dan jika Anda beruntung, maka dalam mani. <br><br>  Bagaimana cara preprocess kencan?  Semua orang melakukan pra-pemrosesan tanggal plus-minus dengan cara yang sama - melakukan fitur buatan tangan, mencoba menyandikan pewaktuan dengan goresan warna yang berbeda, dll. Ini persis seperti yang dikatakan Alexey Nozdrin-Plotnitsky, yang mengambil posisi ke-8. <br><br><img src="https://habrastorage.org/webt/lq/jg/yb/lqjgybopsgcacrtnubcet3jub9e.jpeg"><br><br>  Dia melakukannya secara berbeda.  Dia mengatakan bahwa semua fitur buatan tangan ini tidak berfungsi, Anda tidak perlu melakukan ini, jaringan Anda harus mempelajari semua ini sendiri.  Dan sebagai gantinya, dia datang dengan modul pembelajaran yang melakukan preprocessing data Anda.  Dia melemparkan data sumber tanpa preprocessing - koordinat poin dan timing. <br><br>  Selanjutnya, ia mengambil perbedaan dalam koordinat, dan rata-rata selama waktu.  Dan dia punya matriks yang agak panjang.  Dia menggunakan konvolusi 1D beberapa kali untuk mendapatkan matriks 64xn, di mana n adalah jumlah total poin, dan 64 dibuat untuk memberi makan matriks yang dihasilkan ke lapisan beberapa jaringan konvolusional yang menerima 64 saluran. ternyata menjadi matriks 64xn, maka dari ini perlu untuk menyusun tensor beberapa ukuran sehingga jumlah saluran adalah 64. Dia menormalkan semua titik X, Y dalam kisaran 0 hingga 32 untuk membuat tensor ukuran 32x32.  Saya tidak tahu mengapa dia menginginkan 32x32, itu terjadi.  Dan dalam koordinat ini ia meletakkan fragmen dari matriks ukuran 64xn ini.  Dengan demikian, ia hanya menerima tensor 32x32x64, yang dapat dimasukkan lebih jauh ke dalam jaringan saraf convolutional Anda.  Saya memiliki segalanya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440666/">https://habr.com/ru/post/id440666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440654/index.html">Belajar Python: modul argparse</a></li>
<li><a href="../id440656/index.html">Kontainer profesional aplikasi Node.js menggunakan Docker</a></li>
<li><a href="../id440658/index.html">Menjelajahi Docker, Bagian 4: Mengurangi Ukuran Gambar dan Mempercepat Perakitan Mereka</a></li>
<li><a href="../id440660/index.html">Learning Docker, Bagian 5: Perintah</a></li>
<li><a href="../id440662/index.html">Bereaksi Tutorial Bagian 18: Fase Keenam Bekerja pada Aplikasi TODO</a></li>
<li><a href="../id440670/index.html">Bank Sentral menerbitkan rekomendasi tentang perlindungan kriptografi EBS</a></li>
<li><a href="../id440672/index.html">Metode Rasionalitas dan Matras Doa Maghreb</a></li>
<li><a href="../id440674/index.html">Menggunakan grafik sebar untuk memvisualisasikan data</a></li>
<li><a href="../id440676/index.html">Hari ketika Dodo berhenti. Script sinkron</a></li>
<li><a href="../id440678/index.html">Hobi DIY CNC router. Humaniora untuk humaniora. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>