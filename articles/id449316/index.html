<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§ ğŸ‘ï¸ ğŸ‘š Mencuri: yang mencuri waktu prosesor dari mesin virtual ğŸ‘‰ğŸ» ğŸ‘­ ğŸ°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Saya ingin memberi tahu dalam bahasa sederhana tentang mekanisme kemunculan mencuri di dalam mesin virtual dan tentang beberapa artefak yang tidak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mencuri: yang mencuri waktu prosesor dari mesin virtual</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/449316/"><img src="https://habrastorage.org/getpro/habr/post_images/af7/c70/8aa/af7c708aa619490409ed5cf46d9c96fa.jpg"><br><br>  Hai  Saya ingin memberi tahu dalam bahasa sederhana tentang mekanisme kemunculan mencuri di dalam mesin virtual dan tentang beberapa artefak yang tidak diketahui yang dapat kami temukan selama penelitiannya, di mana saya harus menyelam sebagai penasihat teknis platform cloud <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mail.ru Cloud Solutions</a> .  Platform berjalan pada KVM. <br><br>  Waktu mencuri CPU adalah waktu di mana mesin virtual tidak menerima sumber daya prosesor untuk pelaksanaannya.  Waktu ini dianggap hanya dalam sistem operasi tamu di lingkungan virtualisasi.  Alasan kemana sumber daya yang sangat dialokasikan ini pergi, seperti dalam kehidupan, sangat kabur.  Tapi kami memutuskan untuk mencari tahu, bahkan membuat serangkaian percobaan.  Bukannya kita sekarang tahu segalanya tentang mencuri, tetapi kami akan memberi tahu Anda sesuatu yang menarik saat ini. <br><a name="habracut"></a><br><h2>  1. Apa itu mencuri? </h2><br>  Jadi, mencuri adalah metrik yang menunjukkan kurangnya waktu prosesor untuk proses di dalam mesin virtual.  Seperti yang dijelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam patch kernel KVM</a> , mencuri adalah waktu di mana hypervisor mengeksekusi proses lain pada OS host, meskipun itu telah mengantri proses mesin virtual untuk dieksekusi.  Artinya, mencuri dianggap sebagai perbedaan antara waktu ketika proses siap untuk dieksekusi dan waktu ketika prosesor dialokasikan waktu proses. <br><br>  Kernel kernel menerima metrik mencuri dari hypervisor.  Pada saat yang sama, hypervisor tidak menentukan dengan tepat proses apa yang dijalankannya, hanya "ketika saya sibuk, saya tidak bisa memberi Anda waktu."  Di KVM, mencuri dukungan penghitungan telah ditambahkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tambalan</a> .  Ada dua poin utama di sini: <br><br><ul><li>  Mesin virtual belajar tentang mencuri dari hypervisor.  Yaitu, dari sudut pandang kerugian, untuk proses pada mesin virtual itu sendiri itu adalah pengukuran tidak langsung yang dapat dikenakan berbagai distorsi. <br></li><li> Hypervisor tidak berbagi informasi dengan mesin virtual tentang apa yang dia lakukan dengan orang lain - hal utama adalah dia tidak menyediakan waktu untuk itu.  Karena itu, mesin virtual itu sendiri tidak dapat mendeteksi distorsi dalam indeks mencuri, yang dapat diperkirakan oleh sifat proses yang bersaing. <br></li></ul><br><h2>  2. Apa yang mempengaruhi mencuri </h2><br><h3>  2.1.  Mencuri perhitungan </h3><br>  Bahkan, mencuri dianggap kurang lebih sama dengan waktu pemanfaatan CPU normal.  Tidak ada banyak informasi tentang bagaimana pembuangan dipertimbangkan.  Mungkin karena mayoritas menganggap pertanyaan ini jelas.  Tapi ada juga jebakan di sini.  Untuk berkenalan dengan proses ini, Anda dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel oleh Brendann Gregg</a> : Anda akan belajar tentang banyak nuansa dalam perhitungan pemanfaatan dan tentang situasi ketika perhitungan ini akan keliru karena alasan berikut: <br><br><ul><li>  Prosesor terlalu panas, selama siklus clock dilewati. <br></li><li>  Nyalakan / matikan turbo boost, sebagai akibatnya frekuensi clock prosesor berubah. <br></li><li>  Perubahan durasi kuantum waktu yang terjadi saat menggunakan teknologi hemat energi prosesor, seperti SpeedStep. <br></li><li>  Masalah penghitungan rata-rata: estimasi pemanfaatan dalam satu menit pada 80% dapat menyembunyikan ledakan jangka pendek dalam 100%. <br></li><li>  Cyclic lock (spin lock) mengarah pada fakta bahwa prosesor dibuang, tetapi proses pengguna tidak melihat kemajuan dalam pelaksanaannya.  Akibatnya, perkiraan pemanfaatan prosesor oleh proses akan seratus persen, meskipun proses tidak akan menghabiskan waktu prosesor secara fisik. <br></li></ul><br>  Saya tidak menemukan artikel yang menggambarkan perhitungan yang sama untuk mencuri (jika Anda tahu, bagikan dalam komentar).  Tetapi, dilihat dari sumbernya, mekanisme perhitungannya sama dengan pembuangan.  Hanya saja penghitung lain ditambahkan ke kernel, langsung untuk proses KVM (proses mesin virtual), yang menghitung lamanya waktu proses KVM dalam keadaan siaga waktu prosesor.  Penghitung mengambil informasi tentang prosesor dari spesifikasinya dan mencari tahu apakah semua kutu telah digunakan oleh proses virtual.  Jika itu saja, maka kami percaya bahwa prosesor hanya terlibat dalam proses mesin virtual.  Kalau tidak, kami informasikan bahwa prosesor sedang melakukan sesuatu yang lain, mencuri muncul. <br><br>  Proses mencuri mencuri memiliki masalah yang sama seperti menghitung daur ulang biasa.  Bukan untuk mengatakan bahwa masalah seperti itu sering muncul, tetapi mereka terlihat mengecewakan. <br><br><h3>  2.2.  Jenis Virtualisasi pada KVM </h3><br>  Secara umum, ada tiga jenis virtualisasi, dan semuanya didukung oleh KVM.  Jenis virtualisasi dapat menentukan mekanisme mencuri. <br><br>  <b>Siaran</b>  Dalam hal ini, pengoperasian sistem operasi mesin virtual dengan perangkat fisik hypervisor terjadi kira-kira seperti ini: <br><br><ol><li>  Sistem operasi tamu mengirimkan perintah ke perangkat tamunya. <br></li><li>  Driver perangkat tamu menerima perintah, menghasilkan permintaan untuk BIOS perangkat, dan mengirimkannya ke hypervisor. <br></li><li>  Proses hypervisor menerjemahkan perintah menjadi perintah untuk perangkat fisik, membuatnya, antara lain, lebih aman. <br></li><li>  Driver perangkat fisik menerima perintah yang dimodifikasi dan mengirimkannya ke perangkat fisik itu sendiri. <br></li><li>  Hasil eksekusi perintah kembali di jalur yang sama. <br></li></ol><br>  Keuntungan terjemahannya adalah memungkinkan Anda untuk meniru perangkat apa pun dan tidak memerlukan persiapan khusus dari kernel sistem operasi.  Tetapi Anda harus membayar untuk itu, pertama-tama, dengan kecepatan. <br><br>  <b>Virtualisasi perangkat keras</b> .  Dalam hal ini, perangkat di tingkat perangkat keras memahami perintah dari sistem operasi.  Ini adalah cara tercepat dan terbaik.  Tetapi, sayangnya, itu tidak didukung oleh semua perangkat fisik, hypervisor, dan OS tamu.  Saat ini, perangkat utama yang mendukung virtualisasi perangkat keras adalah prosesor. <br><br>  <b>Paravirtualization (paravirtualization)</b> .  Versi paling umum dari virtualisasi perangkat pada KVM dan umumnya mode virtualisasi yang paling umum untuk sistem operasi tamu.  Kekhasannya adalah bahwa bekerja dengan beberapa subsistem hypervisor (misalnya, dengan jaringan atau tumpukan disk) atau alokasi halaman memori terjadi menggunakan API hypervisor, tanpa menerjemahkan perintah tingkat rendah.  Kerugian dari metode virtualisasi ini adalah kebutuhan untuk memodifikasi kernel dari sistem operasi guest sehingga dapat berinteraksi dengan hypervisor menggunakan API ini.  Tetapi biasanya ini diselesaikan dengan menginstal driver khusus pada sistem operasi tamu.  Di KVM, API ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">virtio API</a> . <br><br>  Dengan paravirtualization, dibandingkan dengan terjemahan, jalur ke perangkat fisik berkurang secara signifikan dengan mengirimkan perintah langsung dari mesin virtual ke proses hypervisor host.  Ini memungkinkan Anda untuk mempercepat pelaksanaan semua instruksi di dalam mesin virtual.  Di KVM, virtio API bertanggung jawab untuk ini, yang hanya berfungsi untuk perangkat tertentu, seperti adaptor jaringan atau disk.  Itulah sebabnya driver virtio ditempatkan di dalam mesin virtual. <br><br>  Sisi lain dari akselerasi ini adalah bahwa tidak semua proses yang berjalan di dalam mesin virtual tetap berada di dalamnya.  Ini menciptakan beberapa efek khusus yang dapat menyebabkan mencuri muncul.  Saya sarankan memulai studi rinci tentang masalah ini dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API untuk virtual I / O: virtio</a> . <br><br><h3>  2.3.  Penjadwalan yang Adil </h3><br>  Virtualisasi pada hypervisor sebenarnya adalah proses biasa yang mematuhi hukum penjadwalan (alokasi sumber daya antar proses) di kernel Linux, jadi kami akan mempertimbangkannya secara lebih rinci. <br><br>  Linux menggunakan CFS, Completely Fair Scheduler, yang telah menjadi dispatcher default sejak kernel 2.6.23.  Untuk memahami algoritma ini, Anda dapat membaca Arsitektur Kernel Linux atau sumber.  Inti dari CFS adalah distribusi waktu prosesor antar proses tergantung pada durasi eksekusi mereka.  Semakin banyak waktu prosesor yang dibutuhkan, semakin sedikit waktu yang diterimanya.  Ini menjamin eksekusi "jujur" semua proses - sehingga satu proses tidak terus-menerus menempati semua prosesor, dan proses lainnya juga dapat dieksekusi. <br><br>  Terkadang paradigma ini mengarah pada artefak yang menarik.  Pengguna Linux yang sudah lama mungkin akan mengingat memudar dari editor teks desktop biasa saat menjalankan aplikasi seperti compiler.  Ini terjadi karena tugas-tugas aplikasi desktop yang tidak memerlukan banyak sumber daya bersaing dengan tugas-tugas yang secara aktif mengonsumsi sumber daya, seperti penyusun.  CFS menganggap ini tidak jujur, sehingga secara berkala menghentikan editor teks dan memungkinkan prosesor untuk memproses tugas-tugas kompiler.  Ini diperbaiki menggunakan mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sched_autogroup</a> , tetapi banyak fitur lain dari distribusi waktu CPU antara tugas tetap.  Sebenarnya, cerita ini bukan tentang seberapa buruk hal-hal yang ada dalam CFS, tetapi upaya untuk menarik perhatian pada kenyataan bahwa distribusi waktu prosesor yang â€œjujurâ€ bukanlah tugas yang paling sepele. <br><br>  Poin penting lainnya dalam sheduler adalah preemption.  Ini diperlukan untuk mendorong proses kekek dari prosesor dan membiarkan orang lain bekerja.  Proses pengasingan disebut pengalihan konteks, pengalihan konteks prosesor.  Dalam hal ini, seluruh konteks tugas disimpan: keadaan tumpukan, register, dll., Setelah itu proses menunggu, dan yang lainnya mengambil tempatnya.  Ini adalah operasi yang mahal untuk OS, dan jarang digunakan, tetapi pada kenyataannya tidak ada yang salah dengan itu.  Pergantian konteks yang sering dapat mengindikasikan masalah pada OS, tetapi biasanya ini berlangsung terus menerus dan tidak menunjukkan apa-apa secara khusus. <br><br>  Cerita yang begitu panjang diperlukan untuk menjelaskan satu fakta: semakin banyak sumber daya prosesor yang coba dikonsumsi oleh sheduler Linux yang jujur, semakin cepat akan dihentikan sehingga proses lain dapat bekerja juga.  Apakah ini benar atau tidak adalah masalah yang kompleks, yang diselesaikan secara berbeda di bawah beban yang berbeda.  Di Windows, hingga saat ini, sheduler difokuskan pada pemrosesan prioritas aplikasi desktop, karena proses latar belakang mana yang bisa hang.  Sun Solaris memiliki lima kelas sheduler yang berbeda.  Ketika mereka memulai virtualisasi, mereka menambahkan keenam, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penjadwal berbagi yang Adil</a> , karena lima sebelumnya bekerja dengan virtualisasi Solaris Zones tidak memadai.  Saya merekomendasikan memulai studi terperinci tentang masalah ini dengan buku-buku seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solaris Internal: Solaris 10 dan OpenSolaris Kernel Architecture</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami Kernel Linux</a> . <br><br><h3>  2.4.  Bagaimana cara memonitor mencuri? </h3><br>  Memantau mencuri di dalam mesin virtual, seperti metrik prosesor lainnya, sederhana: Anda dapat menggunakan segala cara untuk menghapus metrik prosesor.  Yang utama adalah bahwa mesin virtual ada di Linux.  Untuk beberapa alasan, Windows tidak memberikan informasi tersebut kepada penggunanya.  :( <br><br><img src="https://habrastorage.org/getpro/habr/post_images/804/731/75c/80473175cd23f0ba8721ca61c65fe111.png"><br>  <i>Output dari perintah teratas: detail beban prosesor, di kolom paling kanan - mencuri</i> <br><br>  Kesulitan muncul ketika mencoba untuk mendapatkan informasi ini dari hypervisor.  Anda dapat mencoba memprediksi mencuri pada mesin host, misalnya, dengan parameter Load Average (LA) - nilai rata-rata jumlah proses yang menunggu dalam antrian untuk dieksekusi.  Metodologi untuk menghitung parameter ini tidak sederhana, tetapi secara umum, jika LA, dinormalisasi dengan jumlah utas prosesor, lebih besar dari 1, ini menunjukkan bahwa server Linux agak kelebihan beban. <br><br>  Apa semua proses ini menunggu?  Jawaban yang jelas adalah prosesor.  Tetapi jawabannya tidak sepenuhnya benar, karena kadang-kadang prosesor gratis, dan LA berguling.  Ingat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagaimana NFS jatuh dan bagaimana LA tumbuh</a> .  Bisa kira-kira sama dengan disk, dan dengan perangkat input / output lainnya.  Namun pada kenyataannya, proses dapat mengharapkan akhir dari setiap kunci, baik fisik, yang terkait dengan perangkat I / O, dan logis, seperti mutex.  Ini juga termasuk kunci di tingkat perangkat keras (jawaban yang sama dari disk), atau logika (yang disebut penguncian primitif, yang mencakup banyak entitas, mutex adaptif dan spin, semaphore, variabel kondisi, kunci rw, kunci ipc ...). <br><br>  Fitur lain dari LA adalah dianggap sebagai nilai rata-rata untuk sistem operasi.  Misalnya, 100 proses bersaing untuk satu file, dan kemudian LA = 50.  Nilai yang sedemikian besar, tampaknya, menunjukkan bahwa OS itu buruk.  Tetapi untuk kode lain yang ditulis miring, ini bisa menjadi keadaan normal, meskipun faktanya itu buruk hanya untuknya, dan proses lain dalam sistem operasi tidak menderita. <br><br>  Karena rata-rata ini (dan tidak kurang dari satu menit), menentukan sesuatu dengan indikator LA bukanlah tugas yang paling berterima kasih, dengan hasil yang sangat tidak pasti dalam kasus-kasus tertentu.  Jika Anda mencoba untuk mengetahuinya, Anda akan menemukan bahwa hanya kasus yang paling sederhana yang dijelaskan dalam artikel Wikipedia dan sumber daya lain yang tersedia, tanpa penjelasan mendalam tentang prosesnya.  Saya mengirim semua yang tertarik, sekali lagi, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini, ke Brendann Gregg</a> - lebih jauh di tautan.  Kepada siapa kemalasan dalam bahasa Inggris adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan dari artikel populernya tentang LA</a> . <br><br><h2>  3. Efek khusus </h2><br>  Sekarang mari kita memikirkan kasus-kasus utama pencurian yang kita temui.  Saya akan memberi tahu Anda bagaimana mereka mengikuti dari sebelumnya dan bagaimana mereka berhubungan dengan indikator pada hypervisor. <br><br>  <b>Daur ulang</b> .  Yang paling sederhana dan paling sering: hypervisor digunakan kembali.  Memang, ada banyak menjalankan mesin virtual, konsumsi prosesor besar di dalamnya, banyak kompetisi, pemanfaatan LA lebih dari 1 (dinormalkan oleh utas prosesor).  Di dalam semua virtualoks semuanya melambat.  Mencuri yang ditransmisikan dari hypervisor juga berkembang, perlu untuk mendistribusikan kembali beban atau mematikan seseorang.  Secara umum, semuanya logis dan dapat dimengerti. <br><br>  <b>Paravirtualization versus instance tunggal</b> .  Ada satu mesin virtual tunggal di hypervisor, ia mengkonsumsi sebagian kecil dari itu, tetapi memberikan beban besar pada input / output, misalnya, pada disk.  Dan dari suatu tempat di dalamnya mencuri kecil muncul, hingga 10% (seperti yang ditunjukkan oleh beberapa percobaan). <br><br>  Kasingnya menarik.  Mencuri muncul di sini hanya karena kunci di tingkat driver paravirtualized.  Interupsi dibuat di dalam mesin virtual, diproses oleh driver, dan pergi ke hypervisor.  Karena pemrosesan terputus pada hypervisor untuk mesin virtual, sepertinya permintaan terkirim, siap untuk dieksekusi dan menunggu prosesor, tetapi mereka tidak memberikan waktu prosesor.  Virtualka berpikir bahwa kali ini dicuri. <br><br>  Ini terjadi ketika buffer dikirim, ia pergi ke ruang kernel dari hypervisor, dan kami mulai menunggunya.  Meskipun, dari sudut pandang virtualka, ia harus segera kembali.  Karena itu, menurut algoritma perhitungan mencuri, kali ini dianggap dicuri.  Kemungkinan besar, dalam situasi ini mungkin ada mekanisme lain (misalnya, memproses beberapa panggilan sistem lainnya), tetapi mereka seharusnya tidak jauh berbeda. <br><br>  <b>Sheduler terhadap virtualoks yang sarat muatan</b> .  Ketika satu mesin virtual menderita mencuri lebih dari yang lain, itu terhubung tepat dengan sheduler.  Semakin kuat proses memuat prosesor, semakin cepat sheduler akan mengeluarkannya, sehingga yang lain juga bisa bekerja.  Jika mesin virtual menghabiskan sedikit, dia hampir tidak melihat mencuri: prosesnya jujur â€‹â€‹duduk dan menunggu, perlu memberinya lebih banyak waktu.  Jika mesin virtual menghasilkan beban maksimum pada semua inti, sering dikeluarkan dari prosesor dan mencoba untuk tidak memberikan banyak waktu. <br><br>  Lebih buruk lagi, ketika proses di dalam mesin virtual mencoba untuk mendapatkan lebih banyak prosesor, karena mereka tidak dapat mengatasi pemrosesan data.  Kemudian sistem operasi pada hypervisor, karena optimasi yang jujur, akan memberikan waktu prosesor lebih sedikit.  Proses ini berlangsung seperti longsoran salju, dan mencuri melompat ke surga, meskipun mesin virtual lain mungkin hampir tidak menyadarinya.  Dan semakin banyak inti, semakin buruk mesin jatuh di bawah distribusi.  Singkatnya, mesin virtual yang sarat muatan dengan banyak core paling menderita. <br><br>  <b>Rendah LA, tapi ada mencuri</b> .  Jika LA sekitar 0,7 (yaitu, hypervisor tampaknya kekurangan beban), tetapi mencuri diamati di dalam masing-masing mesin virtual: <br><br><ul><li>  Opsi yang dijelaskan di atas dengan paravirtualization.  Mesin virtual dapat menerima metrik yang mengarah untuk mencuri, meskipun semuanya baik-baik saja dengan hypervisor.  Menurut hasil percobaan kami, opsi mencuri seperti itu tidak melebihi 10% dan seharusnya tidak memiliki dampak signifikan pada kinerja aplikasi di dalam mesin virtual. <br></li><li>  Parameter LA dianggap salah.  Lebih tepatnya, pada setiap momen tertentu itu dianggap benar, tetapi ketika dirata-rata selama satu menit, ternyata diremehkan.  Misalnya, jika satu mesin virtual mengkonsumsi semua prosesornya tepat setengah menit per sepertiga dari hypervisor, maka LA per menit akan menjadi 0,15 pada hypervisor;  empat mesin virtual yang bekerja secara bersamaan akan memberikan 0,6.  Dan fakta bahwa selama setengah menit pada masing-masing dari mereka ada mencuri liar di 25% di LA, tidak bisa lagi ditarik. <br></li><li>  Sekali lagi, karena sheduler yang memutuskan bahwa seseorang makan terlalu banyak, dan biarkan yang ini menunggu.  Sementara itu, saya beralih konteks, memproses interupsi dan melakukan hal-hal penting sistem lainnya.  Akibatnya, beberapa mesin virtual tidak melihat masalah, sementara yang lain mengalami penurunan kinerja yang serius. <br></li></ul><br><h2>  4. Distorsi lainnya </h2><br>  Ada jutaan alasan lain untuk mendistorsi kembalinya waktu prosesor pada mesin virtual.  Sebagai contoh, hypertreading dan NUMA menambah kompleksitas pada perhitungan.  Mereka benar-benar mengacaukan pilihan kernel untuk menjalankan proses, karena sheduler menggunakan koefisien - bobot, yang ketika berpindah konteks membuat perhitungan semakin sulit. <br><br>  Ada distorsi karena teknologi seperti turbo boost atau, sebaliknya, mode hemat energi, yang ketika menghitung pemanfaatan dapat secara artifisial meningkatkan atau mengurangi frekuensi atau bahkan irisan waktu pada server.  Menghidupkan turbo boost mengurangi kinerja satu thread prosesor karena peningkatan kinerja yang lain.  Pada saat ini, informasi tentang frekuensi prosesor saat ini tidak ditransmisikan ke mesin virtual, dan ia percaya bahwa seseorang sedang mengikat waktunya (misalnya, ia meminta 2 GHz, tetapi menerima setengahnya). <br><br>  Secara umum, bisa ada banyak penyebab distorsi.  Dalam sistem tertentu, Anda mungkin menemukan sesuatu yang lain.  Lebih baik memulai dengan buku-buku yang saya berikan tautannya di atas, dan mengambil statistik dari hypervisor dengan utilitas seperti perf, sysdig, systemtap, di mana ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lusinan</a> . <br><br><h2>  5. Kesimpulan </h2><br><ol><li>  Sejumlah mencuri dapat terjadi karena paravirtualization, dan itu dapat dianggap normal.  Di Internet mereka menulis bahwa nilai ini bisa 5-10%.  Itu tergantung pada aplikasi di dalam mesin virtual dan pada jenis beban apa yang diletakkan pada perangkat fisiknya.  Penting untuk memperhatikan bagaimana aplikasi di dalam mesin virtual rasakan. <br></li><li>  Rasio beban pada hypervisor dan mencuri di dalam mesin virtual tidak selalu saling berhubungan, kedua perkiraan pencurian dapat keliru dalam situasi tertentu pada beban yang berbeda. <br></li><li>  Penjadwal tidak suka proses yang banyak bertanya.  Dia mencoba memberi lebih sedikit kepada mereka yang meminta lebih.  Mesin virtual besar itu jahat. <br></li><li>  Mencuri kecil bisa menjadi norma tanpa paravirtualization (dengan mempertimbangkan beban di dalam mesin virtual, fitur dari beban tetangga, distribusi beban antara benang dan faktor lainnya). <br></li><li>  Jika Anda ingin mengetahui mencuri dalam sistem tertentu, Anda harus meriset berbagai opsi, mengumpulkan metrik, menganalisisnya dengan cermat, dan memikirkan cara mendistribusikan beban secara merata.  Penyimpangan dimungkinkan dari setiap kasus, yang harus dikonfirmasi secara eksperimental atau dilihat di debugger kernel. <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449316/">https://habr.com/ru/post/id449316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449306/index.html">12 kata bahasa Inggris yang sering dieja dan diucapkan secara salah</a></li>
<li><a href="../id449308/index.html">Memperkenalkan Microsoft Azure DevTest Labs</a></li>
<li><a href="../id449310/index.html">Citymobil - manual untuk meningkatkan ketersediaan di tengah pertumbuhan bisnis untuk startup. Bagian 2</a></li>
<li><a href="../id449312/index.html">RAID Perangkat Keras: Fitur Penggunaan</a></li>
<li><a href="../id449314/index.html">Imigrasi Freelancer: apa yang perlu Anda ketahui</a></li>
<li><a href="../id449318/index.html">Bagaimana kesuksesan Fortnite menghasilkan berbulan-bulan krisis hebat di Epic Games</a></li>
<li><a href="../id449320/index.html">Bagaimana keamanan informasi telah berubah selama 20 tahun terakhir</a></li>
<li><a href="../id449322/index.html">Jaringan TV kabel untuk yang terkecil. Bagian 1: Arsitektur umum jaringan KTV</a></li>
<li><a href="../id449324/index.html">Banyak, smartphone, perusahaan raksasa: Program Heisenbug 2019 Piter</a></li>
<li><a href="../id449326/index.html">WebRTC dan pengawasan video: bagaimana kami mengalahkan keterlambatan video dari kamera</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>