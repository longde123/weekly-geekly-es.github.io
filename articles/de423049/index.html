<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎌 🤽🏿 🏧 Lernprozesse unter Linux 📂 👩‍👧‍👧 🧙🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel möchte ich über den Lebensweg von Prozessen in der Linux-Betriebssystemfamilie sprechen. In Theorie und Beispielen werde ich untersu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lernprozesse unter Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423049/"><img src="https://habrastorage.org/webt/w9/tj/yz/w9tjyz5nyynb4zwy2kiikc0ckec.png"><br>  In diesem Artikel möchte ich über den Lebensweg von Prozessen in der Linux-Betriebssystemfamilie sprechen.  In Theorie und Beispielen werde ich untersuchen, wie Prozesse geboren werden und sterben, und ein wenig über die Mechanik von Systemaufrufen und Signalen sprechen. <br><br>  Dieser Artikel richtet sich eher an Anfänger in der Systemprogrammierung und an diejenigen, die nur ein wenig mehr über die Funktionsweise von Prozessen unter Linux erfahren möchten. <br><a name="habracut"></a><br>  Alles, was unten geschrieben steht, gilt für Debian Linux mit dem Kernel 4.15.0. <br><br><h2>  Inhalt </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prozessattribute</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prozesslebenszyklus</a> <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prozessgeburt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereitschaftszustand</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Status ist "läuft"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reinkarnation in einem anderen Programm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausstehender Zustand</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Status stoppen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prozessabschluss</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Zustand der "Zombies"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergessenheit</a> </li></ol></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Danksagung</a> </li></ol><br><a name="intro"></a><h2>  Einführung </h2><br>  Systemsoftware interagiert mit dem Systemkern über spezielle Funktionen - Systemaufrufe.  In seltenen Fällen gibt es eine alternative API, z. B. procfs oder sysfs, die in Form von virtuellen Dateisystemen erstellt wird. <br><br><a name="definition"></a><h2>  Prozessattribute </h2><br>  Der Prozess im Kernel wird einfach als Struktur mit vielen Feldern dargestellt (die Definition der Struktur kann hier gelesen <a href="" rel="nofollow">werden</a> ). <br>  Da sich der Artikel jedoch der Systemprogrammierung und nicht der Kernelentwicklung widmet, sind wir etwas abstrahiert und konzentrieren uns einfach auf die für uns wichtigen Prozessfelder: <br><br><ul><li>  Prozess-ID (pid) </li><li>  Öffnen Sie die Dateideskriptoren (fd) </li><li>  Signalhandler </li><li>  Aktuelles Arbeitsverzeichnis (cwd) </li><li>  Umgebungsvariablen (Umgebung) </li><li>  Rückkehrcode </li></ul><br><a name="lifecycle"></a><h2>  Prozesslebenszyklus </h2><br><img src="https://habrastorage.org/webt/dw/ru/5n/dwru5nbeoag7imroc_ki1qa9gba.png"><br><br><a name="fork"></a><h3>  Prozessgeburt </h3><br>  Nur ein Prozess im System wird auf besondere Weise geboren - <code>init</code> - er wird direkt vom Kernel generiert.  Alle anderen Prozesse werden angezeigt, indem der aktuelle Prozess mithilfe des Systemaufrufs <code>fork(2)</code> dupliziert wird.  Nachdem <code>fork(2)</code> ausgeführt wurde, erhalten wir zwei nahezu identische Prozesse mit Ausnahme der folgenden Punkte: <br><br><ol><li>  <code>fork(2)</code> gibt die PID des Kindes an das Elternteil zurück, 0 wird an das Kind zurückgegeben; </li><li>  Das Kind ändert die PPID (Parent Process ID) in die PID des Elternteils. </li></ol><br>  Nachdem <code>fork(2)</code> ausgeführt wurde, sind alle Ressourcen des untergeordneten Prozesses eine Kopie der Ressourcen des übergeordneten Prozesses.  Das Kopieren eines Prozesses mit allen zugewiesenen Speicherseiten ist teuer, daher verwendet der Linux-Kernel die Copy-On-Write-Technologie. <br>  Alle Seiten im Speicher des Elternteils sind als schreibgeschützt markiert und stehen sowohl dem Elternteil als auch dem Kind zur Verfügung.  Sobald einer der Prozesse die Daten auf einer bestimmten Seite ändert, ändert sich diese Seite nicht, aber die Kopie wurde bereits kopiert und geändert.  In diesem Fall wird das Original von diesem Vorgang „gelöst“.  Sobald das schreibgeschützte Original an einen einzelnen Prozess „gebunden“ bleibt, wird die Seite dem Lese- / Schreibstatus zugewiesen. <br><br><div class="spoiler">  <b class="spoiler_title">Ein Beispiel für ein einfaches nutzloses Programm mit Gabel (2)</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/types.h&gt; int main() { int pid = fork(); switch(pid) { case -1: perror("fork"); return -1; case 0: // Child printf("my pid = %i, returned pid = %i\n", getpid(), pid); break; default: // Parent printf("my pid = %i, returned pid = %i\n", getpid(), pid); break; } return 0; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out my pid = 15594, returned pid = 15595 my pid = 15595, returned pid = 0</code> </pre><br></div></div><br><a name="ready"></a><h3>  Bereitschaftszustand </h3><br>  Unmittelbar nach der Ausführung wechselt die <code>fork(2)</code> in den Bereitschaftszustand. <br>  Tatsächlich stellt der Prozess in die Warteschlange und wartet darauf, dass der Scheduler im Kernel den Prozess auf dem Prozessor ausführen lässt. <br><br><a name="running"></a><h3>  Der Status ist "läuft" </h3><br>  Sobald der Scheduler den Prozess ausgeführt hat, begann der Status "Ausführen".  Der Prozess kann den gesamten vorgeschlagenen Zeitraum (Quantum) der Zeit <code>sched_yield</code> oder anderen Prozessen mithilfe des <code>sched_yield</code> . <br><br><a name="exec"></a><h3>  Reinkarnation in einem anderen Programm </h3><br>  Einige Programme implementieren eine Logik, bei der der übergeordnete Prozess ein untergeordnetes Element erstellt, um ein Problem zu lösen.  In diesem Fall löst das Kind ein bestimmtes Problem, und der Elternteil delegiert nur Aufgaben an seine Kinder.  Beispielsweise erstellt ein Webserver mit einer eingehenden Verbindung ein untergeordnetes Element und übergibt die Verbindungsverarbeitung an dieses. <br>  Wenn Sie jedoch ein anderes Programm ausführen müssen, müssen Sie auf den Systemaufruf <code>execve(2)</code> zurückgreifen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argv[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> envp[])</span></span></span></span>;</code> </pre><br>  oder Bibliotheksaufrufe <code>execl(3), execlp(3), execle(3), execv(3), execvp(3), execvpe(3)</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, ... </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* (char *) NULL */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execlp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, ... </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* (char *) NULL */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, ... </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*, (char *) NULL, char * const envp[] */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argv[])</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execvp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argv[])</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execvpe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argv[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> envp[])</span></span></span></span>;</code> </pre><br>  Alle oben genannten Aufrufe führen das Programm aus, dessen Pfad im ersten Argument angegeben ist.  Bei Erfolg wird die Steuerung an das geladene Programm übertragen und nicht an das ursprüngliche zurückgegeben.  In diesem Fall verfügt das geladene Programm über alle Felder der Prozessstruktur, mit Ausnahme der als <code>O_CLOEXEC</code> gekennzeichneten <code>O_CLOEXEC</code> , die geschlossen werden. <br><br>  Wie kann man bei all diesen Herausforderungen nicht verwirrt werden und die richtige auswählen?  Es reicht aus, die Namenslogik zu verstehen: <br><br><ul><li>  Alle Aufrufe beginnen mit <code>exec</code> </li><li>  Der fünfte Buchstabe definiert die Art der Argumentübergabe: <br><ul><li>  <b>l</b> steht für <b>Liste</b> , alle Parameter werden als <code>arg1, arg2, ..., NULL</code> </li><li>  <b>v</b> steht für <b>Vektor</b> , alle Parameter werden in einem nullterminierten Array übergeben; </li></ul></li><li>  Der Buchstabe <b>p</b> , der für <b>Pfad</b> steht, kann folgen.  Wenn das <code>file</code> mit einem anderen Zeichen als "/" beginnt, wird die angegebene <code>file</code> in den Verzeichnissen nachgeschlagen, die in der Umgebungsvariablen PATH aufgeführt sind </li><li>  Der letzte kann der Buchstabe <b>e sein</b> , der die <b>Umgebung</b> angibt.  In solchen Aufrufen ist das letzte Argument ein nullterminiertes Array von nullterminierten Zeichenfolgen der Form <code>key=value</code> - Umgebungsvariablen, die an das neue Programm übergeben werden. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Beispielaufruf an / bin / cat --help via execve</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _GNU_SOURCE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt; int main() { char* args[] = { "/bin/cat", "--help", NULL }; execve("/bin/cat", args, environ); // Unreachable return 1; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out Usage: /bin/cat [OPTION]... [FILE]... Concatenate FILE(s) to standard output. * *</code> </pre><br></div></div><br>  Mit der Familie <code>exec*</code> call können Sie Skripte mit Ausführungsrechten ausführen und mit einer Folge von Shebangs (#!) Beginnen. <br><br><div class="spoiler">  <b class="spoiler_title">Ein Beispiel für das Ausführen eines Skripts mit einem gefälschten PATH mithilfe von execle</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _GNU_SOURCE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt; int main() { char* e[] = {"PATH=/habr:/rulez", NULL}; execle("/tmp/test.sh", "test.sh", NULL, e); // Unreachable return 1; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/bin/bash echo $0 echo $PATH $ gcc test.c &amp;&amp; ./a.out /tmp/test.sh /habr:/rulez</span></span></code> </pre><br></div></div><br>  Es gibt eine Konvention, die impliziert, dass argv [0] mit den Nullargumenten für Funktionen in der exec * -Familie übereinstimmt.  Dies kann jedoch verletzt werden. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel, wenn Katze mit execlp zum Hund wird</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _GNU_SOURCE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt; int main() { execlp("cat", "dog", "--help", NULL); // Unreachable return 1; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out Usage: dog [OPTION]... [FILE]... * *</code> </pre><br></div></div><br>  Ein neugieriger Leser kann feststellen, dass die Signatur der <code>int main(int argc, char* argv[])</code> eine Zahl enthält <code>int main(int argc, char* argv[])</code> - die Anzahl der Argumente, aber nichts dergleichen wird an die <code>exec*</code> -Funktionsfamilie übergeben.  Warum?  Denn wenn das Programm startet, wird die Steuerung nicht sofort auf main übertragen.  Zuvor werden einige von glibc definierte Aktionen ausgeführt, einschließlich des Zählens von argc. <br><br><a name="waiting"></a><h3>  Ausstehender Zustand </h3><br>  Einige Systemaufrufe können lange dauern, z. B. E / A.  In solchen Fällen geht der Prozess in einen Wartezustand über.  Sobald der Systemaufruf abgeschlossen ist, versetzt der Kernel den Prozess in den Status "Bereit". <br>  Unter Linux gibt es auch einen Wartezustand, in dem der Prozess nicht auf Interrupt-Signale reagiert.  In diesem Zustand wird der Prozess "unzerstörbar" und alle eingehenden Signale stehen in einer Linie, bis der Prozess diesen Zustand verlässt. <br>  Der Kernel selbst wählt aus, in welchen Zustand der Prozess übertragen werden soll.  In den meisten Fällen befinden sich Prozesse, die E / A anfordern, im Status "Warten (ohne Unterbrechungen)".  Dies macht sich insbesondere bei Verwendung einer Remote-Festplatte (NFS) mit einem nicht sehr schnellen Internet bemerkbar. <br><br><a name="stopped"></a><h3>  Status stoppen </h3><br>  Sie können einen Prozess jederzeit anhalten, indem Sie ihm ein SIGSTOP-Signal senden.  Der Prozess wird in einen "gestoppten" Zustand versetzt und bleibt dort, bis er ein Signal erhält, weiter zu arbeiten (SIGCONT) oder zu sterben (SIGKILL).  Die verbleibenden Signale werden in die Warteschlange gestellt. <br><br><a name="exit"></a><h3>  Prozessabschluss </h3><br>  Kein Programm kann sich selbst herunterfahren.  Sie können das System nur mit dem <code>_exit</code> fragen oder vom System aufgrund eines Fehlers beendet werden.  Selbst wenn Sie eine Zahl von <code>main()</code> , wird <code>_exit</code> implizit aufgerufen. <br>  Obwohl das Argument für den Systemaufruf int ist, wird nur das niedrige Byte der Nummer als Rückkehrcode verwendet. <br><br><a name="zombie"></a><h3>  Der Zustand der "Zombies" </h3><br>  Unmittelbar nach Abschluss des Prozesses (unabhängig davon, ob er korrekt ist oder nicht) schreibt der Kernel Informationen darüber, wie der Prozess beendet wurde, und versetzt ihn in den Status "Zombie".  Mit anderen Worten, ein Zombie ist ein abgeschlossener Prozess, aber der Speicher davon ist immer noch im Kernel gespeichert. <br>  Darüber hinaus ist dies der zweite Zustand, in dem der Prozess das SIGKILL-Signal sicher ignorieren kann, da es nicht wieder tot sterben kann. <br><br><a name="wait"></a><h3>  Vergessenheit </h3><br>  Der Rückkehrcode und der Grund für den Abschluss des Prozesses sind noch im Kernel gespeichert und müssen von dort übernommen werden.  Dazu können Sie die entsprechenden Systemaufrufe verwenden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> wait(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *wstatus); <span class="hljs-comment"><span class="hljs-comment">/*  waitpid(-1, wstatus, 0) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> waitpid(<span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> pid, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *wstatus, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> options);</code> </pre><br>  Alle Informationen zur Beendigung des Prozesses passen in den Datentyp int.  Die in der <code>waitpid(2)</code> beschriebenen Makros werden verwendet, um den Rückkehrcode und den Grund für die Programmbeendigung abzurufen. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel für die korrekte Vervollständigung und den Erhalt eines Rückkehrcodes</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/types.h&gt; int main() { int pid = fork(); switch(pid) { case -1: perror("fork"); return -1; case 0: // Child return 13; default: { // Parent int status; waitpid(pid, &amp;status, 0); printf("exit normally? %s\n", (WIFEXITED(status) ? "true" : "false")); printf("child exitcode = %i\n", WEXITSTATUS(status)); break; } } return 0; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> normally? <span class="hljs-literal"><span class="hljs-literal">true</span></span> child exitcode = 13</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Falsches Abschlussbeispiel</b> <div class="spoiler_text"><br>  Das Übergeben von argv [0] als NULL führt zu einem Absturz. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/types.h&gt; int main() { int pid = fork(); switch(pid) { case -1: perror("fork"); return -1; case 0: // Child execl("/bin/cat", NULL); return 13; default: { // Parent int status; waitpid(pid, &amp;status, 0); if(WIFEXITED(status)) { printf("Exit normally with code %i\n", WEXITSTATUS(status)); } if(WIFSIGNALED(status)) { printf("killed with signal %i\n", WTERMSIG(status)); } break; } } return 0; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out killed with signal 6</code> </pre><br></div></div><br>  Es gibt Zeiten, in denen ein Elternteil früher als das Kind endet.  In solchen Fällen wird <code>init</code> zum Elternteil des Kindes und verwendet zu <code>wait(2)</code> Zeit den Anruf <code>wait(2)</code> . <br><br>  Nachdem der Elternteil Informationen über den Tod des Kindes aufgenommen hat, löscht der Kernel alle Informationen über das Kind, sodass bald ein anderer Prozess an seine Stelle tritt. <br><br><a name="thanks"></a><h2>  Danksagung </h2><br>  Vielen Dank an Sasha „Al“ für die Bearbeitung und Unterstützung beim Design. <br><br>  Vielen Dank an Sasha „Reisse“ für die klaren Antworten auf schwierige Fragen. <br><br>  Sie ertrugen die Inspiration, die mich angriff, und die Flut meiner Fragen, die mich angriffen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423049/">https://habr.com/ru/post/de423049/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423039/index.html">Wir führen die Webauthentifizierung über Blockchain durch</a></li>
<li><a href="../de423041/index.html">Bizarre Geschichte Super NES CD-ROM</a></li>
<li><a href="../de423043/index.html">Aufgrund einer Sicherheitslücke im Tesla-Schutzsystem für Elektrofahrzeuge kann ein Auto in wenigen Sekunden gestohlen werden</a></li>
<li><a href="../de423045/index.html">Welchen 3D-Drucker wählen? 3Dtool Video Review</a></li>
<li><a href="../de423047/index.html">Wir reservieren IT-Systeme für angemessenes Geld</a></li>
<li><a href="../de423051/index.html">Der Kampf um Ressourcen, Teil 1: Die Grundlagen von Cgroups</a></li>
<li><a href="../de423053/index.html">Struktur und schreibgeschützt: So vermeiden Sie Leistungseinbußen</a></li>
<li><a href="../de423055/index.html">Wall Street Analysten: "Apple hat uns dazu gebracht, unsere Hüte zu essen"</a></li>
<li><a href="../de423057/index.html">Python lehnt auch die Begriffe Master / Slave teilweise ab</a></li>
<li><a href="../de423059/index.html">Besser als sie sagen: Drei Grundlagen für das nächste MacBook als eines der besten Laptops von Apple</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>