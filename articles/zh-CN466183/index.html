<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏼 👩🏼‍🎓 👩🏼‍🎨 ClickHouse中的智能字符串处理算法 📱 ⁉️ 🏥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ClickHouse经常遇到字符串处理任务。 例如，无论是区分大小写的搜索还是压缩的数据搜索，都进行搜索，计算UTF-8字符串的属性或其他更奇特的内容。 


一切始于ClickHouse开发经理Lesha Milovidov o6CuFl2Q来到我们的经济学院计算机科学系，并为学期论文和文凭提供了...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ClickHouse中的智能字符串处理算法</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/466183/"><p>  ClickHouse经常遇到字符串处理任务。 例如，无论是区分大小写的搜索还是压缩的数据搜索，都进行搜索，计算UTF-8字符串的属性或其他更奇特的内容。 </p><br><p>一切始于ClickHouse开发经理Lesha Milovidov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">o6CuFl2Q</a>来到我们的经济学院计算机科学系，并为学期论文和文凭提供了大量主题。 当我看到“ ClickHouse中的智能字符串处理算法”（我是一个对各种算法（包括实验算法）感兴趣的人）时，我立即制定了如何制作最酷文凭的计划。 我的喜悦和表情可以描述如下： </p><br><p><img src="https://habrastorage.org/webt/av/4d/2g/av4d2gj_pplevfljaomiqsnccda.jpeg"></p><br><a name="habracut"></a><br><h2 id="clickhouse">  Clickhouse </h2><br><p>  ClickHouse仔细考虑了内存中数据存储的组织方式-按列。 每列的末尾都有15字节的填充，用于安全读取16字节的寄存器。 例如，ColumnString存储以null结尾的字符串以及偏移量。 使用此类数组非常方便。 </p><br><p><img src="https://habrastorage.org/webt/w4/go/yp/w4goypgrxiigdp5tpdy3eyao2bu.png"><br></p><br><p> 也有ColumnFixedString，ColumnConst和LowCardinality，但是我们今天不再详细讨论它们。 此时的重点是，安全读取尾巴的设计非常漂亮，并且数据的局部性在处理中也起作用。 </p><br><h2 id="poisk-po-podstrokam"> 子串搜索 </h2><br><p> 您很可能知道用于在字符串中查找子字符串的许多不同算法。 我们将讨论ClickHouse中使用的那些。 首先，我们介绍几个定义： </p><br><ol><li> 干草堆-我们正在寻找的线； 通常，长度用<em>n</em>表示。 </li><li> 针-我们正在寻找的字符串或正则表达式; 长度将由<em>m</em>表示。 </li></ol><br><p> 在研究了大量算法之后，我可以说有2种（最多3种）子串搜索算法。 首先是以一种或另一种形式创建后缀结构。 第二种是基于内存比较的算法。 还有Rabin-Karp算法，该算法使用哈希，但是在同类算法中非常独特。 最快的算法并不存在，这完全取决于字母的大小，针的长度，干草堆和出现的频率。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>了解不同的算法。 以下是最受欢迎的算法： </p><br><ol><li> 纳特-莫里斯-普拉特， </li><li> 博耶-摩尔， </li><li> 博耶-摩尔-霍斯浦， </li><li> 拉宾-鲤鱼， </li><li> 双面（在glibc中使用，称为“ memmem”）， </li><li>  BNDM </li></ol><br><p> 清单继续。 我们在ClickHouse诚实地尝试了所有内容，但最终我们选择了一个更加出色的版本。 </p><br><h4 id="algoritm-volnickogo">  Volnitsky算法 </h4><br><p> 该算法于2010年末发布在程序员Leonid Volnitsky的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客上</a> 。 它在某种程度上让人联想到Boyer-Moore-Horspool算法，只是一个改进版本。 </p><br><p> 如果<em>m &lt;4</em> ，则使用标准搜索算法。 从头将所有双字（2个连续字节）的指针保存到哈希表中，并以开放地址寻址<em>| Sigma |</em>  <em><sup>2个</sup></em>元素（实际上是2 <sup>16个</sup>元素），其中此bigram的偏移量将是值，而bigram本身将同时是哈希和索引。 初始位置将从干草堆开始处的位置<em>m-2</em>处。 我们在haystack之后执行步骤<em>m-1</em> ，从干草堆中的该位置查看下一个bigram，并考虑哈希表中bigram的所有值。 然后，我们将使用常规比较算法比较两个内存。 剩下的尾巴将由相同的算法处理。 </p><br><p> 选择步骤<em>m-1</em>的方式是，如果大海捞针中出现针刺，那么我们肯定会考虑该条目的二元组-从而确保我们返回大海捞针中条目的位置。 我们通过bigram从末尾向哈希表添加索引这一事实保证了第一次出现。 这意味着，当我们从左到右移动时，我们将首先从行尾开始考虑二元组（也许最初考虑的是完全不必要的二元组），然后再接近起点。 </p><br><p>考虑一个例子。 令干草堆为<code>abacabaac</code>和等于<code>aaca</code>针。 哈希表将为<code>{aa : 0, ac : 1, ca : 2}</code> 。 </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p> 我们看到了二元组<code>ac</code> 。 从本质上讲，我们用平等代替： </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca aaca</code> </pre> <br><p> 不匹配。 在<code>ac</code>之后，哈希表中没有任何条目，我们进入步骤3： </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p> 哈希表中没有bigrams <code>ba</code> ，继续： </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p> 针中有一个bigram <code>ca</code> ，我们查看偏移量并找到条目： </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca aaca</code> </pre> <br><p> 该算法具有许多优点。 首先，您不需要在堆上分配内存，并且堆栈上的64 KB现在已经不是先验的了。 其次，2 <sup>16</sup>是对处理器取模的极好数字。 这些只是movzwl指令（或者，我们开玩笑说是“ movsvl”）和家人。 </p><br><p> 平均而言，该算法被证明是最好的。 我们从Yandex.Metrica中获取数据，这些请求几乎是真实的。 一股流速度，越多越好，KMP：Knut-Morris-Pratt算法，BM：Boyer-Moore，BMH：Boyer-Moore-Horspool。 </p><br><p><img src="https://habrastorage.org/webt/wp/vn/v2/wpvnv2eqrbhhvqvryaqmdjc9igy.png"><br></p><br><p> 为了不成立，该算法可以工作二次时间： </p><br><p><img src="https://habrastorage.org/webt/oi/3x/dh/oi3xdhxe7awdlsqxxui2lyqvxjc.png"><br></p><br><p> 它用在<code>position(Column, ConstNeedle)</code>函数<code>position(Column, ConstNeedle)</code> ，还用作正则表达式搜索的优化。 </p><br><h2 id="poisk-po-regulyarnym-vyrazheniyam"> 正则表达式搜索 </h2><br><p> 我们将告诉您ClickHouse如何优化正则表达式搜索。 许多正则表达式内部都包含一个子字符串，该子字符串必须在干草堆内部。 为了不构建有限状态机并进行检查，我们将隔离这些子字符串。 </p><br><p> 要做到这一点很简单：任何打开的括号都会增加嵌套的水平，任何关闭的括号都会减少； 还有一些特定于正则表达式的字符（例如'。'，'*'，'？'，'\ w'等）​​。 我们需要在级别0处获取所有子字符串。请考虑一个示例： <br><img src="https://habrastorage.org/webt/2x/uk/uo/2xukuompabpmnrjpk-muwg1yydi.png"><br></p><br><p> 我们将其分为正则表达式必须位于干草堆中的那些子字符串，然后选择最大长度，在其上寻找候选对象，然后使用常规正则表达式引擎RE2进行检查。 在上面的图片中，有一个正则表达式，它由常规的RE2引擎以736 MB / s的速度处理，Hyperscan（稍后介绍）管理到1.6 GB / s，我们每个内核管理1.69 GB / s的压缩以及解压缩。 LZ4。 通常，这种优化是表面上的，它极大地加快了对正则表达式的搜索，但是通常它并未在工具中实现，这使我感到惊讶。 </p><br><p>  LIKE关键字也使用此算法进行了优化，只有在LIKE之后，非常简化的正则表达式才能通过%%%%%（任意子字符串）和<code>_</code> （任意字符）。 </p><br><p> 不幸的是，并非所有的正则表达式都经过这样的优化，例如，从<code>yandex|google</code> ，不可能显式提取必须在干草堆中出现的子字符串。 因此，我们提出了一个完全不同的解决方案。 </p><br><h2 id="poisk-po-mnogim-podstrokam"> 搜索许多子字符串 </h2><br><p> 问题是有很多针头，我想了解一下大海捞针中是否至少包括一根针头。 有相当经典的搜索方法，例如Aho-Korasik算法。 但是他并不太快完成我们的任务。 我们稍后再讨论。 </p><br><p><del> 乐莎 </del>  ClickHouse喜欢非标准解决方案，因此我们决定尝试不同的方法，也许我们自己制定一种新的搜索算法。 他们做到了。 </p><br><p> 我们研究了Volnitsky算法并对其进行了修改，以使其开始立即搜索许多子字符串。 为此，您只需要添加所有行的二元组并将行索引存储在哈希表中。 该步长将至少从所有针长减去1中进行选择，以再次保证该属性，如果出现这种情况，我们将看到其二字组。 哈希表将增长到128 KB（标准算法处理的行长超过255，我们将考虑不超过256个针）。 我很懒，所以这是演示文稿中的一个示例（从左到右，从上到下阅读）： </p><br><p><img src="https://habrastorage.org/webt/ak/no/hq/aknohqtvebtx-c_ijmza8af0emm.png"><br></p><br><p><img src="https://habrastorage.org/webt/x6/cm/z4/x6cmz4d3i5qy5i3tfj1ngbssewc.png"><br></p><br><p> 我们开始研究这种算法与其他算法相比的行为（行是从真实数据中提取的）。 对于少量的线路，他可以完成所有工作（指示速度和卸载速度-约2.5 GB / s）。 </p><br><p><img src="https://habrastorage.org/webt/nl/t_/pt/nlt_pt077xl7n-cya0qb6eh67re.png"><br></p><br><p> 然后变得有趣。 例如，在大量类似的二元组中，我们输给了一些竞争对手。 这是可以理解的-我们开始比较许多内存并进行降级。 </p><br><p><img src="https://habrastorage.org/webt/n8/wm/uz/n8wmuzm_vcepo4olqcse1e7gwqy.png"><br></p><br><p> 如果针的最小长度足够大，您将无法加速。 显然，我们有更多机会跳过整个草堆而无需为此付出任何代价。 </p><br><p><img src="https://habrastorage.org/webt/zg/z1/ej/zgz1ejecxev4-j-oz3m6egxydt0.png"><br></p><br><p> 引爆点开始于第13-15行。 我在集群上看到的请求中约有97％少于15行： </p><br><p><img src="https://habrastorage.org/webt/x-/6j/od/x-6jodqalhriam_byxewdzoxzhs.png"><br></p><br><p> 好吧，一张非常可怕的图片-41行，许多重复的二元组： </p><br><p><img src="https://habrastorage.org/webt/yx/ez/da/yxezdam_2poycdgttd9nnsyjjqy.png"><br></p><br><p> 结果，在ClickHouse（19.5）中，我们通过此算法实现了以下功能： </p><br><p>  <code>multiSearchAny(h, [n_1, ..., n_k])</code> -1，如果至少一根针在干草堆中。 <br>  <code>multiSearchFirstPosition(h, [n_1, ..., n_k])</code> -进入干草堆的最左侧位置（从1开始）；如果找不到，则为0。 <br>  <code>multiSearchFirstIndex(h, [n_1, ..., n_k])</code> -最左侧的针索引，在干草堆中找到；  0（如果未找到）。 <br>  <code>multiSearchAllPositions(h, [n_1, ..., n_k])</code> -所有针的所有第一位置，均返回一个数组。 </p><br><p> 后缀为-UTF8（我们不进行规范化），-CaseInsensitive（我们添加4个大小写不同的双字），-CaseInsensitiveUTF8（存在一个条件，即大写字母和小写字母必须具有相同的字节数）。 在<a href="">此处</a>查看实现。 </p><br><p> 之后，我们想知道是否可以对许多正则表达式执行类似的操作。 他们找到了基准中已经损坏的解决方案。 </p><br><h2 id="poisk-po-mnogim-regulyarnym-vyrazheniyam"> 通过许多正则表达式进行搜索 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hyperscan</a>是Intel的一个库，可立即搜索许多正则表达式。 它使用启发式方法将子词与我们编写的正则表达式隔离开来，并使用许多SIMD搜索Glushkov自动机（该算法似乎称为Teddy）。 </p><br><p> 通常，一切都遵循最佳传统，即从正则表达式的搜索中获得最大收益。 该库确实执行其函数中声明的操作。 </p><br><p><img src="https://habrastorage.org/webt/of/xl/dd/ofxlddsnj92zghvsducv9e9jktu.png"><br></p><br><p> 幸运的是，在ClickHouse的一个月的开发工作中，我能够在相当不错的查询水平上超过12年的开发工作，对此我感到非常满意。 </p><br><p> 在Yandex中，Hyperscan库也用于反垃圾邮件。 从评论来看，她冷静地处理了数千个正则表达式并快速搜索它们。 </p><br><p> 该库有几个缺点。 首先是未记录的内存消耗量，这是一个奇怪的功能，即干草堆必须小于2 <sup>32</sup>字节。 第二个-您无法免费返回第一个位置，最左边的针索引等。第三个-则有一些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">错误</a> 。 因此，在ClickHouse，我们使用Hyperscan实现了以下功能： </p><br><p>  <code>multiMatchAny(h, [n_1, ..., n_k])</code> -1，如果至少一根针从干草堆中冒出来。 <br>  <code>multiMatchAnyIndex(h, [n_1, ..., n_k])</code> -针<code>multiMatchAnyIndex(h, [n_1, ..., n_k])</code>干草堆<code>multiMatchAnyIndex(h, [n_1, ..., n_k])</code>任何索引。 </p><br><p> 我们很感兴趣，但是您怎么能不精确地而是近似地搜索呢？ 并提出了几种解决方案。 </p><br><h2 id="priblizhyonnyy-poisk"> 近似搜索 </h2><br><p> 近似搜索中的标准是Levenshtein距离-可以替换，添加和删除以从长度为m的字符串a获得长度为n的字符串b的最小字符数。 不幸的是，朴素的动态规划算法适用于<em>O（mn）</em> ；  ShAD最好的头脑可以做到<em>O（mn / log max（n，m））</em> ; 很容易想到<em>O（（n + m）⋅alpha）</em> ，其中<em>alpha</em>是答案；  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">科学</a>可以针对<em>O（（alpha-| n-m |）min（m，n，alpha）+ m + n）</em> （算法很简单，至少要在ShAD中读取）做到这一点，或者如果更清晰一点，可以针对<em>O（alpha ^ 2 + m + n）</em> 。 还有一个缺点：在多项式最坏的情况下，摆脱二次时间是最不可能的-彼得·英迪克（Peter Indik）撰写了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇</a>非常有力的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> 。 </p><br><p> 有一个练习：想象一下，要替换Levenshtein距离中的一个字符，您要支付的罚款不是2个而是2个。 然后提出<em>O（（n + m）log（n + m））的算法</em> 。 </p><br><p> 它仍然无法正常运行，时间太长且价格昂贵。 但是借助这样的距离，我们在查询中进行了错别字检测。 </p><br><p><img src="https://habrastorage.org/webt/ok/b8/gg/okb8ggb8vwkzft3ggzdipy29pja.png"><br></p><br><p> 除了Levenshtein距离外，还有汉明距离。 和他在一起，一切都还不错，但是比Levenshtein的距离要好一些。 它不考虑字符的删除，而是仅考虑长度相同的两行不同字符的数量。 因此，如果我们将距离用于长度为m &lt;n的字符串，则仅在搜索最接近的子字符串时使用。 </p><br><p> 对于<em>O（| Sigma |（n + m）log（n + m），</em>如何计算这样的差异数组（n-m + 1个元素的数组d，其中d [i]是从叠加层开始的第i个不同字符的数量<em>） ）</em> ？ 首先，做<em>| Sigma |</em> 指示此符号是否等于所考虑符号的位掩码。 接下来，我们为每个Sigma蒙版计算答案并加-得到原始答案。 </p><br><p> 考虑一个例子。  <code>abba</code> ，substring <code>ba</code> ，二进制字母。 我们得到2个蒙版<code>1001, 01</code>和<code>0110, 10</code> 。 </p><br><pre> <code class="plaintext hljs">   a 1001 01 - 0  01 - 0  01 - 1 </code> </pre> <br><pre> <code class="plaintext hljs">   b 0110 10 - 0  10 - 1  10 - 1 </code> </pre> <br><p> 我们得到数组[0，1，2]-这几乎是正确的答案。 但是请注意，对于每个字母，匹配的数目只是固定的二进制指针与所有干草堆子字符串的标量积。 为此，当然有一个快速的傅立叶变换！ </p><br><p> 对于那些不知道的人：FFT可以在时间<em>O（n log n）</em>中将<em>m &lt;n的</em>两个多项式相乘，前提是每单位时间执行系数运算。 卷积与标量积非常相似。 复制第一个多项式的系数，然后用所需的零数目扩展和补充第二个多项式就足够了，然后我们得到一个二进制字符串的所有标量乘积和另一个二进制字符串的所有子字符串的标量乘积<em>O（n log n）</em> -有点神奇！ 但是请相信我，这是绝对真实的，有时人们会这样做。 </p><br><p> 但不在ClickHouse中。 对我们来说，与| Sigma |  = 30已经很大，并且FFT并不是处理器最实用的实用算法，或者像普通人所说的那样，“常数很大”。 </p><br><p> 因此，我们决定考虑其他指标。 我们到了生物信息学，人们使用n克距离。 实际上，我们将所有n-gram的干草堆和needle都考虑在内，并考虑这些n-gram的2个多集。 然后，我们取对称差，并用n元语法除以两个多重集的基数之和。 我们得到一个从0到1的数字-越接近0，线条越相似。 考虑一个<em>n = 4</em>的示例： </p><br><pre> <code class="plaintext hljs">abcda → {abcd, bcda}; Size = 2 bcdab → {bcda, cdab}; Size = 2         . |{abcd, cdab}| / (2 + 2) = 0.5</code> </pre> <br><p> 结果，我们之间的距离为4克，并从那里的SSE那里扎了很多想法，并且还稍微削弱了对双字节crc32哈希的实现。 </p><br><p><img src="https://habrastorage.org/webt/ad/36/uk/ad36ukzmrspftbjxxwbc3djljv4.png"><br></p><br><p> 检查<a href="">实施</a> 。 注意：非常引人注目的优化代码。 </p><br><p> 我特别建议您注意为ASCII和俄语代码点转换小写字母的<a href="">肮脏技巧</a> 。 </p><br><p>  <code>ngramDistance(haystack, needle)</code> -返回从0到1的数字； 越接近0，则越多的行彼此相似。 <br>  --UTF8，-CaseInsensitive，-CaseInsensitiveUTF8（俄语和ASCII的肮脏hack）。 </p><br><p>  Hyperscan也不会停滞不前-它具有近似搜索功能：通过Levenshtein的恒定距离，您可以搜索看起来像正则表达式的行。 创建<em>距离+ 1</em>自动机，通过删除，替换或插入字符（表示“精细”）将其互连，然后应用检查自动机是否接受特定行的常用算法。 在ClickHouse中，我们以以下名称实现了它们： </p><br><p>  <code>multiFuzzyMatchAny(haystack, distance, [n_1, ..., n_k])</code> -与multiMatchAny类似，仅具有距离。 <br>  <code>multiFuzzyMatchAnyIndex(haystack, distance, [n_1, ..., n_k])</code> -与multiMatchAnyIndex类似，仅具有距离。 </p><br><p> 随着<em>距离的</em>增加<em>，</em>速度开始大大降低，但仍保持在相当不错的水平。 </p><br><p> 完成搜索并开始处理UTF-8字符串。 还有很多有趣的事情。 </p><br><h2 id="obrabotka-utf-8-strok">  UTF-8线处理 </h2><br><p> 我承认，要突破UTF-8编码字符串的幼稚实现的上限是很困难的。 拧紧SIMD特别困难。 我将分享一些有关如何执行此操作的想法。 </p><br><p> 回想一下有效的UTF-8序列是什么样的： </p><br><p><img src="https://habrastorage.org/webt/iu/xn/zu/iuxnzucrcetohvgsxb7ozohxwws.png"><br></p><br><p> 让我们尝试通过第一个字节来计算代码点的长度。 这是位魔术开始的地方。 再次，我们写一些属性： </p><br><p>  -从0xC <em>和0xD开始</em>有2个字节 <br>  -0xC2 = 11 <u>0</u> 00010 <br>  -0xDF = 11 <u>0</u> 11111 <br>  -0xE0 = 111 <u>0</u> 0000 <br>  -0xF4 = 1111 <u>0</u> 100，除了0xF4之外，没有别的，但是如果有0xF8，则情况会有所不同 <br>  -如果不是ASCII字符，则回答7减去结尾处第一个零的位置 </p><br><p> 我们计算长度： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seqLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> UInt8 first_octet)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_octet &lt; <span class="hljs-number"><span class="hljs-number">0x80</span></span>u) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> first_zero = bitScanReverse(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;UInt8&gt;(~first_octet)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> - first_zero; }</code> </pre> <br><p> 幸运的是，我们有可用的指令，可以从最高有效位开始计算零位的数量。 </p><br><pre> <code class="cpp hljs">f = __builtin_clz(val) <span class="hljs-comment"><span class="hljs-comment">// (bsrl,     ) f(2) = 30, f(8) = 28, f(7) = 29</span></span></code> </pre> <br><p> 计算bitScanReverse： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitScanReverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> - __builtin_clz(x); }</code> </pre> <br><p> 让我们尝试通过SIMD通过代码点计算UTF-8字符串的长度。 为此，将每个字节视为带符号的数字，并注意以下属性： </p><br><p>  -0xBF = -65 <br>  -0x80 = -128 <br>  -0xC2 = -62 <br>  -0x7F = 127 <br>  -所有的第一个字节都在[0xC2，0x7F]中 <br>  -所有非首字节均位于[0x80，0xBF]中 </p><br><p> 该算法非常简单。 将每个字节与-65进行比较，如果大于此数字，则加1。 如果要使用SIMD，则通常是输入流中16字节的负载。 然后是一个字节比较，如果结果为正，则为字节0xFF，如果结果为负，则为0x00。 然后是<code>pmovmskb</code>指令，它将收集寄存器每个字节的高位。 然后下划线的数量增加，我们将内部函数用于<code>popcnt</code> SSE4指令。 该算法的方案可以通过一个例子说明： </p><br><p><img src="https://habrastorage.org/webt/gn/mh/q5/gnmhq5lwynwpkdmqe2k3xsowxfs.png"><br></p><br><p> 事实证明，随着解压缩，每个内核的处理速度约为1.5 GB / s。 </p><br><p> 这些函数称为： </p><br><p>  <code>lengthUTF8(string)</code> -返回正确编码的UTF-8字符串的长度，某些东西被认为是无效的，不会引发异常。 </p><br><p> 我们走得更远，因为我们希望通过UTF-8字符串处理获得更多功能。 例如，检查有效性并转换为有效的UTF-8表达式。 </p><br><p> 为了检查有效性，我采用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/cyb70289/utf8/</a> ，它适用于ClickHouse（实际上只是改变了尾部的处理），并且获得了1.22 GB / s的速度，而朴素算法的速度为900 MB / s。 。 我不会描述算法本身，它对于感知来说相当复杂。 </p><br><p>  <code>isValidUTF8(string)</code> -如果字符串已使用UTF-8正确编码，则返回1，否则返回0。 <br>  <code>toValidUTF8(string)</code> -用 （U + FFFD）字符替换无效的UTF-8字符。 所有连续的无效字符都折叠为一个替换字符。 没有火箭科学。 </p><br><p> 通常，在UTF-8线路中，由于静态方案不太理想，因此总是很难提出经过优化的方案。 </p><br><h2 id="chto-dalshe"> 接下来是什么？ </h2><br><p> 让我提醒您，这是我的论文。 当然，我为她辩护10/10。 我们已经和她一起去了Highload ++ Siberia（尽管在我看来，她对任何人都没什么兴趣）。 观看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示</a> 。 我喜欢论文的实践部分导致了很多有趣的研究。 这就是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文凭</a>本身。 它有很多错别字，因为没人读。  :) </p><br><p> 作为准备文凭的一部分，我做了很多其他类似的工作（链接导致合并请求）： </p><br><p>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">优化的concat功能2倍</a> ； <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">制作最简单的python格式的请求</a> ； <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-LZ4加速了4％</a> ； <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我在ARM和PPC64LE的SIMD方面做得很好</a> ; <br>  -他还为一些FCS的学生提供了ClickHouse文凭的建议。 </p><br><p> 最后，根据我的经验， <del> 勒莎每个月都想念我 </del>  ClickHouse是用于编写高性能代码的最令人愉悦的系统，其中提供文档，注释，出色的开发人员和devops支持。  ClickHouse确实很棒。 厌倦了转换JSON格式？ 来Lesha询问任何级别的任务-他将为您提供该任务，并且在周末，您将从编写代码中获得极大的乐趣。 </p><br><p> 但是，随着ClickHouse及其设计的所有成就，可能与他们无关。 不主要在他们。 </p><br><p> 我在FCS经历了4年的本科学习，6月以优异的成绩从HSE毕业，在Yandex一支很棒的团队工作了一年半，表现出色。 一直没有经验 <del> 和铁 </del> 帖子中写的任何内容都行不通。 如果您从中获取最大收益，那么FCN非常酷。 感谢Vana Puzyrevsky <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">ivan_puzyrevskiy</a> ，Ignat Kolesnichenko，Gleb Evstropov，Max Babenko <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">maxim_babenko</a>参加了我在FCN上的有趣冒险。 同时还要感谢所有教给我一些知识的老师。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN466183/">https://habr.com/ru/post/zh-CN466183/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN466165/index.html">人工智能如何帮助管理项目</a></li>
<li><a href="../zh-CN466169/index.html">JetBrains在职学生的特别优惠</a></li>
<li><a href="../zh-CN466171/index.html">选择JUG.EKB的五个理由</a></li>
<li><a href="../zh-CN466179/index.html">fform：React＆JSONSchema-最大的灵活性</a></li>
<li><a href="../zh-CN466181/index.html">C语言的Python（C API）</a></li>
<li><a href="../zh-CN466187/index.html">Unity3d的可视逻辑编辑器。 第二部分</a></li>
<li><a href="../zh-CN466191/index.html">美国网络中立之战的主要内容是事件的时间顺序和当前的事务状态</a></li>
<li><a href="../zh-CN466193/index.html">从RSS提要自定义MailChimp自动提要</a></li>
<li><a href="../zh-CN466195/index.html">PVS-Studio 7.04</a></li>
<li><a href="../zh-CN466197/index.html">PVS-Studio 7.04</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>