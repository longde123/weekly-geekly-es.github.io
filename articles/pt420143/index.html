<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ê ü§≤ üí∞ Desempenho do Kotlin no Android üë©üèø üíÇ üèµÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vamos falar hoje sobre o desempenho do Kotlin no Android em produ√ß√£o. Vamos dar uma olhada, implementar otimiza√ß√µes complicadas, comparar o c√≥digo de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desempenho do Kotlin no Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/420143/">  Vamos falar hoje sobre o desempenho do Kotlin no Android em produ√ß√£o.  Vamos dar uma olhada, implementar otimiza√ß√µes complicadas, comparar o c√≥digo de bytes.  Finalmente, abordaremos seriamente a compara√ß√£o e mediremos os benchmarks. <br><br>  Este artigo √© baseado em um relat√≥rio de <strong>Alexander Smirnov</strong> no AppsConf 2017 e ajudar√° a descobrir se √© poss√≠vel escrever c√≥digo no Kotlin, que n√£o ser√° inferior ao Java em velocidade. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AqeKHDKJ4To" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre o palestrante:</strong> Alexander Smirnov, CTO da PapaJobs, administra o blog de v√≠deo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Android no Faces</a> e tamb√©m √© um dos organizadores da comunidade Mosdroid. <br><a name="habracut"></a><br>  Vamos come√ßar com suas expectativas. <br><br><blockquote>  Voc√™ acha que o Kotlin em tempo de execu√ß√£o √© mais lento que o Java?  Ou mais r√°pido?  Ou talvez n√£o haja muita diferen√ßa?  Afinal, ambos trabalham no bytecode que a m√°quina virtual nos fornece. </blockquote><br>  Vamos acertar.  Tradicionalmente, quando surge a quest√£o de comparar o desempenho, todo mundo quer ver refer√™ncias e n√∫meros espec√≠ficos.  Infelizmente, para o Android n√£o existe JMH ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java Microbenchmark Harness</a> ), ent√£o n√£o podemos medir o qu√£o legal isso pode ser feito em Java.  Ent√£o, o que podemos fazer para fazer a medi√ß√£o, conforme descrito abaixo? <br><br><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startTime = System.nanoTime() work() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> System.nanoTime() - startTime } adb shell dumpsys gfxinfo %package_name%</code> </pre> <br>  Se voc√™ tentar medir seu c√≥digo dessa maneira, um dos desenvolvedores do JMH ficar√° triste, chorar√° e vir√° at√© voc√™ em um sonho - nunca fa√ßa isso. <br><br>  No Android, voc√™ pode fazer benchmarks, em particular, o Google demonstrou isso na E / S do ano passado.  Eles disseram que melhoraram muito a m√°quina virtual, neste caso, ART, e se no Android 4.1 uma aloca√ß√£o de um objeto levasse de 600 a 700 nanossegundos, na oitava vers√£o levaria cerca de 60 nanossegundos.  I.e.  eles foram capazes de medi-lo com tanta precis√£o em uma m√°quina virtual.  Por que n√£o podemos fazer isso - n√£o temos essas ferramentas. <br><br>  Se examinarmos toda a documenta√ß√£o, a √∫nica coisa que podemos encontrar √© a recomenda√ß√£o acima, como medir a interface do usu√°rio: <br><br>  <strong>adb shell dumpsys gfxinfo% package_name%</strong> <br><br>  Na verdade, vamos fazer dessa maneira e ver no final o que isso dar√°.  Mas primeiro, determinaremos o que mediremos e o que mais podemos fazer. <br><br><blockquote>  A pr√≥xima pergunta.  Onde voc√™ acha que o desempenho √© importante quando voc√™ cria um aplicativo de primeira classe? <br><br><ol><li>  Definitivamente em todo lugar. </li><li>  Thread da interface do usu√°rio. </li><li>  Visualiza√ß√£o personalizada + anima√ß√µes. </li></ol><br></blockquote><br><img src="https://habrastorage.org/webt/h3/hi/0n/h3hi0n8douh0daoayii6yono2lo.jpeg"><br><br>  Acima de tudo, gosto da primeira op√ß√£o, mas √© mais prov√°vel que seja imposs√≠vel fazer com que todo o c√≥digo funcione muito, muito rapidamente e √© importante que pelo menos n√£o haja UiThread ou exibi√ß√£o personalizada.  Eu tamb√©m concordo com isso - √© muito, muito importante.  O fato de que em seu fluxo JSON separado ser√° desserializado por 10 milissegundos a mais ser√° que ningu√©m notar√°. <br><br>  A psicologia da Gestalt diz que, quando piscamos, por cerca de 150 a 300 milissegundos, o olho humano est√° desfocado e n√£o v√™ o que realmente est√° acontecendo ali.  E ent√£o esses 10 milissegundos de tempo n√£o.  Mas se voltarmos √† psicologia da gestalt, √© importante n√£o o que realmente vejo e o que realmente acontece, mas o que entendo como usu√°rio √© importante. <br><br>  I.e.  se fizermos o usu√°rio pensar que ele tem tudo muito, muito r√°pido, mas na verdade ele ser√° simplesmente superado, por exemplo, com a ajuda de uma bela anima√ß√£o, ele ficar√° satisfeito, mesmo que de fato n√£o seja. <br><br>  Os motivos da psicologia da Gestalt no iOS est√£o mudando h√° algum tempo.  Portanto, se voc√™ pegar dois aplicativos com o mesmo tempo de processamento, mas em plataformas diferentes, e coloc√°-los lado a lado, parece que no iOS tudo √© mais r√°pido.  A anima√ß√£o no iOS processa um pouco mais r√°pido, a anima√ß√£o anterior inicia na inicializa√ß√£o e muitas outras anima√ß√µes, para que fique bonita. <br><br>  Portanto, a <strong>primeira regra √© pensar no usu√°rio.</strong> <br><br>  E para a segunda regra, voc√™ precisa mergulhar no hardcore. <br><br><h2>  KOTLIN STYLE <br></h2><br>  Para avaliar honestamente o desempenho do Kotlin, o compararemos com o Java.  Portanto, √© imposs√≠vel medir algumas coisas que est√£o apenas no Kotlin, por exemplo: <br><br><ul><li>  Cole√ß√£o Api. </li><li>  Par√¢metros padr√£o do m√©todo. </li><li>  Classes de dados. </li><li>  Tipos reificados. </li><li>  Corotinas. </li></ul><br>  <strong>A API de coleta</strong> que o Kotlin nos fornece √© muito legal, muito r√°pida.  Em Java, isso simplesmente n√£o existe, existem apenas implementa√ß√µes diferentes.  Por exemplo, a biblioteca da API do Liteweight Stream API ser√° mais lenta porque faz tudo igual ao Kotlin, mas com uma ou duas aloca√ß√µes adicionais para a opera√ß√£o, pois tudo se transforma em um objeto adicional. <br><br>  Se pegarmos a API Stream do Java 8, ela funcionar√° mais lentamente que a API Kotlin Collection, mas com uma condi√ß√£o - n√£o h√° paralisia na API Collection, se incluirmos paralelo, em grandes volumes de dados da API Stream, O Java ignorar√° a API do Kotlin Collection.  Portanto, n√£o podemos comparar essas coisas, porque realizamos a compara√ß√£o precisamente do ponto de vista do Android. <br><br>  A segunda coisa que, ao que me parece, n√£o pode ser comparada, s√£o <strong>os par√¢metros padr√£o do m√©todo</strong> - um recurso muito interessante, que, ali√°s, est√° no Dart.  Quando voc√™ chama algum m√©todo, ele pode ter alguns par√¢metros que podem ter algum valor, mas podem ser NULL.  E, portanto, voc√™ n√£o cria 10 m√©todos diferentes, mas executa um m√©todo e diz que um dos par√¢metros pode ser NULL e, no futuro, use-o sem nenhum par√¢metro.  I.e.  ele olhar√°, o par√¢metro chegou ou ele n√£o chegou.  √â muito conveniente que voc√™ possa escrever muito menos c√≥digo, mas o inconveniente √© que voc√™ deve pagar por isso.  Este √© o a√ß√∫car sint√°tico: voc√™, como desenvolvedor, pensa que este √© um m√©todo de API, mas, na realidade, sob o cap√¥, cada varia√ß√£o do m√©todo com par√¢metros ausentes √© gerada no bytecode.  E cada um desses m√©todos tamb√©m verifica pouco a pouco se esse par√¢metro chegou.  Se veio, ok, se n√£o, criamos uma m√°scara de bit e, dependendo dessa m√°scara de bit, o m√©todo original que voc√™ escreveu √© realmente chamado.  Opera√ß√µes bit a bit, todas custam um pouco de dinheiro, mas muito pouco, e √© normal que voc√™ pague por conveni√™ncia.  Parece-me que isso √© absolutamente normal. <br><br>  O pr√≥ximo item que n√£o pode ser comparado √© <strong>Classes de dados</strong> . <br><br>  Todo mundo chora que em Java existem par√¢metros para os quais existem classes de modelo.  I.e.  voc√™ pega par√¢metros e faz mais m√©todos, getters e setters para todos esses par√¢metros.  Acontece que, para uma turma com dez par√¢metros, voc√™ ainda precisa de todo um conjunto de getters, setters e muito mais.  Al√©m disso, se voc√™ n√£o usar geradores, precisar√° escrever com as m√£os, o que geralmente √© terr√≠vel. <br><br>  Kotlin permite que voc√™ fique longe de tudo.  Primeiro, como existem propriedades no Kotlin, voc√™ n√£o precisa escrever getters e setters.  N√£o possui <strong>par√¢metros de classe, todas as propriedades</strong> .  De qualquer forma, achamos que sim.  Em segundo lugar, se voc√™ escrever que essas s√£o classes de dados, um monte de tudo o mais ser√° gerado.  Por exemplo, equals (), toStrung () / hasCode (), etc. <br><br>  Obviamente, isso tamb√©m tem desvantagens.  Por exemplo, eu n√£o precisava que todos os 20 par√¢metros de minhas classes de dados fossem comparados ao mesmo tempo em meus iguais (), eu s√≥ precisava comparar 3. Algu√©m n√£o gosta de tudo isso porque o desempenho √© perdido nisso e, al√©m disso, muito √© gerado fun√ß√µes de servi√ßo e o c√≥digo compilado √© bastante volumoso.  Ou seja, se voc√™ escrever tudo manualmente, haver√° menos c√≥digo do que se voc√™ usar classes de dados. <br><br>  Eu n√£o uso classes de dados por outro motivo.  Anteriormente, havia restri√ß√µes √† expans√£o de tais classes e outras coisas.  Agora todo mundo est√° melhor com isso, mas o h√°bito permanece. <br><br>  O que √© muito, muito legal no Kotlin e o que sempre ser√° mais r√°pido que o Java?  <strong>S√£o os tipos Reified</strong> , que, a prop√≥sito, tamb√©m est√£o em Dart. <br><br>  Voc√™ sabe que quando voc√™ usa gen√©ricos, o apagamento de tipo √© apagado no est√°gio de compila√ß√£o e, em tempo de execu√ß√£o, voc√™ n√£o sabe mais qual objeto desse gen√©rico √© realmente usado. <br><br>  Com os tipos Reified, voc√™ n√£o precisa usar a reflex√£o em muitos lugares quando precisaria em Java, porque com os m√©todos inline √© com a Reified que voc√™ conhece o tipo e, portanto, verifica-se que voc√™ n√£o usa a reflex√£o e seu c√≥digo funciona mais r√°pido.  A magia <br><br>  E h√° <strong>Coroutines</strong> .  Eles s√£o muito legais, eu gosto muito deles, mas no momento do desempenho eles foram inclu√≠dos apenas na vers√£o alfa, portanto n√£o foi poss√≠vel fazer compara√ß√µes corretas com eles. <br><br><h2>  CAMPOS <br></h2><br>  Ent√£o, vamos em frente, vamos para o que podemos comparar com Java e o que podemos influenciar em geral. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = B() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = a + b <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> e = ca + cb } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre><br>  Como eu disse, n√£o temos par√¢metros para a classe, temos propriedades. <br><br>  Temos var, temos val, temos uma classe externa, uma das propriedades √© @JvmField, e veremos o que realmente acontece com a fun√ß√£o work (): somamos o valor dos campos a e b de nossa pr√≥pria classe e valores do campo ae campo b da classe externa, escritos no campo imut√°vel c. <br><br>  A quest√£o √© como, de fato, ser√° chamado em d = a + b.  Todos sabemos que, uma vez que essa propriedade, o getter dessa classe ser√° chamado para esse par√¢metro. <br><br><pre> <code class="hljs cmake"> L0 LINENUMBER <span class="hljs-number"><span class="hljs-number">10</span></span> L0 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.a : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.b : I IADD ISTORE <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Mas se olharmos para o bytecode, veremos que o getfield est√° realmente sendo acessado.  Ou seja, isso no bytecode n√£o √© uma chamada para a fun√ß√£o InvokeVirtual, mas um acesso direto ao campo.  Inicialmente, nada nos foi prometido, que possu√≠mos todas as propriedades, n√£o os campos.  Acontece que Kotlin est√° nos enganando, h√° um apelo direto. <br><br>  O que acontece se vermos o bytecode gerado para outra linha: val e = ca + cb? <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L1</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">11</span></span> L1 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">GETFIELD</span></span> kotlin/Ba : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/B.getB ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Anteriormente, se voc√™ estava acessando uma propriedade privada, sempre tinha uma chamada InvokeVirtual.  Se essa era uma propriedade privada, o acesso a ela era atrav√©s do GetField.  GetField √© muito mais r√°pido que o InvokeVirtual, a especifica√ß√£o do Android afirma que acessar um campo diretamente √© 3 a 7 vezes mais r√°pido.  Portanto, √© recomend√°vel que voc√™ sempre consulte o Field, e n√£o atrav√©s de getters ou setters.  Agora, especialmente na oitava m√°quina virtual ART, j√° haver√° n√∫meros diferentes, mas se voc√™ ainda suportar o 4.1, isso ser√° verdade. <br><br>  Portanto, verifica-se que ainda √© ben√©fico termos o GetField, e n√£o o InvokeVirtual. <br><br>  Agora, voc√™ pode obter o GetField se estiver acessando uma propriedade de sua pr√≥pria classe ou, se for uma propriedade p√∫blica, voc√™ deve definir @JvmField.  Ent√£o, exatamente o mesmo no bytecode ser√° uma chamada GetField, que √© 3 a 7 vezes mais r√°pida. <br><br>  √â claro que aqui falamos em nanossegundos e, com um trono, √© muito, muito pequeno.  Mas, por outro lado, se voc√™ fizer isso no thread da interface do usu√°rio, por exemplo, no m√©todo ondraw, voc√™ acessa algum tipo de exibi√ß√£o, isso afetar√° a renderiza√ß√£o de cada quadro e voc√™ poder√° faz√™-lo um pouco mais r√°pido. <br><br>  <strong>Se somarmos todas as otimiza√ß√µes, em suma, isso pode dar alguma coisa.</strong> <br><br><h2>  EST√ÅTICO!? <br></h2><br>  E a est√°tica?  Todos sabemos que no Kotlin a est√°tica √© um objeto complementar.  Anteriormente, voc√™ provavelmente adicionava algum tipo de tag, por exemplo, est√°tica p√∫blica, est√°tica final etc., se converter isso em c√≥digo Kotlin, voc√™ receber√° um objeto complementar, que escrever√° algo como o seguinte: <br><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br><blockquote>  Voc√™ acha que essa entrada √© id√™ntica √† declara√ß√£o final est√°tica padr√£o em Java?  √â est√°tico ou n√£o? </blockquote><br>  Sim, de fato, Kotlin declara que aqui est√° em Kotlin - est√°tico, esse objeto diz que √© est√°tico.  Na realidade, isso n√£o √© est√°tico. <br><br>  Se observarmos o bytecode gerado, veremos o seguinte: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.getK ()I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Um Test.Companion √© gerado; um objeto singleton para o qual a inst√¢ncia √© criada, essa inst√¢ncia √© gravada em seu pr√≥prio campo.  Depois disso, o acesso a um objeto complementar ocorre atrav√©s desse objeto.  Ele pega getstatic, isto √©, uma inst√¢ncia est√°tica dessa classe e chama a fun√ß√£o getK invokevirtual nela, e exatamente o mesmo para a fun√ß√£o work2.  Ent√£o entendemos que n√£o √© est√°tico. <br><br>  Isso importa, porque nas JVMs mais antigas, o invokestatic era cerca de 30% mais r√°pido que o invokevirtual.  Agora, √© claro, no HotSpot, a virtualiza√ß√£o otimizada est√° ficando muito legal e √© quase invis√≠vel.  No entanto, √© preciso ter isso em mente, especialmente porque h√° uma aloca√ß√£o extra, e um local extra no 4ST1 √© de 700 nanossegundos em excesso. <br><br>  Vejamos o c√≥digo Java que sai se voc√™ implantar novamente o bytecode: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Test.k;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ Test.k = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br>  Um campo est√°tico √© criado, uma implementa√ß√£o final est√°tica do objeto Companion, getters e setters s√£o criados e, como voc√™ pode ver, referindo-se ao campo est√°tico interno, um m√©todo est√°tico adicional √© exibido.  Tudo √© triste o suficiente. <br><br>  O que podemos fazer, certificando-se de que n√£o √© est√°tico?  Podemos tentar adicionar @JvmField e @JvmStatic e ver o que acontece. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> i = k + work2() <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> JvmStatic <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br>  Diremos imediatamente que voc√™ n√£o vai se afastar do @JvmStatic, ser√° o mesmo objeto, j√° que esse √© um objeto complementar, haver√° uma aloca√ß√£o extra desse objeto e uma chamada extra. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br>  Mas a chamada mudar√° apenas para k, porque ser√° @JvmField, ser√° tomada diretamente como getstatic, getters e setters n√£o ser√£o mais gerados.  Mas para a fun√ß√£o work2, nada mudar√°. <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.k : I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  A segunda op√ß√£o sobre como criar est√°tica √© proposta na documenta√ß√£o do Kotlin, por isso √© dito que podemos apenas criar um objeto, e este ser√° um c√≥digo est√°tico. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">53</span></span> }</code> </pre><br>  Na realidade, isso tamb√©m n√£o √© assim. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">L3</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">23</span></span> L3 GETSTATIC kotlin/A.INSTANCE : Lkotlin/A; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/A.test ()I POP</code> </pre><br>  Acontece que fazemos uma chamada de inst√¢ncia getstatic de singletone, que √© criada, e chamamos exatamente os mesmos m√©todos virtuais. <br><br>  A √∫nica maneira de obtermos invocest√°ticos s√£o as fun√ß√µes de ordem superior.  Quando apenas escrevemos alguma fun√ß√£o fora da classe, por exemplo, o divertido teste2 ser√° realmente chamado de est√°tico. <br><br><pre> <code class="hljs kotlin"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">99</span></span> L4 LINENUMBER <span class="hljs-number"><span class="hljs-number">24</span></span> L4 INVOKESTATIC kotlin/TestKt.test2 ()I POP</code> </pre><br>  Al√©m disso, o mais interessante √© que uma classe ser√° criada, um objeto, neste caso testKt, gerar√° um objeto para si, gerar√° uma fun√ß√£o que ele coloca nesse objeto e agora ser√° chamada de invocativa. <br><br>  Por que isso foi feito √© incompreens√≠vel.  Muitos est√£o descontentes com isso, mas h√° quem considere essa implementa√ß√£o bastante normal.  Desde a m√°quina virtual, incl.  A arte est√° melhorando, agora n√£o √© t√£o cr√≠tica.  Na oitava vers√£o do Android, assim como no HotSpot, tudo √© otimizado, mas essas pequenas coisas ainda afetam levemente o desempenho geral. <br><br><h2>  NULABILIDADE <br></h2><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> : String { second ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>  Este √© o pr√≥ximo exemplo interessante.  Parece que observamos que o segundo pode ser anul√°vel e deve ser verificado antes de fazer qualquer coisa com ele.  Nesse caso, espero que tenhamos um se.  Quando esse c√≥digo √© implantado se o segundo n√£o for igual a zero, acho que a execu√ß√£o ir√° al√©m e produzir√° apenas primeiro. <br><br>  Como isso realmente se desenrola no c√≥digo java?  Na verdade, haver√° um cheque. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first,@Nullable String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> second != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? (first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second) : first; }</code> </pre><br>  Obteremos Intrinsics inicialmente.  Digamos que eu digo que este <br><br>  Se expandir√° para um operador tern√°rio.  Al√©m disso, embora tenhamos fixado que o primeiro par√¢metro n√£o pode ser anul√°vel, ele ainda ser√° verificado atrav√©s do Intrinsics. <br><br>  Intrinsics √© uma classe interna no Kotlin que possui um determinado conjunto de par√¢metros e verifica√ß√µes.  E toda vez que voc√™ torna o par√¢metro do m√©todo n√£o nulo, ele o verifica de qualquer maneira.  Porque  Ent√£o, trabalhamos no Interop Java e pode acontecer que voc√™ espere que n√£o seja anul√°vel aqui, mas com o Java ele vir√° de algum lugar. <br><br>  Se voc√™ marcar isso, ele ir√° al√©m do c√≥digo e, depois de 10 a 20 chamadas ao m√©todo, voc√™ far√° algo com um par√¢metro que, embora possa n√£o ser nulo, mas por alguma raz√£o acabou sendo.  Tudo cair√° para voc√™ e voc√™ n√£o ser√° capaz de entender o que realmente aconteceu.  Para evitar essa situa√ß√£o, sempre que voc√™ passar o par√¢metro nulo, voc√™ ainda precisar√° verific√°-lo.  E se for anul√°vel, haver√° uma exce√ß√£o. <br><br>  Essa verifica√ß√£o tamb√©m vale alguma coisa e, se houver muitas delas, n√£o ser√° muito boa. <br><br>  Mas, de fato, se falarmos sobre HotSpot, 10 chamadas desses intr√≠nsecos levar√£o cerca de quatro nanossegundos.  Isso √© muito, muito pequeno, e voc√™ n√£o deve se preocupar com isso, mas esse √© um fator interessante. <br><br><h2>  PRIMITIVOS <br></h2><br>  Em Java, existem coisas como primitivas.  Em Kotlin, como todos sabemos, n√£o existem primitivos, sempre operamos com objetos.  Em Java, eles s√£o usados ‚Äã‚Äãpara fornecer maior desempenho para objetos em alguns c√°lculos menores.  Adicionar dois objetos √© muito mais caro do que adicionar duas primitivas.  Considere um exemplo. <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bOption : <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br>  Existem tr√™s n√∫meros, para os dois primeiros o tipo n√£o nulo ser√° deduzido e, no terceiro, dizemos que pode ser anul√°vel. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer bOption = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre><br>  Se voc√™ olhar para o bytecode e ver qual c√≥digo Java √© gerado, os dois primeiros n√∫meros n√£o ser√£o nulos e, portanto, poder√£o ser primitivos.  Mas o primitivo n√£o pode conter Nulo, apenas um objeto pode fazer isso; portanto, um objeto ser√° gerado para o terceiro n√∫mero. <br><br><h2>  AUTOBOXING <br></h2><br>  Ao trabalhar com primitivos e executar uma opera√ß√£o com um primitivo e n√£o primitivo, voc√™ precisar√° converter um deles em um primitivo ou em um objeto. <br><br>  E, ao que parece, n√£o √© surpreendente que, se voc√™ fizer opera√ß√µes com valor nulo e n√£o com valor nulo no Kotlin, perder√° um pouco de desempenho.  Al√©m disso, se houver muitas dessas opera√ß√µes, voc√™ perder√° muito. <br><br><pre> <code class="hljs scala"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-type"><span class="hljs-type">String</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = a?.isBlank() == <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  Veja onde o boxe / unboxing estar√° aqui?  Tamb√©m n√£o vi at√© olhar o bytecode. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; a.isBlank()) <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre><br>  Na verdade, eu esperava que houvesse algo como essa compara√ß√£o: se a sequ√™ncia n√£o for nula e estiver vazia, defina como true, caso contr√°rio, defina como false.  Tudo parece ser simples, mas, na realidade, o seguinte c√≥digo √© gerado: <br><br><pre> <code class="java hljs">String a = (String)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> b = Intrinsics.areEqual(a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? Boolean.valueOf(StringsKt.isBlank((CharSequence)a)) : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, Boolean.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>));</code> </pre><br>  Vamos olhar para dentro.  A vari√°vel <em>a √©</em> obtida, √© convertida em CharSequence, depois de lan√ßada, que tamb√©m foi gasta por algum tempo, outra verifica√ß√£o √© chamada - StringsKt.isBlank - √© assim que a fun√ß√£o de extens√£o para CharSequence √© gravada e, portanto, convertida e enviada.  Como a primeira express√£o pode ser anul√°vel, ela pega e executa Boxing e agrupa tudo em Boolean.valueOf.  Portanto, o verdadeiro primitivo tamb√©m se torna um objeto, e somente depois disso a verifica√ß√£o j√° ocorre e o Intrinsics.areEqual √© chamado. <br><br>  Parece uma opera√ß√£o t√£o simples, mas um resultado inesperado.  De fato, existem muito poucas coisas assim.  Mas quando voc√™ pode ter anul√°vel / n√£o anul√°vel, pode gerar muitas dessas coisas e algo que voc√™ nunca esperaria.  Portanto, recomendo que voc√™ evite a obscuridade o mais r√°pido poss√≠vel.  I.e.  <strong>chegue √† imunidade de valores o mais cedo poss√≠vel e afaste-se de anul√°vel</strong> para que voc√™ n√£o opere o mais r√°pido poss√≠vel. <br><br><h2>  Loops <br></h2><br>  A pr√≥xima coisa interessante. <br><br>  Voc√™ pode usar o usual para, que est√° em Java, mas tamb√©m pode usar a nova API conveniente - escrever a enumera√ß√£o de elementos na lista imediatamente. ,      work,  it  -   . <br><br><pre> <code class="hljs pgsql">list.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">work</span></span>(it * <span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre><br>         .  ,    .    ,     Google,  ,       ArrayList   for   3  ,   .        . <br><br>    ,    ArrayList,     ‚Äî   foreach. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; size) { action(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(i)) i++ } } list.foreach { }</code> </pre><br>    API,     -  .     ,    Kotlin:   extension ,   ¬´¬ª,    reified, ..    ,    ,   ,    crossinline.      ,  ,    .  3  ,      Android  Google. <br><br><h2> RANGES <br></h2><br>        Ranges. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..size) { work(i * <span class="hljs-number"><span class="hljs-number">2</span></span>) } }</code> </pre><br>     : Unit     -.        ‚àí1,  until ,   ,    .   ,    ,    ranges.  I.e.   ,     .           step.    . <br><br><h2> INTRINSICS <br></h2><br> -  Intrinsics,      : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>    Intrinsics    ‚Äî   second,   first. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first, @NotNull String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); Intrinsics.checkParameterIsNotNull(second, <span class="hljs-string"><span class="hljs-string">"second"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second; } }</code> </pre><br>   ,      gradle.   ,    -     4 ,      .     Kotlin  UI,    ,       nullable,    Kotlin : <br><br> <strong>kotlinc -Xno-call-assertions -Xno-param-assertions Test.kt</strong> <br><br>   Intrinsics,    ,   . <br><br>   ,     ,      .   ‚Äî Xno-param-assertions ‚Äî    Intrinsics,     . <br><br>    ,     ,     ,    ,     ,    .    ,    ,     ,    . <br><br><h2> REDEX <br></h2><br>  ,    ,    ,   Proguard.    ,   99%  ,     ,   .  Android 8.0  ,    .   ,      . <br><br>  ,    Proguard,   Facebook,   <strong>Redex</strong> .      -,        ,        . ,  Jvm Fields     ,         . <br><br>  ,  Redex   .  ,    ,      ,    Proguard,   ,    .          Redex    7%   APK.  ,   . <br><br><h2> BENCHMARKS </h2><br>   .     ,       ,     .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ,        . ,   dumpsys gfxinfo     ,       .   github  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>github.com/smred</strong></a>      . <br><br> ,     Huawei. <br><img src="https://habrastorage.org/webt/hm/nf/hb/hmnfhbvpmrfyg6aapr_z7u5pbws.jpeg"><br><br>       .  ‚Äî ,     .     ,    ,    0,04 . ,  ,        ‚Äî   ,         . <br><img src="https://habrastorage.org/webt/jo/kg/ov/jokgovmpmtwe_h6gsdrmohvzi5g.jpeg"><br><br>      Kotlin,      .  ,    ,     .  - ,     Kotlin  ,   Java.    , , ,     ,      .       . <br><img src="https://habrastorage.org/webt/je/h5/tm/jeh5tm5-oyprnnvzjaegqemeecs.jpeg"><br><br> , ,    ,      ,  Kotlin          Java. , -    , ,  ,    ,    ,        . <br><img src="https://habrastorage.org/webt/k8/6o/c6/k86oc6tr5tnegbzvtizkhddnyz4.jpeg"><br><br> ,   : -      Kotlin       , ..   .       ,     .    -             -  ‚Äî   2  ,    Galaxy S6,     . <br><img src="https://habrastorage.org/webt/ix/ud/d2/ixudd25fkc3zje65vwseoo7xkzm.jpeg"><br><br>    Google Pixel.     ,    0,1 . <br><br><h1>  <br></h1><br>  ,   ,    ,  <br><br><ul><li>     UI   custom view. </li><li>    onmeasure-onlayout-ondraw.     autoboxing, not null   .. </li><li>       Kotlin,      Java ,        . </li><li>   ‚Äî . </li></ul><br>  ,   ,       .  ,  ,    , , Kotlin,     .       ,  Kotlin             . <br><br>    ,      . <br><br><blockquote>        brand new <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppsConf</a> ,        Android   . ,      . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ,   8  9       . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420143/">https://habr.com/ru/post/pt420143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420131/index.html">M√©todo Probabil√≠stico de Minera√ß√£o de Bitcoin</a></li>
<li><a href="../pt420133/index.html">Modelagem de sistemas din√¢micos: como a lua se move?</a></li>
<li><a href="../pt420135/index.html">Isso tamb√©m √© Toshiba: produtos inesperados da corpora√ß√£o japonesa</a></li>
<li><a href="../pt420139/index.html">Livro ‚ÄúSite Confiabilidade Engenharia. Confiabilidade e confiabilidade como no Google ¬ª</a></li>
<li><a href="../pt420141/index.html">No MPP DBMS carregado - peppy Data Lake com ferramentas anal√≠ticas: compartilhe os detalhes da cria√ß√£o</a></li>
<li><a href="../pt420145/index.html">Como √© o dia √∫til dos membros do PC AppsConf</a></li>
<li><a href="../pt420147/index.html">C√≥digo aberto no Clojure</a></li>
<li><a href="../pt420151/index.html">Mais f√°cil do que parece. Cap√≠tulo 12</a></li>
<li><a href="../pt420153/index.html">Impress√£o 3D de pe√ßas complexas feitas de ABS e PLA com muito suporte</a></li>
<li><a href="../pt420155/index.html">SSD do Intel Datacenter. Grandes volumes e novos nomes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>