<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖋️ 🍗 🎚️ iOS中应用程序的本地化。 第1部分。我们有什么？ 💩 🏼 💆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="iOS中应用程序的本地化 
 第1部分。我们有什么？ 


 本地化字符串资源指南 
 引言 


 几年前，我进入了iOS开发的神奇世界，从本质上讲，它为我带来了IT领域的美好未来。 但是，在深入研究平台和开发环境的功能时，在解决看似微不足道的任务时，我遇到了许多困难和不便之处：苹果公司的“创新的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS中应用程序的本地化。 第1部分。我们有什么？</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419077/"><h1 id="lokalizaciya-prilozheniy-v-ios">  iOS中应用程序的本地化 </h1><br><h2 id="chast-1-chto-my-imeem"> 第1部分。我们有什么？ </h2><br><p>  <strong><em>本地化字符串资源指南</em></strong> </p><br><h3 id="vvedenie"> 引言 </h3><br><p> 几年前，我进入了iOS开发的神奇世界，从本质上讲，它为我带来了IT领域的美好未来。 但是，在深入研究平台和开发环境的功能时，在解决看似微不足道的任务时，我遇到了许多困难和不便之处：苹果公司的“创新的保守主义”有时使开发人员变得非常老练，从而满足了无限的“ WANT”客户。 </p><br><p> 这些问题之一是本地化应用程序的字符串资源的问题。 我想将我在哈勃（Habr）的广阔著作中的第一批出版物投入到这个问题上。 </p><a name="habracut"></a><br><p> 最初，我希望将自己的想法写在一篇文章中，但是我想介绍的信息量很大。 在本文中，我将尝试揭示使用本地化资源的标准机制的本质，重点是大多数指南和教程所忽略的某些方面。 该材料主要针对初学者（或尚未经历过此类任务的开发人员）。 对于有经验的开发人员，此信息可能不是特别有价值。 但是关于实践中可能会遇到的不便和不利之处，我会在未来告诉大家... </p><br><h3 id="iz-pod-korobki-kak-organizovano-hranenie-strokovyh-resursov-v-ios-prilozheniyah"> 开箱即用。 如何在iOS应用程序中组织字符串资源的存储 </h3><br><p> 首先，我们注意到平台中的本地化机制已经是一个巨大的优势，因为 使程序员免于进行额外的开发，并设置了用于处理数据的单一格式。 通常，基本机制足以实施相对较小的项目。 </p><br><p> 那么，Xcode为我们提供了“开箱即用”的机会吗？ 首先，让我们看一下在项目中存储字符串资源的标准。 </p><br><p>在具有静态内容的项目中，字符串数据可以直接存储在界面中（ <em><code>.storyboard</code></em>和<em><code>.storyboard</code></em>标记文件，它们依次是使用<em>Interface Builder</em>工具呈现的XML文件）或代码中。 第一种方法使我们能够简化并加快标记屏幕和单个显示器的过程，因为 开发人员无需构建应用程序即可观察到大部分更改。 但是，在这种情况下，不难实现数据冗余（如果多个元素使用相同的文本，则显示）。 第二种方法只是消除了数据冗余的问题，但是导致需要手动填充屏幕（通过设置其他<em><code>IBOutlet</code></em>并为其分配相应的文本值），这反过来又导致了代码冗余（当然，除非文本应由应用程序代码直接安装）。 </p><br><p> 此外，Apple提供了标准文件扩展名<em><code>.strings</code></em> 。 该标准规范了以关联数组（ <code>"-"</code> ）的形式存储字符串数据的格式： </p><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"key"</span></span> = <span class="hljs-string"><span class="hljs-string">"value"</span></span>;</code> </pre> <br><p> 该键区分大小写，允许使用空格，下划线，标点符号和特殊字符。 </p><br><p> 重要的是要注意，尽管语法简单明了，但<em>字符串</em>文件是应用程序的编译，汇编或操作期间的常规错误源。 这有几个原因。 </p><br><p> 首先，语法错误。 缺少分号，等号，多余或未转义的引号将不可避免地导致编译器错误。 此外，Xcode将指向带有错误的文件，但不会突出显示出现错误的行。 查找此类错字可能需要花费大量时间，尤其是在文件中包含大量数据的情况下。 </p><br><p> 其次，重复密钥。 该应用程序当然不会因此而崩溃，但是可能会向用户显示不正确的数据。 问题是，当按键访问一行时，对应于文件中最后一次出现的键的值将被拉出。 </p><br><p> 结果，简单的设计要求程序员在用数据填充文件时要非常透彻和专心。 </p><br><p><del> 知识渊博 </del> 开发人员可以立即惊呼： <em>“但是JSON和PLIST呢？他们不满意呢？”</em> 好吧，首先， <em><code>JSON</code></em>和<em><code>PLIST</code></em> （实际上是普通的<em><code>XML</code></em> ）是通用标准，允许同时存储字符串和数字，逻辑（ <em><code>BOOL</code></em> ），二进制数据，时间和日期以及索引集（ <em><code>Array</code></em> ）和关联性（ <em><code>Dictionary</code></em> ）数组。 因此，这些标准的语法更加饱和，因此更容易被它们所蚕食。 其次，再次由于复杂的语法，此类文件的处理速度略低于Strings文件。 更不用说要与他们合作，您需要在代码中进行许多操作。 </p><br><h3 id="lokalizovali-lokalizovali-da-ne-vylokalizovali-lokalizaciya-polzovatelskogo-interfeysa"> 本地化，本地化但不本地化。 用户界面本地化 </h3><br><p> 因此，在找出标准之后，现在让我们找出如何使用所有标准。 </p><br><p> 让我们去吧。 首先，创建一个简单的<em>Single View Application</em>并将一些文本组件添加到<em>ViewController</em>的<em>Main.storyboard</em>上。 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/310/a0b/c0d/310a0bc0df4192cd2ab87ad46407666a.png" width="50%" height="50%"><br><br><p> 在这种情况下，内容直接存储在界面中。 要对其进行本地化，必须执行以下操作： </p><br><p>  1）转到项目设置 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/b9e/0bb/f6e/b9e0bbf6eb66b5d8acb88ee3b29fd45c.png" width="50%" height="50%"><br><br><p>  2）然后-从<strong><em>目标</em></strong>到<strong><em>项目</em></strong> </p><br><img src="https://habrastorage.org/getpro/habr/post_images/bb5/bf0/334/bb5bf033410cedeb98e3e46399637d7b.png" width="50%" height="50%"><br><br><p>  3）打开<strong><em>信息</em></strong>标签 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/324/5bd/cdd/3245bdcdd605153e52668fd795f65720.png" width="50%" height="50%"><br><br><p> 在“ <strong><em>本地化”部分中</em></strong> ，我们立即看到我们已经有了条目<em>“英语-开发语言”</em> 。 这意味着将英语设置为开发语言（或默认语言）。 </p><br><p> 现在添加另一种语言。 为此，请单击“ <strong>+</strong> ”并选择所需的语言（例如，我选择了俄语）。 关心Xcode立即为我们提供了选择要添加的语言本地化的文件。 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/781/801/3ae/7818013aee9b0574048779957404bb31.png" width="50%" height="50%"><br><br><p> 点击<strong>完成</strong> ，看看发生了什么。 在项目导航器中，用于显示嵌套的按钮出现在所选文件的附近。 通过单击它们，我们看到先前选择的文件包含创建的本地化文件。 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/5b0/882/089/5b0882089822427b954eb7ce5e497048.png" width="35%" height="35%"><br><br><p> 例如， <strong><em><code>Main.storyboard (Base)</code></em></strong>是基本开发语言中的默认接口标记文件，并且在对其进行本地化时，成对创建了关联的<strong><em><code>Main.strings (Russian)</code></em></strong> -俄罗斯本地化的字符串文件。 打开它，您将看到以下内容： </p><br><pre> <code class="hljs vbscript">/* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UILabel"</span></span>; text = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo.text"</span></span> = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UITextField"</span></span>; placeholder = <span class="hljs-string"><span class="hljs-string">"TextField"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N.placeholder"</span></span> = <span class="hljs-string"><span class="hljs-string">"TextField"</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UIButton"</span></span>; normalTitle = <span class="hljs-string"><span class="hljs-string">"Button"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2.normalTitle"</span></span> = <span class="hljs-string"><span class="hljs-string">"Button"</span></span>;</code> </pre> <br><p> 通常，这里一切都很简单，但是为了清楚起见，我们将更详细地考虑，注意由有爱心的Xcode生成的注释： </p><br><pre> <code class="hljs vbscript">/* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UILabel"</span></span>; text = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo.text"</span></span> = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>;</code> </pre> <br><p> 这是<strong><em><code>UILabel</code></em></strong>类的实例，其<strong><em><code>text</code></em></strong>参数值为<strong><em><code>"Label"</code></em></strong> 。  <strong><em><code>ObjectID</code></em></strong>标记文件中对象的标识符-这是在将其放置在<em><code>Storyboard/Xib</code></em>上时分配给任何组件的唯一行。 密钥是由对象<em><code>ObjectID</code></em>和对象的参数名称（在这种情况下为<em><code>text</code></em> ）组成的，记录本身可以按如下方式正式解释： </p><br><p> 将tQe-tG-eeo对象的text参数设置为Label。 </p><br><p> 在此记录中，仅“ <em>值</em> ”可以更改。 将“ <em>标签</em> ”替换为“ <em>标签</em> ”。 我们将对其他对象执行相同的操作。 </p><br><pre> <code class="hljs vbscript">/* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UILabel"</span></span>; text = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo.text"</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UITextField"</span></span>; placeholder = <span class="hljs-string"><span class="hljs-string">"TextField"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N.placeholder"</span></span> = <span class="hljs-string"><span class="hljs-string">" "</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UIButton"</span></span>; normalTitle = <span class="hljs-string"><span class="hljs-string">"Button"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2.normalTitle"</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>;</code> </pre> <br><p> 我们启动我们的应用程序。 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/9e7/85a/332/9e785a3328aff1923329541d31447672.png" width="50%" height="50%"><br><br><p> 但是我们看到了什么？ 该应用程序使用基本本地化。 如何检查我们是否正确转帐？ </p><br><p> 在这里值得做一些小小的改动，并在iOS平台的功能和应用程序结构的方向上进行一些挖掘。 </p><br><p> 首先，请考虑在添加本地化的过程中更改项目的结构。 这是添加俄语本地化之前项目目录的外观： </p><br><img src="https://habrastorage.org/getpro/habr/post_images/bb3/0b2/f07/bb30b2f0799f2c7ce2433aa7ec2350fc.png" width="50%" height="50%"><br><br><p> 之后： </p><br><img src="https://habrastorage.org/getpro/habr/post_images/ae7/a10/b14/ae7a10b14491da04c89ce8e456cf5ac1.png" width="50%" height="50%"><br><br><p> 如我们所见，Xcode创建了一个新目录<em><code>ru.lproj</code></em> ，在其中放置了创建的本地化字符串。 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/ceb/ca2/ff5/cebca2ff5edaae9d6a1398f9e41e7652.png" width="50%" height="50%"><br><br><p> 完成的iOS应用程序的Xcode项目的结构在哪里？ 尽管事实上这有助于更好地了解平台的功能，以及直接在最终应用程序中分配和存储资源的原理。 最重要的是，在组装Xcode项目时，除了生成可执行文件之外，环境还将资源（ <em>情节提要/ Xib</em>界面布局文件，图像，行文件等）传输到完成的应用程序中，从而保留了在开发阶段指定的层次结构。 </p><br><p> 为了使用此层次结构，Apple提供了<em><code>Bundle(NSBundle)</code></em>类<em><code>Bundle(NSBundle)</code></em> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">免费翻译</a> ）： </p><br><blockquote>  Apple使用<strong><code>Bundle</code></strong>提供对应用程序，框架，插件和许多其他类型内容的访问。 捆绑包将资源组织到明确定义的子目录中，并且捆绑包结构因平台和类型而异。 使用<em><code>bundle</code></em> ，可以访问包的资源而无需了解其结构。  <em><code>Bundle</code></em>是一个用于搜索元素的界面，其中考虑了包的结构，用户需求，可用的本地化以及其他相关因素。 <br>  <strong>搜索和发现资源</strong> <br> 在开始使用资源之前，必须指定其<em><code>bundle</code></em> 。  <strong><code>Bundle</code></strong>类具有许多构造函数，但<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">main是</a></strong>最常用的。  <em><code>Bundle.main</code></em>提供了包含当前可执行代码的目录的路径。 这样， <em><code>Bundle.main</code></em>提供对当前应用程序使用的资源的访问。 </blockquote><p> 考虑使用<strong><em><code>FileManager</code></em></strong>类的<em><code>Bundle.main</code></em>结构： </p><br><img src="https://habrastorage.org/getpro/habr/post_images/60f/e0f/8b3/60fe0f8b3bb62a0db757f06f999e8065.png" width="65%" height="65%"><br><br><p> 基于上述内容，我们可以得出以下结论：在加载应用程序时， <em><code>Bundle.main</code></em>形成了<em><code>Bundle.main</code></em> ，并分析了当前设备的本地化（系统语言），应用程序本地化和本地化资源。 然后，应用程序从所有可用的本地化中选择一种与系统当前语言相对应的本地化，并提取相应的本地化资源。 如果没有匹配项，则使用默认目录中的资源（在我们的示例中，英语为本地化，因为英语被定义为开发语言，因此可以忽略对资源的其他本地化的需求）。 如果将设备语言更改为俄语并重新启动应用程序，则界面将已经对应于俄语本地化。 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/47e/e24/6fe/47ee246fec532a890503019af1bfc91c.png" width="50%" height="50%"><br><br><p> 但是在关闭通过<em>Interface Builder</em>本地化用户界面的主题之前，值得注意另一种值得注意的方式。 创建本地化文件时（通过向项目或本地化文件检查器中添加新语言），很容易注意到Xcode提供了选择要创建的文件类型的能力： </p><br><img src="https://habrastorage.org/getpro/habr/post_images/272/aa5/cb3/272aa5cb38ea6b2a4178edc911296982.png" width="35%" height="35%"><br><br><p> 您可以轻松地创建一个本地化的<em><code>Storyboard/Xib</code></em> ，而不是一个线文件，该文件将保存基本文件的所有标记。 这种方法的一大优点是，开发人员可以立即查看如何以特定语言显示内容，并立即更正屏幕的布局，尤其是在文本量不同或使用了另一个方向（例如阿拉伯语，希伯来语）的情况下，更是如此。 。 但是同时，创建其他<em>Storyboard / Xib</em>文件会大大增加应用程序本身的大小（同样，字符串文件占用的空间要少得多）。 </p><br><p> 因此，在选择一种或另一种接口本地化方法时，值得考虑哪种方法在特定情况下会更合适和实用。 </p><br><h3 id="do-it-yourself-rabota-s-lokalizovannymi-strokovymi-resursami-v-kode"> 自己动手。 在代码中使用本地化的字符串资源 </h3><br><p> 希望有了静态内容，一切都差不多了。 但是直接在代码中设置的文本呢？ </p><br><p>  iOS操作系统的开发人员负责此工作。 </p><br><p> 为了使用本地化的文本资源，Foundation框架在<strong><em>Swift中</em></strong>提供了<strong><em><code>NSLocalizedStrings</code></em></strong>系列方法。 </p><br><pre> <code class="hljs sql">NSLocalizedString(_ key: String, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>) NSLocalizedString(_ <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>, tableName: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>?, bundle: Bundle, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>)</code> </pre> <br><p> 和<strong><em>Objective-C中的</em></strong>宏 </p><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedString</span></span>(key, comment) <span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedStringFromTable</span></span>(key, tbl, comment) <span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedStringFromTableInBundle</span></span>(key, tbl, bundle, comment) <span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedStringWithDefaultValue</span></span>(key, tbl, bundle, val, comment)</code> </pre> <br><p> 让我们从显而易见的地方开始。  <strong><em><code>key</code></em></strong>参数是Strings文件中的字符串键；  <strong><em><code>val</code></em></strong> （默认值）-如果指定的密钥不在文件中，则使用默认值；  <strong><em><code>comment</code></em></strong> -（不太明显）对本地化字符串的简短描述（实际上，它不具有有用的功能，并且旨在解释使用特定字符串的目的）。 </p><br><p> 至于参数<em><code>tableName</code></em> （ <em><code>tbl</code></em> ）和<em><code>bunble</code></em> ，则应更详细地考虑它们。 </p><br><p>  <strong><em><code>tableName</code></em></strong> （ <strong><em><code>tbl</code></em></strong> ）是String文件的名称（说实话，我不知道Apple为什么将其称为表），该文件包含指定键所需的行； 传输时，未指定<em><code>.string</code></em>扩展名。 在表之间导航的功能使您不必将字符串资源存储在一个文件中，而是可以自行决定分配它们。 这使您可以消除文件拥塞，简化编辑，并最大程度地减少错误发生的机会。 </p><br><p>  <strong><em><code>bundle</code></em></strong>参数进一步扩展了资源导航。 如前所述， <em>捆绑</em>是一种访问应用程序资源的机制，也就是说，我们可以独立确定资源的来源。 </p><br><p> 多一点。 我们将直接进入<strong><em>基金会，</em></strong>并考虑方法的声明（宏），以获得更清晰的画面，因为 绝大多数教程只是忽略了这一点。  <em>Swift</em>框架不是非常有用： </p><br><pre> <code class="hljs vhdl">/// Returns a localized <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, using the main bundle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> one <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> specified. public func NSLocalizedString(_ key: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, tableName: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>? = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, bundle: Bundle = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, value: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, comment: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span></code> </pre> <br><p>  <em>“主捆绑包返回本地化的字符串”</em> -我们所拥有的。  <em>Objective-C</em>有点不同。 </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define NSLocalizedString(key, comment) \ [NSBundle.mainBundle localizedStringForKey:(key) value:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> table:nil] #define NSLocalizedStringFromTable(key, tbl, comment) \ [NSBundle.mainBundle localizedStringForKey:(key) value:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> table:(tbl)] #define NSLocalizedStringFromTableInBundle(key, tbl, bundle, comment) \ [bundle localizedStringForKey:(key) value:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> table:(tbl)] #define NSLocalizedStringWithDefaultValue(key, tbl, bundle, val, comment) \ [bundle localizedStringForKey:(key) value:(val) table:(tbl)]</span></span></code> </pre> <br><p> 在这里，您已经可以清楚地看到，除了<strong><em><code>bundle</code></em></strong> （在前两种情况下， <em><code>mainBundle</code></em> ）对字符串资源文件起作用之外，其他一切都与接口本地化情况相同。 当然，考虑到上一段中的<em><code>Bundle</code></em> （ <em><code>NSBundle</code></em> ）类，我可以立即说出来，但是那时该信息没有特别的实用价值。 但是在使用代码行的情况下，这不能说。 实际上， <strong><em>基金会</em></strong>提供的全局功能只是标准捆绑方法的包装，其主要任务是使代码更加简洁和安全。 没有人禁止手动初始化<em><code>bundle</code></em>并直接代表<em><code>bundle</code></em>访问资源，但是以这种方式出现（尽管非常小）形成循环链接和内存泄漏的可能性。 </p><br><p> 下面的示例将描述如何使用全局函数和宏。 </p><br><p> 让我们看看它是如何工作的。 <br> 首先，创建一个字符串文件，其中将包含我们的字符串资源。 将其命名为Localizable.strings *并将其添加到其中。 </p><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"testKey"</span></span> = <span class="hljs-string"><span class="hljs-string">"testValue"</span></span>;</code> </pre> <br><p>  （ <em>字符串文件的本地化与</em>情节提要/ Xib <em>完全相同</em> <em>，因此，我将不描述此过程。我们将俄语本地化文件</em> <em>中的</em> <em>“</em> testValue <em>”</em> <em>替换</em> <em>为“</em> test value *”。） </p><br><p>  <strong>重要！</strong> 在iOS中，具有此名称的文件是默认的字符串资源文件，即 如果您未指定<em><code>tableName</code></em> （ <em><code>tbl</code></em> ）表名，则应用程序将自动关闭<strong><em><code>Localizable.strings</code></em></strong> 。 </p><br><p> 将以下代码添加到我们的项目中 </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-string"><span class="hljs-string">"String for 'testKey': "</span></span> + NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"testKey"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"String for 'testKey': %@", NSLocalizedString(@"testKey", @""));</span></span></code> </pre> <br><p> 并运行该项目。 执行代码后，控制台中将出现一行 </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'testKey'</span></span>: testValue</code> </pre> <br><p> 一切正常！ </p><br><p> 与接口本地化的示例类似，更改本地化并运行应用程序。 代码执行的结果将是 </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'testKey'</span></span>:  </code> </pre> <br><p> 现在，让我们尝试通过键获取值，该键不在<em><code>Localizable.strings</code></em>文件中： </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-string"><span class="hljs-string">"String for 'unknownKey': "</span></span> + NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"unknownKey"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"String for 'unknownKey': %@", NSLocalizedString(@"unknownKey", @""));</span></span></code> </pre> <br><p> 这样的代码执行的结果将是 </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'unknownKey'</span></span>: unknownKey</code> </pre> <br><p> 由于文件中没有密钥，因此该方法将返回密钥本身。 如果这样的结果是不可接受的，那么最好使用该方法 </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-string"><span class="hljs-string">"String for 'testKey': "</span></span> + NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"unknownKey"</span></span>, tableName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, bundle: Bundle.main, value: <span class="hljs-string"><span class="hljs-string">"noValue"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"String for 'testKey': %@", NSLocalizedStringWithDefaultValue(@"unknownKey", nil, NSBundle.mainBundle, @"noValue", @""));</span></span></code> </pre> <br><p> 其中有一个<strong><em><code>value</code></em></strong>参数（ <em>默认值</em> ）。 但是在这种情况下，您必须指定资源的来源<em><code>bundle</code></em> 。 </p><br><p> 本地化字符串支持插值机制，类似于标准iOS字符串。 为此，请使用字符串文字（ <em><code>%@</code></em> ， <em><code>%li</code></em> ， <em><code>%f</code></em>等）将记录添加到字符串文件中，例如： </p><br><pre> <code class="hljs perl"><span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span> = <span class="hljs-string"><span class="hljs-string">"String with %@: %li, %f"</span></span>;</code> </pre> <br><p> 要输出这样的行，必须添加以下形式的代码 </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-name"><span class="hljs-name">String</span></span>(<span class="hljs-name"><span class="hljs-name">format</span></span>: NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>), <span class="hljs-string"><span class="hljs-string">"some"</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">123.098</span></span> ))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"%@", [NSString stringWithFormat: NSLocalizedString(@"stringWithArgs", @""), @"some", 123, 123.098]);</span></span></code> </pre> <br><p> 但是在使用此类设计时，您需要非常小心！ 事实是，iOS严格监视参数的数量，参数顺序，类型与指定文字的对应关系。 因此，例如，如果您将字符串替换为第二个参数而不是整数值 </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-name"><span class="hljs-name">String</span></span>(<span class="hljs-name"><span class="hljs-name">format</span></span>: NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>), <span class="hljs-string"><span class="hljs-string">"some"</span></span>, <span class="hljs-string"><span class="hljs-string">"123"</span></span>, <span class="hljs-number"><span class="hljs-number">123.098</span></span> ))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"%@", [NSString stringWithFormat: NSLocalizedString(@"stringWithArgs", @""), @"some", @"123", 123.098]);</span></span></code> </pre> <br><p> 那么应用程序将用字符串<strong><em>“ 123”</em></strong>的整数代码代替不匹配的位置 </p><br><pre> <code class="hljs sql">"String <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span>: <span class="hljs-number"><span class="hljs-number">4307341664</span></span>, <span class="hljs-number"><span class="hljs-number">123.089000</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><p> 如果您跳过它，我们得到 </p><br><pre> <code class="hljs sql">"String <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">123.089000</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><p> 但是，如果您跳过参数列表中与<strong><em><code>%@</code></em></strong>对应的对象 </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-name"><span class="hljs-name">String</span></span>(<span class="hljs-name"><span class="hljs-name">format</span></span>: NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>), <span class="hljs-string"><span class="hljs-string">"123"</span></span>, <span class="hljs-number"><span class="hljs-number">123.098</span></span> ))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"%@", [NSString stringWithFormat: NSLocalizedString(@"stringWithArgs", @""), @"123", 123.098]);</span></span></code> </pre> <br><p> 那么应用程序只会在代码执行时崩溃。 </p><br><h3 id="push-me-baby-lokalizaciya-uvedomleniy"> 推我，宝贝！ 通知本地化 </h3><br><p> 我想简单地谈一谈使用本地化的字符串资源的另一项重要任务是本地化通知。 最重要的是，大多数教程（有关<em><code>Push Notifications</code></em>和<em><code>Localizable Strings</code></em> ）通常都忽略了这个问题，而且这样的任务并不罕见。 因此，当开发人员第一次遇到这个问题时，可能会遇到一个合理的问题： <em>原则上这可能吗？</em> 我不会在这里考虑<em><code>Apple Push Notification Service</code></em>操作机制，尤其是因为从iOS 10.0开始，Push和本地通知是通过相同的框架<strong><code>UserNotifications</code></strong> 。 </p><br><p> 开发多语言客户端-服务器应用程序时，您必须面对类似的问题。 当这样的任务第一次遇到我时，我想到的第一件事就是摆脱服务器端消息本地化的问题。 这个想法非常简单：应用程序在启动时将当前本地化发送到<em>后端</em> ，并且服务器在发送<em>push</em>时选择适当的消息。 但是问题很快就解决了：如果设备的本地化发生了变化，并且应用程序没有重新启动（没有更新数据库中的数据），则服务器将发送与上一次“注册”本地化相对应的文本。 而且，如果将应用程序一次安装在具有不同系统语言的多台设备上，则整个实现将像地狱一样工作。 由于这样的解决方案对我而言似乎是最疯狂的拐杖，因此我立即开始寻找适当的解决方案（很有趣，但是在许多论坛中，“开发人员”建议完全将<em>后端</em>定位在本地）。 </p><br><p> 正确的决定非常简单，尽管并不完全显而易见。 代替服务器在<em>APNS</em>上发送的标准<em>JSON</em> </p><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"body"</span></span> : <span class="hljs-string"><span class="hljs-string">"some message"</span></span>; }; };</code> </pre> <br><p> 需要发送形式的<em>JSON</em> </p><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"message localized key"</span></span>; }; };</code> </pre> <br><p> 其中<strong><em><code>loc-key</code></em></strong>用于传递<strong><em><code>Localizable.strings</code></em></strong>文件中的本地化字符串关键字。 因此，根据设备的当前位置显示推送消息。 </p><br><p> 在<em>推式</em>通知中插值本地化字符串的机制以类似的方式工作： </p><br><pre> <code class="hljs powershell"> <span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"message localized key"</span></span>; <span class="hljs-string"><span class="hljs-string">"loc-args"</span></span> : [ <span class="hljs-string"><span class="hljs-string">"First argument"</span></span>, <span class="hljs-string"><span class="hljs-string">"Second argument"</span></span> ]; }; };</code> </pre> <br><p>  <strong><em><code>loc-args</code></em></strong>键传递一个参数数组，该参数必须嵌入本地化的通知文本中。 </p><br><h3 id="podytozhim"> 总结一下... </h3><br><p> 因此，我们到底有什么？ </p><br><ul><li> 使用简单且可访问的语法将字符串数据存储在专用<strong><em><code>.string</code></em></strong>文件中的标准； </li><li> 无需在代码中进行其他操作即可对接口进行本地化的能力； </li><li> 通过代码快速访问本地化资源； </li><li> 使用Xcode工具自动生成本地化文件并构建项目目录（应用程序）的资源； </li><li> 本地化通知文本的能力。 </li></ul><br><p>  , Xcode           ,          . </p><br><p>               . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN419077/">https://habr.com/ru/post/zh-CN419077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN419065/index.html">虚拟世界英特尔。 练习</a></li>
<li><a href="../zh-CN419067/index.html">如何出售个人数据，或为什么很难在信息上加上价格标签</a></li>
<li><a href="../zh-CN419069/index.html">全球变暖将使我们的世界更加绿色，但不要高兴</a></li>
<li><a href="../zh-CN419071/index.html">继TP链接黑客</a></li>
<li><a href="../zh-CN419075/index.html">关于Collat​​z假设（3n +1）中序列的形成</a></li>
<li><a href="../zh-CN419085/index.html">大爆炸之前的奇异想法已经过时</a></li>
<li><a href="../zh-CN419089/index.html">玩骰子时如何作弊-游戏专家提示</a></li>
<li><a href="../zh-CN419091/index.html">我们中间的放射性物体</a></li>
<li><a href="../zh-CN419095/index.html">我们写的CSS更好，更漂亮</a></li>
<li><a href="../zh-CN419097/index.html">Mambot-孕妇电报中的机器人</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>