<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏾 🍮 🖊️ Résoudre une tâche à partir d'une interview Google sur JavaScript: 4 façons différentes 🐁 🙎🏿 🧑🏽‍🤝‍🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsque j'étudiais les performances des algorithmes, je suis tombé sur cette vidéo de la fausse interview de Google . Il donne non seulement une idée ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Résoudre une tâche à partir d'une interview Google sur JavaScript: 4 façons différentes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillbox/blog/443886/"><img src="https://habrastorage.org/getpro/habr/post_images/83f/a6b/8bb/83fa6b8bb04adab1ec1067682d5a2fd1.jpg"><br><br>  Lorsque j'étudiais les performances des algorithmes, je suis tombé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette vidéo de la fausse interview de Google</a> .  Il donne non seulement une idée de la façon dont les entretiens sont organisés dans les grandes sociétés technologiques, mais vous permet également de comprendre comment les problèmes algorithmiques sont résolus, et plus efficacement. <br><br>  Cet article est une sorte d'accompagnement de la vidéo.  Dans ce document, je donne des commentaires sur toutes les solutions présentées, ainsi que ma propre version de la solution en JavaScript.  Les nuances de chaque algorithme sont également discutées. <br><a name="habracut"></a><br><blockquote>  <b>Nous vous rappelons:</b> <i>pour tous les lecteurs de «Habr» - une remise de 10 000 roubles lors de l'inscription à un cours Skillbox en utilisant le code promo «Habr».</i> <br><br>  <b>Skillbox recommande:</b> Cours pratique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Mobile Developer PRO"</a> . <br></blockquote><br><h3>  Énoncé du problème </h3><br>  On nous donne un tableau ordonné et une valeur spécifique.  Ensuite, ils demandent de créer une fonction qui renvoie vrai ou faux, selon que la somme de deux nombres quelconques du tableau peut être égale à la valeur donnée. <br><br>  En d'autres termes, y a-t-il deux entiers x et y dans le tableau qui, une fois ajoutés, sont égaux à la valeur spécifiée? <br><br>  <b>Exemple A</b> <br><br>  Si on nous a donné un tableau [1, 2, 4, 9] et une valeur de 8, la fonction retournera false, car aucun nombre du tableau ne peut donner 8 au total. <br><br>  <b>Exemple B</b> <br><br>  Mais s'il s'agit d'un tableau [1, 2, 4, 4] et que la valeur est 8, la fonction doit retourner true, car 4 + 4 = 8. <br><br>  <b>Solution 1. Bruteforce</b> <br><br>  <i>Difficulté temporelle: O (N²).</i> <i><br></i>  <i>Complexité spatiale: O (1).</i> <br><br>  La signification la plus évidente consiste à utiliser une paire de boucles imbriquées. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arr.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; arr.length; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i !== j &amp;&amp; arr[i] + arr[j] === val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; }; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre> <br>  Cette solution ne peut pas être qualifiée d’efficace, car elle vérifie chaque somme possible de deux éléments du tableau et compare également deux fois chaque paire d’indices.  (Par exemple, lorsque i = 1 et j = 2 - c'est en fait la même chose que la comparaison avec i = 2 et j = 1, mais dans cette solution, nous essayons les deux options). <br><br>  Puisque notre solution utilise une paire de boucles imbriquées, elle est quadratique avec une complexité temporelle de O (N²). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/BretCameron/embed/preview/aMLOyb" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Solution 2. Recherche binaire (binaire)</b> <br><br>  <i>Difficulté temporelle: O (Nlog (N)).</i> <i><br></i>  <i>Complexité spatiale: O (1)</i> . <br><br>  Puisque les tableaux sont ordonnés, nous pouvons rechercher une solution en utilisant la recherche binaire.  Il s'agit de l'algorithme le plus efficace pour les tableaux ordonnés.  La recherche binaire elle-même a un runtime O (log (N)).  Cependant, vous devez toujours utiliser une boucle for pour comparer chaque élément à toutes les autres valeurs. <br><br>  Voici à quoi pourrait ressembler la solution.  Pour que tout soit clair, nous utilisons une fonction distincte pour contrôler la recherche binaire.  Ainsi que la fonction removeIndex (), qui renvoie la version du tableau moins l'index spécifié. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arr.length; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binarySearch(removeIndex(arr, i), val - arr[i])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> removeIndex = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, i</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, i).concat(arr.slice(i + <span class="hljs-number"><span class="hljs-number">1</span></span>, arr.length)); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> binarySearch = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> end = arr.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pivot = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(arr.length / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (start &lt; end) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val &lt; arr[pivot]) { end = pivot - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val &gt; arr[pivot]) { start = pivot + <span class="hljs-number"><span class="hljs-number">1</span></span>; }; pivot = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((start + end) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[pivot] === val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre> <br>  L'algorithme commence à l'index [0].  Ensuite, il crée une version du tableau, à l'exclusion du premier index, et utilise une recherche binaire pour vérifier si l'une des valeurs restantes peut être ajoutée au tableau pour obtenir la quantité souhaitée.  Cette action est effectuée une fois pour chaque élément du tableau. <br><br>  La boucle for elle-même aura une complexité temporelle linéaire de O (N), mais à l'intérieur de la boucle for, nous effectuons une recherche binaire, qui donne la complexité temporelle totale de O (Nlog (N)).  Cette solution est meilleure que la précédente, mais il y a encore quelque chose à améliorer. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/BretCameron/embed/preview/MxEYdB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Solution 3. Temps linéaire</b> <br><br>  <i>Difficulté temporelle: O (N).</i> <i><br></i>  <i>Complexité spatiale: O (1).</i> <br><br>  Nous allons maintenant résoudre le problème en nous souvenant que le tableau est trié.  La solution consiste à prendre deux nombres: un au début et un à la fin.  Si le résultat diffère de celui requis, nous modifions les points de début et de fin. <br><br>  En fin de compte, soit nous atteignons la valeur souhaitée et retournons vrai, soit les points de début et de fin convergent et retournent faux. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> end = arr.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (start &lt; end) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = arr[start] + arr[end]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum &gt; val) { end -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum &lt; val) { start += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/BretCameron/embed/preview/jJGERY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Maintenant tout va bien, la solution semble être optimale.  Mais qui garantira que la baie a été commandée? <br><br><h3>  Et alors? </h3><br>  À première vue, nous pourrions simplement trier le tableau en premier, puis utiliser la solution ci-dessus.  Mais comment cela affectera-t-il l'exécution? <br><br>  Le meilleur algorithme est un tri rapide avec une complexité temporelle O (Nlog (N)).  Si nous l'utilisons dans notre solution optimale, il changera ses performances de O (N) à O (Nlog (N)).  Est-il possible de trouver une solution linéaire avec un tableau non ordonné? <br><br>  <b>Décision 4</b> <br><br>  <i>Difficulté temporelle: O (N).</i> <i><br></i>  <i>Complexité spatiale: O (N).</i> <br><br>  Oui, une solution linéaire existe, pour cela vous devez créer un nouveau tableau contenant une liste de correspondances que nous recherchons.  Le compromis ici est une utilisation plus active de la mémoire: c'est la seule solution de l'article dont la complexité spatiale dépasse O (1). <br><br>  Si la première valeur de ce tableau est 1 et la valeur de recherche est 8, nous pouvons ajouter la valeur 7 au tableau de «valeurs de recherche». <br><br>  Ensuite, en traitant chaque élément du tableau, nous pouvons vérifier le tableau des «valeurs de recherche» et voir si l'un d'eux est égal à notre valeur.  Si oui, retournez vrai. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> searchValues = [val - arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; arr.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> searchVal = val - arr[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchValues.includes(arr[i])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchValues.push(searchVal); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre> <br>  La base de la solution est la boucle for, qui, comme nous l'avons vu ci-dessus, a une complexité temporelle linéaire O (N). <br><br>  La deuxième partie d'itération de notre fonction est Array.prototype.include (), une méthode JavaScript qui retournera vrai ou faux selon que le tableau contient la valeur donnée. <br><br>  Pour découvrir la complexité temporelle de Array.prototype.includes (), nous pouvons regarder le polyfill fourni par MDN (et écrit en JavaScript), ou utiliser une méthode dans le code source d'un moteur JavaScript tel que Google V8 (C ++). <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// https://tc39.github.io/ecma262/#sec-array.prototype.includes if (!Array.prototype.includes) { Object.defineProperty(Array.prototype, 'includes', { value: function(valueToFind, fromIndex) { if (this == null) { throw new TypeError('"this" is null or not defined'); } // 1. Let O be ? ToObject(this value). var o = Object(this); // 2. Let len be ? ToLength(? Get(O, "length")). var len = o.length &gt;&gt;&gt; 0; // 3. If len is 0, return false. if (len === 0) { return false; } // 4. Let n be ? ToInteger(fromIndex). // (If fromIndex is undefined, this step produces the value 0.) var n = fromIndex | 0; // 5. If n ≥ 0, then // a. Let k be n. // 6. Else n &lt; 0, // a. Let k be len + n. // b. If k &lt; 0, let k be 0. var k = Math.max(n &gt;= 0 ? n : len - Math.abs(n), 0); function sameValueZero(x, y) { return x === y || (typeof x === 'number' &amp;&amp; typeof y === 'number' &amp;&amp; isNaN(x) &amp;&amp; isNaN(y)); } // 7. Repeat, while k &lt; len while (k &lt; len) { // a. Let elementK be the result of ? Get(O, ! ToString(k)). // b. If SameValueZero(valueToFind, elementK) is true, return true. if (sameValueZero(o[k], valueToFind)) { return true; } // c. Increase k by 1. k++; } // 8. Return false return false; } }); }</span></span></code> </pre> <br>  Ici, la partie itérative de Array.prototype.include () est la boucle while à l'étape 7, qui traverse (presque) toute la longueur du tableau donné.  Cela signifie que sa complexité temporelle est également linéaire.  Eh bien, comme c'est toujours une étape derrière notre tableau principal, la complexité temporelle est O (N + (N - 1)).  En utilisant la notation Big O, nous la simplifions en O (N) - car c'est N qui a la plus grande influence avec l'augmentation de la taille d'entrée. <br><br>  Quant à la complexité spatiale, un tableau supplémentaire est nécessaire, dont la longueur reflète le tableau d'origine (moins un, oui, mais cela peut être ignoré), ce qui conduit à la complexité spatiale de O (N).  Eh bien, une utilisation accrue de la mémoire garantit une efficacité maximale de l'algorithme. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/BretCameron/embed/preview/vPeYqb" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  J'espère que cet article vous sera utile en tant que pièce jointe à une interview vidéo.  Il montre qu'un problème simple peut être résolu de plusieurs manières différentes avec différentes quantités de ressources utilisées (temps, mémoire). <br><br><blockquote>  <b>Skillbox recommande:</b> <br><br><ul><li>  Cours en ligne Applied <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Python Data Analyst</a> . <br></li><li>  Cours en ligne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Profession frontend-developer"</a> . </li><li>  Cours pratique annuel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Développeur PHP de 0 à PRO"</a> . </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443886/">https://habr.com/ru/post/fr443886/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443874/index.html">Comparaison des frameworks d'apprentissage en profondeur: TensorFlow, PyTorch, Keras, MXNet, Microsoft Cognitive Toolkit, Caffe, etc.</a></li>
<li><a href="../fr443876/index.html">Nous développons un bot Telegram pour suivre les films sur NodeJS et TypeScript</a></li>
<li><a href="../fr443878/index.html">DEV Labs 2019. Python pour résoudre des tâches non triviales. Mitap en ligne</a></li>
<li><a href="../fr443882/index.html">MOSDROID # 15 Phosphorus: vidéo de performance</a></li>
<li><a href="../fr443884/index.html">3 qualités clés d'un chef de produit performant: Anton Danilov</a></li>
<li><a href="../fr443894/index.html">Le quatrième niveau du multi-univers de Max Tegmark</a></li>
<li><a href="../fr443896/index.html">Dette technique comme tetris</a></li>
<li><a href="../fr443898/index.html">Clous dans la couverture du cercueil de Runet</a></li>
<li><a href="../fr443900/index.html">Comment nous mesurons la qualité et l'efficacité du développement de la documentation. Contexte et notions de base. Rapport Yandex</a></li>
<li><a href="../fr443902/index.html">Comment nous avons gagné le hackathon interne en apprenant le skibidi, la soie dentaire et le javascript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>