<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📋 🤱🏼 ♦️ Practical Go: Dicas para escrever programas suportados no mundo real ☝🏽 👧🏼 👨🏽‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo se concentra nas práticas recomendadas para escrever código Go. É composto no estilo de apresentação, mas sem os slides usuais. Vamos tent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Practical Go: Dicas para escrever programas suportados no mundo real</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441842/">  Este artigo se concentra nas práticas recomendadas para escrever código Go.  É composto no estilo de apresentação, mas sem os slides usuais.  Vamos tentar brevemente e claramente percorrer cada item. <br><br>  Primeiro, você precisa concordar sobre o significado das <i>melhores</i> práticas para uma linguagem de programação.  Aqui você pode se lembrar das palavras de Russ Cox, diretor técnico da Go: <br><br><blockquote>  Engenharia de software é o que acontece com a programação, se você adicionar o fator tempo e outros programadores. </blockquote><br>  Assim, Russ distingue entre os conceitos de <i>programação</i> e <i>engenharia de software</i> .  No primeiro caso, você escreve um programa para si mesmo; no segundo, cria um produto no qual outros programadores trabalharão com o tempo.  Engenheiros vêm e vão.  As equipes crescem ou encolhem.  Novos recursos são adicionados e os bugs são corrigidos.  Essa é a natureza do desenvolvimento de software. <br><a name="habracut"></a><br><a name="0"></a><h1>  Conteúdo </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conteúdo</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Princípios fundamentais</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Simplicidade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Legibilidade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Produtividade</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2. Identificadores</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Identificadores de nome com base na clareza e não na brevidade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comprimento do ID</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Não nomeie variáveis ​​por tipo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Use um único estilo de nomeação</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.5</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Use um único estilo de declaração</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.6</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalho para a equipe</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3. Comentários</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comentários em variáveis ​​e constantes devem descrever seu conteúdo, não o objetivo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sempre documente caracteres publicamente disponíveis</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4. Estrutura do pacote</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um bom pacote começa com um bom nome</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Evite nomes como base, comum ou util</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Volte rapidamente sem mergulhar fundo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tornar o valor nulo útil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.5</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Evitar estado do nível do pacote</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5. Estrutura do projeto</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Menos pacotes, mas maiores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O menor pacote principal</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6. estrutura da API</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">APIs de design difíceis de abusar por design</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Projetar uma API para um caso de uso básico</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Deixe as funções determinarem o comportamento desejado.</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7. Tratamento de erros</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Elimine a necessidade de tratamento de erros removendo os próprios erros</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Manipule o erro apenas uma vez</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8. Concorrência</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Faça algum trabalho o tempo todo.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Deixe o paralelismo para o chamador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nunca execute a goroutine sem saber quando vai parar</a> </li></ul></li></ul><br><a name="1"></a><h1>  1. Princípios fundamentais </h1><br>  Talvez eu seja um dos primeiros usuários do Go entre vocês, mas essa não é minha opinião pessoal.  Estes princípios básicos estão subjacentes ao próprio Go: <br><br><ol><li>  Simplicidade </li><li>  Legibilidade </li><li>  Produtividade </li></ol><br>  <i>Nota</i>  <i>Observe que eu não mencionei "desempenho" ou "simultaneidade".</i>  <i>Existem idiomas mais rápidos que o Go, mas certamente não podem ser comparados com simplicidade.</i>  <i>Existem linguagens que colocam o paralelismo como a principal prioridade, mas elas não podem ser comparadas em termos de legibilidade ou produtividade de programação.</i> <i><br><br></i>  <i>Desempenho e simultaneidade são atributos importantes, mas não tão importantes quanto simplicidade, legibilidade e produtividade.</i> <br><br><a name="1_1"></a><h2>  Simplicidade </h2><br><blockquote>  <i>“Simplicidade é um pré-requisito para a confiabilidade”</i> - Edsger Dijkstra </blockquote><br>  Por que lutar pela simplicidade?  Por que é importante que os programas Go sejam simples? <br><br>  Cada um de nós se deparou com um código incompreensível, certo?  Quando você tem medo de fazer uma alteração, porque isso interrompe outra parte do programa que você não entende e não sabe como consertar.  Essa é a dificuldade. <br><br><blockquote>  <i>“Existem duas maneiras de projetar software: a primeira é torná-lo tão simples que não há falhas óbvias, e a segunda é torná-lo tão complexo que não há falhas óbvias.</i>  <i>O primeiro é muito mais difícil. ”</i> - C.E. R. Hoar </blockquote><br>  Complexidade transforma software confiável em não confiável.  Complexidade é o que mata projetos de software.  Portanto, a simplicidade é o objetivo final da Go.  Quaisquer que sejam os programas que escrevemos, eles devem ser simples. <br><br><a name="1_2"></a><h2>  1.2  Legibilidade </h2><br><blockquote>  <i>“A legibilidade é parte integrante da manutenção”</i> - Mark Reinhold, JVM Conference, 2018 </blockquote><br>  Por que é importante que o código seja legível?  Por que devemos nos esforçar para facilitar a leitura? <br><br><blockquote>  <i>“Os programas devem ser escritos para as pessoas e as máquinas apenas os executam”</i> - Hal Abelson e Gerald Sassman, “Estrutura e interpretação de programas de computador” </blockquote><br>  Não apenas os programas Go, mas geralmente todo o software é escrito por pessoas para pessoas.  O fato de as máquinas também processarem código é secundário. <br><br>  Uma vez que o código escrito será lido repetidamente pelas pessoas: centenas, se não milhares de vezes. <br><br><blockquote>  <i>“A habilidade mais importante para um programador é a capacidade de comunicar idéias de maneira eficaz.”</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gaston Horker</a> </blockquote><br>  A legibilidade é a chave para entender o que um programa faz.  Se você não consegue entender o código, como mantê-lo?  Se o software não puder ser suportado, ele será reescrito;  e essa pode ser a última vez que sua empresa usa o Go. <br><br>  Se você está escrevendo um programa para si mesmo, faça o que funciona para você.  Mas se isso faz parte de um projeto conjunto ou o programa for usado por tempo suficiente para alterar os requisitos, funções ou o ambiente em que ele trabalha, seu objetivo é tornar o programa sustentável. <br><br>  O primeiro passo para escrever o software suportado é garantir que o código esteja claro. <br><br><a name="1_3"></a><h2>  1.3  Produtividade </h2><br><blockquote>  <i>“O design é a arte de organizar o código para que ele funcione hoje, mas sempre suporte mudanças.”</i> - Sandy Mets </blockquote><br>  Como último princípio básico, quero nomear a produtividade do desenvolvedor.  Esse é um tópico importante, mas tudo se resume à proporção: quanto tempo você gasta em trabalho útil e quanto - aguardando uma resposta de ferramentas ou andanças sem esperança em uma base de código incompreensível.  Os programadores de Go devem sentir que podem lidar com muito trabalho. <br><br>  É uma piada que a linguagem Go tenha sido desenvolvida enquanto o programa C ++ estava compilando.  A compilação rápida é um recurso essencial do Go e um fator essencial para atrair novos desenvolvedores.  Embora os compiladores estejam sendo aprimorados, em geral, a compilação de minutos em outros idiomas leva alguns segundos no Go.  Os desenvolvedores do So Go se sentem tão produtivos quanto os programadores em linguagens dinâmicas, mas sem problemas com a confiabilidade dessas linguagens. <br><br>  Se falamos fundamentalmente sobre a produtividade dos desenvolvedores, os programadores do Go entendem que a leitura do código é essencialmente mais importante do que a sua criação.  Nessa lógica, o Go chega ao ponto de usar as ferramentas para formatar todo o código em um determinado estilo.  Isso elimina a menor dificuldade em aprender o dialeto específico de um projeto específico e ajuda a identificar erros, porque eles simplesmente <i>parecem</i> errados em comparação com o código regular. <br><br>  Os programadores da Go não passam dias depurando erros estranhos de compilação, scripts de compilação complexos ou implementando código em um ambiente de produção.  E o mais importante, eles não perdem tempo tentando entender o que um colega escreveu. <br><br>  Quando os desenvolvedores do Go falam sobre <i>escalabilidade</i> , eles significam produtividade. <br><br><a name="2"></a><h1>  2. Identificadores </h1><br>  O primeiro tópico que discutiremos - <i>identificadores</i> , é sinônimo de <i>nomes</i> : nomes de variáveis, funções, métodos, tipos, pacotes e assim por diante. <br><br><blockquote>  <i>“O mau nome é um sintoma de mau design”</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dave Cheney</a> </blockquote><br>  Dada a sintaxe limitada do Go, os nomes de objetos têm um enorme impacto na legibilidade do programa.  A legibilidade é um fator chave no bom código, portanto, a escolha de bons nomes é crucial. <br><br><a name="2_1"></a><h2>  2.1  Identificadores de nome com base na clareza e não na brevidade </h2><br><blockquote>  <i>“É importante que o código seja óbvio.</i>  <i>O que você pode fazer em uma linha, você deve fazer em três. ”</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ukia Smith</a> </blockquote><br>  O Go não é otimizado para one-liners complicados ou o número mínimo de linhas em um programa.  Não otimizamos o tamanho do código fonte no disco, nem o tempo necessário para digitar o programa no editor. <br><br><blockquote>  <i>“Um bom nome é como uma boa piada.</i>  <i>Se você precisar explicar, não será mais engraçado. ”</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dave Cheney</a> </blockquote><br>  A chave da máxima clareza são os nomes que escolhemos para identificar programas.  Que qualidades são inerentes a um bom nome? <br><br><ul><li>  <b>Um bom nome é conciso</b> .  Não precisa ser o mais curto, mas não contém excesso.  Possui uma alta relação sinal / ruído. </li><li>  <b>Um bom nome é descritivo</b> .  Descreve o uso de uma variável ou constante, <i>não o</i> conteúdo.  Um bom nome descreve o resultado de uma função ou o comportamento de um método, <i>não uma</i> implementação.  O objetivo do pacote, <i>não</i> seu conteúdo.  Quanto mais precisamente o nome descreve o que identifica, melhor. </li><li>  <b>Um bom nome é previsível</b> .  Por um nome, você deve entender como o objeto será usado.  Os nomes devem ser descritivos, mas também é importante seguir a tradição.  É isso que os programadores do Go querem dizer quando dizem <i>"idiomático"</i> . </li></ul><br>  Vamos considerar em mais detalhes cada uma dessas propriedades. <br><br><a name="2_2"></a><h2>  2.2  Comprimento do ID </h2><br>  Às vezes, o estilo de Go é criticado por nomes curtos de variáveis.  Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">disse</a> Rob Pike, "os programadores da Go querem identificadores do tamanho <i>correto</i> ". <br><br>  Andrew Gerrand oferece identificadores mais longos para indicar importância. <br><br><blockquote>  <i>“Quanto maior a distância entre a declaração de um nome e o uso de um objeto, maior deve ser o nome”</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Andrew Gerrand</a> </blockquote><br>  Assim, algumas recomendações podem ser feitas: <br><br><ul><li>  Nomes curtos de variáveis ​​são bons se a distância entre a declaração e o <i>último</i> uso for pequena. <br></li><li>  Nomes de variáveis ​​longos devem se justificar;  quanto mais longos, mais importantes devem ser.  Os títulos detalhados contêm pouco sinal em relação ao peso na página. <br></li><li>  Não inclua o nome do tipo no nome da variável. <br></li><li>  Nomes constantes devem descrever o valor interno, não como o valor é usado. <br></li><li>  Prefira variáveis ​​de letra única para loops e ramificações, palavras separadas para parâmetros e valores de retorno, várias palavras para funções e declarações no nível do pacote. <br></li><li>  Prefira palavras simples para métodos, interfaces e pacotes. <br></li><li>  Lembre-se de que o nome do pacote faz parte do nome que o chamador usa para referência. </li></ul><br>  Considere um exemplo. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Age <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-comment"><span class="hljs-comment">// AverageAge returns the average age of people. func AverageAge(people []Person) int { if len(people) == 0 { return 0 } var count, sum int for _, p := range people { sum += p.Age count += 1 } return sum / count }</span></span></code> </pre> <br>  Na décima linha, uma variável do intervalo <code>p</code> declarada e é chamada apenas uma vez da próxima linha.  Ou seja, a variável permanece na página por um período muito curto.  Se o leitor estiver interessado no papel de <code>p</code> no programa, ele só precisará ler duas linhas. <br><br>  Para comparação, <code>people</code> declaradas em parâmetros de função e sete linhas ao vivo.  O mesmo vale para <code>sum</code> e <code>count</code> , para que justifiquem seus nomes mais longos.  O leitor precisa digitalizar mais códigos para encontrá-los: isso justifica os nomes mais distintos. <br><br>  Você pode escolher <code>s</code> para <code>sum</code> <code>c</code> (ou <code>n</code> ) para <code>count</code> , mas isso reduz a importância de todas as variáveis ​​no programa para o mesmo nível.  Você pode substituir as <code>people</code> por <code>p</code> , mas haverá um problema, o que chamar de variável de iteração <code>for ... range</code> .  Uma única <code>person</code> parecerá estranha, porque uma variável de iteração de curta duração recebe um nome mais longo do que vários valores dos quais é derivada. <br><br><blockquote>  <b>Dica</b> .  Separe o fluxo de funções com linhas vazias, pois as linhas vazias entre parágrafos interrompem o fluxo de texto.  Na <code>AverageAge</code> , temos três operações consecutivas.  Primeiro, verificando a divisão por zero, depois a conclusão da idade total e número de pessoas e a última - o cálculo da idade média. </blockquote><br><h3>  2.2.1  O principal é o contexto </h3><br>  É importante entender que a maioria das dicas de nomenclatura é específica ao contexto.  Eu gosto de dizer que isso é um princípio, não uma regra. <br><br>  Qual é a diferença entre <code>i</code> e <code>index</code> ?  Por exemplo, você não pode dizer inequivocamente que esse código <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index := <span class="hljs-number"><span class="hljs-number">0</span></span>; index &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s); index++ { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br>  fundamentalmente mais legível do que <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s); i++ { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br>  Acredito que a segunda opção não é pior, porque nesse caso a região <code>i</code> ou o <code>index</code> limitado pelo corpo do loop <code>for</code> , e a verbosidade adicional acrescenta pouco ao entendimento do programa. <br><br>  Mas qual dessas funções é mais legível? <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *SNMP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oid []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, index </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br>  ou <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *SNMP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br>  Neste exemplo, <code>oid</code> é uma abreviação de SNMP Object ID e a abreviação adicional para <code>o</code> força ao ler código para alternar de uma notação documentada para uma notação mais curta no código.  Da mesma forma, reduzir o <code>index</code> para <code>i</code> torna mais difícil entender, porque nas mensagens SNMP, o sub-valor de cada OID é chamado de índice. <br><br><blockquote>  <b>Dica</b> .  Não combine parâmetros formais longos e curtos em um anúncio. </blockquote><br><a name="2_3"></a><h2>  2.3  Não nomeie variáveis ​​por tipo </h2><br>  Você não chama seus animais de estimação de "cachorro" e "gato", certo?  Pelo mesmo motivo, você não deve incluir o nome do tipo no nome da variável.  Ele deve descrever o conteúdo, não seu tipo.  Considere um exemplo: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usersMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*User</code> </pre> <br>  Que bom é esse anúncio?  Vemos que este é um mapa e tem algo a ver com o <code>*User</code> Tipo de <code>*User</code> : isso provavelmente é bom.  Mas <code>usersMap</code> é <i>realmente um</i> mapa, e Go, como uma linguagem de tipo estaticamente, não permitirá o uso acidental de um nome como esse quando uma variável escalar for necessária, portanto o sufixo do <code>Map</code> é redundante. <br><br>  Considere uma situação em que outras variáveis ​​são adicionadas: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( companiesMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Company productsMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Products )</code> </pre> <br>  Agora, temos três variáveis ​​do tipo mapa: <code>usersMap</code> , <code>companiesMap</code> e <code>productsMap</code> , e todas as linhas são mapeadas para tipos diferentes.  Sabemos que esses são mapas e também sabemos que o compilador lançará um erro se tentarmos usar <code>companiesMap</code> onde o código espera <code>map[string]*User</code> .  Nessa situação, fica claro que o sufixo <code>Map</code> não melhora a clareza do código, são apenas caracteres extras. <br><br>  Sugiro evitar sufixos semelhantes ao tipo de uma variável. <br><br><blockquote>  <b>Dica</b> .  Se o nome de <code>users</code> não descrever a essência com clareza suficiente, o <code>usersMap</code> também. </blockquote><br>  Esta dica também se aplica aos parâmetros de função.  Por exemplo: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// } func WriteConfig(w io.Writer, config *Config)</span></span></code> </pre> <br>  O nome da <code>config</code> para o parâmetro <code>*Config</code> é redundante.  Já sabemos que este é <code>*Config</code> ; ele é imediatamente escrito ao lado. <br><br>  Nesse caso, considere <code>conf</code> ou <code>c</code> se a vida útil da variável for curta o suficiente. <br><br>  Se em algum momento da nossa área houver mais de um <code>*Config</code> , os nomes <code>conf1</code> e <code>conf2</code> menos significativos que o <code>original</code> e <code>updated</code> , pois os últimos são mais difíceis de serem misturados. <br><br><blockquote>  <b>Nota</b>  Não permita que nomes de pacotes roubem bons nomes de variáveis. <br><br>  O nome do identificador importado contém o nome do pacote.  Por exemplo, o tipo de <code>context</code> pacote de <code>context</code> será chamado <code>context.Context</code> .  Isso impossibilita o uso de uma variável ou tipo de <code>context</code> no seu pacote. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context context.Context, message </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br>  Isso não será compilado.  É por isso que, ao declarar o <code>context.Context</code> Tipos de <code>context.Context</code> localmente, por exemplo, nomes como <code>ctx</code> são tradicionalmente usados. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, message </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> </blockquote><br><a name="2_4"></a><h2>  2.4  Use um único estilo de nomeação </h2><br>  Outra propriedade de um bom nome é que deve ser previsível.  O leitor deve entendê-lo imediatamente.  Se esse é um nome <i>comum</i> , o leitor tem o direito de assumir que não mudou o significado da época anterior. <br><br>  Por exemplo, se o código contornar o descritor do banco de dados, sempre que o parâmetro for exibido, ele deverá ter o mesmo nome.  Em vez de todos os tipos de combinações como <code>d *sql.DB</code> , <code>dbase *sql.DB</code> , <code>DB *sql.DB</code> e <code>database *sql.DB</code> , é melhor usar uma coisa: <br><br><pre> <code class="go hljs">db *sql.DB</code> </pre> <br>  É mais fácil entender o código.  Se você <code>*sql.DB</code> <code>db</code> , saberá que é <code>*sql.DB</code> e é declarado localmente ou fornecido pelo chamador. <br><br>  Conselho semelhante em relação aos destinatários de um método;  use o mesmo nome de destinatário para cada método desse tipo.  Isso tornará mais fácil para o leitor entender o uso do receptor entre os vários métodos desse tipo. <br><br><blockquote>  <b>Nota</b>  O Contrato de Nome Curto do Destinatário da Go contradiz as recomendações expressas anteriormente.  Esse é um daqueles casos em que a escolha feita em um estágio inicial se torna o estilo padrão, como usar o <code>CamelCase</code> vez de <code>snake_case</code> . </blockquote><br><blockquote>  <b>Dica</b> .  O estilo Ir aponta para nomes de uma letra ou abreviações para destinatários derivados de seu tipo.  Pode acontecer que o nome do destinatário às vezes esteja em conflito com o nome do parâmetro no método.  Nesse caso, é recomendável aumentar um pouco o nome do parâmetro e não se esqueça de usá-lo sequencialmente. </blockquote><br>  Finalmente, algumas variáveis ​​de uma letra são tradicionalmente associadas a loops e contagem.  Por exemplo, <code>i</code> , <code>j</code> e <code>k</code> são geralmente variáveis ​​indutivas em loops, <code>n</code> geralmente associado a um contador ou somador acumulador, <code>v</code> é uma abreviação típica de valor em uma função de codificação, <code>k</code> geralmente usado para uma chave de mapa e <code>s</code> frequentemente usado como uma abreviação de parâmetros do tipo <code>string</code> . <br><br>  Como no exemplo <code>db</code> acima, os programadores <i>esperam que</i> <code>i</code> seja uma variável indutiva.  Se o virem no código, esperam ver um loop em breve. <br><br><blockquote>  <b>Dica</b> .  Se você tiver tantos loops aninhados que esgotou as variáveis <code>i</code> , <code>j</code> <code>k</code> , poderá dividir a função em unidades menores. </blockquote><br><a name="2_5"></a><h2>  2.5  Use um único estilo de declaração </h2><br>  Go tem pelo menos seis maneiras diferentes de declarar uma variável. <br><br><ul><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; x = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> </li><li><pre> <code class="go hljs">x := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li></ul><br>  Tenho certeza de que ainda não lembrei de tudo.  Os desenvolvedores do Go provavelmente consideram isso um erro, mas é tarde demais para mudar qualquer coisa.  Com esta escolha, como garantir um estilo uniforme? <br><br>  Quero propor um estilo de declarar variáveis ​​que eu mesmo tento usar sempre que possível. <br><br><ul><li>  <b>Ao declarar uma variável sem inicialização, use <code>var</code></b> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0 var things []Thing // an empty slice of Things var thing Thing // empty Thing struct json.Unmarshall(reader, &amp;thing)</span></span></code> </pre> <br>  <code>var</code> atua como uma dica de que essa variável é declarada <i>intencionalmente</i> como um valor nulo do tipo especificado.  Isso é consistente com o requisito de declarar variáveis ​​no nível do pacote com <code>var</code> em oposição à sintaxe da declaração curta, embora eu argumente mais tarde que as variáveis ​​no nível do pacote não devem ser usadas. </li><li>  <b>Ao declarar com inicialização, use <code>:=</code></b> .  Isso deixa claro para o leitor que a variável à esquerda de <code>:=</code> intencionalmente inicializada. <br><br>  Para explicar o porquê, vejamos o exemplo anterior, mas desta vez inicializamos especialmente cada variável: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing *Thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing) json.Unmarshall(reader, thing)</code> </pre> </li></ul><br>  Como o Go não possui conversões automáticas de um tipo para outro, no primeiro e terceiro exemplos, o tipo no lado esquerdo do operador de atribuição deve ser idêntico ao tipo no lado direito.  O compilador pode inferir o tipo da variável declarada do tipo à direita, para que o exemplo possa ser escrito de forma mais concisa: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing) json.Unmarshall(reader, thing)</code> </pre> <br>  Aqui, os <code>players</code> inicializados explicitamente em <code>0</code> , o que é redundante, porque o valor inicial dos <code>players</code> é zero em qualquer caso.  Portanto, é melhor deixar claro que queremos usar um valor nulo: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br>  E o segundo operador?  Não podemos determinar o tipo e escrever <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things = <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre> <br>  Porque <code>nil</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">não</a> <code>nil</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tipo</a> .  Em vez disso, temos uma escolha: ou usamos um valor zero para cortar ... <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing</code> </pre> <br>  ... ou criar uma fatia com zero elementos? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Thing, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  No segundo caso, o valor da fatia <i>não</i> é zero e deixamos claro para o leitor usando uma forma abreviada de declaração: <br><br><pre> <code class="go hljs">things := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Thing, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Isso diz ao leitor que decidimos inicializar explicitamente as <code>things</code> . <br><br>  Então chegamos à terceira declaração: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing)</code> </pre> <br>  Aqui, a inicialização explícita da variável e a introdução da palavra-chave “única” <code>new</code> , que alguns programadores do Go não gostam.  O uso da sintaxe curta recomendada gera <br><br><pre> <code class="go hljs">thing := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing)</code> </pre> <br>  Isso deixa claro que <code>thing</code> explicitamente inicializado no resultado de <code>new(Thing)</code> , mas ainda deixa um <code>new</code> atípico.  O problema pode ser resolvido usando um literal: <br><br><pre> <code class="go hljs">thing := &amp;Thing{}</code> </pre> <br>  O que é semelhante ao <code>new(Thing)</code> , e essa duplicação perturba alguns programadores do Go.  No entanto, isso significa que inicializamos explicitamente a <code>thing</code> com um ponteiro para <code>Thing{}</code> e um valor <code>Thing</code> de zero. <br><br>  Mas é melhor levar em consideração o fato de que <code>thing</code> declarado com um valor zero e usar o endereço do operador para passar o endereço de <code>thing</code> em <code>json.Unmarshall</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing Thing json.Unmarshall(reader, &amp;thing)</code> </pre> <br><blockquote>  <b>Nota</b>  Obviamente, há exceções a qualquer regra.  Por exemplo, às vezes duas variáveis ​​estão intimamente relacionadas, por isso será estranho escrever <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max := <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br>  Declaração mais legível: <br><br><pre> <code class="go hljs">min, max := <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> </blockquote><br>  Para resumir: <br><br><ul><li>  Ao declarar uma variável sem inicialização, use a sintaxe <code>var</code> . <br></li><li>  Ao declarar e inicializar explicitamente uma variável, use <code>:=</code> . </li></ul><br><blockquote>  <b>Dica</b> .  Explique explicitamente coisas complexas. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> = <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br>  Aqui, o <code>length</code> pode ser usado com a biblioteca, que requer um tipo numérico específico, e esta opção indica mais claramente que o comprimento do tipo é especificamente selecionado como uint32 do que na declaração curta: <br><br><pre> <code class="go hljs">length := <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span>(<span class="hljs-number"><span class="hljs-number">0x80</span></span>)</code> </pre> <br>  No primeiro exemplo, eu intencionalmente quebrei minha regra usando a declaração var com inicialização explícita.  Um afastamento do padrão faz com que o leitor entenda que algo incomum está acontecendo. </blockquote><br><a name="2_6"></a><h2>  2.6  Trabalho para a equipe </h2><br>  Eu já disse que a essência do desenvolvimento de software é a criação de código legível e suportado.  A maior parte da sua carreira provavelmente funcionará em projetos conjuntos.  Meu conselho nessa situação: siga o estilo adotado na equipe. <br><br>  Alterar estilos no meio do arquivo é irritante.  A consistência é importante, embora em detrimento da preferência pessoal.  Minha regra geral é: se o código se encaixa no <code>gofmt</code> , o problema geralmente não vale a pena ser discutido. <br><br><blockquote>  <b>Dica</b> .  Se você deseja renomear em toda a base de código, não misture isso com outras alterações.  Se alguém usa git bisect, ele não gosta de percorrer milhares de renomeações para encontrar outro código modificado. </blockquote><br><h1>  3. Comentários </h1><br>  Antes de passarmos a pontos mais importantes, quero dedicar alguns minutos para comentar. <br><br><blockquote>  <i>“Um bom código tem muitos comentários e um código ruim precisa de muitos comentários.”</i> - Dave Thomas e Andrew Hunt, programador pragmático </blockquote><br>  Os comentários são muito importantes para a legibilidade do programa.  Cada comentário deve fazer uma - e apenas uma - de três coisas: <br><br><ol><li>  Explique o <i>que o</i> código faz. </li><li>  Explique <i>como</i> ele faz isso. </li><li>  Explique o <i>porquê</i> . </li></ol><br>  O primeiro formulário é ideal para comentar caracteres públicos: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Open     . //           .</span></span></code> </pre> <br>  O segundo é ideal para comentários dentro de um método: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//     var results []chan error for _, dep := range a.Deps { results = append(results, execute(seen, dep)) }</span></span></code> </pre> <br>  A terceira forma ("por quê") é única, pois não substitui nem substitui as duas primeiras.  Tais comentários explicam os fatores externos que levaram à escrita do código em sua forma atual.  Muitas vezes, sem esse contexto, é difícil entender por que o código é escrito dessa maneira. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;v2.Cluster_CommonLbConfig{ <span class="hljs-comment"><span class="hljs-comment">//  HealthyPanicThreshold HealthyPanicThreshold: &amp;envoy_type.Percent{ Value: 0, }, }</span></span></code> </pre> <br>  Neste exemplo, pode não ficar claro imediatamente o que acontece quando HealthyPanicThreshold é definido como zero por cento.  O comentário pretende esclarecer que um valor 0 desativa o limite de pânico. <br><br><a name="3_1"></a><h2>  3.1  Comentários em variáveis ​​e constantes devem descrever seu conteúdo, não o objetivo </h2><br>  Eu disse anteriormente que o nome de uma variável ou constante deve descrever seu propósito.  Mas um comentário sobre uma variável ou constante deve descrever exatamente o <i>conteúdo</i> , não o <i>objetivo</i> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre> <br>  Neste exemplo, um comentário descreve <i>por que</i> <code>randomNumber</code> como 6 e de onde veio.  O comentário não descreve onde o <code>randomNumber</code> será usado.  Aqui estão mais alguns exemplos: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusContinue = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-comment"><span class="hljs-comment">// RFC 7231, 6.2.1 StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2 StatusProcessing = 102 // RFC 2518, 10.1 StatusOK = 200 // RFC 7231, 6.3.1</span></span></code> </pre> <br>  <i>No contexto do HTTP, o</i> número <code>100</code> conhecido como <code>StatusContinue</code> , conforme definido na RFC 7231, seção 6.2.1. <br><br><blockquote>  <b>Dica</b> .  Para variáveis ​​sem valor inicial, o comentário deve descrever quem é responsável por inicializar essa variável. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// sizeCalculationDisabled ,   //     . . dowidth. var sizeCalculationDisabled bool</span></span></code> </pre> <br>  Aqui, um comentário informa ao leitor que a função <code>dowidth</code> responsável por manter o estado de <code>sizeCalculationDisabled</code> . </blockquote><br><blockquote>  <b>Dica</b> .  Esconder à vista.  Este é o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conselho de Kate Gregory</a> .  Às vezes, o melhor nome para uma variável está oculto nos comentários. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   SQL var registry = make(map[string]*sql.Driver)</span></span></code> </pre> <br>  Um comentário foi adicionado pelo autor porque o <code>registry</code> nomes não explica suficientemente sua finalidade - este é um registro, mas qual é o registro? <br><br>  Se você renomear uma variável como sqlDrivers, fica claro que ela contém drivers SQL. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlDrivers = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*sql.Driver)</code> </pre> <br>  Agora o comentário tornou-se redundante e pode ser excluído. </blockquote><br><a name="3_2"></a><h2>  3.2  Sempre documente caracteres publicamente disponíveis </h2><br>  A documentação do seu pacote é gerada pelo godoc, portanto, você deve adicionar um comentário a cada caractere público declarado no pacote: uma variável, constante, função e método. <br><br>  Aqui estão duas diretrizes do Guia de estilos do Google: <br><br><ul><li>  Qualquer função pública que não seja óbvia nem concisa deve ser comentada. <br></li><li>  Qualquer função na biblioteca deve ser comentada, independentemente do tamanho ou complexidade. </li></ul><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ioutil <span class="hljs-comment"><span class="hljs-comment">// ReadAll   r      (EOF)   // ..    err == nil, not err == EOF. //  ReadAll     ,     //  . func ReadAll(r io.Reader) ([]byte, error)</span></span></code> </pre> <br>  Há uma exceção a esta regra: você não precisa documentar métodos que implementam a interface.  Especificamente, não faça isso: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Read   io.Reader func (r *FileReader) Read(buf []byte) (int, error)</span></span></code> </pre> <br>  Este comentário não significa nada.  Ele não diz o que o método faz: pior, ele envia para algum lugar para procurar documentação.  Nesta situação, proponho excluir completamente o comentário. <br><br>  Aqui está um exemplo do pacote <code>io</code> . <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// LimitReader  Reader,    r, //    EOF  n . //   *LimitedReader. func LimitReader(r Reader, n int64) Reader { return &amp;LimitedReader{r, n} } // LimitedReader   R,     //   N .   Read  N  //    . // Read  EOF,  N &lt;= 0    R  EOF. type LimitedReader struct { R Reader // underlying reader N int64 // max bytes remaining } func (l *LimitedReader) Read(p []byte) (n int, err error) { if lN &lt;= 0 { return 0, EOF } if int64(len(p)) &gt; lN { p = p[0:lN] } n, err = lRRead(p) lN -= int64(n) return }</span></span></code> </pre> <br>  Observe que a declaração <code>LimitedReader</code> é imediatamente precedida pela função que a usa e a declaração <code>LimitedReader.Read</code> segue a declaração do <code>LimitedReader</code> .  Embora o <code>LimitedReader.Read</code> si não esteja documentado, é possível entender que essa é uma implementação do <code>io.Reader</code> . <br><br><blockquote>  <b>Dica</b> .  Antes de escrever uma função, escreva um comentário descrevendo-a.  Se você acha difícil escrever um comentário, isso é um sinal de que o código que você está prestes a escrever será difícil de entender. </blockquote><br><h3>  3.2.1  Não comente sobre código incorreto, reescreva-o </h3><br><blockquote>  <i>“Não comente código incorreto - reescreva-o”</i> - Brian Kernighan </blockquote><br>  Não basta indicar nos comentários a dificuldade do fragmento de código.  Se você se deparar com um desses comentários, inicie um ticket com um lembrete de refatoração.  Você pode viver com dívida técnica, desde que seu valor seja conhecido. <br><br>  Na biblioteca padrão, é habitual deixar comentários no estilo TODO com o nome do usuário que notou o problema. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TODO(dfc)  O(N^2),     .</span></span></code> </pre> <br>  Isso não é uma obrigação para corrigir o problema, mas o usuário indicado pode ser a melhor pessoa para fazer uma pergunta.  Outros projetos acompanham o TODO com uma data ou número do ticket. <br><br><h3>  3.2.2  Em vez de comentar o código, refatore-o </h3><br><blockquote>  <i>“Bom código é a melhor documentação.</i>  <i>Quando você estiver prestes a adicionar um comentário, faça a si mesmo a pergunta: “Como melhorar o código para que este comentário não seja necessário?”</i>  <i>Refatore e deixe um comentário para torná-lo ainda mais claro. ”</i> - Steve McConnell </blockquote><br>  As funções devem executar apenas uma tarefa.  Se você deseja escrever um comentário porque algum fragmento não está relacionado ao restante da função, considere extraí-lo em uma função separada. <br><br>  Recursos menores não são apenas mais claros, mas mais fáceis de testar separadamente.  Quando você isolou o código em uma função separada, seu nome pode substituir um comentário. <br><br><a name="4"></a><h1>  4. Estrutura do pacote </h1><br><blockquote>  <i>“Escreva um código modesto: módulos que não mostram nada supérfluo para outros módulos e que não dependem da implementação de outros módulos”</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dave Thomas</a> </blockquote><br>  Cada pacote é essencialmente um pequeno programa Go separado.  Assim como a implementação de uma função ou método não importa para quem chama, a implementação das funções, métodos e tipos que compõem a API pública do seu pacote não importa. <br><br>  Um bom pacote Go busca uma conectividade mínima com outros pacotes no nível do código-fonte, para que, à medida que o projeto cresça, as alterações em um pacote não sejam distribuídas em cascata por toda a base de código.  Tais situações inibem muito os programadores que trabalham nessa base de código. <br><br>  Nesta seção, falaremos sobre o design de pacotes, incluindo seu nome e dicas para escrever métodos e funções. <br><br><a name="4_1"></a><h2>  4.1<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um bom pacote começa com um bom nome </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um bom pacote Go começa com um nome de qualidade. </font><font style="vertical-align: inherit;">Pense nisso como uma breve apresentação limitada a apenas uma palavra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como os nomes das variáveis ​​na seção anterior, o nome do pacote é muito importante. </font><font style="vertical-align: inherit;">Não há necessidade de pensar nos tipos de dados deste pacote; é melhor fazer a pergunta: "Que serviço esse pacote fornece?" </font><font style="vertical-align: inherit;">Normalmente, a resposta não é "Este pacote fornece o tipo X", mas "Este pacote permite que você se conecte via HTTP".</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Escolha um nome de pacote por sua funcionalidade, não por seu conteúdo.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1.1 </font><font style="vertical-align: inherit;">Os bons nomes de pacotes devem ser exclusivos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada pacote tem um nome exclusivo no projeto. </font><font style="vertical-align: inherit;">Não há dificuldade se você seguiu o conselho de dar nomes para os fins dos pacotes. </font><font style="vertical-align: inherit;">Se os dois pacotes tiverem o mesmo nome, provavelmente:</font></font><br><br><ol><li>     . </li><li>       .       ,     . </li></ol><br><a name="4_2"></a><h2>  4.2    <code>base</code> , <code>common</code>  <code>util</code> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um motivo comum para nomes incorretos são os chamados </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pacotes de serviços</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , onde, com o tempo, vários ajudantes e códigos de serviço se acumulam. Como é difícil encontrar um nome único lá. Isso geralmente leva ao fato de que o nome do pacote é derivado do que ele </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contém</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : utilitários. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nomes como </font></font><code>utils</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>helpers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">são geralmente encontrados em grandes projetos, nos quais uma hierarquia profunda de pacotes está enraizada e as funções auxiliares são compartilhadas. Se você extrair alguma função em um novo pacote, a importação será interrompida. Nesse caso, o nome do pacote não reflete o objetivo do pacote, mas apenas o fato de a função de importação falhar devido à organização incorreta do projeto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em tais situações, recomendo analisar de onde os pacotes são chamados.</font></font><code>utils</code> <code>helpers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, se possível, mova as funções correspondentes para o pacote de chamada. </font><font style="vertical-align: inherit;">Mesmo que isso implique duplicação de algum código auxiliar, é melhor do que introduzir uma dependência de importação entre dois pacotes.</font></font><br><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“[Um pouco] duplicação é muito mais barata que uma abstração errada”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Sandy Mets</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se funções utilitárias são usadas em muitos lugares, em vez de um pacote monolítico com funções utilitárias, é melhor criar vários pacotes, cada um dos quais se concentra em um aspecto. </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Use o plural para pacotes de serviços. </font><font style="vertical-align: inherit;">Por exemplo, </font></font><code>strings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para utilitários de processamento de cadeia.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pacotes com nomes como </font></font><code>base</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">são frequentemente encontrados quando uma certa funcionalidade comum de duas ou mais implementações ou tipos comuns para um cliente e um servidor é mesclada em um pacote separado. </font><font style="vertical-align: inherit;">Acredito que, nesses casos, é necessário reduzir o número de pacotes combinando cliente, servidor e código comum em um pacote com um nome que corresponda à sua função. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, para </font></font><code>net/http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não fazer os pacotes individuais </font></font><code>client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, em vez disso, existem arquivos </font></font><code>client.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>server.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com os tipos de dados correspondentes, bem como </font></font><code>transport.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o transporte total.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">É importante lembrar que o nome do identificador inclui o nome do pacote.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma função </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de um pacote </font></font><code>net/http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se torna um </font></font><code>http.Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link de outro pacote.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um tipo </font></font><code>Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de um pacote é </font></font><code>strings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transformado quando importado para outros pacotes </font></font><code>strings.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A interface </font></font><code>Error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do pacote está </font></font><code>net</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">claramente associada a erros de rede.</font></font></li></ul></blockquote><br><a name="4_3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3 </font><font style="vertical-align: inherit;">Volte rapidamente sem mergulhar fundo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o Go não usa exceções no fluxo de controle, não há necessidade de se aprofundar no código para fornecer uma estrutura </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font><font style="vertical-align: inherit;">blocos de nível superior </font></font><code>catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em vez de uma hierarquia multinível, o código Go desce a tela à medida que a função progride. </font><font style="vertical-align: inherit;">Meu amigo Matt Ryer chama essa prática de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"linha de visão"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso é conseguido usando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operadores de limite</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : blocos condicionais com uma pré-condição na entrada da função. </font><font style="vertical-align: inherit;">Aqui está um exemplo do pacote </font></font><code>bytes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnreadRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.lastRead &lt;= opInvalid { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.off &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) { b.off -= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) } b.lastRead = opInvalid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao entrar na função </font></font><code>UnreadRune</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o estado é verificado </font></font><code>b.lastRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, se a operação anterior não foi </font></font><code>ReadRune</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um erro é retornado imediatamente. O restante da função funciona com base no que é </font></font><code>b.lastRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maior que </font></font><code>opInvalid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compare com a mesma função, mas sem o operador de limite:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnreadRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.lastRead &gt; opInvalid { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.off &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) { b.off -= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) } b.lastRead = opInvalid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O corpo de uma ramificação bem-sucedida mais provável é incorporado na primeira condição </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a condição para uma saída bem-sucedida </font></font><code>return nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve ser descoberta combinando cuidadosamente os </font><font style="vertical-align: inherit;">colchetes de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fechamento</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A última linha da função agora retorna um erro e você precisa acompanhar a execução da função no </font><font style="vertical-align: inherit;">colchete de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abertura</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correspondente </font><font style="vertical-align: inherit;">para descobrir como chegar a esse ponto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa opção é mais difícil de ler, o que diminui a qualidade da programação e do suporte ao código; portanto, o Go prefere usar operadores de limite e retornar erros logo no início.</font></font><br><br><a name="4_4"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4 </font><font style="vertical-align: inherit;">Tornar o valor nulo útil</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada declaração de variável, assumindo a ausência de um inicializador explícito, será automaticamente inicializada com um valor correspondente ao conteúdo da memória zerada, ou seja, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zero</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O tipo de valor é determinado por uma das opções: para tipos numéricos - zero, para tipos de ponteiros - zero, o mesmo para fatias, mapas e canais. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A capacidade de sempre definir um valor padrão conhecido é importante para a segurança e a correção do seu programa e pode tornar seus programas Go mais fáceis e compactos. É isso que os programadores do Go têm em mente quando dizem: "Dê às estruturas um valor zero útil". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere um tipo </font></font><code>sync.Mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que contém dois campos inteiros que representam o estado interno do mutex. Esses campos são automaticamente nulos em qualquer declaração.</font></font><code>sync.Mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esse fato é levado em consideração no código, portanto, o tipo é adequado para uso sem inicialização explícita.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { mu sync.Mutex val <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i MyInt <span class="hljs-comment"><span class="hljs-comment">// i.mu is usable without explicit initialisation. i.mu.Lock() i.val++ i.mu.Unlock() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro exemplo de um tipo com um valor nulo útil é </font></font><code>bytes.Buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Você pode declarar e começar a escrever nele sem inicialização explícita.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span>) io.Copy(os.Stdout, &amp;b) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O valor zero dessa estrutura significa que </font></font><code>len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ambos </font></font><code>cap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">são iguais </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y </font></font><code>array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o ponteiro para a memória com o conteúdo da matriz de fatia de backup, valor </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso significa que você não precisa cortar explicitamente, você pode simplesmente declarar.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// s := make([]string, 0) // s := []string{} var s []string s = append(s, "Hello") s = append(s, "world") fmt.Println(strings.Join(s, " ")) }</span></span></code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><code>var s []string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semelhante às duas linhas comentadas no topo, mas não idênticas a elas. </font><font style="vertical-align: inherit;">Há uma diferença entre um valor de fatia nulo e um valor de fatia de comprimento zero. </font><font style="vertical-align: inherit;">O código a seguir será impresso como falso.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1 = []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2 []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fmt.Println(reflect.DeepEqual(s1, s2)) }</code> </pre> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma propriedade útil, embora inesperada, de variáveis ​​de ponteiro não inicializadas - ponteiros nulos - é a capacidade de chamar métodos em tipos que são nulos. </font><font style="vertical-align: inherit;">Isso pode ser usado para fornecer facilmente valores padrão.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/usr/home"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.path } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c1 *Config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c2 = &amp;Config{ path: <span class="hljs-string"><span class="hljs-string">"/export"</span></span>, } fmt.Println(c1.Path(), c2.Path()) }</code> </pre> <br><a name="4_5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5 </font><font style="vertical-align: inherit;">Evitar estado do nível do pacote</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A chave para escrever programas de fácil suporte que estão fracamente conectados é que a alteração de um pacote deve ter uma baixa probabilidade de afetar outro pacote que não depende diretamente do primeiro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem duas maneiras excelentes de obter conectividade fraca no Go:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use interfaces para descrever o comportamento exigido por funções ou métodos. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evite status global. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No Go, podemos declarar variáveis ​​no escopo de uma função ou método, bem como no escopo de um pacote. </font><font style="vertical-align: inherit;">Quando uma variável está disponível publicamente, com um identificador com letra maiúscula, seu escopo é realmente global para todo o programa: qualquer pacote </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a qualquer momento</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vê o tipo e o conteúdo dessa variável. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O estado global mutável fornece uma estreita relação entre as partes independentes do programa, pois as variáveis ​​globais se tornam um parâmetro invisível para cada função no programa! </font><font style="vertical-align: inherit;">Qualquer função que depende de uma variável global pode ser violada quando o tipo dessa variável é alterado. </font><font style="vertical-align: inherit;">Qualquer função que depende do estado de uma variável global pode ser violada se outra parte do programa alterar essa variável.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como reduzir a conectividade que uma variável global cria: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mova as variáveis ​​correspondentes como campos para as estruturas que precisam delas. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use interfaces para reduzir a conexão entre o comportamento e a implementação desse comportamento. </font></font></li></ol><br><a name="5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Estrutura do projeto </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos falar sobre como os pacotes são combinados em um projeto. </font><font style="vertical-align: inherit;">Geralmente é um único repositório Git. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o pacote, cada projeto deve ter um objetivo claro. </font><font style="vertical-align: inherit;">Se for uma biblioteca, deve fazer uma coisa, por exemplo, análise XML ou registro no diário. </font><font style="vertical-align: inherit;">Você não deve combinar vários objetivos em um projeto, isso ajudará a evitar uma biblioteca assustadora </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Na minha experiência, o repositório </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">está intimamente associado ao maior consumidor, e isso dificulta a correção de versões anteriores (correções de porta traseira) sem atualizar </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o consumidor e o consumidor no estágio de bloqueio, o que leva a muitas mudanças não relacionadas, além de serem interrompidas pelo caminho API</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você possui um aplicativo (aplicativo Web, controlador Kubernetes, etc.), o projeto pode ter um ou mais pacotes principais. </font><font style="vertical-align: inherit;">Por exemplo, no meu controlador Kubernetes, há um pacote </font></font><code>cmd/contour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que serve como um servidor implantado em um cluster Kubernetes e como um cliente de depuração.</font></font><br><br><a name="5_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1 </font><font style="vertical-align: inherit;">Menos pacotes, mas maiores</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na revisão de código, notei um dos erros típicos dos programadores que mudaram para o Go de outros idiomas: eles tendem a abusar de pacotes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GO não fornecer o elaborado sistema de visibilidade: a linguagem não é suficiente modificadores de acesso, como no Java ( </font></font><code>public</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>protected</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e implícita </font></font><code>default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Não há análogo de classes amigáveis ​​do C ++. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No Go, temos apenas dois modificadores de acesso: são identificadores públicos e privados, indicados pela primeira letra do identificador (maiúscula / minúscula). </font><font style="vertical-align: inherit;">Se o identificador for público, seu nome começará com uma letra maiúscula e poderá ser referenciado por qualquer outro pacote Go.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Você pode ouvir as palavras "exportado" ou "não exportado" como sinônimos para público e privado.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dado os recursos limitados de controle de acesso, quais métodos podem ser usados ​​para evitar hierarquias de pacotes excessivamente complexas? </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Em cada pacote, além </font></font><code>cmd/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve estar presente o código fonte.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu já disse várias vezes que é melhor preferir menos pacotes maiores. </font><font style="vertical-align: inherit;">Sua posição padrão deve ser não criar um novo pacote. </font><font style="vertical-align: inherit;">Isso faz com que muitos tipos se tornem públicos, criando um escopo amplo e pequeno da API disponível. </font><font style="vertical-align: inherit;">Abaixo, consideramos esta tese em mais detalhes.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Veio de Java? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você é do mundo Java ou C #, lembre-se da regra tácita: um pacote Java é equivalente a um único arquivo de origem </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O pacote Go é equivalente a todo o módulo Maven ou assembly .NET.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1.1 </font><font style="vertical-align: inherit;">Classificando o código por arquivo usando as instruções de importação</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você organizar pacotes por serviço, faça o mesmo com os arquivos no pacote? </font><font style="vertical-align: inherit;">Como saber quando dividir um arquivo </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em vários? </font><font style="vertical-align: inherit;">Como você sabe se você foi longe demais e precisa pensar em mesclar arquivos? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui estão as recomendações que eu uso:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicie cada pacote com um arquivo </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Atribua a esse arquivo o mesmo nome que o diretório. </font><font style="vertical-align: inherit;">Por exemplo, o pacote </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve estar no arquivo </font></font><code>http.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no diretório </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conforme o pacote cresce, você pode dividir as várias funções em vários arquivos. </font><font style="vertical-align: inherit;">Por exemplo, o arquivo </font></font><code>messages.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conterá tipos </font></font><code>Request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Response</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>client.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipo de </font></font><code>Client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arquivo, </font></font><code>server.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">servidor de tipo de </font><font style="vertical-align: inherit;">arquivo </font><font style="vertical-align: inherit;">.</font></font><br></li><li>       ,    .  ,       . <br></li><li>        . , <code>messages.go</code>     HTTP-       , <code>http.go</code>      , <code>client.go</code>  <code>server.go</code> —    HTTP     . </li></ul><br><blockquote> <b></b> .      . </blockquote><br><blockquote> <b></b> .  Go    .      <i></i> ( —      Go).           . </blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1.2 </font><font style="vertical-align: inherit;">Prefira testes internos a externos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A ferramenta </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suporta o pacote </font></font><code>testing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em dois lugares. </font><font style="vertical-align: inherit;">Se você possui um pacote </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pode escrever um arquivo </font></font><code>http2_test.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e usar a declaração do pacote </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele compila o código </font></font><code>http2_test.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é parte do pacote </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No discurso coloquial, esse teste é chamado interno. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A ferramenta </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">também suporta uma declaração de pacote especial que termina com </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teste</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou seja </font></font><code>http_test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso permite que os arquivos de teste residam no mesmo pacote com o código, mas quando esses testes são compilados, eles não fazem parte do código do seu pacote, mas vivem em seu próprio pacote. </font><font style="vertical-align: inherit;">Isso permite que você escreva testes como se outro pacote estivesse invocando seu código. </font><font style="vertical-align: inherit;">Tais testes são chamados externos.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu recomendo usar testes internos para testes de unidade. Isso permite que você teste cada função ou método diretamente, evitando a burocracia de testes externos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas é </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necessário</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> colocar exemplos de funções de teste ( </font></font><code>Example</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">em um arquivo de teste externo </font><font style="vertical-align: inherit;">. Isso garante que, quando visualizados no godoc, os exemplos recebam o prefixo do pacote apropriado e possam ser facilmente copiados.</font></font><br><br><blockquote> <b></b> .    ,     . <br><br>   ,    ,   Go      <code>go</code> . ,  <code>net/http</code>       <code>net</code> . <br><br>           <code>.go</code> , ,    . </blockquote><br><h3> 5.1.3.   ,     API </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o seu projeto tiver vários pacotes, você poderá encontrar funções exportadas que devem ser usadas por outros pacotes, mas não para a API pública. </font><font style="vertical-align: inherit;">Em tal situação, a ferramenta </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reconhece um nome de pasta especial </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que pode ser usado para colocar o código aberto para o seu projeto, mas fechado para outros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar esse pacote, coloque-o em um diretório com um nome </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou em seu subdiretório. </font><font style="vertical-align: inherit;">Quando a equipe </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vê a importação do pacote com o caminho </font></font><code>internal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, verifica o local do pacote de chamada em um diretório ou subdiretório </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, um pacote </font></font><code>.../a/b/c/internal/d/e/f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode importar apenas um pacote de uma árvore de diretórios </font></font><code>.../a/b/c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas não de todo </font></font><code>.../a/b/g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou qualquer outro repositório (consulte</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><a name="5_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2 </font><font style="vertical-align: inherit;">O menor pacote principal</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma função </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e um pacote </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devem ter funcionalidade mínima, porque </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">age como um singleton: um programa pode ter apenas uma função </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, incluindo testes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é um singleton, há muitas restrições nos objetos chamados: eles são chamados apenas durante </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>main.init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e apenas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma vez</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Isso dificulta a escrita de testes de código </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Portanto, você precisa se esforçar para derivar o máximo de lógica possível da função principal e, idealmente, do pacote principal.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><code>func main()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve analisar sinalizadores, abrir conexões com bancos de dados, registradores etc. e depois transferir a execução para um objeto de alto nível.</font></font></blockquote><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. estrutura da API </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O último conselho de design do projeto que considero o mais importante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas as frases anteriores são, em princípio, não vinculativas. </font><font style="vertical-align: inherit;">Estas são apenas recomendações baseadas na experiência pessoal. </font><font style="vertical-align: inherit;">Eu não forço muito essas recomendações em uma revisão de código. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A API é outra questão: aqui, os erros são levados mais a sério, porque todo o resto pode ser corrigido sem quebrar a compatibilidade com versões anteriores: na maior parte, esses são apenas detalhes de implementação. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando se trata de APIs públicas, vale a pena considerar seriamente a estrutura desde o início, porque as alterações subsequentes serão destrutivas para os usuários.</font></font><br><br><a name="6_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.1 </font><font style="vertical-align: inherit;">APIs de design difíceis de abusar por design</font></font></h2><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“As APIs devem ser simples para uso adequado e difíceis para incorretas”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josh Bloch</font></font></a> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O conselho de Josh Bloch é talvez o mais valioso neste artigo. </font><font style="vertical-align: inherit;">Se for difícil usar a API para coisas simples, todas as chamadas à API serão mais complicadas do que o necessário. </font><font style="vertical-align: inherit;">Quando uma chamada de API é complexa e não óbvia, é provável que seja ignorada.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.1.1 </font><font style="vertical-align: inherit;">Cuidado com as funções que aceitam vários parâmetros do mesmo tipo.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um bom exemplo de uma API simples à primeira vista, mas difícil de usar, é quando ela requer dois ou mais parâmetros do mesmo tipo. </font><font style="vertical-align: inherit;">Compare duas assinaturas de função:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to, from </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qual é a diferença entre essas duas funções? </font><font style="vertical-align: inherit;">Obviamente, um retorna no máximo dois números e o outro copia o arquivo. </font><font style="vertical-align: inherit;">Mas este não é o ponto.</font></font><br><br><pre> <code class="go hljs">Max(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 10 Max(10, 8) // 10</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Max é </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comutativo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : a ordem dos parâmetros não importa. </font><font style="vertical-align: inherit;">Um máximo de oito e dez é dez, independentemente de oito e dez ou dez e oito serem comparados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas no caso do CopyFile, não é assim.</font></font><br><br><pre> <code class="go hljs">CopyFile(<span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>, <span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span>) CopyFile(<span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span>, <span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quais desses operadores farão backup da sua apresentação e quais serão substituídos pela versão da semana passada? </font><font style="vertical-align: inherit;">Você não pode saber até verificar a documentação. </font><font style="vertical-align: inherit;">No curso da revisão de código, não está claro se a ordem dos argumentos está correta ou não. </font><font style="vertical-align: inherit;">Mais uma vez, veja a documentação. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma solução possível é a introdução de um tipo auxiliar responsável pela chamada correta </font></font><code>CopyFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Source <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src Source)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dest </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CopyFile(dest, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(src)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> from Source = <span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span> from.CopyTo(<span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É </font></font><code>CopyFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sempre chamado corretamente aqui - isso pode ser declarado usando um teste de unidade - e pode ser feito em particular, o que reduz ainda mais a probabilidade de uso incorreto.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Uma API com vários parâmetros do mesmo tipo é difícil de usar corretamente.</font></font></blockquote><br><a name="6_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2 </font><font style="vertical-align: inherit;">Projetar uma API para um caso de uso básico</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alguns anos atrás, fiz uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apresentação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre o uso de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opções funcionais</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para facilitar a API por padrão. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A essência da apresentação foi que você deveria desenvolver uma API para o caso de uso principal. </font><font style="vertical-align: inherit;">Em outras palavras, a API não deve exigir que o usuário forneça parâmetros extras que não lhe interessam.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2.1 </font><font style="vertical-align: inherit;">O uso de nil como parâmetro não é recomendado</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comecei dizendo que você não deve forçar o usuário a fornecer parâmetros de API que não lhe interessam. </font><font style="vertical-align: inherit;">Isso significa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projetar as APIs para o caso de uso principal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (opção padrão). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui está um exemplo do pacote net / http.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-comment"><span class="hljs-comment">// ListenAndServe listens on the TCP network address addr and then calls // Serve with handler to handle requests on incoming connections. // Accepted connections are configured to enable TCP keep-alives. // // The handler is typically nil, in which case the DefaultServeMux is used. // // ListenAndServe always returns a non-nil error. func ListenAndServe(addr string, handler Handler) error {</span></span></code> </pre> <br> <code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aceita dois parâmetros: um endereço TCP para escutar nas conexões recebidas e </font></font><code>http.Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para processar uma solicitação HTTP recebida. </font></font><code>Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permite que o segundo parâmetro seja </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nos comentários, note-se que geralmente o objeto de chamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> passa </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, indicando um desejo de usá-lo </font></font><code>http.DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como um parâmetro implícito. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora o chamador </font></font><code>Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tem duas maneiras de fazer o mesmo.</font></font><br><br><pre> <code class="go hljs">http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, http.DefaultServeMux)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambas as opções fazem a mesma coisa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este aplicativo se </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espalha como um vírus. </font><font style="vertical-align: inherit;">O pacote também </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">possui um auxiliar </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para que você possa imaginar a estrutura da função </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListenAndServe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, handler Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { l, err := net.Listen(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, addr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> l.Close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Serve(l, handler) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele permite que o chamador passe </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o segundo parâmetro, </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">também suporta esse comportamento. </font><font style="vertical-align: inherit;">De fato, está na </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lógica implementada "se o manipulador for igual </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, use </font></font><code>DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". </font><font style="vertical-align: inherit;">A aceitação </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de um parâmetro pode levar o chamador a pensar que pode ser passado </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para ambos os parâmetros. </font><font style="vertical-align: inherit;">Mas tal</font></font><code>Serve</code> <br><br><pre> <code class="go hljs">http.Serve(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> leva a um pânico terrível. </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Não misture parâmetros na mesma assinatura de função </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e não </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O autor </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tentou simplificar a vida dos usuários da API para o caso padrão, mas a segurança foi afetada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na presença, </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não há diferença no número de linhas entre uso explícito e indireto </font></font><code>DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comparado com </font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, http.DefaultServeMux)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Valeu a confusão manter uma linha? </font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) mux := http.NewServeMux() mux.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux)</code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pense seriamente em quanto tempo as funções auxiliares salvarão o programador. </font><font style="vertical-align: inherit;">Clareza é melhor que concisão.</font></font></blockquote><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Evite APIs públicas com parâmetros que somente os testes precisam. </font><font style="vertical-align: inherit;">Evite exportar APIs com parâmetros cujos valores diferem apenas durante o teste. </font><font style="vertical-align: inherit;">Em vez disso, as funções do wrapper de exportação que ocultam a transferência desses parâmetros e nos testes usam funções auxiliares semelhantes que passam os valores necessários para o teste.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2.2 </font><font style="vertical-align: inherit;">Use argumentos de comprimento variável em vez de [] T</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Muitas vezes, uma função ou método usa uma fatia dos valores. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShutdownVMs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ids []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este é apenas um exemplo inventado, mas isso é muito comum. O problema é que essas assinaturas assumem que serão chamadas com mais de um registro. Como mostra a experiência, eles geralmente são chamados com apenas um argumento, que deve ser "empacotado" dentro da fatia para atender aos requisitos da assinatura da função. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além disso, como o parâmetro </font></font><code>ids</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é uma fatia, você pode passar uma fatia vazia ou zero para a função e o compilador ficará feliz. Isso adiciona uma carga extra de teste, pois o teste deve cobrir esses casos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para dar um exemplo dessa classe de API, refatorei recentemente a lógica que exigia a instalação de alguns campos adicionais se pelo menos um dos parâmetros fosse diferente de zero. A lógica era algo assim:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> svc.MaxConnections &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxPendingRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxRetries &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-comment"><span class="hljs-comment">// apply the non zero parameters }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o operador estava </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ficando muito longo, eu queria colocar a lógica de validação em uma função separada. </font><font style="vertical-align: inherit;">Aqui está o que eu vim com:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero. func anyPositive(values ...int) bool { for _, v := range values { if v &gt; 0 { return true } } return false }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isso tornou possível indicar claramente a condição sob a qual a unidade interna será executada: </font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) { <span class="hljs-comment"><span class="hljs-comment">// apply the non zero parameters }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, há um problema com </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, alguém poderia acidentalmente chamá-lo assim:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> anyPositive() { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse caso, </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornará </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esta não é a pior opção. </font><font style="vertical-align: inherit;">Pior se </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornado </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na ausência de argumentos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, seria melhor poder alterar a assinatura de anyPositive para garantir que pelo menos um argumento seja passado ao chamador. </font><font style="vertical-align: inherit;">Isso pode ser feito combinando parâmetros para argumentos normais e argumentos de comprimento variável (varargs):</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero. func anyPositive(first int, rest ...int) bool { if first &gt; 0 { return true } for _, v := range rest { if v &gt; 0 { return true } } return false }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">você não pode chamar com menos de um argumento.</font></font><br><br><a name="6_3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3 </font><font style="vertical-align: inherit;">Deixe as funções determinarem o comportamento desejado.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que me foi atribuída a tarefa de escrever uma função que preserva a estrutura </font></font><code>Document</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no disco.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      f. func Save(f *os.File, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu poderia escrever uma função </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que grava </font></font><code>Document</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em um arquivo </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mas existem alguns problemas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A assinatura </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elimina a possibilidade de gravar dados pela rede. Se esse requisito aparecer no futuro, a assinatura da função precisará ser alterada, o que afetará todos os objetos de chamada. </font></font><br><br> <code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Também é desagradável para o teste, uma vez que trabalha diretamente com os arquivos no disco. Portanto, para verificar seu funcionamento, o teste deve ler o conteúdo do arquivo após a gravação. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E eu tenho que garantir que ele seja </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gravado em uma pasta temporária e posteriormente excluído. </font></font><br><br> <code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">também define muitos métodos que não estão relacionados a </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por exemplo, ler diretórios e verificar se um caminho é um link simbólico. Bem, se a assinatura</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descreveu apenas as partes relevantes </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que pode ser feito?</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // ReadWriterCloser. func Save(rwc io.ReadWriteCloser, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com a ajuda </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dele, você pode aplicar o princípio de separação da interface - e redefini-lo </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em uma interface que descreva as propriedades mais gerais do arquivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Após essa alteração, qualquer tipo que implemente a interface </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser substituído pelo anterior </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso expande simultaneamente o escopo </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e esclarece ao chamador quais métodos de tipo </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estão relacionados à sua operação. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E o autor </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não pode mais chamar esses métodos não relacionados </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque ele está oculto por trás da interface </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas podemos estender o princípio da separação de interface ainda mais. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em primeiro lugar se</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segue o princípio da responsabilidade única, é improvável que ele leia o arquivo que acabou de escrever para verificar seu conteúdo - outro código deve fazer isso. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // WriteCloser. func Save(wc io.WriteCloser, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, você pode restringir as especificações da interface para </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas escrever e fechar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em segundo lugar, o mecanismo de fechamento do encadeamento y </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é um legado do tempo em que trabalhou com o arquivo. </font><font style="vertical-align: inherit;">A questão é: em que circunstâncias </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele será fechado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se a </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">causa </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incondicionalmente, quer no caso de sucesso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso apresenta um problema para o chamador, pois ele pode querer adicionar dados ao fluxo após a gravação do documento.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // Writer. func Save(w io.Writer, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A melhor opção é redefinir Salvar para trabalhar apenas </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, salvando o operador de todas as outras funcionalidades, exceto para gravar dados no fluxo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de aplicar o princípio de separação de interface, a função tornou-se ao mesmo tempo mais específica em termos de requisitos (precisa apenas de um objeto onde possa ser gravada) e mais geral em termos de funcionalidade, já que agora podemos usá-la </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para salvar dados onde quer que seja implementada </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Tratamento de erros </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fiz </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">várias apresentações</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">escrevi </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muito</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre esse tópico no blog, então não vou repeti-lo. </font><font style="vertical-align: inherit;">Em vez disso, quero cobrir duas outras áreas relacionadas ao tratamento de erros.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><a name="7_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1 </font><font style="vertical-align: inherit;">Elimine a necessidade de tratamento de erros removendo os próprios erros</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fiz muitas sugestões para melhorar a sintaxe de manipulação de erros, mas a melhor opção é não lidar com elas. </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Não digo "excluir tratamento de erros". </font><font style="vertical-align: inherit;">Sugiro alterar o código para que não haja erros no processamento.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O recente livro de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filosofia de desenvolvimento de software de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> John Osterhout me inspirou a fazer essa sugestão </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um dos capítulos é intitulado "Eliminar erros da realidade". </font><font style="vertical-align: inherit;">Vamos tentar aplicar este conselho.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.1 </font><font style="vertical-align: inherit;">Contagem de linhas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escreveremos uma função para contar o número de linhas em um arquivo. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( br = bufio.NewReader(r) lines <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err error ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != io.EOF { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conforme seguimos o conselho das seções anteriores, </font></font><code>CountLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aceita </font></font><code>io.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, não </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; já é tarefa do chamador fornecer </font></font><code>io.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cujo conteúdo queremos contar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criamos </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, em seguida, chamamos o método em um loop </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aumentando o contador, até chegarmos ao final do arquivo e retornamos o número de linhas lidas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelo menos queremos escrever esse código, mas a função está sobrecarregada com o tratamento de erros. Por exemplo, há uma construção tão estranha:</font></font><br><br><pre> <code class="go hljs"> _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aumentamos o número de linhas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antes de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verificar se há erros - isso parece estranho. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A razão pela qual devemos escrever dessa maneira é porque ele </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornará um erro se encontrar o final do arquivo antes do caractere de nova linha. </font><font style="vertical-align: inherit;">Isso pode acontecer se não houver nova linha no final do arquivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para tentar corrigir isso, altere a lógica do contador de linhas e veja se precisamos sair do loop.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Essa lógica ainda não é perfeita, você pode encontrar um erro?</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas ainda não terminamos de verificar se há erros. </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornará </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando encontrar o final do arquivo. </font><font style="vertical-align: inherit;">Essa é a situação esperada, portanto, para </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">você precisar fazer alguma maneira de dizer "pare, não há mais nada para ler". </font><font style="vertical-align: inherit;">Portanto, antes de retornar o erro ao objeto de chamada </font></font><code>CountLine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, é necessário verificar se o erro não está relacionado </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e depois transmiti-lo; caso contrário, retornamos </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e dizemos que está tudo bem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penso que este é um bom exemplo da tese de Russ Cox sobre como o tratamento de erros pode ocultar a função. </font><font style="vertical-align: inherit;">Vejamos a versão melhorada.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { sc := bufio.NewScanner(r) lines := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sc.Scan() { lines++ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, sc.Err() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta versão aprimorada usa em seu </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lugar </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sob o capô </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas adiciona um bom nível de abstração, o que ajuda a remover o tratamento de erros.</font></font><br><br><blockquote> <b></b> . <code>bufio.Scanner</code>    ,      . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O método </font></font><code>sc.Scan()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornará um valor </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se o scanner encontrou uma sequência e não encontrou um erro. Portanto, o corpo do loop é </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamado apenas se houver uma linha de texto no buffer do scanner. Isso significa que o novo </font></font><code>CountLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lida com casos quando não há nova linha ou quando o arquivo está vazio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em segundo lugar, como </font></font><code>sc.Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorna </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando um erro é detectado, o ciclo </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">termina quando atinge o final do arquivo ou um erro é detectado. O tipo </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lembra o primeiro erro encontrado e, usando o método </font></font><code>sc.Err()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podemos restaurar esse erro assim que sairmos do loop. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por fim, ele </font></font><code>sc.Err()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuida do processamento </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o converte para </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se o final do arquivo for alcançado sem erros.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Se você encontrar um tratamento excessivo de erros, tente extrair algumas operações para um tipo auxiliar.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.2 </font><font style="vertical-align: inherit;">Writeresponse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meu segundo exemplo é inspirado no post </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Erros são valores"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, vimos exemplos de como um arquivo é aberto, gravado e fechado. </font><font style="vertical-align: inherit;">Há manipulação de erros, mas não é demais, porque as operações podem ser encapsuladas em auxiliares, como </font></font><code>ioutil.ReadFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>ioutil.WriteFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Porém, ao trabalhar com protocolos de rede de baixo nível, é necessário criar uma resposta diretamente usando as primitivas de E / S. </font><font style="vertical-align: inherit;">Nesse caso, a manipulação de erros pode se tornar intrusiva. </font><font style="vertical-align: inherit;">Considere um fragmento de um servidor HTTP que cria uma resposta HTTP.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Header <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Key, Value <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Code <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Reason <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := fmt.Fprint(w, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } _, err = io.Copy(w, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, construa a barra de status </font></font><code>fmt.Fprintf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e verifique o erro. Então, para cada cabeçalho, escrevemos um valor de chave e cabeçalho, sempre verificando um erro. Por fim, concluímos a seção do cabeçalho com outra </font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, verificamos o erro e copiamos o corpo da resposta para o cliente. Finalmente, embora não seja necessário verificar o erro </font></font><code>io.Copy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, precisamos convertê-lo de dois valores de retorno para o único que retornar </font></font><code>WriteResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso é muito trabalho monótono. Mas você pode facilitar sua tarefa aplicando um pequeno tipo de wrapper </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satisfaz o contrato </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para que possa ser usado como invólucro. </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passa registros pela função até que um erro seja detectado. Nesse caso, ele rejeita as entradas e retorna o erro anterior.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> errWriter <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { io.Writer err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *errWriter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e.err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, e.err } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, e.err = e.Writer.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { ew := &amp;errWriter{Writer: w} fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) } fmt.Fprint(ew, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>) io.Copy(ew, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ew.err }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você aplicar </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>WriteResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a clareza de código melhorou significativamente. </font><font style="vertical-align: inherit;">Você não precisa mais verificar se há erros em cada operação individual. </font><font style="vertical-align: inherit;">A mensagem de erro é movida para o final da função como uma verificação de campo </font></font><code>ew.err</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, evitando a tradução irritante dos valores io.Copy retornados.</font></font><br><br><a name="7_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2 </font><font style="vertical-align: inherit;">Manipule o erro apenas uma vez</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, quero observar que os erros devem ser tratados apenas uma vez. </font><font style="vertical-align: inherit;">Processar significa verificar o significado do erro e tomar uma </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">única</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> decisão.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// WriteAll writes the contents of buf to the supplied writer. func WriteAll(w io.Writer, buf []byte) { w.Write(buf) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você tomar menos de uma decisão, ignorará o erro. </font><font style="vertical-align: inherit;">Como vemos aqui, o erro de é </font></font><code>w.WriteAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ignorado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas tomar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais de uma</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> decisão em resposta a um erro também está errado. </font><font style="vertical-align: inherit;">Abaixo está o código que geralmente encontro.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := w.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"unable to write:"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">// annotated error goes to log file return err // unannotated error returned to caller } return nil }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste exemplo, se ocorrer um erro durante o tempo </font></font><code>w.Write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a linha será gravada no log e também retornada ao chamador, que também poderá registrá-lo e transmiti-lo, até o nível superior do programa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provavelmente, o chamador faz o mesmo:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := WriteAll(w, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"could not write config: %v"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assim, uma pilha de linhas repetidas é criada no log. </font></font><br><br><pre> <code class="go hljs">unable to write: io.EOF could not write config: io.EOF</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mas na parte superior do programa você recebe um erro original sem nenhum contexto. </font></font><br><br><pre> <code class="go hljs">err := WriteConfig(f, &amp;conf) fmt.Println(err) <span class="hljs-comment"><span class="hljs-comment">// io.EOF</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quero analisar este tópico com mais detalhes, porque não considero o problema de retornar um erro simultaneamente e registrar minhas preferências pessoais. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">// oops, forgot to return } if err := WriteAll(w, buf); err != nil { log.Println("could not write config: %v", err) return err } return nil }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costumo encontrar um problema que um programador esquece de retornar de um erro. Como dissemos anteriormente, o estilo de Go é usar operadores de limite, verificar os pré-requisitos à medida que a função é executada e retornar mais cedo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste exemplo, o autor verificou o erro, registrou-o, mas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esqueceu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de retornar. Por isso, surge um problema sutil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O contrato de tratamento de erros Go diz que, na presença de um erro, nenhuma suposição pode ser feita sobre o conteúdo de outros valores de retorno. Como o empacotamento JSON falhou, o conteúdo é </font></font><code>buf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desconhecido: ele pode conter nada, mas pior, pode conter um fragmento JSON semi-escrito.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o programador esqueceu de retornar após verificar e registrar o erro, o buffer danificado será transferido </font></font><code>WriteAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">É provável que a operação tenha êxito e, portanto, o arquivo de configuração não será gravado corretamente. </font><font style="vertical-align: inherit;">No entanto, a função é concluída normalmente, e o único sinal de que ocorreu um problema é uma linha no log em que o empacotamento JSON falhou e não uma falha no registro de configuração.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2.1 </font><font style="vertical-align: inherit;">Adicionando contexto a erros</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ocorreu um erro porque o autor estava tentando adicionar contexto à mensagem de erro. </font><font style="vertical-align: inherit;">Ele tentou deixar uma marca para indicar a fonte do erro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vejamos outra maneira de fazer o mesmo </font></font><code>fmt.Errorf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := WriteAll(w, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"could not write config: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := w.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"write failed: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você combinar o registro de erro com o retorno em uma linha, é mais difícil esquecer de retornar e evitar a continuação acidental. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se ocorrer um erro de E / S durante a gravação do arquivo, o método </font></font><code>Error()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">produzirá algo como isto:</font></font><br><br><pre> <code class="go hljs">could not write config: write failed: input/output error</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2.2 </font><font style="vertical-align: inherit;">Erro ao agrupar com github.com/pkg/errors</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O padrão </font></font><code>fmt.Errorf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funciona bem para registrar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mensagens de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erro, mas o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipo de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erro segue o caminho. </font><font style="vertical-align: inherit;">Argumentei que o tratamento de erros como valores opacos é importante para </font><font style="vertical-align: inherit;">projetos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fracamente acoplados</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; portanto, o tipo de erro de origem não deve importar se precisamos apenas trabalhar com seu valor:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifique se não é zero. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exibi-lo na tela ou registrá-lo. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, acontece que você precisa restaurar o erro original. </font><font style="vertical-align: inherit;">Para anotar esses erros, você pode usar algo como o meu pacote </font></font><code>errors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { f, err := os.Open(path) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"open failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> f.Close() buf, err := ioutil.ReadAll(f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"read failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { home := os.Getenv(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>) config, err := ReadFile(filepath.Join(home, <span class="hljs-string"><span class="hljs-string">".settings.xml"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config, errors.WithMessage(err, <span class="hljs-string"><span class="hljs-string">"could not read config"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := ReadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora a mensagem se torna um belo bug no estilo K &amp; D: </font></font><br><br><pre> <code class="go hljs">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e seu valor contém um link para o motivo original. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := ReadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"original error: %T %v\n"</span></span>, errors.Cause(err), errors.Cause(err)) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"stack trace:\n%+v\n"</span></span>, err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assim, você pode restaurar o erro original e exibir o rastreamento da pilha: </font></font><br><br><pre> <code class="plaintext hljs">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory stack trace: open /Users/dfc/.settings.xml: no such file or directory open failed main.ReadFile /Users/dfc/devel/practical-go/src/errors/readfile2.go:16 main.ReadConfig /Users/dfc/devel/practical-go/src/errors/readfile2.go:29 main.main /Users/dfc/devel/practical-go/src/errors/readfile2.go:35 runtime.main /Users/dfc/go/src/runtime/proc.go:201 runtime.goexit /Users/dfc/go/src/runtime/asm_amd64.s:1333 could not read config</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O pacote </font></font><code>errors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permite adicionar contexto aos valores de erro em um formato conveniente para uma pessoa e uma máquina. </font><font style="vertical-align: inherit;">Em uma apresentação recente, eu lhe disse que no próximo lançamento do Go, esse invólucro aparecerá na biblioteca padrão.</font></font><br><br><a name="8"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Concorrência </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Go geralmente é escolhido por causa de seus recursos de concorrência. Os desenvolvedores fizeram muito para aumentar sua eficiência (em termos de recursos de hardware) e desempenho, mas as funções de paralelismo da Go podem ser usadas para escrever código que não é produtivo nem confiável. No final do artigo, quero dar algumas dicas sobre como evitar algumas das armadilhas das funções simultâneas do Go. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O suporte de simultaneidade de primeira linha da Go é fornecido pelos canais, bem como instruções </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se você estudou a teoria do Go em livros didáticos ou em uma universidade, deve ter notado que a seção paralelismo é sempre uma das últimas do curso. </font><font style="vertical-align: inherit;">Nosso artigo não é diferente: decidi falar sobre paralelismo no final, como algo adicional às habilidades usuais que o programador do Go deve aprender. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Há uma certa dicotomia aqui, porque a principal característica do Go é o nosso modelo simples e fácil de paralelismo. </font><font style="vertical-align: inherit;">Como produto, nossa linguagem se vende à custa de quase essa função. </font><font style="vertical-align: inherit;">Por outro lado, a concorrência não é realmente tão fácil de usar; caso contrário, os autores não o tornariam o último capítulo de seus livros e não teríamos visto com pesar nosso código. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta seção discute algumas das armadilhas do uso ingênuo das funções de simultaneidade Go.</font></font><br><br><a name="8_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.1 </font><font style="vertical-align: inherit;">Faça algum trabalho o tempo todo.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qual é o problema com este programa? </font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O programa faz o que pretendemos: serve um servidor web simples. </font><font style="vertical-align: inherit;">Ao mesmo tempo, gasta o tempo da CPU em um loop infinito, porque </font></font><code>for{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na última linha ele </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloqueia o gorutin main, sem executar nenhuma E / S, não há espera para bloquear, enviar ou receber mensagens ou algum tipo de conexão com o sheduler. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o tempo de execução do Go geralmente é atendido por um sheduler, esse programa é executado sem sentido no processador e pode terminar em um bloqueio ativo (live-lock). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como consertar isso? </font><font style="vertical-align: inherit;">Aqui está uma opção.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { runtime.Gosched() } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pode parecer bobagem, mas essa é uma solução comum que me ocorre na vida real. </font><font style="vertical-align: inherit;">Este é um sintoma de um mal-entendido do problema subjacente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você é um pouco mais experiente com o Go, pode escrever algo assim.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma declaração vazia é </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloqueada para sempre. </font><font style="vertical-align: inherit;">Isso é útil, porque agora não giramos o processador inteiro apenas para uma chamada </font></font><code>runtime.GoSched()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No entanto, tratamos apenas o sintoma, não a causa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quero lhe mostrar outra solução que, espero, já tenha ocorrido a você. </font><font style="vertical-align: inherit;">Em vez de executar </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na goroutine, deixando o principal problema da goroutine, basta executar </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na goroutine principal.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Se você sair da função </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o programa Go será encerrado incondicionalmente, independentemente do que outras goroutines em execução durante a execução do programa façam.</font></font></blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, este é o meu primeiro conselho: se a goroutine não puder progredir até que ele receba um resultado de outro, então é mais fácil fazer o trabalho sozinho, do que delegá-lo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso geralmente elimina muitos rastreamentos de estados e manipulação de canais necessários para transferir o resultado da goroutina para o iniciador do processo.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Muitos programadores do Go abusam de goroutines, especialmente no início. </font><font style="vertical-align: inherit;">Como tudo na vida, a chave do sucesso é a moderação.</font></font></blockquote><br><a name="8_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.2 </font><font style="vertical-align: inherit;">Deixe o paralelismo para o chamador</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qual é a diferença entre as duas APIs? </font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ListDirectory returns the contents of dir. func ListDirectory(dir string) ([]string, error)</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ListDirectory returns a channel over which // directory entries will be published. When the list // of entries is exhausted, the channel will be closed. func ListDirectory(dir string) chan string</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mencionamos as diferenças óbvias: o primeiro exemplo lê o diretório em uma fatia e, em seguida, retorna a fatia ou o erro inteiro se algo der errado. Isso acontece de forma síncrona, o chamador bloqueia </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">até que todas as entradas do diretório sejam lidas. Dependendo do tamanho do diretório, pode levar muito tempo e potencialmente muita memória. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere o segundo exemplo. É um pouco mais como a programação Go clássica, aqui </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorna o canal através do qual as entradas do diretório serão transmitidas. Quando o canal está fechado, isso é um sinal de que não há mais entradas no catálogo. Como o preenchimento do canal ocorre após o retorno </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pode-se assumir que as goroutines começam a preencher o canal.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Na segunda opção, não é necessário usar a goroutine: você pode selecionar um canal suficiente para armazenar todas as entradas do diretório sem bloquear, preenchê-lo, fechá-lo e devolvê-lo ao chamador. </font><font style="vertical-align: inherit;">Mas isso é improvável, pois nesse caso os mesmos problemas surgirão ao usar uma grande quantidade de memória para armazenar em buffer todos os resultados no canal.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A versão do </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canal tem mais dois problemas:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O uso de um canal fechado como um sinal que não há mais elementos a serem processados </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não pode informar o chamador de um conjunto incompleto de elementos devido a um erro. </font><font style="vertical-align: inherit;">O chamador não tem como transmitir a diferença entre um diretório vazio e um erro. </font><font style="vertical-align: inherit;">Nos dois casos, parece que o canal será imediatamente fechado.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O chamador deve continuar lendo o canal quando estiver fechado, porque esta é a única maneira de entender que a goroutina de preenchimento do canal parou de funcionar. </font><font style="vertical-align: inherit;">Essa é uma restrição séria ao uso </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: o chamador passa um tempo lendo do canal, mesmo que tenha recebido todos os dados necessários. </font><font style="vertical-align: inherit;">Isso provavelmente é mais eficiente em termos de uso de memória para diretórios médios e grandes, mas o método não é mais rápido que o método baseado em fatia original.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nos dois casos, a solução é usar um retorno de chamada: uma função que é chamada no contexto de cada entrada de diretório enquanto é executada. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListDirectory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sem surpresa, a função </font></font><code>filepath.WalkDir</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funciona dessa maneira.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Se sua função iniciar a goroutine, você deverá fornecer ao chamador uma maneira de interromper explicitamente essa rotina. </font><font style="vertical-align: inherit;">Geralmente, é mais fácil deixar o modo de execução assíncrona no chamador.</font></font></blockquote><br><a name="8_3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.3 </font><font style="vertical-align: inherit;">Nunca execute a goroutine sem saber quando vai parar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No exemplo anterior, a goroutine foi usada desnecessariamente. </font><font style="vertical-align: inherit;">Mas um dos principais pontos fortes de Go são seus recursos de simultaneidade de primeira classe. </font><font style="vertical-align: inherit;">De fato, em muitos casos, o trabalho paralelo é bastante apropriado e é necessário o uso de goroutines. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse aplicativo simples atende o tráfego http em duas portas diferentes: porta 8080 para tráfego de aplicativos e porta 8001 para acesso ao terminal </font></font><code>/debug/pprof</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> _ <span class="hljs-string"><span class="hljs-string">"net/http/pprof"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) <span class="hljs-comment"><span class="hljs-comment">// debug http.ListenAndServe("0.0.0.0:8080", mux) // app traffic }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora o programa seja simples, é a base de um aplicativo real. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O aplicativo em sua forma atual tem vários problemas que aparecerão à medida que crescem, então vamos examinar imediatamente alguns deles.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveDebug() serveApp() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manipuladores de quebra </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de funções distintas, temos os separou </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nós também seguiu o conselho anterior e fez com que </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deixar a tarefa para garantir o paralelismo do chamador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas existem alguns problemas com o desempenho desse programa. </font><font style="vertical-align: inherit;">Se sairmos </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font><font style="vertical-align: inherit;">sairmos </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o programa será encerrado e será reiniciado pelo gerenciador de processos.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Assim como as funções em Go deixam paralelismo para o chamador, os aplicativos devem parar de monitorar seu estado e reiniciar o programa que os chamou. </font><font style="vertical-align: inherit;">Não responsabilize seus aplicativos por reiniciarem: este procedimento é melhor manipulado de fora do aplicativo.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, ele </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicia em uma goroutina separada e, no caso de seu lançamento, a goroutine termina, enquanto o restante do programa continua. </font><font style="vertical-align: inherit;">Seus desenvolvedores não gostarão do fato de que você não pode obter estatísticas de aplicativos porque o manipulador </font></font><code>/debug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parou de funcionar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos garantir que o aplicativo seja fechado se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alguma</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> goroutina que o servir </font><font style="vertical-align: inherit;">parar </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveDebug() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveApp() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora </font></font><code>serverApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eles </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verificam os erros </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, se necessário, os chamam </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como os dois manipuladores trabalham em goroutines, traçamos a rotina principal em </font></font><code>select{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa abordagem tem vários problemas:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se ele </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornar com um erro </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, não haverá chamada </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o serviço HTTP nessa porta será encerrado sem parar o aplicativo.</font></font><br></li><li> <code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chama </font></font><code>os.Exit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que sai incondicionalmente do programa; </font><font style="vertical-align: inherit;">chamadas adiadas não funcionarão, outras goroutines não serão notificadas do fechamento, o programa simplesmente parará. </font><font style="vertical-align: inherit;">Isso dificulta a gravação de testes para essas funções.</font></font></li></ol><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Use apenas </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em funções </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, queremos transmitir qualquer erro que ocorra ao criador da goroutina, para que ele possa descobrir por que ela parou e concluiu o processo de maneira limpa.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> error, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done &lt;- serveDebug() }() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done &lt;- serveApp() }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(done); i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := &lt;-done; err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"error: %v"</span></span>, err) } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O status de retorno da Goroutine pode ser obtido através do canal. O tamanho do canal é igual ao número de goroutines que queremos controlar, portanto, o envio ao canal </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não será bloqueado, pois isso bloqueará o desligamento das goroutines e causará um vazamento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o canal </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não pode ser fechado com segurança, não podemos usar o idioma para o ciclo do canal </font></font><code>for range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">até que todas as goroutines tenham sido relatadas. Em vez disso, executamos todas as goroutines em execução em um ciclo, que é igual à capacidade do canal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora temos uma maneira de sair corretamente de todas as goroutines e corrigir todos os erros que encontrarem. Resta apenas enviar um sinal para concluir o trabalho da primeira goroutina para todos os outros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O apelo a</font></font><code>http.Server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sobre a conclusão, envolvi essa lógica em uma função auxiliar. </font><font style="vertical-align: inherit;">O ajudante </font></font><code>serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aceita o endereço e </font></font><code>http.Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da mesma forma </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o canal </font></font><code>stop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que usamos para executar o método </font></font><code>Shutdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, handler http.Handler, stop &lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { s := http.Server{ Addr: addr, Handler: handler, } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { &lt;-stop <span class="hljs-comment"><span class="hljs-comment">// wait for stop signal s.Shutdown(context.Background()) }() return s.ListenAndServe() } func serveApp(stop &lt;-chan struct{}) error { mux := http.NewServeMux() mux.HandleFunc("/", func(resp http.ResponseWriter, req *http.Request) { fmt.Fprintln(resp, "Hello, QCon!") }) return serve("0.0.0.0:8080", mux, stop) } func serveDebug(stop &lt;-chan struct{}) error { return serve("127.0.0.1:8001", http.DefaultServeMux, stop) } func main() { done := make(chan error, 2) stop := make(chan struct{}) go func() { done &lt;- serveDebug(stop) }() go func() { done &lt;- serveApp(stop) }() var stopped bool for i := 0; i &lt; cap(done); i++ { if err := &lt;-done; err != nil { fmt.Println("error: %v", err) } if !stopped { stopped = true close(stop) } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, para cada valor no canal </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, fechamos o canal </font></font><code>stop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o que faz com que cada gorutina desse canal se feche </font></font><code>http.Server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por sua vez, isso leva a um retorno de todas as goroutinas restantes </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Quando todas as gorutinas em execução são interrompidas, </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o processo termina e o processo é interrompido corretamente.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Escrever essa lógica por conta própria é um trabalho repetitivo e o risco de erros. </font><font style="vertical-align: inherit;">Veja algo como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este pacote</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que fará a maior parte do trabalho para você.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441842/">https://habr.com/ru/post/pt441842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441826/index.html">O que está acontecendo no mercado de streaming de áudio: discutindo o desenvolvimento de plataformas de streaming</a></li>
<li><a href="../pt441830/index.html">Guia do Usuário Kibana. Visualização. Parte 4</a></li>
<li><a href="../pt441832/index.html">Quem é o gerente do projeto na opinião do proprietário da empresa e como lidar com isso</a></li>
<li><a href="../pt441834/index.html">Não leve para o trabalho. Mas e se o problema estiver em você?</a></li>
<li><a href="../pt441836/index.html">Uma história na nuvem: Huawei + 3data = nuvem</a></li>
<li><a href="../pt441844/index.html">iRobot Scooba: experiência e soluções para problemas comuns de um limpador de robô de lavagem</a></li>
<li><a href="../pt441848/index.html">Estágios para desenvolvedores em Avito: missões de combate e trabalho com mentores experientes</a></li>
<li><a href="../pt441850/index.html">Cartomancia em redes neurais: se o próprio autor anotou nos comentários no post</a></li>
<li><a href="../pt441852/index.html">42 Vale do Silício: como ser selecionado</a></li>
<li><a href="../pt441854/index.html">REST? Tome um JSON-RPC idiota</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>