<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚úàÔ∏è ‚úåüèª üë©üèæ‚Äçüåæ C ++ vtables. Teil 2 (Virtuelle Vererbung + Compiler-generierter Code) üë©‚Äçüë¶ ü§¥üèø ü§ôüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die √úbersetzung des Artikels wurde speziell f√ºr Studierende des Kurses "C ++ Developer" erstellt . Ist es interessant, sich in diese Richtung zu entwi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ vtables. Teil 2 (Virtuelle Vererbung + Compiler-generierter Code)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/480610/"><p>  <em>Die √úbersetzung des Artikels wurde speziell f√ºr Studierende des Kurses <a href="https://otus.pw/HhBg/">"C ++ Developer" erstellt</a> .</em>  <em>Ist es interessant, sich in diese Richtung zu entwickeln?</em>  <em>Sehen Sie sich die Aufzeichnung der <a href="https://otus.pw/B2p1/">Google Test Framework Practice</a> Class an!</em> </p><br><p><img src="https://habrastorage.org/webt/tk/dp/8n/tkdp8nfahc7sglqks8sl_tazk1o.png"></p><br><h2 id="chast-3---virtualnoe-nasledovanie">  Teil 3 - Virtuelle Vererbung </h2><br><p>  Im <a href="https://habr.com/ru/company/otus/blog/479802/">ersten und zweiten Teil</a> dieses Artikels haben wir dar√ºber gesprochen, wie vtables in den einfachsten F√§llen und dann in mehrfacher Vererbung funktionieren.  Virtuelle Vererbung macht die Situation noch komplizierter. <a name="habracut"></a></p><br><p>  Wie Sie sich vielleicht erinnern, bedeutet virtuelle Vererbung, dass es in einer bestimmten Klasse nur eine Instanz der Basisklasse gibt.  Zum Beispiel: </p><br><pre><code class="plaintext hljs">class ios ... class istream : virtual public ios ... class ostream : virtual public ios ... class iostream : public istream, public ostream</code> </pre> <br><p>  <code>iostream</code> oben genannte <code>virtual</code> Schl√ºsselwort <code>iostream</code> tats√§chlich zwei Instanzen von <code>ios</code> , die w√§hrend der Synchronisierung Kopfschmerzen verursachen k√∂nnten und einfach ineffektiv w√§ren. </p><br><p>  Um die virtuelle Vererbung zu verstehen, betrachten wir das folgende Codefragment: </p><br><pre> <code class="plaintext hljs">#include &lt;iostream&gt; using namespace std; class Grandparent { public: virtual void grandparent_foo() {} int grandparent_data; }; class Parent1 : virtual public Grandparent { public: virtual void parent1_foo() {} int parent1_data; }; class Parent2 : virtual public Grandparent { public: virtual void parent2_foo() {} int parent2_data; }; class Child : public Parent1, public Parent2 { public: virtual void child_foo() {} int child_data; }; int main() { Child child; }</code> </pre> <br><p>  Lass uns das <code>child</code> erforschen.  Ich beginne damit, eine gro√üe Menge an Speicher genau dort <code>vtable Child</code> , wo das <code>vtable Child</code> startet, wie wir es in den vorherigen Abschnitten getan haben, und dann die Ergebnisse zu analysieren.  Ich schlage vor, hier einen kurzen Blick auf das Ergebnis zu werfen und darauf zur√ºckzukommen, wenn ich die folgenden Details offenlege. </p><br><pre> <code class="plaintext hljs">(gdb) p child $1 = {&lt;Parent1&gt; = {&lt;Grandparent&gt; = {_vptr$Grandparent = 0x400998 &lt;vtable for Child+96&gt;, grandparent_data = 0}, _vptr$Parent1 = 0x400950 &lt;vtable for Child+24&gt;, parent1_data = 0}, &lt;Parent2&gt; = {_vptr$Parent2 = 0x400978 &lt;vtable for Child+64&gt;, parent2_data = 4195888}, child_data = 0} (gdb) x/600xb 0x400938 0x400938 &lt;vtable for Child&gt;: 0x20 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400940 &lt;vtable for Child+8&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400948 &lt;vtable for Child+16&gt;: 0x00 0x0b 0x40 0x00 0x00 0x00 0x00 0x00 0x400950 &lt;vtable for Child+24&gt;: 0x70 0x08 0x40 0x00 0x00 0x00 0x00 0x00 0x400958 &lt;vtable for Child+32&gt;: 0xa0 0x08 0x40 0x00 0x00 0x00 0x00 0x00 0x400960 &lt;vtable for Child+40&gt;: 0x10 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400968 &lt;vtable for Child+48&gt;: 0xf0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x400970 &lt;vtable for Child+56&gt;: 0x00 0x0b 0x40 0x00 0x00 0x00 0x00 0x00 0x400978 &lt;vtable for Child+64&gt;: 0x90 0x08 0x40 0x00 0x00 0x00 0x00 0x00 0x400980 &lt;vtable for Child+72&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400988 &lt;vtable for Child+80&gt;: 0xe0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x400990 &lt;vtable for Child+88&gt;: 0x00 0x0b 0x40 0x00 0x00 0x00 0x00 0x00 0x400998 &lt;vtable for Child+96&gt;: 0x80 0x08 0x40 0x00 0x00 0x00 0x00 0x00 0x4009a0 &lt;VTT for Child&gt;: 0x50 0x09 0x40 0x00 0x00 0x00 0x00 0x00 0x4009a8 &lt;VTT for Child+8&gt;: 0xf8 0x09 0x40 0x00 0x00 0x00 0x00 0x00 0x4009b0 &lt;VTT for Child+16&gt;: 0x18 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x4009b8 &lt;VTT for Child+24&gt;: 0x98 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x4009c0 &lt;VTT for Child+32&gt;: 0xb8 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x4009c8 &lt;VTT for Child+40&gt;: 0x98 0x09 0x40 0x00 0x00 0x00 0x00 0x00 0x4009d0 &lt;VTT for Child+48&gt;: 0x78 0x09 0x40 0x00 0x00 0x00 0x00 0x00 0x4009d8: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x4009e0 &lt;construction vtable for Parent1-in-Child&gt;: 0x20 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x4009e8 &lt;construction vtable for Parent1-in-Child+8&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x4009f0 &lt;construction vtable for Parent1-in-Child+16&gt;: 0x50 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x4009f8 &lt;construction vtable for Parent1-in-Child+24&gt;: 0x70 0x08 0x40 0x00 0x00 0x00 0x00 0x00 0x400a00 &lt;construction vtable for Parent1-in-Child+32&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400a08 &lt;construction vtable for Parent1-in-Child+40&gt;: 0xe0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x400a10 &lt;construction vtable for Parent1-in-Child+48&gt;: 0x50 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400a18 &lt;construction vtable for Parent1-in-Child+56&gt;: 0x80 0x08 0x40 0x00 0x00 0x00 0x00 0x00 0x400a20 &lt;typeinfo name for Parent1&gt;: 0x37 0x50 0x61 0x72 0x65 0x6e 0x74 0x31 0x400a28 &lt;typeinfo name for Parent1+8&gt;: 0x00 0x31 0x31 0x47 0x72 0x61 0x6e 0x64 0x400a30 &lt;typeinfo name for Grandparent+7&gt;: 0x70 0x61 0x72 0x65 0x6e 0x74 0x00 0x00 0x400a38 &lt;typeinfo for Grandparent&gt;: 0x50 0x10 0x60 0x00 0x00 0x00 0x00 0x00 0x400a40 &lt;typeinfo for Grandparent+8&gt;: 0x29 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400a48: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400a50 &lt;typeinfo for Parent1&gt;: 0xa0 0x10 0x60 0x00 0x00 0x00 0x00 0x00 0x400a58 &lt;typeinfo for Parent1+8&gt;: 0x20 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400a60 &lt;typeinfo for Parent1+16&gt;: 0x00 0x00 0x00 0x00 0x01 0x00 0x00 0x00 0x400a68 &lt;typeinfo for Parent1+24&gt;: 0x38 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400a70 &lt;typeinfo for Parent1+32&gt;: 0x03 0xe8 0xff 0xff 0xff 0xff 0xff 0xff 0x400a78: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400a80 &lt;construction vtable for Parent2-in-Child&gt;: 0x10 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400a88 &lt;construction vtable for Parent2-in-Child+8&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400a90 &lt;construction vtable for Parent2-in-Child+16&gt;: 0xd0 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400a98 &lt;construction vtable for Parent2-in-Child+24&gt;: 0x90 0x08 0x40 0x00 0x00 0x00 0x00 0x00 0x400aa0 &lt;construction vtable for Parent2-in-Child+32&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400aa8 &lt;construction vtable for Parent2-in-Child+40&gt;: 0xf0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x400ab0 &lt;construction vtable for Parent2-in-Child+48&gt;: 0xd0 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400ab8 &lt;construction vtable for Parent2-in-Child+56&gt;: 0x80 0x08 0x40 0x00 0x00 0x00 0x00 0x00 0x400ac0 &lt;typeinfo name for Parent2&gt;: 0x37 0x50 0x61 0x72 0x65 0x6e 0x74 0x32 0x400ac8 &lt;typeinfo name for Parent2+8&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400ad0 &lt;typeinfo for Parent2&gt;: 0xa0 0x10 0x60 0x00 0x00 0x00 0x00 0x00 0x400ad8 &lt;typeinfo for Parent2+8&gt;: 0xc0 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400ae0 &lt;typeinfo for Parent2+16&gt;: 0x00 0x00 0x00 0x00 0x01 0x00 0x00 0x00 0x400ae8 &lt;typeinfo for Parent2+24&gt;: 0x38 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400af0 &lt;typeinfo for Parent2+32&gt;: 0x03 0xe8 0xff 0xff 0xff 0xff 0xff 0xff 0x400af8 &lt;typeinfo name for Child&gt;: 0x35 0x43 0x68 0x69 0x6c 0x64 0x00 0x00 0x400b00 &lt;typeinfo for Child&gt;: 0xa0 0x10 0x60 0x00 0x00 0x00 0x00 0x00 0x400b08 &lt;typeinfo for Child+8&gt;: 0xf8 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400b10 &lt;typeinfo for Child+16&gt;: 0x02 0x00 0x00 0x00 0x02 0x00 0x00 0x00 0x400b18 &lt;typeinfo for Child+24&gt;: 0x50 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400b20 &lt;typeinfo for Child+32&gt;: 0x02 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400b28 &lt;typeinfo for Child+40&gt;: 0xd0 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400b30 &lt;typeinfo for Child+48&gt;: 0x02 0x10 0x00 0x00 0x00 0x00 0x00 0x00 0x400b38 &lt;vtable for Grandparent&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400b40 &lt;vtable for Grandparent+8&gt;: 0x38 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400b48 &lt;vtable for Grandparent+16&gt;: 0x80 0x08 0x40 0x00 0x00 0x00 0x00 0x00</code> </pre> <br><p>  Wow, es gibt viele Informationen.  Zwei neue Fragen <code>vtable for X-in-Child</code> sofort auf: Was ist <code>VTT</code> und was ist die Konstruktionstabelle <code>vtable for X-in-Child</code> ?  Wir werden sie schnellstm√∂glich beantworten. <br>  Beginnen wir mit der Kinderspeicherstruktur: </p><br><div class="scrollable-table"><table><thead><tr><th>  Gr√∂√üe </th><th>  Wert </th></tr></thead><tbody><tr><td>  8 Bytes </td><td>  _vptr $ Parent1 </td></tr><tr><td>  4 Bytes </td><td>  parent1_data (+ 4 Auff√ºllbytes) </td></tr><tr><td>  8 Bytes </td><td>  _vptr $ Parent2 </td></tr><tr><td>  4 Bytes </td><td>  parent2_data </td></tr><tr><td>  4 Bytes </td><td>  child_data </td></tr><tr><td>  8 Bytes </td><td>  _vptr $ Gro√üeltern </td></tr><tr><td>  4 Bytes </td><td>  grandparent_data (+ 4 F√ºllbytes) </td></tr></tbody></table></div><br><p>  In der Tat hat <code>Child</code> nur 1 Instanz von Gro√üeltern.  Das Nichttriviale ist, dass er der Letzte im Ged√§chtnis ist, obwohl er der H√∂chste in der Hierarchie ist. <br>  Hier ist die <code>vtable</code> Struktur: </p><br><div class="scrollable-table"><table><thead><tr><th>  Die Adresse </th><th>  Wert </th><th>  Inhalt </th></tr></thead><tbody><tr><td>  0x400938 </td><td>  0x20 (32) </td><td>  Virtual-Base-Offset (wir werden das bald besprechen) </td></tr><tr><td>  0x400940 </td><td>  0 </td><td>  top_offset </td></tr><tr><td>  0x400948 </td><td>  0x400b00 </td><td>  typeinfo f√ºr kind </td></tr><tr><td>  0x400950 </td><td>  0x400870 </td><td>  Parent1 :: parent1_foo ().  Der vtable-Zeiger Parent1 zeigt hier. </td></tr><tr><td>  0x400958 </td><td>  0x4008a0 </td><td>  Child :: child_foo () </td></tr><tr><td>  0x400960 </td><td>  0x10 (16) </td><td>  Virtual-Base-Offset </td></tr><tr><td>  0x400968 </td><td>  -16 </td><td>  top_offset </td></tr><tr><td>  0x4009 </td><td>  0x400b </td><td>  typeinfo f√ºr kind </td></tr><tr><td>  70 </td><td>  00 </td><td></td></tr><tr><td>  0x400978 </td><td>  0x400890 </td><td>  Parent2 :: parent2_foo ().  Der vtable-Zeiger Parent2 zeigt hier. </td></tr><tr><td>  0x400980 </td><td>  0 </td><td>  Virtual-Base-Offset </td></tr><tr><td>  0x400988 </td><td>  -32 </td><td>  top_offset </td></tr><tr><td>  0x400990 </td><td>  0x400b00 </td><td>  typeinfo f√ºr kind </td></tr><tr><td>  0x400998 </td><td>  0x400880 </td><td>  Grandparent :: grandparent_foo ().  Der vtable-Zeiger Grandparent zeigt hier. </td></tr></tbody></table></div><br><p>  Oben gibt es ein neues Konzept - <code>virtual-base offset</code> .  Bald werden wir verstehen, was er dort tut. <br>  Lassen Sie uns als N√§chstes diese seltsam aussehenden <code>construction vtables</code> .  Hier ist die Konstruktionstabelle <code>vtable for Parent1-in-Child</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Wert </th><th>  Inhalt </th></tr></thead><tbody><tr><td>  0x20 (32) </td><td>  Virtual-Base-Offset </td></tr><tr><td>  0 </td><td>  oben versetzt </td></tr><tr><td>  0x400a50 </td><td>  TypInfo f√ºr Parent1 </td></tr><tr><td>  0x400870 </td><td>  Parent1 :: parent1_foo () </td></tr><tr><td>  0 </td><td>  Virtual-Base-Offset </td></tr><tr><td>  -32 </td><td>  oben versetzt </td></tr><tr><td>  0x400a50 </td><td>  TypInfo f√ºr Parent1 </td></tr><tr><td>  0x400880 </td><td>  Gro√üeltern :: grandparent_foo () </td></tr></tbody></table></div><br><p>  Im Moment halte ich es f√ºr verst√§ndlicher, den Prozess zu beschreiben, als mehr Tabellen mit Zufallszahlen auf Sie zu stapeln.  Also: </p><br><p>  Stellen Sie sich vor, Sie sind ein <code>Child</code> .  Sie werden gebeten, sich in einem neuen St√ºck Erinnerung zu konstruieren.  Da Sie <code>Grandparent</code> direkt erben (was virtuelle Vererbung bedeutet), rufen Sie seinen Konstruktor direkt auf (wenn es keine virtuelle Vererbung w√§re, w√ºrden Sie den Konstruktor <code>Parent1</code> , der wiederum den <code>Grandparent</code> Konstruktor aufrufen w√ºrde).  Sie setzen <code>this += 32</code> Bytes, da sich hier <code>Grandparent</code> befinden und Sie den Konstruktor aufrufen.  Sehr einfach. </p><br><p>  Dann ist es Zeit, <code>Parent1</code> zu <code>Parent1</code> .  <code>Parent1</code> kann davon ausgehen, dass <code>Grandparent</code> zum Zeitpunkt seiner Erstellung bereits erstellt wurde, sodass er beispielsweise auf Daten und Methoden von <code>Grandparent</code> zugreifen kann.  Aber warte, wie kann er wissen, wo er diese Daten findet?  Sie befinden sich nicht am selben Ort wie die Variablen <code>Parent1</code> ! </p><br><p>  Die <code>construction table for Parent1-in-Child</code> betritt die Szene.  In dieser Tabelle wird <code>Parent1</code> wo Daten zu finden sind, auf die <code>Parent1</code> kann.  <code>this</code> verweist auf die Daten von <code>Parent1</code> .  <code>virtual-base offset</code> gibt an, wo Sie Gro√üeltern-Daten finden k√∂nnen: Schritt 32 Bytes vorw√§rts, und Sie finden <code>Grandparent</code> Speicher.  Verstehst du es?  Der Versatz f√ºr die virtuelle Basis √§hnelt top_offset, gilt jedoch f√ºr virtuelle Klassen. </p><br><p>  <code>Parent2</code> wir das verstanden haben, ist der Aufbau von <code>Parent2</code> im Grunde der gleiche, nur unter Verwendung der <code>construction table for Parent2-in-Child</code> .  Tats√§chlich hat <code>Parent2-in-Child</code> einen <code>virtual-base offset</code> der <code>virtual-base offset</code> von 16 Bytes. </p><br><p>  Lassen Sie die Informationen ein wenig einweichen.  Bist du bereit fortzufahren?  Gut <br>  Kommen wir nun zu <code>VTT</code> .  Hier ist die <code>VTT</code> Struktur: </p><br><div class="scrollable-table"><table><thead><tr><th>  Die Adresse </th><th>  Wert </th><th>  Symbol </th><th>  Inhalt </th></tr></thead><tbody><tr><td>  0x4009a0 </td><td>  0x400950 </td><td>  vtabelle f√ºr Kind + 24 </td><td>  Parent1-Eintr√§ge in vtable Child </td></tr><tr><td>  0x4009a8 </td><td>  0x4009f8 </td><td>  Konstruktionstabelle f√ºr Parent1-in-Child + 24 </td><td>  Parent1-Methoden in Parent1-in-Child </td></tr><tr><td>  0x4009b0 </td><td>  0x400a18 </td><td>  Konstruktionstabelle f√ºr Parent1-in-Child + 56 </td><td>  Gro√üelternmethoden f√ºr Parent1-in-Child </td></tr><tr><td>  0x4009b8 </td><td>  0x400a98 </td><td>  Konstruktionstabelle f√ºr Parent2-in-Child + 24 </td><td>  Parent2-Methoden in Parent2-in-Child </td></tr><tr><td>  0x4009c0 </td><td>  0x400ab8 </td><td>  Konstruktionstabelle f√ºr Parent2-in-Child + 56 </td><td>  `Gro√üelternmethoden f√ºr Parent2-in-Child </td></tr><tr><td>  0x4009c8 </td><td>  0x400998 </td><td>  vtable f√ºr Kind + 96 </td><td>  `Gro√üelterneintr√§ge in vtable Child </td></tr><tr><td>  0x4009d0 </td><td>  0x400978 </td><td>  vtable f√ºr Kind + 64 </td><td>  `Parent2-Eintr√§ge in vtable Child </td></tr></tbody></table></div><br><p>  <code>VTT</code> steht f√ºr <code>virtual-table table</code> , was bedeutet, dass es sich um eine vtable handelt.  Dies ist eine √úbersetzungstabelle, die beispielsweise wei√ü, ob der Konstruktor <code>Parent1</code> f√ºr ein einzelnes Objekt, f√ºr das <code>Parent1-in-Child</code> Objekt oder f√ºr <code>Parent1-in-SomeOtherObject</code> .  Es wird immer unmittelbar nach <code>vtable</code> , damit der Compiler wei√ü, wo er es finden kann.  Daher muss in den Objekten selbst kein weiterer Zeiger gespeichert werden. </p><br><p>  Fuh ... viele Details, aber ich denke, wir haben alles abgedeckt, was ich abdecken wollte.  Im vierten Teil werden wir uns mit den Details der √ºbergeordneten <code>vtables</code> .  √úberspringen Sie nicht, da dies wahrscheinlich der wichtigste Teil in diesem Artikel ist! </p><br><h2 id="chast-4---kod-sgenerirovannyy-kompilyatorom">  Teil 4 - Vom Compiler generierter Code </h2><br><p>  An diesem Punkt in diesem Artikel haben wir erfahren, wie <code>vtables</code> und <code>typeinfo</code> in unsere Bin√§rdateien passen und wie der Compiler sie verwendet.  Jetzt werden wir den Teil der Arbeit verstehen, den der Compiler automatisch f√ºr uns erledigt. </p><br><h4 id="konstruktory">  Konstruktoren </h4><br><p>  F√ºr den Konstruktor einer Klasse wird der folgende Code generiert: </p><br><ul><li>  Aufrufen von √ºbergeordneten Konstrukten, falls vorhanden; </li><li>  Festlegen von vtable-Zeigern, falls vorhanden; </li><li>  Initialisierung der Mitglieder gem√§√ü der Liste der Initialisierer; </li><li>  Code-Ausf√ºhrung in Klammern des Konstruktors. </li></ul><br><p>  All dies kann ohne expliziten Code geschehen: </p><br><ul><li>  √úbergeordnete Konstruktoren werden standardm√§√üig automatisch gestartet, sofern nicht anders angegeben. </li><li>  Mitglieder werden standardm√§√üig initialisiert, wenn sie keinen Standardwert oder keine Eintr√§ge in der Initialisierungsliste haben. </li><li>  Der gesamte Konstruktor kann markiert werden = default; </li><li>  Nur die vtable-Zuweisung wird immer ausgeblendet. </li></ul><br><p>  Hier ist ein Beispiel: </p><br><pre> <code class="plaintext hljs">#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Parent { public: Parent() { Foo(); } virtual ~Parent() = default; virtual void Foo() { cout &lt;&lt; "Parent" &lt;&lt; endl; } int i = 0; }; class Child : public Parent { public: Child() : j(1) { Foo(); } void Foo() override { cout &lt;&lt; "Child" &lt;&lt; endl; } int j; }; class Grandchild : public Child { public: Grandchild() { Foo(); s = "hello"; } void Foo() override { cout &lt;&lt; "Grandchild" &lt;&lt; endl; } string s; }; int main() { Grandchild g; }</code> </pre> <br><p>  Schreiben wir einen Pseudocode f√ºr den Konstruktor jeder Klasse: </p><br><div class="scrollable-table"><table><thead><tr><th>  Elternteil </th><th>  Kind </th><th>  Enkelkind </th></tr></thead><tbody><tr><td>  1. vtable = vtable Parent; </td><td>  1. Ruft den Standardkonstruktor Parent auf. </td><td>  1. Ruft den Standardkonstruktor Child auf. </td></tr><tr><td>  2. i = 0; </td><td>  2. vtable = vtable Child; </td><td>  2. vtable = vtable Enkelkind; </td></tr><tr><td>  3. Ruft Foo () auf; </td><td>  3. j = 1; </td><td>  3. Ruft den Standardkonstruktor auf; </td></tr><tr><td></td><td>  4. Ruft Foo () auf; </td><td>  4. Ruft Foo () auf; </td></tr><tr><td></td><td></td><td>  5. Ruft den Operator = f√ºr s auf; </td></tr></tbody></table></div><br><p>  Angesichts dessen ist es nicht verwunderlich, dass sich vtable im Kontext des Klassenkonstruktors auf die vtable dieser Klasse selbst und nicht auf ihre spezifische Klasse bezieht.  Dies bedeutet, dass virtuelle Anrufe so aufgel√∂st werden, als ob keine Erben verf√ºgbar w√§ren.  So die Schlussfolgerung </p><br><pre> <code class="plaintext hljs">Parent Child Grandchild</code> </pre> <br><p>  Was ist mit rein virtuellen Funktionen?  Wenn sie nicht implementiert sind (ja, Sie k√∂nnen rein virtuelle Funktionen implementieren, aber warum brauchen Sie das?), Werden Sie wahrscheinlich (und hoffentlich) direkt zu segfault √ºbergehen.  Einige Compiler vernachl√§ssigen den Fehler, was cool ist. </p><br><h4 id="destruktory">  Destruktoren </h4><br><p>  Wie Sie sich vorstellen k√∂nnen, verhalten sich Destruktoren wie Konstruktoren, nur in umgekehrter Reihenfolge. </p><br><p>  Hier ist eine kurze √úbung zum Nachdenken: Warum √§ndern Destruktoren den vtable-Zeiger so, dass er auf seine eigene Klasse zeigt, anstatt einen Zeiger auf eine bestimmte Klasse zu lassen?  Antwort: Zum Zeitpunkt des Starts des Destruktors war jede erbende Klasse bereits zerst√∂rt.  Das Aufrufen von Methoden dieser Klasse ist nicht das, was Sie tun m√∂chten. </p><br><h4 id="neyavnoe-privedenie">  Implizite Besetzung </h4><br><p>  Wie wir im <a href="https://habr.com/ru/company/otus/blog/479802/">zweiten und dritten Teil gesehen haben</a> , entspricht ein Zeiger auf ein untergeordnetes Objekt nicht unbedingt dem √ºbergeordneten Zeiger derselben Instanz (wie im Fall der Mehrfachvererbung). </p><br><p>  F√ºr Sie (den Entwickler) gibt es jedoch keine zus√§tzliche Arbeit zum Aufrufen einer Funktion, die einen √ºbergeordneten Zeiger empf√§ngt.  Dies liegt daran, dass der Compiler dies implizit verschiebt, wenn Sie Zeiger und Verweise an √ºbergeordnete Klassen anh√§ngen. </p><br><h4 id="dinamicheskoe-privedenie-rtti">  Dynamische Besetzung (RTTI) </h4><br><p>  Dynamische Casts verwenden <code>typeinfo</code> Tabellen, die wir im ersten Teil untersucht haben.  Sie tun dies zur Laufzeit, indem sie den Eintrag <code>typeinfo</code> einen Zeiger vor dem Zeiger <code>vtable</code> und die Klasse von dort verwenden, um zu pr√ºfen, ob die <code>vtable</code> m√∂glich ist. </p><br><p>  Dies erkl√§rt die <a href="https://tinodidriksen.com/2010/04/14/cpp-dynamic-cast-performance/">Kosten von dynamic_cast</a> bei h√§ufiger Verwendung. </p><br><h4 id="ukazateli-na-metody">  Methodenzeiger </h4><br><p>  Ich plane, in Zukunft einen vollst√§ndigen Beitrag √ºber Zeiger auf Methoden zu schreiben.  Vorher m√∂chte ich betonen, dass ein Zeiger auf eine Methode, die auf eine virtuelle Funktion verweist, tats√§chlich eine √ºberschriebene Methode aufruft (im Gegensatz zu Zeigern auf Funktionen, die keine Mitglieder sind). </p><br><pre> <code class="plaintext hljs">// TODO:  ,    </code> </pre> <br><h4 id="proverte-sebya">  √úberpr√ºfe dich selbst! </h4><br><p>  Jetzt k√∂nnen Sie sich erkl√§ren, warum sich das folgende Codefragment so verh√§lt wie es sich verh√§lt: </p><br><pre> <code class="plaintext hljs">#include &lt;iostream&gt; using namespace std; class FooInterface { public: virtual ~FooInterface() = default; virtual void Foo() = 0; }; class BarInterface { public: virtual ~BarInterface() = default; virtual void Bar() = 0; }; class Concrete : public FooInterface, public BarInterface { public: void Foo() override { cout &lt;&lt; "Foo()" &lt;&lt; endl; } void Bar() override { cout &lt;&lt; "Bar()" &lt;&lt; endl; } }; int main() { Concrete c; c.Foo(); c.Bar(); FooInterface* foo = &amp;c; foo-&gt;Foo(); BarInterface* bar = (BarInterface*)(foo); bar-&gt;Bar(); //  "Foo()" - WTF? }</code> </pre> <br><p>  Damit ist mein vierteiliger Artikel abgeschlossen.  Ich hoffe du lernst etwas Neues, genau wie ich. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480610/">https://habr.com/ru/post/de480610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480596/index.html">Was erwartet Sie in dem innovativen Netzwerkbetriebssystem ArubaOS-CX</a></li>
<li><a href="../de480598/index.html">Die Basis jeder Programmierung auf ... R√§tseln</a></li>
<li><a href="../de480600/index.html">Schnellere Aufz√§hlung</a></li>
<li><a href="../de480606/index.html">F√ºnf weitere Ideen, wie Sie Ihre F√§higkeiten als Front-End-Entwickler verbessern k√∂nnen (Dezember 2019)</a></li>
<li><a href="../de480608/index.html">Rust √ºbertrifft C ++ mit Benchmarks</a></li>
<li><a href="../de480612/index.html">Nehmen Sie diese √Ñnderungen vor, um die Barrierefreiheitsstandards f√ºr das Webdesign zu erf√ºllen.</a></li>
<li><a href="../de480614/index.html">Schnelle ENUM</a></li>
<li><a href="../de480618/index.html">Elektronisches Spiel Tic Tac Toe. Zu was bin ich gekommen?</a></li>
<li><a href="../de480620/index.html">SD-WAN und DNA zur Unterst√ºtzung des Administrators: Merkmale von Architekturen und Verfahren</a></li>
<li><a href="../de480622/index.html">So nutzen Sie die verf√ºgbare Speicherkapazit√§t richtig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>