<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌋 🏑 🎡 智能合约简介 👨‍❤️‍💋‍👨 ↗️ 🚝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我们将研究什么是智能合约，它们是什么，熟悉不同的智能合约平台，它们的功能，并讨论它们如何工作以及可以带来哪些优势。 对于不熟悉智能合约主题但想进一步了解它的读者来说，该材料将非常有用。 

 常规合同与 智能合约 
 在详细介绍之前，让我们看一下纸上设置的普通合同和以数字形式显示的智能合同...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>智能合约简介</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/distributedlab/blog/413231/"> 在本文中，我们将研究什么是智能合约，它们是什么，熟悉不同的智能合约平台，它们的功能，并讨论它们如何工作以及可以带来哪些优势。 对于不熟悉智能合约主题但想进一步了解它的读者来说，该材料将非常有用。 <br><a name="habracut"></a><br><h2>  <b>常规合同与</b>  <b>智能合约</b> </h2><br> 在详细介绍之前，让我们看一下纸上设置的普通合同和以数字形式显示的智能合同之间的区别的示例。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e19/d3a/226/e19d3a22688347a83b9ef987a94162c7.png" alt="图片"><br><br> 在进行智能合约之前这是如何工作的？ 想象一下，一群人想要为价值分配建立一些规则和条件，以及一种根据给定的规则和条件保证这种分配的实施的机制。 然后他们聚在一起，写了一篇论文，写下了他们的识别数据，条件，所涉及的值，设置日期和签名。 该合同还由受托方（例如公证人）证明。 此外，这些人以这种合同的纸质副本朝不同的方向发展，并开始执行可能与合同本身不符的某些行动，即他们做了一件事，并在纸上确信他们应该做完全不同的事情。 以及如何摆脱这种情况？ 实际上，该小组的一名成员需要拿出这份文件，拿出一些证据，将其提交法院，并寻求合同与实际行动之间的遵守。 通常很难实现该合同的公平执行，从而导致不愉快的后果。 <br><br> 关于智能合约可以说些什么？ 它们结合了编写合同条款的可能性和严格执行合同的机制。 如果已经设置了条件并且已经签署了相应的事务或请求，则在接受该请求或事务之后，将无法再更改条件或影响其实现。 <br><br> 有一个验证器或整个网络，还有一个数据库，用于按严格的时间顺序存储所有要执行的智能合约。 同样重要的是，该数据库应包含执行智能合约的所有触发条件。 另外，它必须考虑到非常的价值，其价值在合同中有所描述。 如果这适用于某种数字货币，则该数据库应将其考虑在内。 <br><br> 换句话说，智能合约的验证者必须有权访问智能合约所使用的所有数据。 例如，应该使用一个数据库来同时记录数字货币，用户余额，用户交易和时间戳。 然后，在智能合约中，条件可能是用户以某种货币的余额，一定时间的开始或某笔交易的事实，但仅此而已。 <br><br><h2>  <b>智能合约定义</b> </h2><br> 通常，该术语本身是由研究人员Nick Szabo发明的，于1994年首次应用，并在1997年的一篇文章中进行了记录，该文章描述了智能合约的概念。 <br><br> 智能合约意味着执行价值分配的某种自动化，这可能仅取决于预定义的条件。 以最简单的形式，它看起来像是具有特定条件的合同，由某些各方签署。 <br><br> 智能合约旨在最大程度地减少对第三方的信任。 有时，一切所依赖的决策中心会被完全排除。 此外，对此类合同进行审核更容易。 这是这种系统的某些设计特征的结果，但是通常，我们所说的智能合约是指分散的环境和功能的存在，该功能使任何人都可以分析数据库并对合同的执行情况进行全面审核。 这样可以确保防止数据的追溯更改，因为追溯更改会导致合同本身的执行发生更改。 创建和启动智能合约时，大多数流程的数字化通常会简化技术及其实施成本。 <br><br><h3> 一个简单的例子-托管服务 </h3><br> 让我们看一个非常简单的例子。 它将帮助您更深入地了解智能合约的功能，以及更好地导航在哪种情况下应使用它们。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c49/ff9/541/c49ff9541c0289e2da814c0d62a0425a.png" alt="图片"><br><br> 它也可以使用比特币来实现，尽管现在仍然很难将比特币称为成熟的智能合约平台。 因此，我们有一些买家，并且有一个在线商店。 买家想在这家商店购买显示器。 在最简单的情况下，买方准备并发送付款，然后在线商店接受付款，确认，然后发送货物。 但是，在这种情况下，需要高度信任-买方必须信任在线商店以支付显示器的全部费用。 由于在线商店在购买者眼中声誉可能很低，因此存在由于某种原因在接受付款后，商店将拒绝提供服务并且不会将商品发送给购买者的风险。 因此，买方会问一个问题（分别是在线商店会问这个问题），在这种情况下可以采取什么措施，以最大程度地降低此类风险并使此类交易更加可靠。 <br><br> 对于比特币，您可以为买卖双方提供独立选择调解员的机会。 有很多人处理有争议的问题。 我们的参与者可以从将同时受到信任的一般调解员列表中进行选择。 他们一起创建了一个3的多重签名地址2，其中有三个密钥，任何两个密钥都需要两个签名，以便从该地址消费硬币。 一把钥匙属于买方，第二把钥匙属于在线商店，第三把钥匙属于调解人。 买方将把为显示器支付的必要金额发送到这样的多重签名地址。 现在，当卖方看到资金在依赖于他的多重签名地址上被封锁了一会儿时，他可以通过邮件安全地发送监视器。 <br><br> 此外，买方收到包裹，检查货物并做出最终购买决定。 他可能完全同意所提供的服务，并用他的钥匙签署交易，在那里他将硬币从多重签名地址转移到卖方，或者可能对某些事情不满意。 在第二种情况下，他与调解员联系以进行替代交易，这将以不同方式分配这些硬币。 <br><br> 假设显示器有点划伤，并且套件中没有用于连接计算机的电缆，尽管在线商店的网站上写到套件中应包含电缆。 然后买主收集必要的证据，以向调解员证明他在这种情况下被骗了：他拍摄了网站的屏幕截图，拍下了邮件中的支票照片，拍摄了显示器上的划痕照片，并显示封条已损坏并且电缆已拔出。 反过来，在线商店将收集其证据并将其传递给调解员。 <br><br> 调解员有兴趣满足购买者的愤慨和在线商店的利益（这将进一步理解原因）。 他进行了这样的交易，其中带有多重签名地址的硬币将在购买者，在线商店和签单之间以一定比例花费，因为他为自己的工作做出了贡献。 假设总金额的90％归卖方，5％归仲裁员，5％归买方。 调解员使用他的密钥在此事务上签名，但是该事务尚不能应用，因为这需要两个签名，但只有一个。 他将这样的交易发送给买卖双方。 如果其中至少有一个对重新分配硬币的选项感到满意，则将对交易进行额外签名并分配给网络。 为了进行验证，交易的参与者之一足以同意调解员的选择。 <br><br> 在这种情况下，重要的是首先选择一名调解员，以使两个参与者都信任他。 在这种情况下，他将采取行动，而不论对方的利益如何，并客观地评估情况。 如果调解员没有提供满足至少一个参与者满意的硬币分配选项，则在达成一致意见后，买方和在线商店都可以将硬币转发到新的多重签名地址，并放置两个签名。 新的多重签名地址将与另一个选项一起编译，这也许会在此问题上更加胜任，并将提供更好的选择。 <br><br><h3> 宿舍和冰箱的例子 </h3><br> 让我们看一个更复杂的示例，它更清楚地显示智能合约的功能。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d9/d62/be0/4d9d62be0f11ea9938eb092ee279dd85.png" alt="图片"><br><br> 比方说，最近有三个人定居在一个宿舍里。 他们三个有兴趣在他们的房间里购买一台冰箱，他们将分享这些冰箱。 其中一位自愿收集必要的款项购买冰箱并与卖方协商。 但是，他们最近才见面，彼此之间没有足够的信任。 显然，其中两个处于危险之中，给了第三者以金钱。 此外，他们需要就卖方的选择达成协议。 <br><br> 他们可以使用托管服务，即选择一个调解员来监视交易的执行并解决有争议的问题。 然后，在达成协议后，他们起草了一份智能合约并规定了其中的某些条件。 <br><br> 第一个条件是，必须在一定时间（例如一周内）之前，从智能合约的相应帐户中接收来自某些地址的一定金额的三笔付款。 如果没有发生，智能合约将终止，并将代币退还给所有参与者。 如果满足该条件，则设置卖方和中介者的标识符的值，并且检查所有参与者都同意卖方和中介者的选择的条件。 当满足所有条件时，资金将被转移到指定的地址。 这种方法可以保护参与者免受任何方面的欺诈，并且通常消除了信任的需要。 <br><br> 我们在此示例中看到了原理本身，即这样一种机会，可以为要满足的每个条件逐步设置参数，从而可以创建任何复杂度和嵌套级别深度的系统。 此外，首先您可以在智能合约中定义第一个条件，只有完成后才能为下一个条件设置参数。 换句话说，正式地规定了条件，并且可以在其操作期间就已经为其设置参数。 <br><br><h3> 智能合约分类 </h3><br> 对于分类，您可以指定不同的条件组。 但是，在技术发展的时刻，其中四个是相关的。 <br><br> 智能合约可以通过集中式或分散式运行时环境来区分。 在分散的情况下，我们在执行智能合约时具有更大的独立性和容错能力。 <br><br> 还可以通过设置和满足条件的过程来区分它们：它们可以是任意可编程的，受限的或预定义的，即严格键入的。 当在智能合约平台上只有四个特定的智能合约时，可以任意设置它们的参数。 因此，设置它们要容易得多：我们从列表中选择一个合约并传递参数。 <br><br> 通过启动方法，存在自动化的智能合约，也就是说，当满足某些条件时，它们是自我实现的，并且存在其中指定了条件的此类合约，但是平台不会自动验证其履行，因此需要单独启动这些合约。 <br><br> 此外，智能合约在隐私方面也有所不同。 它们可以是完全开放的，部分开放的或完全机密的。 后者意味着外部观察者看不到智能合约的条款。 但是，隐私主题非常广泛，应该与当前文章分开考虑。 <br><br> 下面，我们将详细介绍前三个标准，以阐明对当前主题的理解。 <br><br><h3> 运行时智能合约 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/64d/ffe/abc/64dffeabc36e80f36101529bd8cf1ff3.png" alt="图片"><br><br> 运行时区分集中式和分散式智能合约平台。 在集中式数字合同的情况下，将使用一项服务，其中只有一个验证者，并且可能会有一个备份和恢复服务，该服务也由中央管理。 有一个数据库存储所有必要的信息，这些信息用于设置智能合约的条款以及在该服务的数据库中考虑的价值分布。 这种集中式服务的客户可以根据某些请求设置条件并使用此类合同。 由于平台是集中式的，因此身份验证机制可能不如加密货币可靠。 <br><br> 例如，您可以使用移动服务提供商（不同的移动运营商）。 假设某个运营商以集中的方式跟踪其服务器上的流量，该流量可以以不同的格式传输，例如：以语音呼叫，SMS，移动Internet流量的形式并根据各种标准进行传输，并且还跟踪用户余额上的资金。 因此，移动服务提供商可以草拟合同以在不同条件下对所提供的服务及其付款进行核算。 在这种情况下，容易设置诸如“将具有这样和这样的代码的SMS发送给这样和这样的号码，并且您将得到这样和这样的业务量分配条件”的条件。 <br><br> 可以举出另一个例子：具有先进的互联网银行功能以及传统合同非常简单的传统银行，例如定期付款，自动转换收款，自动扣除指定帐户上的利息等。 <br><br> 如果我们谈论的是分散运行时的智能合约，那么我们有一组验证器。 在理想情况下，任何人都可以成为验证者。 由于数据库同步协议和共识的建立，我们有了一些通用的数据库，该数据库现在将存储所有带有严格描述的合同的交易，而不是一些条件请求，条件请求的格式经常更改，但是没有开放的规范。 在这里，交易将包含有关如何按照严格的规范执行合同的说明。 该规范是开放的，因此，平台用户自己可以审核和验证智能合约。 在这里，我们看到分散式平台在独立性和容错性方面优于集中式平台，但是它们的设计和维护却要复杂得多。 <br><br><h3> 建立和满足条件的智能合约 </h3><br> 现在，我们将更详细地分析智能合约在定义和实现方式上的差异。 在这里，我们注意智能合约，它是任意编程的并且是图灵完备的。 使用图灵完备的智能合约，您几乎可以指定任何算法作为履行合约的条件：注册周期，某种概率计算功能等，直至您自己的电子签名算法。 在这种情况下，我们指的是逻辑的任意拼写。 <br><br> 他们还挑出任意智能合约，但根据Turing的说法并没有完成。 其中包括带有自己脚本的比特币和莱特币。 这意味着只能以任意顺序使用某些操作，但是不再可能编写循环和自定义算法。 <br><br> 此外，还有一些实现预定义智能合约的智能合约平台。 其中包括Bitshares和Steemit。  Bitshares具有许多用于交易，管理账户，管理平台本身及其参数的智能合约。  Steemit是一个类似的平台，但不再像Bitshares那样专注于发行代币和交易，而是专注于博客，即它以分散的方式存储和处理内容。 <br><br> 图灵完备的合同包括仍在开发中的以太坊和RootStock平台。 因此，我们将进一步详细介绍以太坊智能合约平台。 <br><br><h3> 通过启动方法进行智能合约 </h3><br> 通过启动方法，智能合约也可以分为至少两组：自动和手动（非自动）。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于自动化交易而言，通常具有所有已知参数和条件开始的条件下，智能合约会自动完全执行，也就是说，它不需要发送任何其他交易，也无需为以后的每次执行花费额外的佣金。平台本身具有所有数据，以便计算智能合约的终止方式。逻辑不是任意的，而是预先确定的，所有这些都是可以预见的。也就是说，您可以预先评估智能合约的复杂性，对其使用某种恒定佣金，并且其实施的所有流程都将更加高效。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于任意编程的智能合约，执行不是自动的。</font><font style="vertical-align: inherit;">要启动这样的智能合约，实际上每个步骤都需要创建一个新交易，该交易将调用智能合约的下一个执行阶段或下一个方法，并支付适当的佣金并等待确认交易。</font><font style="vertical-align: inherit;">由于智能合约代码是任意的，并且可能会出现一些不可预测的时刻，例如一个永恒的周期，缺少一些参数和参数，未处理的特殊时刻等，因此执行是否成功就可以完成。</font></font><br><br><h2> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以太坊账户</font></font></b> </h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 以太坊账户类型 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们考虑一下以太坊平台上的账户。这里只有两种类型的帐户，没有更多选择。第一种称为用户帐户，第二种称为合同帐户。让我们看看它们有何不同。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户帐户仅由电子签名的私钥管理。帐户所有者通过ECDSA算法（椭圆曲线数字签名算法）生成其密钥对以进行电子签名。只有使用此密钥签名的交易才能更改此帐户的状态。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">智能合约帐户有单独的逻辑。</font><font style="vertical-align: inherit;">它只能在完全确定智能合约行为的预定程序代码的帮助下进行控制：在某些情况下，它将由哪个用户主动以及在哪些其他条件下分配这些代币，它将如何管理代币。</font><font style="vertical-align: inherit;">如果开发人员未在程序代码中提供某些要点，则可能会出现问题。</font><font style="vertical-align: inherit;">例如，智能合约可能会收到某些特定状态，在该状态下，智能合约不接受任何用户发起的进一步执行。</font><font style="vertical-align: inherit;">在这种情况下，实际上将冻结硬币，因为智能合约不会提供退出此状态的方法。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如何在以太坊中创建账户 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于用户帐户，所有者通过ECDSA独立生成密钥对。重要的是要注意，以太坊使用与比特币完全相同的算法和完全相同的椭圆曲线进行电子签名，但是地址的计算方式略有不同。在这里，不再像在比特币中那样应用双重哈希的结果，而是通过Keccak函数对256位的长度提供了一次哈希。从接收的值中切除最低有效位，即哈希函数输出值的160个最低有效位。结果，我们在以太坊中获得了地址。实际上，它需要20个字节。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意，以太坊中的账户标识符是在不使用校验和的情况下以十六进制编码的，这与比特币和许多其他系统的地址在基数系统58中加上校验和进行编码的比特币不同。这意味着您需要谨慎地使用以太坊中的账户标识符：即使标识符中的一个错误也可以确保导致硬币丢失。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一个重要的功能，它包含一个事实，即在用户接受第一笔付款时创建了通用数据库级别的用户帐户。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建智能合约账户有完全不同的方法。最初，一位用户编写了智能合约的源代码，然后该代码通过用于Ethereum平台的特殊编译器传递，从而接收以太坊虚拟机的字节代码。收到的字节码放置在特殊的事务字段中。它代表发起者的帐户进行身份验证。此外，此交易在网络上分布，并托管智能合约代码。交易佣金以及相应的合同执行佣金将从发起人帐户的余额中删除。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个智能合约必定包含其自己的（该合约的）构造函数。</font><font style="vertical-align: inherit;">它可能为空，或者可能包含内容。</font><font style="vertical-align: inherit;">执行构造函数后，将创建一个智能合约帐户标识符，您可以使用该标识符来发送硬币，调用智能合约的某些方法等。</font></font><br><br><h2> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以太坊交易结构</font></font></b> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了更加清楚，我们将开始审查以太坊交易的结构和示例智能合约代码。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2cf/562/c11/2cf562c11f33cc0ed594c935925a1fad.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以太坊交易包括几个领域。这些随机数中的第一个是相对于帐户本身的特定交易编号，该交易编号将其分发并为其创建者。为了区分事务的重复，即排除两次接受同一事务的情况，这是必需的。通过使用标识符，每个事务都具有唯一的哈希值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其次是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">天然气价格</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等领域</font><font style="vertical-align: inherit;">。这是将以太坊基础货币转换为天然气的价格，该价格为执行智能合约和分配虚拟机资源付费。</font></font>这是什么意思？ <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在比特币中，佣金直接由基础货币支付-比特币本身。这有可能要归功于一种简单的计算方式：我们严格支付交易中包含的数据量。在以太坊中，情况更加复杂，因为从交易数据量开始很难。在这里，事务可能仍然包含将在虚拟机上运行的程序代码，并且虚拟机的每个操作可能具有不同的复杂性。也有为变量分配内存的操作。它们将具有自己的复杂性，每个操作的费用将取决于这些复杂性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每次操作的气体等效成本将保持不变。专门介绍它是为了确定每个操作的不变成本。取决于网络上的负载，天然气价格将发生变化，即，基础货币将根据该系数转换为该辅助单位以支付佣金。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以太坊中交易的另一个功能是：它包含在虚拟机中执行的字节码将被执行，直到完成某些结果（成功）或分配了一定数量的硬币为止支付佣金。为了避免出现这种情况，在某些错误的情况下，所有硬币都从发送者的帐户中花了佣金（例如，虚拟机中启动了某种永久性循环），因此存在以下字段- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始加油</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（通常称为加油限额）-它定义了发件人愿意花在特定交易上的最大硬币数量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一个字段称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目标地址</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这包括硬币接收者的地址或特定智能合约的地址，将调用其方法。在它后面跟随</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段</font><font style="vertical-align: inherit;">，在其中输入发送到目标地址的硬币数量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来是一个有趣的字段，称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它适合整个结构。这不是一个单独的字段，而是定义虚拟机代码的整个结构。您可以在此处放置任意数据-为此有单独的规则。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后一个字段称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">签名</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它同时包含此交易作者的电子签名和将用来验证此签名的公共密钥。</font><font style="vertical-align: inherit;">从公共密钥，您可以获取此交易的发件人帐户标识符，即在系统本身中唯一地标识发件人帐户。</font><font style="vertical-align: inherit;">根据交易的结构，我们发现了主要问题。</font></font><br><br><h2> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">智能合约代码示例</font></font></b> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，让我们通过一个示例仔细研究最简单的智能合约。 </font></font><br><br><pre><code class="javascript hljs">contract Bank { address owner; mapping(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address</span></span></span><span class="hljs-function"> =&gt;</span></span> uint) balances; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bank</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ owner = msg.sender; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deposit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> </span></span>{ balances[msg.sender] += msg.value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withdraw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint amount</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (balances[msg.sender] &gt;= amount) { balances[msg.sender] -= amount; msg.sender.transfer(amount); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMyBalance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> balances[msg.sender]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kill</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.sender == owner) selfdestruct(owner); } }</code> </pre> <br> 上面是一个简化的源代码，可以保存用户硬币并按需退还它们。 <br><br> 因此，有一个执行以下功能的银行智能合约：它在其余额上累积硬币，即，在确认交易并放置这种智能合约后，将创建一个新帐户，该帐户可以在其余额中包含硬币； 它记住用户以及用户之间的硬币分配； 它有几种管理余额的方法，即可以补充，提取和验证用户的余额。 <br><br> 让我们遍历每一行源代码。 该合同中有固定字段。 其中一个地址类型称为所有者。 在这里，合同会记住创建此智能合同的用户的地址。 此外，存在一种动态结构，可以保留用户地址和余额之间的对应关系。 <br><br> 之后，使用Bank方法-与合同相同。 因此，这是他的构造函数。 在此，为所有者变量分配了在网络上发布此智能合约的人员的地址。 这是此构造函数中唯一发生的事情。 也就是说，在这种情况下，msg就是与包含该合同的所有代码的事务一起传输到虚拟机的数据。 因此，msg.sender是此事务的作者，该事务托管此代码。 他将成为智能合约的所有者。 <br><br> 存款方法允许交易将一定数量的硬币转移到合约账户。 在这种情况下，接收这些代币的智能合约将它们留在资产负债表上，但会向余额结构写入谁是这些代币的确切发送者，以便知道它们属于谁。 <br><br> 下一个方法称为取款，它有一个参数-某人要从该银行取款的硬币数量。 这是一项检查，以查看调用此方法发送硬币的用户的余额中是否有足够的硬币。 如果有足够的钱，则智能合约本身会将这笔硬币返还给呼叫者。 <br><br> 接下来是检查用户当前余额的方法。 调用此方法的人将用于在智能合约中获得此余额。 值得注意的是，此方法的修饰符是view。 这意味着该方法本身不会以任何方式更改其类的变量，实际上，它只是一种读取方法。 不会创建单独的事务来调用此方法，不会支付任何佣金，并且所有计算都在本地执行，之后用户会收到结果。 <br><br> 需要使用kill方法来破坏智能合约的状态。 在此还要进行额外的检查，以检查此方法的调用者是否是该合同的所有者。 如果是，则合同是自毁的，销毁功能将接受一个参数-帐户标识符，合同会将余额中剩余的所有硬币发送至该参数。 在这种情况下，剩余的硬币将自动到达合同持有人的地址。 <br><br><h2>  <b>完整的以太坊网络节点如何工作？</b> </h2><br> 让我们看一下这些智能合约在以太坊平台上如何执行以及整个网络节点如何工作的示意图。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10b/d25/63a/10bd2563a30d8284e5498e774e4abaf9.png" alt="图片"><br><br> 完整的以太坊网络节点必须至少具有四个模块。 <br> 对于任何分散式协议，第一个是P2P网络模块-一个用于网络连接并与其他节点一起工作的模块，在该模块中交换块，事务和其他节点的信息。 这是所有分散式加密货币的传统组件。 <br><br> 此外，我们有一个模块用于存储区块链数据，处理，选择优先级分支，补充区块，解耦区块，检查这些区块等。 <br><br> 第三个模块称为EVM（以太坊虚拟机）-这是从以太坊事务接收字节码的虚拟机。 该模块采用特定帐户的当前状态，并根据接收到的字节码对其状态进行更改。 每个网络节点上的虚拟机版本必须相同。 每个以太坊节点上的计算完全相同，但是它们以异步顺序进行：有人先检查并接受此事务，即先执行其中包含的所有代码，然后再执行。 因此，当创建交易时，它被分发到网络，节点接受它，并且在验证时，就像在比特币中执行比特币脚本一样，在这里执行虚拟机的字节码。 <br><br> 如果事务中包含的所有代码都已执行，则交易被视为已验证，特定帐户的新状态已生成并保存，直到明确是否应用了该事务为止。 如果应用了事务，则该状态不仅被视为已完成，而且已经相关。 有一个数据库，用于存储每个主机的每个帐户的状态。 由于所有计算都以相同的方式进行，并且区块链的状态相同，因此每个节点包含所有帐户状态的数据库也将相同。 <br><br><h2>  <b>智能合约的神话与局限</b> </h2><br> 至于类似以太坊的智能合约平台存在的限制，可以引用以下内容： <br><br><ul><li> 代码执行； </li><li> 分配内存； </li><li> 区块链数据; </li><li> 发送付款； </li><li> 创建新合同； </li><li> 打电话给其他合同。 </li></ul><br> 让我们看一下对虚拟机施加的限制，从而消除有关智能合约的一些神话。 在不仅可以在以太坊中，而且可以在类似平台中的虚拟机上，您可以执行真正的任意逻辑操作，即编写代码并在其中执行，还可以额外分配内存。 但是，将为每个操作和每个额外分配的内存单元分别支付佣金。 <br><br> 此外，虚拟机可以从区块链数据库读取数据，以便将该数据用作执行智能合约的一种或另一种逻辑的触发器。 虚拟机可以创建和发送交易，它可以创建新合同以及调用其他已在网络上发布的智能合同的方法：存在，可用等。 <br><br> 最普遍的神话是，以太坊智能合约可以在自己的条件下使用来自任何Internet资源的信息。 事实是，虚拟机无法将网络请求发送到Internet上的某些外部信息资源，也就是说，不可能编写这样的智能合约来根据用户的天气情况在用户之间分配价值，或者谁赢得了某个冠军，或基于外界发生了什么其他事件，因为有关这些事件的信息根本不在平台本身的数据库中。 也就是说，区块链上没有任何相关内容。 如果未在此处显示，则虚拟机无法将该数据用作触发器。 <br><br><h2>  <b>以太坊的缺点</b> </h2><br> 让我们列出主要的。 第一个缺点是在以太坊中设计，开发和测试智能合约存在一些困难（以太坊使用Solidity语言编写智能合约）。 实际上，实践表明，所有错误中有很大一部分属于人为因素。 实际上，对于已经编写的以太坊智能合约而言，这是正确的，其复杂度为中等或更高。 如果对于简单的智能合约，错误的可能性很小，那么在复杂的智能合约中，经常会发生错误，这些错误导致资金被盗，冻结，以意外方式破坏智能合约等。许多这样的情况是已知的。 <br><br> 第二个缺点是虚拟机本身并不完美，因为它也是由人编写的。 它可以执行任意命令，这是一个漏洞：可以以某种方式配置许多命令，这将导致无法预料的后果。 这是一个非常复杂的领域，但是已经有一些研究表明这些漏洞存在于当前版本的以太坊网络中，它们可能导致许多智能合约的失败。 <br><br> 另一个大难题，可以认为是一个缺点。 它包含以下事实：可以通过实践或技术方式得出这样的结论：如果编译将在虚拟机上执行的合同的字节码，则可以确定某些特定的操作顺序。 当这些操作一起执行时，它们将非常沉重地加载虚拟机，并使虚拟机的速度成比例地降低，从而降低了为这些操作支付的佣金。 <br><br> 过去，以太坊已经发展了一段时期，当时许多了解虚拟机操作的人都发现了此类漏洞。 实际上，交易支付的佣金很小，但实际上减慢了整个网络的速度。 这些问题很难解决，因为您需要确定它们，其次，调整执行这些操作的价格，其次，进行硬分叉，这意味着将所有网络节点更新为该软件的新版本，然后同时激活这些更改。 <br><br> 至于以太坊，已经进行了很多研究，获得了很多实践经验：正面和负面，但尽管如此，仍然存在必须以某种方式进行斗争的困难和脆弱性。 <br><br> 至此，本文的主题部分完成了，我们转向经常出现的问题。 <br><br><h2>  <b>常见问题</b> </h2><br>  <i>-如果当前智能合约的所有各方都想更改条款，是否可以使用多重签名取消该智能合约，然后创建具有更新条件的新智能合约来执行？</i> <br><br> 答案是双重的。 怎么了 因为，一方面，智能合约设置一次，并不意味着任何更改，另一方面，它可以具有预定义的逻辑，可以在某些条件下提供完整或部分更改。 也就是说，如果您想更改智能合约中的某些内容，则必须规定可以更新这些条件的条件。 因此，只有以审慎的方式才能组织合同续签。 但是在这里，您也会遇到麻烦：犯一些错误并获得相应的漏洞。 因此，这些事情需要非常详细，彻底地设计和测试。 <br><br>  <i>-如果调解员与以下其中一个当事方串谋：代管还是智能合约？</i>  <i>智能合约中需要调解员吗？</i> <br><br> 智能合约中不需要调解员。 可能不是。 如果在托管的情况下，调解员从当事方之一串谋阴谋，那么是的，那么该方案将严重丧失其所有价值。 因此，选择中介者的方式应使参与此过程的所有各方同时信任他们。 因此，您根本不会将硬币与您不信任的调解人一起转移到多重签名地址。 <br><br>  <i>-是否有可能将许多不同的令牌从一个地址转移到不同的目标地址，例如交换地址，在这些地址中以一次以太坊交易来交换这些令牌？</i> <br><br> 这是一个好问题，涉及以太坊交易模型及其与比特币模型的区别。 区别是巨大的。 如果您在以太坊交易模型中只是简单地转移硬币，那么它们只会从一个地址转移到另一个地址，而不会改变，只是您指定的特定数量。 换句话说，这不是未使用输出（UTXO）的模型，而是帐户和相应余额的模型。 从理论上讲，如果您编写一个棘手的智能合约，一次交易就可以一次发送多个不同的代币，但您仍然必须进行大量交易，创建一个合约，然后将代币和硬币转移给它，然后调用适当的方法。 这分别需要精力和时间，实际上，它并不能那样工作，以太坊中的所有付款都是在单独的交易中进行的。 <br><br>  <i>-以太坊平台的神话之一是不可能描述将取决于外部Internet资源数据的条件，那又是什么呢？</i> <br><br> 解决方案是，智能合约本身可能包含一个或多个所谓的受信任的预言家，这些人收集有关外界事物状态的数据，并通过特殊方法将其传输到智能合约中。 合同本身认为从受信任方收到的数据是真实的。 为了获得更高的可靠性，他们只需选择一大堆预言机，就可以最大程度地降低合谋风险。 合同本身可能未考虑来自Oracle的与大多数矛盾的数据。 <br><br> 在线区块链课程的其中一个讲座-“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">智能合约简介</a> ”中涵盖了该主题。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413231/">https://habr.com/ru/post/zh-CN413231/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413221/index.html">细菌在飞船组装过程中在“洁净室”中生存，食用清洁产品</a></li>
<li><a href="../zh-CN413223/index.html">哈布拉语字典。 第一部分</a></li>
<li><a href="../zh-CN413225/index.html">安全周20：非凡的网络攻击</a></li>
<li><a href="../zh-CN413227/index.html">衣服下的神是什么</a></li>
<li><a href="../zh-CN413229/index.html">在Google合作实验室上构建Caffe：云中的免费图形卡</a></li>
<li><a href="../zh-CN413233/index.html">uLogin服务将数据从表单（邮件，电话）发送到第三方站点，并且对此保持沉默</a></li>
<li><a href="../zh-CN413235/index.html">押注更好的预测：天气预报的新数学</a></li>
<li><a href="../zh-CN413237/index.html">Facebook否认向设备制造商发送与开发商Alexander Kogan相同的数据</a></li>
<li><a href="../zh-CN413239/index.html">如何使智能手机变得笨拙</a></li>
<li><a href="../zh-CN413241/index.html">使用ftrace拦截Linux内核中的函数</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>