<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòà üëπ üè∫ Modelo de gerenciamento automatizado de programas üë©‚Äçüè´ üì≥ ü§üüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Em [1], foi dada uma resposta √† quest√£o do que √© considerado programa√ß√£o autom√°tica (AP), mas o modelo de uma m√°quina de estados finit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modelo de gerenciamento automatizado de programas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484588/"><h3>  1. Introdu√ß√£o </h3><br>  Em [1], foi dada uma resposta √† quest√£o do que √© considerado programa√ß√£o autom√°tica (AP), mas o modelo de uma m√°quina de estados finitos (SC) n√£o foi descrito em detalhes como um modelo de controle de programas autom√°ticos.  √â claro que um aut√¥mato abstrato puro n√£o √© adequado para esse papel, porque  limitado pelo n√∫mero de canais.  Mas o modelo estrutural do aut√¥mato, bem como a teoria do aut√¥mato estrutural correspondente a ele, ainda n√£o permite dar uma resposta sobre a escolha do modelo do aut√¥mato. <br><br>  O problema come√ßa com o fato de que, dentre os muitos trabalhos sobre a teoria dos aut√¥matos finitos (ACT), poucos s√£o os que definem o modelo de um aut√¥mato finito estrutural (ACS).  √â verdade que se pode entender que um aut√¥mato estrutural √© um diagrama [estrutural] de aut√¥matos elementares (elementos funcionais) que implementa um modelo de um aut√¥mato abstrato [2].  Lembre-se de que, de acordo com a teoria, tudo come√ßa com a cria√ß√£o de um modelo de dispositivo na forma de um aut√¥mato abstrato e, em seguida, a tarefa √© sintetizar um circuito digital que o implementa [3]. <br><br>  A programa√ß√£o √† primeira vista parece um pouco com uma s√≠ntese de circuitos digitais.  Mas s√≥ a princ√≠pio.  Em primeiro lugar, l√° e ali tudo come√ßa com um algoritmo.  Em segundo lugar, as quest√µes estruturais da organiza√ß√£o e implementa√ß√£o de circuitos digitais e programa√ß√£o t√™m muito em comum, especialmente no contexto da programa√ß√£o paralela.  Mas discutiremos o t√≥pico do paralelismo separadamente.  Enquanto isso, nossa tarefa √© escolher e / ou modificar o modelo de uma m√°quina de estados finitos, o que seria compreens√≠vel, conveniente e agrad√°vel para programadores estragados por v√°rias ferramentas de software. <br><br>  √â verdade que a pergunta √© imediatamente l√≥gica - por que mais um ‚Äúkit de ferramentas autom√°tico‚Äù incomum?  Vamos tentar responder a essa pergunta definindo um modelo de controle autom√°tico [aninhado], considerando tamb√©m suas vantagens em compara√ß√£o com o modelo de programa√ß√£o usual. <br><a name="habracut"></a><br><h3>  2. Defini√ß√£o do modelo de controle de programas autom√°ticos </h3><br>  No processo de evolu√ß√£o, a pr√°tica da programa√ß√£o formou certos requisitos para o modelo de gerenciamento do programa.  Deve-se reconhecer que o modelo de uma m√°quina cl√°ssica de estados finitos corresponde pouco a eles.  E se a tarefa √© usar aut√¥matos na programa√ß√£o, ela precisa ser adaptada.  √â desej√°vel fazer isso no quadro da teoria dos aut√¥matos.  As principais reivindica√ß√µes para o AP existente s√£o reduzidas ao fato de que essa condi√ß√£o √© violada. <br><br>  <i>Defini√ß√£o 1.</i> Chamamos de <i>forma normal disjuntiva de aut√¥matos finitos (DNKA)</i> aut√¥matos finitos totalmente definidos cujas transi√ß√µes s√£o rotuladas por conjun√ß√µes elementares de vari√°veis ‚Äã‚Äãl√≥gicas. <br><br>  O modelo de DNA √© baseado em modelos formais de <i>aut√¥matos</i> totalmente (totalmente) definidos <i>com um estado abstrato</i> [4] e <i>aut√¥matos l√≥gicos</i> [5]. <br><br>  <i>Defini√ß√£o 2.</i> Chamamos a <i>forma disjuntiva de um aut√¥mato finito (DFA), um</i> aut√¥mato na forma de um DFA contendo apenas <i>transi√ß√µes resultantes</i> . <br><br>  As transi√ß√µes marcadas com sinais de sa√≠da e as transi√ß√µes com um tra√ßo no lugar dos sinais de sa√≠da que alteram o estado atual do aut√¥mato s√£o classificadas como transi√ß√µes efetivas.  As transi√ß√µes que n√£o est√£o inclu√≠das na descri√ß√£o do aut√¥mato disjuntivo constituem uma <i>adi√ß√£o da DKA (DDA)</i> ao aut√¥mato do DFA totalmente definido.  Tal adi√ß√£o √© um aut√¥mato que consiste em estados isolados com transi√ß√µes na forma de loops e tra√ßos no lugar dos sinais de sa√≠da. <br><br><h3>  3. O modelo de mem√≥ria para o modelo de c√°lculo AP </h3><br>  A presen√ßa de muitas entradas e sa√≠das do DFA define o paralelismo dos operadores / fun√ß√µes de software associados a ele.  Para sua correta implementa√ß√£o, √© necess√°rio um modelo de mem√≥ria do tipo CREW (leitura simult√¢nea exclusiva - grava√ß√£o) [6].  Dentro de sua estrutura, a leitura dos valores atuais dos dados √© permitida por parte do conjunto de todas as fun√ß√µes (predicados e a√ß√µes), e apenas uma delas pode alterar <i>dados gerais</i> para a√ß√µes execut√°veis ‚Äã‚Äãparalelas. <br><br>  O modelo de controle autom√°tico, em contraste com o modelo de computa√ß√£o multithread, limita claramente a execu√ß√£o dos operadores / fun√ß√µes do programa autom√°tico aos limites de um ciclo de tempo discreto.  Em tal situa√ß√£o, quaisquer altera√ß√µes na mem√≥ria por a√ß√µes executadas no ciclo de clock atual podem ser gravadas na <i>‚Äúmem√≥ria de sombra‚Äù</i> , para que, depois de conclu√≠das e antes do in√≠cio do pr√≥ximo ciclo de clock discreto, elas se tornem seus novos valores. <br><br>  A intera√ß√£o dos operadores do programa de aut√¥matos com a mem√≥ria ser√° chamada de <i>modelo de mem√≥ria de sombra</i> .  Este modelo √© uma parte essencial do modelo geral de programa√ß√£o autom√°tica.  Garante a corre√ß√£o da opera√ß√£o paralela dos operadores de ponto de acesso e simplifica a programa√ß√£o de processos paralelos. <br><br>  Dentro da estrutura do modelo de mem√≥ria, mecanismos complexos e pouco confi√°veis ‚Äã‚Äãpara a sincroniza√ß√£o multi-threaded dos processos n√£o s√£o realmente necess√°rios (para obter mais detalhes, consulte [7]).  Por√©m, se necess√°rio, devido √† equival√™ncia de aut√¥matos e <i>esquemas gr√°ficos de algoritmos (GAW)</i> [8], o modelo de programa√ß√£o autom√°tica n√£o limita sua aplica√ß√£o. <br><br><h3>  4. Modelos aninhados e inerciais de aut√¥matos </h3><br>  A tarefa de criar um modelo do elemento l√≥gico do atraso, escolhido como exemplo, por um lado, demonstra os problemas do modelo cl√°ssico do aut√¥mato e, por outro lado, reflete as qualidades do modelo DFA que resolve problemas algor√≠tmicos com meios mais visuais e convenientes.  O modelo introduzido de aut√¥matos aninhados gera uma subclasse de modelos de aut√¥matos, a seguir denominados <i>aut√¥matos inerciais</i> , e uma subclasse correspondente de <i>algoritmos inerciais</i> . <br><br>  Portanto, seja a tarefa de criar um modelo discreto de um elemento l√≥gico de atraso que implemente a transmiss√£o de um sinal de entrada bin√°rio.  Al√©m disso, os tempos de seus atrasos t01 e t10, respectivamente, para os estados de unidade e zero no caso geral n√£o coincidem. <br><br>  O modelo mais simples de um <i>√∫nico atraso</i> na forma de um aut√¥mato Mealy √© mostrado na Fig.  1 (veja, para compara√ß√£o, o modelo de atraso em [2]).  Seus atrasos s√£o determinados por um √∫nico ciclo de rel√≥gio discreto.  Modelos mais complexos de atrasos de <i>transporte</i> (para obter mais detalhes sobre os tipos de atrasos, veja [9]) na forma de um aut√¥mato Miley e um modelo combinado de Miley-Moore s√£o apresentados, respectivamente, na Fig.  2a e fig.  2b. <br><br><img src="https://habrastorage.org/webt/1v/1j/pw/1v1jpwicourr8xbg6yf2egq5nxk.jpeg" alt="imagem"><br>  Fig.  1. Modelo de atraso da unidade na forma de um aut√¥mato de milhas <br><br><img src="https://habrastorage.org/webt/di/bf/-d/dibf-daun_zrsuqr6hohywv2le0.jpeg" alt="imagem"><br>  Fig.  2. O modelo de atraso de transporte de Miles (a) e Miles-Moore (b) <br><br>  O sinal de entrada x3 (lembramos que no programa autom√°tico corresponde ao predicado [1]) assume um valor verdadeiro se o valor do contador do rel√≥gio for igual ao valor da vari√°vel t igual ao atraso t01 ou t10.  O valor da vari√°vel t √© atribu√≠do aos sinais y3 e y4 (no programa, a a√ß√£o funciona com o mesmo nome que os sinais de sa√≠da).  Os sinais y1, y2 definem o valor da vari√°vel que representa a sa√≠da do modelo.  O sinal y5 incrementa o contador do rel√≥gio, que √© redefinido pelo sinal y6. <br><br>  <i>Observa√ß√£o 2. Os estados internos do modelo na Fig.</i>  <i>1, √© conveniente associar a um estado de sa√≠da de um elemento.</i>  <i>Isso nos permite excluir n√£o apenas os operadores y1 e y2, mas tamb√©m a pr√≥pria vari√°vel de sa√≠da.</i> <i><br></i> <br>  A implementa√ß√£o da incorpora√ß√£o de aut√¥matos semelhante √† chamada de sub-rotinas forma a tecnologia da programa√ß√£o modular de aut√¥matos.  Ao mesmo tempo, no n√≠vel do software, em contraste com tentativas semelhantes no n√≠vel do hardware (veja [10] para compara√ß√£o), isso √© muito mais simples.  Para fazer isso, √© necess√°rio inserir a chamada de programa do aut√¥mato aninhado e, em seguida, o kernel da implementa√ß√£o de aut√¥matos, como um processador normal, organiza o retorno do controle ao n√≠vel atual de aninhamento. <br><br>  <i>Defini√ß√£o 3. Os aut√¥matos aninhados</i> ser√£o chamados de aut√¥matos com um estado final, cuja transi√ß√£o inicia o procedimento de retorno ao n√≠vel anterior (classifica√ß√£o) de aninhamento. <br><br>  A implementa√ß√£o correta do aninhamento de aut√¥matos imp√µe restri√ß√µes ao procedimento para sua cria√ß√£o.  Em primeiro lugar, um aut√¥mato aninhado s√≥ pode ser subordinado.  Al√©m disso, um aut√¥mato de n√≠vel superior, excluindo a classifica√ß√£o zero, tamb√©m pode ser um aut√¥mato aninhado.  Em segundo lugar, em qualquer transi√ß√£o, <b>apenas um</b> aut√¥mato aninhado pode ser criado.  O mecanismo de aut√¥matos aninhados tamb√©m cria a base para a implementa√ß√£o de algoritmos recursivos baseados no controle autom√°tico. <br><br><img src="https://habrastorage.org/webt/8c/4u/e5/8c4ue5ufusdgforqughwh5aw83w.jpeg" alt="imagem"><br>  Fig.  3. Modelo de atraso na forma de aut√¥matos aninhados <br><br>  A Fig. 3 mostra o modelo de atraso, onde a Fig. 3a representa o modelo de n√≠vel superior, e a Fig. 3b e a Fig.  3c - variantes de aut√¥matos aninhados para atrasos de transporte e <i>inerciais</i> (para obter mais detalhes sobre os tipos de atrasos, consulte [8]).  Ao mesmo tempo, estes s√£o exemplos de dois tipos de aut√¥matos aninhados - <i>ordin√°rio</i> e <i>inercial</i> .  O tipo de aut√¥mato aninhado √© definido pelo nome de seus estados finais: um estado com o nome "00" determina a sa√≠da usual do aut√¥mato aninhado e um estado com o nome "XX" n√£o altera o estado atual do aut√¥mato de n√≠vel superior. <br><br>  Uma explica√ß√£o importante para a compreens√£o do algoritmo de atraso inercial.  Para isso (veja a Fig. 3c), o valor do predicado x1 depende da transi√ß√£o na qual o aut√¥mato incorporado √© criado.  Em outras palavras, o predicado no estado "0" controla a preserva√ß√£o de "zero" na entrada e no estado "1", pelo contr√°rio, "unidades".  Se o valor na entrada for zero no valor zero da sa√≠da, ser√° necess√°rio retornar o valor verdadeiro.  Al√©m disso, se a estabilidade da entrada for violada (o valor x1 √© falso) e o tempo de atraso n√£o expirar (o valor x3 √© falso), a sa√≠da da m√°quina incorporada ser√° realizada atrav√©s do estado inercial (consulte a Fig. 3c). <br><br>  <i>Defini√ß√£o 4. Os</i> aut√¥matos, incluindo a chamada de aut√¥matos aninhados que t√™m um estado inercial final, ser√£o chamados <i>aut√¥matos inerciais</i> . <br><br>  No modelo da Fig. 3a, a a√ß√£o z1 (o s√≠mbolo z √© selecionado para os nomes de a√ß√µes que incluem uma chamada para um aut√¥mato aninhado) cria um aut√¥mato aninhado se um valor de atraso for definido.  Como parte dessa a√ß√£o, o tipo de atraso especificado √© determinado, de acordo com o qual um dos aut√¥matos aninhados √© criado, mostrado nas Fig.3b ou Fig.  3c. <br><br>  No n√≠vel superior da hierarquia, a vis√£o do aut√¥mato na Figura 3a coincide completamente em estrutura com o modelo na Figura 1, diferindo apenas na presen√ßa de a√ß√µes nas transi√ß√µes.  Atrasos com aut√¥matos aninhados t√™m uma forma mais simples em compara√ß√£o com o modelo de n√≠vel √∫nico na Fig. 2.  Um aut√¥mato aninhado tamb√©m pode ser considerado como um tipo de "aut√¥mato de biblioteca" que pode ser chamado de qualquer outro aut√¥mato. <br><br><h3>  3. Programa√ß√£o de aut√¥matos de objetos </h3><br>  O modelo de controle autom√°tico, al√©m da forma gr√°fica, tamb√©m possui uma forma tabular simples - uma tabela de transi√ß√£o (TP), que pode ser efetivamente interpretada em C ++.  Dentro de sua estrutura, um programa de aut√¥mato separado (ou parte dele) e, consequentemente, sua defini√ß√£o na forma de um circuito de programa S podem ser representados por uma classe.  Nesse caso, os modelos de mem√≥ria corresponder√£o √†s propriedades da classe, o conjunto de opera√ß√µes corresponder√° aos m√©todos da classe e o controle autom√°tico na forma de um TP descrever√° o comportamento da classe.  A introdu√ß√£o do controle na classe nos permite falar sobre objetos ativos, tamb√©m chamados de agentes, etc. <br><br>  Muitos objetos com comportamento na forma de controle de aut√¥mato formalizam o conceito de um <i>programa paralelo de aut√¥mato de objetos</i> .  Nesse caso, o modelo de qualquer programa paralelo pode ser representado por um diagrama de programa no qual o controle C ser√° apresentado na forma de uma rede de aut√¥matos, onde aut√¥matos de componentes descrevem o comportamento de objetos ativos, a mem√≥ria M √© representada por uma combina√ß√£o de propriedades de objetos e muitos operadores A s√£o representados por uma combina√ß√£o de m√©todos de objetos de programa. <br><br>  No ambiente VKPA, a fun√ß√£o da linguagem de programa√ß√£o automatizada √© atribu√≠da √† linguagem C ++.  No ‚ÄúC ++ autom√°tico‚Äù, os objetos s√£o dotados de atividade / comportamento e t√™m os meios de descrever e implementar paralelismo, tanto no n√≠vel de m√©todos de objetos individuais quanto no n√≠vel de descri√ß√£o da opera√ß√£o paralela de muitos objetos. <br><br>  As implementa√ß√µes de objetos existentes do AP s√£o bastante complicadas.  No VKPa, sua implementa√ß√£o de objeto √© baseada na interpreta√ß√£o de aut√¥matos e controle dedicado do programa.  Diferentemente da implementa√ß√£o direta de aut√¥matos, usada, por exemplo, na tecnologia SWITH, isso elimina o procedimento para converter um modelo de aut√¥mato em um modelo de fluxograma.  O algoritmo de interpreta√ß√£o usado no VKPa √© semelhante ao m√©todo de interpreta√ß√£o de tabelas de decis√£o de E. Hamby [12]. <br><br>  A menos que especificado de outra forma, associaremos ainda mais o conceito de um programa de aut√¥mato ao conceito de um <i>objeto de aut√¥mato (AO)</i> no sentido de POO, mas levando em considera√ß√£o o conceito de um programa paralelo de aut√¥mato de objeto apresentado acima.  Por esse motivo, os operadores e a mem√≥ria do ponto de acesso ser√£o determinados atrav√©s dos m√©todos e propriedades dos objetos ativos.  Os objetos aut√¥matos s√£o diferenciados dos objetos comuns pela presen√ßa de comportamento determinado pelo modelo da m√°quina de estados. <br><br><h3>  4. Conclus√µes </h3><br>  Criar um modelo de aut√¥matos aninhados √© um passo em dire√ß√£o a uma mudan√ßa qualitativa na tecnologia de programa√ß√£o.  O modelo inercial descrito do aut√¥mato √© semelhante ao conceito de estados hist√≥ricos na UML.  A incorpora√ß√£o usual de aut√¥matos tem um anal√≥gico na programa√ß√£o, a ‚Äúincorpora√ß√£o inercial‚Äù n√£o a possui, porque  Em um programa, voc√™ n√£o pode retornar a um comando que precede uma chamada de sub-rotina.  E esses s√£o elementos de uma diferen√ßa qualitativa entre programa√ß√£o autom√°tica e programa√ß√£o comum. <br><br>  Voc√™ pode, √© claro, introduzir mem√≥ria de sombra na programa√ß√£o comum e denotar o paralelismo de fun√ß√µes.  Mas, na estrutura do modelo de aut√¥matos, tudo isso tem uma forma org√¢nica, tanto em termos de descri√ß√£o quanto em termos de desempenho.  Tudo √© determinado pelo paralelismo natural do modelo.  O modelo do diagrama de blocos n√£o possui esses recursos. <br><br>  Objetos ativos tamb√©m expandem os recursos de programa√ß√£o.  Mas o ‚Äúwrapper de objeto‚Äù, por sua vez, afeta qualitativamente a programa√ß√£o autom√°tica, simplificando os procedimentos para chamar e implementar aut√¥matos aninhados.  Portanto, o uso das propriedades da classe [local] permite implementar n√£o apenas a incorpora√ß√£o, mas tamb√©m algoritmos recursivos. <br><br><div class="spoiler">  <b class="spoiler_title">Refer√™ncias</b> <div class="spoiler_text">  1. M√°quina de Turing, como modelo de programas autom√°ticos.  [Recurso eletr√¥nico], Modo de acesso: <a href="https://habr.com/ru/post/481998/">habr.com/en/post/481998</a> , gratuito.  Yaz.  Russo  (data do tratamento 07.01.2020). <br>  2. KUDRYAVTSEV VB, Aleshin S.V., PODKOLZIN A.S.  Introdu√ß√£o √† teoria dos aut√¥matos - M .: Science.  Cap.  ed.  F√≠sica-Matem√°tica.  lit., 1985 - 320 p. <br>  3. GLUSHKOV V.M.  S√≠ntese de m√°quinas digitais.  M.: Fizmatgiz, 1962. <br>  4. ZAKREVSKY A.D.  S√≠ntese l√≥gica de esquemas em cascata.  - M.: Ci√™ncia.  Cap.  ed.  Phys.-mat.  lit., 1981. - 416 p. <br>  5. KUZNETSOV O.P.  Gr√°ficos de aut√¥matos l√≥gicos e suas transforma√ß√µes // Automa√ß√£o e Telemec√¢nica.  - 1975. - No. 9.‚Äì S. 149-158. <br>  6. Kormen T., Leiserson Ch., Rivest R. Algoritmos: constru√ß√£o e an√°lise - M .: MCCMO, 2001. - 960 p. <br>  7. BUCH G., RAMBO J., JACOBSON I. UML.  Manual do usu√°rio.  Segunda edi√ß√£o.  IT Academy: Moscou, 2007 - 493 p. <br>  8. BARANOV S.I.  S√≠ntese de firmware  - L.: Energia, 1979. - 232s. <br>  9. ARMSTRONG J.R.  Modelagem de sistemas digitais na linguagem VHDL: trad. From English / M .: Mir, 1992. - 175 p. <br>  10. HAMBARTSUMYAN A.A., ZAPOLSKYH E.N.  Aproximadamente uma abordagem para a decomposi√ß√£o tempor√°ria de aut√¥matos.  Eu, Avtomat.  e Telemech., 1981, Edi√ß√£o 2, 135-144 <br>  11. SHALYTO A. A. O paradigma da programa√ß√£o autom√°tica.  Boletim Cient√≠fico e T√©cnico da Universidade Estadual de S√£o Petersburgo de Tecnologias da Informa√ß√£o, Mec√¢nica e √ìtica.  Vol.  53. Programa√ß√£o automatizada.  2008, p.  3-23. <br>  12. HAMBI E. Tabelas de decis√£o de programa√ß√£o.  M.: Mir, 1976 - 86 p. <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484588/">https://habr.com/ru/post/pt484588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484578/index.html">Objetivos do n√≠vel de servi√ßo - Experi√™ncia do Google (tradu√ß√£o do cap√≠tulo do livro do Google SRE)</a></li>
<li><a href="../pt484580/index.html">O que voc√™ precisa saber sobre simuladores de mem√≥ria</a></li>
<li><a href="../pt484582/index.html">ASP.NET MVC - Entity Framework, MySQL e usando o Dependency Resolver para selecionar um reposit√≥rio</a></li>
<li><a href="../pt484584/index.html">Por que precisamos de um gerente em um projeto de TI e o que acontecer√° quando n√£o for</a></li>
<li><a href="../pt484586/index.html">Trabalhar com IPv6 em PHP</a></li>
<li><a href="../pt484590/index.html">Para que os meninos n√£o tivessem vergonha de mostrar</a></li>
<li><a href="../pt484592/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 398 (13 a 19 de janeiro de 2020)</a></li>
<li><a href="../pt484596/index.html">Loja on-line do lado do cliente Blazor: Parte 1 - Autoriza√ß√£o oidc (oauth2) + Identity Server4</a></li>
<li><a href="../pt484600/index.html">Microsoft Ignite The Tour Confer√™ncia T√©cnica de Praga</a></li>
<li><a href="../pt484602/index.html">Livro "Desenvolvimento de aplicativos m√≥veis em C # para iOS e Android"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>