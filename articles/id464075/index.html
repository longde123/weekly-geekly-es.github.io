<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰 ✋🏼 👨🏿‍🤝‍👨🏻 Pengantar C. Pesan dari abad terakhir ➗ 🤹🏻 👼🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kata Pengantar 
 Dalam komentar saya , saya merujuk beberapa kali ke buku Andrew Tanenbaum tentang Desain dan Implementasi Sistem Operasi, edisi perta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar C. Pesan dari abad terakhir</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464075/"><h3>  Kata Pengantar </h3><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, saya</a> merujuk beberapa kali ke buku Andrew Tanenbaum tentang Desain dan Implementasi Sistem Operasi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">edisi pertamanya,</a> dan bagaimana C diwakili di dalamnya.  Dan komentar ini selalu menarik.  Saya memutuskan sudah waktunya untuk menerbitkan terjemahan pengantar ini ke C.  Itu masih relevan.  Meskipun pasti ada yang belum mendengar tentang bahasa pemrograman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PL / 1</a> , dan mungkin bahkan tentang sistem operasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Minix</a> . <br><br>  Deskripsi ini juga menarik dari sudut pandang historis dan untuk memahami sejauh mana bahasa C telah berkembang sejak kelahirannya dan industri TI secara keseluruhan. <br><a name="habracut"></a><br>  Saya ingin segera melakukan reservasi bahwa bahasa kedua saya adalah Prancis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/961/467/5a3/9614675a3883bf417fa2505dada57690.png" alt="gambar"><br><br>  Tapi ini diimbangi oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengalaman pemrograman</a> selama 46 tahun. <br>  Jadi, mari kita mulai, giliran Andrew Tanenbaum. <br><br><h3>  Pengantar Bahasa C (hal. 350 - 362) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cx/s5/il/cxs5ilctyz8rybmfwoqyjahv5ty.png"></div><br><br>  Bahasa pemrograman C dibuat oleh Dennis Ritchie dari AT&amp;T Bell Laboratories sebagai bahasa pemrograman tingkat tinggi untuk mengembangkan sistem operasi UNIX.  Saat ini, bahasa tersebut banyak digunakan di berbagai bidang.  C sangat populer dengan pemrogram sistem karena memungkinkan Anda untuk menulis program secara sederhana dan ringkas. <br><br>  Buku utama yang menggambarkan bahasa C adalah buku bahasa pemrograman C (1978) oleh Brian Kernigan dan Dennis Ritchie.  Buku-buku tentang bahasa C ditulis oleh Bolon (1986), Gehani (1984), Hancock dan Krieger (1986), Harbison and Steele (1984) dan banyak lainnya. <br><br>  Dalam aplikasi ini, kami akan mencoba memberikan pengantar yang cukup lengkap untuk C, sehingga mereka yang terbiasa dengan bahasa tingkat tinggi seperti Pascal, PL / 1, atau Modula 2 akan dapat memahami sebagian besar kode MINIX yang diberikan dalam buku ini.  Fitur C yang tidak digunakan dalam MINIX tidak dibahas di sini.  Banyak titik halus dihilangkan.  Penekanannya adalah pada membaca program C, daripada menulis kode. <br><br><h3>  A.1.  Dasar-dasar bahasa C </h3><br>  Program C terdiri dari serangkaian prosedur (sering disebut fungsi, meskipun tidak mengembalikan nilai).  Prosedur ini berisi deklarasi, operator, dan elemen lain yang bersama-sama memberi tahu komputer apa yang harus dilakukan.  Gambar A-1 menunjukkan prosedur kecil di mana tiga variabel integer dinyatakan dan diberi nilai.  Nama prosedurnya adalah utama.  Prosedur tidak memiliki parameter formal, seperti yang ditunjukkan oleh tidak adanya pengidentifikasi antara tanda kurung di belakang nama prosedur.  Tubuh prosedur tertutup dalam kurung ({}).  Contoh ini menunjukkan bahwa C memiliki variabel, dan bahwa variabel-variabel ini harus dideklarasikan sebelum digunakan.  C juga memiliki operator, dalam contoh ini adalah operator penugasan.  Semua pernyataan harus diakhiri dengan tanda titik koma (tidak seperti Pascal, yang menggunakan titik dua di antara pernyataan, bukan setelahnya). <br><br>  Komentar dimulai dengan karakter “/ *” dan diakhiri dengan karakter “* /” dan dapat menjangkau beberapa baris. <br><br><pre><code class="cpp hljs">main () <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j, k; <span class="hljs-comment"><span class="hljs-comment">/*  3   */</span></span> i = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  i  10 ( ) */</span></span> j = i + <span class="hljs-number"><span class="hljs-number">015</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  j  i + 015 ( ) */</span></span> k = j * j + <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  k  j * j + 0xFF ( ) */</span></span> } . Al.    .</code> </pre> <br>  Prosedur ini mengandung tiga konstanta.  Constant 10 dalam tugas pertama <br>  ini adalah konstanta desimal biasa.  Konstanta 015 adalah konstanta oktal <br>  (sama dengan 13 dalam desimal).  Konstanta oktal selalu mulai dari nol.  Konstanta 0xFF adalah konstanta heksadesimal (sama dengan 255 desimal).  Konstanta heksadesimal selalu dimulai dengan 0x.  Ketiga jenis digunakan dalam C. <br><br><h3>  A.2.  Tipe data dasar </h3><br>  C memiliki dua jenis data (variabel) utama: integer dan karakter, masing-masing dinyatakan sebagai int dan char.  Tidak ada variabel boolean yang terpisah.  Variabel int digunakan sebagai variabel boolean.  Jika variabel ini berisi 0, maka itu berarti false / false, dan nilai lainnya berarti benar / benar.  C juga memiliki tipe floating point, tetapi MINIX tidak menggunakannya. <br><br>  Anda dapat menerapkan "kata sifat" pendek, panjang, atau tidak bertanda tangan ke tipe int yang menentukan rentang nilai (kisaran tergantung pada kompiler).  Kebanyakan prosesor 8.088 menggunakan bilangan bulat 16-bit untuk int dan int pendek dan bilangan bulat 32-bit untuk int panjang.  Bilangan bulat tak bertanda (unsigned int) pada prosesor 8088 memiliki rentang dari 0 hingga 65535, dan tidak dari -32768 hingga +32767, seperti halnya bilangan bulat biasa (int).  Karakter membutuhkan 8 bit. <br><br>  Specifier register juga diperbolehkan untuk int dan char, dan merupakan petunjuk bagi kompiler bahwa variabel yang dideklarasikan harus ditempatkan dalam register agar program bekerja lebih cepat. <br><br>  Beberapa iklan ditampilkan dalam gambar.  A - 2. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z1, z2; / *    */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> flag_poll; <span class="hljs-comment"><span class="hljs-comment">/* 'int'    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> . <span class="hljs-number"><span class="hljs-number">-2.</span></span>  .</code> </pre> <br>  Konversi antar tipe diperbolehkan.  Misalnya operator <br><br><pre> <code class="cpp hljs">flag_pole = i;</code> </pre> <br>  diizinkan meskipun saya bertipe int dan flag_pole panjang.  Dalam banyak kasus <br>  perlu atau berguna untuk memaksa konversi antara tipe data.  Untuk konversi paksa, cukup untuk memasukkan tipe target di dalam tanda kurung di depan ekspresi untuk konversi.  Sebagai contoh: <br><br><pre> <code class="cpp hljs"> ( (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) i);</code> </pre> <br>  menginstruksikan untuk mengonversi integer i menjadi panjang sebelum meneruskannya sebagai parameter ke prosedur p, yang mengharapkan parameter panjang. <br><br>  Saat mengonversi antar jenis, perhatikan tandanya. <br>  Saat mengkonversi karakter ke integer, beberapa kompiler memperlakukan karakter sebagai ditandatangani, yaitu, dari - 128 hingga +127, sementara yang lain memperlakukannya sebagai <br>  unsigned, yaitu dari 0 hingga 255. Dalam MINIX, ekspresi seperti <br><br><pre> <code class="cpp hljs">i = c &amp; <span class="hljs-number"><span class="hljs-number">0377</span></span>;</code> </pre> <br>  yang mengkonversi dari (karakter) ke integer, dan kemudian melakukan logika AND <br>  (ampersand) dengan konstanta oktal 0377. Hasilnya adalah 8 bit yang tinggi <br>  diatur ke nol, sebenarnya memaksa c untuk dianggap sebagai nomor unsigned 8-bit, dalam kisaran 0 hingga 255. <br><br><h3>  A.3.  Jenis dan petunjuk majemuk </h3><br>  Pada bagian ini, kita akan melihat empat cara untuk membangun tipe data yang lebih kompleks: array, struktur, serikat, dan pointer.  Array adalah kumpulan / set elemen dengan tipe yang sama.  Semua array di C dimulai dengan elemen 0. <br><br>  Pengumuman <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a [<span class="hljs-number"><span class="hljs-number">10</span></span>];</code> </pre> <br>  mendeklarasikan array a dengan 10 integer yang akan disimpan dalam elemen array dari [0] ke [9].  Kedua, array bisa tiga atau lebih dimensi, tetapi tidak digunakan dalam MINIX. <br>  Struktur adalah kumpulan variabel, biasanya dari berbagai jenis.  Struktur dalam C mirip dengan catatan dalam Pascal.  Operator <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} s;</code> </pre> <br>  menyatakan s sebagai struktur yang mengandung dua anggota, integer i dan karakter c. <br><br>  Untuk menetapkan anggota i dari struktur s ke 6, tulis ungkapan berikut: <br><br><pre> <code class="cpp hljs">si = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  di mana operator titik menunjukkan bahwa elemen i milik struktur s. <br>  Serikat pekerja juga merupakan sekumpulan anggota, mirip dengan struktur, kecuali bahwa setiap saat hanya satu dari mereka yang dapat bergabung dalam serikat pekerja.  Pengumuman <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} u;</code> </pre> <br>  berarti Anda dapat memiliki integer atau karakter, tetapi tidak keduanya.  Compiler harus mengalokasikan ruang yang cukup untuk menggabungkan sehingga dapat mengakomodasi elemen menggabungkan terbesar (dari sudut pandang memori yang ditempati).  Serikat pekerja hanya digunakan di dua tempat di MINIX (untuk mendefinisikan pesan sebagai gabungan dari beberapa struktur yang berbeda, dan untuk mendefinisikan blok disk sebagai gabungan dari blok data, blok i-simpul, blok katalog, dll.). <br><br>  Pointer digunakan untuk menyimpan alamat mesin di C.  Mereka digunakan sangat, sangat sering.  Tanda bintang (*) digunakan untuk menunjukkan penunjuk dalam iklan.  Pengumuman <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, *pi, a [<span class="hljs-number"><span class="hljs-number">10</span></span>], *b[<span class="hljs-number"><span class="hljs-number">10</span></span>], **ppi;</code> </pre> <br>  mendeklarasikan integer i, pointer ke integer pi, array a dari 10 elemen, array b dari 10 pointer ke integer, dan pointer ke pointer ppi ke integer. <br><br>  Aturan sintaksis yang tepat untuk deklarasi kompleks yang menggabungkan array, pointer, dan tipe lainnya agak rumit.  Untungnya, MINIX hanya menggunakan deklarasi sederhana. <br><br>  Gambar A-3 menunjukkan deklarasi array z dari struktur tabel struct, yang masing-masing memiliki <br>  tiga anggota, integer i, pointer cp ke karakter dan karakter c. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; / *  */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, c; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } z [<span class="hljs-number"><span class="hljs-number">20</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*    20  */</span></span> .  - <span class="hljs-number"><span class="hljs-number">3.</span></span>  .</code> </pre> <br>  Susunan struktur umum dalam MINIX.  Lebih jauh, tabel nama dapat dideklarasikan sebagai struktur tabel struct yang dapat digunakan dalam deklarasi selanjutnya.  Sebagai contoh <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>  mendeklarasikan p sebuah pointer ke struktur tabel struct dan menyarankan untuk menyimpannya <br>  dalam daftar.  Selama eksekusi program, p dapat mengindikasikan, misalnya, z [4] atau <br>  untuk setiap elemen lain di z, semua 20 elemen di antaranya adalah struktur tabel tipe struct. <br><br>  Untuk membuat p sebuah pointer ke z [4], tulis saja <br><br><pre> <code class="cpp hljs">p = &amp;z[<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre> <br>  di mana ampersand sebagai operator unary (monadic) berarti "ambil alamat yang mengikutinya."  Salin nilai member i ke variabel integer n <br>  struktur yang ditunjukkan oleh p dapat dilakukan sebagai berikut: <br><br><pre> <code class="cpp hljs">n = p-&gt;i;</code> </pre> <br>  Perhatikan bahwa panah digunakan untuk mengakses anggota struktur melalui pointer.  Jika kita menggunakan variabel z, maka kita harus menggunakan operator titik: <br><br><pre> <code class="cpp hljs">n = z [<span class="hljs-number"><span class="hljs-number">4</span></span>] .i;</code> </pre> <br>  Perbedaannya adalah bahwa z [4] adalah struktur, dan operator titik memilih elemen <br>  dari tipe komposit (struktur, susunan) secara langsung.  Menggunakan petunjuk, kami tidak memilih peserta secara langsung.  Pointer menginstruksikan Anda untuk terlebih dahulu memilih struktur dan hanya kemudian memilih anggota struktur ini. <br><br>  Terkadang lebih mudah untuk memberi nama ke tipe gabungan.  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unshort;</code> </pre> <br>  mendefinisikan unshort sebagai unsigned short (unsigned short integer).  Sekarang unshort dapat digunakan dalam program sebagai tipe utama.  Sebagai contoh <br><br><pre> <code class="cpp hljs">unshort ul, *u2, u3[<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  mendeklarasikan integer unsigned pendek, sebuah pointer ke integer unsigned pendek, dan <br>  array bilangan bulat tak bertanda pendek. <br><br><h3>  A.4.  Operator </h3><br>  Prosedur dalam C berisi deklarasi dan pernyataan.  Kami sudah melihat deklarasi, jadi sekarang kami akan mempertimbangkan operator.  Tujuan dari operator kondisional dan loop pada dasarnya sama dengan dalam bahasa lain.  Gambar A - 4 menunjukkan beberapa contohnya.  Satu-satunya hal yang perlu diperhatikan adalah kurung kurawal digunakan untuk mengelompokkan operator, dan pernyataan while memiliki dua bentuk, yang kedua mirip dengan pernyataan berulang Pascal. <br><br>  C juga memiliki pernyataan for, tetapi tidak terlihat seperti pernyataan for dalam bahasa lain.  Pernyataan for memiliki bentuk berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (&lt;&gt;; &lt;&gt;; &lt;&gt;) ;</code> </pre> <br>  Hal yang sama dapat diungkapkan melalui pernyataan sementara: <br><br><pre> <code class="cpp hljs">&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(&lt;&gt;) { &lt;&gt;; &lt;&gt; }</code> </pre> <br>  Sebagai contoh, perhatikan pernyataan berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;n; i = i+l) a[i]=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Operator ini menetapkan elemen n pertama array a menjadi nol.  Eksekusi operator dimulai dengan menetapkan i ke nol (ini dilakukan di luar loop).  Kemudian operator diulangi sampai i &lt;n, sambil melakukan penugasan dan peningkatan i.  Tentu saja, alih-alih operator yang menetapkan nilai ke elemen saat ini dari array nol, mungkin ada operator gabungan (blok) yang tertutup kurung keriting. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) k = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; y) { <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j + l, } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x + <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;y) { <span class="hljs-comment"><span class="hljs-comment">/*  if-else */</span></span> j = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  while */</span></span> k = k + k; n = n - l; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { / *    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> */ k = k + k; n = n - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); . A<span class="hljs-number"><span class="hljs-number">-4.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>  C.</code> </pre> <br>  C juga memiliki operator yang mirip dengan operator kasus di Pascal.  Ini adalah pernyataan beralih.  Contoh ditunjukkan pada Gambar A-5.  Bergantung pada nilai ekspresi yang ditentukan dalam sakelar, satu atau lain pernyataan kasus dipilih. <br><br>  Jika ekspresi tidak cocok dengan salah satu pernyataan kasus, maka pernyataan standar dipilih. <br><br>  Jika ekspresi tidak terkait dengan pernyataan kasus dan pernyataan default tidak ada, eksekusi berlanjut dari pernyataan berikutnya setelah pernyataan beralih. <br><br>  Perlu dicatat bahwa untuk keluar dari blok kasus, gunakan pernyataan istirahat.  Jika tidak ada pernyataan break, blok kasus berikutnya akan dieksekusi. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (k) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>: i = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   case 20, ..    switch */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>: i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; / *   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>* / <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: j = <span class="hljs-number"><span class="hljs-number">5</span></span>; } . A<span class="hljs-number"><span class="hljs-number">-5.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span></code> </pre> <br>  Pernyataan break juga bertindak di dalam loop for dan while.  Harus diingat bahwa jika pernyataan break berada di dalam serangkaian loop bersarang, output hanya naik satu tingkat. <br><br>  Pernyataan terkait adalah pernyataan lanjut, yang tidak keluar dari loop, <br>  tetapi menyebabkan penyelesaian iterasi saat ini dan awal iterasi berikutnya <br>  segera.  Ini pada dasarnya adalah pengembalian ke atas loop. <br><br>  C memiliki prosedur yang dapat dipanggil dengan atau tanpa parameter. <br>  Menurut Kernigan dan Ritchie (p. 121), itu tidak diperbolehkan untuk mentransfer array, <br>  struktur atau prosedur sebagai parameter, meskipun melewati pointer ke semua ini <br>  diizinkan.  Apakah ada buku atau tidak (itu akan muncul di ingatan saya: - "Jika ada kehidupan di Mars, jika tidak ada kehidupan di Mars"), banyak kompiler C memungkinkan struktur sebagai parameter. <br>  Nama array, jika ditulis tanpa indeks, berarti pointer ke array, yang menyederhanakan transfer pointer array.  Jadi, jika a adalah nama array jenis apa pun, ia dapat diteruskan ke g dengan menulis <br><br><pre> <code class="cpp hljs">g();</code> </pre> <br>  Aturan ini hanya berlaku untuk array, aturan ini tidak berlaku untuk struktur. <br>  Prosedur dapat mengembalikan nilai dengan menjalankan pernyataan pengembalian.  Pernyataan ini dapat berisi ekspresi, yang hasilnya akan dikembalikan sebagai nilai prosedur, tetapi pemanggil dapat dengan aman mengabaikan nilai pengembalian.  Jika prosedur mengembalikan nilai, maka nilai jenis ditulis sebelum nama prosedur, seperti yang ditunjukkan pada Gambar.  A-6.  Seperti parameter, prosedur tidak dapat mengembalikan array, struktur, atau prosedur, tetapi dapat mengembalikan pointer ke mereka.  Aturan ini dirancang untuk implementasi yang lebih efisien - semua parameter dan hasil selalu sesuai dengan satu kata mesin (di mana alamat disimpan).  Kompiler yang memungkinkan penggunaan struktur sebagai parameter biasanya juga memungkinkan penggunaannya sebagai nilai balik. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/*      */</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> i, j </span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i + j); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } . <span class="hljs-number"><span class="hljs-number">-6.</span></span>   ,   .</code> </pre> <br>  C tidak memiliki I / O. bawaan  Input / output diimplementasikan dengan memanggil fungsi pustaka, yang paling umum diilustrasikan di bawah ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> («x=% dy = %oz = %x \n», x, y, z);</code> </pre> <br>  Parameter pertama adalah string karakter antara tanda kutip (pada kenyataannya, ini adalah array karakter). <br><br>  Setiap karakter yang bukan persentase hanya dicetak apa adanya. <br><br>  Ketika persentase terjadi, parameter berikut dicetak dalam bentuk yang ditentukan oleh surat berikut persentase: <br><blockquote>  d - mencetak sebagai bilangan bulat desimal <br>  o - cetak sebagai integer oktal <br>  u - mencetak sebagai bilangan bulat desimal yang tidak ditandatangani <br>  x - cetak sebagai hex integer <br>  s - cetak sebagai serangkaian karakter <br>  c - cetak sebagai satu karakter </blockquote>  Huruf D, 0, dan X juga diperbolehkan untuk pencetakan angka panjang desimal, oktal, dan heksadesimal. <br><br><h3>  A.5.  Ekspresi </h3><br>  Ekspresi dibuat dengan menggabungkan operan dan operator. <br><br>  Operator aritmatika seperti + dan - dan operator relasional seperti &lt; <br>  dan&gt; mirip dengan rekan mereka dalam bahasa lain.  % Operator <br>  menggunakan modulo.  Perlu dicatat bahwa operator persamaan adalah ==, dan operator kesenjangan adalah!  =.  Untuk memeriksa apakah a dan b sama, Anda dapat menulis seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;&gt;;</code> </pre> <br>  C juga memungkinkan Anda untuk menggabungkan operator penugasan dengan operator lain <br><br><pre> <code class="cpp hljs">a += <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  setara dengan rekaman <br><br><pre> <code class="cpp hljs"> =  + <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Operator lain juga dapat digabungkan dengan cara ini. <br><br>  C memiliki operator untuk memanipulasi bit kata.  Operasi shift dan bitwise logis diizinkan.  Operator shift kiri dan kanan adalah &lt;&lt; <br>  dan &gt;&gt; masing-masing.  Operator Logikal Bitwise &amp;, |  dan ^, yang logis AND (AND), termasuk OR (OR) dan OR eksklusif (XOP), masing-masing.  Jika saya memiliki nilai 035 (oktal), maka ekspresi i &amp; 06 memiliki nilai 04 (oktal).  Contoh lain, jika i = 7, maka <br><br><pre> <code class="cpp hljs">j = (i &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) | <span class="hljs-number"><span class="hljs-number">014</span></span>;</code> </pre> <br>  dan dapatkan 074 untuk j. <br>  Grup operator penting lainnya adalah operator unary, yang masing-masing hanya menerima satu operan.  Sebagai operator unary, ampersand &amp; mendapatkan alamat variabel. <br><br>  Jika p adalah pointer ke integer dan i adalah integer, operator <br><br><pre> <code class="cpp hljs">p = &amp;i;</code> </pre> <br>  menghitung alamat i dan menyimpannya dalam variabel p. <br>  Kebalikan dari mengambil alamat adalah operator yang mengambil pointer sebagai input dan menghitung nilai di alamat itu.  Jika kita baru saja menetapkan alamat i ke pointer p, maka * p memiliki arti yang sama dengan saya. <br><br>  Dengan kata lain, sebagai operator unary, tanda bintang diikuti oleh pointer (atau <br>  ekspresi memberi pointer) dan mengembalikan nilai elemen yang ditunjuknya.  Jika saya memiliki nilai 6, maka operator <br><br><pre> <code class="cpp hljs">j = *;</code> </pre> <br>  akan menetapkan j angka 6. <br>  Operator!  (tanda seru adalah operator negasi) mengembalikan 0 jika operandnya bukan nol, dan 1 jika operatornya adalah 0. <br><br>  Ini terutama digunakan dalam pernyataan if, misalnya <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!x) k=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  memeriksa nilai x.  Jika x adalah nol (salah), maka k diberi nilai 0. Sebenarnya, operator!  membatalkan kondisi yang mengikutinya, sama seperti operator yang tidak ada di Pascal. <br><br>  Operator ~ adalah operator komplemen bitwise.  Setiap 0 di operan <br>  menjadi 1, dan setiap 1 menjadi 0. <br><br>  Ukuran operator melaporkan ukuran operan dalam byte.  Sehubungan dengan <br>  array 20 integer pada komputer dengan integer 2 byte, misalnya sizeof akan memiliki nilai 40. <br><br>  Kelompok operator terakhir adalah operator kenaikan dan penurunan. <br><br>  Operator <br><br><pre> <code class="cpp hljs">++;</code> </pre> <br>  berarti peningkatan p.  Berapa banyak p akan meningkat tergantung pada jenisnya. <br>  Integer atau karakter bertambah 1, tetapi pointer bertambah oleh <br>  ukuran objek yang ditunjukkan dengan cara ini, jika a adalah susunan struktur, dan p adalah penunjuk ke salah satu dari struktur ini, dan kami menulis <br><br><pre> <code class="cpp hljs">p = &amp;a[<span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br>  untuk membuat p point ke salah satu struktur dalam array, lalu setelah meningkatkan p <br>  akan menunjuk ke [4] tidak peduli seberapa besar strukturnya.  Operator <br><br><pre> <code class="cpp hljs">p--;</code> </pre> <br>  mirip dengan operator p ++, kecuali ia menurun daripada meningkatkan nilai operan. <br><br>  Dalam pernyataan <br><br><pre> <code class="cpp hljs">n = k++;</code> </pre> <br>  di mana kedua variabel adalah bilangan bulat, nilai asli k ditugaskan untuk n dan <br>  barulah k meningkat.  Dalam pernyataan <br><br><pre> <code class="cpp hljs">n = ++ k;</code> </pre> <br>  k bertambah pertama, kemudian nilai barunya disimpan dalam n. <br><br>  Dengan demikian, operator ++ (atau -) dapat ditulis sebelum atau setelah operandnya, yang menghasilkan berbagai nilai. <br><br>  Pernyataan terakhir adalah ini?  (tanda tanya) yang memilih satu dari dua alternatif <br>  dipisahkan oleh titik dua.  Misalnya, seorang operator, <br><br><pre> <code class="cpp hljs">i = (x &lt; y ? <span class="hljs-number"><span class="hljs-number">6</span></span> : k + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  bandingkan x dengan y.  Jika x kurang dari y, maka saya mendapat nilai 6;  jika tidak, variabel i mendapat nilai k + 1. Tanda kurung adalah opsional. <br><br><h3>  A.6.  Struktur program </h3><br>  Program C terdiri dari satu atau lebih file yang berisi prosedur dan deklarasi. <br>  File-file ini dapat dikompilasi secara individual menjadi file objek, yang kemudian dihubungkan satu sama lain (menggunakan tautan) untuk membentuk program yang dapat dieksekusi. <br>  Tidak seperti Pascal, deklarasi prosedur tidak dapat disarangkan, oleh karena itu semuanya ditulis pada "tingkat atas" dalam file program. <br><br>  Itu diperbolehkan untuk mendeklarasikan variabel di luar prosedur, misalnya, di awal file sebelum deklarasi pertama prosedur.  Variabel ini bersifat global, dan dapat digunakan dalam prosedur apa pun di seluruh program, kecuali kata kunci statis mendahului deklarasi.  Dalam hal ini, variabel-variabel ini tidak dapat digunakan di file lain.  Aturan yang sama berlaku untuk prosedur.  Variabel yang dideklarasikan di dalam prosedur adalah lokal untuk prosedur. <br>  Prosedur dapat mengakses variabel integer v yang dideklarasikan dalam file lain (asalkan variabel tersebut tidak statis), menyatakannya eksternal: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v;</code> </pre> <br>  Setiap variabel global harus dinyatakan tepat sekali tanpa atribut eksternal untuk mengalokasikan memori untuknya. <br><br>  Variabel dapat diinisialisasi ketika dideklarasikan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  Susunan dan struktur juga dapat diinisialisasi.  Variabel global yang tidak diinisialisasi secara eksplisit menerima nilai default nol. <br><br><h3>  A.7.  C preprocessor </h3><br>  Sebelum file sumber ditransfer ke kompiler C, itu diproses secara otomatis <br>  sebuah program yang disebut preprocessor.  Ini adalah output dari preprocessor, bukan <br>  Program asli diumpankan ke input dari kompiler.  Performa preprosesor <br>  Tiga konversi dasar dalam file sebelum meneruskannya ke kompiler: <br><br>  1. Penyertaan file. <br>  2. Definisi dan penggantian makro. <br>  3. Kompilasi bersyarat. <br><br>  Semua arahan preprosesor dimulai dengan tanda nomor (#) di kolom 1. <br>  Saat melihat arahan <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"prog.h"</span></span></span></span></code> </pre> <br>  dipenuhi oleh preprocessor, itu termasuk file prog.h, baris demi baris, dalam <br>  program untuk diteruskan ke kompiler.  Ketika arahan #include ditulis sebagai <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;prog.h&gt;</span></span></span></span></code> </pre> <br>  kemudian file yang disertakan dicari di direktori / usr / include bukan direktori kerja.  Ini adalah praktik umum dalam C untuk mengelompokkan deklarasi yang digunakan oleh beberapa file dalam file header (biasanya dengan akhiran .h), dan memasukkannya jika perlu. <br>     .  Sebagai contoh <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BLOCK_SIZE 1024</span></span></code> </pre> <br>   BLOCK_SIZE     1024.    <br>     10  «BLOCK_SIZE»    <br>  4-  «1024»  ,      .        .    ,      . <br><br>    —  .  MINIX   <br> ,       8088,           .     : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> i8088 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;   8088&gt; #endif</span></span></span></span></code> </pre> <br>   i8088 ,       #ifdef i8088  #endif     ;     .     <br><br><pre> <code class="cpp hljs">cc -c -Di8088 prog.c</code> </pre> <br>      <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> i8088</span></span></code> </pre> <br>    i8088,      8088  .    MINIX       68000s   ,    . <br><br>    ,   ,   . A-7 (a).       prog.h,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAXAELEMENTS 100</span></span></code> </pre><br> ,      <br><br><pre> <code class="bash hljs">cc -E -Di8088 prog.c</code> </pre> <br>  ,     ,   ,    . A-7 (b). <br><br>   ,    ,     C . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include prog.h int x; main () main (); { { int a[MAX_ELEMENTS]; int a [100];  = 4;  = 4; a[x] = 6; [] = 6; #ifdef i8088 printf("8088. a[x]:% d\n", a[x]); printf ("8088. a[x]:% d\n", a[x]); #endif } #ifdef m68000 printf ("68000. x=%d\n", x); #endif } () (b) . -7. (a)   prog.c. (b)  .</span></span></code> </pre> <br>  ,         ,    #.       <br><br><pre> <code class="bash hljs">cc -c -Dm68000 prog.c</code> </pre> <br>      .       : <br><br><pre> <code class="bash hljs">cc -c prog.c</code> </pre> <br>        . (    ,   ,        -Dﬂags.) <br><br><h3> .8.  </h3><br>       ,    C,       .    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n--) *p++ = *q++;</code> </pre> <br>  p  q    ,  n  .   n-   ,    q,  ,    .      ,      0,     ,           . <br><br>    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) a[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>    N    0.       : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; p &lt; &amp;a[N]; p++) *p = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>      p  ,      .     ,  p    N-  .    ,   ,     . <br><br>       .  Sebagai contoh <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = f (x)) &lt;  &gt;;</code> </pre> <br>    f,      a  <br> , ,     ()   ().     ,   .  Operator <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = b) &lt;  &gt;;</code> </pre> <br>     b  a,    a,     .       <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;  &gt;;</code> </pre> <br>       ,   . <br><br><h3>  Kata penutup </h3><br>   .   ,     ,   .          . ,          . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464075/">https://habr.com/ru/post/id464075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464053/index.html">Nota: Pemilihan trek dan algoritma rotasi</a></li>
<li><a href="../id464055/index.html">Kami mempelajari data yang dikumpulkan oleh Xiaomi Mi Band untuk tahun ini</a></li>
<li><a href="../id464057/index.html">Hilbert, Lebesgue ... and the Void</a></li>
<li><a href="../id464063/index.html">Memotong kabel pada tahun 2019</a></li>
<li><a href="../id464071/index.html">Revolusi atau rasa sakit? Laporan Reaksi Kait Yandex</a></li>
<li><a href="../id464077/index.html">Tidak, Anda tidak perlu delta 50 km / s. Anda Membutuhkan Teknologi Aditif (Bagian 1)</a></li>
<li><a href="../id464079/index.html">Cara membuat pesawat ruang angkasa lepas landas dan mendarat tanpa teknologi keajaiban</a></li>
<li><a href="../id464083/index.html">Bagaimana ITSM akan membantu dan siapa yang menerapkan metodologi ini</a></li>
<li><a href="../id464089/index.html">Mengotomatiskan permintaan HTTP dalam konteks Spring</a></li>
<li><a href="../id464091/index.html">Intisari materi menarik untuk pengembang ponsel # 311 (pada 12 - 18 Agustus)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>