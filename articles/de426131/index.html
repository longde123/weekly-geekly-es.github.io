<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•å üë®‚Äçüë®‚Äçüëß‚Äçüë¶ üëµüèª Laden Sie die Konfiguration √ºber USB auf das FPGA herunter oder zerlegen Sie FTDI MPSSE üì¥ üìµ üî∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Leben jeder Schublade kommt eine Zeit, in der Sie Ihren eigenen Loader der Konfigurationsdatei in das FPGA schreiben m√∂chten. Ich musste an der Ent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Laden Sie die Konfiguration √ºber USB auf das FPGA herunter oder zerlegen Sie FTDI MPSSE</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426131/"><img src="https://habrastorage.org/webt/dx/i7/px/dxi7pxs820_gc9p_q_1m6zoaakm.jpeg"><br><br>  Im Leben jeder Schublade kommt eine Zeit, in der Sie Ihren eigenen Loader der Konfigurationsdatei in das FPGA schreiben m√∂chten.  Ich musste an der Entwicklung eines Ausbildungsstandes f√ºr die Abteilung einer technischen Universit√§t teilnehmen.  Der Stand ist f√ºr die Untersuchung der digitalen Signalverarbeitung konzipiert, obwohl dies im Rahmen dieses Artikels nicht von besonderer Bedeutung ist.  Und die Bedeutung ist, dass das FPGA (Altera Cyclone IV) das Herzst√ºck des Standes ist, auf dem die Sch√ºler alle Arten von DSP-Schemata sammeln, wie sie vom Autor des Standes konzipiert wurden.  Der St√§nder ist √ºber USB mit dem Computer verbunden.  Sie m√ºssen das FPGA √ºber USB vom Computer herunterladen. <br><p>  Es wurde beschlossen, mithilfe von FTDI in seiner zweikanaligen Inkarnation - FT2232H - eine Verbindung zu einem PC herzustellen.  Ein Kanal wird f√ºr die FPGA-Konfiguration verwendet, der andere f√ºr den Hochgeschwindigkeits-FIFO-Austausch. </p><a name="habracut"></a><br><p>  FTDI verf√ºgt √ºber eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MORPH-IC-II-</a> Debug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-</a> Karte, auf der das Cyclone II-FPGA √ºber USB <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geflasht</a> wird.  Konzepte im √∂ffentlichen Bereich.  Der Quellcode des Bootloaders ist teilweise ge√∂ffnet: Der Bootloader selbst ist verf√ºgbar. Die gesamte Logik der Arbeit mit FTDI wird jedoch in eine private Bibliothek verschoben und kann nicht ge√§ndert werden.  In Wahrheit hatte ich urspr√ºnglich vor, diesen Bootloader in meinem Projekt zu verwenden oder in extremen F√§llen meine Shell basierend auf ihrer DLL zu erstellen.  Die Firmware wird im passiven seriellen Modus (passives serielles PS) in das FPGA geladen, FTDI arbeitet im MPSSE-Modus.  Auf dem Steckbrett wurde die Leistung der MORPH-IC-II-L√∂sung vollst√§ndig best√§tigt, aber das Problem kam, wie es h√§ufig vorkommt, nicht von wo.  Es stellte sich heraus, dass w√§hrend des Betriebs der DLL MORPH-IC-II alle angeschlossenen FTDI-Ger√§te blockiert sind und im Rahmen des Trainingskomplexes zwei weitere Ger√§te mit √§hnlichen Wandlern vorhanden sind: ein Generator und ein Signalanalysator.  Gleichzeitiges Arbeiten mit ihnen ist nicht m√∂glich.  Verdammt komisch und nervig. </p><br><p>  Ein √§hnlicher Fall wurde von den Jungs vom Marsrover implementiert: dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">USB JTAG-Programmierer MBFTDI</a> .  FTDI wird dort auch im MPSSE-Modus verwendet, aber im Gegensatz zu MORPH-IC-II werden FPGA-Operationen im JTAG-Modus ausgef√ºhrt.  Quellen sind frei verf√ºgbar, aber ich habe keinen eindeutigen Hinweis auf ihren Status (Lizenz) gefunden.  Um sie in einem kommerziellen Projekt zu verwenden, hob sich meine Hand nicht. </p><br><p>  Ich werde einen solchen Fehler korrigieren. Alles, was im Rahmen dieses Artikels vorgestellt wird, wird in einem offenen Repository unter der BSD-Lizenz ver√∂ffentlicht. </p><br><h2 id="zagruzka-fayla-konfiguracii-v-mikroshemu-plis">  Konfigurationsdatei auf FPGA-Chip herunterladen </h2><br><p>  Zun√§chst sollten Sie sich mit dem FPGA-Startmodus befassen.  F√ºr diejenigen, die gerade erst anfangen, sich mit dem Thema vertraut zu machen, werde ich einen kleinen Ausflug machen.  Obwohl Altera (Intel) FPGAs der Cyclone IV E-Familie auf meinem Board installiert sind, sind die Lademethoden f√ºr die gesamte Cyclone FPGA-Gruppe √§hnlich, und es besteht der Verdacht, dass sie in der einen oder anderen Form f√ºr viele andere Familien geeignet sind. </p><br><p>  Diese Art von FPGA verwendet fl√ºchtiges SRAM zum Speichern von Konfigurationsdaten.  Diese Konfigurationsdaten bestimmen die Funktionalit√§t des resultierenden Ger√§ts.  Im Fachjargon werden diese Daten h√§ufig als "Firmware" bezeichnet.  Daher wird die Firmware in einem speziellen RAM gespeichert und muss bei jedem Einschalten des Ger√§ts in den FPGA-Chip geladen werden.  Es gibt verschiedene M√∂glichkeiten (Konfigurationsschemata), mit denen die Firmware in den SRAM geladen werden kann (die Liste ist f√ºr Cyclone IV E relevant): </p><br><ol><li>  Aktive serielle (AS). </li><li>  Aktive Parallele (AP) </li><li>  Passive Seriennummer (PS) </li><li>  Schnelle passive Parallele (FPP). </li><li>  JTAG. </li></ol><br><p>  Die Auswahl eines bestimmten Startmodus erfolgt √ºber die externen Terminals des FPGA (MSEL-Gruppe).  Der JTAG-Modus ist immer verf√ºgbar.  Der aktive Modus bedeutet, dass das FPGA bei eingeschalteter Stromversorgung unabh√§ngig Daten aus dem externen Speicher (seriell oder parallel) liest.  Im passiven Modus wartet das FPGA darauf, dass ein externes Medium proaktiv Konfigurationsdaten an dieses √ºbertr√§gt.  Diese Schemata passen gut in das Konzept von Master (Master) - Slave (Slave).  Im aktiven Modus fungiert das FPGA als Master und im passiven Modus als Slave. </p><br><p>  Bei diesem Problem handelt es sich nicht um das FPGA, sondern der Benutzer muss entscheiden, wann die Firmware aktualisiert werden soll, sodass der Startmodus passiv sein sollte.  Und um die Beine des Chips zu schonen, w√§hlen wir eine serielle Schnittstelle.  Passive Serial (PS) -Modus und JTAG sind hier geeignet.  Die Logik des JTAG ist etwas komplizierter. Konzentrieren wir uns also auf die erste Option. <br>  Die folgende Abbildung zeigt das Verbindungsschema des FPGA zu einem externen Controller zum Herunterladen im PS-Modus. </p><br><img width="400" src="https://habrastorage.org/webt/q-/rj/pe/q-rjpeqe5y8ojlu8ywedoejklxq.png"><br><p>  Um die Konfiguration zu starten, muss der externe Master einen √úbergang von niedrig nach hoch auf der <em>nCONFIG-</em> Leitung <em>erzeugen</em> .  Sobald das FPGA bereit ist, Daten zu empfangen, bildet es auf der <em>nSTATUS-</em> Leitung einen hohen Pegel.  Danach kann der Master mit der √úbertragung von Daten auf der <em>DATA-</em> Leitung <em>[0]</em> und den entsprechenden Taktimpulsen auf der <em>DCLK-</em> Leitung beginnen.  Daten m√ºssen an das Zielger√§t √ºbertragen werden, bis auf der Leitung <em>CONF_DONE</em> ein hoher Pegel hergestellt ist (oder die Daten nicht enden) und das FPGA in den Initialisierungszustand wechselt.  Es ist zu beachten, dass nach dem <em>Setzen von CONF_DONE</em> auf eins zwei weitere Taktimpulse angelegt werden m√ºssen, damit die FPGA-Initialisierung beginnt. </p><br><p>  Die Daten werden durch das niedrigstwertige Bit ( <abbr title="Am wenigsten bedeutendes St√ºck">LSB</abbr> ) vorw√§rts √ºbertragen, <abbr title="Am wenigsten bedeutendes St√ºck">dh</abbr> wenn die Konfigurationsdatei die Sequenz 02 1B EE 01 FA enth√§lt (nehmen Sie das Beispiel wie aus dem Handbuch), sollte die Sequenz auf der Datenleitung gebildet werden: </p><br><pre><code class="hljs powershell"><span class="hljs-number"><span class="hljs-number">0100</span></span><span class="hljs-literal"><span class="hljs-literal">-0000</span></span> <span class="hljs-number"><span class="hljs-number">1101</span></span><span class="hljs-literal"><span class="hljs-literal">-1000</span></span> <span class="hljs-number"><span class="hljs-number">0111</span></span><span class="hljs-literal"><span class="hljs-literal">-0111</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span><span class="hljs-literal"><span class="hljs-literal">-0000</span></span> <span class="hljs-number"><span class="hljs-number">0101</span></span><span class="hljs-literal"><span class="hljs-literal">-1111</span></span></code> </pre> <br><p>  Somit werden nur f√ºnf Leitungen verwendet: <em>DATA-</em> Leitungen <em>[0]</em> und <em>DCLK</em> f√ºr die serielle √úbertragung, <em>nCONFIG-</em> , <em>nSTATUS-</em> , <em>CONF_DONE-Leitungen</em> f√ºr die Steuerung. <br>  Im Kern ist der PS-Modus nichts anderes als SPI mit zus√§tzlicher Flag-Manipulation. <br>  Die Daten√ºbertragungsrate sollte niedriger sein als die in der Dokumentation angegebene maximale Frequenz. F√ºr die im Projekt verwendete Cyclone IV E-Serie betr√§gt sie 66 MHz. </p><br><p>  Die minimale √úbertragungsfrequenz existiert nicht, theoretisch ist es m√∂glich, die Konfiguration auf unbestimmte Zeit auszusetzen.  Dies bietet hervorragende M√∂glichkeiten f√ºr ein schrittweises Debuggen unter Beteiligung eines Oszilloskops, das wir sicherlich verwenden werden. </p><br><p>  Die folgende Abbildung zeigt das Zeitdiagramm der Schnittstelle mit den wichtigsten Zeitabl√§ufen. </p><br><img width="720" src="https://habrastorage.org/webt/54/et/uy/54etuy0yva1est_qtdqp9yopqj8.png"><br><h2 id="hitryy-zver-mpsse">  Sly Beast MPSSE </h2><br><p>  Betrachten Sie den Betrieb von FTDI im MPSSE-Modus.  Der MPSSE-Modus (Multi-Protocol Synchronous Serial Engine) ist meiner Meinung nach ein mehr oder weniger erfolgreicher Versuch, einen bestimmten Designer f√ºr serielle Schnittstellen zu erstellen, um dem Entwickler die M√∂glichkeit zu geben, weit verbreitete Daten√ºbertragungsprotokolle wie SPI, I2C, JTAG, 1-Wire und viele zu implementieren andere basieren auf ihnen. </p><br><p>  Derzeit ist der Modus f√ºr Mikroschaltungen verf√ºgbar: FT232H, FT2232D, FT2232H, FT4232H.  In meinem Projekt verwende ich FT2232H, daher sprechen wir in gr√∂√üerem Umfang dar√ºber.  F√ºr den MPSSE-Modus werden 16 Abschnitte zugewiesen, die in zwei Bytes unterteilt sind: das untere L und das h√∂chste H. Jedes Byte kann gelesen oder gesetzt werden.  Die vier Unterschenkel des Bytes L haben spezielle Funktionen - √ºber sie kann eine serielle Daten√ºbertragung erfolgen.  Jeder Zweig kann als Eingabe oder Ausgabe konfiguriert werden, ein Standardwert f√ºr die Ausgabe kann festgelegt werden.  F√ºr die sequentielle √úbertragung, die Reihenfolge der Bits ( <abbr title="Das wichtigste Bit">MSB</abbr> / <abbr title="Am wenigsten bedeutendes St√ºck">LSB</abbr> ), die L√§nge des √ºbertragenen Wortes, die Frequenz der Taktimpulse, die Synchronisation vorne - vorne (steigend) oder hinten (fallend) k√∂nnen Sie w√§hlen, ob Sie nur Taktimpulse ohne Daten senden oder die 3-Phasen-Taktung ausw√§hlen m√∂chten (relevant f√ºr I2C) und vieles mehr. </p><br><p>  Fahren Sie nahtlos mit der Programmierung fort.  Es gibt zwei alternative M√∂glichkeiten der Softwareinteraktion mit FTDI-Chips: Die erste, nennen wir es klassisch. In diesem Fall wird der Chip im System, wenn er an einen USB-Anschluss angeschlossen ist, als virtueller serieller Anschluss (COM) definiert. Das Betriebssystem verwendet den VCP-Treiber (Virtual COM Port).  Alle weiteren Programmierungen unterscheiden sich nicht von der Programmierung des klassischen COM-Ports: ge√∂ffnet - √ºbertragen / gez√§hlt - geschlossen.  Dies gilt f√ºr verschiedene Betriebssysteme, einschlie√ülich Linux und Mac OS.  Mit diesem Ansatz k√∂nnen jedoch nicht alle Funktionen des FTDI-Controllers realisiert werden - der Chip funktioniert als USB-UART-Adapter.  Die zweite Methode wird von der propriet√§ren FTD2XX-Bibliothek bereitgestellt. Diese Schnittstelle bietet spezielle Funktionen, die in der Standard-COM-Port-API nicht verf√ºgbar sind. Insbesondere k√∂nnen spezielle Betriebsmodi wie MPSSE, 245 FIFO und Bit-Bang konfiguriert und verwendet werden.  Die FTD2XX-API-Bibliothek ist im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">D2XX-Programmierhandbuch f√ºr die Entwicklung</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Softwareanwendungen</a> gut dokumentiert, das in engen Kreisen seit langem bekannt ist.  Und ja, FTD2XX ist auch f√ºr verschiedene Betriebssysteme verf√ºgbar. </p><br><p>  Die FTDI-Entwickler standen vor der Aufgabe, das relativ neue MPSSE in das bestehende Interaktionsmodell der D2XX-Software zu integrieren.  Und es gelang ihnen, f√ºr die Arbeit im MPSSE-Modus werden dieselben Funktionen verwendet wie f√ºr andere "klassische" Modi, es wird dieselbe FTD2XX-Bibliotheks-API verwendet. </p><br><p>  Kurz gesagt kann der Algorithmus f√ºr den Betrieb im MPSSE-Modus wie folgt beschrieben werden: </p><br><ol><li>  Suchen Sie das Ger√§t im System und √∂ffnen Sie es. </li><li>  Initialisieren Sie den Chip und versetzen Sie ihn in den MPSSE-Modus. </li><li>  Stellen Sie den Betriebsmodus von MPSEE ein. </li><li>  Direkte Arbeit mit Daten: GPIO senden, empfangen, verwalten - wir implementieren das Zielaustauschprotokoll. </li><li>  Schlie√üen Sie das Ger√§t. </li></ol><br><h2 id="pishem-zagruzchik">  Einen Bootloader schreiben </h2><br><p>  Kommen wir zum praktischen Teil.  In meinen Experimenten werde ich die Eclipse-Version von Oxygen.3a Release (4.7.3a) als IDE und mingw32-gcc (6.3.0) als Compiler verwenden.  Win7 Betriebssystem. </p><br><p>  Von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FTDI-</a> Website laden wir die neueste aktuelle Version des Treibers f√ºr unser Betriebssystem herunter.  Im Archiv finden wir die Header-Datei ftd2xx.h mit einer Beschreibung aller API-Funktionen.  Die API selbst ist als ftd2xx.dll implementiert, aber wir werden den dynamischen Import f√ºr sp√§ter belassen und den statischen Link verwenden: Wir ben√∂tigen die Bibliotheksdatei ftd2xx.lib.  In meinem Fall befindet sich ftd2xx.lib im i386-Verzeichnis. </p><br><p>  Erstellen Sie in Eclipse ein neues C-Projekt.  Das Erstellen eines <em>Makefiles</em> kann mit einer IDE als vertrauensw√ºrdig eingestuft werden.  Geben Sie in den Linker-Einstellungen den Pfad und den Namen der ftd2xx-Bibliothek an (ich habe die erforderlichen Dateien in das Projektverzeichnis im Ordner ftdi √ºbertragen).  Ich werde mich nicht auf die Funktionen zum Einrichten eines Projekts f√ºr Eclipse konzentrieren, da ich vermute, dass die meisten von ihnen andere Umgebungen und Compiler f√ºr die Win-Programmierung verwenden. </p><br><h3 id="punkt-pervyy-nayti-devays-i-otkryt-ego">  Punkt eins.  Suchen Sie ein Ger√§t und √∂ffnen Sie es </h3><br><p>  Mit der FTD2XX-API k√∂nnen Sie den Chip anhand der einen oder anderen bekannten Informationen √∂ffnen.  Dies kann die Seriennummer im System sein: Der erste angeschlossene FTDI-Chip erh√§lt die Nummer 0, die n√§chste 1 usw.  Die Anzahl im System wird durch die Reihenfolge bestimmt, in der die Mikroschaltungen angeschlossen sind, gelinde gesagt, dies ist nicht immer praktisch.  Um den Chip nach Nummer zu √∂ffnen, wird die Funktion <code>FT_Open</code> .  Sie k√∂nnen den Chip anhand seiner Seriennummer ( <code>FT_OPEN_BY_SERIAL_NUMBER</code> ), Beschreibung ( <code>FT_OPEN_BY_DESCRIPTION</code> ) oder nach Standort ( <code>FT_OPEN_BY_LOCATION</code> ) <code>FT_OpenEx</code> . <code>FT_OpenEx</code> Funktion <code>FT_OpenEx</code> .  Die Seriennummer und Beschreibung werden im internen Speicher des Chips gespeichert und k√∂nnen dort w√§hrend der Herstellung des Ger√§ts mit installiertem FTDI aufgezeichnet werden.  Die Beschreibung kennzeichnet in der Regel den Ger√§tetyp oder die Familie, und die Seriennummer muss f√ºr jedes Produkt eindeutig sein.  Daher ist die Beschreibung die bequemste Methode, um Ger√§te zu identifizieren, die von dem zu entwickelnden Programm unterst√ºtzt werden.  Wir werden den FTDI-Chip gem√§√ü der Beschreibung (Deskriptor) √∂ffnen.  Wenn wir die Chip-Deskriptor-Zeichenfolge anfangs kannten, m√ºssen wir nicht nach dem Ger√§t im System suchen. Als Experiment werden jedoch alle Ger√§te angezeigt, die mit FTDI an den Computer angeschlossen sind.  Mit der Funktion <code>FT_CreateDeviceInfoList</code> erstellen <code>FT_CreateDeviceInfoList</code> eine detaillierte Liste der verbundenen Chips, und mit der Funktion <code>FT_GetDeviceInfoList</code> ber√ºcksichtigt. </p><br><div class="spoiler">  <b class="spoiler_title">Liste der angeschlossenen Ger√§te.</b>  <b class="spoiler_title">Listing:</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ftStatus = FT_CreateDeviceInfoList(&amp;numDevs); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ftStatus == FT_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Number of devices is %d\n"</span></span>,numDevs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numDevs == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allocate storage for list based on numDevs devInfo = (FT_DEVICE_LIST_INFO_NODE*)malloc(sizeof(FT_DEVICE_LIST_INFO_NODE)*numDevs); ftStatus = FT_GetDeviceInfoList(devInfo,&amp;numDevs); if (ftStatus == FT_OK) for (int i = 0; i &lt; numDevs; i++) { printf("Dev %d:\n",i); printf(" Flags=0x%x\n",devInfo[i].Flags); printf(" Type=0x%x\n",devInfo[i].Type); printf(" ID=0x%x\n",devInfo[i].ID); printf(" LocId=0x%x\n",devInfo[i].LocId); printf(" SerialNumber=%s\n",devInfo[i].SerialNumber); printf(" Description=%s\n",devInfo[i].Description); }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Begr√º√üe meinen Zoo</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">D:\workspace\ftdi-mpsse-ps\<span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span>&gt;ftdi-mpsse-ps.exe Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> devices <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> Dev <span class="hljs-number"><span class="hljs-number">0</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x5</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036001</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x214</span></span> SerialNumber = AI043NNV Description = FT232R USB UART Dev <span class="hljs-number"><span class="hljs-number">1</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x6</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036010</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x2121</span></span> SerialNumber = L731T70OA Description = LESO7 A Dev <span class="hljs-number"><span class="hljs-number">2</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x6</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036010</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x2122</span></span> SerialNumber = L731T70OB Description = LESO7 B Dev <span class="hljs-number"><span class="hljs-number">3</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x8</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036014</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x213</span></span> SerialNumber = FTYZ92L6 Description = LESO4<span class="hljs-number"><span class="hljs-number">.1</span></span>_ER</code> </pre> </div></div><br><p>  An meinen PC sind drei Ger√§te mit FTDI-Chips angeschlossen: FT232RL (Typ 0x5), FT2232H (Typ 0x6) und FT232H (Tepe 0x8).  Der FT2232H-Chip im System wurde als zwei unabh√§ngige Ger√§te angezeigt (Dev 1 und Dev 2).  Die FPGA-PS-Schnittstelle ist mit Dev 2 verbunden, ihr Deskriptor lautet ‚ÄûLESO7 B‚Äú.  √ñffne es: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Open a device with device description "LESO7 B" ftStatus = FT_OpenEx("LESO7 B", FT_OPEN_BY_DESCRIPTION, &amp;ftHandle); if (ftStatus != FT_OK) { printf ("pen failure\r\n"); return -1; }</span></span></code> </pre> <br><p>  Die meisten API-Funktionen geben den Status ihres Aufrufs vom Typ <code>FT_STATUS</code> . Alle m√∂glichen Werte werden in der Header-Datei als enum beschrieben.  Es gibt viele davon, aber es reicht zu wissen, dass der <code>FT_OK</code> Wert das Fehlen eines Fehlers ist. Alle anderen Werte sind Fehlercodes.  Ein guter Programmierstil besteht darin, den Statuswert nach jedem Aufruf der API-Funktion zu √ºberpr√ºfen. </p><br><p>  Wenn das Ger√§t erfolgreich ge√∂ffnet wurde, wird in der Variablen <code>ftHandle</code> anderer Wert als Null <code>ftHandle</code> , ein √§quivalenter Dateideskriptor, der beim Arbeiten mit Dateien verwendet wird.  Das resultierende Handle stellt eine Verbindung mit der Hardwareschnittstelle her und sollte verwendet werden, wenn alle Bibliotheksfunktionen aufgerufen werden, die Zugriff auf den Chip erfordern. <br>  Um die Funktionsf√§higkeit des Systems f√ºr die aktuelle Phase in der Praxis zu best√§tigen, sollten wir sofort mit Schritt 5 unseres Algorithmus fortfahren. </p><br><p>  Nachdem Sie mit dem Chip fertig sind, m√ºssen Sie ihn schlie√üen.  Verwenden Sie dazu die Funktion <code>FT_Close</code> : </p><br><pre> <code class="cpp hljs">FT_Close(ftHandle);</code> </pre> <br><h3 id="punkt-2-inicializiruem-chip-i-vklyuchaem-mpsse">  Punkt 2. Initialisieren Sie den Chip und schalten Sie die MPSSE ein </h3><br><p>  Die Einstellung ist typisch f√ºr die meisten Modi und wird in der Dokumentation zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AN_135 FTDI MPSSE Basics ausf√ºhrlich beschrieben</a> . </p><br><ol><li>  Wir f√ºhren einen Reset (Rezet) des Chips durch.  <code>FT_ResetDevice</code> Funktion. </li><li>  Falls sich im Empfangspuffer M√ºll befindet, l√∂schen wir ihn.  <code>FT_Purge</code> Funktion. </li><li>  Passen Sie die Gr√∂√üe der Puffer zum Lesen und Schreiben an.  Funktion <code>FT_SetUSBParameters</code> . </li><li>  Schalten Sie die Parit√§t aus.  <code>FT_SetChars</code> . </li><li>  Wir legen Zeit√ºberschreitungen f√ºr das Lesen und Schreiben fest.  Standardm√§√üig sind Zeit√ºberschreitungen deaktiviert. Aktivieren Sie die √úbertragungszeit√ºberschreitung.  <code>FT_SetTimeouts</code> . </li><li>  Wir konfigurieren die Wartezeit f√ºr das Senden eines Pakets vom Chip an den Host.  Standardm√§√üig 16 ms, beschleunigen auf 1 ms.  <code>FT_SetLatencyTimer</code> . </li><li>  Aktivieren Sie die Flusskontrolle, um eingehende Anforderungen zu synchronisieren.  <code>FT_SetFlowControl</code> . </li><li>  Alles ist bereit, um den MPSSE-Modus zu aktivieren.  Setzen Sie den MPSSE-Controller zur√ºck.  Wir verwenden die Funktion <code>FT_SetBitMode</code> und setzen den Modus auf 0 (Modus = 0, Maske = 0). </li><li>  Schalten Sie den MPSSE-Modus ein.  Funktion <code>FT_SetBitMode</code> - Modus = 2, Maske = 0. </li></ol><br><p>  Wir vereinen und konfigurieren den Chip in der Funktion <code>MPSSE_open</code> . Als Parameter √ºbergeben wir eine Zeile mit dem Handle des zu √∂ffnenden Ger√§ts: </p><br><div class="spoiler">  <b class="spoiler_title">Listing MPSSE_open</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_open</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *description)</span></span></span><span class="hljs-function"> </span></span>{ FT_STATUS ftStatus; ftStatus = FT_OpenEx(description, FT_OPEN_BY_DESCRIPTION, &amp;ftHandle); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ftStatus != FT_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"open failure\r\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FT_DEVICE_NOT_OPENED; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"open OK, %d\r\n"</span></span>, ftHandle); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nConfiguring port for MPSSE use...\n"</span></span>); ftStatus |= FT_ResetDevice(ftHandle); <span class="hljs-comment"><span class="hljs-comment">//Purge USB receive buffer first by reading out all old data from FT2232H receive buff: ftStatus |= FT_Purge(ftHandle, FT_PURGE_RX); //Set USB request transfer sizes to 64K: ftStatus |= FT_SetUSBParameters(ftHandle, 65536, 65536); //Disable event and error characters: ftStatus |= FT_SetChars(ftHandle, 0, 0, 0, 0); //Sets the read and write timeouts in milliseconds: ftStatus |= FT_SetTimeouts(ftHandle, 0, 5000); //Set the latency timer to 1mS (default is 16mS): ftStatus |= FT_SetLatencyTimer(ftHandle, 1); //Turn on flow control to synchronize IN requests: ftStatus |= FT_SetFlowControl(ftHandle, FT_FLOW_RTS_CTS, 0x00, 0x00); //Reset controller: ftStatus |= FT_SetBitMode(ftHandle, 0x0, FT_BITMODE_RESET); //Enable MPSSE mode: ftStatus |= FT_SetBitMode(ftHandle, 0x0, FT_BITMODE_MPSSE); if (ftStatus != FT_OK) { printf("Error in initializing the MPSSE %d\n", ftStatus); return FT_OTHER_ERROR; } Sleep(50); // Wait for all the USB stuff to complete and work return FT_OK; }</span></span></code> </pre> </div></div><br><h3 id="punkt-3-nastroim-rezhim-raboty-mpsee">  Punkt 3. Konfigurieren Sie den MPSEE-Betriebsmodus </h3><br><p>  Tats√§chlich ist zu diesem Zeitpunkt der MPSSE-Prozessor aktiviert und bereit, Befehle zu empfangen.  Befehle sind Bytefolgen, deren erstes Byte "Op-Code" ist, gefolgt von Befehlsparametern.  Der Befehl hat m√∂glicherweise keine Parameter und besteht aus einem "Op-Code".  Befehle werden mit der Funktion <code>FT_Write</code> . Eine Antwort vom MPSSE-Prozessor kann mit der Funktion <code>FT_Read</code> abgerufen werden. </p><br><p>  Nach jedem Senden eines Befehls ist es hilfreich, die Prozessorantwort zu lesen, da die Antwort im Falle eines falschen Befehls eine Fehlermeldung enthalten kann - das 0xFA-Zeichen.  Der Mechanismus "Bad Command - 0xFA Response" kann verwendet werden, um das Anwendungsprogramm mit dem MPSSE-Prozessor zu synchronisieren.  Wenn alles in Ordnung ist, gibt der Chip das 0xFA-Zeichen bei einem absichtlich fehlerhaften Befehl zur√ºck.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Operationscodes</a> werden im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Befehlsprozessor f√ºr den MPSSE- und MCU-Hostbus-Emulationsmodus beschrieben</a> . <br>  Bei der Konfiguration von MPSSE m√ºssen Datenrate, Richtung und Anfangszust√§nde der E / A-Leitungen festgelegt werden. <br>  Stellen Sie die Datenrate des MPSSE-Prozessors ein.  Die Einstellungen f√ºr Chips, die nur den Vollgeschwindigkeitsmodus (FT2232 <strong>D</strong> ) unterst√ºtzen, und f√ºr Chips mit Hochgeschwindigkeitsmodus (FT2232 <strong>H</strong> , FT232H, FT4232H) sind etwas unterschiedlich.  Der √§ltere FT2232D verwendet einen 12-MHz-Takt, w√§hrend moderne 60-MHz-Takt verwenden.  Daher die Formel zur Berechnung der Daten√ºbertragungsrate: </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>S</mi><mi>p</mi><mi>e</mi><mi>e</mi><mi>d</mi><mo>&amp;#x200B;</mo><mo>&amp;#x200B;</mo><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>f</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow></msub></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mi>D</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>o</mi><mi>r</mi><mo stretchy=&quot;false&quot;>)</mo><mtext>&amp;#xA0;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><mn>2</mn></mrow></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="43.704ex" height="2.66ex" viewBox="0 -832 18817 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-44" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-61" x="828" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-74" x="1358" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-61" x="1719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-53" x="2249" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-70" x="2894" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-65" x="3398" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-65" x="3864" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-64" x="4331" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMAIN-3D" x="5187" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-66" x="6494" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-72" x="7044" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-61" x="7496" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-63" x="8025" y="0"></use><g transform="translate(8459,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-66" x="0" y="0"></use><g transform="translate(490,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-63" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-6F" x="433" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-72" x="919" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-65" x="1370" y="0"></use></g></g><g transform="translate(10348,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMAIN-31" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMAIN-2B" x="1112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-44" x="2112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-69" x="2941" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-76" x="3286" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-69" x="3772" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-73" x="4117" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-6F" x="4587" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-72" x="5072" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMAIN-29" x="5524" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-63" x="6163" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-64" x="6597" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-6F" x="7120" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMATHI-74" x="7606" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhiIeXSQFhlmsQomDBungF7KEmowOg#MJMAIN-32" x="7967" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D.</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S.</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></mi><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A. A.</font></font></mo><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A. A.</font></font></mo><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></mo><mtext>&nbsp;</mtext><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></mi><mrow class="MJX-TeXAtom-ORD"><msub><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></mi><mrow class="MJX-TeXAtom-ORD"><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font></mi></mrow></msub></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></mn><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D.</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ich</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ich</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></mi><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></mo><mtext>&nbsp;</mtext><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></mi><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></mn></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> Data Speed ‚Äã‚Äã= \ frac {f_ {core}} {(1 + Divisor) \ cdot 2} </script></p><br><p>  wobei <em>f <sub>core</sub></em> die FTDI- <em>Kernfrequenz</em> ist, ist <em>Divisor</em> ein Zwei-Byte-Teiler, der tats√§chlich die Datentaktfrequenz festlegt. <br>  Wenn der Teiler gleich Null ist, betr√§gt die maximale Daten√ºbertragungsrate 30 Mbit / s, und die minimale Daten√ºbertragungsrate liegt bei einem Teiler zwischen 65535 und 458 Bit / s. <br>  Wir werden die Berechnung des Teilers dem Pr√§prozessor anvertrauen.  Das Makro gibt den Divisor zur√ºck: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FCORE 60000000ul #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV(data_speed) ((FCORE/(2*data_speed)) -1)</span></span></code> </pre> <br><p>  Und diese beiden Makros geben die hohen bzw. niedrigen Bytes des Teilers zur√ºck: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV_H(data_speed) ((MPSSE_DATA_SPEED_DIV(data_speed)) &gt;&gt; 8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV_L(data_speed) \ (MPSSE_DATA_SPEED_DIV(data_speed) - (MPSSE_DATA_SPEED_DIV_H(data_speed)&lt;&lt; 8))</span></span></code> </pre> <br><p>  Dar√ºber hinaus ist zu beachten, dass in modernen Chips aus Gr√ºnden der Kompatibilit√§t mit dem alten FT2232D ein zus√§tzlicher 5-Teiler vorhanden ist, der 60 MHz in 12 MHz umwandelt.  Dieser Teiler ist standardm√§√üig aktiviert, in unserem Fall sollte er ausgeschaltet sein. <br>  Wir finden den entsprechenden Op-Code (0x8A) und den Helmbefehl an den Prozessor: </p><br><div class="spoiler">  <b class="spoiler_title">Auflistung der Teameinreichungen</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], byInputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; DWORD dwNumBytesToRead, dwNumBytesSent = <span class="hljs-number"><span class="hljs-number">0</span></span>, dwNumBytesRead = <span class="hljs-number"><span class="hljs-number">0</span></span>; byOutputBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0x8A</span></span>; ftStatus = FT_Write(ftHandle, byOutputBuffer, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;dwNumBytesSent); Sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, byInputBuffer, dwNumBytesToRead, &amp;dwNumBytesRead); if (ftStatus != FT_OK) { printf("Error\r\n"); return FT_OTHER_ERROR; } else if (dwNumBytesToRead &gt; 0) { printf("dwNumBytesToRead = %d:", dwNumBytesToRead); for ( int i = 0; i &lt; dwNumBytesToRead; i++) printf (" %02Xh", byInputBuffer[i]); printf("\r\n"); return FT_INVALID_PARAMETER; } return FT_OK;</span></span></code> </pre> </div></div><br><p>  Als Experiment senden wir anstelle des eigentlichen Befehls 0x8A den Wert 0xFE, der keinem Op-Code entspricht, die Konsolenausgabe: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">dwNumBytesToRead</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>: FAh FEh</code> </pre> <br><p>  Der Prozessor hat zwei Bytes zur√ºckgegeben, das fehlerhafte Befehlsbyte ist 0xFA und der Wert dieses fehlerhaften Befehls.  Indem wir mehrere Befehle gleichzeitig senden, k√∂nnen wir nicht nur die Tatsache des Fehlers selbst verfolgen, sondern auch verstehen, in welchem ‚Äã‚ÄãTeam dieser Fehler aufgetreten ist. <br>  Um in Zukunft nicht mit "magischen Zahlen" umzugehen, werden wir alle Op-Codes in Form von Konstanten formatieren und in einer separaten Header-Datei ablegen. <br>  Um den Modus vollst√§ndig zu konfigurieren, m√ºssen Sie die Richtung der E / A-Leitungen und ihren Standardwert angeben.  Wenden wir uns dem Anschlussplan zu.  Um einen bereits aufgebl√§hten Artikel nicht zu √ºberladen, habe ich ein interessantes Fragment des Schemas gezeichnet: </p><br><img width="500" src="https://habrastorage.org/webt/sc/6g/no/sc6gnoqy5_eyc5lsjpmlqbnl2-m.png"><br><p>  Die <em>Zeilen DCLK</em> , <em>DATA [0]</em> , <em>nCONFIG</em> m√ºssen als Ausg√§nge konfiguriert sein, die <em>Zeilen</em> <em>nSTATUS</em> , <em>CONF_DONE</em> als Eing√§nge.  Anhand des Diagramms bestimmen wir, welche Anfangszust√§nde die Linien haben sollen.  Aus Gr√ºnden der √úbersichtlichkeit ist die Pinbelegung der Schaltung in der Tabelle zusammengefasst: </p><br><table><thead><tr><th>  FPGA-Pin </th><th>  Pin Name </th><th>  Pin </th><th>  MPSSE </th><th>  Richtung </th><th>  Standard </th></tr></thead><tbody><tr><td>  DCLK </td><td>  BDBUS0 </td><td>  38 </td><td>  TCK / SK </td><td>  Raus </td><td>  0 </td></tr><tr><td>  DATEN [0] </td><td>  BDBUS1 </td><td>  39 </td><td>  TDI / DO </td><td>  Raus </td><td>  1 </td></tr><tr><td>  nKONFIG </td><td>  BDBUS2 </td><td>  40 </td><td>  TDO / DI </td><td>  Raus </td><td>  1 </td></tr><tr><td>  nSTATUS </td><td>  BDBUS3 </td><td>  41 </td><td>  TMS / CS </td><td>  In </td><td>  1 </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td>  In </td><td>  1 </td></tr></tbody></table><br><p>  Alle verwendeten Leitungen befinden sich im Low-Byte des MPSSE-Ports.  Verwenden Sie den Op-Code 0x80, um den Wert festzulegen.  Dieser Befehl setzt zwei Argumente voraus: Das erste Byte nach dem Operationscode ist der bitweise Wert und das zweite die Richtung (eins ist der Ausgangsport, Null ist der Eingangsport). <br>  Im Rahmen des Kampfes gegen die "magische Zahl" werden alle Seriennummern und ihre Standardwerte als Konstanten formatiert: </p><br><div class="spoiler">  <b class="spoiler_title">Ports definieren</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_DIRECTION (0x07) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DCLK (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DATA0 (1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_CONFIG (2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_STATUS (3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONF_DONE (4) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// initial states of the MPSSE interface #define DCLK_DEF (1) #define DATA0_DEF (0) #define N_CONFIG_DEF (1) #define N_STATUS_DEF (1) #define CONF_DONE_DEF (1)</span></span></span></span></code> </pre> </div></div><br><p>  Es muss nur noch sichergestellt werden, dass die TDI-TDO-Schleife deaktiviert ist (kann zum Testen aktiviert werden) und in eine separate Funktion gestellt werden: </p><br><div class="spoiler">  <b class="spoiler_title">Auflisten der MPSSE_setup-Funktion</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_setup</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent, dwNumBytesToRead, dwNumBytesRead; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], byInputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; FT_STATUS ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Multple commands can be sent to the MPSSE with one FT_Write dwNumBytesToSend = 0; // Start with a fresh index byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_DIVIDER_5; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_ADAPTIVE_CLK; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_3PHASE_CLOCKING; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); dwNumBytesToSend = 0; // Reset output buffer pointer // Set TCK frequency // Command to set clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_TCK_DIVISION; // Set ValueL of clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_DATA_SPEED_DIV_L(DATA_SPEED); // Set 0xValueH of clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_DATA_SPEED_DIV_H(DATA_SPEED); ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); dwNumBytesToSend = 0; // Reset output buffer pointer // Set initial states of the MPSSE interface // - low byte, both pin directions and output values /* | FPGA pin | Pin Name | Pin | MPSSE | Dir | def | | --------- | -------- | --- | ------ | --- | --- | | DCLK | BDBUS0 | 38 | TCK/SK | Out | 0 | | DATA[0] | BDBUS1 | 39 | TDI/DO | Out | 1 | | nCONFIG | BDBUS2 | 40 | TDO/DI | Out | 1 | | nSTATUS | BDBUS3 | 41 | TMS/CS | In | 1 | | CONF_DONE | BDBUS4 | 43 | GPIOL0 | In | 1 | */ // Configure data bits low-byte of MPSSE port: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_LOWBYTE; // Initial state config above: byOutputBuffer[dwNumBytesToSend++] = (DCLK_DEF &lt;&lt; DCLK) | (DATA0_DEF &lt;&lt; DATA0) | (N_CONFIG_DEF &lt;&lt; N_CONFIG) | (N_STATUS_DEF &lt;&lt; N_STATUS) | (CONF_DONE_DEF &lt;&lt; CONF_DONE); // Direction config above: byOutputBuffer[dwNumBytesToSend++] = PORT_DIRECTION; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); // Send off the low GPIO config commands dwNumBytesToSend = 0; // Reset output buffer pointer // Set initial states of the MPSSE interface // - high byte, all input, Initial State -- 0. // Send off the high GPIO config commands: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_HIGHBYTE; byOutputBuffer[dwNumBytesToSend++] = 0x00; byOutputBuffer[dwNumBytesToSend++] = 0x00; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); // Disable loopback: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_LOOP_TDI_TDO; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); Sleep(2); // Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, byInputBuffer, dwNumBytesToRead, &amp;dwNumBytesRead); if (ftStatus != FT_OK) { printf("Unknown error in initializing the MPSSE\r\n"); return FT_OTHER_ERROR; } else if (dwNumBytesToRead &gt; 0) { printf("Error in initializing the MPSSE, bad code:\r\n"); for ( int i = 0; i &lt; dwNumBytesToRead; i++) printf (" %02Xh", byInputBuffer[i]); printf("\r\n"); return FT_INVALID_PARAMETER; } return FT_OK; }</span></span></code> </pre> </div></div><br><h3 id="punkt-4-realizuem-protokol-zagruzki">  Punkt 4. Wir implementieren das Ladeprotokoll </h3><br><p>  Alles scheint bereit f√ºr praktische Experimente.  √úberpr√ºfen Sie zun√§chst, ob die Initialisierung korrekt durchgef√ºhrt wurde. Rufen <code>MPSSE_open()</code> im Hauptteil des Programms <code>MPSSE_open()</code> und <code>MPSSE_setup()</code> . Bevor Sie das Ger√§t schlie√üen ( <code>FT_Close</code> ), setzen Sie ein leeres <code>getchar()</code> .  F√ºhren Sie das Programm aus und verwenden Sie das Oszilloskop, um sicherzustellen, dass alle PS-Leitungen auf die Standardpegel eingestellt sind.  Wenn Sie den Wert dieser Ebenen bei der Initialisierung √§ndern (mit dem FPGA passiert nichts Schlimmes), stellen wir sicher, dass der MPSSE-Prozessor das gew√ºnschte Ergebnis als g√ºltig ausgibt - alles funktioniert ordnungsgem√§√ü und Sie k√∂nnen mit der Daten√ºbertragung fortfahren. <br>  Das sequentielle Senden und Empfangen von Daten erfolgt im Befehlsmodus mit demselben Operationscode.  Das erste Byte des Befehls ist ein Op-Code, der die Art der Operation bestimmt, gefolgt von der L√§nge der gesendeten oder empfangenen Sequenz und, falls es sich um eine √úbertragung handelt, den tats√§chlichen Daten.  Der MPSSE-Prozessor kann Daten senden und empfangen, auch gleichzeitig.  Die √úbertragung kann entweder das niedrigstwertige Bit Forward (LSB) oder das h√∂chstwertige (MSB) sein.  Die Daten√ºbertragung kann entweder an der Vorder- oder der Hinterflanke von Taktimpulsen erfolgen.  Jede Kombination von Optionen hat ihren eigenen Op-Code, jedes Op-Code-Bit beschreibt den Betriebsmodus: </p><br><table><thead><tr><th>  Bit </th><th>  Funktion </th></tr></thead><tbody><tr><td>  0 </td><td>  Front-Write-Synchronisation: 0 - positiv, 1 - negativ </td></tr><tr><td>  1 </td><td>  1 - Arbeit mit Bytes, 0 - Arbeit mit Bits </td></tr><tr><td>  2 </td><td>  Vorderkante zum Lesen: 0 - positiv, 1 - negativ </td></tr><tr><td>  3 </td><td>  √úbertragungsmodus: 1 - LSB, 0 - MSB zuerst </td></tr><tr><td>  4 </td><td>  TDI-Daten√ºbertragung </td></tr><tr><td>  5 </td><td>  Lesen von Daten von einer TDO-Leitung </td></tr><tr><td>  6 </td><td>  TMS-Daten√ºbertragung </td></tr><tr><td>  7 </td><td>  Muss 0 sein, sonst ist dies eine andere Gruppe von Befehlen </td></tr></tbody></table><br><p>  Bei der Konfiguration von FPGAs gem√§√ü dem PS-Schema werden Daten im LSB-Modus an der Vorderkante √ºbertragen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist f√ºr uns bequemer, mit Bytes anstatt mit Bits zu arbeiten. In diesem Fall nimmt der Op-Code den Wert 0001_1000b oder 0x18 in hexadezimaler Darstellung an. </font><font style="vertical-align: inherit;">Die Argumente des Befehls sind die L√§nge der √ºbertragenen Sequenz (zwei Bytes, beginnend mit der niedrigstwertigen) und die Datensequenz selbst. </font><font style="vertical-align: inherit;">Ein kleines Merkmal sollte ber√ºcksichtigt werden: Die L√§nge wird minus eins codiert. </font><font style="vertical-align: inherit;">Das hei√üt, wenn wir ein Byte senden m√∂chten, dann ist die L√§nge 0, wenn wir 65536 senden m√∂chten, m√ºssen wir die L√§nge von 65535 angeben. Ich denke, es ist klar, warum dies getan wird. </font><font style="vertical-align: inherit;">Senden wir den Datenblock als Funktion aus </font></font><code>MPSSE_send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></p><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auflisten der MPSSE_send-Funktion</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> BYTE byBuffer[<span class="hljs-number"><span class="hljs-number">65536</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE * buff, DWORD dwBytesToWrite)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend = <span class="hljs-number"><span class="hljs-number">0</span></span>, dwNumBytesSent, bytes; FT_STATUS ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Output on rising clock, no input // MSB first, clock a number of bytes out byBuffer[dwNumBytesToSend++] = MPSSE_CMD_LSB_DATA_OUT_BYTES_POS_EDGE; // 0x18 bytes = dwBytesToWrite -1; byBuffer[dwNumBytesToSend++] = (bytes) &amp; 0xFF; // Length L byBuffer[dwNumBytesToSend++] = (bytes &gt;&gt; 8) &amp; 0xFF; // Length H memcpy(&amp;byBuffer[dwNumBytesToSend], buff, dwBytesToWrite); dwNumBytesToSend += dwBytesToWrite; ftStatus = FT_Write(ftHandle, byBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); if (ftStatus != FT_OK ) { printf ("ERROR send data\r\n"); return ftStatus; } else if (dwNumBytesSent != dwNumBytesToSend) { printf ("ERROR send data, %d %d\r\n", dwNumBytesSent, dwNumBytesToSend); } return FT_OK; }</span></span></code> </pre> </div></div><br><p>        ‚Äî      65 ,   - ,        op-code   .   <code>byBuffer</code> ,             <code>buff</code> ,  ,      op-code  .    ,     ,         . <br>    ,        ""  ,       25 , ,  ,     1  ( ,     <code>#define DATA_SPEED 1000000ul</code> ).   : </p><br><pre> <code class="hljs objectivec">BYTE byOutputBuffer[] = {<span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x1B</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">MPSSE_send</span></span>(byOutputBuffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(byOutputBuffer));</code> </pre> <br><p>    ( ): <br> <a href=""><img src="https://habrastorage.org/webt/bp/gp/es/bpgpesvsoradzqfecft07bdjk-u.png"></a> </p><br><p>   ‚Äî    <em>DATA[0]</em> ,   ‚Äî <em>DCLK</em> .             .  ,  ,   . </p><br><p>      ,     SPI  ( ).  ,     PS,     .   <em>nCONFIG</em> , <em>nSTATUS</em> , <em>CONF_DONE</em> .   ‚Äî  ,      ,   ‚Äî ,     . </p><br><p>  <code>MPSSE_get_lbyte</code>    ,  ,         . </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_get_lbyte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_get_lbyte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE *lbyte)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent, dwNumBytesToRead, dwNumBytesRead; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; FT_STATUS ftStatus; dwNumBytesToSend = <span class="hljs-number"><span class="hljs-number">0</span></span>; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_GET_DATA_BITS_LOWBYTE; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); Sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, lbyte, dwNumBytesToRead, &amp;dwNumBytesRead); if ((ftStatus != FT_OK) &amp; (dwNumBytesToRead != 1)) { printf("Error read Lbyte\r\n"); return FT_OTHER_ERROR; // Exit with error } return FT_OK; }</span></span></code> </pre> </div></div><br><p>  ,  op-code  ,         . ,     -     ,    ,          .    ,   .     <code>MPSSE_set_lbyte</code> : </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_set_lbyte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_set_lbyte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE lb, BYTE mask)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], lbyte; FT_STATUS ftStatus; ftStatus = MPSSE_get_lbyte(&amp;lbyte); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ftStatus != FT_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Set to zero the bits selected by the mask: lbyte &amp;= ~mask; // Setting zero is not selected by the mask bits: lb &amp;= mask; lbyte |= lb; dwNumBytesToSend = 0; // Set data bits low-byte of MPSSE port: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_LOWBYTE; byOutputBuffer[dwNumBytesToSend++] = lbyte; byOutputBuffer[dwNumBytesToSend++] = PORT_DIRECTION; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); if ((ftStatus != FT_OK) &amp; (dwNumBytesSent != 1)) { printf("Error set Lbyte\r\n"); return FT_OTHER_ERROR; } return FT_OK; }</span></span></code> </pre> </div></div><br><p>   ,     .   :  FTDI;    MPSSE;  rbf-  ,    <em>nCONFIG</em>  ,      <em>N_STATUS</em> ;    rbf-    ;  ,    ,      <em>CONF_DONE</em> .     ,     MPSSE   FTDI       .   ,  <em>nCONFIG</em>      ""  ,     ,        ,     . </p><br><div class="spoiler"> <b class="spoiler_title">  main</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ FT_STATUS ftStatus; BYTE lowByte; DWORD numDevs; <span class="hljs-comment"><span class="hljs-comment">// create the device information list if ( argv[1] == NULL) { printf ("NO file\r\n"); return -1; } frbf = fopen(argv[1],"rb"); if (frbf == NULL) { printf ("Error open rbf\r\n"); return -1; } ftStatus = FT_CreateDeviceInfoList(&amp;numDevs); if ((numDevs == 0) || (ftStatus != FT_OK)) { printf("Error. FTDI devices not found in the system\r\n"); return -1; } ftStatus = MPSSE_open ("LESO7 B"); if (ftStatus != FT_OK) { printf("Error in MPSSE_open %d\n", ftStatus); EXIT(-1); } MPSSE_setup(); if (ftStatus != FT_OK) { printf("Error in MPSSE_setup %d\n", ftStatus); EXIT(-1); } printf ("nConfig -&gt; 0\r\n"); MPSSE_set_lbyte(0, 1 &lt;&lt; N_CONFIG); printf ("nConfig -&gt; 1\r\n"); MPSSE_set_lbyte(1 &lt;&lt; N_CONFIG, 1 &lt;&lt; N_CONFIG); if (MPSSE_get_lbyte(&amp;lowByte) != FT_OK) { EXIT(-1); } if (((lowByte &gt;&gt; N_STATUS) &amp; 1) == 0) { printf("Error. FPGA is not responding\r\n"); EXIT(-1); } int i = 0; size_t readBytes = 0; // Send the configuration file: do { readBytes = fread(buff, 1, MPSSE_PCK_SEND_SIZE, frbf); if (MPSSE_send(buff, readBytes) != FT_OK) EXIT(-1); putchar('*'); if (!((++i)%16)) printf("\r\n"); } while (readBytes == MPSSE_PCK_SEND_SIZE); printf("\r\n"); memset(buff, 0x00, sizeof(buff)); MPSSE_send(buff, 1); //        ? printf("Load complete\r\n"); // wait CONF_DONE set // A low-to-high transition on the CONF_DONE pin indicates that the configuration is // complete and initialization of the device can begin. i = 0; do { if (MPSSE_get_lbyte(&amp;lowByte) != FT_OK) { printf ("Error read CONF_DONE\r\n"); EXIT(-1); } if (i++ &gt; TIMEOUT_CONF_DONE) { printf ("Error CONF_DONE\r\n"); EXIT(-1); } Sleep(2); } while (((lowByte &gt;&gt; CONF_DONE) &amp; 1) == 0); printf("Configuration complete\r\n"); FT_Close(ftHandle); fclose(frbf); }</span></span></code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beispiel f√ºr das Starten eines Programms: </font></font></p><br><pre> <code class="hljs pgsql">pen "LESO7 B" OK nConfig -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> nConfig -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ** <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> complete <span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span> complete</code> </pre> </div></div><br><p>    rbf-  .    .       30 /     . <br>      ,        -  JTAG. </p><br><h3 id="materialy-po-teme">  Verwandte Materialien </h3><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FTDI-MPSSE-Altera PS</a> .   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a> .   .       . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Software Application Development D2XX Programmer's Guide</a> .        FTDI.   API D2XX. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FTDI MPSSE Basics. Application Note AN_135</a> .    .  FTDI MPSSE.      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Command Processor for MPSSE and MCU Host Bus Emulation Modes. Application Note AN_108</a> .   op-code.   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">D2XX Drivers</a> .  FTDI. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426131/">https://habr.com/ru/post/de426131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426117/index.html">Der B√ºrgerbeauftragte schl√§gt vor, Anzeigen mit potenziell gef√§hrlichen Babyprodukten zu blockieren</a></li>
<li><a href="../de426119/index.html">Altert√ºmer: Cryptonomicon Iron</a></li>
<li><a href="../de426121/index.html">MC.exe (Nachrichten-Compiler), rc.exe, link.exe zum Generieren einer DLL f√ºr EventMessageFile</a></li>
<li><a href="../de426123/index.html">Lerne OpenGL. Lektion 6.1. PBR oder physikalisch korrektes Rendern. Theorie</a></li>
<li><a href="../de426125/index.html">Karriere Steroide. Aufz√ºge</a></li>
<li><a href="../de426133/index.html">Einf√ºhrung in die Alpha-Version von Volume Snapshots in Kubernetes</a></li>
<li><a href="../de426135/index.html">Private Cloud f√ºr das Internet der Dinge</a></li>
<li><a href="../de426137/index.html">Zeitalter der Ehrlichkeit</a></li>
<li><a href="../de426141/index.html">Red Hat ersetzt Docker durch Podman</a></li>
<li><a href="../de426143/index.html">3D-Animation - Video oder interaktiv?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>