<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòã ü§¶üèΩ üëÉüèø Beste HTTP / 2-Priorisierung f√ºr die Webbeschleunigung üë®üèª‚Äç‚öñÔ∏è üçë üë®‚Äçüë©‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="HTTP / 2 versprach, das Web erheblich zu beschleunigen, und Cloudflare stellte vor langer Zeit den HTTP / 2-Zugriff f√ºr alle Clients bereit. Ein Merkm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beste HTTP / 2-Priorisierung f√ºr die Webbeschleunigung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452020/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57d/5cf/dbe/57d5cfdbe917c7b464a249fb187b3ffd.png"></div><br>  HTTP / 2 versprach, das Web erheblich zu beschleunigen, und Cloudflare stellte vor langer Zeit den HTTP / 2-Zugriff f√ºr alle Clients bereit.  Ein Merkmal von HTTP / 2, die Priorisierung, entsprach jedoch nicht den Erwartungen.  Nicht weil es grundlegend kaputt ist, sondern wegen der Implementierung in Browsern. <br><br>  Heute schl√§gt Cloudflare vor, die Priorisierung von HTTP / 2 zu √§ndern, um unseren Servern die Kontrolle √ºber Priorisierungsentscheidungen zu geben, die das Internet wirklich beschleunigen. <br><br>  In der Vergangenheit war es der Browser, der kontrollierte, wie und wann Webinhalte heruntergeladen werden sollten.  Heute nehmen wir f√ºr alle bezahlten Pl√§ne radikale √Ñnderungen an diesem Modell vor.  Sie √ºbertragen die Kontrolle direkt an den Websitebesitzer.  Auf der Registerkarte "Geschwindigkeit" im Cloudflare-Dashboard k√∂nnen Clients die "Erweiterte HTTP / 2-Priorisierung" aktivieren: Sie √ºberschreibt die Standardbrowsereinstellungen f√ºr ein verbessertes Planungsschema, das den Zugriff f√ºr Besucher erheblich beschleunigt (in einigen F√§llen konnten wir eine Steigerung von 50% feststellen).  Mit Cloudflare-Mitarbeitern k√∂nnen Websitebesitzer noch weiter gehen und die Einstellungen vollst√§ndig an ihre spezifischen Anforderungen anpassen. <br><a name="habracut"></a><br><h1>  Aktuelle Situation </h1><br>  Webseiten bestehen aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://discuss.">Dutzenden (manchmal Hunderten)</a> einzelner Ressourcen, die vom Browser heruntergeladen und f√ºr den endg√ºltig angezeigten Inhalt gesammelt werden.  Dies umfasst den sichtbaren Inhalt, mit dem der Benutzer interagiert (HTML, CSS, Bilder), sowie die Anwendungslogik (JavaScript) f√ºr die Website selbst, Werbe-, Analyse- und Marketing-Tracking-Beacons.  Aus Sicht des Benutzers ist die Reihenfolge, in der diese Ressourcen geladen werden, sehr wichtig: Dies wirkt sich auf die Zeit aus, zu der er den Inhalt sieht und mit der Seite interagieren kann. <br><br>  Ein Browser ist in der Tat eine HTML-Verarbeitungs-Engine, die ein HTML-Dokument durchl√§uft und die Anweisungen der Reihe nach befolgt: Von Anfang bis Ende HTML, Erstellen der Seite w√§hrend des Verschiebens.  Stylesheet-Links (CSS) teilen dem Browser mit, wie der Inhalt der Seite gestaltet werden soll, und der Browser verz√∂gert die Anzeige des Inhalts, bis das Stylesheet geladen wird.  Skripte auf der Seite k√∂nnen sich unterschiedlich verhalten.  Wenn das Skript als "asynchron" oder "ausstehend" markiert ist, kann der Browser das Dokument weiter verarbeiten und das Skript einfach ausf√ºhren, sobald es verf√ºgbar ist.  Wenn das Skript nicht als asynchron oder verz√∂gert markiert ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MUSS</a> der Browser die Verarbeitung des Dokuments beenden, bis das Skript geladen und ausgef√ºhrt wird.  Solche Skripte werden als "Blockieren" bezeichnet, da sie den Browser daran hindern, das Dokument weiter zu verarbeiten. <br><br>  Das HTML-Dokument ist in zwei Teile unterteilt.  Der Titel des &lt;head&gt; -Dokuments steht am Anfang und enth√§lt Stylesheets, Skripte und andere Browseranweisungen, die zum Anzeigen des Inhalts erforderlich sind.  Nachdem die √úberschrift der Hauptteil des Dokuments &lt;body&gt; ist, enth√§lt sie den tats√§chlichen Inhalt, der im Browserfenster angezeigt wird (obwohl sich auch Skripte und Stylesheets im Hauptteil befinden k√∂nnen).  Bis der Browser den Dokumententext erreicht, hat der Benutzer nichts anzuzeigen und die Seite bleibt leer.  Daher ist es wichtig, den Header so schnell wie m√∂glich zu verarbeiten.  Wenn Sie an Details interessiert sind, finden Sie auf der <i>HTML5 Rocks-</i> Website ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gro√üartiges Tutorial</a> zur Funktionsweise von Browsern. <br><br>  Der Browser ist normalerweise f√ºr die Reihenfolge verantwortlich, in der die verschiedenen Ressourcen geladen werden, die zum Erstellen der Seite und zum weiteren Verarbeiten des Dokuments erforderlich sind.  In HTTP / 1.x gibt es Einschr√§nkungen, wie viele Objekte der Browser gleichzeitig von einem Server anfordern kann (normalerweise 6 Verbindungen und jeweils nur eine Ressource pro Verbindung), sodass die Reihenfolge der Anforderungen vom Browser streng kontrolliert wird.  In HTTP / 2 ist die Situation v√∂llig anders.  Der Browser kann alle Ressourcen gleichzeitig anfordern (zumindest sobald er davon erf√§hrt) und stellt dem Server detaillierte Anweisungen zur Bereitstellung dieser Ressourcen zur Verf√ºgung. <br><br><h1>  Optimale Reihenfolge beim Laden von Ressourcen </h1><br>  In den meisten F√§llen gibt es eine optimale Reihenfolge im Seitenladezyklus, die die Verf√ºgbarkeit der Seite f√ºr den Benutzer maximiert (und der Unterschied zwischen der optimalen und der nicht optimalen Ladereihenfolge kann 50% oder mehr erreichen). <br><br>  Wie oben beschrieben, wird der Browser, bevor er Inhalte anzeigen kann, durch CSS und JavaScript im Abschnitt <code>&lt;head&gt;</code> blockiert.  In dieser Phase ist es rentabler, 100% des Kanals zum Laden blockierender Ressourcen zu verwenden, als sie in der Reihenfolge zu laden, wie sie im HTML-Code geschrieben sind.  Auf diese Weise kann der Browser jedes Element analysieren und ausf√ºhren, w√§hrend die n√§chste blockierende Ressource geladen wird, wodurch eine optimale Pipeline erstellt wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db9/e18/fbe/db9e18fbe00d27755a152a8deabbcaa4.png"><br><br>  Die Ladezeit des Skripts f√ºr das parallele oder sequentielle Laden unterscheidet sich nicht, aber f√ºr das sequentielle Laden kann das erste Skript w√§hrend des zweiten Ladens verarbeitet und ausgef√ºhrt werden. <br><br>  Nach dem Laden blockierender Ressourcen wird die Situation etwas interessanter.  Hier kann die optimale Auslastung von einer bestimmten Website oder sogar von Gesch√§ftspriorit√§ten abh√§ngen (Auswahl von benutzergenerierten Inhalten oder Werbung oder Analysen usw.).  Ein separates Problem mit Schriftarten, da der Browser die gew√ºnschten Schriftarten erkennt, nachdem er das Stylesheet auf den angezeigten Inhalt angewendet hat.  Wenn der Browser von der Schriftart erf√§hrt, muss daher Text angezeigt werden, der bereits f√ºr die Anzeige auf dem Bildschirm bereit ist.  Verz√∂gerungen beim Laden der Schrift f√ºhren dazu, dass kein Text auf dem Bildschirm angezeigt wird (oder der Text in der falschen Schrift angezeigt wird). <br><br>  In der Regel m√ºssen einige Kompromisse ber√ºcksichtigt werden: <br><br><ul><li>  Benutzerdefinierte Schriftarten und Bilder im sichtbaren Teil der Seite (Ansichtsfenster) sollten so schnell wie m√∂glich geladen werden.  Sie wirken sich direkt auf die visuelle Erfahrung des Benutzers beim Laden der Seite aus. <br></li><li>  Nicht blockierendes JavaScript sollte in Bezug auf andere JavaScript-Ressourcen nacheinander geladen werden, damit jede von ihnen per Pipeline weitergeleitet werden kann.  JavaScript kann benutzerdefinierte Anwendungslogik sowie Tracking-Beacons f√ºr Analyse und Marketing enthalten, und ihre Verz√∂gerung kann zu einer Verringerung der vom Unternehmen verfolgten Indikatoren f√ºhren. <br></li><li>  Bilder k√∂nnen parallel hochgeladen werden.  Die ersten paar Bytes der Bilddatei enthalten ihre Gr√∂√üe, die f√ºr das Browserlayout erforderlich sein kann, und das parallele Laden progressiver Bilder kann nach der √úbertragung von etwa 50% des Gesamtvolumens die visuelle Vollst√§ndigkeit gew√§hrleisten. </li></ul><br>  In Anbetracht der Kompromisse funktioniert diese Strategie in den meisten F√§llen gut: <br><br><ul><li>  Benutzerdefinierte Schriftarten werden nacheinander heruntergeladen und teilen die verf√ºgbare Bandbreite mit Bildern im Umfang. <br></li><li>  Sichtbare Bilder werden parallel geladen und teilen sich den Teil der ihnen zugewiesenen Bandbreite. <br></li><li>  Wenn keine Schriftarten oder sichtbaren Bilder mehr vorhanden sind: <br><ul><li>  Nicht blockierende Skripte werden nacheinander geladen und teilen die verf√ºgbare Bandbreite mit unsichtbaren Bildern (die au√üerhalb des G√ºltigkeitsbereichs liegen). <br></li><li>  Unsichtbare Bilder werden parallel geladen und teilen sich den Teil der ihnen zugewiesenen Bandbreite. </li></ul></li></ul><br>  So wird der f√ºr den Benutzer sichtbare Inhalt so schnell wie m√∂glich geladen, die Anwendungslogik auf ein Minimum verz√∂gert und unsichtbare Bilder so geladen, dass das Layout so schnell wie m√∂glich fertiggestellt wird. <br><br><h1>  Beispiel </h1><br>  Verwenden Sie zur Veranschaulichung eine vereinfachte Produktkategorieseite einer typischen E-Commerce-Website: <br><br><ul><li>  <b>Blau</b> - HTML-Datei der Seite selbst. <br></li><li>  <b>Gr√ºn</b> - Ein externes Stylesheet (CSS-Datei). <br></li><li>  <b>Orange</b> - Vier externe Skripte (JavaScript).  Zwei blockierende Skripte oben auf der Seite und zwei asynchrone.  Blockierende Skripte werden in einem dunkleren Orangeton angezeigt. <br></li><li>  <b>Rot</b> ist eine benutzerdefinierte Webschrift. <br></li><li>  <b>Violett</b> - 13 Bilder.  Das Seitenlogo und vier Produktbilder werden im Anzeigefenster angezeigt. Weitere 8 Produktbilder m√ºssen gescrollt werden.  Die f√ºnf sichtbaren Bilder werden durch einen dunkleren Purpur angezeigt. </li></ul><br>  Nehmen wir zur Vereinfachung an, dass alle Ressourcen dieselbe Gr√∂√üe und jede Last in 1 Sekunde haben.  Das Herunterladen aller Ressourcen dauert insgesamt 20 Sekunden, aber die Reihenfolge und Methode des Ladens sind √§u√üerst wichtig. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fbd/07b/58a/fbd07b58a4c8aeff2a758ad1946d8523.png"><br><br>  So sieht das optimale Laden von Ressourcen in einem Browser aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b2/6a8/2cd/8b26a82cdb5c546e9005200e5528b988.gif"><br><br><ul><li>  Die Seite ist in den ersten 4 Sekunden beim Laden von HTML, CSS und Blockieren von Skripten leer: Alle verwenden eine 100% ige Verbindung. <br></li><li>  Bei der 4-Sekunden-Marke werden der Hintergrund und die Seitenstruktur ohne Text oder Bilder angezeigt. <br></li><li>  Nach einer Sekunde, nach ungef√§hr 5 Sekunden, wird der Seitentext angezeigt. <br></li><li>  Im Intervall von 5-10 Sekunden werden Bilder heruntergeladen, zun√§chst verschwommen, aber sehr schnell werden sie klar.  Nach etwa 7 Sekunden ist das Ergebnis von der endg√ºltigen Version kaum zu unterscheiden. <br></li><li>  Nach ca. 10 Sekunden ist das Laden aller visuellen Inhalte im sichtbaren Teil der Seite abgeschlossen. <br></li><li>  In den n√§chsten zwei Sekunden wird asynchrones JavaScript geladen und ausgef√ºhrt, wobei unkritische Logik (Analysen, Marketing-Tags usw.) ausgef√ºhrt wird. <br></li><li>  W√§hrend der letzten 8 Sekunden werden die verbleibenden Bilder geladen, falls der Benutzer die Seite scrollt. </li></ul><br><h1>  Aktuelle Browser-Priorisierung </h1><br>  Alle aktuellen Browser-Engines implementieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://calendar.perfplanet.com/2018/">verschiedene Priorisierungsstrategien</a> , von denen keine optimal ist. <br><br>  <b>Microsoft Edge und Internet Explorer</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://calendar.perfplanet.com/2018/">unterst√ºtzen keine Priorisierung</a> , daher arbeiten sie mit den Standardeinstellungen f√ºr HTTP / 2, bei denen alles parallel geladen wird und die Bandbreite gleichm√§√üig auf alle Ressourcen verteilt wird.  Microsoft Edge wird in zuk√ºnftigen Versionen auf die Verwendung der Chromium-Engine umstellen, was die Situation verbessern kann.  In unserem Beispiel bleibt der Browser jedoch die meiste Zeit im Seitenkopf h√§ngen, da Bilder die √úbertragung blockierender Skripte und Stylesheets verlangsamen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e9c/844/a65/e9c844a65472a56d92cb37cd27f2f035.png"><br><br>  Optisch f√ºhrt dies zu einer ziemlich schmerzhaften Erfahrung: Der Benutzer schaut 19 Sekunden lang auf einen leeren Bildschirm, und dann gibt es eine Verz√∂gerung von 1 Sekunde, um den Text anzuzeigen.  Seien Sie geduldig, wenn Sie die folgende Animation anzeigen, denn 19 Sekunden lang scheint auf einem leeren Bildschirm nichts zu passieren (obwohl dies der Fall ist): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c9/fae/539/6c9fae539ae1d3c99570cf53af415be4.gif"><br><br>  <b>Safari</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://calendar.perfplanet.com/2018/">l√§dt alle Ressourcen parallel</a> und teilt laut Safari die Bandbreite entsprechend ihrer Wichtigkeit (das Blockieren von Ressourcen wie Skripten und Stylesheets ist wichtiger als Bilder).  Bilder werden parallel geladen, aber auch gleichzeitig mit blockierenden Inhalten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c75/a7d/f05/c75a7df05716f5706aa4b037774733d2.png"><br><br>  Obwohl Safari Edge in dem Sinne √§hnlich ist, dass alles gleichzeitig geladen wird, k√∂nnen Sie durch das Zuweisen von mehr Bandbreite zum Blockieren von Ressourcen Inhalte viel fr√ºher anzeigen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0c/840/5a1/f0c8405a1b6ddc40645ab7985e28a5eb.gif"><br><br><ul><li>  Nach ca. 8 Sekunden ist das Laden des Stylesheets und der Skripte abgeschlossen, sodass Sie mit dem Rendern der Seite beginnen k√∂nnen.  Da die Bilder parallel geladen wurden, k√∂nnen sie auch teilweise angezeigt werden (verschwommen f√ºr progressive Bilder).  Dies ist immer noch doppelt so langsam wie das optimale Szenario, aber viel besser als in Edge. <br></li><li>  Nach ca. 11 Sekunden wird die Schriftart geladen.  Sie k√∂nnen den Text anzeigen.  Zu diesem Zeitpunkt werden mehr Daten f√ºr die Bilder geladen und sie werden etwas sch√§rfer.  Dies ist vergleichbar mit der Situation um die 7-Sekunden-Marke f√ºr ein optimales Ladeszenario. <br></li><li>  In den verbleibenden 9 Sekunden werden die Bilder sch√§rfer, wenn mehr Daten heruntergeladen werden, bis der Vorgang in 20 Sekunden abgeschlossen ist. </li></ul><br>  <b>Firefox</b> erstellt einen Abh√§ngigkeitsbaum, der Ressourcen gruppiert, und plant dann, dass die Gruppen entweder nacheinander geladen werden oder die Bandbreite zwischen Gruppen gemeinsam nutzen.  Innerhalb dieser Gruppe teilen sich Ressourcen Bandbreite und laden gleichzeitig.  Es ist geplant, Bilder nach Stylesheets zu laden, die das Rendern blockieren und parallel laden. Skripte und Stylesheets, die das Rendern blockieren, werden jedoch auch parallel geladen und profitieren nicht vom Pipelining. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/870/e6d/83c/870e6d83c673b9c706dac49c78d3848d.png"><br><br>  In unserem Beispiel geschieht dies etwas schneller als in Safari, da die Bilder darauf warten, dass das Stylesheet geladen wird: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd2/806/b55/bd2806b55e830bd4c2a7e08bb1b18ce4.gif"><br><br><ul><li>  Nach ca. 6 Sekunden wird der urspr√ºngliche Seiteninhalt mit einem Hintergrund und verschwommenen Versionen der Produktbilder angezeigt (im Vergleich zu 8 Sekunden f√ºr Safari und 4 Sekunden im besten Fall). <br></li><li>  Nach 8 Sekunden wird die Schriftart geladen, und Sie k√∂nnen den Text zusammen mit etwas sch√§rferen Bildern des Produkts anzeigen (im Vergleich zu Safari im besten Fall 11 Sekunden und 7 Sekunden). <br></li><li>  W√§hrend der verbleibenden 12 Sekunden werden die Bilder sch√§rfer, wenn der verbleibende Inhalt geladen wird. </li></ul><br>  <b>Chrome</b> (und alle Chromium-basierten Browser) priorisieren das Inventar.  Dies funktioniert sehr gut, um Ressourcen zu blockieren, die optimal in der richtigen Reihenfolge geladen werden, aber nicht so gut f√ºr Bilder.  Jedes Bild wird zu 100% geladen, bevor das n√§chste gestartet wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e22/14d/4e0/e2214d4e04fab810f0a4398fe02434c1.png"><br><br>  In der Praxis ist dies ein nahezu optimales Download-Szenario. Der einzige Unterschied besteht darin, dass Bilder einzeln und nicht parallel heruntergeladen werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/91e/76c/d1d/91e76cd1d814aef138b35345eda46d82.gif"><br><br><ul><li>  Bis zu 5 Sekunden ist das Laden von Chrome identisch mit dem optimalen Szenario. Der Hintergrund wird in der 4. Sekunde und der Textinhalt in der 5. Sekunde angezeigt. <br></li><li>  In den n√§chsten 5 Sekunden werden die Bilder des Sichtbarkeitsbereichs einzeln geladen, bis der Vorgang nach etwa 10 Sekunden abgeschlossen ist (im Vergleich zum optimalen Szenario, wenn sie nach etwa 7 Sekunden in einer leicht verschwommenen Form angezeigt werden und f√ºr die verbleibenden drei Sekunden sch√§rfer werden). <br></li><li>  Nachdem der visuelle Teil der Seite in 10 Sekunden abgeschlossen ist (identisch mit dem optimalen Szenario), werden die verbleibenden 10 Sekunden f√ºr das Ausf√ºhren asynchroner Skripts und das Laden versteckter Bilder (sowie im optimalen Szenario) aufgewendet. </li></ul><br><h1>  Visueller Vergleich </h1><br>  Der visuelle Unterschied ist sehr unterschiedlich, obwohl das technische Laden des gesamten Inhalts dieselbe Zeit in Anspruch nimmt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/62e/2a1/d5f/62e2a1d5f10b801af61992517d7f5a5a.gif"><br><br><h1>  Serverseitige Priorisierung </h1><br>  Die HTTP / 2-Priorisierung wird vom Client (Browser) angefordert, und der Server muss basierend auf der Anforderung entscheiden, was zu tun ist.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/andydavies/">Eine gro√üe Anzahl von Servern unterst√ºtzt diese Funktion √ºberhaupt nicht</a> , und der Rest erf√ºllt eine Clientanforderung.  Eine andere M√∂glichkeit besteht darin, basierend auf der Clientanforderung die beste serverseitige Priorisierung festzulegen. <br><br>  Gem√§√ü der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://http2.github.io/">Spezifikation</a> ist die HTTP / 2-Priorisierung ein Abh√§ngigkeitsbaum, der die vollst√§ndige Kenntnis aller aktuellen Anforderungen erfordert, um Ressourcen relativ zueinander priorisieren zu k√∂nnen.  Auf diese Weise k√∂nnen Sie unglaublich komplexe Strategien implementieren, es ist jedoch schwierig, sie auf Browser- oder Serverseite gut zu implementieren (wie verschiedene Browserstrategien und unterschiedliche Ebenen der Serverunterst√ºtzung belegen).  Um die Verwaltung der Priorisierung zu vereinfachen, haben wir ein einfacheres Schema entwickelt, das dennoch √ºber die f√ºr eine optimale Planung erforderliche Flexibilit√§t verf√ºgt. <br><br>  Das Priorisierungsschema von Cloudflare besteht aus 64 Priorit√§tsstufen. Innerhalb jeder Stufe gibt es Gruppen von Ressourcen, die bestimmen, wie die Verbindung untereinander aufgeteilt werden soll: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba5/7e5/efa/ba57e5efa56119a58bbd39596da3f9ce.png"><br><br>  Zuerst werden alle Ressourcen mit einer h√∂heren Priorit√§t heruntergeladen, dann erfolgt ein √úbergang zu einer niedrigeren Ebene. <br><br>  Innerhalb einer bestimmten Priorit√§tsstufe gibt es drei verschiedene Parallelit√§tsgruppen: <br><br><ul><li>  <b>0</b> : Alle Ressourcen in Gruppe "0" werden nacheinander in der Reihenfolge gesendet, in der sie mit 100% Bandbreite angefordert wurden.  Erst nach dem Laden aller Ressourcen der Gruppe "0" werden andere Gruppen auf derselben Ebene ber√ºcksichtigt. <br></li><li>  <b>1</b> : Alle Ressourcen in der Parallelit√§tsgruppe "1" werden nacheinander in der Reihenfolge gesendet, in der sie angefordert wurden.  Die verf√ºgbare Bandbreite ist gleichm√§√üig zwischen der Parallelit√§tsgruppe "1" und der Parallelit√§tsgruppe "n" verteilt. <br></li><li>  <b>n</b> : Ressourcen in der Parallelit√§tsgruppe "n" werden parallel √ºbertragen und teilen sich die verf√ºgbare Bandbreite. </li></ul><br>  In der Praxis ist die Parallelit√§tsgruppe ‚Äû0‚Äú n√ºtzlich f√ºr kritische Inhalte, die nacheinander verarbeitet werden m√ºssen (Skripte, CSS usw.).  Die Gruppe ‚Äû1‚Äú ist n√ºtzlich f√ºr weniger wichtige Inhalte, die Bandbreite mit anderen Ressourcen teilen k√∂nnen, bei denen die Ressourcen selbst jedoch weiterhin von einer sequentiellen Verarbeitung profitieren (asynchrone Skripte, nicht progressive Bilder usw.).  Die Parallelit√§tsgruppe "n" ist n√ºtzlich f√ºr Ressourcen, die von der Parallelverarbeitung profitieren (progressive Bilder, Video, Audio usw.). <br><br><h1>  Standardpriorisierung von Cloudflare </h1><br>  Mit der Option der erweiterten Priorisierung wird die oben beschriebene ‚Äûoptimale‚Äú Reihenfolge des Ressourcenladens implementiert.  Die spezifischen Priorit√§ten lauten wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b89/e96/e4f/b89e96e4f4534f5df00d732e97b5db62.png"><br><br>  Mit diesem Schema k√∂nnen Sie nacheinander Ressourcen senden, die das Rendern blockieren, dann sichtbare Bilder parallel senden und dann den Rest des Seiteninhalts mit einer gewissen Bandbreitenteilung teilen, um das Laden der Anwendung und des Inhalts auszugleichen.  Die <i>Einschr√§nkung * Wenn erkennbar</i> ist, dass nicht alle Browser zwischen verschiedenen Arten von Stylesheets und Skripten unterscheiden, dies jedoch in allen F√§llen viel schneller ist.  Eine Beschleunigung von 50%, insbesondere f√ºr Edge- und Safari-Besucher, ist nichts Ungew√∂hnliches: <br><br> <a href=""><img src="https://habrastorage.org/webt/u_/1n/px/u_1npxrzhg0svmgdyzelnamxj84.png"></a> <br><br><h1>  Festlegen der Priorisierung mit Arbeitnehmern </h1><br>  Eine schnellere Standardarbeit ist gro√üartig, wird jedoch dank der M√∂glichkeit, die Priorisierung mit Cloudflare Workers-Unterst√ºtzung zu konfigurieren, sehr interessant, sodass Websites die Standardpriorit√§t f√ºr Ressourcen √ºberschreiben oder ihre eigenen Priorisierungsschemata implementieren k√∂nnen. <br><br>  Wenn der Worker der Antwort den Header <code>cf-priority</code> hinzuf√ºgt, wenden die Cloudflare-Edgeserver die angegebene Priorit√§t und Parallelit√§t an.  Das Header-Format lautet &lt;Priorit√§t&gt; / &lt;W√§hrung&gt;, daher der <code>response.headers.set('cf-priority', ‚Äú30/0‚Äù);</code>  setzt f√ºr diese Antwort die Priorit√§t 30 und die Parallelit√§t 0. In √§hnlicher Weise setzt "30/1" die Parallelit√§t auf "1" und "30 / n" die Parallelit√§t auf n. <br><br>  Mit dieser Flexibilit√§t kann ein Standort eine beliebige Priorit√§t der Ressourcen f√ºr seine Anforderungen festlegen.  Um beispielsweise die Priorit√§t einiger wichtiger asynchroner Skripte oder Hauptbilder zu erh√∂hen: Sie werden heruntergeladen, noch bevor der Browser feststellt, dass sie sich in Reichweite befinden. <br><br>  Um √ºber Priorisierungsentscheidungen zu informieren, gibt die Laufzeit der Worker auch die vom Browser bei der Priorisierung angeforderten Informationen im Anforderungsobjekt an, die an den Empf√§nger der Worker-Ereignisse √ºbergeben werden (request.cf.requestPriority).  Eingehende Priorit√§ten sind eine Liste von Attributen, die durch ein Semikolon getrennt sind.  Es sieht ungef√§hr so ‚Äã‚Äãaus: <code>weight=192;exclusive=0;group=3;group-weight=127</code> . <br><br><ul><li>  <b>Gewicht</b> : Gewicht zur Priorisierung von HTTP / 2. <br></li><li>  <b>exklusiv</b> : das exklusive HTTP / 2-Flag (1 f√ºr Chromium-basierte Browser, 0 f√ºr andere). <br></li><li>  <b>Gruppe</b> : HTTP / 2-Stream-ID f√ºr die Anforderungsgruppe (ungleich Null f√ºr Firefox). <br></li><li>  <b>Gruppengewicht</b> : HTTP / 2-Gewicht f√ºr die Gruppe von Anforderungen (ungleich Null f√ºr Firefox). </li></ul><br><h1>  Dies ist nur der Anfang. </h1><br>  Die F√§higkeit, die Priorit√§t von Antworten zu konfigurieren und zu steuern, ist der Hauptbaustein f√ºr eine gro√üartige zuk√ºnftige Arbeit.  Dar√ºber hinaus beabsichtigen wir, unsere eigenen erweiterten Optimierungen einzuf√ºhren. Mit Unterst√ºtzung der Mitarbeiter k√∂nnen jedoch alle Standorte und Forscher mit verschiedenen Priorisierungsstrategien experimentieren.  √úber den Apps Marketplace k√∂nnen Unternehmen auch neue Optimierungsservices √ºber der Arbeitsplattform erstellen und diese f√ºr andere Websites verf√ºgbar machen. <br><br>  Wenn Sie einen Pro-Plan oder h√∂her haben, wechseln Sie im Cloudflare-Dashboard zur Registerkarte "Geschwindigkeit" und aktivieren Sie die "erweiterte HTTP / 2-Priorisierung", um Ihre Site zu beschleunigen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/386/d53/276/386d532767b6396ee628a7e0eb837282.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452020/">https://habr.com/ru/post/de452020/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452004/index.html">Fand die Absturzstelle des Bereshit auf dem Mond</a></li>
<li><a href="../de452006/index.html">Epic Metaverse: Warum Fortnite-Autoren es bekommen sollten</a></li>
<li><a href="../de452008/index.html">Technische Ans√§tze und Checkliste: Wie man im Chaos der Aufgaben nicht verr√ºckt wird</a></li>
<li><a href="../de452010/index.html">Osmo Action: DJIs erste Actionkamera</a></li>
<li><a href="../de452016/index.html">12 Jahre in der Cloud</a></li>
<li><a href="../de452022/index.html">Google informiert Nutzer mit ihren Titan-Sicherheitsschl√ºsseln √ºber eine Sicherheitsanf√§lligkeit</a></li>
<li><a href="../de452026/index.html">Vor 20 Jahren hat Microsoft die Art und Weise, wie wir die Maus verwenden, f√ºr immer ver√§ndert</a></li>
<li><a href="../de452028/index.html">Lichtstrahl im dunklen K√∂nigreich: Wie Technologie verlorene Sicht zur√ºckgibt</a></li>
<li><a href="../de452030/index.html">Internet-Verlauf: Interaktivit√§t entdecken</a></li>
<li><a href="../de452034/index.html">Selbstkontrolle der Zeit f√ºr Selbstbildung und Zeit f√ºr das Lesen von B√ºchern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>