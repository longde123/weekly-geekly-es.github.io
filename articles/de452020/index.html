<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😋 🤦🏽 👃🏿 Beste HTTP / 2-Priorisierung für die Webbeschleunigung 👨🏻‍⚖️ 🍑 👨‍👩‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="HTTP / 2 versprach, das Web erheblich zu beschleunigen, und Cloudflare stellte vor langer Zeit den HTTP / 2-Zugriff für alle Clients bereit. Ein Merkm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beste HTTP / 2-Priorisierung für die Webbeschleunigung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452020/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57d/5cf/dbe/57d5cfdbe917c7b464a249fb187b3ffd.png"></div><br>  HTTP / 2 versprach, das Web erheblich zu beschleunigen, und Cloudflare stellte vor langer Zeit den HTTP / 2-Zugriff für alle Clients bereit.  Ein Merkmal von HTTP / 2, die Priorisierung, entsprach jedoch nicht den Erwartungen.  Nicht weil es grundlegend kaputt ist, sondern wegen der Implementierung in Browsern. <br><br>  Heute schlägt Cloudflare vor, die Priorisierung von HTTP / 2 zu ändern, um unseren Servern die Kontrolle über Priorisierungsentscheidungen zu geben, die das Internet wirklich beschleunigen. <br><br>  In der Vergangenheit war es der Browser, der kontrollierte, wie und wann Webinhalte heruntergeladen werden sollten.  Heute nehmen wir für alle bezahlten Pläne radikale Änderungen an diesem Modell vor.  Sie übertragen die Kontrolle direkt an den Websitebesitzer.  Auf der Registerkarte "Geschwindigkeit" im Cloudflare-Dashboard können Clients die "Erweiterte HTTP / 2-Priorisierung" aktivieren: Sie überschreibt die Standardbrowsereinstellungen für ein verbessertes Planungsschema, das den Zugriff für Besucher erheblich beschleunigt (in einigen Fällen konnten wir eine Steigerung von 50% feststellen).  Mit Cloudflare-Mitarbeitern können Websitebesitzer noch weiter gehen und die Einstellungen vollständig an ihre spezifischen Anforderungen anpassen. <br><a name="habracut"></a><br><h1>  Aktuelle Situation </h1><br>  Webseiten bestehen aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://discuss.">Dutzenden (manchmal Hunderten)</a> einzelner Ressourcen, die vom Browser heruntergeladen und für den endgültig angezeigten Inhalt gesammelt werden.  Dies umfasst den sichtbaren Inhalt, mit dem der Benutzer interagiert (HTML, CSS, Bilder), sowie die Anwendungslogik (JavaScript) für die Website selbst, Werbe-, Analyse- und Marketing-Tracking-Beacons.  Aus Sicht des Benutzers ist die Reihenfolge, in der diese Ressourcen geladen werden, sehr wichtig: Dies wirkt sich auf die Zeit aus, zu der er den Inhalt sieht und mit der Seite interagieren kann. <br><br>  Ein Browser ist in der Tat eine HTML-Verarbeitungs-Engine, die ein HTML-Dokument durchläuft und die Anweisungen der Reihe nach befolgt: Von Anfang bis Ende HTML, Erstellen der Seite während des Verschiebens.  Stylesheet-Links (CSS) teilen dem Browser mit, wie der Inhalt der Seite gestaltet werden soll, und der Browser verzögert die Anzeige des Inhalts, bis das Stylesheet geladen wird.  Skripte auf der Seite können sich unterschiedlich verhalten.  Wenn das Skript als "asynchron" oder "ausstehend" markiert ist, kann der Browser das Dokument weiter verarbeiten und das Skript einfach ausführen, sobald es verfügbar ist.  Wenn das Skript nicht als asynchron oder verzögert markiert ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MUSS</a> der Browser die Verarbeitung des Dokuments beenden, bis das Skript geladen und ausgeführt wird.  Solche Skripte werden als "Blockieren" bezeichnet, da sie den Browser daran hindern, das Dokument weiter zu verarbeiten. <br><br>  Das HTML-Dokument ist in zwei Teile unterteilt.  Der Titel des &lt;head&gt; -Dokuments steht am Anfang und enthält Stylesheets, Skripte und andere Browseranweisungen, die zum Anzeigen des Inhalts erforderlich sind.  Nachdem die Überschrift der Hauptteil des Dokuments &lt;body&gt; ist, enthält sie den tatsächlichen Inhalt, der im Browserfenster angezeigt wird (obwohl sich auch Skripte und Stylesheets im Hauptteil befinden können).  Bis der Browser den Dokumententext erreicht, hat der Benutzer nichts anzuzeigen und die Seite bleibt leer.  Daher ist es wichtig, den Header so schnell wie möglich zu verarbeiten.  Wenn Sie an Details interessiert sind, finden Sie auf der <i>HTML5 Rocks-</i> Website ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">großartiges Tutorial</a> zur Funktionsweise von Browsern. <br><br>  Der Browser ist normalerweise für die Reihenfolge verantwortlich, in der die verschiedenen Ressourcen geladen werden, die zum Erstellen der Seite und zum weiteren Verarbeiten des Dokuments erforderlich sind.  In HTTP / 1.x gibt es Einschränkungen, wie viele Objekte der Browser gleichzeitig von einem Server anfordern kann (normalerweise 6 Verbindungen und jeweils nur eine Ressource pro Verbindung), sodass die Reihenfolge der Anforderungen vom Browser streng kontrolliert wird.  In HTTP / 2 ist die Situation völlig anders.  Der Browser kann alle Ressourcen gleichzeitig anfordern (zumindest sobald er davon erfährt) und stellt dem Server detaillierte Anweisungen zur Bereitstellung dieser Ressourcen zur Verfügung. <br><br><h1>  Optimale Reihenfolge beim Laden von Ressourcen </h1><br>  In den meisten Fällen gibt es eine optimale Reihenfolge im Seitenladezyklus, die die Verfügbarkeit der Seite für den Benutzer maximiert (und der Unterschied zwischen der optimalen und der nicht optimalen Ladereihenfolge kann 50% oder mehr erreichen). <br><br>  Wie oben beschrieben, wird der Browser, bevor er Inhalte anzeigen kann, durch CSS und JavaScript im Abschnitt <code>&lt;head&gt;</code> blockiert.  In dieser Phase ist es rentabler, 100% des Kanals zum Laden blockierender Ressourcen zu verwenden, als sie in der Reihenfolge zu laden, wie sie im HTML-Code geschrieben sind.  Auf diese Weise kann der Browser jedes Element analysieren und ausführen, während die nächste blockierende Ressource geladen wird, wodurch eine optimale Pipeline erstellt wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db9/e18/fbe/db9e18fbe00d27755a152a8deabbcaa4.png"><br><br>  Die Ladezeit des Skripts für das parallele oder sequentielle Laden unterscheidet sich nicht, aber für das sequentielle Laden kann das erste Skript während des zweiten Ladens verarbeitet und ausgeführt werden. <br><br>  Nach dem Laden blockierender Ressourcen wird die Situation etwas interessanter.  Hier kann die optimale Auslastung von einer bestimmten Website oder sogar von Geschäftsprioritäten abhängen (Auswahl von benutzergenerierten Inhalten oder Werbung oder Analysen usw.).  Ein separates Problem mit Schriftarten, da der Browser die gewünschten Schriftarten erkennt, nachdem er das Stylesheet auf den angezeigten Inhalt angewendet hat.  Wenn der Browser von der Schriftart erfährt, muss daher Text angezeigt werden, der bereits für die Anzeige auf dem Bildschirm bereit ist.  Verzögerungen beim Laden der Schrift führen dazu, dass kein Text auf dem Bildschirm angezeigt wird (oder der Text in der falschen Schrift angezeigt wird). <br><br>  In der Regel müssen einige Kompromisse berücksichtigt werden: <br><br><ul><li>  Benutzerdefinierte Schriftarten und Bilder im sichtbaren Teil der Seite (Ansichtsfenster) sollten so schnell wie möglich geladen werden.  Sie wirken sich direkt auf die visuelle Erfahrung des Benutzers beim Laden der Seite aus. <br></li><li>  Nicht blockierendes JavaScript sollte in Bezug auf andere JavaScript-Ressourcen nacheinander geladen werden, damit jede von ihnen per Pipeline weitergeleitet werden kann.  JavaScript kann benutzerdefinierte Anwendungslogik sowie Tracking-Beacons für Analyse und Marketing enthalten, und ihre Verzögerung kann zu einer Verringerung der vom Unternehmen verfolgten Indikatoren führen. <br></li><li>  Bilder können parallel hochgeladen werden.  Die ersten paar Bytes der Bilddatei enthalten ihre Größe, die für das Browserlayout erforderlich sein kann, und das parallele Laden progressiver Bilder kann nach der Übertragung von etwa 50% des Gesamtvolumens die visuelle Vollständigkeit gewährleisten. </li></ul><br>  In Anbetracht der Kompromisse funktioniert diese Strategie in den meisten Fällen gut: <br><br><ul><li>  Benutzerdefinierte Schriftarten werden nacheinander heruntergeladen und teilen die verfügbare Bandbreite mit Bildern im Umfang. <br></li><li>  Sichtbare Bilder werden parallel geladen und teilen sich den Teil der ihnen zugewiesenen Bandbreite. <br></li><li>  Wenn keine Schriftarten oder sichtbaren Bilder mehr vorhanden sind: <br><ul><li>  Nicht blockierende Skripte werden nacheinander geladen und teilen die verfügbare Bandbreite mit unsichtbaren Bildern (die außerhalb des Gültigkeitsbereichs liegen). <br></li><li>  Unsichtbare Bilder werden parallel geladen und teilen sich den Teil der ihnen zugewiesenen Bandbreite. </li></ul></li></ul><br>  So wird der für den Benutzer sichtbare Inhalt so schnell wie möglich geladen, die Anwendungslogik auf ein Minimum verzögert und unsichtbare Bilder so geladen, dass das Layout so schnell wie möglich fertiggestellt wird. <br><br><h1>  Beispiel </h1><br>  Verwenden Sie zur Veranschaulichung eine vereinfachte Produktkategorieseite einer typischen E-Commerce-Website: <br><br><ul><li>  <b>Blau</b> - HTML-Datei der Seite selbst. <br></li><li>  <b>Grün</b> - Ein externes Stylesheet (CSS-Datei). <br></li><li>  <b>Orange</b> - Vier externe Skripte (JavaScript).  Zwei blockierende Skripte oben auf der Seite und zwei asynchrone.  Blockierende Skripte werden in einem dunkleren Orangeton angezeigt. <br></li><li>  <b>Rot</b> ist eine benutzerdefinierte Webschrift. <br></li><li>  <b>Violett</b> - 13 Bilder.  Das Seitenlogo und vier Produktbilder werden im Anzeigefenster angezeigt. Weitere 8 Produktbilder müssen gescrollt werden.  Die fünf sichtbaren Bilder werden durch einen dunkleren Purpur angezeigt. </li></ul><br>  Nehmen wir zur Vereinfachung an, dass alle Ressourcen dieselbe Größe und jede Last in 1 Sekunde haben.  Das Herunterladen aller Ressourcen dauert insgesamt 20 Sekunden, aber die Reihenfolge und Methode des Ladens sind äußerst wichtig. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fbd/07b/58a/fbd07b58a4c8aeff2a758ad1946d8523.png"><br><br>  So sieht das optimale Laden von Ressourcen in einem Browser aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b2/6a8/2cd/8b26a82cdb5c546e9005200e5528b988.gif"><br><br><ul><li>  Die Seite ist in den ersten 4 Sekunden beim Laden von HTML, CSS und Blockieren von Skripten leer: Alle verwenden eine 100% ige Verbindung. <br></li><li>  Bei der 4-Sekunden-Marke werden der Hintergrund und die Seitenstruktur ohne Text oder Bilder angezeigt. <br></li><li>  Nach einer Sekunde, nach ungefähr 5 Sekunden, wird der Seitentext angezeigt. <br></li><li>  Im Intervall von 5-10 Sekunden werden Bilder heruntergeladen, zunächst verschwommen, aber sehr schnell werden sie klar.  Nach etwa 7 Sekunden ist das Ergebnis von der endgültigen Version kaum zu unterscheiden. <br></li><li>  Nach ca. 10 Sekunden ist das Laden aller visuellen Inhalte im sichtbaren Teil der Seite abgeschlossen. <br></li><li>  In den nächsten zwei Sekunden wird asynchrones JavaScript geladen und ausgeführt, wobei unkritische Logik (Analysen, Marketing-Tags usw.) ausgeführt wird. <br></li><li>  Während der letzten 8 Sekunden werden die verbleibenden Bilder geladen, falls der Benutzer die Seite scrollt. </li></ul><br><h1>  Aktuelle Browser-Priorisierung </h1><br>  Alle aktuellen Browser-Engines implementieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://calendar.perfplanet.com/2018/">verschiedene Priorisierungsstrategien</a> , von denen keine optimal ist. <br><br>  <b>Microsoft Edge und Internet Explorer</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://calendar.perfplanet.com/2018/">unterstützen keine Priorisierung</a> , daher arbeiten sie mit den Standardeinstellungen für HTTP / 2, bei denen alles parallel geladen wird und die Bandbreite gleichmäßig auf alle Ressourcen verteilt wird.  Microsoft Edge wird in zukünftigen Versionen auf die Verwendung der Chromium-Engine umstellen, was die Situation verbessern kann.  In unserem Beispiel bleibt der Browser jedoch die meiste Zeit im Seitenkopf hängen, da Bilder die Übertragung blockierender Skripte und Stylesheets verlangsamen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e9c/844/a65/e9c844a65472a56d92cb37cd27f2f035.png"><br><br>  Optisch führt dies zu einer ziemlich schmerzhaften Erfahrung: Der Benutzer schaut 19 Sekunden lang auf einen leeren Bildschirm, und dann gibt es eine Verzögerung von 1 Sekunde, um den Text anzuzeigen.  Seien Sie geduldig, wenn Sie die folgende Animation anzeigen, denn 19 Sekunden lang scheint auf einem leeren Bildschirm nichts zu passieren (obwohl dies der Fall ist): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c9/fae/539/6c9fae539ae1d3c99570cf53af415be4.gif"><br><br>  <b>Safari</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://calendar.perfplanet.com/2018/">lädt alle Ressourcen parallel</a> und teilt laut Safari die Bandbreite entsprechend ihrer Wichtigkeit (das Blockieren von Ressourcen wie Skripten und Stylesheets ist wichtiger als Bilder).  Bilder werden parallel geladen, aber auch gleichzeitig mit blockierenden Inhalten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c75/a7d/f05/c75a7df05716f5706aa4b037774733d2.png"><br><br>  Obwohl Safari Edge in dem Sinne ähnlich ist, dass alles gleichzeitig geladen wird, können Sie durch das Zuweisen von mehr Bandbreite zum Blockieren von Ressourcen Inhalte viel früher anzeigen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0c/840/5a1/f0c8405a1b6ddc40645ab7985e28a5eb.gif"><br><br><ul><li>  Nach ca. 8 Sekunden ist das Laden des Stylesheets und der Skripte abgeschlossen, sodass Sie mit dem Rendern der Seite beginnen können.  Da die Bilder parallel geladen wurden, können sie auch teilweise angezeigt werden (verschwommen für progressive Bilder).  Dies ist immer noch doppelt so langsam wie das optimale Szenario, aber viel besser als in Edge. <br></li><li>  Nach ca. 11 Sekunden wird die Schriftart geladen.  Sie können den Text anzeigen.  Zu diesem Zeitpunkt werden mehr Daten für die Bilder geladen und sie werden etwas schärfer.  Dies ist vergleichbar mit der Situation um die 7-Sekunden-Marke für ein optimales Ladeszenario. <br></li><li>  In den verbleibenden 9 Sekunden werden die Bilder schärfer, wenn mehr Daten heruntergeladen werden, bis der Vorgang in 20 Sekunden abgeschlossen ist. </li></ul><br>  <b>Firefox</b> erstellt einen Abhängigkeitsbaum, der Ressourcen gruppiert, und plant dann, dass die Gruppen entweder nacheinander geladen werden oder die Bandbreite zwischen Gruppen gemeinsam nutzen.  Innerhalb dieser Gruppe teilen sich Ressourcen Bandbreite und laden gleichzeitig.  Es ist geplant, Bilder nach Stylesheets zu laden, die das Rendern blockieren und parallel laden. Skripte und Stylesheets, die das Rendern blockieren, werden jedoch auch parallel geladen und profitieren nicht vom Pipelining. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/870/e6d/83c/870e6d83c673b9c706dac49c78d3848d.png"><br><br>  In unserem Beispiel geschieht dies etwas schneller als in Safari, da die Bilder darauf warten, dass das Stylesheet geladen wird: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd2/806/b55/bd2806b55e830bd4c2a7e08bb1b18ce4.gif"><br><br><ul><li>  Nach ca. 6 Sekunden wird der ursprüngliche Seiteninhalt mit einem Hintergrund und verschwommenen Versionen der Produktbilder angezeigt (im Vergleich zu 8 Sekunden für Safari und 4 Sekunden im besten Fall). <br></li><li>  Nach 8 Sekunden wird die Schriftart geladen, und Sie können den Text zusammen mit etwas schärferen Bildern des Produkts anzeigen (im Vergleich zu Safari im besten Fall 11 Sekunden und 7 Sekunden). <br></li><li>  Während der verbleibenden 12 Sekunden werden die Bilder schärfer, wenn der verbleibende Inhalt geladen wird. </li></ul><br>  <b>Chrome</b> (und alle Chromium-basierten Browser) priorisieren das Inventar.  Dies funktioniert sehr gut, um Ressourcen zu blockieren, die optimal in der richtigen Reihenfolge geladen werden, aber nicht so gut für Bilder.  Jedes Bild wird zu 100% geladen, bevor das nächste gestartet wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e22/14d/4e0/e2214d4e04fab810f0a4398fe02434c1.png"><br><br>  In der Praxis ist dies ein nahezu optimales Download-Szenario. Der einzige Unterschied besteht darin, dass Bilder einzeln und nicht parallel heruntergeladen werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/91e/76c/d1d/91e76cd1d814aef138b35345eda46d82.gif"><br><br><ul><li>  Bis zu 5 Sekunden ist das Laden von Chrome identisch mit dem optimalen Szenario. Der Hintergrund wird in der 4. Sekunde und der Textinhalt in der 5. Sekunde angezeigt. <br></li><li>  In den nächsten 5 Sekunden werden die Bilder des Sichtbarkeitsbereichs einzeln geladen, bis der Vorgang nach etwa 10 Sekunden abgeschlossen ist (im Vergleich zum optimalen Szenario, wenn sie nach etwa 7 Sekunden in einer leicht verschwommenen Form angezeigt werden und für die verbleibenden drei Sekunden schärfer werden). <br></li><li>  Nachdem der visuelle Teil der Seite in 10 Sekunden abgeschlossen ist (identisch mit dem optimalen Szenario), werden die verbleibenden 10 Sekunden für das Ausführen asynchroner Skripts und das Laden versteckter Bilder (sowie im optimalen Szenario) aufgewendet. </li></ul><br><h1>  Visueller Vergleich </h1><br>  Der visuelle Unterschied ist sehr unterschiedlich, obwohl das technische Laden des gesamten Inhalts dieselbe Zeit in Anspruch nimmt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/62e/2a1/d5f/62e2a1d5f10b801af61992517d7f5a5a.gif"><br><br><h1>  Serverseitige Priorisierung </h1><br>  Die HTTP / 2-Priorisierung wird vom Client (Browser) angefordert, und der Server muss basierend auf der Anforderung entscheiden, was zu tun ist.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/andydavies/">Eine große Anzahl von Servern unterstützt diese Funktion überhaupt nicht</a> , und der Rest erfüllt eine Clientanforderung.  Eine andere Möglichkeit besteht darin, basierend auf der Clientanforderung die beste serverseitige Priorisierung festzulegen. <br><br>  Gemäß der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://http2.github.io/">Spezifikation</a> ist die HTTP / 2-Priorisierung ein Abhängigkeitsbaum, der die vollständige Kenntnis aller aktuellen Anforderungen erfordert, um Ressourcen relativ zueinander priorisieren zu können.  Auf diese Weise können Sie unglaublich komplexe Strategien implementieren, es ist jedoch schwierig, sie auf Browser- oder Serverseite gut zu implementieren (wie verschiedene Browserstrategien und unterschiedliche Ebenen der Serverunterstützung belegen).  Um die Verwaltung der Priorisierung zu vereinfachen, haben wir ein einfacheres Schema entwickelt, das dennoch über die für eine optimale Planung erforderliche Flexibilität verfügt. <br><br>  Das Priorisierungsschema von Cloudflare besteht aus 64 Prioritätsstufen. Innerhalb jeder Stufe gibt es Gruppen von Ressourcen, die bestimmen, wie die Verbindung untereinander aufgeteilt werden soll: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba5/7e5/efa/ba57e5efa56119a58bbd39596da3f9ce.png"><br><br>  Zuerst werden alle Ressourcen mit einer höheren Priorität heruntergeladen, dann erfolgt ein Übergang zu einer niedrigeren Ebene. <br><br>  Innerhalb einer bestimmten Prioritätsstufe gibt es drei verschiedene Parallelitätsgruppen: <br><br><ul><li>  <b>0</b> : Alle Ressourcen in Gruppe "0" werden nacheinander in der Reihenfolge gesendet, in der sie mit 100% Bandbreite angefordert wurden.  Erst nach dem Laden aller Ressourcen der Gruppe "0" werden andere Gruppen auf derselben Ebene berücksichtigt. <br></li><li>  <b>1</b> : Alle Ressourcen in der Parallelitätsgruppe "1" werden nacheinander in der Reihenfolge gesendet, in der sie angefordert wurden.  Die verfügbare Bandbreite ist gleichmäßig zwischen der Parallelitätsgruppe "1" und der Parallelitätsgruppe "n" verteilt. <br></li><li>  <b>n</b> : Ressourcen in der Parallelitätsgruppe "n" werden parallel übertragen und teilen sich die verfügbare Bandbreite. </li></ul><br>  In der Praxis ist die Parallelitätsgruppe „0“ nützlich für kritische Inhalte, die nacheinander verarbeitet werden müssen (Skripte, CSS usw.).  Die Gruppe „1“ ist nützlich für weniger wichtige Inhalte, die Bandbreite mit anderen Ressourcen teilen können, bei denen die Ressourcen selbst jedoch weiterhin von einer sequentiellen Verarbeitung profitieren (asynchrone Skripte, nicht progressive Bilder usw.).  Die Parallelitätsgruppe "n" ist nützlich für Ressourcen, die von der Parallelverarbeitung profitieren (progressive Bilder, Video, Audio usw.). <br><br><h1>  Standardpriorisierung von Cloudflare </h1><br>  Mit der Option der erweiterten Priorisierung wird die oben beschriebene „optimale“ Reihenfolge des Ressourcenladens implementiert.  Die spezifischen Prioritäten lauten wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b89/e96/e4f/b89e96e4f4534f5df00d732e97b5db62.png"><br><br>  Mit diesem Schema können Sie nacheinander Ressourcen senden, die das Rendern blockieren, dann sichtbare Bilder parallel senden und dann den Rest des Seiteninhalts mit einer gewissen Bandbreitenteilung teilen, um das Laden der Anwendung und des Inhalts auszugleichen.  Die <i>Einschränkung * Wenn erkennbar</i> ist, dass nicht alle Browser zwischen verschiedenen Arten von Stylesheets und Skripten unterscheiden, dies jedoch in allen Fällen viel schneller ist.  Eine Beschleunigung von 50%, insbesondere für Edge- und Safari-Besucher, ist nichts Ungewöhnliches: <br><br> <a href=""><img src="https://habrastorage.org/webt/u_/1n/px/u_1npxrzhg0svmgdyzelnamxj84.png"></a> <br><br><h1>  Festlegen der Priorisierung mit Arbeitnehmern </h1><br>  Eine schnellere Standardarbeit ist großartig, wird jedoch dank der Möglichkeit, die Priorisierung mit Cloudflare Workers-Unterstützung zu konfigurieren, sehr interessant, sodass Websites die Standardpriorität für Ressourcen überschreiben oder ihre eigenen Priorisierungsschemata implementieren können. <br><br>  Wenn der Worker der Antwort den Header <code>cf-priority</code> hinzufügt, wenden die Cloudflare-Edgeserver die angegebene Priorität und Parallelität an.  Das Header-Format lautet &lt;Priorität&gt; / &lt;Währung&gt;, daher der <code>response.headers.set('cf-priority', “30/0”);</code>  setzt für diese Antwort die Priorität 30 und die Parallelität 0. In ähnlicher Weise setzt "30/1" die Parallelität auf "1" und "30 / n" die Parallelität auf n. <br><br>  Mit dieser Flexibilität kann ein Standort eine beliebige Priorität der Ressourcen für seine Anforderungen festlegen.  Um beispielsweise die Priorität einiger wichtiger asynchroner Skripte oder Hauptbilder zu erhöhen: Sie werden heruntergeladen, noch bevor der Browser feststellt, dass sie sich in Reichweite befinden. <br><br>  Um über Priorisierungsentscheidungen zu informieren, gibt die Laufzeit der Worker auch die vom Browser bei der Priorisierung angeforderten Informationen im Anforderungsobjekt an, die an den Empfänger der Worker-Ereignisse übergeben werden (request.cf.requestPriority).  Eingehende Prioritäten sind eine Liste von Attributen, die durch ein Semikolon getrennt sind.  Es sieht ungefähr so ​​aus: <code>weight=192;exclusive=0;group=3;group-weight=127</code> . <br><br><ul><li>  <b>Gewicht</b> : Gewicht zur Priorisierung von HTTP / 2. <br></li><li>  <b>exklusiv</b> : das exklusive HTTP / 2-Flag (1 für Chromium-basierte Browser, 0 für andere). <br></li><li>  <b>Gruppe</b> : HTTP / 2-Stream-ID für die Anforderungsgruppe (ungleich Null für Firefox). <br></li><li>  <b>Gruppengewicht</b> : HTTP / 2-Gewicht für die Gruppe von Anforderungen (ungleich Null für Firefox). </li></ul><br><h1>  Dies ist nur der Anfang. </h1><br>  Die Fähigkeit, die Priorität von Antworten zu konfigurieren und zu steuern, ist der Hauptbaustein für eine großartige zukünftige Arbeit.  Darüber hinaus beabsichtigen wir, unsere eigenen erweiterten Optimierungen einzuführen. Mit Unterstützung der Mitarbeiter können jedoch alle Standorte und Forscher mit verschiedenen Priorisierungsstrategien experimentieren.  Über den Apps Marketplace können Unternehmen auch neue Optimierungsservices über der Arbeitsplattform erstellen und diese für andere Websites verfügbar machen. <br><br>  Wenn Sie einen Pro-Plan oder höher haben, wechseln Sie im Cloudflare-Dashboard zur Registerkarte "Geschwindigkeit" und aktivieren Sie die "erweiterte HTTP / 2-Priorisierung", um Ihre Site zu beschleunigen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/386/d53/276/386d532767b6396ee628a7e0eb837282.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452020/">https://habr.com/ru/post/de452020/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452004/index.html">Fand die Absturzstelle des Bereshit auf dem Mond</a></li>
<li><a href="../de452006/index.html">Epic Metaverse: Warum Fortnite-Autoren es bekommen sollten</a></li>
<li><a href="../de452008/index.html">Technische Ansätze und Checkliste: Wie man im Chaos der Aufgaben nicht verrückt wird</a></li>
<li><a href="../de452010/index.html">Osmo Action: DJIs erste Actionkamera</a></li>
<li><a href="../de452016/index.html">12 Jahre in der Cloud</a></li>
<li><a href="../de452022/index.html">Google informiert Nutzer mit ihren Titan-Sicherheitsschlüsseln über eine Sicherheitsanfälligkeit</a></li>
<li><a href="../de452026/index.html">Vor 20 Jahren hat Microsoft die Art und Weise, wie wir die Maus verwenden, für immer verändert</a></li>
<li><a href="../de452028/index.html">Lichtstrahl im dunklen Königreich: Wie Technologie verlorene Sicht zurückgibt</a></li>
<li><a href="../de452030/index.html">Internet-Verlauf: Interaktivität entdecken</a></li>
<li><a href="../de452034/index.html">Selbstkontrolle der Zeit für Selbstbildung und Zeit für das Lesen von Büchern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>