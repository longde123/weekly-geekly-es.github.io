<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö≠ üë©üèΩ‚Äçüé§ üèì Was ist neu in SObjectizer-5.7.0 und worauf wartet dieses Projekt als n√§chstes? üèí üéí üôåüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SObjectizer ist ein relativ kleines C ++ 17-Framework, mit dem Sie Ans√§tze wie Actor Model, Publish-Subscribe und Communicating Sequential Processes (...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was ist neu in SObjectizer-5.7.0 und worauf wartet dieses Projekt als n√§chstes?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485450/"><p>  <a href="https://github.com/Stiffstream/sobjectizer">SObjectizer</a> ist ein relativ kleines C ++ 17-Framework, mit dem Sie Ans√§tze wie Actor Model, Publish-Subscribe und Communicating Sequential Processes (CSP) in C ++ - Programmen verwenden k√∂nnen.  Dies vereinfacht die Entwicklung komplexer Multithread-Anwendungen in C ++ erheblich.  Wenn der Leser zum ersten Mal von SObjectizer h√∂rt, k√∂nnen Sie sich anhand dieser <a href="https://sourceforge.net/projects/sobjectizer/files/sobjectizer/Slides/What%2520is%2520SObjectizer-5.7%2520%2528at%2520v.5.7.0%2529.pdf/download">Pr√§sentation</a> oder anhand dieses bereits recht alten <a href="https://habr.com/post/304386/">Artikels</a> ein Bild von ihm machen. </p><br><p>  Generell gibt es nicht so viele √§hnliche offene, noch lebende und sich noch entwickelnde Tools f√ºr C ++.  Man kann sich nur an <a href="https://www.state-machine.com/qpcpp/">QP / C ++</a> , <a href="http://actor-framework.org/">CAF: C ++ Actor Framework</a> , <a href="https://github.com/jinncrafters/actor-zeta">actor-zeta</a> und das sehr junge <a href="https://github.com/basiliscos/cpp-rotor">Rotorprojekt</a> erinnern.  Es gibt eine Wahl, aber nicht so gro√ü. </p><br><p>  In letzter Zeit ist eine <a href="https://groups.google.com/d/msg/sobjectizer/iudaw-GBHnc/7HjgPLPTCgAJ">weitere "Major" -Version von SObjectizer</a> verf√ºgbar geworden, in der endlich etwas <a href="https://groups.google.com/d/msg/sobjectizer/iudaw-GBHnc/7HjgPLPTCgAJ">aufgetaucht</a> ist, wor√ºber schon lange gesprochen wurde und auf das ich mehrmals erfolglos <a href="https://groups.google.com/d/msg/sobjectizer/iudaw-GBHnc/7HjgPLPTCgAJ">zugegriffen</a> habe.  Wir k√∂nnen sagen, dass ein Meilenstein erreicht wurde.  Dies ist auch eine Gelegenheit dar√ºber zu sprechen, was SObjectizer nach der Ver√∂ffentlichung von Version 5.7.0 erwartet. </p><br><h1 id="podderzhka-send_case-v-select">  Send_case-Unterst√ºtzung in select () </h1><br><p>  Die wichtigste Neuerung in Version 5.7.0, f√ºr die die Kompatibilit√§t mit Version 5.6 im letzten Jahr ver√∂ffentlicht wurde (und die Kompatibilit√§t wird nicht beeintr√§chtigt), war die fehlerhafte send_case-Unterst√ºtzung in der select () -Funktion.  Was hat SObjectizers select () viel √§hnlicher gemacht als Go selects.  Mit select () k√∂nnen Sie jetzt nicht nur Nachrichten von mehreren CSP-Kan√§len lesen, sondern auch ausgehende Nachrichten an die Kan√§le senden, die zum Schreiben bereit waren. </p><a name="habracut"></a><br><p>  Aber um dieses Thema zu enth√ºllen, m√ºssen Sie von weitem beginnen. </p><br><h2 id="poyavlenie-elementov-csp-v-sobjectizer-5">  Die Entstehung von CSP-Elementen in SObjectizer-5 </h2><br><p>  In SObjectizer-5 tauchten Elemente von CSP auf, n√§mlich Analoga von CSP-Kan√§len, um nicht das Kontrollk√§stchen "CSP-Unterst√ºtzung" zu aktivieren, sondern ein praktisches Problem zu l√∂sen. </p><br><p>  Die Sache war, dass, wenn die gesamte Anwendung vollst√§ndig auf SObjectizer basiert, der Informationsaustausch zwischen verschiedenen Entit√§ten (Teilen) des Programms auf einzig offensichtliche Weise realisiert wird.  Alles in der Anwendung wird in Form von Agenten (Akteuren) dargestellt, und Agenten senden sich einfach auf standardm√§√üige Weise Nachrichten. </p><br><p>  Aber wenn in der Anwendung nur ein Teil der Funktionalit√§t auf SObjectizer implementiert ist ... </p><br><p>  Zum Beispiel eine GUI-Anwendung auf Qt oder wxWidgets, in der der Hauptteil des Codes eine GUI ist, und ein SObjectizer, um einige Hintergrundaufgaben auszuf√ºhren.  Oder ein Teil der Anwendung wird mit Bare-Threads und Asio geschrieben, und von Asio gelesene Daten aus dem Netzwerk werden zur Verarbeitung an SObjectizer-Agenten gesendet. </p><br><p>  Wenn eine Anwendung einen SObjectizer-Teil und einen Nicht-SObjectizer-Teil hat, stellt sich die Frage: Wie werden Informationen vom SObjectizer-Teil der Anwendung zum Nicht-SObjectizer-Teil √ºbertragen? </p><br><p>  Die L√∂sung wurde in Form von sogenannten gefunden  Nachrichtenketten (mchains), d.h.  Gespr√§che.  Was sich zuf√§llig als die Essenz der CSP-Kan√§le herausstellte.  Der SObjectizer-Teil der Anwendung sendet unter Verwendung der regul√§ren send () -Funktion auf die √ºbliche Weise Nachrichten an mchain. </p><br><p>  Um Nachrichten vom Nicht-SObjectizer-Teil zu lesen, k√∂nnen Sie die neue Funktion receive () verwenden, mit der Sie keine Agenten erstellen oder in andere Bereiche von SObjectizer eintauchen m√ºssen. </p><br><p>  Es stellte sich als ziemlich verst√§ndliches und funktionierendes Schema heraus. </p><br><h2 id="nachalo-ispolzovaniya-mchains-ne-po-naznacheniyu">  Missbrauch von Ketten </h2><br><p>  Dar√ºber hinaus erwies sich das Schema als so verst√§ndlich und funktionierte so schnell, dass einige Anwendungen auf SObjectizer √ºberhaupt ohne Agenten zu schreiben begannen, nur auf mchain-ahs.  Das hei√üt  mit dem CSP-Ansatz, nicht das Actor Model.  Hier auf Habr√© gab es bereits Artikel dar√ºber: <a href="https://habr.com/ru/post/336854/">eins</a> und <a href="https://habr.com/ru/post/358120/">zwei</a> . </p><br><p>  Dies f√ºhrte zu zwei interessanten Konsequenzen. </p><br><p>  Erstens ist die Funktion receive () mit erweiterten Funktionen √ºberladen.  Dies war erforderlich, damit nur ein Aufruf von receive () m√∂glich war, dessen R√ºckkehr erfolgen w√ºrde, wenn alle erforderlichen Arbeiten bereits ausgef√ºhrt wurden.  Hier sind Beispiele daf√ºr, was SObjectizer mit receive () tun kann: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-comment"><span class="hljs-comment">//    3 . //  3    mchain ,   . //   receive    3 , //      . receive( from(chain).handle_n( 3 ), handlers... ); //    3 . //       mchain ,    //     200ms. // ..     200ms,    receive,   //      . receive( from(chain).handle_n( 3 ).empty_timeout( milliseconds(200) ), handlers... ); //       . //     ,    //  500ms. receive( from(chain).handle_all().empty_timeout( milliseconds(500) ), handlers... ); //       . //       2s. receive( from(chain).handle_all().total_time( seconds(2) ), handlers... );</span></span></code> </pre> <br><p>  Zweitens wurde schnell klar, dass obwohl verschiedene Arten von Nachrichten in der SObjectizer-Kette platziert werden k√∂nnen und trotz der erweiterten Funktion receive () manchmal mit mehreren Kan√§len gleichzeitig gearbeitet werden muss ... </p><br><h2 id="select-no-tolko-dlya-chteniya">  W√§hle (), aber schreibgesch√ºtzt </h2><br><p>  Die Funktion select () wurde zu SObjectizer hinzugef√ºgt, um Nachrichten von mehreren Ketten zu lesen und zu verarbeiten.  Clear Business Select () erschien nicht nur so, sondern unter dem Einfluss der Go-Sprache.  Aber SObjectizers select () hatte zwei Funktionen. </p><br><p>  Erstens war unser select () wie receive () skriptorientiert, wenn select () nur einmal aufgerufen wird und die gesamte n√ºtzliche Arbeit darin erledigt ist.  Zum Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> ch1 = env.create_mchain(...); <span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> ch2 = env.create_mchain(...); <span class="hljs-comment"><span class="hljs-comment">//    3 . //    3    ch1. //  2  ch1    ch2. //    ch1  2  ch2... // //   ,       . // select()      3 , //     . select( from_all().handle_n( 3 ), receive_case( ch1, []( const first_message_type &amp; msg ) { ... }, []( const second_message_type &amp; msg ) { ... } ), receive_case( ch2, []( const third_message_type &amp; msg ) { ... }, []( so_5::mhood_t&lt; some_signal_type &gt; ) { ... } ), ... ) ); //    3 . //    ,     200ms. select( from_all().handle_n( 3 ).empty_timeout( milliseconds(200) ), receive_case( ch1, []( const first_message_type &amp; msg ) { ... }, []( const second_message_type &amp; msg ) { ... } ), receive_case( ch2, []( const third_message_type &amp; msg ) { ... }, []( so_5::mhood_t&lt; some_signal_type &gt; ) { ... } ), ... ) ); //       . //    ,     500ms. select( from_all().handle_all().empty_timeout( milliseconds(500) ), receive_case( ch1, []( const first_message_type &amp; msg ) { ... }, []( const second_message_type &amp; msg ) { ... } ), receive_case( ch2, []( const third_message_type &amp; msg ) { ... }, []( so_5::mhood_t&lt; some_signal_type &gt; ) { ... } ), ... ) );</span></span></code> </pre> <br><p>  Zweitens unterst√ºtzte select () das Senden von Nachrichten an den Kanal nicht.  Das hei√üt  Nachrichten von Kan√§len konnten gelesen werden.  Um jedoch Nachrichten an den Kanal zu senden, w√§hlen Sie () - Nr. </p><br><p>  Jetzt ist es sogar schwer, sich daran zu erinnern, warum es passiert ist.  Wahrscheinlich, weil select () mit send_case-Unterst√ºtzung eine schwierige Aufgabe war und keine Ressourcen gefunden wurden, um sie zu l√∂sen. </p><br><h3 id="mchain-y-v-sobjectizer-hitree-chem-kanaly-v-go">  M-Ketten in SObjectizer sind schwieriger als Kan√§le in Go </h3><br><p>  Zun√§chst wurde select () ohne send_case-Unterst√ºtzung nicht als Problem angesehen.  Tatsache ist, dass Ketten in SObjectizer ihre eigenen Besonderheiten haben, die Go-Kan√§le nicht haben. </p><br><p>  Erstens werden SObjectizer-Ketten in dimensionslose und mit einer festen maximalen Kapazit√§t unterteilt.  Wenn daher send () f√ºr eine dimensionslose Kette ausgef√ºhrt wird, wird dieses send () im Prinzip nicht blockiert.  Daher ist es nicht sinnvoll, select () zu verwenden, um eine Nachricht an die dimensionslose Kette zu senden. </p><br><p>  Zweitens wird bei Ketten mit fester maximaler Kapazit√§t beim Erstellen sofort angezeigt, was passiert, wenn Sie versuchen, eine Nachricht an die vollst√§ndige Kette zu schreiben: </p><br><ul><li>  Muss ich auf freien Speicherplatz in mchain warten?  Und wenn n√∂tig, wie lange? </li><li>  Wenn es keinen freien Speicherplatz gibt, was tun? L√∂schen Sie die √§lteste Nachricht aus der mchain, ignorieren Sie die neue Nachricht, l√∂sen Sie eine Ausnahme aus oder rufen Sie std :: abort () auf (dieses harte Skript ist in der Praxis sehr gefragt). </li></ul><br><p>  Daher war in SObjectizer ein (meines Wissens) recht h√§ufiges Szenario, in Go select zu verwenden, um eine Nachricht zu senden, die Goroutin nicht fest blockiert, sofort in SObjectizer ohne Funken und ohne select verf√ºgbar. </p><br><h2 id="v-konce-koncov-polnocennyy-select">  Am Ende eine vollst√§ndige Auswahl () </h2><br><p>  Trotzdem verging die Zeit, gelegentlich gab es F√§lle, in denen der Mangel an send_case-Unterst√ºtzung in select () immer noch betroffen war.  Dar√ºber hinaus haben in diesen F√§llen die eingebauten F√§higkeiten von Ketten nicht geholfen, sondern eher das Gegenteil. </p><br><p>  Daher habe ich von Zeit zu Zeit versucht, mich dem Problem der send_case-Implementierung zu n√§hern.  Aber bis vor kurzem hat nichts funktioniert.  Haupts√§chlich, weil es nicht m√∂glich war, das Design dieses send_case selbst zu entwerfen.  Das hei√üt  Wie soll send_case in select () aussehen?  Was genau soll er tun, wenn es m√∂glich ist zu senden?  Im Falle der Unm√∂glichkeit?  Was tun mit der Unterteilung in dimensionslose und feste Ketten? </p><br><p>  Auf diese und andere Fragen konnte ich erst im Dezember 2019 Antworten finden.  Vor allem aufgrund von Konsultationen mit Personen, die mit Go vertraut sind und Go Selects in der Praxis eingesetzt haben.  Nun, sobald das send_case-Bild endlich Gestalt angenommen hatte, traf die Implementierung genau dort ein. </p><br><p>  So, jetzt kannst du so schreiben: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Greeting</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> text_; }; select(from_all().handle_n(<span class="hljs-number"><span class="hljs-number">1</span></span>), send_case(ch, <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;Greeting&gt;::make(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>), []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello sent!"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }));</code> </pre> <br><p>  Wichtig ist, dass send_case in select () die √úberladungsantwort ignoriert, die f√ºr die Ziel-Mchain festgelegt wurde.  Im obigen Beispiel k√∂nnte ch also mit der Reaktion abort_app erstellt werden, wenn versucht wird, eine Nachricht an den vollst√§ndigen Kanal zu senden.  Und wenn Sie versuchen, simple send () aufzurufen, um in ch zu schreiben, kann std :: abort () aufgerufen werden.  Aber im Fall von select () - und dies wird nicht passieren, wird select () warten, bis freier Speicherplatz in ch erscheint.  Oder bis ch geschlossen ist. </p><br><p>  Hier einige weitere Beispiele, wie send_case in select () von SObjectizer vorgehen kann: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-comment"><span class="hljs-comment">//     ,   //    . //    . select(from_all().handle_n(1), send_case(ch1, message_holder_t&lt;FirstMessage&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMessage&gt;::make(...), []{...}), send_case(ch3, message_holder_t&lt;ThirdMessage&gt;::make(...), []{...})); //     . //     ( ) //   ( ). select(from_all().handle_n(3), send_case(ch1, message_holder_t&lt;FirstMessage&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMessage&gt;::make(...), []{...}), send_case(ch3, message_holder_t&lt;ThirdMessage&gt;::make(...), []{...})); //     chW. //     chW    150ms. select(from_all().handle_n(1).empty_timeout(150ms), send_case(chW, message_holder_t&lt;Msg&gt;::make(...), []{...})); //     chW. //  ,   chW   . select(from_all().handle_n(1).no_wait_on_empty(), send_case(chW, message_holder_t&lt;Msg&gt;::make(...), []{...})); //    ,      250ms. select(from_all().handle_all().total_time(250ms), send_case(ch1, message_holder_t&lt;FirstMessage&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMessage&gt;::make(...), []{...}), send_case(ch3, message_holder_t&lt;ThirdMessage&gt;::make(...), []{...}));</span></span></code> </pre> <br><p>  Nat√ºrlich kann send_case in select () in Verbindung mit receive_case verwendet werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//          //  .       //  . select(from_all().handle_n(1), send_case(ch1, message_holder_t&lt;FirstMsg&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMsg&gt;::make(...), []{...}), receive_case(ch3, [](...){...}), receive_case(ch4, [](...){...}));</span></span></code> </pre> <br><p>  So kann jetzt in SObjectizer der CSP-Ansatz in allen Bereichen verwendet werden.  Es wird nicht schlimmer sein als in Go.  Nat√ºrlich ausf√ºhrlich.  Aber nicht schlimmer :) </p><br><p>  Wir k√∂nnen sagen, dass die lange Geschichte des Hinzuf√ºgens von Unterst√ºtzung f√ºr den CSP-Ansatz zu SObjectizer beendet ist. </p><br><h1 id="drugie-vazhnye-veschi-v-etom-relize">  Andere wichtige Dinge in dieser Version </h1><br><h2 id="okonchatelnyy-pereezd-na-github">  Letzter Umzug nach Github </h2><br><p>  SObjectizer lebte und entwickelte urspr√ºnglich bei <a href="https://sourceforge.net/projects/sobjectizer/">SourceForge</a> .  Ein Jahr der Werbung seit 2006.  Bei SF.net ging die Leistung von Subversion jedoch immer weiter zur√ºck, sodass wir letztes Jahr zu BitBucket und Mercurial wechselten.  Sobald wir dies getan haben, gab Atlassian bekannt, dass Mercurial-Repositorys mit BitBucket bald vollst√§ndig gel√∂scht werden.  Daher befinden sich seit August 2019 sowohl SObjectizer als auch so5extra auf GitHub. </p><br><p>  SF.net hat den gesamten alten Inhalt, einschlie√ülich des Wikis mit der Dokumentation f√ºr fr√ºhere Versionen von SObjectizer.  Au√üerdem k√∂nnen Sie <a href="https://sourceforge.net/projects/sobjectizer/files/">im Bereich "Dateien"</a> Archive verschiedener Versionen von SObjectizer / so5extra herunterladen (z. B. <a href="https://sourceforge.net/projects/sobjectizer/files/sobjectizer/Slides/">PDF-Dateien mit einigen Pr√§sentationen zu SObjectizer</a> ). </p><br><p>  Im Allgemeinen suchen Sie uns jetzt auf <a href="https://github.com/Stiffstream/sobjectizer">GitHub</a> .  Und vergessen Sie nicht, Sterne zu setzen, wir haben vorerst zu wenig;) </p><br><h2 id="ispravleno-povedenie-enveloped-messages">  Behobenes Verhalten von umh√ºllten Nachrichten </h2><br><p>  In SO-5.7.0 fand eine kleine Korrektur statt, die nicht erw√§hnt werden konnte.  Es ist jedoch zu erw√§hnen, dass dies eine gute Demonstration daf√ºr ist, wie sich die verschiedenen Funktionen von SObjectizer w√§hrend der Entwicklung gegenseitig beeinflussen. </p><br><p>  Vor vier Jahren wurde SObjectizer um die Unterst√ºtzung f√ºr Agenten erweitert, die hierarchische Zustandsautomaten sind (weitere Details <a href="https://habr.com/post/423497/">hier</a> ).  Nach einigen Jahren wurden dann <a href="https://habr.com/ru/post/426983/">Nachrichtenumschl√§ge</a> zu SObjectizer hinzugef√ºgt.  Das hei√üt  Die Nachricht wurde beim Senden in ein zus√§tzliches Umschlagobjekt eingeschlossen, und dieser Umschlag konnte Informationen dar√ºber erhalten, was mit der Nachricht geschieht. </p><br><p>  Eines der Merkmale des Mechanismus f√ºr umh√ºllte Nachrichten besteht darin, dass dem Umschlag mitgeteilt wird, dass die Nachricht an den Adressaten zugestellt wurde.  Das hei√üt, dass ein Handler f√ºr diese Nachricht beim Teilnehmeragenten gefunden wurde und dieser Handler aufgerufen wurde. </p><br><p>  Es stellte sich heraus, dass, wenn der Empf√§ngeragent der Nachricht eine hierarchische Zustandsmaschine ist, die eine Funktion wie <code>suppress()</code> (d. H. Das Erzwingen, dass die Nachricht in einem bestimmten Zustand ignoriert wird), der Umschlag m√∂glicherweise eine Benachrichtigung √ºber eine falsche Zustellung erh√§lt, obwohl die Nachricht tats√§chlich vom Empf√§nger zur√ºckgewiesen wurde aufgrund von <code>suppress()</code> .  Eine noch interessantere Situation war mit <code>transfer_to_state()</code> , weil  Nach dem √Ñndern des Status des empfangenden Agenten wird der Nachrichtenhandler m√∂glicherweise gefunden oder fehlt.  Aber der Umschlag √ºber die Zustellung der Nachricht wurde trotzdem informiert. </p><br><p>  Sehr seltene F√§lle, die meines Wissens von niemandem in der Praxis nachgewiesen wurden.  Trotzdem wurde eine Fehleinsch√§tzung vorgenommen. </p><br><p>  Daher wurde in SO-5.7.0 dieser Punkt verbessert. Wenn die Nachricht infolge der Anwendung von <code>suppress()</code> oder <code>transfer_to_state()</code> ignoriert wird, glaubt der Umschlag nicht mehr, dass die Nachricht an den Adressaten zugestellt wurde. </p><br><h2 id="dopolnitelnaya-biblioteka-so5extra-smenila-licenziyu-na-bsd-3-clause">  Zus√§tzliche so5extra-Bibliothek √§ndert die BSD-3-CLAUSE-Lizenz </h2><br><p>  2017 haben wir begonnen, eine Bibliothek mit zus√§tzlichen Komponenten f√ºr SObjectizer namens <a href="https://github.com/Stiffstream/so5extra">so5extra zu erstellen</a> .  In dieser Zeit ist die Bibliothek erheblich gewachsen und enth√§lt viele n√ºtzliche Dinge im Haushalt. </p><br><p>  So5extra wurde urspr√ºnglich unter einer doppelten Lizenz vertrieben: GNU Affero GPL v.3 f√ºr Open Source-Projekte und kommerzielle f√ºr geschlossene Projekte. </p><br><p>  Jetzt haben wir die Lizenz f√ºr so5extra ge√§ndert und ab Version 1.4.0 wird so5extra unter der BSD-3-CLAUSE-Lizenz vertrieben.  Das hei√üt  Es kann kostenlos verwendet werden, auch wenn propriet√§re Software entwickelt wird. </p><br><p>  Wenn Sie also etwas in SObjectizer vermissen, k√∂nnen Sie <a href="https://github.com/Stiffstream/so5extra/wiki/so5extra-1.4-docs">sich so5extra ansehen</a> . Was ist, wenn Sie bereits das haben, was Sie brauchen? </p><br><h1 id="buduschee-sobjectizer-a">  Die Zukunft von SObjectizer </h1><br><p>  Bevor Sie ein paar Worte dar√ºber sagen, worauf SObjectizer wartet, ist ein wichtiger Exkurs erforderlich.  Speziell f√ºr diejenigen, die glauben, dass SObjectizer eine "Referenzverschwendung" ist, "kniehohe Verarbeitung", "Sch√ºlerlabor", "experimentelle Projektion, die die Autoren aufgeben, wenn sie genug spielen" ... (dies ist nur ein Teil der Eigenschaften, die wir von Experten geh√∂rt haben unseres Internets in den letzten 4-5 Jahren). </p><br><p>  Ich habe SObjectizer f√ºr fast achtzehn Jahre entwickelt.  Und ich kann verantwortungsbewusst sagen, dass er nie ein Pilotprojekt war.  Dies ist ein praktisches Werkzeug, das seit seiner allerersten Version im Jahr 2002 in die Praxis umgesetzt wurde. </p><br><p>  Sowohl ich als auch meine Kollegen und Leute, die es wagten, SObjectizer zu testen, waren oft davon √ºberzeugt, dass SObjectizer die Entwicklung einiger Arten von Multithread-C ++ - Anwendungen erheblich erleichtert.  Nat√ºrlich ist SObjectizer kein Wundermittel und kann auf keinen Fall immer verwendet werden.  Aber wo es angebracht ist, hilft es. </p><br><p>  Das Leben bietet immer wieder die Gelegenheit, sich davon zu √ºberzeugen.  Von Zeit zu Zeit f√§llt uns der Multithread-Code eines anderen auf, in dem es nichts Vergleichbares zu SObjectizer gab und der wahrscheinlich nie auftaucht.  Behandeln Sie diesen Code hier und da. Momente, in denen die Verwendung von Akteuren oder CSP-Kan√§len den Code sowohl einfacher als auch zuverl√§ssiger machen k√∂nnte, sind bemerkenswert.  Aber nein, Sie m√ºssen nicht-triviale Muster der Thread-Interaktion mithilfe von mutex-s und condition_variables erstellen, wobei Sie in SObjectizer mit einer mchain, ein paar Nachrichten und einem in SObjectizer integrierten Timer zurechtkommen k√∂nnen.  Und dann auch noch viel Zeit damit verbringen, diese nicht trivialen Schemata zu testen ... </p><br><p>  SObjectizer war also n√ºtzlich f√ºr uns.  Ich wage zu glauben, dass es nicht nur f√ºr uns n√ºtzlich war.  Und vor allem ist es schon lange hier und steht jedem frei zur Verf√ºgung.  Er wird nirgendwo abreisen.  Und wohin soll man gehen, was in OpenSource unter einer genehmigten Lizenz steht?  ;) </p><br><p>  Eine andere Sache ist, dass wir selbst alle unsere gro√üen Wishlist in SObjectizer implementiert haben.  Und die zuk√ºnftige Entwicklung von SObjectizer wird weniger von unseren Bed√ºrfnissen als vielmehr von den W√ºnschen der Anwender bestimmt. </p><br><p>  Es wird solche W√ºnsche geben - es wird neue Funktionen in SObjectizer geben. </p><br><p>  Es wird nicht so sein ... Nun, dann werden wir von Zeit zu Zeit nur Korrekturversionen herausgeben und die Leistung von SObjectizer unter den neuen Versionen von C ++ - Compilern √ºberpr√ºfen. </p><br><p>  Wenn Sie also etwas in SObjectizer sehen m√∂chten, lassen Sie es uns wissen.  Wenn Sie Hilfe zu SObjectizer ben√∂tigen, k√∂nnen Sie sich gerne an uns wenden (√ºber <a href="https://github.com/Stiffstream/sobjectizer/issues">Probleme mit GitHub</a> oder der <a href="https://groups.google.com/forum/">Google-Gruppe</a> ). Wir werden uns auf jeden Fall bem√ºhen, Ihnen zu helfen. </p><br><p>  Nun, ich m√∂chte mich bei den Lesern bedanken, die bis zum Ende dieses Artikels lesen konnten.  Und ich werde versuchen, alle Fragen zu SObjectizer / so5extra zu beantworten, falls solche auftauchen. </p><br><p>  PS.  Ich w√§re dankbar, wenn die Leser Zeit h√§tten, in den Kommentaren zu schreiben, ob es interessant / n√ºtzlich ist, Artikel √ºber SObjectizer zu lesen, und ob sie dies in Zukunft tun m√∂chten.  Oder ist es f√ºr uns besser, keine Zeit mehr mit dem Schreiben solcher Artikel zu verschwenden und uns nicht mehr die Zeit der Habr-Benutzer zu nehmen? </p><br><p>  PPS  Oder k√∂nnte jemand, der SObjectizer als Werkzeug betrachtet, aus dem einen oder anderen Grund nicht angewendet werden?  Es w√§re sehr interessant, dar√ºber zu wissen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485450/">https://habr.com/ru/post/de485450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485426/index.html">Autos in den Niederlanden: Statistiken und Informationen f√ºr 2019</a></li>
<li><a href="../de485428/index.html">Das mysteri√∂se LyX-Programm. Teil 5</a></li>
<li><a href="../de485430/index.html">Einfacher Mehrbenutzer-Texteditor mit End-to-End-Verschl√ºsselung</a></li>
<li><a href="../de485438/index.html">Testen der Komponenten der Reaktionsoberfl√§che</a></li>
<li><a href="../de485448/index.html">Ein weiteres FM-Radio auf dem RDA5807 mit Arduino</a></li>
<li><a href="../de485452/index.html">Warum Rust den TechEmpower Framework Benchmark anf√ºhrt</a></li>
<li><a href="../de485454/index.html">Erste Schritte mit User Returns: Tipps f√ºr das Hooked-Modell</a></li>
<li><a href="../de485458/index.html">Haubitze Schalld√§mpfer</a></li>
<li><a href="../de485460/index.html">20 Bibliotheken f√ºr eine spektakul√§re iOS-Anwendung</a></li>
<li><a href="../de485462/index.html">Wir besch√§ftigen uns mit eSIM (+ Interview mit einem Experten)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>