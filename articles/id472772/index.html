<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ŒğŸ¼ ğŸ§‘ğŸ½â€ğŸ¤â€ğŸ§‘ğŸ½ ğŸ¥Œ Cari insiden dan klaim serupa. Metrik dan Optimasi ğŸ‘¨ğŸ¾â€ğŸ”§ â™ï¸ ğŸ±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya, saya berbicara tentang mesin pencari kami untuk aplikasi serupa . Setelah diluncurkan, kami mulai menerima ulasan pertama. A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cari insiden dan klaim serupa. Metrik dan Optimasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472772/"><p>  Dalam artikel sebelumnya, saya berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin pencari</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk aplikasi serupa</a> .  Setelah diluncurkan, kami mulai menerima ulasan pertama.  Analis menyukai dan merekomendasikan beberapa rekomendasi, beberapa tidak. </p><br><p>  Untuk melanjutkan dan menemukan model yang lebih baik, pertama-tama perlu untuk mengevaluasi kinerja model saat ini.  Itu juga perlu untuk memilih kriteria dimana dua model dapat dibandingkan satu sama lain. </p><br><p>  Di bawah potongan, saya akan berbicara tentang: </p><br><ul><li>  mengumpulkan umpan balik tentang rekomendasi </li><li>  pengembangan metrik untuk menilai kualitas rekomendasi </li><li>  membangun siklus optimisasi model </li><li>  menerima wawasan dan model baru </li></ul><a name="habracut"></a><br><h2 id="sbor-otzyvov">  Koleksi umpan balik </h2><br><p>  Akan ideal untuk mengumpulkan umpan balik eksplisit dari analis: seberapa relevan rekomendasi dari masing-masing insiden yang diusulkan.  Ini akan memungkinkan kita untuk memahami situasi saat ini dan terus meningkatkan sistem berdasarkan indikator kuantitatif. </p><br><p>  Diputuskan untuk mengumpulkan ulasan dalam format yang sangat sederhana: </p><br><ul><li>  jumlah insiden yang kami analisis </li><li>  nomor insiden yang direkomendasikan </li><li>  review rekomendasi: baik / buruk </li></ul><br><p>  "Suara" (proyek kecil yang menerima permintaan GET dengan parameter, dan memasukkan informasi ke dalam file) ditempatkan langsung di blok rekomendasi sehingga analis dapat segera meninggalkan umpan balik mereka dengan hanya mengklik salah satu tautan: "baik" atau "buruk". </p><br><p>  Selain itu, untuk tinjauan retrospektif rekomendasi, solusi yang sangat sederhana dibuat: </p><br><ul><li>  untuk sejumlah besar data historis, sebuah model diluncurkan; </li><li>  Rekomendasi yang terkumpul disajikan dalam bentuk beberapa file HTML mandiri, di mana "voting" yang sama digunakan; </li><li>  file yang disiapkan diserahkan kepada analis untuk melihat hasilnya selama 50-100 insiden. </li></ul><br><p>  Jadi dimungkinkan untuk mengumpulkan data sekitar 4000+ pasang insiden-rekomendasi. </p><br><h2 id="pervichnyy-analiz-otzyvov">  Analisis tinjauan awal </h2><br><p>  Metrik awal adalah "biasa saja" - bagian dari rekomendasi "baik", menurut rekan, hanya sekitar 25%. </p><br><p>  Masalah utama dari model pertama: </p><br><ol><li>  insiden pada masalah "baru" menerima rekomendasi yang tidak relevan dari sistem;  Ternyata dengan tidak adanya kebetulan dalam isi banding, sistem memilih insiden yang dekat dengan departemen karyawan yang menghubungi. </li><li>  rekomendasi untuk insiden pada satu sistem mengenai insiden dari sistem lain.  Kata-kata yang digunakan dalam permohonan serupa, tetapi menggambarkan masalah sistem lain dan berbeda. </li></ol><br><p>  Cara-cara yang mungkin untuk meningkatkan kualitas rekomendasi dipilih: </p><br><ul><li>  penyesuaian komposisi dan bobot atribut perawatan yang termasuk dalam vektor akhir </li><li> pemilihan pengaturan vektorisasi <code>TfidfVectorizer</code> </li><li>  pemilihan jarak "cutoff" dari rekomendasi </li></ul><br><h2 id="vyrabotka-kriteriev-kachestva-i-metodiki-ocenki">  Pengembangan kriteria kualitas dan metode penilaian </h2><br><p>  Untuk mencari versi model yang lebih baik, perlu untuk menentukan prinsip menilai kualitas hasil model.  Ini akan memungkinkan Anda untuk membandingkan kedua model secara kuantitatif dan memilih yang terbaik. </p><br><h3 id="chto-mozhno-poluchit-iz-sobrannyh-otzyvov">  Apa yang bisa diperoleh dari ulasan yang dikumpulkan </h3><br><p>  Kami memiliki banyak bentuk: "Insiden", "Insiden yang Direkomendasikan", "Penilaian Rekomendasi". </p><br><ul><li>  "Rating rekomendasi" ( <strong>v</strong> ) - disetel biner: "Bagus" |  Buruk (1 / -1); </li><li>  "Insiden" dan "Insiden yang Direkomendasikan" hanyalah angka insiden.  Pada mereka, Anda dapat menemukan insiden di database. </li></ul><br><p>  Memiliki data seperti itu, Anda dapat menghitung: </p><br><ul><li>  <code>n_inc_total</code> - Jumlah total insiden yang ada rekomendasi </li><li>  <code>n_inc_good</code> - Jumlah insiden yang ada rekomendasi "baik" </li><li>  <code>avg_inc_good</code> - Jumlah rata-rata rekomendasi "baik" untuk insiden </li><li>  <code>n_rec_total</code> - Jumlah total rekomendasi </li><li>  <code>n_rec_good</code> - Jumlah total rekomendasi "baik" </li><li>  <code>pct_inc_good</code> - bagian insiden yang ada rekomendasi "baik" <br> <code>pct_inc_good = n_inc_good / n_inc_total</code> </li> <li>  <code>pct_rec_good</code> - total bagian dari rekomendasi "baik" <br> <code>pct_rec_good = n_rec_good / n_rec_total</code> </li> </ul><br><p>  Indikator-indikator ini, dihitung berdasarkan estimasi dari pengguna, dapat dianggap sebagai "indikator dasar" dari model asli.  Dengan itu kita akan membandingkan indikator serupa dari versi model yang baru. </p><br><p>  Ambil semua "insiden" unik dari <strong>m</strong> , dan arahkan melalui model baru. </p><br><p>  Akibatnya, kami mendapatkan banyak <strong>m *</strong> tupel: "Insiden", "Insiden yang Direkomendasikan", "Jarak". <br>  Di sini, "jarak" adalah metrik yang didefinisikan di NearestNeighbor.  Dalam model kami, ini adalah jarak cosinus.  Nilai "0" sesuai dengan kebetulan vektor yang lengkap. </p><br><h3 id="podbor-rasstoyaniya-otsechki">  Pemilihan "jarak cutoff" </h3><br><p>  Melengkapi serangkaian rekomendasi <strong>m * dengan</strong> informasi tentang estimasi sebenarnya dari <strong>v</strong> dari set awal estimasi <strong>m</strong> , kami memperoleh korespondensi antara jarak <strong>d</strong> dan estimasi sebenarnya dari <strong>v</strong> untuk model ini. </p><br><p>  Memiliki set ( <strong>d</strong> , <strong>v</strong> ), dimungkinkan untuk memilih level cutoff optimal <strong>t</strong> , yang untuk d &lt;= t rekomendasi akan menjadi "baik", dan untuk d&gt; t - "buruk".  Pemilihan t dapat dilakukan dengan mengoptimalkan penggolong biner paling sederhana <code>v = -1 if d&gt;t else 1</code> selain <code>v = -1 if d&gt;t else 1</code> berkenaan dengan t hiperparameter, dan menggunakan, misalnya, AUC ROC sebagai metrik. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     class BinarizerClassifier(Binarizer): def transform(self, x): return np.array([-1 if _x &gt; self.threshold else 1 for _x in np.array(x, dtype=float)]).reshape(-1, 1) def predict_proba(self, x): z = self.transform(x) return np.array([[0 if _x &gt; 0 else 1, 1 if _x &gt; 0 else 0] for _x in z.ravel()]) def predict(self, x): return self.transform(x) # #   : # -  , # -    m* # -   (d,v)  z_data_for_t # #   t b = BinarizerClassifier() z_x = z_data_for_t[['distance']] z_y = z_data_for_t['TYPE'] cv = GridSearchCV(b, param_grid={'threshold': np.arange(0.1, 0.7, 0.01)}, scoring='roc_auc', cv=5, iid=False, n_jobs=-1) cv.fit(z_x, z_y) score = cv.best_score_ t = cv.best_params_['threshold'] best_b = cv.best_estimator_</span></span></code> </pre> <br><p>  Nilai <strong>t yang</strong> diperoleh dapat digunakan untuk memfilter rekomendasi. </p><br><p>  Tentu saja, pendekatan ini masih bisa mengabaikan rekomendasi "buruk" dan memotong yang "baik".  Oleh karena itu, pada tahap ini kami selalu menunjukkan rekomendasi "Top 5", tetapi kami secara khusus menandai rekomendasi yang dianggap "baik", dengan mempertimbangkan <strong>t yang</strong> ditemukan. <br>  Alternatif: jika setidaknya satu rekomendasi "baik" ditemukan, maka tunjukkan hanya "baik".  Jika tidak, tunjukkan semua yang tersedia (juga - "N Top"). </p><br><h3 id="predpolozhenie-dlya-sravneniya-modeley">  Asumsi untuk membandingkan model </h3><br><p>  Untuk model pelatihan, kasus insiden yang sama digunakan. <br>  Misalkan jika rekomendasi "baik" sebelumnya ditemukan, maka model baru juga harus menemukan rekomendasi "baik" untuk kejadian yang sama.  Secara khusus, model baru dapat menemukan rekomendasi "baik" yang sama dengan yang lama.  Namun, dengan model baru, kami berharap bahwa jumlah rekomendasi "buruk" akan menjadi lebih sedikit. </p><br><p>  Kemudian, dengan mempertimbangkan indikator yang sama untuk rekomendasi <strong>m * dari</strong> model baru, mereka dapat dibandingkan dengan indikator yang sesuai untuk <strong>m</strong> .  Berdasarkan perbandingan, Anda dapat memilih model terbaik. </p><br><p>  Ada dua cara untuk memperhitungkan rekomendasi "baik" untuk perangkat <strong>m *</strong> : </p><br><ol><li>  berdasarkan <strong>t</strong> ditemukan: pertimbangkan bahwa semua rekomendasi dari <strong>m *</strong> dengan <strong>d</strong> &lt; <strong>t</strong> adalah "baik" dan memperhitungkannya untuk menghitung metrik </li><li>  berdasarkan estimasi sebenarnya yang sesuai dari himpunan <strong>m</strong> : dari rekomendasi <strong>m *,</strong> pilih hanya mereka yang ada estimasi benar dalam <strong>m</strong> , dan buang sisanya. </li></ol><br><p>  Dalam kasus pertama, indikator "absolut" ( <code>n_inc_good</code> , <code>n_rec_good</code> ) dari model baru harus lebih besar daripada untuk model dasar.  Dalam kasus kedua, indikator harus mendekati indikator model dasar. <br>  Masalah metode kedua: jika model baru lebih baik dari yang asli, dan ia menemukan sesuatu yang sebelumnya tidak diketahui, rekomendasi seperti itu tidak akan diperhitungkan dalam perhitungan. </p><br><h3 id="vybor-parametrov-sravneniya-modeley">  Pilih opsi perbandingan model </h3><br><p>  Saat memilih model baru, saya ingin indikator meningkat dibandingkan dengan model yang ada: </p><br><ul><li>  jumlah rata-rata rekomendasi "baik" per insiden ( <code>avg_inc_good</code> ) </li><li>  jumlah insiden yang ada rekomendasi "baik" ( <code>n_inc_good</code> ). </li></ul><br><p>  Untuk perbandingan dengan model asli, kami akan menggunakan hubungan parameter ini dari model baru dan asli.  Jadi, jika rasio parameter model baru dan lama lebih dari 1, model baru lebih baik. </p><br><pre> <code class="plaintext hljs">benchmark_agv_inc_good = avg_inc_good* / avg_inc_good benchmark_n_inc_good = n_inc_good* / n_inc_good</code> </pre> <br><p>  Untuk menyederhanakan pemilihan, lebih baik menggunakan parameter tunggal.  Kami mengambil rata-rata harmonik dari masing-masing indikator relatif dan menggunakannya sebagai satu-satunya kriteria kualitas komposit untuk model baru. </p><br><pre> <code class="plaintext hljs">composite = 2 / ( 1/benchmark_agv_inc_good + 1/benchmark_n_inc_good)</code> </pre> <br><h2 id="novaya-model-i-ee-optimizaciya">  Model baru dan pengoptimalannya </h2><br><p>  Untuk model baru, dalam vektor akhir yang mewakili insiden, tambahkan komponen yang bertanggung jawab untuk "area kejadian" (salah satu dari beberapa sistem yang dilayani oleh tim kami). <br>  Informasi tentang unit dan lokasi karyawan yang menciptakan insiden juga ditempatkan dalam komponen vektor yang terpisah.  Semua komponen memiliki bobotnya dalam vektor akhir. </p><br><pre> <code class="python hljs">p = Pipeline( steps=[ (<span class="hljs-string"><span class="hljs-string">'grp'</span></span>, ColumnTransformer( transformers=[ (<span class="hljs-string"><span class="hljs-string">'text'</span></span>, Pipeline(steps=[ (<span class="hljs-string"><span class="hljs-string">'pp'</span></span>, CommentsTextTransformer(n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span>)), (<span class="hljs-string"><span class="hljs-string">"tfidf"</span></span>, TfidfVectorizer(stop_words=get_stop_words(), ngram_range=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), max_features=<span class="hljs-number"><span class="hljs-number">10000</span></span>, min_df=<span class="hljs-number"><span class="hljs-number">0</span></span>)) ]), [<span class="hljs-string"><span class="hljs-string">'short_description'</span></span>, <span class="hljs-string"><span class="hljs-string">'comments'</span></span>] ), (<span class="hljs-string"><span class="hljs-string">'area'</span></span>, OneHotEncoder(handle_unknown=<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>), [<span class="hljs-string"><span class="hljs-string">'area'</span></span>] ), (<span class="hljs-string"><span class="hljs-string">'dept'</span></span>, OneHotEncoder(handle_unknown=<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>), [<span class="hljs-string"><span class="hljs-string">'u_impacted_department'</span></span>] ), (<span class="hljs-string"><span class="hljs-string">'loc'</span></span>, OneHotEncoder(handle_unknown=<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>), [<span class="hljs-string"><span class="hljs-string">'u_impacted_location'</span></span>] ) ], transformer_weights={<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span> )), (<span class="hljs-string"><span class="hljs-string">'norm'</span></span>, Normalizer()), (<span class="hljs-string"><span class="hljs-string">"nn"</span></span>, NearestNeighborsTransformer(n_neighbors=<span class="hljs-number"><span class="hljs-number">10</span></span>, metric=<span class="hljs-string"><span class="hljs-string">'cosine'</span></span>)) ], memory=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre> <br><p>  Model hiperparameter diharapkan mempengaruhi target model.  Dalam arsitektur model yang dipilih, kami akan mempertimbangkan sebagai hiperparameter: </p><br><ul><li>  Parameter vektorisasi TF-IDF - digunakan n-gram (ngram_range), ukuran kamus (max_features), mengemudi istilah minimum (min_df) </li><li>  kontribusi komponen pada vektor akhir - transformer_weights. </li></ul><br><p>  Nilai-nilai awal dari hyperparameters vektorisasi teks diambil dari model sebelumnya.  Bobot komponen awal dipilih berdasarkan penilaian ahli. </p><br><h3 id="cikl-podbora-parametrov">  Siklus pemilihan parameter </h3><br><p>  Cara membandingkan, memilih level misfire dan membandingkan model di antara mereka sendiri telah ditentukan.  Sekarang kita dapat melanjutkan ke optimasi melalui pemilihan hyperparameters. </p><br><p><img src="https://habrastorage.org/webt/zy/zy/kb/zyzykbygrls9ca0bjscn3usfqby.png" alt="Siklus optimisasi"></p><br><pre> <code class="python hljs">param_grid = { <span class="hljs-string"><span class="hljs-string">'grp__text__tfidf__ngram_range'</span></span>: [(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)], <span class="hljs-string"><span class="hljs-string">'grp__text__tfidf__max_features'</span></span>: [<span class="hljs-number"><span class="hljs-number">5000</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">20000</span></span>], <span class="hljs-string"><span class="hljs-string">'grp__text__tfidf__min_df'</span></span>: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0001</span></span>, <span class="hljs-number"><span class="hljs-number">0.0005</span></span>, <span class="hljs-number"><span class="hljs-number">0.001</span></span>], <span class="hljs-string"><span class="hljs-string">'grp__transformer_weights'</span></span>: [{<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>}], } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ParameterGrid(param_grid=param_grid): p.set_params(**param) p.fit(x) ...</code> </pre> <br><h3 id="rezultaty-optimizacii">  Hasil Optimasi </h3><br><p>  Tabel tersebut menunjukkan hasil percobaan di mana hasil yang menarik dicapai - 5 nilai terbaik dan terburuk untuk indikator yang dikendalikan. </p><br><p><img src="https://habrastorage.org/webt/bi/l2/tj/bil2tj8dbqexqtezwmxealh3imq.png"></p><br><p>  Sel-sel dengan indikator dalam tabel ditandai sebagai: </p><br><ul><li>  hijau tua adalah indikator terbaik di antara semua eksperimen </li><li>  hijau pucat - nilai indikator di atas-5 </li><li>  merah gelap - indikator terburuk di antara semua percobaan </li><li>  merah pucat - indikatornya ada di terburuk-5 </li></ul><br><p>  Indikator komposit terbaik diperoleh untuk model dengan parameter: </p><br><pre> <code class="plaintext hljs">ngram_range = (1,2) min_df = 0.0001 max_features = 20000 transformer_weights = {'text': 1, 'area': 1, 'dept': 0.1, 'loc': 0.1}</code> </pre> <br><p>  Model dengan parameter ini menunjukkan peningkatan indikator komposit dibandingkan dengan model asli 24% </p><br><h2 id="nekotorye-nablyudeniya-i-vyvody">  Beberapa pengamatan dan kesimpulan </h2><br><p>  Menurut hasil optimasi: </p><br><ol><li><p>  Menggunakan trigram ( <code>ngram_range = (1,3)</code> ) tampaknya tidak dibenarkan.  Mereka mengembang kamus dan sedikit meningkatkan akurasi dibandingkan dengan bigRAM. </p><br></li><li><p>  Perilaku yang menarik ketika membangun kamus hanya menggunakan bigrams ( <code>ngram_range = (2,2)</code> ): "akurasi" rekomendasi meningkat, dan jumlah rekomendasi yang ditemukan berkurang.  Sama seperti keseimbangan presisi / recall dalam pengklasifikasi.  Perilaku serupa diamati dalam pemilihan tingkat batas <strong>t</strong> - untuk bigrams â€œkerucutâ€ yang lebih sempit dan pemisahan yang lebih baik dari rekomendasi "baik" dan "buruk" adalah karakteristik. </p><br></li><li><p>  Parameter nol_ min_df, bersama dengan bigrams, meningkatkan akurasi rekomendasi.  Mereka mulai didasarkan pada istilah yang muncul setidaknya beberapa kali.  Ketika parameter meningkat, kamus mulai menyusut dengan cepat.  Untuk sampel kecil, seperti dalam kasus kami, mungkin akan lebih dimengerti untuk beroperasi dengan jumlah dokumen (nilai integer min_df) daripada fraksi dokumen (nilai fraksional min_df) yang mengandung istilah tersebut. </p><br></li><li><p>  Hasil yang baik diperoleh ketika atribut insiden yang bertanggung jawab untuk "wilayah" termasuk dalam vektor akhir dengan bobot sama dengan atau dekat dengan komponen teks.  Nilai yang rendah menyebabkan peningkatan proporsi rekomendasi "buruk" karena menemukan kata-kata serupa dalam dokumen dari bidang lain.  Tetapi tanda-tanda lokasi pelanggan tidak mempengaruhi hasil rekomendasi dengan baik dalam kasus kami. </p><br></li></ol><br><p>  Beberapa ide baru telah muncul: </p><br><ul><li>  tambahkan komponen "waktu" sehingga insiden terkini lebih diutamakan daripada insiden serupa. </li><li>  lihat bagaimana pengantar parameter max_df akan mempengaruhi - walaupun dengan tf-idf kata-kata yang terlalu umum untuk corpus seharusnya tidak memiliki bobot yang signifikan, menurut definisi. </li><li>  akhirnya mencoba cara lain untuk membuat vektor konten, misalnya, berdasarkan kata-ke-vektor, atau berdasarkan konvolusi pandangan tf-idf menggunakan jaringan. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472772/">https://habr.com/ru/post/id472772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472760/index.html">Kurangi waktu komputasi dari beberapa tahun menjadi beberapa menit. Memahami pembelajaran mesin kuantum</a></li>
<li><a href="../id472762/index.html">Analisis teknis eksploitasi checkm8</a></li>
<li><a href="../id472766/index.html">Parameterisasi dari file di py.test</a></li>
<li><a href="../id472768/index.html">Cara merekrut, memecat, dan kembali dari manajemen ke pengembangan: video dari Badoo Techleads Meetup # 5</a></li>
<li><a href="../id472770/index.html">Organisasi antarmuka dalam Persatuan dengan Kanvas UI</a></li>
<li><a href="../id472776/index.html">Cadangan Bagian 7: Kesimpulan</a></li>
<li><a href="../id472778/index.html">5 Cara Menggunakan Raspberry Pi</a></li>
<li><a href="../id472780/index.html">Mengapa menghindari teman, atau bagaimana saya kehilangan semua kelebihan saya</a></li>
<li><a href="../id472782/index.html">Mengapa 3D Headache / Bagian 8 Defocus dan masa depan 3D</a></li>
<li><a href="../id472790/index.html">Barang Antik: i-Mate Jasjar, seorang komunikator untuk bisnis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>