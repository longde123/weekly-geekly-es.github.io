<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏾 🧑🏼‍🤝‍🧑🏼 🕴🏽 OS1: un noyau primitif sur Rust pour x86. Partie 3. Carte mémoire, exception de défaut de page, tas et allocations 🛌🏼 🤗 👩🏻‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Première partie 
 Deuxième partie 


 Le sujet de la conversation d'aujourd'hui est de travailler avec la mémoire. Je vais parler de l'initialisation ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OS1: un noyau primitif sur Rust pour x86. Partie 3. Carte mémoire, exception de défaut de page, tas et allocations</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446214/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Première partie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Deuxième partie</a> </p><br><p>  Le sujet de la conversation d'aujourd'hui est de travailler avec la mémoire.  Je vais parler de l'initialisation du répertoire des pages, du mappage de la mémoire physique, de la gestion du virtuel et de mon tas d'organisation pour l'allocateur. </p><br><p>  Comme je l'ai dit dans le premier article, j'ai décidé d'utiliser des pages de 4 Mo pour me simplifier la vie et ne pas avoir à gérer de tableaux hiérarchiques.  À l'avenir, j'espère aller sur des pages de 4 Ko, comme la plupart des systèmes modernes.  Je pourrais en utiliser un prêt à l'emploi (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un tel allocateur de blocs</a> ), mais écrire le mien était un peu plus intéressant et je voulais comprendre un peu plus comment vit la mémoire, alors j'ai quelque chose à vous dire. </p><a name="habracut"></a><br><p> La dernière fois que j'ai opté pour la méthode setup_pd dépendante de l'architecture et que je voulais continuer, il y avait un autre détail que je n'avais pas couvert dans l'article précédent - la sortie VGA utilisant Rust et la macro println standard.  Étant donné que son implémentation est triviale, je vais le supprimer sous le spoiler.  Le code est dans le package de débogage. </p><br><div class="spoiler">  <b class="spoiler_title">Impression macro</b> <div class="spoiler_text"><pre><code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[macro_export]</span></span> <span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> print { ($($arg:tt)*) =&gt; ($crate::debug::_print(<span class="hljs-built_in"><span class="hljs-built_in">format_args!</span></span>($($arg)*))); } <span class="hljs-meta"><span class="hljs-meta">#[macro_export]</span></span> <span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> println { () =&gt; ($crate::<span class="hljs-built_in"><span class="hljs-built_in">print!</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)); ($($arg:tt)*) =&gt; ($crate::<span class="hljs-built_in"><span class="hljs-built_in">print!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}\n"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">format_args!</span></span>($($arg)*))); } <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_print</span></span></span></span>(args: core::fmt::Arguments) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> core::fmt::Write; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch::vga; vga::VGA_WRITER.lock().write_fmt(args).unwrap(); } <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86_64"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_print</span></span></span></span>(args: core::fmt::Arguments) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> core::fmt::Write; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch::vga; <span class="hljs-comment"><span class="hljs-comment">// vga::VGA_WRITER.lock().write_fmt(args).unwrap(); }</span></span></code> </pre> </div></div><br><p>  Maintenant, avec une conscience claire, je reviens à la mémoire. </p><br><h1 id="inicializaciya-direktorii-stranic">  Initialisation du répertoire de pages </h1><br><p>  Notre méthode kmain a pris trois arguments en entrée, dont l'un est l'adresse virtuelle de la table des pages.  Pour l'utiliser ultérieurement pour l'allocation et la gestion de la mémoire, vous devez désigner la structure des enregistrements et des répertoires.  Pour x86, le répertoire Page et la table Page sont assez bien décrits, je vais donc me limiter à une petite introduction.  L'entrée du répertoire Page est une structure de taille de pointeur, pour nous, elle est de 4 octets.  La valeur contient une adresse physique de 4 Ko de la page.  L'octet le moins significatif de l'enregistrement est réservé aux drapeaux.  Le mécanisme de conversion d'une adresse virtuelle en adresse physique ressemble à ceci (dans le cas de ma granularité de 4 Mo, le décalage se produit sur 22 bits. Pour les autres granularités, le décalage sera différent et des tableaux hiérarchiques seront utilisés!): </p><br><blockquote>  Adresse virtuelle 0xC010A110 -&gt; Obtenez l'index dans le répertoire en déplaçant l'adresse 22 bits vers la droite -&gt; index 0x300 -&gt; Obtenez l'adresse physique de la page par l'index 0x300, vérifiez les drapeaux et l'état -&gt; 0x1000000 -&gt; Prenez les 22 bits inférieurs de l'adresse virtuelle comme décalage, ajoutez à l'adresse physique de la page -&gt; 0x1000000 + 0x10A110 = adresse physique en mémoire 0x110A110 </blockquote><p>  Pour accélérer l'accès, le processeur utilise TLB - tampon de traduction de cache, qui met en cache les adresses de page. </p><br><p>  Alors, voici comment mon répertoire et ses entrées sont décrits, et la méthode très setup_pd est implémentée.  Pour écrire une page, la méthode «constructeur» est implémentée, qui garantit l'alignement de 4 Ko et la définition des drapeaux, ainsi qu'une méthode pour obtenir l'adresse physique de la page.  Un répertoire n'est qu'un tableau de 1024 entrées de quatre octets.  Le répertoire peut associer une adresse virtuelle à une page à l'aide de la méthode set_by_addr. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PDirectoryEntry</span></span></span></span>(<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PDirectoryEntry { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">by_phys_address</span></span></span></span>(address: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, flags: PDEntryFlags) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { PDirectoryEntry((address <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) &amp; ADDRESS_MASK | flags.bits()) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flags</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; PDEntryFlags { PDEntryFlags::from_bits_truncate(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_address</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &amp; ADDRESS_MASK } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbg</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PDirectory</span></span></span></span> { entries: [PDirectoryEntry; <span class="hljs-number"><span class="hljs-number">1024</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PDirectory { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">at</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; PDirectoryEntry { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.entries[idx] } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_by_addr</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, logical_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, entry: PDirectoryEntry) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set(PDirectory::to_idx(logical_addr), entry); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, entry: PDirectoryEntry) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.entries[idx] = entry; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { invalidate_page(idx); } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_logical_addr</span></span></span></span>(idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { (idx &lt;&lt; <span class="hljs-number"><span class="hljs-number">22</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_idx</span></span></span></span>(logical_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { (logical_addr &gt;&gt; <span class="hljs-number"><span class="hljs-number">22</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> PAGE_DIRECTORY: Mutex&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory&gt; = Mutex::new( <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(<span class="hljs-number"><span class="hljs-number">0xC0000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory) } ); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_pd</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> data = PAGE_DIRECTORY.lock(); *data = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(pd <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory); }</code> </pre> <br><p>  J'ai très maladroitement fait de l'initialisation statique initiale une adresse inexistante, donc je vous serais reconnaissant de m'écrire comment il est habituel dans la communauté Rust de faire de telles initialisations avec une réaffectation de liens. </p><br><p>  Maintenant que nous pouvons gérer les pages à partir de code de haut niveau, nous pouvons passer à la compilation de l'initialisation de la mémoire.  Cela se fera en deux étapes: par le traitement de la carte mémoire physique et l'initialisation du gestionnaire virtuel </p><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mb_magic { <span class="hljs-number"><span class="hljs-number">0x2BADB002</span></span> =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"multibooted v1, yeah, reading mb info"</span></span>); boot::init_with_mb1(mb_pointer); }, . . . . . . } memory::init();</code> </pre> <br><h1 id="karta-pamyati-grub-i-karta-fizicheskoy-pamyati-os1">  Carte mémoire GRUB et carte mémoire physique OS1 </h1><br><p>  Afin d'obtenir une carte mémoire de GRUB, au démarrage, j'ai mis le drapeau correspondant dans l'en-tête, et GRUB m'a donné l'adresse physique de la structure.  Je l'ai porté de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle</a> à la notation Rust, et j'ai également ajouté des méthodes pour itérer confortablement sur la carte mémoire.  La majeure partie de la structure GRUB ne sera pas remplie, et à ce stade, elle n'est pas très intéressante pour moi.  L'essentiel est que je ne souhaite pas déterminer manuellement la quantité de mémoire disponible. </p><br><p>  Lors de l'initialisation via Multiboot, nous convertissons d'abord l'adresse physique en virtuelle.  En théorie, GRUB peut positionner la structure n'importe où, donc si l'adresse s'étend au-delà de la page, vous devez allouer une page virtuelle dans le répertoire Page.  En pratique, la structure se situe presque toujours à côté du premier mégaoctet, que nous avons déjà alloué au démarrage.  Au cas où, nous vérifions l'indicateur de présence de la carte mémoire et procédons à son analyse. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> multiboot2; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> multiboot; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_pointer</span></span></span></span>(mb_pointer: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-comment"><span class="hljs-comment">//if in first 4 MB - map to kernel address space if mb_pointer &lt; 0x400000 { arch::KERNEL_BASE | mb_pointer } else { arch::paging::allocate_page(mb_pointer, arch::MB_INFO_BASE, arch::paging::PDEntryFlags::PRESENT | arch::paging::PDEntryFlags::WRITABLE | arch::paging::PDEntryFlags::HUGE_PAGE ); arch::MB_INFO_BASE | mb_pointer } } pub fn init_with_mb1(mb_pointer: usize) { let ln_pointer = unsafe { process_pointer(mb_pointer) }; println!("mb pointer 0x{:X}", ln_pointer); let mb_info = multiboot::from_ptr(ln_pointer); println!("mb flags: {:?}", mb_info.flags().unwrap()); if mb_info.flags().unwrap().contains(multiboot::MBInfoFlags::MEM_MAP) { multiboot::parse_mmap(mb_info); println!("Multiboot memory map parsed, physical memory map has been built"); } else { panic!("MB mmap is not presented"); } }</span></span></code> </pre> <br><p>  Une carte mémoire est une liste liée pour laquelle l'adresse physique initiale est spécifiée dans la structure de base (n'oubliez pas de tout traduire en virtuelle) et la taille du tableau en octets.  Vous devez parcourir la liste en fonction de la taille de chaque élément, car en <em>théorie,</em> leurs tailles peuvent différer.  Voici à quoi ressemble l'itération: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> MultibootInfo { . . . . . . <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_mmap</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, index: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry&gt; { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> crate::arch::get_mb_pointer_base; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> base: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = get_mb_pointer_base(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry = (base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..index { iter = ((iter <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) + ((*iter).size <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) + <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((iter <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) - base) &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_lenght) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {} } <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(iter) } }</code> </pre> <br><p>  Lors de l'analyse d'une carte mémoire, nous parcourons la structure GRUB et la convertissons en bitmap, avec lequel OS1 travaillera pour gérer la mémoire physique.  J'ai décidé de me limiter à un petit ensemble de valeurs disponibles pour le contrôle - libre, occupé, réservé, indisponible, bien que GRUB et BIOS fournissent plus d'options.  Ainsi, nous parcourons les entrées de la carte et convertissons leur état des valeurs GRUB / BIOS en valeurs pour OS1: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_mmap</span></span></span></span>(mbi: &amp;MultibootInfo) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> mmap_opt = mbi.get_mmap(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> i: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmap = mmap_opt.unwrap(); crate::memory::physical::map((*mmap).addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, (*mmap).len <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, translate_multiboot_mem_to_os1(&amp;(*mmap).mtype)); mmap_opt = mbi.get_mmap(i); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mmap_opt { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, _ =&gt; i += <span class="hljs-number"><span class="hljs-number">1</span></span>, } } } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translate_multiboot_mem_to_os1</span></span></span></span>(mtype: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> crate::memory::physical::{RESERVED, UNUSABLE, USABLE}; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mtype { &amp;MULTIBOOT_MEMORY_AVAILABLE =&gt; USABLE, &amp;MULTIBOOT_MEMORY_RESERVED =&gt; UNUSABLE, &amp;MULTIBOOT_MEMORY_ACPI_RECLAIMABLE =&gt; RESERVED, &amp;MULTIBOOT_MEMORY_NVS =&gt; UNUSABLE, &amp;MULTIBOOT_MEMORY_BADRAM =&gt; UNUSABLE, _ =&gt; UNUSABLE } }</code> </pre> <br><p>  La mémoire physique est gérée dans le module memory :: physical, pour lequel nous appelons la méthode map ci-dessus, en lui passant l'adresse de la région, sa longueur et son état.  Les 4 Go de mémoire potentiellement disponibles pour le système et divisés en quatre pages mégaoctets sont représentés par deux bits dans une image bitmap, ce qui vous permet de stocker 4 états pour 1024 pages.  Au total, cette construction prend 256 octets.  Un bitmap entraîne une terrible fragmentation de la mémoire, mais il est compréhensible et facile à implémenter, ce qui est la principale chose à faire. </p><br><p>  Je vais supprimer l'implémentation bitmap sous le spoiler afin de ne pas encombrer l'article.  La structure est capable de compter le nombre de classes et de mémoire libre, de marquer les pages par index et adresse, et également de rechercher des pages libres (cela sera nécessaire à l'avenir pour implémenter le tas).  La carte elle-même est un tableau de 64 éléments u32, pour isoler les deux bits (blocs) nécessaires, la conversion en soi-disant bloc (index dans le tableau, emballage de 16 blocs) et bloc (position du bit dans le bloc) est utilisée. </p><br><div class="spoiler">  <b class="spoiler_title">Bitmap de mémoire physique</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> USABLE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> USED: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RESERVED: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UNUSABLE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEAD: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0xDEAD</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PhysMemoryInfo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> total: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, used: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, reserved: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, chunks: [<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>; <span class="hljs-number"><span class="hljs-number">64</span></span>], } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PhysMemoryInfo { <span class="hljs-comment"><span class="hljs-comment">// returns (chunk, page) pub fn find_free(&amp;self) -&gt; (usize, usize) { for chunk in 0..64 { for page in 0.. 16 { if ((self.chunks[chunk] &gt;&gt; page * 2) &amp; 3) ^ 3 == 3 { return (chunk, page) } else {} } } (DEAD, 0) } // marks page to given flag and returns its address pub fn mark(&amp;mut self, chunk: usize, block: usize, flag: usize) -&gt; usize { self.chunks[chunk] = self.chunks[chunk] ^ (3 &lt;&lt; (block * 2)); let mask = (0xFFFFFFFC ^ flag).rotate_left(block as u32 * 2); self.chunks[chunk] = self.chunks[chunk] &amp; (mask as u32); if flag == USED { self.used += 1; } else if flag == UNUSABLE || flag == RESERVED { self.reserved += 1; } else { if self.used &gt; 0 { self.used -= 1; } } (chunk * 16 + block) &lt;&lt; 22 } pub fn mark_by_addr(&amp;mut self, addr: usize, flag: usize) { let block_num = addr &gt;&gt; 22; let chunk: usize = (block_num / 16) as usize; let block: usize = block_num - chunk * 16; self.mark(chunk, block, flag); } pub fn count_total(&amp; mut self) { let mut count: usize = 0; for i in 0..64 { let mut chunk = self.chunks[i]; for _j in 0..16 { if chunk &amp; 0b11 != 0b11 { count += 1; } chunk = chunk &gt;&gt; 2; } } self.total = count; } pub fn get_total(&amp;self) -&gt; usize { self.total } pub fn get_used(&amp;self) -&gt; usize { self.used } pub fn get_reserved(&amp;self) -&gt; usize { self.reserved } pub fn get_free(&amp;self) -&gt; usize { self.total - self.used - self.reserved } }</span></span></code> </pre> </div></div><br><p>  Et maintenant, nous sommes arrivés à l'analyse d'un élément de la carte.  Si un élément de carte décrit une zone mémoire inférieure à une page de 4 Mo ou égale à celle-ci, nous marquons cette page dans son ensemble.  Si plus - battez en morceaux de 4 Mo et marquez chaque morceau séparément par récursivité.  Au stade de l'initialisation du bitmap, nous considérons toutes les sections de mémoire inaccessibles, de sorte que lorsque la carte s'épuise, par exemple à 128 Mo, les sections restantes sont marquées comme inaccessibles. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> RAM_INFO: Mutex&lt;PhysMemoryInfo&gt; = Mutex::new(PhysMemoryInfo { total: <span class="hljs-number"><span class="hljs-number">0</span></span>, used: <span class="hljs-number"><span class="hljs-number">0</span></span>, reserved: <span class="hljs-number"><span class="hljs-number">0</span></span>, chunks: [<span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>; <span class="hljs-number"><span class="hljs-number">64</span></span>] }); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>(addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, len: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, flag: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// if len &lt;= 4MiB then mark whole page with flag if len &lt;= 4 * 1024 * 1024 { RAM_INFO.lock().mark_by_addr(addr, flag); } else { let pages: usize = len &gt;&gt; 22; for map_page in 0..(pages - 1) { map(addr + map_page &lt;&lt; 22, 4 * 1024 * 1024, flag); } map(addr + (pages &lt;&lt; 22), len - (pages &lt;&lt; 22), flag); } }</span></span></code> </pre> <br><h1 id="kucha-i-upravlenie-ey">  Tas et gestion d'elle </h1><br><p>  La gestion de la mémoire virtuelle est actuellement limitée à la gestion de tas, car le noyau n'en sait pas beaucoup plus.  À l'avenir, bien sûr, il sera nécessaire de gérer toute la mémoire, et ce petit gestionnaire sera réécrit.  Cependant, pour le moment, tout ce dont j'ai besoin est de la mémoire statique, qui contient le code exécutable et la pile, et de la mémoire de tas dynamique, où j'allouerai les structures pour le multithreading.  Nous allouons de la mémoire statique au démarrage (et jusqu'à présent, nous avons limité 4 Mo, car le noyau y tient) et en général, il n'y a plus de problème maintenant.  De plus, à ce stade, je n'ai pas d'appareils DMA, donc tout est extrêmement simple, mais compréhensible. </p><br><p>  J'ai donné 512 Mo de l'espace mémoire du noyau le plus élevé (0xE0000000) au tas, je stocke la carte d'utilisation du tas (0xDFC00000) 4 Mo plus bas.  J'utilise un bitmap pour décrire l'état, tout comme pour la mémoire physique, mais il n'y a que 2 états - occupé / libre.  La taille du bloc de mémoire est de 64 octets - c'est beaucoup pour de petites variables comme u32, u8, mais, peut-être, c'est optimal pour stocker des structures de données.  Pourtant, il est peu probable que nous ayons besoin de stocker des variables uniques sur le tas, maintenant son objectif principal est de stocker des structures de contexte pour le multitâche. </p><br><p>  Les blocs de 64 octets sont regroupés en structures qui décrivent l'état d'une page entière de 4 Mo, afin que nous puissions allouer des quantités de mémoire petites et grandes à plusieurs pages.  J'utilise les termes suivants: bloc - 64 octets, pack - 2 Ko (un u32 - 64 octets * 32 bits par package), page - 4 Mo. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(packed)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HeapPageInfo</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//every bit represents 64 bytes chunk of memory. 0 is free, 1 is busy //u32 size is 4 bytes, so page information total size is 8KiB pub _4mb_by_64b: [u32; 2048], } #[repr(packed)] #[derive(Copy, Clone)] struct HeapInfo { //Here we can know state of any 64 bit chunk in any of 128 4-MiB pages //Page information total size is 8KiB, so information about 128 pages requires 1MiB reserved data pub _512mb_by_4mb: [HeapPageInfo; 128], }</span></span></code> </pre> <br><p>  Lorsque je demande de la mémoire à un allocateur, je considère trois cas, selon la granularité: </p><br><ul><li>  Une demande de mémoire inférieure à 2 Ko est venue de l'allocateur.  Vous devez trouver un pack dans lequel il sera libre [taille / 64, tout reste différent de zéro ajoute un] morceaux consécutifs, marquez ces morceaux comme occupés, renvoyez l'adresse du premier morceau. </li><li>  Une demande est venue de l'allocateur pour une mémoire inférieure à 4 Mo, mais supérieure à 2 Ko.  Vous devez trouver une page qui a gratuitement [taille / 2048, tout reste différent de zéro ajoute un] packs d'affilée.  Marquez les packs [taille / 2048] comme occupés; s'il y a un reste, marquez les morceaux [restants] dans le dernier pack comme occupés. </li><li>  Une demande de mémoire de plus de 4 Mo est venue de l'allocateur.  Recherchez [taille / 4 Mi, tout solde différent de zéro ajoute une] pages de suite, marquez [taille / 4 Mi] pages comme occupées, s'il y a un solde - marquez [packs] comme étant occupé.  Dans le dernier pack, marquez le reste des morceaux comme occupé. </li></ul><br><p>  La recherche de zones libres dépend également de la granularité - un tableau est sélectionné pour l'itération ou les masques de bits.  Chaque fois que vous partez à l'étranger, OOM arrive.  Lors de la désallocation, un algorithme similaire est utilisé, uniquement pour le marquage libéré.  La mémoire libérée n'est pas réinitialisée.  Tout le code est gros, je vais le mettre sous le spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Bitmap de mémoire virtuelle</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//512 MiB should be enough for kernel heap. If not - ooops... pub const KHEAP_START: usize = 0xE0000000; //I will keep 1MiB info about my heap in separate 4MiB page before heap at this point pub const KHEAP_INFO_ADDR: usize = 0xDFC00000; pub const KHEAP_CHUNK_SIZE: usize = 64; pub fn init() { KHEAP_INFO.lock().init(); } #[repr(packed)] #[derive(Copy, Clone)] struct HeapPageInfo { //every bit represents 64 bytes chunk of memory. 0 is free, 1 is busy //u32 size is 4 bytes, so page information total size is 8KiB pub _4mb_by_64b: [u32; 2048], } impl HeapPageInfo { pub fn init(&amp;mut self) { for i in 0..2048 { self._4mb_by_64b[i] = 0; } } pub fn mark_chunks_used(&amp;mut self, _32pack: usize, chunk: usize, n: usize) { let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n) &lt;&lt; chunk; self._4mb_by_64b[_32pack] = self._4mb_by_64b[_32pack] | mask; } pub fn mark_chunks_free(&amp;mut self, _32pack: usize, chunk: usize, n: usize) { let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n) &lt;&lt; chunk; self._4mb_by_64b[_32pack] = self._4mb_by_64b[_32pack] ^ mask; } pub fn empty(&amp;self) -&gt; bool { for i in 0..2048 { if self._4mb_by_64b[i] != 0 { return false } } true } } #[repr(packed)] #[derive(Copy, Clone)] struct HeapInfo { //Here we can know state of any 64 bit chunk in any of 128 4-MiB pages //Page information total size is 8KiB, so information about 128 pages requires 1MiB reserved data pub _512mb_by_4mb: [HeapPageInfo; 128], } impl HeapInfo { pub fn init(&amp;mut self) { for i in 0..128 { self._512mb_by_4mb[i].init(); } } // returns page number pub fn find_free_pages_of_size(&amp;self, n: usize) -&gt; usize { if n &gt;= 128 { 0xFFFFFFFF } else { let mut start_page: usize = 0xFFFFFFFF; let mut current_page: usize = 0xFFFFFFFF; for page in 0..128 { if self._512mb_by_4mb[page].empty() { if current_page - start_page == n { return start_page } if start_page == 0xFFFFFFFF { start_page = page; } current_page = page; } else { start_page = 0xFFFFFFFF; current_page = 0xFFFFFFFF; } } 0xFFFFFFFF } } // returns (page number, 32pack number) pub fn find_free_packs_of_size(&amp;self, n: usize) -&gt; (usize, usize) { if n &lt; 2048 { for page in 0..128 { let mut start_pack: usize = 0xFFFFFFFF; let mut current_pack: usize = 0xFFFFFFFF; for _32pack in 0..2048 { let _32pack_info = self._512mb_by_4mb[page]._4mb_by_64b[_32pack]; if _32pack_info == 0 { if current_pack - start_pack == n { return (page, start_pack) } if start_pack == 0xFFFFFFFF { start_pack = _32pack; } current_pack = _32pack; } else { start_pack = 0xFFFFFFFF; current_pack = 0xFFFFFFFF; } } } (0xFFFFFFFF, 0xFFFFFFFF) } else { (0xFFFFFFFF, 0xFFFFFFFF) } } // returns (page number, 32pack number, chunk number) pub fn find_free_chunks_of_size(&amp;self, n: usize) -&gt; (usize, usize, usize) { if n &lt; 32 { for page in 0..128 { for _32pack in 0..2048 { let _32pack_info = self._512mb_by_4mb[page]._4mb_by_64b[_32pack]; let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n); for chunk in 0..(32-n) { if ((_32pack_info &gt;&gt; chunk) &amp; mask) ^ mask == mask { return (page, _32pack, chunk) } } } } (0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) } else { (0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) } } fn mark_chunks_used(&amp;mut self, page: usize, _32pack: usize, chunk: usize, n: usize) { self._512mb_by_4mb[page].mark_chunks_used(_32pack, chunk, n); } fn mark_chunks_free(&amp;mut self, page: usize, _32pack: usize, chunk: usize, n: usize) { self._512mb_by_4mb[page].mark_chunks_free(_32pack, chunk, n); } fn mark_packs_used(&amp;mut self, page: usize, _32pack:usize, n: usize) { for i in _32pack..(_32pack + n) { self._512mb_by_4mb[page]._4mb_by_64b[i] = 0xFFFFFFFF; } } fn mark_packs_free(&amp;mut self, page: usize, _32pack:usize, n: usize) { for i in _32pack..(_32pack + n) { self._512mb_by_4mb[page]._4mb_by_64b[i] = 0; } } } use lazy_static::lazy_static; use spin::Mutex; lazy_static! { static ref KHEAP_INFO: Mutex&lt;&amp;'static mut HeapInfo&gt; = Mutex::new(unsafe { &amp;mut *(KHEAP_INFO_ADDR as *mut HeapInfo) }); } fn allocate_n_chunks_less_than_pack(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let (page, _32pack, chunk) = heap_info.find_free_chunks_of_size(n); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page + _32pack * 32 * 64 + chunk * 64; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { heap_info.mark_chunks_used(page, _32pack, chunk, n); uptr as *mut u8 } else { core::ptr::null_mut() } } } fn allocate_n_chunks_less_than_page(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; let mut packs_to_alloc = packs_n; if lost_chunks != 0 { packs_to_alloc += 1; } let (page, pack) = heap_info.find_free_packs_of_size(packs_to_alloc); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page + pack * 32 * 64; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { heap_info.mark_packs_used(page, pack, packs_n); if lost_chunks != 0 { heap_info.mark_chunks_used(page, pack + packs_to_alloc, 0, lost_chunks); } uptr as *mut u8 } else { core::ptr::null_mut() } } } //unsupported yet fn allocate_n_chunks_more_than_page(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; let mut packs_to_alloc = packs_n; if lost_chunks != 0 { packs_to_alloc += 1; } let pages_n: usize = packs_to_alloc / 2048; let mut lost_packs = packs_to_alloc - pages_n * 2048; let mut pages_to_alloc = pages_n; if lost_packs != 0 { pages_to_alloc += 1; } if lost_chunks != 0 { lost_packs -= 1; } let page = heap_info.find_free_pages_of_size(pages_to_alloc); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B * n //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { for i in page..(page + pages_n) { heap_info.mark_packs_used(i, 0, 2048); } if lost_packs != 0 { heap_info.mark_packs_used(page + pages_to_alloc, 0, lost_packs); } if lost_chunks != 0 { heap_info.mark_chunks_used(page + pages_to_alloc, lost_packs, 0, lost_chunks); } uptr as *mut u8 } else { core::ptr::null_mut() } } } // returns pointer pub fn allocate_n_chunks(n: usize, align: usize) -&gt; *mut u8 { if n &lt; 32 { allocate_n_chunks_less_than_pack(n, align) } else if n &lt; 32 * 2048 { allocate_n_chunks_less_than_page(n, align) } else { allocate_n_chunks_more_than_page(n, align) } } pub fn free_chunks(ptr: usize, n: usize) { let page: usize = (ptr - KHEAP_START) / 0x400000; let _32pack: usize = ((ptr - KHEAP_START) - (page * 0x400000)) / (32 * 64); let chunk: usize = ((ptr - KHEAP_START) - (page * 0x400000) - (_32pack * (32 * 64))) / 64; let mut heap_info = KHEAP_INFO.lock(); if n &lt; 32 { heap_info.mark_chunks_free(page, _32pack, chunk, n); } else if n &lt; 32 * 2048 { let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; heap_info.mark_packs_free(page, _32pack, packs_n); if lost_chunks != 0 { heap_info.mark_chunks_free(page, _32pack + packs_n, 0, lost_chunks); } } else { let packs_n: usize = n / 32; let pages_n: usize = packs_n / 2048; let lost_packs: usize = packs_n - pages_n * 2048; let lost_chunks = n - packs_n * 32; for i in page..(page + pages_n) { heap_info.mark_packs_free(i, 0, 2048); } if lost_packs != 0 { heap_info.mark_packs_free(page + pages_n, 0, lost_packs); } if lost_chunks != 0 { heap_info.mark_chunks_free(page + pages_n, packs_n, 0, lost_chunks); } } }</span></span></code> </pre> </div></div><br><h1 id="allokaciya-i-page-fault">  Allocation et erreur de page </h1><br><p>  Pour utiliser le tas, vous avez besoin d'un allocateur.  L'ajout nous ouvrira un vecteur, des arbres, des tables de hachage, des boîtes et plus, sans lesquels il est presque impossible de vivre.  Dès que nous brancherons le module alloc et déclarerons un allocateur global, la vie deviendra immédiatement plus facile. </p><br><p>  La mise en œuvre de l'allocateur est très simple - elle se réfère simplement au mécanisme décrit ci-dessus. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> alloc::alloc::{GlobalAlloc, Layout}; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Os1Allocator</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Sync</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Os1Allocator {} <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GlobalAlloc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Os1Allocator { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alloc</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, layout: Layout) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::logical::{KHEAP_CHUNK_SIZE, allocate_n_chunks}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = layout.size(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chunk_count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size &gt; KHEAP_CHUNK_SIZE { chunk_count = size / KHEAP_CHUNK_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> KHEAP_CHUNK_SIZE * chunk_count != size { chunk_count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } allocate_n_chunks(chunk_count, layout.align()) } <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dealloc</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ptr: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, layout: Layout) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::logical::{KHEAP_CHUNK_SIZE, free_chunks}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = layout.size(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chunk_count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size &gt; KHEAP_CHUNK_SIZE { chunk_count = size / KHEAP_CHUNK_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> KHEAP_CHUNK_SIZE * chunk_count != size { chunk_count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } free_chunks(ptr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, chunk_count); } }</code> </pre> <br><p>  L'allocateur dans lib.rs est activé comme suit: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![feature(alloc, alloc_error_handler)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> alloc; <span class="hljs-meta"><span class="hljs-meta">#[global_allocator]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ALLOCATOR: memory::allocate::Os1Allocator = memory::allocate::Os1Allocator;</code> </pre> <br><p>  Et lorsque nous essayons de nous allouer simplement de cette manière, nous obtenons une exception de défaut de page, car nous n'avons pas encore défini l'allocation de mémoire virtuelle.  Eh bien, comment ça!  Eh bien, vous devez revenir à la matière de l'article précédent et ajouter des exceptions.  J'ai décidé d'implémenter l'allocation différée de mémoire virtuelle, c'est-à-dire que la page a été allouée non pas au moment de la demande de mémoire, mais au moment d'une tentative d'accès.  Heureusement, le processeur x86 le permet et l'encourage même.   Page fault     ,   ,    ,          —      ,     ,    CR2 —  ,    . </p><br><p>    ,      .        32 (     ,     ,     32 ),    .           Rust.           ,        .  ,   ,   iret    ,    ,     Page fault   Protection fault.        Protection fault — ,        . </p><br><pre> <code class="plaintext hljs">eE_page_fault: pushad mov eax, [esp + 32] push eax mov eax, cr2 push eax call kE_page_fault pop eax pop eax popad add esp, 4 iret</code> </pre> <br><p>  Rust         ,    .     ,     .            .            . </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">bitflags!</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PFErrorCode</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PROTECTION = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 - protection caused, 0 - not present page caused const WRITE = 1 &lt;&lt; 1; //1 - write caused, 0 - read caused const USER_MODE = 1 &lt;&lt; 2; //1 - from user mode, 0 - from kernel const RESERVED = 1 &lt;&lt; 3; //1 - reserved page (PAE/PSE), 0 - not const INSTRUCTION = 1 &lt;&lt; 4; //1 - instruction fetch caused, 0 - not } } impl PFErrorCode { pub fn to_pd_flags(&amp;self) -&gt; super::super::paging::PDEntryFlags { use super::super::paging; let mut flags = paging::PDEntryFlags::empty(); if self.contains(PFErrorCode::WRITE) { flags.set(paging::PDEntryFlags::WRITABLE, true); } if self.contains(PFErrorCode::USER_MODE) { flags.set(paging::PDEntryFlags::USER_ACCESSIBLE, true); } flags } } #[no_mangle] pub unsafe extern fn kE_page_fault(ptr: usize, code: usize) { use super::super::paging; println!("Page fault occured at addr 0x{:X}, code {:X}", ptr, code); let phys_address = crate::memory::physical::alloc_page(); let code_flags: PFErrorCode = PFErrorCode::from_bits(code).unwrap(); if !code_flags.contains(PFErrorCode::PROTECTION) { //page not presented, we need to allocate the new one let mut flags: paging::PDEntryFlags = code_flags.to_pd_flags(); flags.set(paging::PDEntryFlags::HUGE_PAGE, true); paging::allocate_page(phys_address, ptr, flags); println!("Page frame allocated at Paddr {:#X} Laddr {:#X}", phys_address, ptr); } else { panic!("Protection error occured, cannot handle yet"); } }</span></span></code> </pre> <br><p>        ,   .  ,       .           .          ,      .    ,      ,        : </p><br><pre> <code class="rust hljs"> <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"memory: total {} used {} reserved {} free {}"</span></span>, memory::physical::total(), memory::physical::used(), memory::physical::reserved(), memory::physical::free()); <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> alloc::vec::<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">1000000</span></span> { vec.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"vec len {}, ptr is {:?}"</span></span>, vec.len(), vec.as_ptr()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Still works, check reusage!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec2: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span> { vec2.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"vec2 len {}, ptr is {:?}, vec is still here? {}"</span></span>, vec2.len(), vec2.as_ptr(), vec.get(<span class="hljs-number"><span class="hljs-number">1000</span></span>).unwrap()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Still works!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"memory: total {} used {} reserved {} free {}"</span></span>, memory::physical::total(), memory::physical::used(), memory::physical::reserved(), memory::physical::free());</code> </pre> <br><p>     : <br><img src="https://habrastorage.org/webt/7x/y3/bs/7xy3bs8m91uxbmexphxpelzc2cs.jpeg" alt="Tas OS1"></p><br><p>  ,   ,           .          3,5  + 3 ,   .          3,5     . </p><br><p> IRQ 1    —        Alt + PrntScrn :) </p><br><p> ,    ,      Rust —       ,   —    ,    ! </p><br><p>       ,                . </p><br><p>  Merci de votre attention! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446214/">https://habr.com/ru/post/fr446214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446204/index.html">Prévision sur la manière dont les restrictions Internet seront surmontées</a></li>
<li><a href="../fr446206/index.html">Tutoriel React, partie 26: Architecture d'application, modèle de conteneur / composant</a></li>
<li><a href="../fr446208/index.html">Tutoriel React Partie 25: Atelier sur les formulaires</a></li>
<li><a href="../fr446210/index.html">ADAM-3600 - un contrôleur industriel multifonctionnel</a></li>
<li><a href="../fr446212/index.html">Profondeurs SIEM: corrélations prêtes à l'emploi. Partie 5. Méthodologie pour développer des règles de corrélation</a></li>
<li><a href="../fr446218/index.html">Le game designer n'est pas très différent d'un psycho. Comment nous avons créé le jeu CMAN</a></li>
<li><a href="../fr446222/index.html">Utilisation des potentiels thermiques pour l'analyse de territoire</a></li>
<li><a href="../fr446228/index.html">Améliorer la qualité de la classification des textes en connectant Wikipedia</a></li>
<li><a href="../fr446230/index.html">Surveillance et gestion à distance des périphériques basés sur Linux / OpenWrt / Lede via le port 80, suite</a></li>
<li><a href="../fr446234/index.html">Comment des bénévoles du monde entier créent des émissions en direct de l'ICPC-2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>