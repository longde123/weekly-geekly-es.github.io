<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📤 👨‍✈️ 🤵🏿 Indeks dalam PostgreSQL - 9 (BRIN) 😽 👩🏼 🙆🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel sebelumnya kita membahas mesin pengindeksan PostgreSQL, antarmuka metode akses, dan metode berikut: indeks hash , B-tree , GiST , SP-GiST...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indeks dalam PostgreSQL - 9 (BRIN)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452900/">  Pada artikel sebelumnya kita membahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin pengindeksan</a> PostgreSQL, antarmuka metode akses, dan metode berikut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indeks hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">B-tree</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SP-GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GIN</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RUM</a> .  Topik artikel ini adalah indeks BRIN. <br><br><h1>  Brin </h1><br><h2>  Konsep umum </h2><br>  Tidak seperti indeks yang telah kami kumpulkan, ide BRIN adalah untuk menghindari melihat-lihat baris yang tidak cocok daripada dengan cepat menemukan yang cocok.  Ini selalu merupakan indeks yang tidak akurat: ini tidak mengandung TIDs baris tabel sama sekali. <br><br>  Secara sederhana, BRIN berfungsi dengan baik untuk kolom yang nilainya berkorelasi dengan lokasi fisiknya dalam tabel.  Dengan kata lain, jika kueri tanpa klausa ORDER BY mengembalikan nilai kolom secara virtual dalam urutan kenaikan atau penurunan (dan tidak ada indeks pada kolom itu). <br><br>  Metode akses ini dibuat dalam lingkup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Axle</a> , proyek Eropa untuk database analitik yang sangat besar, dengan memperhatikan tabel yang beberapa terabyte atau puluhan terabyte besar.  Fitur penting dari BRIN yang memungkinkan kami membuat indeks pada tabel tersebut adalah ukuran kecil dan biaya pemeliharaan minimal. <br><br>  Ini berfungsi sebagai berikut.  Tabel ini dibagi menjadi <em>rentang</em> yang beberapa halaman besar (atau beberapa blok besar, yang sama) - maka namanya: Block Range Index, BRIN.  Indeks menyimpan <em>informasi ringkasan</em> tentang data di setiap rentang.  Sebagai aturan, ini adalah nilai minimal dan maksimal, tetapi kebetulan berbeda, seperti yang ditunjukkan lebih lanjut.  Asumsikan bahwa kueri dilakukan yang berisi kondisi untuk kolom;  jika nilai yang dicari tidak masuk ke dalam interval, seluruh rentang dapat dilewati;  tetapi jika mereka mendapatkan, semua baris di semua blok harus diperiksa untuk memilih yang cocok di antara mereka. <br><br>  Ini tidak akan menjadi kesalahan untuk memperlakukan BRIN bukan sebagai indeks, tetapi sebagai akselerator pemindaian sekuensial.  Kita dapat menganggap BRIN sebagai alternatif untuk mempartisi jika kita menganggap setiap rentang sebagai partisi "virtual". <br><br>  Sekarang mari kita bahas struktur indeks secara lebih rinci. <br><a name="habracut"></a><br><h2>  Struktur </h2><br>  Halaman pertama (lebih tepatnya, nol) berisi metadata. <br><br>  Halaman dengan informasi ringkasan terletak pada offset tertentu dari metadata.  Setiap baris indeks pada halaman tersebut berisi informasi ringkasan pada satu rentang. <br><br>  Antara halaman meta dan data ringkasan, halaman dengan <em>peta rentang terbalik</em> (disingkat "revmap") berada.  Sebenarnya, ini adalah array pointer (TIDs) ke baris indeks yang sesuai. <br><br><img src="https://habrastorage.org/webt/nr/pm/s9/nrpms932o5clzubwymywxtud6q4.png"><br><br>  Untuk beberapa rentang, penunjuk di "revmap" dapat menyebabkan tidak ada baris indeks (satu ditandai dengan warna abu-abu pada gambar).  Dalam kasus seperti itu, jangkauan dianggap belum memiliki informasi ringkasan. <br><br><h2>  Memindai indeks </h2><br>  Bagaimana indeks digunakan jika tidak mengandung referensi ke baris tabel?  Metode akses ini tentu saja tidak dapat mengembalikan baris TID oleh TID, tetapi dapat membangun bitmap.  Ada dua jenis halaman bitmap: akurat, ke baris, dan tidak akurat, ke halaman.  Ini adalah bitmap yang tidak akurat yang digunakan. <br><br>  Algoritma itu sederhana.  Peta rentang dipindai secara berurutan (yaitu, rentang tersebut dilalui sesuai urutan lokasi mereka dalam tabel).  Pointer digunakan untuk menentukan baris indeks dengan informasi ringkasan pada setiap rentang.  Jika rentang tidak mengandung nilai yang dicari, itu dilewati, dan jika itu dapat mengandung nilai (atau informasi ringkasan tidak tersedia), semua halaman rentang ditambahkan ke bitmap.  Bitmap yang dihasilkan kemudian digunakan seperti biasa. <br><br><h2>  Memperbarui indeks </h2><br>  Lebih menarik bagaimana indeks diperbarui ketika tabel diubah. <br><br>  Saat <strong>menambahkan</strong> versi baru baris ke halaman tabel, kami menentukan rentang mana yang terkandung di dalamnya dan menggunakan peta rentang untuk menemukan baris indeks dengan informasi ringkasan.  Semua ini adalah operasi aritmatika sederhana.  Biarkan, misalnya, ukuran rentang menjadi empat dan pada halaman 13, versi baris dengan nilai 42 muncul.  Jumlah rentang (dimulai dengan nol) adalah 13/4 = 3, oleh karena itu, dalam "revmap" kita mengambil pointer dengan offset 3 (nomor urutnya empat). <br><br>  Nilai minimum untuk rentang ini adalah 31, dan yang maksimal adalah 40. Karena nilai baru 42 berada di luar interval, kami memperbarui nilai maksimal (lihat gambar).  Tetapi jika nilai baru masih dalam batas yang disimpan, indeks tidak perlu diperbarui. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba7/6ce/e4c/ba76cee4c3d40e9f428954d0478ecee0.png"><br><br>  Semua ini berkaitan dengan situasi ketika versi halaman yang baru muncul dalam kisaran di mana informasi ringkasan tersedia.  Ketika indeks dibuat, informasi ringkasan dihitung untuk semua rentang yang tersedia, tetapi sementara tabel diperluas, halaman baru dapat terjadi yang berada di luar batas.  Dua opsi tersedia di sini: <br><br><ol><li>  Biasanya indeks tidak segera diperbarui.  Ini bukan masalah besar: seperti yang telah disebutkan, saat memindai indeks, seluruh rentang akan diperiksa.  Pembaruan aktual dilakukan selama "vakum", atau dapat dilakukan secara manual dengan memanggil fungsi "brin_summarize_new_values". </li><li> Jika kita membuat indeks dengan parameter "autosummarize", pembaruan akan segera dilakukan.  Tetapi ketika halaman rentang diisi dengan nilai-nilai baru, pembaruan dapat terjadi terlalu sering, oleh karena itu, parameter ini dimatikan secara default. </li></ol><br>  Ketika rentang baru terjadi, ukuran "revmap" dapat meningkat.  Setiap kali peta, yang terletak di antara halaman meta dan data ringkasan, perlu diperpanjang oleh halaman lain, versi baris yang ada dipindahkan ke beberapa halaman lain.  Jadi, peta rentang selalu berada di antara halaman meta dan data ringkasan. <br><br>  Ketika satu baris <strong>dihapus</strong> , ... tidak ada yang terjadi.  Kita dapat memperhatikan bahwa kadang-kadang nilai minimal atau maksimal akan dihapus, sehingga intervalnya dapat dikurangi.  Tetapi untuk mendeteksi ini, kita harus membaca semua nilai dalam kisaran, dan ini mahal. <br><br>  Keakuratan indeks tidak terpengaruh, tetapi pencarian mungkin memerlukan melihat lebih banyak rentang daripada yang sebenarnya dibutuhkan.  Secara umum, informasi ringkasan dapat secara manual dihitung ulang untuk zona seperti itu (dengan memanggil "brin_desummarize_range" dan "brin_summarize_new_values" fungsi), tetapi bagaimana kita dapat mendeteksi kebutuhan seperti itu?  Bagaimanapun, tidak ada prosedur konvensional yang tersedia untuk tujuan ini. <br><br>  Akhirnya, <strong>memperbarui baris</strong> hanyalah penghapusan dari versi yang sudah usang dan penambahan yang baru. <br><br><h2>  Contoh </h2><br>  Mari kita coba membangun gudang data mini kita sendiri untuk data dari tabel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">database demo</a> .  Mari kita asumsikan bahwa untuk tujuan pelaporan BI, diperlukan tabel denormalized untuk mencerminkan penerbangan yang berangkat dari bandara atau mendarat di bandara dengan akurasi kursi di kabin.  Data untuk setiap bandara akan ditambahkan ke tabel sekali sehari, saat tengah malam di zona waktu yang sesuai.  Data tidak akan diperbarui atau dihapus. <br><br>  Tabel akan terlihat sebagai berikut: <br><br><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> flights_bi( airport_code <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>), airport_coord <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- geo coordinates of airport airport_utc_offset interval, -- time zone flight_no char(6), -- flight number flight_type text. -- flight type: departure / arrival scheduled_time timestamptz, -- scheduled departure/arrival time of flight actual_time timestamptz, -- actual time of flight aircraft_code char(3), seat_no varchar(4), -- seat number fare_conditions varchar(10), -- travel class passenger_id varchar(20), passenger_name text );</span></span></code> </pre> <br>  Kami dapat mensimulasikan prosedur pemuatan data menggunakan nested loop: eksternal satu - per hari (oleh karena itu kami akan mempertimbangkan <a href="">basis data besar</a> , oleh karena itu 365 hari), dan zona loop - per waktu internal (dari UTC + 02 ke UTC + 12) .  Permintaannya cukup panjang dan tidak menarik, jadi saya akan menyembunyikannya di bawah spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Simulasi memuat data ke penyimpanan</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-symbol"><span class="pgsql"><span class="hljs-symbol">&lt;&lt;local&gt;&gt;</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">DECLARE</span></span></span><span class="pgsql"> curdate </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">date</span></span></span><span class="pgsql"> := (</span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> min(scheduled_departure) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> flights); utc_offset </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">interval</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHILE</span></span></span><span class="pgsql"> (curdate &lt;= bookings.now()::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">date</span></span></span><span class="pgsql">) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql"> utc_offset := </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">interval</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'12 hours'</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHILE</span></span></span><span class="pgsql"> (utc_offset &gt;= </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">interval</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'2 hours'</span></span></span><span class="pgsql">) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INSERT</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> flights_bi </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WITH</span></span></span><span class="pgsql"> flight ( airport_code, airport_coord, flight_id, flight_no, scheduled_time, actual_time, aircraft_code, flight_type ) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ( </span><span class="hljs-comment"><span class="pgsql"><span class="hljs-comment">--  SELECT a.airport_code, a.coordinates, f.flight_id, f.flight_no, f.scheduled_departure, f.actual_departure, f.aircraft_code, 'departure' FROM airports a, flights f, pg_timezone_names tzn WHERE a.airport_code = f.departure_airport AND f.actual_departure IS NOT NULL AND tzn.name = a.timezone AND tzn.utc_offset = local.utc_offset AND timezone(a.timezone, f.actual_departure)::date = curdate UNION ALL --  SELECT a.airport_code, a.coordinates, f.flight_id, f.flight_no, f.scheduled_arrival, f.actual_arrival, f.aircraft_code, 'arrival' FROM airports a, flights f, pg_timezone_names tzn WHERE a.airport_code = f.arrival_airport AND f.actual_arrival IS NOT NULL AND tzn.name = a.timezone AND tzn.utc_offset = local.utc_offset AND timezone(a.timezone, f.actual_arrival)::date = curdate ) SELECT f.airport_code, f.airport_coord, local.utc_offset, f.flight_no, f.flight_type, f.scheduled_time, f.actual_time, f.aircraft_code, s.seat_no, s.fare_conditions, t.passenger_id, t.passenger_name FROM flight f JOIN seats s ON s.aircraft_code = f.aircraft_code LEFT JOIN boarding_passes bp ON bp.flight_id = f.flight_id AND bp.seat_no = s.seat_no LEFT JOIN ticket_flights tf ON tf.ticket_no = bp.ticket_no AND tf.flight_id = bp.flight_id LEFT JOIN tickets t ON t.ticket_no = tf.ticket_no; RAISE NOTICE '%, %', curdate, utc_offset; utc_offset := utc_offset - interval '1 hour'; END LOOP; curdate := curdate + 1; END LOOP; END; $$</span></span></span></span>;</code> </pre><br></div></div><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi;</code> </pre><pre> <code class="plaintext hljs"> count ---------- 30517076 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 4127 MB (1 row)</code> </pre><br>  Kami mendapatkan 30 juta baris dan 4 GB.  Ukurannya tidak terlalu besar, tapi cukup bagus untuk laptop: pemindaian sekuensial memakan waktu sekitar 10 detik. <br><br><h3>  Pada kolom apa kita harus membuat indeks? </h3><br>  Karena indeks BRIN memiliki ukuran kecil dan biaya overhead sedang dan pembaruan jarang terjadi, jika ada, peluang langka muncul untuk membangun banyak indeks "berjaga-jaga", misalnya, di semua bidang tempat pengguna analis dapat membuat kueri ad-hoc mereka .  Tidak akan berguna - tidak masalah, tetapi bahkan indeks yang tidak terlalu efisien akan bekerja lebih baik daripada pemindaian berurutan pasti.  Tentu saja, ada bidang yang tidak berguna untuk membangun indeks;  akal sehat murni akan mendorong mereka. <br><br>  Tetapi seharusnya aneh membatasi diri pada nasihat ini, oleh karena itu, mari kita coba untuk menyatakan kriteria yang lebih akurat. <br><br>  Kami telah menyebutkan bahwa data harus berkorelasi dengan lokasi fisiknya.  Di sini masuk akal untuk diingat bahwa PostgreSQL mengumpulkan statistik kolom tabel, yang mencakup nilai korelasi.  Perencana menggunakan nilai ini untuk memilih antara pemindaian indeks reguler dan pemindaian bitmap, dan kita dapat menggunakannya untuk memperkirakan penerapan indeks BRIN. <br><br>  Dalam contoh di atas, data jelas dipesan berdasarkan hari (oleh "dijadwalkan_waktu", serta oleh "aktual_waktu" - tidak ada banyak perbedaan).  Ini karena ketika baris ditambahkan ke tabel (tanpa penghapusan dan pembaruan), mereka diletakkan dalam file satu demi satu.  Dalam simulasi pemuatan data, kami bahkan tidak menggunakan klausa ORDER BY, oleh karena itu, tanggal dalam satu hari dapat, secara umum, tercampur secara sewenang-wenang, tetapi pemesanan harus dilakukan.  Mari kita periksa ini: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> flights_bi; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> attname, correlation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename=<span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> correlation <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nulls last</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | correlation --------------------+------------- scheduled_time | 0.999994 actual_time | 0.999994 fare_conditions | 0.796719 flight_type | 0.495937 airport_utc_offset | 0.438443 aircraft_code | 0.172262 airport_code | 0.0543143 flight_no | 0.0121366 seat_no | 0.00568042 passenger_name | 0.0046387 passenger_id | -0.00281272 airport_coord | (12 rows)</code> </pre><br>  Nilai yang tidak terlalu dekat dengan nol (idealnya, mendekati plus-minus, seperti dalam kasus ini), memberi tahu kita bahwa indeks BRIN akan sesuai. <br><br>  Kelas perjalanan "fare_condition" (kolom berisi tiga nilai unik) dan jenis penerbangan "flight_type" (dua nilai unik) secara tak terduga tampaknya berada di tempat kedua dan ketiga.  Ini adalah ilusi: secara formal korelasinya tinggi, sementara sebenarnya pada beberapa halaman berturut-turut semua nilai yang mungkin akan ditemui pasti, yang berarti bahwa BRIN tidak akan berbuat baik. <br><br>  Zona waktu "airport_utc_offset" berlangsung berikutnya: dalam contoh yang dipertimbangkan, dalam siklus satu hari, bandara dipesan berdasarkan zona waktu "berdasarkan konstruksi". <br><br>  Dua bidang ini, zona waktu dan waktu, inilah yang akan kami eksperimen lebih lanjut. <br><br><h3>  Kemungkinan melemahnya korelasi </h3><br>  Korelasi tempat "dengan konstruksi" dapat dengan mudah dilemahkan ketika data diubah.  Dan masalahnya di sini bukanlah perubahan ke nilai tertentu, tetapi dalam struktur kontrol konkurensi multiversion: versi baris yang usang dihapus pada satu halaman, tetapi versi baru dapat dimasukkan di mana pun ruang kosong tersedia.  Karena itu, seluruh baris digabungkan selama pembaruan. <br><br>  Kami dapat mengontrol sebagian efek ini dengan mengurangi nilai parameter penyimpanan "fillfactor" dan dengan cara ini memberikan ruang kosong pada halaman untuk pembaruan di masa mendatang.  Tapi apakah kita ingin menambah ukuran meja yang sudah besar?  Selain itu, ini tidak menyelesaikan masalah penghapusan: mereka juga "mengatur jebakan" untuk baris baru dengan membebaskan ruang di suatu tempat di dalam halaman yang ada.  Karena ini, baris yang sebaliknya akan sampai ke akhir file, akan disisipkan di beberapa tempat sewenang-wenang. <br><br>  Ngomong-ngomong, ini adalah fakta yang aneh.  Karena indeks BRIN tidak mengandung referensi ke baris tabel, ketersediaannya tidak boleh menghalangi pembaruan HOT sama sekali, tetapi itu. <br><br>  Jadi, BRIN terutama dirancang untuk tabel ukuran besar dan bahkan sangat besar yang tidak diperbarui sama sekali atau diperbarui sangat sedikit.  Namun, ini sangat cocok dengan penambahan baris baru (sampai akhir tabel).  Ini tidak mengherankan karena metode akses ini dibuat dengan maksud untuk gudang data dan pelaporan analitis. <br><br><h3>  Ukuran rentang apa yang perlu kita pilih? </h3><br>  Jika kita berurusan dengan tabel terabyte, perhatian utama kita ketika memilih ukuran rentang mungkin tidak akan membuat indeks BRIN terlalu besar.  Namun, dalam situasi kami, kami dapat menganalisis data dengan lebih akurat. <br><br>  Untuk melakukan ini, kita dapat memilih nilai unik suatu kolom dan melihat pada berapa banyak halaman yang muncul.  Pelokalan nilai meningkatkan peluang keberhasilan dalam menerapkan indeks BRIN.  Selain itu, jumlah halaman yang ditemukan akan meminta ukuran rentang.  Tetapi jika nilainya "tersebar" di semua halaman, BRIN tidak berguna. <br><br>  Tentu saja, kita harus menggunakan teknik ini untuk mengawasi struktur internal data.  Sebagai contoh, tidak masuk akal untuk mempertimbangkan setiap tanggal (lebih tepatnya, cap waktu, juga termasuk waktu) sebagai nilai unik - kita perlu membulatkannya menjadi beberapa hari. <br><br>  Secara teknis, analisis ini dapat dilakukan dengan melihat nilai kolom "ctid" tersembunyi, yang menyediakan penunjuk ke versi baris (TID): jumlah halaman dan jumlah baris di dalam halaman.  Sayangnya, tidak ada teknik konvensional untuk mengurai TID menjadi dua komponennya, oleh karena itu, kita harus membuang tipe melalui representasi teks: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> min(numblk), round(avg(numblk)) avg, max(numblk) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(<span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> (ctid::<span class="hljs-type"><span class="hljs-type">text</span></span>::<span class="hljs-type"><span class="hljs-type">point</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]) numblk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> scheduled_time::<span class="hljs-type"><span class="hljs-type">date</span></span> ) t;</code> </pre><pre> <code class="plaintext hljs"> min | avg | max ------+------+------ 1192 | 1500 | 1796 (1 row)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname = <span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 528172 (1 row)</code> </pre><br>  Kita dapat melihat bahwa setiap hari didistribusikan secara merata di seluruh halaman, dan hari-hari sedikit tercampur satu sama lain (1500 &amp; kali 365 = 547500, yang hanya sedikit lebih besar dari jumlah halaman pada tabel 528172).  Ini sebenarnya jelas "dengan konstruksi". <br><br>  Informasi berharga di sini adalah jumlah halaman tertentu.  Dengan ukuran rentang konvensional 128 halaman, setiap hari akan mengisi rentang 9-14.  Ini tampaknya realistis: dengan permintaan untuk hari tertentu, kami dapat mengharapkan kesalahan sekitar 10%. <br><br>  Mari kita coba: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> brin(scheduled_time);</code> </pre><br>  Ukuran indeks sekecil 184 KB: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 184 kB (1 row)</code> </pre><br>  Dalam hal ini, hampir tidak masuk akal untuk meningkatkan ukuran kisaran dengan mengorbankan kehilangan keakuratan.  Tetapi kita dapat mengurangi ukuran jika diperlukan, dan keakuratannya akan, sebaliknya, meningkat (bersama dengan ukuran indeks). <br><br>  Sekarang mari kita lihat zona waktu.  Di sini kita juga tidak bisa menggunakan pendekatan brute-force.  Semua nilai harus dibagi dengan jumlah siklus hari sebagai gantinya karena distribusi diulang dalam setiap hari.  Selain itu, karena hanya ada beberapa zona waktu saja, kita dapat melihat seluruh distribusi: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> airport_utc_offset, count(<span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> (ctid::<span class="hljs-type"><span class="hljs-type">text</span></span>::<span class="hljs-type"><span class="hljs-type">point</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>])/<span class="hljs-number"><span class="hljs-number">365</span></span> numblk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> airport_utc_offset <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> airport_utc_offset | numblk --------------------+-------- 12:00:00 | 6 06:00:00 | 8 02:00:00 | 10 11:00:00 | 13 08:00:00 | 28 09:00:00 | 29 10:00:00 | 40 04:00:00 | 47 07:00:00 | 110 05:00:00 | 231 03:00:00 | 932 (11 rows)</code> </pre><br>  Rata-rata, data untuk setiap zona waktu mengisi 133 halaman sehari, tetapi distribusinya sangat tidak seragam: Petropavlovsk-Kamchatskiy dan Anadyr cocok hanya dengan enam halaman, sedangkan Moskow dan lingkungannya membutuhkan ratusan halaman.  Ukuran default rentang tidak baik di sini;  mari, misalnya, atur menjadi empat halaman. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> brin(airport_utc_offset) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (pages_per_range=<span class="hljs-number"><span class="hljs-number">4</span></span>); demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_airport_utc_offset_idx'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 6528 kB (1 row)</code> </pre><br><h2>  Rencana eksekusi </h2><br>  Mari kita lihat bagaimana indeks kita bekerja.  Mari kita pilih suatu hari, katakanlah, seminggu yang lalu (dalam database demo, "hari ini" ditentukan oleh fungsi "booking.now"): <br><br><pre> <code class="pgsql hljs">demo=# \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> d <span class="hljs-string"><span class="hljs-string">'bookings.now()::date - interval \'</span></span><span class="hljs-number"><span class="hljs-number">7</span></span> days\<span class="hljs-string"><span class="hljs-string">''</span></span> demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduled_time &gt;= :d <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> scheduled_time &lt; :d + <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=10.282..94.328 rows=83954 loops=1) Recheck Cond: ... Rows Removed by Index Recheck: 12045 Heap Blocks: lossy=1664 -&gt; Bitmap Index Scan on flights_bi_scheduled_time_idx (actual time=3.013..3.013 rows=16640 loops=1) Index Cond: ... Planning time: 0.375 ms Execution time: 97.805 ms</code> </pre><br>  Seperti yang bisa kita lihat, perencana menggunakan indeks yang dibuat.  Seberapa akurat?  Rasio jumlah baris yang memenuhi persyaratan kueri ("baris" dari Bitmap Heap Scan node) dengan total jumlah baris yang dikembalikan menggunakan indeks (nilai yang sama ditambah Baris Dihapus oleh Index Recheck) memberi tahu kita tentang hal ini.  Dalam hal ini 83954 / (83954 + 12045), yaitu sekitar 90%, seperti yang diharapkan (nilai ini akan berubah dari satu hari ke hari lain). <br><br>  Dari mana asal 16640 dalam "baris aktual" dari Bitmap Index Scan node berasal?  Masalahnya adalah bahwa simpul rencana ini membangun bitmap (halaman demi halaman) yang tidak akurat dan sama sekali tidak mengetahui berapa banyak baris bitmap yang akan disentuh, sementara sesuatu perlu ditunjukkan.  Karena itu, dalam keputusasaan satu halaman diasumsikan mengandung 10 baris.  Bitmap berisi total 1664 halaman (nilai ini ditunjukkan dalam "Heap Blocks: lossy = 1664");  jadi, kita baru mendapatkan 16640. Secara keseluruhan, ini adalah angka yang tidak masuk akal, yang seharusnya tidak kita perhatikan. <br><br>  Bagaimana dengan bandara?  Sebagai contoh, mari kita ambil zona waktu Vladivostok, yang memuat 28 halaman sehari: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> airport_utc_offset = <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'8 hours'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=75.151..192.210 rows=587353 loops=1) Recheck Cond: (airport_utc_offset = '08:00:00'::interval) Rows Removed by Index Recheck: 191318 Heap Blocks: lossy=13380 -&gt; Bitmap Index Scan on flights_bi_airport_utc_offset_idx (actual time=74.999..74.999 rows=133800 loops=1) Index Cond: (airport_utc_offset = '08:00:00'::interval) Planning time: 0.168 ms Execution time: 212.278 ms</code> </pre><br>  Perencana lagi menggunakan indeks BRIN yang dibuat.  Akurasinya lebih buruk (sekitar 75% dalam kasus ini), tetapi ini diharapkan karena korelasinya lebih rendah. <br><br>  Beberapa indeks BRIN (sama seperti yang lain) tentu saja dapat digabungkan di tingkat bitmap.  Misalnya, berikut ini adalah data pada zona waktu yang dipilih selama sebulan (perhatikan simpul "BitmapAnd"): <br><br><pre> <code class="pgsql hljs">demo=# \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> d <span class="hljs-string"><span class="hljs-string">'bookings.now()::date - interval \'</span></span><span class="hljs-number"><span class="hljs-number">60</span></span> days\<span class="hljs-string"><span class="hljs-string">''</span></span> demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduled_time &gt;= :d <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> scheduled_time &lt; :d + <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'30 days'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> airport_utc_offset = <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'8 hours'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=62.046..113.849 rows=48154 loops=1) Recheck Cond: ... Rows Removed by Index Recheck: 18856 Heap Blocks: lossy=1152 -&gt; BitmapAnd (actual time=61.777..61.777 rows=0 loops=1) -&gt; Bitmap Index Scan on flights_bi_scheduled_time_idx (actual time=5.490..5.490 rows=435200 loops=1) Index Cond: ... -&gt; Bitmap Index Scan on flights_bi_airport_utc_offset_idx (actual time=55.068..55.068 rows=133800 loops=1) Index Cond: ... Planning time: 0.408 ms Execution time: 115.475 ms</code> </pre><br><h3>  Perbandingan dengan b-tree </h3><br>  Bagaimana jika kita membuat indeks B-tree reguler pada bidang yang sama dengan BRIN? <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_bi_scheduled_time_btree <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi(scheduled_time); demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_btree'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 654 MB (1 row)</code> </pre><br>  Tampaknya <em>beberapa ribu kali lebih besar</em> dari BRIN kami!  Namun, kueri dilakukan sedikit lebih cepat: perencana menggunakan statistik untuk mengetahui bahwa data dipesan secara fisik dan tidak diperlukan untuk membangun bitmap dan, terutama, kondisi indeks tidak perlu diperiksa ulang: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduled_time &gt;= :d <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> scheduled_time &lt; :d + <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------- Index Scan using flights_bi_scheduled_time_btree on flights_bi (actual time=0.099..79.416 rows=83954 loops=1) Index Cond: ... Planning time: 0.500 ms Execution time: 85.044 ms</code> </pre><br>  Itulah yang sangat luar biasa dari BRIN: kami mengorbankan efisiensinya, tetapi mendapatkan banyak ruang. <br><br><h2>  Kelas operator </h2><br><h3>  minmax </h3><br>  Untuk tipe data yang nilainya dapat dibandingkan satu sama lain, informasi ringkasan terdiri dari <em>nilai minimal dan maksimal</em> .  Nama-nama kelas operator yang sesuai berisi "minmax", misalnya, "date_minmax_ops".  Sebenarnya, ini adalah tipe data yang kami pertimbangkan sejauh ini, dan sebagian besar tipe dari jenis ini. <br><br><h3>  inklusif </h3><br>  Operator perbandingan tidak ditentukan untuk semua tipe data.  Misalnya, mereka tidak didefinisikan untuk titik (tipe "titik"), yang mewakili koordinat geografis bandara.  Omong-omong, karena alasan inilah statistik tidak menunjukkan korelasi untuk kolom ini. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> attname, correlation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename=<span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> attname = <span class="hljs-string"><span class="hljs-string">'airport_coord'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | correlation ---------------+------------- airport_coord | (1 row)</code> </pre><br>  Tetapi banyak dari jenis-jenis tersebut memungkinkan kita untuk memperkenalkan konsep "daerah pembatas", misalnya, persegi panjang pembatas untuk bentuk geometris.  Kami membahas secara rinci bagaimana indeks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GiST</a> menggunakan fitur ini.  Demikian pula, BRIN juga memungkinkan pengumpulan informasi ringkasan pada kolom yang memiliki tipe data seperti ini: <em>area pembatas untuk semua nilai di dalam rentang</em> hanyalah nilai ringkasan. <br><br>  Tidak seperti untuk GiST, nilai ringkasan untuk BRIN harus dari jenis yang sama dengan nilai yang diindeks.  Oleh karena itu, kami tidak dapat membuat indeks untuk poin, walaupun jelas bahwa koordinat tersebut dapat berfungsi di BRIN: garis bujur terkait erat dengan zona waktu.  Untungnya, tidak ada yang menghalangi pembuatan indeks pada ekspresi setelah mengubah poin menjadi persegi panjang yang merosot.  Pada saat yang sama, kami akan mengatur ukuran rentang menjadi satu halaman, hanya untuk menunjukkan batas kasus: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> brin (box(airport_coord)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (pages_per_range=<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Ukuran indeks sekecil 30 MB bahkan dalam situasi ekstrem seperti ini: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_box_idx'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 30 MB (1 row)</code> </pre><br>  Sekarang kita dapat membuat kueri yang membatasi bandara dengan koordinat.  Sebagai contoh: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> airport_code, airport_name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> airports <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(coordinates) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> airport_code | airport_name --------------+----------------- KHV | Khabarovsk-Novyi VVO | Vladivostok (2 rows)</code> </pre><br>  Perencana akan, bagaimanapun, menolak untuk menggunakan indeks kami. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> flights_bi; demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(airport_coord) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Seq Scan on flights_bi (cost=0.00..985928.14 rows=30517 width=111) Filter: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box)</code> </pre><br>  Mengapa  Mari kita nonaktifkan pemindaian berurutan dan lihat apa yang terjadi: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(airport_coord) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (cost=14079.67..1000007.81 rows=30517 width=111) Recheck Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) -&gt; Bitmap Index Scan on flights_bi_box_idx (cost=0.00..14072.04 rows=30517076 width=0) Index Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box)</code> </pre><br>  Tampaknya indeks <em>dapat</em> digunakan, tetapi perencana menduga bahwa bitmap harus dibangun di atas seluruh tabel (lihat "baris" dari simpul Pemindaian Bitmap Index), dan tidak heran bahwa perencana memilih pemindaian berurutan dalam kasus ini.  Masalahnya di sini adalah untuk tipe geometris, PostgreSQL tidak mengumpulkan statistik apa pun, dan perencana harus membabi buta: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'flights_bi_box_idx'</span></span> \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------+------------------- schemaname | bookings tablename | flights_bi_box_idx attname | box inherited | f null_frac | 0 avg_width | 32 n_distinct | 0 most_common_vals | most_common_freqs | histogram_bounds | correlation | most_common_elems | most_common_elem_freqs | elem_count_histogram |</code> </pre><br>  Sayang  Tetapi tidak ada keluhan tentang indeks - itu berfungsi dan berfungsi dengan baik: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(airport_coord) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=158.142..315.445 rows=781790 loops=1) Recheck Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) Rows Removed by Index Recheck: 70726 Heap Blocks: lossy=14772 -&gt; Bitmap Index Scan on flights_bi_box_idx (actual time=158.083..158.083 rows=147720 loops=1) Index Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) Planning time: 0.137 ms Execution time: 340.593 ms</code> </pre><br>  Kesimpulannya harus seperti ini: PostGIS diperlukan jika ada sesuatu yang nontrivial diperlukan dari geometri.  Itu bisa mengumpulkan statistik. <br><br><h2>  Internal </h2><br>  Ekstensi konvensional "pageinspect" memungkinkan kita untuk melihat ke dalam indeks BRIN. <br><br>  Pertama, metainformation akan meminta kita ukuran rentang dan berapa banyak halaman yang dialokasikan untuk "revmap": <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> magic | version | pagesperrange | lastrevmappage ------------+---------+---------------+---------------- 0xA8109CFA | 1 | 128 | 3 (1 row)</code> </pre><br>  Halaman 1-3 di sini dialokasikan untuk "revmap", sementara sisanya berisi data ringkasan.  Dari "revmap" kita bisa mendapatkan referensi ke data ringkasan untuk setiap rentang.  Katakanlah, informasi pada rentang pertama, menggabungkan 128 halaman pertama, terletak di sini: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_revmap_data(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pages --------- (6,197) (1 row)</code> </pre><br>  Dan ini adalah data ringkasan itu sendiri: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> allnulls, hasnulls, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_page_items( get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> itemoffset = <span class="hljs-number"><span class="hljs-number">197</span></span>;</code> </pre><pre> <code class="plaintext hljs"> allnulls | hasnulls | value ----------+----------+---------------------------------------------------- f | f | {2016-08-15 02:45:00+03 .. 2016-08-15 17:15:00+03} (1 row)</code> </pre><br>  Rentang selanjutnya: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_revmap_data(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pages --------- (6,198) (1 row)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> allnulls, hasnulls, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_page_items( get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> itemoffset = <span class="hljs-number"><span class="hljs-number">198</span></span>;</code> </pre><pre> <code class="plaintext hljs"> allnulls | hasnulls | value ----------+----------+---------------------------------------------------- f | f | {2016-08-15 06:00:00+03 .. 2016-08-15 18:55:00+03} (1 row)</code> </pre><br>  Dan sebagainya. <br><br>  Untuk kelas "inklusi", bidang "nilai" akan menampilkan sesuatu seperti <br><br><pre> <code class="plaintext hljs"> {(94.4005966186523,69.3110961914062),(77.6600036621,51.6693992614746) .. f .. f}</code> </pre><br>  Nilai pertama adalah persegi panjang penyematan, dan huruf "f" pada akhirnya menunjukkan kekurangan elemen kosong (yang pertama) dan tidak memiliki nilai yang tidak dapat digabungkan (yang kedua).  Sebenarnya, satu-satunya nilai yang tidak dapat digabungkan adalah alamat "IPv4" dan "IPv6" (tipe data "inet"). <br><br><h2>  Properti </h2><br>  Mengingatkan Anda pada pertanyaan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telah disediakan</a> . <br><br>  Berikut ini adalah properti dari metode akses: <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- brin | can_order | f brin | can_unique | f brin | can_multi_col | t brin | can_exclude | f</code> </pre><br>  Indeks dapat dibuat di beberapa kolom.  Dalam hal ini, statistik ringkasannya dikumpulkan untuk setiap kolom, tetapi statistik tersebut disimpan bersama untuk setiap rentang.  Tentu saja, indeks ini masuk akal jika satu dan ukuran rentang yang sama cocok untuk semua kolom. <br><br>  Properti lapisan indeks berikut tersedia: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  Terbukti, hanya pemindaian bitmap yang didukung. <br><br>  Namun, kurangnya pengelompokan mungkin tampak membingungkan.  Tampaknya, karena indeks BRIN sensitif terhadap urutan fisik baris, akan logis untuk dapat mengelompokkan data sesuai dengan indeks.  Tapi ini tidak benar.  Kami hanya dapat membuat indeks "biasa" (B-tree atau GiST, tergantung pada tipe data) dan mengelompokkannya.  Omong-omong, apakah Anda ingin mengelompokkan tabel yang seharusnya besar dengan mempertimbangkan kunci eksklusif, waktu eksekusi, dan konsumsi ruang disk selama pembangunan kembali? <br><br>  Berikut ini adalah properti layer-kolom: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | t</code> </pre><br>  Satu-satunya properti yang tersedia adalah kemampuan untuk memanipulasi NULL. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca terus</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452900/">https://habr.com/ru/post/id452900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452886/index.html">Proyek Wiki dan nama Noosphere di HACKNOWLEGE</a></li>
<li><a href="../id452888/index.html">Dekat Munich mulai menguji tiltrotor lima-kursi Lilium Jet ukuran penuh</a></li>
<li><a href="../id452890/index.html">23 Mei 18:30 - siaran langsung QIWI Kitchen</a></li>
<li><a href="../id452892/index.html">Bagaimana cara non-programmer pindah ke AS: petunjuk langkah demi langkah</a></li>
<li><a href="../id452894/index.html">Face Anti-Spoofing atau secara teknis mengenali penipu dari seribu wajah</a></li>
<li><a href="../id452902/index.html">Menyelesaikan pelatihan 4 tahun sebagai programmer, saya mengerti bahwa saya jauh dari seorang programmer</a></li>
<li><a href="../id452904/index.html">Bagaimana mesin berkomunikasi - protokol MQTT</a></li>
<li><a href="../id452906/index.html">Mesin JavaScript: bagaimana cara kerjanya? Dari tumpukan panggilan ke janji-janji, (hampir) semua yang perlu Anda ketahui</a></li>
<li><a href="../id452908/index.html">Selenium WebDriver - Metrik uji waktu-nyata menggunakan Grafana dan InfluxDB</a></li>
<li><a href="../id452910/index.html">Halo, Habr! Halo Tercon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>