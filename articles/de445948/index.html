<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐇 👰🏽 😖 Vererbung in C ++: Anfänger, Mittelstufe, Fortgeschrittene 👩🏿‍💼 🌄 🍁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel beschreibt die Vererbung auf drei Ebenen: Anfänger, Mittelstufe und Fortgeschrittene. Experte Nr. Und kein Wort über SOLID. Ehrlich ges...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vererbung in C ++: Anfänger, Mittelstufe, Fortgeschrittene</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445948/"><p> Dieser Artikel beschreibt die Vererbung auf drei Ebenen: Anfänger, Mittelstufe und Fortgeschrittene.  Experte Nr.  Und kein Wort über SOLID.  Ehrlich gesagt. </p><br><h1 id="beginner">  Anfänger </h1><br><h3 id="chto-takoe-nasledovanie">  Was ist Vererbung? </h3><br><p>  Vererbung ist eines der Grundprinzipien von OOP.  Demnach kann eine Klasse die Variablen und Methoden einer anderen Klasse als ihre eigenen verwenden. </p><br><p>  Eine Klasse, die Daten erbt, wird als Unterklasse, abgeleitete Klasse oder untergeordnete Klasse bezeichnet.  Die Klasse, von der Daten oder Methoden geerbt werden, wird als Superklasse, Basisklasse oder übergeordnete Klasse bezeichnet.  Die Begriffe "Eltern" und "Kind" sind äußerst nützlich für das Verständnis der Vererbung.  Wenn ein Kind die Merkmale seiner Eltern erhält, erhält die abgeleitete Klasse die Methoden und Variablen der Basisklasse. </p><br><p>  Vererbung ist nützlich, weil Sie damit Code strukturieren und wiederverwenden können, was wiederum der Fall ist <a name="habracut"></a>  kann den Entwicklungsprozess erheblich beschleunigen.  Trotzdem sollte die Vererbung mit Vorsicht angewendet werden, da die meisten Änderungen an der Oberklasse alle Unterklassen betreffen, was zu unvorhergesehenen Konsequenzen führen kann. </p><br><p> In diesem Beispiel wurden die Methode <code>turn_on()</code> und die Variable <code>serial_number</code> in der Unterklasse <code>Computer</code> nicht deklariert oder definiert.  Sie können jedoch verwendet werden, da sie von der Basisklasse geerbt werden. </p><br><p>  <em>Wichtiger Hinweis</em> : Private Variablen und Methoden können nicht vererbt werden. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: int serial_number = 12345678; void turn_on() { cout &lt;&lt; "Device is on" &lt;&lt; endl; } private: int pincode = 87654321; }; class Computer: public Device {}; int main() { Computer Computer_instance; Computer_instance.turn_on(); cout &lt;&lt; "Serial number is: " &lt;&lt; Computer_instance.serial_number &lt;&lt; endl; // cout &lt;&lt; "Pin code is: " &lt;&lt; Computer_instance.pincode &lt;&lt; endl; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h3 id="tipy-nasledovaniya">  Arten der Vererbung </h3><br><p>  In C ++ gibt es verschiedene Arten der Vererbung: </p><br><ul><li>  öffentlich - öffentliche ( <code>public</code> ) und geschützte ( <code>protected</code> ) Daten werden vererbt, ohne die Zugriffsebene zu ändern. </li><li>  geschützt ( <code>protected</code> ) - alle geerbten Daten werden geschützt; </li><li>  privat - Alle geerbten Daten werden privat. </li></ul><br><p>  Für die <code>Device</code> ändert sich die Datenzugriffsebene nicht. Da die vom <code>Computer</code> abgeleitete Klasse Daten als privat erbt, werden die Daten für die <code>Computer</code> privat. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: int serial_number = 12345678; void turn_on() { cout &lt;&lt; "Device is on" &lt;&lt; endl; } }; class Computer: private Device { public: void say_hello() { turn_on(); cout &lt;&lt; "Welcome to Windows 95!" &lt;&lt; endl; } }; int main() { Device Device_instance; Computer Computer_instance; cout &lt;&lt; "\t Device" &lt;&lt; endl; cout &lt;&lt; "Serial number is: "&lt;&lt; Device_instance.serial_number &lt;&lt; endl; Device_instance.turn_on(); // cout &lt;&lt; "Serial number is: " &lt;&lt; Computer_instance.serial_number &lt;&lt; endl; // Computer_instance.turn_on(); // will cause compile time error cout &lt;&lt; "\t Computer" &lt;&lt; endl; Computer_instance.say_hello(); return 0; }</span></span></span></span></code> </pre> <br><p>  Die <code>Computer</code> Klasse verwendet jetzt die <code>turn_on()</code> -Methode wie jede private Methode: <code>turn_on()</code> kann innerhalb der Klasse aufgerufen werden. Der Versuch, sie direkt von <code>main</code> aufzurufen, führt jedoch beim Kompilieren zu einem Fehler.  Für die Basisklasse <code>Device</code> ist die Methode <code>turn_on()</code> öffentlich geblieben und kann von <code>main</code> aus aufgerufen werden. </p><br><h3 id="konstruktory-i-destruktory">  Konstruktoren und Destruktoren </h3><br><p>  In C ++ werden Konstruktoren und Destruktoren nicht vererbt.  Sie werden jedoch aufgerufen, wenn die untergeordnete Klasse ihr Objekt initialisiert.  Konstruktoren werden nacheinander hierarchisch aufgerufen, beginnend mit der Basisklasse und endend mit der zuletzt abgeleiteten Klasse.  Destruktoren werden in umgekehrter Reihenfolge aufgerufen. </p><br><p>  <em>Wichtiger Hinweis:</em> Dieser Artikel behandelt keine virtuellen Destruktoren.  Zusätzliches Material zu diesem Thema finden Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Artikel über die Habr</a> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: // constructor Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } // destructor ~Device() { cout &lt;&lt; "Device destructor called" &lt;&lt; endl; } }; class Computer: public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } ~Computer() { cout &lt;&lt; "Computer destructor called" &lt;&lt; endl; } }; class Laptop: public Computer { public: Laptop() { cout &lt;&lt; "Laptop constructor called" &lt;&lt; endl; } ~Laptop() { cout &lt;&lt; "Laptop destructor called" &lt;&lt; endl; } }; int main() { cout &lt;&lt; "\tConstructors" &lt;&lt; endl; Laptop Laptop_instance; cout &lt;&lt; "\tDestructors" &lt;&lt; endl; return 0; }</span></span></span></span></code> </pre> <br><p>  Konstruktoren: <code>Device</code> -&gt; <code>Computer</code> -&gt; <code>Laptop</code> . <br>  Zerstörer: <code>Laptop</code> -&gt; <code>Computer</code> -&gt; <code>Device</code> . </p><br><h3 id="mnozhestvennoe-nasledovanie">  Mehrfachvererbung </h3><br><p>  Mehrfachvererbung tritt auf, wenn eine Unterklasse zwei oder mehr Oberklassen hat.  In diesem Beispiel erbt die <code>Laptop</code> Klasse gleichzeitig <code>Monitor</code> und <code>Computer</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Computer { public: void turn_on() { cout &lt;&lt; "Welcome to Windows 95" &lt;&lt; endl; } }; class Monitor { public: void show_image() { cout &lt;&lt; "Imagine image here" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); Laptop_instance.show_image(); return 0; }</span></span></span></span></code> </pre> <br><h3 id="problematika-mnozhestvennogo-nasledovaniya">  Probleme mit Mehrfachvererbung </h3><br><p>  Mehrfachvererbung erfordert sorgfältiges Design, da dies zu unvorhergesehenen Konsequenzen führen kann.  Die meisten dieser Konsequenzen werden durch Mehrdeutigkeiten bei der Vererbung verursacht.  In diesem Beispiel erbt <code>Laptop</code> die Methode <code>turn_on()</code> von beiden Elternteilen, und es ist nicht klar, welche Methode aufgerufen werden soll. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Computer { private: void turn_on() { cout &lt;&lt; "Computer is on." &lt;&lt; endl; } }; class Monitor { public: void turn_on() { cout &lt;&lt; "Monitor is on." &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; // Laptop_instance.turn_on(); // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><p>  Trotz der Tatsache, dass private Daten nicht vererbt werden, ist es unmöglich, eine mehrdeutige Vererbung aufzulösen, indem die Zugriffsebene auf private Daten geändert wird.  Beim Kompilieren wird zunächst nach einer Methode oder Variablen gesucht und anschließend die Zugriffsebene überprüft. </p><br><h1 id="intermediate">  Mittelstufe </h1><br><h3 id="problema-romba">  Rautenproblem </h3><br><img align="left" src="https://habrastorage.org/webt/qn/ae/po/qnaepojwdop6urntrubztgdd7x4.png"><br><p>  Das Diamantproblem ist ein klassisches Problem in Sprachen, die Mehrfachvererbung unterstützen.  Dieses Problem tritt auf, wenn die Klassen <code>B</code> und <code>C</code> <code>A</code> und die Klasse <code>D</code> <code>B</code> und <code>C</code> erben <code>C</code> </p><br><p>  Beispielsweise definieren die Klassen <code>A</code> , <code>B</code> und <code>C</code> die Methode <code>print_letter()</code> .  Wenn <code>print_letter()</code> von Klasse <code>D</code> aufgerufen wird, ist nicht klar, welche Methode aufgerufen werden soll - eine Methode der Klassen <code>A</code> , <code>B</code> oder <code>C</code>  Verschiedene Sprachen haben unterschiedliche Ansätze zur Lösung rautenförmiger Probleme.  In C ++ liegt die Lösung des Problems im Ermessen des Programmierers. <br><br clear="all">  Das rautenförmige Problem ist in erster Linie ein Entwurfsproblem und sollte in der Entwurfsphase bereitgestellt werden.  In der Entwicklungsphase kann dies wie folgt gelöst werden: </p><br><ul><li>  Rufen Sie die Methode einer bestimmten Oberklasse auf. </li><li>  das Objekt der Unterklasse als Objekt einer bestimmten Oberklasse bezeichnen; </li><li>  Überschreiben Sie die problematische Methode in der letzten <code>turn_on()</code> Klasse (im Code <code>turn_on()</code> in der <code>Laptop</code> Unterklasse). </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; class Computer: public Device {}; class Monitor: public Device {}; class Laptop: public Computer, public Monitor { /* public: void turn_on() { cout &lt;&lt; "Laptop is on." &lt;&lt; endl; } // uncommenting this function will resolve diamond problem */ }; int main() { Laptop Laptop_instance; // Laptop_instance.turn_on(); // will produce compile time error // if Laptop.turn_on function is commented out // calling method of specific superclass Laptop_instance.Monitor::turn_on(); // treating Laptop instance as Monitor instance via static cast static_cast&lt;Monitor&amp;&gt;( Laptop_instance ).turn_on(); return 0; }</span></span></span></span></code> </pre> <br><p>  Wenn die Methode <code>turn_on()</code> in Laptop nicht überschrieben wurde, führt der Aufruf von <code>Laptop_instance.turn_on()</code> zu einem Kompilierungsfehler.  Ein <code>Laptop</code> Objekt kann gleichzeitig auf zwei <code>turn_on()</code> zugreifen: <code>Device:Computer:Laptop.turn_on()</code> und <code>Device:Monitor:Laptop.turn_on()</code> . </p><br><h3 id="problema-romba-konstruktory-i-destruktory">  Das Diamantproblem: Konstruktoren und Destruktoren </h3><br><p>  Da in C ++ beim Initialisieren des Objekts der untergeordneten Klasse die Konstruktoren aller übergeordneten Klassen aufgerufen werden, tritt ein weiteres Problem auf: Der Konstruktor der Basisklasse <code>Device</code> wird zweimal aufgerufen. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } }; class Computer: public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } }; class Monitor: public Device { public: Monitor() { cout &lt;&lt; "Monitor constructor called" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; return 0; }</span></span></span></span></code> </pre> <br><h3 id="virtualnoe-nasledovanie">  Virtuelle Vererbung </h3><br><p>  Die virtuelle Vererbung verhindert, dass mehrere Basisklassenobjekte in der Vererbungshierarchie angezeigt werden.  Daher wird der Konstruktor der Basisklasse <code>Device</code> nur einmal aufgerufen, und der Zugriff auf die Methode <code>turn_on()</code> , ohne sie in der <code>turn_on()</code> Klasse zu überschreiben, führt nicht zu einem Kompilierungsfehler. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; class Computer: virtual public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } }; class Monitor: virtual public Device { public: Monitor() { cout &lt;&lt; "Monitor constructor called" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Hinweis</em> : Die virtuelle Vererbung in den Klassen <code>Computer</code> und <code>Monitor</code> keine rhomboide Vererbung zu, wenn die untergeordnete Klasse <code>Laptop</code> die <code>Laptop</code> nicht virtuell erbt ( <code>class Laptop: public Computer, public Monitor, public Device {};</code> ). </p><br><h3 id="abstraktnyy-klass">  Abstrakte Klasse </h3><br><p>  In C ++ wird eine Klasse, in der mindestens eine reine virtuelle Methode vorhanden ist, als abstrakt betrachtet.  Wenn die virtuelle Methode in der untergeordneten Klasse nicht überschrieben wird, wird der Code nicht kompiliert.  In C ++ ist es außerdem unmöglich, ein Objekt einer abstrakten Klasse zu erstellen. Ein Versuch führt auch zu einem Kompilierungsfehler. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } virtual void say_hello() = 0; }; class Laptop: public Device { public: void say_hello() { cout &lt;&lt; "Hello world!" &lt;&lt; endl; } }; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); Laptop_instance.say_hello(); // Device Device_instance; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h3 id="interfeys">  Schnittstelle </h3><br><p>  Im Gegensatz zu einigen OOP-Sprachen bietet C ++ kein separates Schlüsselwort für eine Schnittstelle.  Die Implementierung der Schnittstelle ist jedoch möglich, indem eine reine abstrakte Klasse erstellt wird - eine Klasse, in der nur Methodendeklarationen vorhanden sind.  Solche Klassen werden oft auch als Abstract Base Class (ABC) bezeichnet. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: virtual void turn_on() = 0; }; class Laptop: public Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); // Device Device_instance; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h1 id="advanced">  Erweitert </h1><br><p>  Obwohl Vererbung ein Grundprinzip von OOP ist, sollte sie mit Vorsicht angewendet werden.  Es ist wichtig zu glauben, dass jeder Code, der verwendet wird, wahrscheinlich geändert wird und auf eine Weise verwendet werden kann, die für den Entwickler nicht offensichtlich ist. </p><br><h3 id="nasledovanie-ot-realizovannogo-ili-chastichno-realizovannogo-klassa">  Vererbung von einer implementierten oder teilweise implementierten Klasse </h3><br><p>  Wenn die Vererbung nicht von einer Schnittstelle (einer reinen abstrakten Klasse im Kontext von C ++) stammt, sondern von einer Klasse, in der Implementierungen vorhanden sind, sollte berücksichtigt werden, dass der Erbe über die engstmögliche Verbindung mit der übergeordneten Klasse verbunden ist.  Die meisten Änderungen an der Elternklasse können sich auf den Erben auswirken, was zu unerwartetem Verhalten führen kann.  Solche Änderungen im Verhalten des Erben sind nicht immer offensichtlich - ein Fehler kann im bereits getesteten und funktionierenden Code auftreten.  Diese Situation wird durch das Vorhandensein einer komplexen Klassenhierarchie verschärft.  Es ist immer daran zu erinnern, dass der Code nicht nur von der Person geändert werden kann, die ihn geschrieben hat, und dass die für den Autor offensichtlichen Vererbungspfade von seinen Kollegen möglicherweise nicht berücksichtigt werden. </p><br><p>  Im Gegensatz dazu ist anzumerken, dass die Vererbung von teilweise implementierten Klassen einen unbestreitbaren Vorteil hat.  Bibliotheken und Frameworks funktionieren häufig wie folgt: Sie bieten dem Benutzer eine abstrakte Klasse mit mehreren virtuellen und vielen implementierten Methoden.  Somit wurde bereits der größte Teil der Arbeit erledigt - die komplexe Logik wurde bereits geschrieben, und der Benutzer kann die vorgefertigte Lösung nur an seine Bedürfnisse anpassen. </p><br><h3 id="interfeys-1">  Schnittstelle </h3><br><p>  Die Vererbung von einer Schnittstelle (reine abstrakte Klasse) bietet die Vererbung als Gelegenheit, den Code zu strukturieren und den Benutzer zu schützen.  Da die Schnittstelle beschreibt, welche Arbeit die Implementierungsklasse ausführen wird, jedoch nicht, wie, wird jeder Benutzer der Schnittstelle vor Änderungen in der Klasse geschützt, die diese Schnittstelle implementiert. </p><br><h3 id="interfeys-primer-ispolzovaniya">  Schnittstelle: Verwendungsbeispiel </h3><br><p>  Zunächst ist anzumerken, dass das Beispiel eng mit dem Konzept des Polymorphismus verwandt ist, aber im Zusammenhang mit der Vererbung von einer rein abstrakten Klasse betrachtet wird. </p><br><p>  Eine Anwendung, die abstrakte Geschäftslogik ausführt, muss aus einer separaten Konfigurationsdatei konfiguriert werden.  In einem frühen Stadium der Entwicklung wurde die Formatierung dieser Konfigurationsdatei nicht vollständig erstellt.  Das Übergeben der Dateianalyse hinter einer Schnittstelle bietet mehrere Vorteile. </p><br><p>  Die mangelnde Klarheit hinsichtlich der Formatierung der Konfigurationsdatei verlangsamt den Entwicklungsprozess des Hauptprogramms nicht.  Zwei Entwickler können parallel arbeiten - einer für die Geschäftslogik und der andere für den Parser.  Da sie über diese Schnittstelle interagieren, kann jeder von ihnen unabhängig arbeiten.  Dieser Ansatz erleichtert das Codieren von Komponententests mit Code, da die erforderlichen Tests mit mock für diese Schnittstelle geschrieben werden können. </p><br><p>  Auch beim Ändern des Konfigurationsdateiformats wird die Geschäftslogik der Anwendung nicht beeinflusst.  Das einzige, was einen vollständigen Übergang von einer Formatierung zur anderen erfordert, ist das Schreiben einer neuen Implementierung der bereits vorhandenen abstrakten Klasse (Parser-Klasse).  Die Rückkehr zum ursprünglichen Dateiformat erfordert nur minimalen Aufwand - das Ersetzen eines vorhandenen Parsers durch einen anderen. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Vererbung bietet viele Vorteile, muss jedoch sorgfältig entworfen werden, um die Probleme zu vermeiden, für die sich eine Chance bietet.  Im Zusammenhang mit der Vererbung bietet C ++ eine breite Palette von Tools, die dem Programmierer eine Vielzahl von Möglichkeiten eröffnen. </p><br><p>  Und SOLID ist gut. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445948/">https://habr.com/ru/post/de445948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445928/index.html">Wie wir die Produktivität des Tensorflow-Dienstes um 70% steigern konnten</a></li>
<li><a href="../de445932/index.html">Sicherheit von Clientanwendungen: Praktische Tipps für einen Front-End-Entwickler</a></li>
<li><a href="../de445936/index.html">Elektronikentwicklung. Über Mikrocontroller an den Fingern</a></li>
<li><a href="../de445940/index.html">AMA mit Habr, v 7.0. Zitrone, Donuts und Nachrichten</a></li>
<li><a href="../de445946/index.html">MWC: Gebrauchsanweisung</a></li>
<li><a href="../de445952/index.html">Eine Billion kleiner Singles</a></li>
<li><a href="../de445954/index.html">AI-Beschleuniger von HSE, MTS und Rostelecom</a></li>
<li><a href="../de445958/index.html">SPDS GraphiCS - Fassaden- und Dachsystem</a></li>
<li><a href="../de445962/index.html">Praktikum in IT: Sicht des Managers</a></li>
<li><a href="../de445964/index.html">MEPhI wird eine Olympiade zur Informationssicherheit für Studenten veranstalten: wie man teilnimmt und was es gibt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>