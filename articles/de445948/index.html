<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêá üë∞üèΩ üòñ Vererbung in C ++: Anf√§nger, Mittelstufe, Fortgeschrittene üë©üèø‚Äçüíº üåÑ üçÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel beschreibt die Vererbung auf drei Ebenen: Anf√§nger, Mittelstufe und Fortgeschrittene. Experte Nr. Und kein Wort √ºber SOLID. Ehrlich ges...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vererbung in C ++: Anf√§nger, Mittelstufe, Fortgeschrittene</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445948/"><p> Dieser Artikel beschreibt die Vererbung auf drei Ebenen: Anf√§nger, Mittelstufe und Fortgeschrittene.  Experte Nr.  Und kein Wort √ºber SOLID.  Ehrlich gesagt. </p><br><h1 id="beginner">  Anf√§nger </h1><br><h3 id="chto-takoe-nasledovanie">  Was ist Vererbung? </h3><br><p>  Vererbung ist eines der Grundprinzipien von OOP.  Demnach kann eine Klasse die Variablen und Methoden einer anderen Klasse als ihre eigenen verwenden. </p><br><p>  Eine Klasse, die Daten erbt, wird als Unterklasse, abgeleitete Klasse oder untergeordnete Klasse bezeichnet.  Die Klasse, von der Daten oder Methoden geerbt werden, wird als Superklasse, Basisklasse oder √ºbergeordnete Klasse bezeichnet.  Die Begriffe "Eltern" und "Kind" sind √§u√üerst n√ºtzlich f√ºr das Verst√§ndnis der Vererbung.  Wenn ein Kind die Merkmale seiner Eltern erh√§lt, erh√§lt die abgeleitete Klasse die Methoden und Variablen der Basisklasse. </p><br><p>  Vererbung ist n√ºtzlich, weil Sie damit Code strukturieren und wiederverwenden k√∂nnen, was wiederum der Fall ist <a name="habracut"></a>  kann den Entwicklungsprozess erheblich beschleunigen.  Trotzdem sollte die Vererbung mit Vorsicht angewendet werden, da die meisten √Ñnderungen an der Oberklasse alle Unterklassen betreffen, was zu unvorhergesehenen Konsequenzen f√ºhren kann. </p><br><p> In diesem Beispiel wurden die Methode <code>turn_on()</code> und die Variable <code>serial_number</code> in der Unterklasse <code>Computer</code> nicht deklariert oder definiert.  Sie k√∂nnen jedoch verwendet werden, da sie von der Basisklasse geerbt werden. </p><br><p>  <em>Wichtiger Hinweis</em> : Private Variablen und Methoden k√∂nnen nicht vererbt werden. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: int serial_number = 12345678; void turn_on() { cout &lt;&lt; "Device is on" &lt;&lt; endl; } private: int pincode = 87654321; }; class Computer: public Device {}; int main() { Computer Computer_instance; Computer_instance.turn_on(); cout &lt;&lt; "Serial number is: " &lt;&lt; Computer_instance.serial_number &lt;&lt; endl; // cout &lt;&lt; "Pin code is: " &lt;&lt; Computer_instance.pincode &lt;&lt; endl; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h3 id="tipy-nasledovaniya">  Arten der Vererbung </h3><br><p>  In C ++ gibt es verschiedene Arten der Vererbung: </p><br><ul><li>  √∂ffentlich - √∂ffentliche ( <code>public</code> ) und gesch√ºtzte ( <code>protected</code> ) Daten werden vererbt, ohne die Zugriffsebene zu √§ndern. </li><li>  gesch√ºtzt ( <code>protected</code> ) - alle geerbten Daten werden gesch√ºtzt; </li><li>  privat - Alle geerbten Daten werden privat. </li></ul><br><p>  F√ºr die <code>Device</code> √§ndert sich die Datenzugriffsebene nicht. Da die vom <code>Computer</code> abgeleitete Klasse Daten als privat erbt, werden die Daten f√ºr die <code>Computer</code> privat. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: int serial_number = 12345678; void turn_on() { cout &lt;&lt; "Device is on" &lt;&lt; endl; } }; class Computer: private Device { public: void say_hello() { turn_on(); cout &lt;&lt; "Welcome to Windows 95!" &lt;&lt; endl; } }; int main() { Device Device_instance; Computer Computer_instance; cout &lt;&lt; "\t Device" &lt;&lt; endl; cout &lt;&lt; "Serial number is: "&lt;&lt; Device_instance.serial_number &lt;&lt; endl; Device_instance.turn_on(); // cout &lt;&lt; "Serial number is: " &lt;&lt; Computer_instance.serial_number &lt;&lt; endl; // Computer_instance.turn_on(); // will cause compile time error cout &lt;&lt; "\t Computer" &lt;&lt; endl; Computer_instance.say_hello(); return 0; }</span></span></span></span></code> </pre> <br><p>  Die <code>Computer</code> Klasse verwendet jetzt die <code>turn_on()</code> -Methode wie jede private Methode: <code>turn_on()</code> kann innerhalb der Klasse aufgerufen werden. Der Versuch, sie direkt von <code>main</code> aufzurufen, f√ºhrt jedoch beim Kompilieren zu einem Fehler.  F√ºr die Basisklasse <code>Device</code> ist die Methode <code>turn_on()</code> √∂ffentlich geblieben und kann von <code>main</code> aus aufgerufen werden. </p><br><h3 id="konstruktory-i-destruktory">  Konstruktoren und Destruktoren </h3><br><p>  In C ++ werden Konstruktoren und Destruktoren nicht vererbt.  Sie werden jedoch aufgerufen, wenn die untergeordnete Klasse ihr Objekt initialisiert.  Konstruktoren werden nacheinander hierarchisch aufgerufen, beginnend mit der Basisklasse und endend mit der zuletzt abgeleiteten Klasse.  Destruktoren werden in umgekehrter Reihenfolge aufgerufen. </p><br><p>  <em>Wichtiger Hinweis:</em> Dieser Artikel behandelt keine virtuellen Destruktoren.  Zus√§tzliches Material zu diesem Thema finden Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Artikel √ºber die Habr</a> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: // constructor Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } // destructor ~Device() { cout &lt;&lt; "Device destructor called" &lt;&lt; endl; } }; class Computer: public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } ~Computer() { cout &lt;&lt; "Computer destructor called" &lt;&lt; endl; } }; class Laptop: public Computer { public: Laptop() { cout &lt;&lt; "Laptop constructor called" &lt;&lt; endl; } ~Laptop() { cout &lt;&lt; "Laptop destructor called" &lt;&lt; endl; } }; int main() { cout &lt;&lt; "\tConstructors" &lt;&lt; endl; Laptop Laptop_instance; cout &lt;&lt; "\tDestructors" &lt;&lt; endl; return 0; }</span></span></span></span></code> </pre> <br><p>  Konstruktoren: <code>Device</code> -&gt; <code>Computer</code> -&gt; <code>Laptop</code> . <br>  Zerst√∂rer: <code>Laptop</code> -&gt; <code>Computer</code> -&gt; <code>Device</code> . </p><br><h3 id="mnozhestvennoe-nasledovanie">  Mehrfachvererbung </h3><br><p>  Mehrfachvererbung tritt auf, wenn eine Unterklasse zwei oder mehr Oberklassen hat.  In diesem Beispiel erbt die <code>Laptop</code> Klasse gleichzeitig <code>Monitor</code> und <code>Computer</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Computer { public: void turn_on() { cout &lt;&lt; "Welcome to Windows 95" &lt;&lt; endl; } }; class Monitor { public: void show_image() { cout &lt;&lt; "Imagine image here" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); Laptop_instance.show_image(); return 0; }</span></span></span></span></code> </pre> <br><h3 id="problematika-mnozhestvennogo-nasledovaniya">  Probleme mit Mehrfachvererbung </h3><br><p>  Mehrfachvererbung erfordert sorgf√§ltiges Design, da dies zu unvorhergesehenen Konsequenzen f√ºhren kann.  Die meisten dieser Konsequenzen werden durch Mehrdeutigkeiten bei der Vererbung verursacht.  In diesem Beispiel erbt <code>Laptop</code> die Methode <code>turn_on()</code> von beiden Elternteilen, und es ist nicht klar, welche Methode aufgerufen werden soll. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Computer { private: void turn_on() { cout &lt;&lt; "Computer is on." &lt;&lt; endl; } }; class Monitor { public: void turn_on() { cout &lt;&lt; "Monitor is on." &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; // Laptop_instance.turn_on(); // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><p>  Trotz der Tatsache, dass private Daten nicht vererbt werden, ist es unm√∂glich, eine mehrdeutige Vererbung aufzul√∂sen, indem die Zugriffsebene auf private Daten ge√§ndert wird.  Beim Kompilieren wird zun√§chst nach einer Methode oder Variablen gesucht und anschlie√üend die Zugriffsebene √ºberpr√ºft. </p><br><h1 id="intermediate">  Mittelstufe </h1><br><h3 id="problema-romba">  Rautenproblem </h3><br><img align="left" src="https://habrastorage.org/webt/qn/ae/po/qnaepojwdop6urntrubztgdd7x4.png"><br><p>  Das Diamantproblem ist ein klassisches Problem in Sprachen, die Mehrfachvererbung unterst√ºtzen.  Dieses Problem tritt auf, wenn die Klassen <code>B</code> und <code>C</code> <code>A</code> und die Klasse <code>D</code> <code>B</code> und <code>C</code> erben <code>C</code> </p><br><p>  Beispielsweise definieren die Klassen <code>A</code> , <code>B</code> und <code>C</code> die Methode <code>print_letter()</code> .  Wenn <code>print_letter()</code> von Klasse <code>D</code> aufgerufen wird, ist nicht klar, welche Methode aufgerufen werden soll - eine Methode der Klassen <code>A</code> , <code>B</code> oder <code>C</code>  Verschiedene Sprachen haben unterschiedliche Ans√§tze zur L√∂sung rautenf√∂rmiger Probleme.  In C ++ liegt die L√∂sung des Problems im Ermessen des Programmierers. <br><br clear="all">  Das rautenf√∂rmige Problem ist in erster Linie ein Entwurfsproblem und sollte in der Entwurfsphase bereitgestellt werden.  In der Entwicklungsphase kann dies wie folgt gel√∂st werden: </p><br><ul><li>  Rufen Sie die Methode einer bestimmten Oberklasse auf. </li><li>  das Objekt der Unterklasse als Objekt einer bestimmten Oberklasse bezeichnen; </li><li>  √úberschreiben Sie die problematische Methode in der letzten <code>turn_on()</code> Klasse (im Code <code>turn_on()</code> in der <code>Laptop</code> Unterklasse). </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; class Computer: public Device {}; class Monitor: public Device {}; class Laptop: public Computer, public Monitor { /* public: void turn_on() { cout &lt;&lt; "Laptop is on." &lt;&lt; endl; } // uncommenting this function will resolve diamond problem */ }; int main() { Laptop Laptop_instance; // Laptop_instance.turn_on(); // will produce compile time error // if Laptop.turn_on function is commented out // calling method of specific superclass Laptop_instance.Monitor::turn_on(); // treating Laptop instance as Monitor instance via static cast static_cast&lt;Monitor&amp;&gt;( Laptop_instance ).turn_on(); return 0; }</span></span></span></span></code> </pre> <br><p>  Wenn die Methode <code>turn_on()</code> in Laptop nicht √ºberschrieben wurde, f√ºhrt der Aufruf von <code>Laptop_instance.turn_on()</code> zu einem Kompilierungsfehler.  Ein <code>Laptop</code> Objekt kann gleichzeitig auf zwei <code>turn_on()</code> zugreifen: <code>Device:Computer:Laptop.turn_on()</code> und <code>Device:Monitor:Laptop.turn_on()</code> . </p><br><h3 id="problema-romba-konstruktory-i-destruktory">  Das Diamantproblem: Konstruktoren und Destruktoren </h3><br><p>  Da in C ++ beim Initialisieren des Objekts der untergeordneten Klasse die Konstruktoren aller √ºbergeordneten Klassen aufgerufen werden, tritt ein weiteres Problem auf: Der Konstruktor der Basisklasse <code>Device</code> wird zweimal aufgerufen. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } }; class Computer: public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } }; class Monitor: public Device { public: Monitor() { cout &lt;&lt; "Monitor constructor called" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; return 0; }</span></span></span></span></code> </pre> <br><h3 id="virtualnoe-nasledovanie">  Virtuelle Vererbung </h3><br><p>  Die virtuelle Vererbung verhindert, dass mehrere Basisklassenobjekte in der Vererbungshierarchie angezeigt werden.  Daher wird der Konstruktor der Basisklasse <code>Device</code> nur einmal aufgerufen, und der Zugriff auf die Methode <code>turn_on()</code> , ohne sie in der <code>turn_on()</code> Klasse zu √ºberschreiben, f√ºhrt nicht zu einem Kompilierungsfehler. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; class Computer: virtual public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } }; class Monitor: virtual public Device { public: Monitor() { cout &lt;&lt; "Monitor constructor called" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Hinweis</em> : Die virtuelle Vererbung in den Klassen <code>Computer</code> und <code>Monitor</code> keine rhomboide Vererbung zu, wenn die untergeordnete Klasse <code>Laptop</code> die <code>Laptop</code> nicht virtuell erbt ( <code>class Laptop: public Computer, public Monitor, public Device {};</code> ). </p><br><h3 id="abstraktnyy-klass">  Abstrakte Klasse </h3><br><p>  In C ++ wird eine Klasse, in der mindestens eine reine virtuelle Methode vorhanden ist, als abstrakt betrachtet.  Wenn die virtuelle Methode in der untergeordneten Klasse nicht √ºberschrieben wird, wird der Code nicht kompiliert.  In C ++ ist es au√üerdem unm√∂glich, ein Objekt einer abstrakten Klasse zu erstellen. Ein Versuch f√ºhrt auch zu einem Kompilierungsfehler. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } virtual void say_hello() = 0; }; class Laptop: public Device { public: void say_hello() { cout &lt;&lt; "Hello world!" &lt;&lt; endl; } }; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); Laptop_instance.say_hello(); // Device Device_instance; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h3 id="interfeys">  Schnittstelle </h3><br><p>  Im Gegensatz zu einigen OOP-Sprachen bietet C ++ kein separates Schl√ºsselwort f√ºr eine Schnittstelle.  Die Implementierung der Schnittstelle ist jedoch m√∂glich, indem eine reine abstrakte Klasse erstellt wird - eine Klasse, in der nur Methodendeklarationen vorhanden sind.  Solche Klassen werden oft auch als Abstract Base Class (ABC) bezeichnet. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: virtual void turn_on() = 0; }; class Laptop: public Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); // Device Device_instance; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h1 id="advanced">  Erweitert </h1><br><p>  Obwohl Vererbung ein Grundprinzip von OOP ist, sollte sie mit Vorsicht angewendet werden.  Es ist wichtig zu glauben, dass jeder Code, der verwendet wird, wahrscheinlich ge√§ndert wird und auf eine Weise verwendet werden kann, die f√ºr den Entwickler nicht offensichtlich ist. </p><br><h3 id="nasledovanie-ot-realizovannogo-ili-chastichno-realizovannogo-klassa">  Vererbung von einer implementierten oder teilweise implementierten Klasse </h3><br><p>  Wenn die Vererbung nicht von einer Schnittstelle (einer reinen abstrakten Klasse im Kontext von C ++) stammt, sondern von einer Klasse, in der Implementierungen vorhanden sind, sollte ber√ºcksichtigt werden, dass der Erbe √ºber die engstm√∂gliche Verbindung mit der √ºbergeordneten Klasse verbunden ist.  Die meisten √Ñnderungen an der Elternklasse k√∂nnen sich auf den Erben auswirken, was zu unerwartetem Verhalten f√ºhren kann.  Solche √Ñnderungen im Verhalten des Erben sind nicht immer offensichtlich - ein Fehler kann im bereits getesteten und funktionierenden Code auftreten.  Diese Situation wird durch das Vorhandensein einer komplexen Klassenhierarchie versch√§rft.  Es ist immer daran zu erinnern, dass der Code nicht nur von der Person ge√§ndert werden kann, die ihn geschrieben hat, und dass die f√ºr den Autor offensichtlichen Vererbungspfade von seinen Kollegen m√∂glicherweise nicht ber√ºcksichtigt werden. </p><br><p>  Im Gegensatz dazu ist anzumerken, dass die Vererbung von teilweise implementierten Klassen einen unbestreitbaren Vorteil hat.  Bibliotheken und Frameworks funktionieren h√§ufig wie folgt: Sie bieten dem Benutzer eine abstrakte Klasse mit mehreren virtuellen und vielen implementierten Methoden.  Somit wurde bereits der gr√∂√üte Teil der Arbeit erledigt - die komplexe Logik wurde bereits geschrieben, und der Benutzer kann die vorgefertigte L√∂sung nur an seine Bed√ºrfnisse anpassen. </p><br><h3 id="interfeys-1">  Schnittstelle </h3><br><p>  Die Vererbung von einer Schnittstelle (reine abstrakte Klasse) bietet die Vererbung als Gelegenheit, den Code zu strukturieren und den Benutzer zu sch√ºtzen.  Da die Schnittstelle beschreibt, welche Arbeit die Implementierungsklasse ausf√ºhren wird, jedoch nicht, wie, wird jeder Benutzer der Schnittstelle vor √Ñnderungen in der Klasse gesch√ºtzt, die diese Schnittstelle implementiert. </p><br><h3 id="interfeys-primer-ispolzovaniya">  Schnittstelle: Verwendungsbeispiel </h3><br><p>  Zun√§chst ist anzumerken, dass das Beispiel eng mit dem Konzept des Polymorphismus verwandt ist, aber im Zusammenhang mit der Vererbung von einer rein abstrakten Klasse betrachtet wird. </p><br><p>  Eine Anwendung, die abstrakte Gesch√§ftslogik ausf√ºhrt, muss aus einer separaten Konfigurationsdatei konfiguriert werden.  In einem fr√ºhen Stadium der Entwicklung wurde die Formatierung dieser Konfigurationsdatei nicht vollst√§ndig erstellt.  Das √úbergeben der Dateianalyse hinter einer Schnittstelle bietet mehrere Vorteile. </p><br><p>  Die mangelnde Klarheit hinsichtlich der Formatierung der Konfigurationsdatei verlangsamt den Entwicklungsprozess des Hauptprogramms nicht.  Zwei Entwickler k√∂nnen parallel arbeiten - einer f√ºr die Gesch√§ftslogik und der andere f√ºr den Parser.  Da sie √ºber diese Schnittstelle interagieren, kann jeder von ihnen unabh√§ngig arbeiten.  Dieser Ansatz erleichtert das Codieren von Komponententests mit Code, da die erforderlichen Tests mit mock f√ºr diese Schnittstelle geschrieben werden k√∂nnen. </p><br><p>  Auch beim √Ñndern des Konfigurationsdateiformats wird die Gesch√§ftslogik der Anwendung nicht beeinflusst.  Das einzige, was einen vollst√§ndigen √úbergang von einer Formatierung zur anderen erfordert, ist das Schreiben einer neuen Implementierung der bereits vorhandenen abstrakten Klasse (Parser-Klasse).  Die R√ºckkehr zum urspr√ºnglichen Dateiformat erfordert nur minimalen Aufwand - das Ersetzen eines vorhandenen Parsers durch einen anderen. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Vererbung bietet viele Vorteile, muss jedoch sorgf√§ltig entworfen werden, um die Probleme zu vermeiden, f√ºr die sich eine Chance bietet.  Im Zusammenhang mit der Vererbung bietet C ++ eine breite Palette von Tools, die dem Programmierer eine Vielzahl von M√∂glichkeiten er√∂ffnen. </p><br><p>  Und SOLID ist gut. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445948/">https://habr.com/ru/post/de445948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445928/index.html">Wie wir die Produktivit√§t des Tensorflow-Dienstes um 70% steigern konnten</a></li>
<li><a href="../de445932/index.html">Sicherheit von Clientanwendungen: Praktische Tipps f√ºr einen Front-End-Entwickler</a></li>
<li><a href="../de445936/index.html">Elektronikentwicklung. √úber Mikrocontroller an den Fingern</a></li>
<li><a href="../de445940/index.html">AMA mit Habr, v 7.0. Zitrone, Donuts und Nachrichten</a></li>
<li><a href="../de445946/index.html">MWC: Gebrauchsanweisung</a></li>
<li><a href="../de445952/index.html">Eine Billion kleiner Singles</a></li>
<li><a href="../de445954/index.html">AI-Beschleuniger von HSE, MTS und Rostelecom</a></li>
<li><a href="../de445958/index.html">SPDS GraphiCS - Fassaden- und Dachsystem</a></li>
<li><a href="../de445962/index.html">Praktikum in IT: Sicht des Managers</a></li>
<li><a href="../de445964/index.html">MEPhI wird eine Olympiade zur Informationssicherheit f√ºr Studenten veranstalten: wie man teilnimmt und was es gibt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>