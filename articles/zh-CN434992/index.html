<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚖️ 🌵 👨‍🎤 升级IDA Pro。 Sega Mega Drive调试器（第1部分） 💤 🔟 💷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="问候！ 


反向交易者，romhackers同志：基本上，本文将专门针对您。 在其中，我将告诉您如何为IDA Pro编写自己的调试器插件。 是的，已经有第一次尝试开始这个故事的尝试 ，但是从那以后，大量的水流了，许多原则都被修改了。 一般来说，他们开车！ 
 抒情介绍 


 实际上，从以前的文章...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>升级IDA Pro。 Sega Mega Drive调试器（第1部分）</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434992/"><p><img src="https://habrastorage.org/webt/mj/6l/rl/mj6lrl7zl2pq7itjpw3cr3s15fw.png"></p><br><p> 问候！ </p><br><p>反向交易者，romhackers同志：基本上，本文将专门针对您。 在其中，我将告诉您如何为<code>IDA Pro</code>编写自己的调试器插件。 是的，已经有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一次尝试开始这个故事的尝试</a> ，但是从那以后，大量的水流了，许多原则都被修改了。 一般来说，他们开车！ <a name="habracut"></a></p><br><h4 id="liricheskoe-vstuplenie"> 抒情介绍 </h4><br><p> 实际上，从以前的文章（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">二</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三</a> ）来看，我最喜欢的处理器是<code>Motorola 68000</code>并不是秘密。 顺便说一句，我最喜欢的老女人<code>Sega Mega Drive</code> / <code>Genesis</code>正在研究它。 而且，由于我一直对Segov游戏的布置方式很感兴趣，因此从使用计算机的最初几个月起，我决定深入了解拆卸领域并进行很长一段时间的逆转。 </p><br><p> 这就是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Smd IDA工具的产生方式</a> 。 <br> 该项目包括各种辅助功能，这些功能使研究Sega上的rom的工作变得更加轻松：装载程序，调试程序， <code>VDP</code>命令的帮助程序。 一切都为<code>IDA 6.8</code>编写，并且运行良好。 但是，当我决定告诉全世界我是怎么做的时，很明显，要向人们展示这样的代码非常困难，甚至很难描述。 因此，那时我不能这样做。 </p><br><p> 然后<code>IDA 7.0</code>出现了。 移植我的项目的愿望立刻出现了，但是我编写调试器所依据的<code>Gens</code>模拟器的体系结构却不适合移植： <code>x86</code>汇编插入，拐杖，难以理解的代码等等。 而《 <code>Pier Solar and the Great Architects</code> 》这款游戏于2010年发布在盒带上，我真的很想探索（那里有很多反仿真技巧），但该游戏并不是<code>Gens</code> 。 </p><br><p><img src="https://habrastorage.org/webt/5f/in/pg/5finpgxicxyqorxx1qa50ka7zne.jpeg"></p><br><p> 为了寻找适合调试器的合适仿真器源，我最终偶然发现了<code>EkeEke</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Genesis Plus GX</a> 。 所以这篇文章出现了。 </p><br><h2 id="chast-pervaya-yadro-otladchika"> 第一部分：调试器核心 </h2><br><p>  Musashi处理<code>Genesis Plus GX</code>中Motorola处理器指令的仿真。 它的原始源代码已经具有基本的调试功能（用于执行指令的钩子），但是<code>EkeEke</code>决定在不需要时将其删除。 我们回来。 </p><br><p><img src="https://habrastorage.org/webt/qp/1v/ls/qp1vls4m3ghzf3aqmknj-23xulu.png"></p><br><p><img src="https://habrastorage.org/webt/tr/wp/rw/trwprwbfno8tkajpbfaftwyqyu8.png"></p><br><p> 现在最重要的是：您需要确定调试器的体系结构。 要求如下： </p><br><ul><li> 中断（断点），用于执行，读取和写入内存 </li><li> 功能<code>Step Into</code> </li><li> 暂停， <code>Resume</code>仿真 </li><li> 读/设置寄存器，读/写存储器 </li></ul><br><p> 如果这四个方面是从内部调试器的工作，那么您仍然需要考虑从外部访问此功能。 添加另一个项目： </p><br><ul><li> 调试器服务器（内核）与调试器客户端（GUI，用户）的通信协议 </li></ul><br><h3 id="yadro-otladchika-spisok-bryakov"> 调试器核心：中断列表 </h3><br><p> 为了实现该列表，我们开始以下结构： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">breakpoint_s</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">breakpoint_s</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enabled; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">bpt_type_t</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> address; } <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span>;</code> </pre> <br><p>  <code>next</code>和<code>prev</code>字段将分别存储指向下一个和上一个元素的指针。 <br> 如果需要在操作测试中跳过此断点，则<code>enabled</code>字段将存储<code>0</code> 。 <br>  <code>width</code>断路器覆盖的<code>address</code>字段中从地址开始的字节数。 <br> 好吧，在<code>type</code>字段中，我们将存储断点类型（执行，读取，写入）。 下面有更多详细信息。 </p><br><p> 为了处理断点列表，我添加了以下功能： </p><br><div class="spoiler">  <b class="spoiler_title">断点功能</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *first_bp = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> breakpoint_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_bpt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *bp = (<span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span>)); bp-&gt;type = type; bp-&gt;address = address; bp-&gt;width = width; bp-&gt;enabled = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_bp) { bp-&gt;next = first_bp; bp-&gt;prev = first_bp-&gt;prev; first_bp-&gt;prev = bp; bp-&gt;prev-&gt;next = bp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { first_bp = bp; bp-&gt;next = bp; bp-&gt;prev = bp; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">breakpoint_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * bp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bp == first_bp) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bp-&gt;next == bp) { first_bp = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { first_bp = bp-&gt;next; } } bp-&gt;next-&gt;prev = bp-&gt;prev; bp-&gt;prev-&gt;next = bp-&gt;next; <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(bp); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> breakpoint_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">breakpoint_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bp-&gt;next != first_bp ? bp-&gt;next : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> breakpoint_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *p; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = first_bp; p; p = next_breakpoint(p)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((p-&gt;address == address) &amp;&amp; ((p-&gt;type == BPT_ANY) || (p-&gt;type &amp; type))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_bpt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *bpt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bpt = find_breakpoint(address, type))) delete_breakpoint(bpt); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count_bpt_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *p; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = first_bp; p; p = next_breakpoint(p)) { ++i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_bpt_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_data_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *p; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = first_bp; p; p = next_breakpoint(p)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == index) { data-&gt;address = p-&gt;address; data-&gt;width = p-&gt;width; data-&gt;type = p-&gt;type; data-&gt;enabled = p-&gt;enabled; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ++i; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear_bpt_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (first_bp != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) delete_breakpoint(first_bp); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_bpt_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_bp) clear_bpt_list(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dbg_req || !dbg_req-&gt;dbg_active || dbg_dont_check_bp) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *bp; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (bp = first_bp; bp; bp = next_breakpoint(bp)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(bp-&gt;type &amp; type) || !bp-&gt;enabled) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((address &lt;= (bp-&gt;address + bp-&gt;width)) &amp;&amp; ((address + width) &gt;= bp-&gt;address)) { dbg_req-&gt;dbg_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre> </div></div><br><h3 id="yadro-otladchika-osnovnye-peremennye"> 调试器核心：核心变量 </h3><br><p> 实际上，我在另一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PCSXR</a>调试器中监视了此实现。 </p><br><p> 添加将存储仿真状态的变量： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_first_paused, dbg_trace, dbg_dont_check_bp; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_step_over; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_last_pc; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_step_over_addr; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_active, dbg_paused;</code> </pre> <br><p>  <code>dbg_first_paused</code>变量将负责在调试开始时停止仿真。 如果为<code>0</code>那么您需要暂停仿真并向客户端发送一条消息，说明仿真已开始。 第一次暂停后，设置为<code>1</code> 。 </p><br><p> 我们需要<code>dbg_trace</code>来根据一条指令执行（ <code>Step Into</code>功能）。 如果等于<code>1</code> ，则执行一条指令，暂停，然后将值重置为<code>0</code> 。 </p><br><p> 我设置了<code>dbg_dont_check_bp</code>变量，以便如果调试器执行此操作，读/写内存中断将不起作用。 </p><br><p> 如果我们处于<code>Step Over</code>模式，则<code>dbg_step_over</code>将存储为<code>1</code> ，直到当前<code>PC</code> （ <em>程序计数器</em> ，又称为<em>指令指针</em> ）等于<code>dbg_step_over_addr</code>的地址。 之后，两个变量都将重置。 稍后我将<code>dbg_step_over_addr</code>的值<code>dbg_step_over_addr</code>计算。 </p><br><p> 我为一种特定情况设置了<code>dbg_last_pc</code>变量：当我们已经休息时，客户端请求<code>Resume</code> 。 为了使断路器不再起作用，我将这个变量中的最后一<code>PC</code>的地址与新变量进行比较，如果值不同，则可以检查当前<code>PC</code>上的断点。 </p><br><p>  <code>dbg_active</code>实际上，当调试处于活动状态时，它将存储状态<code>1</code> ，您需要检查中断，处理来自客户端的请求。 </p><br><p> 使用<code>dbg_paused</code>变量，我认为一切都很清楚： <code>1</code>我们处于暂停状态（例如，在休息后），我们正在等待来自客户端的命令， <code>0</code>我们遵循指示。 </p><br><p> 我们编写用于处理这些变量的函数： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_trace = <span class="hljs-number"><span class="hljs-number">1</span></span>; dbg_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_trace = <span class="hljs-number"><span class="hljs-number">0</span></span>; dbg_paused = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detach_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ clear_bpt_list(); resume_debugger(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activate_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_active = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deactivate_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_active = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p> 我们看到，在执行<code>detach_debugger()</code>我曾经清除过中断列表。 这是必要的，这样在断开客户端连接后，旧的断点将无法继续工作。 </p><br><h3 id="yadro-otladchika-realizuem-huk-na-instrukcii"> 调试器核心：我们实现了指令挂钩 </h3><br><p> 实际上，这里的主要工作是暂停，继续模拟， <code>Step Into</code> ， <code>Step Over</code> 。 </p><br><p> 这是<code>process_breakpoints()</code>函数的代码： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_breakpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> handled_event = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> is_step_over = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> is_step_in = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dbg_active) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pc = m68k_get_reg(M68K_REG_PC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dbg_paused &amp;&amp; dbg_first_paused &amp;&amp; !dbg_trace) longjmp(jmp_env, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dbg_first_paused) { dbg_first_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; dbg_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send emulation started event } if (dbg_trace) { is_step_in = 1; dbg_trace = 0; dbg_paused = 1; // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send event that Step Into has been triggered handled_event = 1; } if (!dbg_paused) { if (dbg_step_over &amp;&amp; pc == dbg_step_over_addr) { is_step_over = 1; dbg_step_over = 0; dbg_step_over_addr = 0; dbg_paused = 1; } if (dbg_last_pc != pc) check_breakpoint(BPT_M68K_E, 1, pc, pc); if (dbg_paused) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send event about Step Over or breakpoint has been triggered handled_event = 1; } } if (dbg_first_paused &amp;&amp; (!handled_event) &amp;&amp; dbg_paused) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send paused event } dbg_last_pc = pc; if (dbg_paused &amp;&amp; (!is_step_in || is_step_over)) { longjmp(jmp_env, 1); } }</span></span></code> </pre> <br><p> 让我们了解一下： </p><br><ol><li> 如果未启用调试，只需退出钩子 </li><li> 需要<code>setjmp</code> / <code>longjmp</code>的技巧， <code>longjmp</code>因为<code>RetroArch</code> shell <code>RetroArch</code>挂起，等待模拟器退出框架渲染功能，而我们为其编写了自己的<code>Genesis Plus GX</code>版本，并运行了该模拟器。 我将在稍后展示该技巧的第二部分，因为 它触及仿真器的外壳，而不是内核。 </li><li> 如果这是钩子的第一个操作，并且因此是仿真的开始，那么我们将暂停并将仿真开始的事件发送给客户端。 </li><li> 如果客户端先前发送了<code>Step Into</code> <code>dbg_trace</code> ，那么我们<code>dbg_trace</code>变量<code>dbg_trace</code>值，并将仿真设置为暂停。 我们将相应的事件发送给客户。 </li><li> 如果我们不处于暂停状态，则将打开“ <code>Step Over</code>模式，并且当前<code>PC</code>等于目标地址<code>dbg_step_over_addr</code> ，我们将必要的变量<code>dbg_step_over_addr</code>并暂停。 </li><li> 如果现在不在断点上，我们会检查断点；如果中断有效，我们会暂停并向客户端发送有关“ <code>Step Over</code>或中断”的事件。 </li><li> 如果这不是故障，不是<code>Step Into</code> ，不是<code>Step Over</code> ，那么客户要求休息一下。 我们发送有关触发的暂停的事件。 </li><li> 我们使用<code>longjump</code>来实现技巧，将其作为在暂停期间等待客户端动作的无限循环的实现。 </li></ol><br><p> 用于计算<code>Step Over</code>地址的代码并不像您最初所想的那么简单。 摩托罗拉处理器具有不同的指令长度，因此您必须根据操作码手动考虑下一个地址。 此外，您需要避免使用<code>bra</code> ， <code>jmp</code> ，有条件跳转的<code>rts</code>类的指令，并将其作为<code>Step Into</code>执行。 实现如下： </p><br><div class="spoiler">  <b class="spoiler_title">Calc_step_over（）函数代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_step_over</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pc = m68k_get_reg(M68K_REG_PC); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sp = m68k_get_reg(M68K_REG_SP); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opc = m68ki_read_imm_16(); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dest_pc = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// jsr if ((opc &amp; 0xFFF8) == 0x4E90) { m68k_op_jsr_32_ai(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EA8) { m68k_op_jsr_32_di(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EB0) { m68k_op_jsr_32_ix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB8) { m68k_op_jsr_32_aw(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB9) { m68k_op_jsr_32_al(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBA) { m68k_op_jsr_32_pcdi(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBB) { m68k_op_jsr_32_pcix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // bsr else if ((opc &amp; 0xFFFF) == 0x6100) { m68k_op_bsr_16(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x61FF) { m68k_op_bsr_32(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFF00) == 0x6100) { m68k_op_bsr_8(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // dbf else if ((opc &amp; 0xfff8) == 0x51C8) { dest_pc = m68k_get_reg(M68K_REG_PC) + 2; } m68k_set_reg(M68K_REG_PC, pc); m68k_set_reg(M68K_REG_SP, sp); return dest_pc;</span></span></code> </pre> </div></div><br><h3 id="yadro-otladchika-inicializaciya-i-ostanovka-otladki"> 调试器内核：初始化和停止调试 </h3><br><p> 这里的一切都很简单： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop_debugging</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send Stopped event to client detach_debugger(); deactivate_debugger(); dbg_first_paused = dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; } void start_debugging() { if (dbg_active) return; activate_debugger(); init_bpt_list(); dbg_first_paused = dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; }</span></span></code> </pre> <br><h3 id="yadro-otladchika-realizaciya-protokola"> 调试器内核：协议实现 </h3><br><p> 可以安全地将调试服务器与客户端之间的通信协议称为调试过程的第二个核心，因为 它实现了处理来自客户端的请求并对其做出反应的功能。 <br> 决定基于<em>共享内存</em>来实现，因为有必要发送大块的内存： <code>VRAM</code> ， <code>RAM</code> ， <code>ROM</code> ，并通过网络发送，这将更加有趣。 </p><br><p> 实质是这样的：内核创建具有预定义结构的共享内存，并期望来自客户端的传入请求。 处理请求后，答案将保存在同一内存中，并且相应的信息将添加到同一内存中的调试器事件列表中。 </p><br><p> 原型选择如下： </p><br><div class="spoiler">  <b class="spoiler_title">下载源码包debug_wrap.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _DEBUG_WRAP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _DEBUG_WRAP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; #define SHARED_MEM_NAME "GX_PLUS_SHARED_MEM" #define MAX_BREAKPOINTS 1000 #define MAX_DBG_EVENTS 20 #ifndef MAXROMSIZE #define MAXROMSIZE ((unsigned int)0xA00000) #endif #pragma pack(push, 4) typedef enum { BPT_ANY = (0 &lt;&lt; 0), // M68K BPT_M68K_E = (1 &lt;&lt; 0), BPT_M68K_R = (1 &lt;&lt; 1), BPT_M68K_W = (1 &lt;&lt; 2), BPT_M68K_RW = BPT_M68K_R | BPT_M68K_W, // VDP BPT_VRAM_R = (1 &lt;&lt; 3), BPT_VRAM_W = (1 &lt;&lt; 4), BPT_VRAM_RW = BPT_VRAM_R | BPT_VRAM_W, BPT_CRAM_R = (1 &lt;&lt; 5), BPT_CRAM_W = (1 &lt;&lt; 6), BPT_CRAM_RW = BPT_CRAM_R | BPT_CRAM_W, BPT_VSRAM_R = (1 &lt;&lt; 7), BPT_VSRAM_W = (1 &lt;&lt; 8), BPT_VSRAM_RW = BPT_VSRAM_R | BPT_VSRAM_W, // Z80 BPT_Z80_E = (1 &lt;&lt; 11), BPT_Z80_R = (1 &lt;&lt; 12), BPT_Z80_W = (1 &lt;&lt; 13), BPT_Z80_RW = BPT_Z80_R | BPT_Z80_W, // REGS BPT_VDP_REG = (1 &lt;&lt; 9), BPT_M68K_REG = (1 &lt;&lt; 10), } bpt_type_t; typedef enum { REQ_NO_REQUEST, REQ_GET_REGS, REQ_SET_REGS, REQ_GET_REG, REQ_SET_REG, REQ_READ_68K_ROM, REQ_READ_68K_RAM, REQ_WRITE_68K_ROM, REQ_WRITE_68K_RAM, REQ_READ_Z80, REQ_WRITE_Z80, REQ_ADD_BREAK, REQ_TOGGLE_BREAK, REQ_DEL_BREAK, REQ_CLEAR_BREAKS, REQ_LIST_BREAKS, REQ_ATTACH, REQ_PAUSE, REQ_RESUME, REQ_STOP, REQ_STEP_INTO, REQ_STEP_OVER, } request_type_t; typedef enum { REG_TYPE_M68K = (1 &lt;&lt; 0), REG_TYPE_S80 = (1 &lt;&lt; 1), REG_TYPE_Z80 = (1 &lt;&lt; 2), REG_TYPE_VDP = (1 &lt;&lt; 3), } register_type_t; typedef enum { DBG_EVT_NO_EVENT, DBG_EVT_STARTED, DBG_EVT_PAUSED, DBG_EVT_BREAK, DBG_EVT_STEP, DBG_EVT_STOPPED, } dbg_event_type_t; typedef struct { dbg_event_type_t type; unsigned int pc; char msg[256]; } debugger_event_t; typedef struct { int index; unsigned int val; } reg_val_t; typedef struct { unsigned int d0, d1, d2, d3, d4, d5, d6, d7; unsigned int a0, a1, a2, a3, a4, a5, a6, a7; unsigned int pc, sr, sp, usp, isp, ppc, ir; } regs_68k_data_t; typedef enum { REG_68K_D0, REG_68K_D1, REG_68K_D2, REG_68K_D3, REG_68K_D4, REG_68K_D5, REG_68K_D6, REG_68K_D7, REG_68K_A0, REG_68K_A1, REG_68K_A2, REG_68K_A3, REG_68K_A4, REG_68K_A5, REG_68K_A6, REG_68K_A7, REG_68K_PC, REG_68K_SR, REG_68K_SP, REG_68K_USP, REG_68K_ISP, REG_68K_PPC, REG_68K_IR, REG_VDP_00, REG_VDP_01, REG_VDP_02, REG_VDP_03, REG_VDP_04, REG_VDP_05, REG_VDP_06, REG_VDP_07, REG_VDP_08, REG_VDP_09, REG_VDP_0A, REG_VDP_0B, REG_VDP_0C, REG_VDP_0D, REG_VDP_0E, REG_VDP_0F, REG_VDP_10, REG_VDP_11, REG_VDP_12, REG_VDP_13, REG_VDP_14, REG_VDP_15, REG_VDP_16, REG_VDP_17, REG_VDP_18, REG_VDP_19, REG_VDP_1A, REG_VDP_1B, REG_VDP_1C, REG_VDP_1D, REG_VDP_1E, REG_VDP_1F, REG_VDP_DMA_LEN, REG_VDP_DMA_SRC, REG_VDP_DMA_DST, REG_Z80_PC, REG_Z80_SP, REG_Z80_AF, REG_Z80_BC, REG_Z80_DE, REG_Z80_HL, REG_Z80_IX, REG_Z80_IY, REG_Z80_WZ, REG_Z80_AF2, REG_Z80_BC2, REG_Z80_DE2, REG_Z80_HL2, REG_Z80_R, REG_Z80_R2, REG_Z80_IFFI1, REG_Z80_IFFI2, REG_Z80_HALT, REG_Z80_IM, REG_Z80_I, } regs_all_t; typedef struct { unsigned int pc, sp, af, bc, de, hl, ix, iy, wz; unsigned int af2,bc2,de2,hl2; unsigned char r, r2, iff1, iff2, halt, im, i; } regs_z80_data_t; typedef struct { unsigned char regs_vdp[0x20]; unsigned short dma_len; unsigned int dma_src, dma_dst; } vdp_regs_t; typedef struct { int type; // register_type_t regs_68k_data_t regs_68k; reg_val_t any_reg; vdp_regs_t vdp_regs; regs_z80_data_t regs_z80; } register_data_t; typedef struct { int size; unsigned int address; unsigned char m68k_rom[MAXROMSIZE]; unsigned char m68k_ram[0x10000]; unsigned char z80_ram[0x2000]; } memory_data_t; typedef struct { bpt_type_t type; unsigned int address; int width; int enabled; } bpt_data_t; typedef struct { int count; bpt_data_t breaks[MAX_BREAKPOINTS]; } bpt_list_t; typedef struct { request_type_t req_type; register_data_t regs_data; memory_data_t mem_data; bpt_data_t bpt_data; int dbg_events_count; debugger_event_t dbg_events[MAX_DBG_EVENTS]; bpt_list_t bpt_list; int dbg_active, dbg_paused; int is_ida; } dbg_request_t; #pragma pack(pop) dbg_request_t *open_shared_mem(); void close_shared_mem(dbg_request_t **request); int recv_dbg_event(dbg_request_t *request, int wait); void send_dbg_request(dbg_request_t *request, request_type_t type); #ifdef __cplusplus } #endif #endif</span></span></span></span></code> </pre> </div></div><br><p> 结构中的第一个字段是请求类型： </p><br><ul><li> 读取/设置寄存器 </li><li> 读/写内存 </li><li> 使用断点 </li><li> 暂停/继续仿真，断开/停止调试器 </li><li>  <code>Step Into</code> / <code>Step Over</code> </li></ul><br><p> 接下来是寄存器<code>M68K</code> ， <code>Z80</code> ， <code>VDP</code> 。 以下是<code>ROM</code> ， <code>RAM</code> ， <code>VRAM</code> ， <code>Z80</code>存储块。 </p><br><p> 要添加/删除裂缝，我还创建了相应的结构。 好了，他们的列表也在这里（大部分情况下，它仅用于在GUI中显示，而无需像<code>IDA</code>一样记住所有已安装的中断）。 </p><br><p> 以下是调试事件的列表： </p><br><ul><li> 调试开始（ <code>IDA Pro</code>必需） </li><li> 调试被暂停（当前暂停仿真的<code>PC</code>被保存在事件中） </li><li> 断点有效（还存储发生操作的<code>PC</code>的值） </li><li> 已执行单<code>Step Over</code>执行或单<code>Step Over</code>执行（实际上，这也仅对<code>IDA</code> ，因为您只能处理一个暂停事件） </li><li> 仿真过程已停止。 在没有收到此事件的情况下单击<code>IDA</code>的“ <code>Stop</code>按钮后，它将无休止地等待停止 </li></ul><br><p> 有了协议的思想，我们实现了客户端请求处理，因此获得了以下调试器内核代码： </p><br><div class="spoiler">  <b class="spoiler_title">下载源码包debug.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"debug.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"shared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> m68ki_cpu m68k #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MUL (7) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> BUILD_TABLES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68ki_cycles.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68kconf.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68kcpu.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68kops.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"vdp_ctrl.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Z80.h"</span></span></span><span class="hljs-meta"> static int dbg_first_paused, dbg_trace, dbg_dont_check_bp; static int dbg_step_over; static int dbg_last_pc; static unsigned int dbg_step_over_addr; static dbg_request_t *dbg_req = NULL; static HANDLE hMapFile = 0; typedef struct breakpoint_s { struct breakpoint_s *next, *prev; int enabled; int width; bpt_type_t type; unsigned int address; } breakpoint_t; static breakpoint_t *first_bp = NULL; static breakpoint_t *add_bpt(bpt_type_t type, unsigned int address, int width) { breakpoint_t *bp = (breakpoint_t *)malloc(sizeof(breakpoint_t)); bp-&gt;type = type; bp-&gt;address = address; bp-&gt;width = width; bp-&gt;enabled = 1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (first_bp) { bp-&gt;next = first_bp; bp-&gt;prev = first_bp-&gt;prev; first_bp-&gt;prev = bp; bp-&gt;prev-&gt;next = bp; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { first_bp = bp; bp-&gt;next = bp; bp-&gt;prev = bp; } return bp; } static void delete_breakpoint(breakpoint_t * bp) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bp == first_bp) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bp-&gt;next == bp) { first_bp = NULL; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { first_bp = bp-&gt;next; } } bp-&gt;next-&gt;prev = bp-&gt;prev; bp-&gt;prev-&gt;next = bp-&gt;next; free(bp); } static breakpoint_t *next_breakpoint(breakpoint_t *bp) { return bp-&gt;next != first_bp ? bp-&gt;next : 0; } static breakpoint_t *find_breakpoint(unsigned int address, bpt_type_t type) { breakpoint_t *p; for (p = first_bp; p; p = next_breakpoint(p)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((p-&gt;address == address) &amp;&amp; ((p-&gt;type == BPT_ANY) || (p-&gt;type &amp; type))) return p; } return 0; } static void remove_bpt(unsigned int address, bpt_type_t type) { breakpoint_t *bpt; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((bpt = find_breakpoint(address, type))) delete_breakpoint(bpt); } static int count_bpt_list() { breakpoint_t *p; int i = 0; for (p = first_bp; p; p = next_breakpoint(p)) { ++i; } return i; } static void get_bpt_data(int index, bpt_data_t *data) { breakpoint_t *p; int i = 0; for (p = first_bp; p; p = next_breakpoint(p)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (i == index) { data-&gt;address = p-&gt;address; data-&gt;width = p-&gt;width; data-&gt;type = p-&gt;type; data-&gt;enabled = p-&gt;enabled; break; } ++i; } } static void clear_bpt_list() { while (first_bp != NULL) delete_breakpoint(first_bp); } static void init_bpt_list() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (first_bp) clear_bpt_list(); } void check_breakpoint(bpt_type_t type, int width, unsigned int address, unsigned int value) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!dbg_req || !dbg_req-&gt;dbg_active || dbg_dont_check_bp) return; breakpoint_t *bp; for (bp = first_bp; bp; bp = next_breakpoint(bp)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!(bp-&gt;type &amp; type) || !bp-&gt;enabled) continue; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((address </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;= (bp-&gt;address + bp-&gt;width)) &amp;&amp; ((address + width) &gt;= bp-&gt;address)) { dbg_req-&gt;dbg_paused = 1; break; } } } static void pause_debugger() { dbg_trace = 1; dbg_req-&gt;dbg_paused = 1; } static void resume_debugger() { dbg_trace = 0; dbg_req-&gt;dbg_paused = 0; } static void detach_debugger() { clear_bpt_list(); resume_debugger(); } static void activate_debugger() { dbg_req-&gt;dbg_active = 1; } static void deactivate_debugger() { dbg_req-&gt;dbg_active = 0; } int activate_shared_mem() { hMapFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(dbg_request_t), SHARED_MEM_NAME); if (hMapFile == 0) { return -1; } dbg_req = (dbg_request_t*)MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(dbg_request_t)); if (dbg_req == 0) { CloseHandle(hMapFile); return -1; } memset(dbg_req, 0, sizeof(dbg_request_t)); return 0; } void deactivate_shared_mem() { UnmapViewOfFile(dbg_req); CloseHandle(hMapFile); hMapFile = NULL; dbg_req = NULL; } static unsigned int calc_step_over() { unsigned int pc = m68k_get_reg(M68K_REG_PC); unsigned int sp = m68k_get_reg(M68K_REG_SP); unsigned int opc = m68ki_read_imm_16(); unsigned int dest_pc = (unsigned int)(-1); // jsr if ((opc &amp; 0xFFF8) == 0x4E90) { m68k_op_jsr_32_ai(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EA8) { m68k_op_jsr_32_di(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EB0) { m68k_op_jsr_32_ix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB8) { m68k_op_jsr_32_aw(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB9) { m68k_op_jsr_32_al(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBA) { m68k_op_jsr_32_pcdi(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBB) { m68k_op_jsr_32_pcix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // bsr else if ((opc &amp; 0xFFFF) == 0x6100) { m68k_op_bsr_16(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x61FF) { m68k_op_bsr_32(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFF00) == 0x6100) { m68k_op_bsr_8(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // dbf else if ((opc &amp; 0xfff8) == 0x51C8) { dest_pc = m68k_get_reg(M68K_REG_PC) + 2; } m68k_set_reg(M68K_REG_PC, pc); m68k_set_reg(M68K_REG_SP, sp); return dest_pc; } void process_request() { if (!dbg_req || !dbg_req-&gt;dbg_active) return; if (dbg_req-&gt;req_type == REQ_NO_REQUEST) return; switch (dbg_req-&gt;req_type) { case REQ_GET_REG: { register_data_t *regs_data = &amp;dbg_req-&gt;regs_data; if (regs_data-&gt;type &amp; REG_TYPE_M68K) regs_data-&gt;any_reg.val = m68k_get_reg(regs_data-&gt;any_reg.index); if (regs_data-&gt;type &amp; REG_TYPE_VDP) regs_data-&gt;any_reg.val = reg[regs_data-&gt;any_reg.index]; if (regs_data-&gt;type &amp; REG_TYPE_Z80) { if (regs_data-&gt;any_reg.index &gt;= 0 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 12) // PC &lt;-&gt; HL2 { regs_data-&gt;any_reg.val = ((unsigned int *)&amp;Z80.pc)[regs_data-&gt;any_reg.index]; } else if (regs_data-&gt;any_reg.index &gt;= 13 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 19) // R &lt;-&gt; I { regs_data-&gt;any_reg.val = ((unsigned char *)&amp;Z80.r)[regs_data-&gt;any_reg.index - 13]; } } } break; case REQ_SET_REG: { register_data_t *regs_data = &amp;dbg_req-&gt;regs_data; if (regs_data-&gt;type &amp; REG_TYPE_M68K) m68k_set_reg(regs_data-&gt;any_reg.index, regs_data-&gt;any_reg.val); if (regs_data-&gt;type &amp; REG_TYPE_VDP) reg[regs_data-&gt;any_reg.index] = regs_data-&gt;any_reg.val; if (regs_data-&gt;type &amp; REG_TYPE_Z80) { if (regs_data-&gt;any_reg.index &gt;= 0 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 12) // PC &lt;-&gt; HL2 { ((unsigned int *)&amp;Z80.pc)[regs_data-&gt;any_reg.index] = regs_data-&gt;any_reg.val; } else if (regs_data-&gt;any_reg.index &gt;= 13 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 19) // R &lt;-&gt; I { ((unsigned char *)&amp;Z80.r)[regs_data-&gt;any_reg.index - 13] = regs_data-&gt;any_reg.val &amp; 0xFF; } } } break; case REQ_GET_REGS: case REQ_SET_REGS: { register_data_t *regs_data = &amp;dbg_req-&gt;regs_data; if (regs_data-&gt;type &amp; REG_TYPE_M68K) { regs_68k_data_t *m68kr = &amp;regs_data-&gt;regs_68k; if (dbg_req-&gt;req_type == REQ_GET_REGS) { m68kr-&gt;d0 = m68k_get_reg(M68K_REG_D0); m68kr-&gt;d1 = m68k_get_reg(M68K_REG_D1); m68kr-&gt;d2 = m68k_get_reg(M68K_REG_D2); m68kr-&gt;d3 = m68k_get_reg(M68K_REG_D3); m68kr-&gt;d4 = m68k_get_reg(M68K_REG_D4); m68kr-&gt;d5 = m68k_get_reg(M68K_REG_D5); m68kr-&gt;d6 = m68k_get_reg(M68K_REG_D6); m68kr-&gt;d7 = m68k_get_reg(M68K_REG_D7); m68kr-&gt;a0 = m68k_get_reg(M68K_REG_A0); m68kr-&gt;a1 = m68k_get_reg(M68K_REG_A1); m68kr-&gt;a2 = m68k_get_reg(M68K_REG_A2); m68kr-&gt;a3 = m68k_get_reg(M68K_REG_A3); m68kr-&gt;a4 = m68k_get_reg(M68K_REG_A4); m68kr-&gt;a5 = m68k_get_reg(M68K_REG_A5); m68kr-&gt;a6 = m68k_get_reg(M68K_REG_A6); m68kr-&gt;a7 = m68k_get_reg(M68K_REG_A7); m68kr-&gt;pc = m68k_get_reg(M68K_REG_PC); m68kr-&gt;sr = m68k_get_reg(M68K_REG_SR); m68kr-&gt;sp = m68k_get_reg(M68K_REG_SP); m68kr-&gt;usp = m68k_get_reg(M68K_REG_USP); m68kr-&gt;isp = m68k_get_reg(M68K_REG_ISP); m68kr-&gt;ppc = m68k_get_reg(M68K_REG_PPC); m68kr-&gt;ir = m68k_get_reg(M68K_REG_IR); } else { m68k_set_reg(M68K_REG_D0, m68kr-&gt;d0); m68k_set_reg(M68K_REG_D1, m68kr-&gt;d1); m68k_set_reg(M68K_REG_D2, m68kr-&gt;d2); m68k_set_reg(M68K_REG_D3, m68kr-&gt;d3); m68k_set_reg(M68K_REG_D4, m68kr-&gt;d4); m68k_set_reg(M68K_REG_D5, m68kr-&gt;d5); m68k_set_reg(M68K_REG_D6, m68kr-&gt;d6); m68k_set_reg(M68K_REG_D7, m68kr-&gt;d7); m68k_set_reg(M68K_REG_A0, m68kr-&gt;a0); m68k_set_reg(M68K_REG_A1, m68kr-&gt;a1); m68k_set_reg(M68K_REG_A2, m68kr-&gt;a2); m68k_set_reg(M68K_REG_A3, m68kr-&gt;a3); m68k_set_reg(M68K_REG_A4, m68kr-&gt;a4); m68k_set_reg(M68K_REG_A5, m68kr-&gt;a5); m68k_set_reg(M68K_REG_A6, m68kr-&gt;a6); m68k_set_reg(M68K_REG_A7, m68kr-&gt;a7); m68k_set_reg(M68K_REG_PC, m68kr-&gt;pc); m68k_set_reg(M68K_REG_SR, m68kr-&gt;sr); m68k_set_reg(M68K_REG_SP, m68kr-&gt;sp); m68k_set_reg(M68K_REG_USP, m68kr-&gt;usp); m68k_set_reg(M68K_REG_ISP, m68kr-&gt;isp); } } if (regs_data-&gt;type &amp; REG_TYPE_VDP) { vdp_regs_t *vdp_regs = &amp;regs_data-&gt;vdp_regs; for (int i = 0; i &lt; (sizeof(vdp_regs) / sizeof(vdp_regs-&gt;regs_vdp[0])); ++i) { if (dbg_req-&gt;req_type == REQ_GET_REGS) vdp_regs-&gt;regs_vdp[i] = reg[i]; else reg[i] = vdp_regs-&gt;regs_vdp[i]; } if (dbg_req-&gt;req_type == REQ_GET_REGS) { vdp_regs-&gt;dma_len = (reg[20] &lt;&lt; 8) | reg[19]; if (!vdp_regs-&gt;dma_len) vdp_regs-&gt;dma_len = 0x10000; vdp_regs-&gt;dma_src = vdp_dma_calc_src(); vdp_regs-&gt;dma_dst = vdp_dma_get_dst(); } } if (regs_data-&gt;type &amp; REG_TYPE_Z80) { regs_z80_data_t *z80r = &amp;regs_data-&gt;regs_z80; if (dbg_req-&gt;req_type == REQ_GET_REGS) { z80r-&gt;pc = Z80.pc.d; z80r-&gt;sp = Z80.sp.d; z80r-&gt;af = Z80.af.d; z80r-&gt;bc = Z80.bc.d; z80r-&gt;de = Z80.de.d; z80r-&gt;hl = Z80.hl.d; z80r-&gt;ix = Z80.ix.d; z80r-&gt;iy = Z80.iy.d; z80r-&gt;wz = Z80.wz.d; z80r-&gt;af2 = Z80.af2.d; z80r-&gt;bc2 = Z80.bc2.d; z80r-&gt;de2 = Z80.de2.d; z80r-&gt;hl2 = Z80.hl2.d; z80r-&gt;r = Z80.r; z80r-&gt;r2 = Z80.r2; z80r-&gt;iff1 = Z80.iff1; z80r-&gt;iff2 = Z80.iff2; z80r-&gt;halt = Z80.halt; z80r-&gt;im = Z80.im; z80r-&gt;i = Z80.i; } else { Z80.pc.d = z80r-&gt;pc; Z80.sp.d = z80r-&gt;sp; Z80.af.d = z80r-&gt;af; Z80.bc.d = z80r-&gt;bc; Z80.de.d = z80r-&gt;de; Z80.hl.d = z80r-&gt;hl; Z80.ix.d = z80r-&gt;ix; Z80.iy.d = z80r-&gt;iy; Z80.wz.d = z80r-&gt;wz; Z80.af2.d = z80r-&gt;af2; Z80.bc2.d = z80r-&gt;bc2; Z80.de2.d = z80r-&gt;de2; Z80.hl2.d = z80r-&gt;hl2; Z80.r = z80r-&gt;r; Z80.r2 = z80r-&gt;r2; Z80.iff1 = z80r-&gt;iff1; Z80.iff2 = z80r-&gt;iff2; Z80.halt = z80r-&gt;halt; Z80.im = z80r-&gt;im; Z80.i = z80r-&gt;i; } } } break; case REQ_READ_68K_ROM: case REQ_READ_68K_RAM: case REQ_READ_Z80: { dbg_dont_check_bp = 1; memory_data_t *mem_data = &amp;dbg_req-&gt;mem_data; for (int i = 0; i &lt; mem_data-&gt;size; ++i) { switch (dbg_req-&gt;req_type) { case REQ_READ_68K_ROM: mem_data-&gt;m68k_rom[mem_data-&gt;address + i] = m68ki_read_8(mem_data-&gt;address + i); break; case REQ_READ_68K_RAM: mem_data-&gt;m68k_ram[(mem_data-&gt;address + i) &amp; 0xFFFF] = m68ki_read_8(mem_data-&gt;address + i); break; case REQ_READ_Z80: mem_data-&gt;z80_ram[(mem_data-&gt;address + i) &amp; 0x1FFF] = z80_readmem(mem_data-&gt;address + i); break; default: break; } } dbg_dont_check_bp = 0; } break; case REQ_WRITE_68K_ROM: case REQ_WRITE_68K_RAM: case REQ_WRITE_Z80: { dbg_dont_check_bp = 1; memory_data_t *mem_data = &amp;dbg_req-&gt;mem_data; for (int i = 0; i &lt; mem_data-&gt;size; ++i) { switch (dbg_req-&gt;req_type) { case REQ_WRITE_68K_ROM: m68ki_write_8(mem_data-&gt;address + i, mem_data-&gt;m68k_rom[mem_data-&gt;address + i]); break; case REQ_WRITE_68K_RAM: m68ki_write_8(0xFF0000 | ((mem_data-&gt;address + i) &amp; 0xFFFF), mem_data-&gt;m68k_ram[(mem_data-&gt;address + i) &amp; 0xFFFF]); break; case REQ_WRITE_Z80: z80_writemem(mem_data-&gt;address + i, mem_data-&gt;z80_ram[(mem_data-&gt;address + i) &amp; 0x1FFF]); break; default: break; } } dbg_dont_check_bp = 0; } break; case REQ_ADD_BREAK: { bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; if (!find_breakpoint(bpt_data-&gt;address, bpt_data-&gt;type)) add_bpt(bpt_data-&gt;type, bpt_data-&gt;address, bpt_data-&gt;width); } break; case REQ_TOGGLE_BREAK: { bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; breakpoint_t *bp = find_breakpoint(bpt_data-&gt;address, bpt_data-&gt;type); if (bp != NULL) bp-&gt;enabled = !bp-&gt;enabled; } break; case REQ_DEL_BREAK: { bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; remove_bpt(bpt_data-&gt;address, bpt_data-&gt;type); } break; case REQ_CLEAR_BREAKS: clear_bpt_list(); case REQ_LIST_BREAKS: { bpt_list_t *bpt_list = &amp;dbg_req-&gt;bpt_list; bpt_list-&gt;count = count_bpt_list(); for (int i = 0; i &lt; bpt_list-&gt;count; ++i) get_bpt_data(i, &amp;bpt_list-&gt;breaks[i]); } break; case REQ_ATTACH: activate_debugger(); dbg_first_paused = 0; break; case REQ_PAUSE: pause_debugger(); break; case REQ_RESUME: resume_debugger(); break; case REQ_STOP: stop_debugging(); break; case REQ_STEP_INTO: { if (dbg_req-&gt;dbg_paused) { dbg_trace = 1; dbg_req-&gt;dbg_paused = 0; } } break; case REQ_STEP_OVER: { if (dbg_req-&gt;dbg_paused) { unsigned int dest_pc = calc_step_over(); if (dest_pc != (unsigned int)(-1)) { dbg_step_over = 1; dbg_step_over_addr = dest_pc; } else { dbg_step_over = 0; dbg_step_over_addr = 0; dbg_trace = 1; } dbg_req-&gt;dbg_paused = 0; } } break; default: break; } dbg_req-&gt;req_type = REQ_NO_REQUEST; } void send_dbg_event(dbg_event_type_t type) { dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].type = type; dbg_req-&gt;dbg_events_count += 1; } void stop_debugging() { send_dbg_event(DBG_EVT_STOPPED); detach_debugger(); deactivate_debugger(); dbg_first_paused = dbg_req-&gt;dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; } void start_debugging() { if (dbg_req != NULL &amp;&amp; dbg_req-&gt;dbg_active) return; activate_debugger(); init_bpt_list(); dbg_first_paused = dbg_req-&gt;dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; } int is_debugger_accessible() { return (dbg_req != NULL); } void process_breakpoints() { int handled_event = 0; int is_step_over = 0; int is_step_in = 0; unsigned int pc = m68k_get_reg(M68K_REG_PC); if (!dbg_req || !dbg_req-&gt;dbg_active) return; if (dbg_req-&gt;dbg_paused &amp;&amp; dbg_first_paused &amp;&amp; !dbg_trace) longjmp(jmp_env, 1); if (!dbg_first_paused) { dbg_first_paused = 1; dbg_req-&gt;dbg_paused = 1; dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; strncpy(dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].msg, "gpgx", sizeof(dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].msg)); send_dbg_event(DBG_EVT_STARTED); } if (dbg_trace) { is_step_in = 1; dbg_trace = 0; dbg_req-&gt;dbg_paused = 1; dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; send_dbg_event(DBG_EVT_STEP); handled_event = 1; } if (!dbg_req-&gt;dbg_paused) { if (dbg_step_over &amp;&amp; pc == dbg_step_over_addr) { is_step_over = 1; dbg_step_over = 0; dbg_step_over_addr = 0; dbg_req-&gt;dbg_paused = 1; } if (dbg_last_pc != pc) check_breakpoint(BPT_M68K_E, 1, pc, pc); if (dbg_req-&gt;dbg_paused) { dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; send_dbg_event(is_step_over ? DBG_EVT_STEP : DBG_EVT_BREAK); handled_event = 1; } } if (dbg_first_paused &amp;&amp; (!handled_event) &amp;&amp; dbg_req-&gt;dbg_paused) { dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; send_dbg_event(DBG_EVT_PAUSED); } dbg_last_pc = pc; if (dbg_req-&gt;dbg_paused &amp;&amp; (!is_step_in || is_step_over)) { longjmp(jmp_env, 1); } } int is_debugger_paused() { return is_debugger_accessible() &amp;&amp; dbg_req-&gt;dbg_paused &amp;&amp; dbg_first_paused &amp;&amp; !dbg_trace; }</span></span></span></span></code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title">  debug.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _DEBUG_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _DEBUG_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;setjmp.h&gt; #include "debug_wrap.h" extern void start_debugging(); extern void stop_debugging(); extern int is_debugger_accessible(); extern void process_request(); extern int is_debugger_paused(); extern int activate_shared_mem(); extern void deactivate_shared_mem(); void check_breakpoint(bpt_type_t type, int width, unsigned int address, unsigned int value); extern jmp_buf jmp_env; #ifdef __cplusplus } #endif #endif</span></span></span></span></code> </pre> </div></div><br><p>              . <br> ,    <code>check_breakpoint</code>  <code>VDP</code>       <code>#ifdef LOGVDP</code> .       <code>vdp_ctrl.c</code> : </p><br><pre> <code class="cpp hljs">check_breakpoint(BPT_VRAM_W, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_CRAM_W, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_VSRAM_W, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_VRAM_R, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_CRAM_R, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_VSRAM_R, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data);</code> </pre> <br><p>  <code>RAM</code>     ( <code>m68kcpu.h</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// m68ki_read_8 check_breakpoint(BPT_M68K_R, 1, address, val); // m68ki_read_16 check_breakpoint(BPT_M68K_R, 2, address, val); // m68ki_read_32 check_breakpoint(BPT_M68K_R, 4, address, val); // m68ki_write_8 check_breakpoint(BPT_M68K_W, 1, address, val); // m68ki_write_16 check_breakpoint(BPT_M68K_W, 2, address, val); // m68ki_write_32 check_breakpoint(BPT_M68K_W, 4, address, val);</span></span></code> </pre> <br><p>      ,      ,      . </p><br><div class="spoiler"> <b class="spoiler_title">  debug_wrap.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; #include &lt;process.h&gt; #include "debug_wrap.h" static HANDLE hMapFile = NULL, hStartFunc = NULL; dbg_request_t *open_shared_mem() { hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, SHARED_MEM_NAME); if (hMapFile == NULL) { return NULL; } dbg_request_t *request = (dbg_request_t *)MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(dbg_request_t)); if (request == NULL) { CloseHandle(hMapFile); return NULL; } return request; } void close_shared_mem(dbg_request_t **request) { UnmapViewOfFile(*request); CloseHandle(hMapFile); hMapFile = NULL; *request = NULL; } int recv_dbg_event(dbg_request_t *request, int wait) { while (request-&gt;dbg_active || request-&gt;dbg_events_count) { for (int i = 0; i &lt; MAX_DBG_EVENTS; ++i) { if (request-&gt;dbg_events[i].type != DBG_EVT_NO_EVENT) { request-&gt;dbg_events_count -= 1; return i; } } if (!wait) return -1; Sleep(10); } return -1; } void send_dbg_request(dbg_request_t *request, request_type_t type) { if (!request) return; request-&gt;req_type = type; while (request-&gt;dbg_active &amp;&amp; request-&gt;req_type != REQ_NO_REQUEST) { Sleep(10); } }</span></span></span></span></code> </pre> </div></div><br><p>       .   ,  . ,         , ,      . </p><br><h3 id="yadro-otladchika-zapusk">  :  </h3><br><p>          <code>Genesis Plus GX</code> : </p><br><pre> <code class="cpp hljs"> var.key = <span class="hljs-string"><span class="hljs-string">"genesis_plus_gx_debugger"</span></span>; environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &amp;var); { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!var.value || !<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(var.value, <span class="hljs-string"><span class="hljs-string">"disabled"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_debugger_accessible()) { stop_debugging(); stop_gui(); deactivate_shared_mem(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { activate_shared_mem(); start_debugging(); run_gui(); } } ... { <span class="hljs-string"><span class="hljs-string">"genesis_plus_gx_debugger"</span></span>, <span class="hljs-string"><span class="hljs-string">"Debugger; disabled|enabled"</span></span> },</code> </pre> <br><p>    <code>RetroArch</code> : <br>   ,      <code>retro_run()</code> .      (      ),    . ,      <code>retro_run()</code> ,  <code>RetroArch</code>  .      <code>setjmp()</code> / <code>longjmp()</code> .  ,        <code>retro_run()</code> : </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_debugger_paused()) { longjmp(jmp_env, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> is_paused = setjmp(jmp_env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_paused) { process_request(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>      <code>retro_run()</code>      <code>process_request()</code> ,      ,    . </p><br><h3 id="ps-zatravka-dlya-vtoroy-chasti"> PS     </h3><br><p><img src="https://habrastorage.org/webt/uc/ln/ec/uclnecmakoun2veml3ooxfvaete.png"></p><br><p> <strong>Update</strong> : <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a>      -  <code>IDA Pro</code> ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN434992/">https://habr.com/ru/post/zh-CN434992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN434976/index.html">ITMO University Fablab：为有创造力的人提供DIY协作-显示内部内容</a></li>
<li><a href="../zh-CN434978/index.html">介绍HealthKit</a></li>
<li><a href="../zh-CN434982/index.html">透视图：MultiClet S1</a></li>
<li><a href="../zh-CN434984/index.html">为什么我讨厌雄辩的ORM</a></li>
<li><a href="../zh-CN434986/index.html">标准库的基本概念</a></li>
<li><a href="../zh-CN434994/index.html">Android：创建动态产品风味和签名配置</a></li>
<li><a href="../zh-CN434996/index.html">我如何通过VK API共享位置</a></li>
<li><a href="../zh-CN434998/index.html">关于如何选择智能手机的另一篇文章</a></li>
<li><a href="../zh-CN435000/index.html">广告渠道互动的概念及其实际应用</a></li>
<li><a href="../zh-CN435008/index.html">特斯拉电动汽车第四季度和2018年生产和销售的初步数据</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>