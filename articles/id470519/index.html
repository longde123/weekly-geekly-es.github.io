<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ” â™Œï¸ ğŸ¦” Pengalaman membangun rakitan Linux untuk pembaruan papan tunggal dengan dukungan ğŸ¤¹ğŸ½ ğŸ‘¢ ğŸ§‘ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Saat ini, pasar menawarkan berbagai pembayar tunggal untuk setiap selera dengan harga yang terjangkau. 

 Sebagai aturan, berbagai majel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengalaman membangun rakitan Linux untuk pembaruan papan tunggal dengan dukungan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470519/"><img src="https://habrastorage.org/webt/uv/15/sj/uv15sjkhjdjizxf0g2acp_abzai.jpeg" alt="gambar"><br><br><h2>  Pendahuluan </h2><br>  Saat ini, pasar menawarkan berbagai pembayar tunggal untuk setiap selera dengan harga yang terjangkau. <br><br>  Sebagai aturan, berbagai majelis dari produsen dirancang untuk mengevaluasi platform dan merupakan titik awal proyek baru, oleh karena itu mereka tidak selalu cocok untuk tugas-tugas tertentu.  Dalam tugas-tugas yang membutuhkan keandalan tinggi, pengembang mengajukan pertanyaan tentang bagaimana mengubah kit distribusi dan kemudian tidak membayarnya dengan revisi gambar dan sistem pembaruan yang lengkap. <br><a name="habracut"></a><br>  Di Internet, hampir tidak ada informasi tentang apa yang seharusnya dibuat oleh rilis dan bagaimana mengimplementasikan pembaruannya, sehingga pengembang dipaksa untuk membuat "sepeda" atau menggunakan perkembangannya sendiri, yang tidak selalu 100% diuji. <br><br>  Karena saya mengambil bagian dalam pengembangan perangkat lunak untuk berbagai perangkat Linux (portofolio saya bisa google dengan kata develinux) dan saya juga penulis proyek 11-bagian, saya secara teratur harus berurusan tidak hanya dengan membangun rakitan, tetapi juga dengan mengembangkan mekanisme pembaruan melalui WEB atau USB flash. <br><br>  Dalam artikel ini saya ingin berbagi pengalaman dan pengetahuan saya di bidang yang relevan. <br><br><h2>  Persyaratan perakitan </h2><br>  Dalam proses pengembangan rakitan dan pembaruan untuk berbagai perangkat, saya mengidentifikasi beberapa persyaratan untuk diri saya sendiri: <br><br><ul><li>  perakitan tidak boleh rusak ketika listrik tiba-tiba mati; </li><li>  perakitan harus dimuat dengan cepat; </li><li>  bootloader harus bekerja dengan sempurna; </li><li>  majelis harus mendukung pembaruan. </li></ul><br>  Saya akan mencoba menjelaskan persyaratan ini secara lebih rinci di bawah ini, dan setelah itu saya akan menjelaskan 3 pendekatan dalam pembagian gambar menjadi beberapa bagian dan pembaruannya. <br><br><h2>  Perakitan tidak boleh rusak saat listrik tiba-tiba mati. </h2><br>  Siapa yang butuh perangkat yang berhenti berfungsi setelah reboot kesepuluh?  Kepada siapa pun!  Jika Anda mengambil distribusi yang sudah jadi (dan ada sangat sedikit dari mereka untuk disematkan), maka tanpa file dari kotak mereka semua sangat tidak dapat diandalkan dalam hal ini.  Saya ingat betul proyek tempat saya menggunakan ubuntu di bawah imx6, sistem file pada kartu rusak, kadang-kadang dari reboot kesepuluh, kadang-kadang dari keempat puluh, itu tergantung pada bintang-bintang di langit.  Proyek ini menyelamatkan aufs FS.  Faktanya adalah bahwa ubuntu tidak dirancang untuk dibaca hanya, dan itu harus selalu menulis sesuatu.  Saya ingat situasi yang sama di proyek lain di mana yocto digunakan pada kartu SD.  Secara umum, jadi perhatikan, kartu SD adalah jenis drive paling jelek yang paling cepat crash, jauh lebih andal daripada emmc dan nand.  Jika Anda menggunakan kartu SD, disarankan untuk menulis sesedikit mungkin selama operasi, algoritma transfer latar belakang untuk sektor ini sangat tidak terduga, saya bekerja dengan puluhan kartu SD berbeda dari merek dunia dan tidak menemukan satu kartu pun yang bisa saya rekomendasikan. <br>  Tetapi kartu SD memiliki beberapa keunggulan, harganya terjangkau, murah dan nyaman dalam perangkat lunak debugging. <br><br>  Mengapa saya ... Dan, inilah masalahnya - root FS harus dibaca saja, seharusnya tidak ada entri di dalamnya selama operasi.  Anda mungkin akan berpikir: bagaimana bisa begitu?  Jutaan perangkat Android selalu menulis sesuatu dan tidak gagal.  Benar, tetapi ini semua karena sebagian besar perangkat Android, pertama, memiliki baterai, dan kedua, FS root dibingkai sebagai ramdisk, dan partisi sistem dibaca hanya. <br><br>  Jika sistem harus dapat diandalkan, maka segala macam hal dengan menginstal paket di root FS dapat merusak banyak.  Saya merekomendasikan squashfs sebagai sistem file.  Ini bekerja cepat, tidak bisa menulis apa pun, menghemat ruang karena kompresi ... <br><br>  Tetapi bagaimana dengan menyimpan konfigurasi, mengunduh file, dll.  kamu bertanya? <br>  Tetapi untuk ini, Anda perlu membuat partisi RW terpisah.  Jika Anda berencana untuk menulis di NAND, maka saya merekomendasikan opsi yang terbukti - UBIFS.  Jika di NOR, maka jffs2.  Jika saya menulis ke drive lain, saya sarankan ext4, btrfs, ReiserFS, saya tidak bisa menunjukkan FS terbaik di antara mereka, karena  ada berbagai masalah dengan semua orang. <br><br>  Dalam hal ini, selalu sebelum me-mount partisi rw, pastikan untuk memeriksa kesalahan partisi yang menggunakan utilitas fsck. <br><br><h2>  Perakitan harus dimuat dengan cepat </h2><br>  Kecepatan unduhan perangkat memengaruhi kegunaan keseluruhan.  Dalam beberapa tugas, waktu pemuatan tidak lebih dari 30 detik, dalam beberapa, 5 menit diperbolehkan.  Bagi saya sendiri, saya bekerja waktu hingga 1 menit, semakin sedikit semakin baik.  Tunggu pengunduhan lebih dari satu menit terlalu lama, mungkin perangkatnya hang, jadi jika Anda dapat mengurangi waktu, maka lebih baik menggunakannya. <br><br><h2>  Bootloader harus berjalan dengan lancar </h2><br>  Loader adalah apa yang tidak akan dimulai tanpa perakitan.  Baru-baru ini, saya sering mengamati bagaimana produsen papan tunggal memfasilitasi pengembangan dengan mengunggah demo untuk kartu SD dengan deskripsi cara mendaftarkan bootloader atau gambar selesai dengan bootloader, yang hanya diisi dengan perintah dd.  Tetapi bagaimana jika kartu SD membeku?  Hal yang sama tidak jarang terjadi.  Secara pribadi, dalam latihan saya, kartu sering jatuh.  Ini adalah bagaimana Anda bekerja dengan bayaran selama beberapa jam, Anda menulis perangkat lunak, tetapi dan itu semua ... kesalahan dalam kernel mulai mengalir, kartu jatuh.  Tetapi bagaimana jika ini adalah perangkat yang harus bekerja di ladang tanpa me-reboot?  Dan omong-omong, me-reboot termasuk watchdog tidak selalu menghidupkan kembali kartu yang hang, kartu tidak memiliki sinyal reset, ini bukan emmc, tentu saja ini lebih merupakan pertanyaan untuk sirkuit papan, jika papan memiliki reset kekuatan kartu, ini akan menghemat, tetapi ini tidak di mana-mana.  Pada beberapa papan, hanya mendistorsi daya atau kartu yang membantu.  Berdasarkan pengalaman saya, saya tidak merekomendasikan menyimpan bootloader pada drive dengan unit utama jika perekaman dilakukan pada drive selama operasi.  Jika sistem tidak menulis apa pun ke drive dengan bootloader, dan ini jarang terjadi, maka silakan.  Dalam pengalaman saya, dalam mode readonly, sistem file cacat hanya karena kesalahan perangkat keras, tetapi bukan kesalahan perangkat lunak. <br><br>  Bootloader harus disimpan di tempat yang aman, pada drive yang andal, misalnya, dalam chip NOR atau EEPROM yang terpisah.  Di bawah ini adalah contoh modul berdasarkan chip imx6ull, dengan SPI NOR untuk menyimpan bootloader. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/w0/ka/um/w0kaumujmmpo6mey_ubuk6oknm4.jpeg" alt="gambar" width="50%"></a> </div><br><h2>  Build harus mendukung peningkatan </h2><br>  Tanpa pembaruan, tidak ada tempat ... Saya berpartisipasi dalam banyak proyek dan tidak pernah mendapatkan perangkat lunak yang sempurna untuk pengiriman pekerjaan.  Kesalahan selalu terdeteksi atau peningkatan fungsional diperlukan.  Anda perlu memahami bahwa ketika orang menulis perangkat lunak, mereka akan membuat kesalahan, sementara orang menggunakan perangkat, mereka akan menginginkan lebih sedikit.  Dalam 90% kasus, tidak adanya sistem pembaruan yang dipikirkan dengan matang dapat menyebabkan sakit kepala bagi pabrikan dan runtuhnya seluruh proyek.  Misalnya, sistem pengawasan video telah dikembangkan untuk transportasi, sistem tersebut telah dipasang di seluruh Rusia, dan ternyata pemasar meremehkan pasar dan tidak menyediakan streaming, dan selain itu, beberapa kesalahan ditemukan dalam firmware, ditambah konsumen mulai melirik ke arah pesaing, karena mereka telah ada sesuatu yang tidak ada dalam perangkat yang dibeli ... Ya, ya, di stroberi taman aneh lebih enak dan cuacanya lebih baik (psikologi). <br>  Apa yang harus dilakukan dalam situasi seperti itu?  Jika pembaruan didukung, maka ada banyak solusi, kesalahan dapat diperbaiki, streaming siaran dapat ditingkatkan, dan fungsi dapat disesuaikan untuk konsumen, berikan konsumen firmware dengan instruksi dan hanya itu.  Tetapi jika tidak didukung, maka pabrikan akan memiliki petualangan besar dengan perjalanan bisnis insinyur layanan hingga mengganti perangkat. <br><br>  Sistem pembaruan pada perangkat harus dipikirkan dengan sangat detail dan diuji 100%.  Satu kesalahan dalam bagian ini akan mengubah besi menjadi batu bata, jadi seharusnya tidak ada toleransi dan pengecualian. <br><br>  Proses pembaruan harus tahan untuk mematikan daya, dan dalam kondisi apa pun tidak boleh merusak perangkat. <br><br><h2>  Ikhtisar pendekatan partisi untuk pembaruan di masa mendatang </h2><br>  Dari sekian banyak pendekatan saya dapat merekomendasikan 3 jenis yang saya implementasikan secara pribadi.  Ini tidak semua pendekatan, ruang lingkup mereka berada di luar cakupan artikel ini.  Ketiga jenis ini memiliki kekurangan dan jauh dari ideal, tetapi, menurut saya, mendekati rata-rata emas akal sehat. <br><br><h3>  Pendekatan No. 1 </h3><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/j4/y0/1l/j4y01l02_tkwvnpe-gs1e2jabiy.jpeg" alt="gambar" width="50%"></a> </div><br>  Cara termudah dan paling terjangkau: <br>  Gambar diletakkan pada drive, misalnya kartu SD, yang di-flash dari u-boot ke drive internal perangkat, misalnya, NAND flash. <br>  Di u-boot, Anda perlu menyiapkan skrip untuk ini. <br>  Dari plus - ini adalah jenis pembaruan termudah, pengembangan yang akan memakan waktu maksimum 1 hari. <br>  Kerugian dari pendekatan ini adalah kurangnya visualisasi proses dan kemampuan bootloader yang sangat terbatas, mis.  tidak ada logika rumit dengan alat standar, kecuali tentu saja Anda datang dengan perintah u-boot Anda sendiri (tapi ini adalah jenis pembaruan lain, C adalah kekuatan besar).  Metode ini tidak dimaksudkan untuk pembaruan melalui WEB - bermasalah untuk mengontrol integritas gambar firmware; dalam beberapa kasus, ukuran perakitan tidak boleh melebihi ukuran RAM. <br>  Selain itu, dalam beberapa tugas diharuskan untuk menyimpan pengaturan selama peningkatan, dan ini, dengan pendekatan ini, tidak mudah untuk diterapkan. <br><br><h3>  Pendekatan No. 2 </h3><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/ia/ox/vd/iaoxvdexq7u8_biakyniktekgmk.jpeg" alt="gambar" width="50%"></a> </div><br><br>  Metode yang paling dapat diandalkan dan dilindungi dari yang dipertimbangkan, tetapi yang paling sulit.  Saya merekomendasikan metode ini untuk digunakan dalam pengembangan yang terutama bertanggung jawab, seperti  Ini melindungi baik dari gambar yang rusak dan dari kerusakan fisik ke drive utama, karena sirkuit menggunakan yang tambahan. <br><br>  Pendekatan ini menggunakan build minimal (ukuran ramdisk 8-16MB) dan yang utama.  Ramdisk adalah arsip terkompresi, jadi build 16MB secara fisik akan beberapa kali lebih kecil. <br>  Tujuan dari perakitan minimal adalah untuk mengevaluasi perakitan utama dan memuatnya. <br>  Ramdisk di-host dengan skrip kernel dan u-boot dalam gambar FIT. <br><br>  Mengapa gambar FIT dan apa fungsinya?  Gambar FIT adalah format yang didukung oleh u-boot.  Ini memastikan integritas semua komponen (kernel, dts, ramdisk, skrip).  Membongkar gambar FIT dilakukan di u-boot, dan jika checksum tidak konvergen, u-boot akan menolak untuk memuatnya.  Ini nyaman, mis.  tidak perlu mengurus kontrol integritas sendiri, tidak perlu menulis beberapa file secara terpisah atau menciptakan gambar Anda sendiri, semuanya dilakukan oleh gambar FIT.  Biasanya gambar FIT memakan waktu 7-20MB, itu harus ditulis ke drive terpisah yang sangat andal, misalnya, dalam qspi atau flash.  Rakitan utama dapat disimpan dalam memori yang lebih murah dan tidak dapat diandalkan, misalnya, NAND flash.  Karena pekerjaan utama akan berlangsung di perakitan utama, justru pekerjaan yang akan dirusak terlebih dahulu.  Dalam hal ini, drive terpisah dengan rootf minimal akan datang untuk menyelamatkan. <br><br>  Proses boot. <br><br>  u-boot mengunduh skrip yang mencoba menggunakan pembaruan FIT (FIT2), dan kemudian firmware pabrik FIT (FIT1). <br><br>  Jika FIT2 tidak ada atau integritasnya dilanggar, uji kecocokan akan gagal dan u-boot akan memuat FIT pertama (FIT1).  Jika ada pembaruan FIT (FIT2), dan tidak rusak, maka ramdisknya dimuat yang memeriksa pembaruan rootfs (Rootfs2). <br><br>  Jika Rootfs2 rusak, maka skrip akan menghapus pembaruan FIT (FIT2), kemudian setelah reboot gambar pabrik yang terdiri dari FIT (FIT1) dan Rootfs1 akan diunduh. <br><br>  Perbarui proses. <br><br>  Gambar pembaruan berisi FIT, rootfs, dan berbagai informasi perakitan, termasuk checksum dari semua komponennya.  Informasi perakitan digunakan selama peningkatan untuk memantau integritas dan kompatibilitas. <br><br>  Perbarui kemajuan dalam langkah-langkah: <br><br><ul><li>  memeriksa gambar untuk kompatibilitas dengan perangkat keras dan perangkat lunak, </li><li>  memeriksa integritas gambar dalam file pembaruan, </li><li>  menyalin Rootfs2 dari file pembaruan ke bagian yang disiapkan sebelumnya, </li><li>  memeriksa integritas gambar yang disalin di bagian, </li><li>  salin FIT2 ke bagian yang sesuai, </li><li>  reboot </li></ul><br>  Jika proses gagal, tidak adanya atau kerusakan FIT2 tidak akan merusak sistem, seperti  u-boot hanya akan menolak untuk menggunakannya dan memuat gambar pabrik.  Oleh karena itu, selama peningkatan, integritas FIT2 tidak dicentang. <br><br>  Setelah pembaruan, rakitan baru akan ditempatkan pada drive utama dalam bentuk FIT2 dan Rootfs2. <br><br>  Metode ini tahan terhadap kerusakan mekanis pada drive dan kesalahan FS. <br><br>  Jika terjadi kerusakan kritis, gambar pabrik akan mulai, tempat perangkat lunak pemulihan akan berfungsi, yang, misalnya, dapat memeriksa ulang NAND, mengunduh firmware dari jaringan menggunakan protokol SSH, dan kemudian merekamnya. <br><br>  Saya memberi contoh saja pemulihan, ada banyak pilihan.  Dalam pendekatan ini, proses pemulihan didorong oleh Linux penuh, yang dapat melakukan segalanya ... dan bukan bootloader seperti pada versi pertama. <br><br><h3>  Pendekatan No. 3 </h3><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/wx/mz/o-/wxmzo-tpggd3a6goz48-us359_s.jpeg" alt="gambar" width="50%"></a> </div><br><br>  Jenis pembaruan ini digunakan di hampir semua proyek 11-bagian, karena telah bekerja dengan sangat baik. <br><br>  Pembaruan ini cocok untuk semua ukuran perakitan, untuk semua jenis drive.  Berbeda dengan tipe sebelumnya, di sini SPI NOR hanya digunakan untuk u-boot, oleh karena itu memiliki ukuran lebih kecil dan biaya lebih rendah, 1 MB sudah cukup. <br><br>  Jenis pembaruan ini tidak memerlukan ramdisk yang terpisah, yang berarti bahwa waktu pemrograman disimpan untuk pengembangan dan dukungannya di masa mendatang. <br><br>  Contohnya menggunakan drive kartu SD, tetapi juga bisa NAND menggunakan UBIFS, tidak ada perbedaan.  Dalam pendekatan ini, tidak ada pemeriksaan RO Rootfs sebelum memuat, jika perakitan rusak, sistem tidak akan tahu bahwa itu rusak dan akan memuatnya dalam lingkaran.  Di sini diasumsikan bahwa data di bagian RO tidak dapat diubah dengan cara apa pun, pendekatan ini menghilangkan kerusakan fisik drive.  Jika drive tidak sehat secara fisik, maka perangkat harus dibawa ke pusat layanan, tidak ada penyembuhan diri yang disediakan.  Ini adalah harga yang harus Anda bayar untuk meningkatkan kecepatan pengembangan, dukungan lebih murah dan basis elemen lebih murah, tetapi itu dibenarkan.  Mengapa mengasuransikan sesuatu yang hampir tidak pernah terjadi. <br><br>  Logika untuk mengunduh dan memperbarui sama seperti pada pendekatan sebelumnya. <br><br>  Dalam hal pemuatan, u-boot pertama kali mengunduh pembaruan FIT (FIT2), jika tidak ada atau integritas dilanggar, u-boot memuat FIT pertama (FIT1), rakitan yang dijahit di pabrik dimulai, dan seterusnya hingga sistem diperbarui.  Ketika sistem diperbarui, FIT2 dan Rootfs2 akan muncul.  Dalam hal ini, saat perangkat melakukan boot, pembaruan FIT (FIT2) dimulai terlebih dahulu.  Dalam skrip u-boot yang disimpan di setiap FIT, harus ditulis rootfs mana yang akan dipasang. <br><br><h2>  Partisi bersama RW </h2><br>  Pada bagan, ada blok partisi bersama di mana-mana, ini adalah sekelompok bagian untuk ditulis.  Entri dibuat hanya di sana.  Partisi bersama ditampilkan sebagai satu partisi untuk kejelasan.  Sebenarnya, ada 3 di antaranya: dua kecil untuk konfigurasi yang bekerja di cermin, dan satu besar untuk yang lainnya.  Selain itu, saya sarankan Anda menyimpan beberapa konfigurasi saat memperbarui, yang nyaman, misalnya, jika Anda mengkonfigurasi jaringan dan meningkatkan, Anda tidak perlu mengkonfigurasi ulang pengaturan jaringan. <br><br><h2>  Untuk meringkas </h2><br>  Artikel ini membahas tiga jenis majelis dengan dukungan untuk pembaruan, semua diperiksa oleh saya pribadi, Anda dapat menggunakannya dengan aman di proyek-proyek. <br><br>  Saat ini, saya hanya menggunakan dua yang terakhir, karena paling cocok untuk persyaratan.  Untuk kejelasan, Anda dapat melihat contoh perangkat di mana jenis pembaruan ini digunakan (detail dalam portofolio 11-bagian): <br><br><ul><li>  Repeater RS485 melalui 4G / WiFi / LAN, </li><li>  Papan Kontrol Pengendali Tampilan Industri 4K V-By-One, </li><li>  sistem kontrol iklim hanggar terintegrasi, </li><li>  Pengontrol video tampilan industri 2DisplayPort-LVDS, </li><li>  sistem kontrol garis </li><li>  Gerbang VPN. </li></ul><br>  Jika artikel saya bermanfaat dan menarik, saya siap untuk membagikan pengalaman saya dan solusi teknis yang telah terbukti di bidang embedded linux di situs ini. <br><br>  Terima kasih semuanya. <br>  Gorchakov Ilya <br>  telegram: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">develinux</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470519/">https://habr.com/ru/post/id470519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470503/index.html">Pengguna dan Otorisasi Kubernetes RBAC</a></li>
<li><a href="../id470511/index.html">TI di Armenia: sektor strategis dan bidang teknologi di negara ini</a></li>
<li><a href="../id470513/index.html">Bagaimana saya menemukan rumah pintar yang didominasi oleh botnet</a></li>
<li><a href="../id470515/index.html">Satu langkah kecil untuk penguji: 10 laporan teratas dari Heisenbug 2019 Piter</a></li>
<li><a href="../id470517/index.html">EP Rusia untuk yang terkecil</a></li>
<li><a href="../id470521/index.html">Dirilis 3CX V16 Pembaruan 3 dan aplikasi seluler 3CX baru untuk Android</a></li>
<li><a href="../id470525/index.html">Windows di browser tanpa registrasi dan SMS - ikhtisar klien HTML5 RDP</a></li>
<li><a href="../id470529/index.html">Bagaimana kami menerjemahkan proyek lawas ke GraphQL</a></li>
<li><a href="../id470531/index.html">Neurofisiologis membahas proyek Neuralink dan berbicara tentang kerja otak â€œdengan jariâ€</a></li>
<li><a href="../id470535/index.html">Cara Membuat Grafik Batang Menggunakan Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>