<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🌾 ⚛️ 👨‍⚖️ OutOfLine: patrón en memoria para aplicaciones C ++ de alto rendimiento 🙌🏿 🕛 👆🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mientras trabajaba en Headlands Technologies, tuve la suerte de escribir varias utilidades para simplificar la creación de código C ++ de alto rendimi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OutOfLine: patrón en memoria para aplicaciones C ++ de alto rendimiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421475/"><p> Mientras trabajaba en Headlands Technologies, tuve la suerte de escribir varias utilidades para simplificar la creación de código C ++ de alto rendimiento.  Este artículo ofrece una descripción general de una de estas utilidades, <a href=""><code>OutOfLine</code></a> . </p><a name="habracut"></a><br><p>  Comencemos con un ejemplo ilustrativo.  Supongamos que tiene un sistema que se ocupa de una gran cantidad de objetos del sistema de archivos.  Estos pueden ser archivos ordinarios, denominados sockets o tuberías UNIX.  Por alguna razón, abres muchos descriptores de archivos al inicio, luego trabajas intensamente con ellos y, al final, cierras los descriptores y eliminas los enlaces a los archivos (aproximadamente. El carril significa la función de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desvinculación</a> ). </p><br><p>  La versión inicial (simplificada) puede verse así: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnlinkingFD</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; p) : path(p) { fd = open(p.c_str(), O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>); } ~UnlinkingFD() { close(fd); unlink(path.c_str()); } UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UnlinkingFD&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>  Y este es un buen diseño lógicamente sólido.  Se basa en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RAII</a> para liberar automáticamente el descriptor y eliminar el enlace.  Puede crear una gran variedad de dichos objetos, trabajar con ellos y, cuando la matriz deje de existir, los propios objetos eliminarán todo lo que se necesitaba en el proceso. </p><br><p>  ¿Pero qué pasa con el rendimiento?  Supongamos que <code>fd</code> usa con mucha frecuencia y <code>path</code> solo cuando se elimina un objeto.  Ahora la matriz consta de objetos de tamaño 40 bytes, pero a menudo solo se usan 4 bytes.  Esto significa que habrá más errores en la memoria caché, ya que debe "omitir" el 90% de los datos. </p><br><p>  Una de las soluciones comunes a este problema es la transición de una matriz de estructuras a una estructura de matriz.  Esto proporcionará el rendimiento deseado, pero a costa de abandonar RAII.  ¿Existe una opción que combine las ventajas de ambos enfoques? </p><br><p>  Un compromiso simple sería reemplazar <code>std::string</code> tamaño de 32 bytes con <code>std::unique_ptr&lt;std::string&gt;</code> , cuyo tamaño es de solo 8 bytes.  Esto reducirá el tamaño de nuestro objeto de 40 bytes a 16 bytes, lo cual es un gran logro.  Pero esta solución aún pierde al usar múltiples matrices. </p><br><p>  <code>OutOfLine</code> es una herramienta que permite, sin abandonar RAII, mover completamente los campos poco utilizados (en frío) fuera del objeto.  OutOfLine se usa como una clase base <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CRTP</a> , por lo que el primer argumento de la plantilla debe ser una clase secundaria.  El segundo argumento es el tipo de datos raramente utilizados (en frío) asociados con un objeto (principal) utilizado con frecuencia. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnlinkingFD</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OutOfLine&lt;UnlinkingFD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; p) : OutOfLine&lt;UnlinkingFD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(p) { fd = open(p.c_str(), O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>); } ~UnlinkingFD(); UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UnlinkingFD&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>  Entonces, ¿cómo es esta clase? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FastData</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColdData</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-class"> {</span></span></code> </pre> <br><p>  La idea de implementación básica es utilizar un contenedor asociativo global que asigne punteros a objetos principales y punteros a objetos que contengan datos en frío. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;ColdData&gt;&gt; global_map_;</code> </pre> <br><p>  <code>OutOfLine</code> se puede usar con cualquier tipo de datos en frío, una instancia de la cual se crea y asocia con el objeto principal automáticamente. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&amp;&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;ColdData&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args)...); }</code> </pre> <br><p>  La eliminación del objeto principal implica la eliminación automática del objeto frío asociado: </p><br><pre> <code class="cpp hljs"> ~OutOfLine() { global_map_.erase(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><p>  Al mover (constructor de movimiento / operador de asignación de movimiento) del objeto principal, el objeto frío correspondiente se asociará automáticamente con el nuevo objeto sucesor principal.  Como resultado, no debe acceder a los datos en frío de un objeto movido desde. </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutOfLine&amp;&amp; other)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = other; } OutOfLine&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(OutOfLine&amp;&amp; other) { global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(global_map_[&amp;other]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  En el ejemplo de implementación <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anterior</a> , <code>OutOfLine</code> se puede <code>OutOfLine</code> por simplicidad.  Si es necesario, las operaciones de copia son fáciles de agregar; solo necesitan crear y vincular una copia de un objeto frío. </p><br><pre> <code class="cpp hljs">OutOfLine(OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; OutOfLine&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;</code> </pre> <br><p>  Ahora, para que esto sea realmente útil, sería bueno tener acceso a datos en frío.  Al heredar de <code>OutOfLine</code> clase recibe los métodos constantes y no constantes de <code>cold()</code> : </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">ColdData&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cold</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]; } <span class="hljs-function"><span class="hljs-function">ColdData </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cold</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]; }</code> </pre> <br><p>  Devuelven el tipo apropiado de referencia a datos fríos. </p><br><p>  Eso es casi todo.  Esta opción <code>UnlinkingFD</code> tendrá un tamaño de 4 bytes, proporcionará acceso fácil al caché al campo <code>fd</code> y conservará los beneficios de RAII.  Todo el trabajo relacionado con el ciclo de vida de un objeto está completamente automatizado.  Cuando el objeto principal que se usa con frecuencia se mueve, rara vez se usan movimientos fríos de datos con él.  Cuando se elimina el objeto principal, también se elimina el objeto frío correspondiente. </p><br><p>  A veces, sin embargo, sus datos se conspiran para complicar su vida, y se enfrenta a una situación en la que primero se deben crear datos básicos.  Por ejemplo, son necesarios para construir datos fríos.  Es necesario crear objetos en el orden inverso en relación con lo que ofrece <code>OutOfLine</code> .  Para tales casos, un "respaldo" es útil para controlar el orden de inicialización y de inicialización. </p><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoPhaseInit</span></span></span><span class="hljs-class"> {</span></span>}; OutOfLine(TwoPhaseInit){} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init_cold_data</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&amp;&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> global_map_.find(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;second = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;ColdData&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args)...); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release_cold_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>].reset(); }</code> </pre> <br><p>  Este es otro constructor <code>OutOfLine</code> que se puede usar en clases secundarias; acepta una etiqueta de tipo <code>TwoPhaseInit</code> .  Si crea <code>OutOfLine</code> de esta manera, los datos en frío no se inicializarán y el objeto permanecerá a medio construir.  Para completar la construcción de dos fases, debe llamar al método <code>init_cold_data</code> (pasando los argumentos necesarios para crear un objeto de tipo <code>ColdData</code> ).  Recuerde que no puede llamar a <code>.cold()</code> en un objeto cuyos datos en frío aún no se hayan inicializado.  Por analogía, los datos en frío se pueden eliminar antes de lo programado antes de ejecutar el destructor <code>~OutOfLine</code> llamando a <code>release_cold_data</code> . </p><br><pre> <code class="cpp hljs">}; <span class="hljs-comment"><span class="hljs-comment">// end of class OutOfLine</span></span></code> </pre> <br><p>  Ahora ya está todo.  Entonces, ¿qué nos dan estas 29 líneas de código?  Son otra posible compensación entre rendimiento y facilidad de uso.  En los casos en que tiene un objeto, algunos de cuyos miembros se usan con mucha más frecuencia que otros, <code>OutOfLine</code> puede servir como una forma fácil de usar para optimizar el caché, a costa de ralentizar significativamente el acceso a los datos raramente utilizados. </p><br><p>  Pudimos aplicar esta técnica en varios lugares; a menudo es necesario complementar los datos de trabajo utilizados intensivamente con metadatos adicionales que son necesarios al final del trabajo, en situaciones raras o inesperadas.  Ya sea información sobre los usuarios que establecieron la conexión, desde el terminal comercial del que provino el pedido, o el manejo del acelerador de hardware dedicado al procesamiento de datos de intercambio, <code>OutOfLine</code> mantendrá el caché limpio cuando se encuentre en la parte crítica de los cálculos (ruta crítica). </p><br><p>  He preparado una <a href="">prueba</a> para que pueda ver y evaluar la diferencia. </p><br><table><thead><tr><th>  El guión </th><th>  Tiempo (ns) </th></tr></thead><tbody><tr><td>  Datos fríos en el objeto principal (versión inicial) </td><td>  34684547 </td></tr><tr><td>  Datos en frío completamente eliminados (el mejor de los casos) </td><td>  2938327 </td></tr><tr><td>  Usando OutOfLine </td><td>  2947645 </td></tr></tbody></table><br><p>  <code>OutOfLine</code> aceleración de aproximadamente <code>OutOfLine</code> al usar <code>OutOfLine</code> .  Obviamente, esta prueba está diseñada para demostrar el potencial de <code>OutOfLine</code> , pero también muestra cuánta optimización de caché puede tener un impacto significativo en el rendimiento, al igual que <code>OutOfLine</code> permite obtener esta optimización.  Mantener el caché libre de datos raramente utilizados puede proporcionar mejoras complejas, medibles e integrales para el resto del código.  Como siempre con la optimización, confíe más en las mediciones que en los supuestos, sin embargo, espero que <code>OutOfLine</code> demuestre ser una herramienta útil en su colección de utilidades. </p><br><h2 id="primechanie-ot-perevodchika">  <em>Nota del traductor</em> </h2><br><p>  <em>El código provisto en el artículo sirve para demostrar la idea y no es representativo del código de producción.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421475/">https://habr.com/ru/post/es421475/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421465/index.html">DevOps móviles en la práctica</a></li>
<li><a href="../es421467/index.html">Desarrollo de un robot para recoger pelotas de golf.</a></li>
<li><a href="../es421469/index.html">Telegram acordó transferir a los servicios especiales [pero no a Rusia] las direcciones IP y los números de algunos usuarios</a></li>
<li><a href="../es421471/index.html">Servidor de Ad Exchange: a diferencia de otros</a></li>
<li><a href="../es421473/index.html">¿Qué son las corutinas en Kotlin?</a></li>
<li><a href="../es421477/index.html">Lo que está escrito en el archivo .ssh / known_hosts</a></li>
<li><a href="../es421481/index.html">Micrófonos, capturas de pantalla y video local: cómo el SDK Voximplant Web controla los medios en un navegador</a></li>
<li><a href="../es421485/index.html">Aviso importante para los usuarios de Gitlab Pages</a></li>
<li><a href="../es421487/index.html">Cómo fortalecer el soporte técnico - 6 formas secretas</a></li>
<li><a href="../es421489/index.html">Gruñir pero dar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>