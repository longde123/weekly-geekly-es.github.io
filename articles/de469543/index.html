<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèº üî© üßôüèª Redis-Skalierung und Failover f√ºr DirectumRX-Dienste üöæ üö© üçî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Redis ist ein Datenbankverwaltungssystem der NoSQL-Klasse (nicht relationale DBMS), das vollst√§ndig im RAM abgelegt ist. F√ºr den Zugriff auf die Daten...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redis-Skalierung und Failover f√ºr DirectumRX-Dienste</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/469543/">  Redis ist ein Datenbankverwaltungssystem der NoSQL-Klasse (nicht relationale DBMS), das vollst√§ndig im RAM abgelegt ist.  F√ºr den Zugriff auf die Daten wird das Modell ‚ÄûSchl√ºssel‚Äú - ‚ÄûWert‚Äú verwendet.  Ein solches DBMS wird h√§ufig zum Speichern von Caches in skalierbaren Diensten, zum Speichern von Bildern und kleinen Daten verwendet. <br><br>  Redis DBMS ist weit verbreitet aufgrund von: <br><br><ul><li>  hohe Geschwindigkeit, weil  Alle Daten werden im RAM gespeichert. </li><li>  plattform√ºbergreifend; </li><li>  Vertrieb unter der BSD-Lizenz (gilt f√ºr Open Source-Software). </li></ul><br>  Die Verbreitung und Anwendbarkeit von Redis l√§sst sich anhand der umfangreichen Dokumentation mit allen Arten von F√§llen auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Website des Projekts</a> absch√§tzen. <br><br>  Wenn Sie die horizontale Skalierung von DirectumRX-Diensten verwenden, m√ºssen Sie die ausfallsichere Redis-Installation verwenden, um ordnungsgem√§√ü mit dem DirectumRX-Speicherdienst und dem DirectumRX-Webzugriffsdienst zu arbeiten. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/740/12b/060/74012b060e74628af35c33d4fa96b3bb.jpg" alt="Bild"><br><br>  Redis speichert Betriebsdaten, Caches und andere Informationen, die f√ºr den Betrieb von Diensten im Skalierungsmodus erforderlich sind, damit der Prozess der Benutzerinteraktion mit dem System nicht von der Installation abh√§ngt, mit der er gerade arbeitet. <br><br>  Redis speichert keine sensiblen Daten und ist nicht stark ausgelastet.  Im Falle eines Redis-Fehlers treten beim Wechseln zwischen Installationen jedoch viele Fehler auf. <br><br>  Auf der offiziellen Redis-Website gibt es zwei M√∂glichkeiten, um horizontale Skalierung und Fehlertoleranz sicherzustellen: <br><br><ol><li>  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redis Sentiel</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redis Cluster verwenden</a> . </li></ol><br>  Ziehen Sie in Betracht, diese Optionen anzupassen. <br><br><h2>  Konfigurieren Sie Redis Sentiel </h2><br>  Die Option zur Verwendung des Redis Sentiel (Redis Tracking Node) wurde in Redis 2.4 implementiert und besteht darin, den zus√§tzlichen Redis Sentiel-Dienst zur √úberwachung der Verf√ºgbarkeit des Assistenten zu verwenden.  Er f√ºhrt auch die Konfiguration von Replikatknoten durch, falls der Assistent ausf√§llt.  Legt fest, welcher der SLAVE-Knoten zu MASTER wird, und f√ºhrt die Neukonfiguration unterwegs durch. <br><br>  Implementiert das klassische Schema: <br><br><img width="467" src="https://habrastorage.org/getpro/habr/post_images/093/10e/efb/09310eefbd3eb3c05d23b9e227bb5d7a.jpg" alt="Bild"><br><br>  Es kann viele SLAVE-Knoten geben (laut offizieller Website bis zu 1000). F√ºr produktive Arbeit wird empfohlen, mindestens zwei SLAVE-Knoten zu verwenden. <br><br>  In der Regel ist das Schema so konfiguriert, dass der Redis Sentiel-Dienst auf den Knoten MASTER und SLAVE konfiguriert ist. Wenn der Knoten MASTER ausf√§llt, entscheiden sich die verbleibenden √úberwachungsknoten f√ºr die Einf√ºhrung eines neuen MASTER. <br><br>  Die aktuelle Version von Redis kann von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Website des Produktentwicklers</a> heruntergeladen werden.  Die Distributionsseite ist jedoch nur f√ºr Linux verf√ºgbar.  Zu einer Zeit wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das</a> Microsoft- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt</a> f√ºr die Portierung von Redis auf Windows entwickelt, aber derzeit hat das Projekt die Entwicklung auf Version 3.2.100 gestoppt. In diesem Artikel werden wir daher die relevanteste Bereitstellungsoption betrachten - unter Linux. <br><br>  Als Testknoten werden wir zwei virtuelle Hosts redis1 und redis2 mit der installierten Linux-Distribution von Debian 10 verwenden. <br><br>  Aktualisieren Sie zun√§chst die Paketlisten aus dem Standard-Repository und installieren Sie Redis: <br><br><pre><code class="bash hljs">apt-get update &amp;&amp; apt-get upgrade apt install redis-server</code> </pre> <br>  √úberpr√ºfen Sie die Version: <br><br><pre> <code class="bash hljs">root@redis1:/home/user<span class="hljs-comment"><span class="hljs-comment"># redis-server -v Redis server v=5.0.3 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=afa0decbb6de285f</span></span></code> </pre> <br>  Lassen Sie redis1 als MASTER-Knoten und redis2 als SLAVE-Knoten fungieren. <br><br>  Zu diesem Zweck schreiben wir in die Redis-Konfigurationsdateien die erforderlichen Parameter, mit denen Sie ein Replikat erstellen k√∂nnen (noch nicht fehlertolerant). <br><br>  Geben Sie f√ºr redis1 in der Konfigurationsdatei /etc/redis/redis.conf Folgendes an: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ,   MASTER     . requirepass TestPass</span></span></code> </pre> <br>  Geben Sie f√ºr redis2 in der Konfigurationsdatei /etc/redis/redis.conf Folgendes an: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   MASTER  . slaveof redis1 6379 #      . masterauth TestPass #   ,         . requirepass TestPass</span></span></code> </pre> <br>  Starten Sie die Redis-Server-Dienste auf beiden Knoten neu: <br><br><pre> <code class="bash hljs">root@redis1:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># /etc/init.d/redis-server stop [ ok ] Stopping redis-server (via systemctl): redis-server.service. root@redis1:/etc/redis# /etc/init.d/redis-server start [ ok ] Starting redis-server (via systemctl): redis-server.service. root@redis2:/etc/redis# /etc/init.d/redis-server stop [ ok ] Stopping redis-server (via systemctl): redis-server.service. root@redis2:/etc/redis# /etc/init.d/redis-server start [ ok ] Starting redis-server (via systemctl): redis-server.service.</span></span></code> </pre> <br>  Wir √ºberpr√ºfen auf der MASTER-Seite, ob die Knoten zu Replikaten wurden und die erforderlichen Rollen erhalten haben: <br><br><pre> <code class="bash hljs">root@redis1:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:master connected_slaves:1 slave0:ip=192.168.9.96,port=6379,state=online,offset=28,lag=0 master_replid:56b0a702d5823d107b0ca1ca2c80f8ef650a4b28 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:28 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:28</span></span></code> </pre> <br>  Auf der Sklaven-Seite sehen wir die gleiche Situation: <br><pre> <code class="bash hljs">root@redis2:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:slave master_host:redis1 master_port:6379 master_link_status:up master_last_io_seconds_ago:4 master_sync_in_progress:0 slave_repl_offset:14 slave_priority:100 slave_read_only:1 connected_slaves:0 master_replid:56b0a702d5823d107b0ca1ca2c80f8ef650a4b28 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:14 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:14</span></span></code> </pre> <br>  Jetzt m√ºssen Sie das Replikat so konfigurieren, dass es bei einem Ausfall eines der Knoten automatisch wiederhergestellt wird.  Dazu ben√∂tigen wir den Redis Sentinel-Tracking-Service. <br><br>  Basierend auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> kann der Redis Sentinel-√úberwachungsdienst die folgenden Vorg√§nge ausf√ºhren: <br><br><ol><li>  √úberpr√ºft die Verf√ºgbarkeit von MASTER- und SLAVE-Knoten und kann Warnungen √ºber die Unzug√§nglichkeit von Knoten senden. </li><li>  Wenn der MASTER-Knoten ausf√§llt, kann der Zeugenknoten den SLAVE-Knoten in den MASTER-Modus versetzen sowie die verbleibenden SLAVE-Knoten neu konfigurieren, und sie beginnen mit dem neuen MASTER zu arbeiten. </li><li>  Nimmt √Ñnderungen an den Konfigurationsdateien der Knoten MASTER und SLAVE vor. </li></ol><br>  Aus Gr√ºnden der Reinheit des Experiments werden wir einen Zeugen-Service auf einer separaten redis3-VM platzieren. <br><br>  Wir verbinden das Redis-Repository auf die gleiche Weise und installieren das Redis-Sentinel-Paket: <br><br><pre> <code class="bash hljs">apt install redis-sentinel</code> </pre> <br>  Nach der Installation m√ºssen Sie die Einstellungen in der Konfigurationsdatei des √úberwachungsknotens /etc/redis/sentinel.conf vornehmen: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    redis1   6379. #   1 -      , #        MASTER-. #       , #     MASTER-. sentinel monitor master01 redis1 6379 1 #  3 ,       . sentinel down-after-milliseconds master01 3000 #    MASTER- sentinel failover-timeout master01 6000 # ,  SLAVE-   . #    ,    , #      . sentinel parallel-syncs master01 1 #    . bind 192.168.9.97 127.0.0.1 ::1 #    MASTER-. sentinel auth-pass master01 TestPass</span></span></code> </pre><br>  Starten Sie den Dienst neu, nachdem Sie die Einstellungen vorgenommen haben: <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># /etc/init.d/redis-sentinel restart [ ok ] Restarting redis-sentinel (via systemctl): redis-sentinel.service.</span></span></code> </pre> <br>  √úberpr√ºfen Sie, ob der Tracking-Service MASTER und SLAVE gesehen hat: <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 26379 info sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=master01,status=ok,address=192.168.9.95:6379,slaves=1,sentinels=1</span></span></code> </pre> <br>  Wir beginnen die Experimente. <br><br>  Wir simulieren einen Fehler, stoppen den Redis-Server-Dienst auf dem Redis1-Knoten und erhalten die aktuellen Informationen des Zeugenknotens: <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 26379 info sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=master01,status=ok,address=192.168.9.96:6379,slaves=1,sentinels=1</span></span></code> </pre> <br>  Wir sehen, dass sich MASTER ver√§ndert hat. <br><br>  Wir werden den Betrieb des redis1-Knotens wiederherstellen und seinen Status √ºberpr√ºfen: <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -h redis1 -p 6379 -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:slave master_host:192.168.9.96 master_port:6379 master_link_status:up master_last_io_seconds_ago:1 master_sync_in_progress:0 slave_repl_offset:15977 slave_priority:100 slave_read_only:1 connected_slaves:0 master_replid:6c0c7d0eedccede56f211f2db74a98c4d0ff6d56 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:15977 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:15977</span></span></code> </pre> <br>  Wir sehen, dass der Knoten die SLAVE-Rolle erhalten hat und der redis2-Knoten ein MASTER-Knoten ist. <br><br>  Simulieren Sie den Ausfall des redis2-Knotens und √ºberpr√ºfen Sie den Status des Zeugenknotens: <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 26379 info sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=master01,status=ok,address=192.168.9.95:6379,slaves=1,sentinels=1</span></span></code> </pre> <br>  Und der Zustand des redis1-Knotens: <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -h redis1 -p 6379 -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:master connected_slaves:0 master_replid:6e9d67d6460815b925319c2bafb58bf2c435cffb master_replid2:6c0c7d0eedccede56f211f2db74a98c4d0ff6d56 master_repl_offset:33610 second_repl_offset:26483 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:33610</span></span></code> </pre> <br>  Gro√üartig, der Mechanismus funktioniert.  Jetzt stellt sich jedoch die Frage, wie wir unsere DirectumRX-Dienste verbinden, da sie eine einzelne Knotenadresse ben√∂tigen.  Wir werden die Situation mit dem HAProxy-Service l√∂sen. <br><br><h2>  Redis Node Proxying </h2><br>  Jeder Proxy-TCP-Dienst kann als Reverse-Proxy f√ºr Redis-Knoten fungieren.  In diesem Artikel werden wir die Verwendung von HAProxy betrachten, da es sich um ein spezielles Tool handelt, das f√ºr hohe Verf√ºgbarkeit und Lastausgleich ausgelegt ist und von allgemein bekannten Onlinediensten verwendet wird.  Weitere Informationen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu</a> HAProxy finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Entwicklerseite</a> . <br><br>  Installieren Sie HAProxy auf dem redis3-Knoten: <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># apt install haproxy</span></span></code> </pre> <br>  F√ºgen Sie in der HAProxy-Konfigurationsdatei /etc/haproxy/haproxy.cfg die Einstellungen f√ºr das Proxying von Anforderungen an Redis-Knoten hinzu: <br><br><pre> <code class="bash hljs">‚Ä¶ frontend ft_redis <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> *:6379 name redis mode tcp default_backend bk_redis backend bk_redis mode tcp option tcp-check tcp-check connect <span class="hljs-comment"><span class="hljs-comment">#  ,         . tcp-check send AUTH\ TestPass\r\n tcp-check expect string +OK tcp-check send PING\r\n tcp-check expect string +PONG tcp-check send info\ replication\r\n #    MASTER, .. SLAVE      . tcp-check expect string role:master tcp-check send QUIT\r\n tcp-check expect string +OK server Redis1 redis1:6379 check inter 3s server Redis2 redis2:6379 check inter 3s</span></span></code> </pre><br>  In dieser Konfiguration wird angegeben, dass wir alle Anforderungen, die an alle Schnittstellen der aktuellen virtuellen Maschine eingehen, an die Adresse an Port 6379 weiterleiten. Wir √ºbertragen Anforderungen an den Knoten, der antwortet, dass er die MASTER-Rolle hat. <br><br>  Starten Sie den Haproxy-Dienst neu: <br><br><pre> <code class="bash hljs">root@redis3:/etc/haproxy<span class="hljs-comment"><span class="hljs-comment"># /etc/init.d/haproxy restart</span></span></code> </pre> <br>  Versuchen wir, eine Verbindung mit dem redis-cli-Client herzustellen und einen Testschl√ºssel zu erstellen: <br><br><pre> <code class="bash hljs">root@redis3:/etc/haproxy<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 6379 -a TestPass Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. 127.0.0.1:6379&gt; SET TestKey "Some test string" OK 127.0.0.1:6379&gt; GET TestKey "Some test string" 127.0.0.1:6379&gt; info keyspace # Keyspace db0:keys=1,expires=0,avg_ttl=0</span></span></code> </pre> <br>  Stoppen Sie den Knoten redis1 und fragen Sie die Liste der Schl√ºssel erneut ab: <br><br><pre> <code class="bash hljs">127.0.0.1:6379&gt; info keyspace Error: Server closed the connection (3.01s) 127.0.0.1:6379&gt; info keyspace <span class="hljs-comment"><span class="hljs-comment"># Keyspace db0:keys=1,expires=0,avg_ttl=0 (2.01s) 127.0.0.1:6379&gt; GET TestKey "Some test string"</span></span></code> </pre><br>  Wir sehen, dass die Verbindung f√ºr einige Zeit getrennt wurde, aber dann die Verbindung wieder hergestellt wurde und alle Daten an Ort und Stelle blieben. <br><br>  Jetzt reicht es aus, die Reverse-Proxy-Adresse in den Konfigurationsdateien der DirectumRX-Dienste zu registrieren, um eine Verbindung zu Redis herzustellen. <br><br><h2>  Konfigurieren Sie den Redis-Cluster </h2><br>  Die f√ºr Version Redis 3.0 und h√∂her implementierte Redis Cluster-Clustering-Option ist eine L√∂sung zum Erstellen und Verwalten eines Clusters mit Datensegmentierung und -replikation.  F√ºhrt Aufgaben der Knotenverwaltung, Replikation, Datensynchronisation auf Knoten aus und stellt den Zugriff der Clientanwendung auf den MASTER-Knoten sicher, falls einer von mehreren MASTER-Knoten ausf√§llt. <br><br><img width="500" src="https://habrastorage.org/getpro/habr/post_images/86e/5c6/e56/86e5c6e56fe5541c36297e978c4c34d4.png" alt="Bild"><br><br>  Redis Cluster arbeitet im Multimaster-Modus. Jeder MASTER-Knoten kann einen oder mehrere SLAVE-Knoten (bis zu 1000) haben. <br><br>  Die Skalierung ist die Hauptfunktion des Clusters.  Dar√ºber hinaus kann der Cluster die Fehlertoleranz des Redis-Dienstes garantieren: <br><br><ul><li>  Wenn einige Knoten nicht funktionieren, verteilt der Cluster die Last von ihnen auf andere Knoten. </li><li>  Wenn Schl√ºsselknoten nicht funktionieren, endet der gesamte Cluster. </li></ul><br>  Eine Situation kann auftreten, wenn Client 2 auf den Knoten M2 schreibt.  M2 antwortet mit "OK" und versucht, in S2 zu schreiben.  Gleichzeitig wartet M2 nicht auf den korrekten Abschluss des Datenaustauschs mit S2, sondern reagiert sofort auf den Client.  In diesem Fall verf√ºgt das S2-Replikat m√∂glicherweise nicht √ºber alle Daten.  Daher wird empfohlen, mehrere SLAVE-Replikate zu verwenden. <br><br>  Eine Situation kann auch auftreten, wenn M1, M3 M2 nicht mehr ‚Äûsehen‚Äú und der Client weiterhin Daten in M2 schreibt.  Wenn die Nichtverf√ºgbarkeit einige Zeit andauert (Cluster-Node-Timeout-Parameter), wird in diesem Fall S2 in den MASTER-Modus versetzt und M2 funktioniert nicht mehr von alleine. <br><br>  In der offiziellen Dokumentation wird die Verwendung von 6 Knoten empfohlen - eine Redis-Instanz pro Knoten, was eine h√∂here Zuverl√§ssigkeit erm√∂glicht. Niemand verbietet jedoch die Verwendung von drei Knoten mit der folgenden Verbindungstopologie: <br><br><img width="573" src="https://habrastorage.org/getpro/habr/post_images/3c1/56a/860/3c156a860e5728015e9631b3bb5854a1.jpg" alt="Bild"><br><br>  Wenn einer der physischen Knoten ausf√§llt, wechseln die entsprechenden SLAVE-Replikate in den MASTER-Modus und der Betrieb wird nicht unterbrochen. <br><br>  Wir implementieren 3 virtuelle Maschinen (redis1, redis2 und redis3) auf dem Pr√ºfstand, von denen jede 2 Redis-Instanzen ausf√ºhren wird. <br><br>  Die Clientanwendung stellt eine Verbindung zu einem bestimmten Port her, der in der Clientkonfigurationsdatei angegeben ist. Daher sollten MASTER-SLAVE-Paare an denselben Ports funktionieren. <br><br>  F√ºr das Paar M1 - S1 verwenden wir Port 6381 <br>  F√ºr das Paar M2 - S2 verwenden wir Port 6382 <br>  F√ºr das Paar M3 - S3 verwenden wir Port 6383 <br><br>  Bereiten Sie die Konfigurationsdateien vor <br><br>  Auf redis1: <br><br><pre> <code class="bash hljs">cp /etc/redis/redis.conf /etc/redis/m1_redis.conf cp /etc/redis/redis.conf /etc/redis/s2_redis.conf mv /etc/redis/redis.conf /etc/redis/redis.bak</code> </pre> <br>  Auf redis2: <br><br><pre> <code class="bash hljs">cp /etc/redis/redis.conf /etc/redis/m2_redis.conf cp /etc/redis/redis.conf /etc/redis/s3_redis.conf mv /etc/redis/redis.conf /etc/redis/redis.bak</code> </pre> <br>  Auf redis3: <br><br><pre> <code class="bash hljs">cp /etc/redis/redis.conf /etc/redis/m3_redis.conf cp /etc/redis/redis.conf /etc/redis/s1_redis.conf mv /etc/redis/redis.conf /etc/redis/redis.bak</code> </pre> <br>  F√ºllen Sie die Konfigurationsdateien gem√§√ü der Vorlage aus: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> &lt;IP- &gt; protected-mode no <span class="hljs-comment"><span class="hljs-comment">#      ,    . port &lt;&gt; pidfile /var/run/redis_&lt;&gt;.pid # &lt;yes/no&gt; -   Redis Cluster cluster-enabled yes # ,      : #  ,  ,    . #         . cluster-config-file nodes-&lt;&gt;.conf #  ,  master-   , #          slaves #    . cluster-node-timeout 15000</span></span></code> </pre> <br>  Lassen Sie uns die Redis-Knoten starten: <br><br>  Knoten redis1: <br><br><pre> <code class="bash hljs">root@redis1:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-server /etc/redis/m1_redis.conf root@redis1:/etc/redis# redis-server /etc/redis/s2_redis.conf</span></span></code> </pre> <br>  Redis2-Knoten: <br><br><pre> <code class="bash hljs">root@redis2:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-server /etc/redis/m2_redis.conf root@redis2:/etc/redis# redis-server /etc/redis/s3_redis.conf</span></span></code> </pre> <br>  Redis3-Knoten: <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-server /etc/redis/m3_redis.conf root@redis3:/etc/redis# redis-server /etc/redis/s1_redis.conf</span></span></code> </pre> <br>  Um den Cluster zu konfigurieren, m√ºssen Sie das Dienstprogramm redis-cli client verwenden und ihm eine Liste von IP: Port-Serverpaaren √ºbergeben, die die Rollen von MASTER und SLAVE: spielen. <br><br><pre> <code class="bash hljs">redis-cli --cluster create redis1-ip:6381 redis2-ip:6382 redis3-ip:6383 redis1-ip:6382 redis2-ip:6383 redis3-ip:6381 --cluster-replicas 1</code> </pre> <br>  Die Option --cluster-replicas 1 gibt an, wie viele SLAVE jeder Master haben wird, und sie werden automatisch aus der Liste der √ºbertragenen Replikate ausgew√§hlt. <br><br><pre> <code class="bash hljs">root@redis1:~/redis/src<span class="hljs-comment"><span class="hljs-comment"># redis-cli --cluster create 192.168.9.51:6381 192.168.9.52:6382 192.168.9.53:6383 192.168.9.51:6382 192.168.9.52:6383 192.168.9.53:6381 --cluster-replicas 1 &gt;&gt;&gt; Performing hash slots allocation on 6 nodes... Master[0] -&gt; Slots 0 - 5460 Master[1] -&gt; Slots 5461 - 10922 Master[2] -&gt; Slots 10923 - 16383 Adding replica 192.168.9.52:6383 to 192.168.9.51:6381 Adding replica 192.168.9.51:6382 to 192.168.9.52:6382 Adding replica 192.168.9.53:6381 to 192.168.9.53:6383 &gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity [OK] Perfect anti-affinity obtained! M: e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381 slots:[0-5460] (5461 slots) master M: d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382 slots:[5461-10922] (5462 slots) master M: 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383 slots:[10923-16383] (5461 slots) master S: 182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382 replicates d499af3672b3063c7239572ec311ad3160f280ae S: 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383 replicates 3a41475e1613519c3ecdec695736a898262a24a5 S: 485ffb786e9763955e6f10ffc59247690ad9bc11 192.168.9.53:6381 replicates e92cb96fd6c20db7509662a248902e3751ebe95f Can I set the above configuration? (type 'yes' to accept): yes &gt;&gt;&gt; Nodes configuration updated &gt;&gt;&gt; Assign a different config epoch to each node &gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster Waiting for the cluster to join ..... &gt;&gt;&gt; Performing Cluster Check (using node 192.168.9.51:6381) M: e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381 slots:[0-5460] (5461 slots) master 1 additional replica(s) M: d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382 slots:[5461-10922] (5462 slots) master 1 additional replica(s) S: 485ffb786e9763955e6f10ffc59247690ad9bc11 192.168.9.53:6381 slots: (0 slots) slave replicates e92cb96fd6c20db7509662a248902e3751ebe95f S: 182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382 slots: (0 slots) slave replicates d499af3672b3063c7239572ec311ad3160f280ae S: 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383 slots: (0 slots) slave replicates 3a41475e1613519c3ecdec695736a898262a24a5 M: 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383 slots:[10923-16383] (5461 slots) master 1 additional replica(s) [OK] All nodes agree about slots configuration. &gt;&gt;&gt; Check for open slots... &gt;&gt;&gt; Check slots coverage... [OK] All 16384 slots covered.</span></span></code> </pre> <br>  Der Cluster ist korrekt aufgebaut.  Wir werden Informationen zum Cluster anzeigen: <br><br><pre> <code class="bash hljs">root@redis1:~/redis/src<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.51 -p 6381 192.168.9.51:6381&gt; CLUSTER INFO cluster_state:ok cluster_slots_assigned:16384 cluster_slots_ok:16384 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:6 cluster_size:3 cluster_current_epoch:6 cluster_my_epoch:1 cluster_stats_messages_ping_sent:1254 cluster_stats_messages_pong_sent:1243 cluster_stats_messages_sent:2497 cluster_stats_messages_ping_received:1238 cluster_stats_messages_pong_received:1254 cluster_stats_messages_meet_received:5 cluster_stats_messages_received:2497 192.168.9.51:6381&gt;</span></span></code> </pre> <br>  Um ein bestimmtes Replikat wie bei Redis Sentiel zu testen, k√∂nnen Sie den INFO-Replikationsbefehl verwenden: <br><br><pre> <code class="bash hljs">root@redis1:~/redis/src<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.51 -p 6381 192.168.9.51:6381&gt; INFO replication # Replication role:master connected_slaves:1 slave0:ip=192.168.9.53,port=6381,state=online,offset=1946,lag=0 master_replid:59cd95d394dad9d0e49042637fdfd5290db4abfe master_replid2:0000000000000000000000000000000000000000 master_repl_offset:1946 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:1946 192.168.9.51:6381&gt;</span></span></code> </pre> <br>  Versuchen wir, mehrere Schl√ºssel zu erstellen und zu √ºberpr√ºfen, ob diese Schl√ºssel auf den Replikaten angezeigt wurden: <br><br><pre> <code class="bash hljs">192.168.9.51:6381&gt; SET key1 test1 -&gt; Redirected to slot [9189] located at 192.168.9.52:6382 OK 192.168.9.52:6382&gt; SET key2 test2 -&gt; Redirected to slot [4998] located at 192.168.9.51:6381 OK 192.168.9.51:6381&gt; SET key3 test3 OK 192.168.9.51:6381&gt;</code> </pre> <br>  √úberpr√ºfen Sie auf M2: <br><br><pre> <code class="bash hljs">root@redis2:/home/user<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.52 -p 6382 192.168.9.52:6382&gt; GET key1 "test1" 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.51:6381 "test2" 192.168.9.51:6381&gt; GET key3 "test3" 192.168.9.51:6381&gt;</span></span></code> </pre> <br>  Und auf dem M3: <br><br><pre> <code class="bash hljs">root@redis3:/home/user<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.53 -p 6383 192.168.9.53:6383&gt; GET key1 -&gt; Redirected to slot [9189] located at 192.168.9.52:6382 "test1" 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.51:6381 "test2" 192.168.9.51:6381&gt; GET key3 "test3" 192.168.9.51:6381&gt;</span></span></code> </pre> <br>  Wir werden den redis1-Knoten deaktivieren und √ºberpr√ºfen, wie S1 funktioniert: <br><br><pre> <code class="bash hljs">192.168.9.52:6382&gt; CLUSTER NODES &lt;b&gt;182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382@16382 slave,fail d499af3672b3063c7239572ec311ad3160f280ae 1569509904727 1569509900000 4 connected&lt;/b&gt; 485ffb786e9763955e6f10ffc59247690ad9bc11 &lt;i&gt;192.168.9.53:6381@16381 master&lt;/i&gt; - 0 1569510017272 7 connected 0-5460 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383@16383 slave 3a41475e1613519c3ecdec695736a898262a24a5 0 1569510018274 5 connected &lt;b&gt;e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381@16381 master,fail - 1569509906731 1569509901721 1 connected&lt;/b&gt; 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383@16383 master - 0 1569510019275 3 connected 10923-16383 d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382@16382 myself,master - 0 1569510017000 2 connected 5461-10922</code> </pre> <br>  Wir sehen Informationen √ºber den Ausfall von M1 und S2 und dass S3 in den MASTER-Modus gewechselt ist. <br><br>  √úberpr√ºfen Sie, wo die Schl√ºssel gespeichert sind: <br><br><pre> <code class="bash hljs">192.168.9.52:6382&gt; GET key1 <span class="hljs-string"><span class="hljs-string">"test1"</span></span> 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.53:6381 <span class="hljs-string"><span class="hljs-string">"test2"</span></span> 192.168.9.53:6381&gt; GET key3 <span class="hljs-string"><span class="hljs-string">"test3"</span></span> 192.168.9.53:6381&gt;</code> </pre><br>  Schl√ºssel, die zuvor auf redis1 gespeichert waren, sind jetzt auf redis3 verf√ºgbar. <br><br>  Stellen Sie den Betrieb des Knotens redis1 wieder her und √ºberpr√ºfen Sie den Status der Knoten M1 und S2: <br><br><pre> <code class="bash hljs">192.168.9.53:6381&gt; CLUSTER NODES &lt;i&gt;e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381@16381 slave 485ffb786e9763955e6f10ffc59247690ad9bc11 0 1569511658217 7 connected 182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382@16382 slave d499af3672b3063c7239572ec311ad3160f280ae 0 1569511657000 4 connected&lt;/i&gt; d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382@16382 master - 0 1569511656000 2 connected 5461-10922 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383@16383 master - 0 1569511656000 3 connected 10923-16383 485ffb786e9763955e6f10ffc59247690ad9bc11 192.168.9.53:6381@16381 myself,master - 0 1569511656000 7 connected 0-5460 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383@16383 slave 3a41475e1613519c3ecdec695736a898262a24a5 0 1569511657216 5 connected</code> </pre> <br>  Der Zustand von M1 und S2 hat sich erholt, aber jetzt befindet sich M1 im SLAVE-Modus. <br><br>  Und die Schl√ºssel befinden sich auch auf dem redis3-Knoten: <br><br><pre> <code class="bash hljs">192.168.9.53:6383&gt; GET key1 -&gt; Redirected to slot [9189] located at 192.168.9.52:6382 <span class="hljs-string"><span class="hljs-string">"test1"</span></span> 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.53:6381 <span class="hljs-string"><span class="hljs-string">"test2"</span></span> 192.168.9.53:6383&gt; GET key3 -&gt; Redirected to slot [935] located at 192.168.9.53:6381 <span class="hljs-string"><span class="hljs-string">"test3"</span></span></code> </pre> <br>  Der Cluster ist konfiguriert und die Redis-Wiederherstellung wird getestet. <br><br>  Um auf DirectumRX-Dienste zugreifen zu k√∂nnen, m√ºssen Sie auch Reverse-Proxys konfigurieren, wie im Fall der Einrichtung von Redis Sentiel. <br><br><h2>  Anstelle einer Schlussfolgerung </h2><br>  In diesem Artikel wurde kein weiterer Weg zur Erh√∂hung der Redis-Fehlertoleranz in Betracht gezogen - die Verwendung eines Cluster-Ressourcenmanagers eines Drittanbieters, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pacemaker</a> .  In diesem Fall ist es m√∂glich, mit zwei Knoten auszukommen, es besteht jedoch eine hohe Wahrscheinlichkeit eines Datenverlusts im Notfall. <br><br>  F√ºr einen Reverse-Proxy (in diesem Fall HAProxy) ist es auch w√ºnschenswert, Fehlertoleranz bereitzustellen, aber dieses Problem ging auch √ºber den Rahmen dieses Artikels hinaus.  Wenn Sie sich f√ºr das Thema interessieren, k√∂nnen diese Bereitstellungsoptionen auch in separaten Artikeln mit schrittweiser Optimierung und Pr√ºfung der Ergebnisse ber√ºcksichtigt werden. <br><br>  Unter den folgenden Links erfahren Sie mehr √ºber das Thema: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redis Cluster Tutorial</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redis Sentinel-Dokumentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HAProxy-Konfigurationshandbuch</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469543/">https://habr.com/ru/post/de469543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469529/index.html">Text-Rendering hasst dich</a></li>
<li><a href="../de469531/index.html">"Programmiersprachen besser und schlechter zu vergleichen, ist eine v√∂llig idiotische Besch√§ftigung."</a></li>
<li><a href="../de469533/index.html">Probleme und Bedrohungen der biometrischen Identifizierung</a></li>
<li><a href="../de469537/index.html">Swift mit Snake kennenlernen</a></li>
<li><a href="../de469541/index.html">Zusammenstellung und Bereitstellung derselben Microservices mit werf und GitLab CI</a></li>
<li><a href="../de469545/index.html">Was ist neu im Linux-Kernel 5.3 - Grafiktreiber, Virtualisierung und √Ñnderungen im Netzwerksubsystem</a></li>
<li><a href="../de469549/index.html">Wie haben wir den Tarif f√ºr Windows VPS f√ºr 99 Rubel gemacht?</a></li>
<li><a href="../de469551/index.html">VDS mit Grafikkarte - wir wissen viel √ºber Perversionen</a></li>
<li><a href="../de469555/index.html">Ausstrahlung: Moscow Kubernetes Meetup # 6</a></li>
<li><a href="../de469557/index.html">Generische Recycler-Ansicht oder wie man keinen Boilerplate-Code schreibt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>