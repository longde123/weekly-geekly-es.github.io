<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë© üöµüèΩ üëÜüèª iOS Rede quando o aplicativo n√£o est√° sendo executado üî∫ üë©üèæ‚Äçüè≠ üôèüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Os usu√°rios esperam que a rede funcione ‚Äúmagicamente‚Äù e despercebida. Essa m√°gica depende dos desenvolvedores do sistema e dos aplicativos. √â dif√≠cil ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS Rede quando o aplicativo n√£o est√° sendo executado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/478566/"><p><img src="https://habrastorage.org/webt/ok/hf/in/okhfincdajhwvcffenwaoaj6wcs.png" alt="imagem"></p><br><p>  Os usu√°rios esperam que a rede funcione ‚Äúmagicamente‚Äù e despercebida.  Essa m√°gica depende dos desenvolvedores do sistema e dos aplicativos.  √â dif√≠cil influenciar o sistema, portanto, nos restringiremos ao aplicativo. </p><br><p>  Este t√≥pico √© complexo e h√° in√∫meros problemas.  Discutiremos aqueles que encontramos nos √∫ltimos meses.  Pe√ßo desculpas pelo volume imediatamente.  Em suma, de jeito nenhum, muitas pequenas coisas que valem a pena prestar aten√ß√£o. </p><a name="habracut"></a><br><p>  Para come√ßar, vamos lidar com a terminologia. </p><br><p>  A transfer√™ncia de dados ocorre em duas dire√ß√µes: </p><br><ul><li>  <em>download</em> (download, download de dados do servidor), </li><li>  <em>upload</em> (envio de dados para o servidor). </li></ul><br><p>  O aplicativo pode estar ativo, mas pode funcionar em segundo plano.  Formalmente, ele tem <a href="https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle">outros estados</a> , mas estamos interessados ‚Äã‚Äãapenas nestes: </p><br><ul><li>  <em>plano de fundo</em> (quando o aplicativo √© minimizado), </li><li>  <em>ativo</em> (quando o aplicativo est√° ativo, na tela). </li></ul><br><p> Padr√µes √∫teis: <em>retorno de chamada</em> , <em>delegado</em> ( <a href="https://developer.apple.com/documentation/swift/cocoa_design_patterns">Cocoa Design Patterns</a> , <a href="https://en.wikipedia.org/wiki/Callback_(computer_programming)">sobre retorno de chamada na Wikipedia</a> ).  Voc√™ tamb√©m precisa saber <a href="https://www.raywenderlich.com/3244963-urlsession-tutorial-getting-started"><code>  URLSession</code></a> (no artigo, o link tamb√©m menciona o trabalho em segundo plano com a rede, mas de passagem). </p><br><p>  Todos os exemplos est√£o escritos no <a href="https://docs.swift.org/swift-book/">Swift 5</a> , funcionam no iOS 11 e mais recentes (testados no iOS 11 e 12) e assumem o uso de solicita√ß√µes HTTP regulares.  Na maioria das vezes, tudo isso funcionar√°, come√ßando com o iOS 9, mas existem "nuances". </p><br><h2 id="obschaya-shema-raboty-s-setyu-urlsession">  O esquema geral de trabalhar com a rede.  URLSession </h2><br><p>  Trabalhar com a rede n√£o √© particularmente dif√≠cil: </p><br><ul><li>  crie a configura√ß√£o <a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration"><code>URLSessionConfiguration</code></a> ; </li><li>  crie uma inst√¢ncia de configura√ß√£o do <a href="https://developer.apple.com/documentation/foundation/urlsession"><code>URLSession</code></a> ; </li><li>  crie uma tarefa (usando <a href="https://developer.apple.com/documentation/foundation/urlsession/1411554-datatask"><code>session.dataTask(‚Ä¶)</code></a> e m√©todos similares); </li><li>  assine atualiza√ß√µes de tarefas.  As atualiza√ß√µes s√£o assincronizadas, podem chegar ao <em>delegado,</em> registrado quando a sess√£o √© criada, ou podem estar no <em>retorno de chamada,</em> criado quando a tarefa √© criada; </li><li>  quando vimos que a tarefa foi conclu√≠da, retornamos √† l√≥gica do aplicativo. </li></ul><br><p>  Um exemplo simples √© assim: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> session = <span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = <span class="hljs-type"><span class="hljs-type">URL</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataTask = session.dataTask(with: url) { data, response, error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//     //  callback,    }</span></span></code> </pre> <br><p>  Esse esquema √© semelhante para v√°rias tarefas, apenas as pequenas coisas mudam.  E at√© n√£o precisarmos continuar trabalhando com a rede ap√≥s o usu√°rio fechar o aplicativo, tudo √© relativamente simples. </p><br><blockquote>  Percebo imediatamente que, mesmo nesse cen√°rio, h√° muitas coisas interessantes.  √Äs vezes, voc√™ precisa trabalhar com redirecionamentos complicados, √†s vezes, precisa de autoriza√ß√£o, fixa√ß√£o de SSL ou tudo de uma vez.  Voc√™ pode ler muito sobre isso.  Por alguma raz√£o, trabalhar com a rede no estado de segundo plano √© descrito muito menos. </blockquote><br><h2 id="sozdanie-sessii-dlya-raboty-v-background">  Criando uma sess√£o para trabalhar em segundo plano </h2><br><p>  Qual √© a diferen√ßa entre <em>URLSession em</em> segundo <em>plano</em> e usual?  Funciona fora do processo de aplica√ß√£o, em algum lugar dentro do sistema.  Portanto, ele n√£o "morre" quando o processo de inscri√ß√£o √© conclu√≠do.  √â chamado de sess√£o em segundo plano (assim como o estado do aplicativo, que √© um pouco confuso) e requer configura√ß√µes espec√≠ficas.  Por exemplo, isto: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> configuration = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.background(withIdentifier: <span class="hljs-string"><span class="hljs-string">"com.my.app"</span></span>) configuration.sessionSendsLaunchEvents = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.isDiscretionary = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.allowsCellularAccess = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.shouldUseExtendedBackgroundIdleMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.waitsForConnectivity = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: configuration, delegate: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><p>  A configura√ß√£o possui muitos outros par√¢metros, mas eles est√£o diretamente relacionados √†s sess√µes em segundo plano: </p><br><ul><li>  <em>identificador</em> (passado no inicializador) √© uma sequ√™ncia usada para corresponder √†s sess√µes em segundo plano quando o aplicativo √© reiniciado.  Se o aplicativo reiniciar e voc√™ criar uma sess√£o em segundo plano com um identificador j√° usado em outra sess√£o em segundo plano, o novo ter√° acesso √†s tarefas da anterior.  A conclus√£o disso √© simples.  Para uma opera√ß√£o correta, voc√™ precisa que esse identificador seja exclusivo para seu aplicativo e permanente (voc√™ pode usar, por exemplo, uma derivada de aplicativos <em>bundleId</em> ); </li><li>  <em>sessionSendsLaunchEvents</em> indica se a sess√£o em segundo plano deve iniciar o aplicativo quando a transfer√™ncia de dados for conclu√≠da.  Se esse par√¢metro for definido como <code>false,</code> o gatilho n√£o ocorrer√° e o aplicativo receber√° todos os eventos na pr√≥xima vez em que for iniciado.  Se o par√¢metro for <code>true</code> , depois que a transfer√™ncia de dados for conclu√≠da, o sistema iniciar√° o aplicativo e chamar√° o m√©todo <code>AppDelegate: application(_:handleEventsForBackgroundURLSession:completionHandler:)</code> correspondente <code>AppDelegate: application(_:handleEventsForBackgroundURLSession:completionHandler:)</code> ; </li><li>  <em>isDiscretionary</em> permite que o sistema agende tarefas mais raramente.  Isso, por um lado, melhora a vida √∫til da bateria e, por outro, pode retardar a tarefa.  Ou talvez acelere.  Por exemplo, se um grande volume for baixado, o sistema poder√° pausar a tarefa at√© se conectar ao Wi-Fi e depois baixar tudo rapidamente sem gastar a Internet m√≥vel lenta (se for permitido, o que vem a seguir).  Se a tarefa for criada quando o aplicativo j√° estiver em segundo plano, esse par√¢metro ser√° automaticamente definido como <code>true</code> ; </li><li>  <em>allowCellularAccess</em> - um par√¢metro que mostra que voc√™ pode usar a comunica√ß√£o celular para trabalhar com a rede.  Eu n√£o brinquei com ele com cuidado, mas, de acordo com os coment√°rios, h√° (junto com uma troca de sistema semelhante) um grande n√∫mero de rakes; </li><li>  <em>shouldUseExtendedBackgroundIdleMode.</em>  Um par√¢metro √∫til que mostra que o sistema deve manter uma conex√£o com o servidor por mais tempo quando o aplicativo entrar em segundo plano.  Caso contr√°rio, a conex√£o ser√° interrompida. </li><li>  <em>waitsForConnectivity</em> Em um dispositivo m√≥vel, as comunica√ß√µes podem desaparecer por curtos per√≠odos de tempo.  As tarefas criadas neste momento podem ser suspensas at√© que uma conex√£o apare√ßa ou retornar imediatamente um erro "sem conex√£o".  O par√¢metro permite controlar esse comportamento.  Se for <code>false,</code> na aus√™ncia de comunica√ß√£o, a tarefa ser√° interrompida imediatamente com um erro.  Se <code>true</code> , aguarde at√© que um link apare√ßa. </li><li>  a √∫ltima linha (inicializador de sess√£o) cont√©m um par√¢metro importante, <em>delegar.</em>  Sobre ele - um pouco mais. </li></ul><br><h3 id="delegate-vs-callbacks">  Delegado x retornos de chamada </h3><br><p>  Como eu disse acima, existem duas maneiras de obter eventos de uma tarefa / de uma sess√£o.  O primeiro √© o <em>retorno de chamada:</em> </p><br><pre> <code class="swift hljs">session.dataTask(with: request) { data, response, error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ...   }</code> </pre> <br><p>  Nesse caso, o evento de conclus√£o da tarefa ser√° enviado ao fechamento, onde voc√™ precisar√° verificar se h√° um erro, o que h√° na resposta e quais dados chegaram. </p><br><p>  A segunda op√ß√£o para trabalhar com uma sess√£o √© atrav√©s do <em>delegado.</em>  Nesse caso, devemos criar uma classe que implemente os protocolos <a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate"><code>URLSessionDataDelegate</code></a> e (ou) outros pr√≥ximos (para diferentes tipos de tarefas, os protocolos s√£o ligeiramente diferentes).  Uma refer√™ncia a uma inst√¢ncia dessa classe reside em uma sess√£o e seus m√©todos s√£o chamados quando os eventos s√£o passados ‚Äã‚Äãpara o delegado.  O link pode ser registrado na sess√£o pelo inicializador.  No exemplo, o <code>self.</code> </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: configuration, delegate: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><p>  Para sess√µes regulares, ambos os m√©todos est√£o dispon√≠veis.  As sess√µes em segundo plano s√≥ podem ser usadas por um delegado. </p><br><p>  Ent√£o, montamos a sess√£o, criamos, vamos ver como fazer o download de algo. </p><br><h2 id="obschaya-shema-skachivaniya-dannyh-v-fone">  Esquema geral para baixar dados em segundo plano </h2><br><p>  Para baixar dados, geralmente √© necess√°rio formar uma <a href="https://developer.apple.com/documentation/foundation/urlrequest"><code> (URLRequest)</code></a> , registrando os par√¢metros / cabe√ßalhos / dados necess√°rios, criar uma <a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask"><code>URLSessionDownloadTask</code></a> e execut√°-la para execu√ß√£o.  Algo assim: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//  request,   let task = session.downloadTask(with: request) if #available(iOS 11, *) { task.countOfBytesClientExpectsToSend = [approximate size of request] task.countOfBytesClientExpectsToReceive = [approximate size of response] } task.resume()</span></span></code> </pre> <br><p>  Neste ponto, nada √© muito diferente da tarefa de download usual.  √â verdade que dois par√¢metros <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1411534-countofbytesexpectedtosend">apareceram countOfBytesClientExpectsToSend</a> / <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1410663-countofbytesexpectedtoreceive">countOfBytesClientExpectsToReceive</a> , eles mostram a quantidade de dados que planejamos enviar na solicita√ß√£o e voltamos √† resposta.  Isso √© necess√°rio para que o sistema possa planejar mais corretamente o trabalho com a tarefa, fa√ßa o download mais r√°pido, sem sobrecarregar.  Esses valores n√£o precisam ser precisos. </p><br><p>  Ap√≥s <code>resume()</code> tarefa ser√° executada.  Durante a transfer√™ncia de dados, o progresso ser√° transmitido (sobre isso - leia abaixo, tamb√©m existem op√ß√µes) e, ap√≥s a conclus√£o, v√°rios m√©todos de delega√ß√£o ser√£o executados.  Entre eles, h√° um muito importante: </p><br><pre> <code class="swift hljs">urlSession(<span class="hljs-number"><span class="hljs-number">_</span></span>:downloadTask:didFinishDownloadingTo:)</code> </pre> <br><p>  O fato √© que o download ocorre em um arquivo tempor√°rio, ap√≥s o qual o aplicativo tem a oportunidade de mover esse arquivo para algum lugar ou fazer outra coisa com ele.  Este arquivo tempor√°rio est√° dispon√≠vel apenas dentro deste m√©todo, depois de sair dele, o arquivo √© exclu√≠do e nada pode ser feito com ele. </p><br><p>  Ap√≥s esse m√©todo importante, outro m√©todo ser√° chamado onde o erro cair√° se ocorrer.  Se n√£o houver <code>error</code> , o <code>error</code> ser√° <code>nil.</code> </p><br><pre> <code class="swift hljs">urlSession(<span class="hljs-number"><span class="hljs-number">_</span></span>:task:didCompleteWithError:)</code> </pre> <br><p>  E o que acontece no final, se o aplicativo entrou em segundo plano ou foi conclu√≠do?  Como chamar m√©todos de delega√ß√£o?  N√£o √© f√°cil aqui. </p><br><p>  Se o download de algo iniciado pelo aplicativo tiver terminado e o sinalizador <code>sessionSendsLaunchEvents</code> na configura√ß√£o da sess√£o, o sistema iniciar√° o aplicativo (em segundo plano) e chamar√° o m√©todo <a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622941-application%3Flanguage%3Dobjc">application (_: handleEventsForBackgroundURLSession: conclus√£oHandler :)</a> no <code>AppDelegate,</code> . </p><br><p>  Nesse m√©todo, o aplicativo deve: </p><br><ul><li>  salve o <code>completionHandler</code> (ele precisar√° ser chamado depois de algum tempo, de forma ass√≠ncrona e no encadeamento principal); </li><li>  recrie uma sess√£o em segundo plano com o mesmo identificador de antes (e que √© passado para esse m√©todo, caso haja v√°rias sess√µes em segundo plano); </li><li>  em uma sess√£o rec√©m-criada, os eventos chegar√£o ao delegado (em particular, a muito importante <code>urlSession(_:downloadTask:didFinishDownloadingTo:)</code> ), voc√™ precisa process√°-los, copiar os arquivos onde quiser; </li><li>  depois que todos os m√©todos s√£o chamados, outro m√©todo delegado √© chamado, chamado <code>urlSessionDidFinishEvents(forBackgroundURLSession:)</code> e no qual voc√™ precisar√° chamar o <code>completionHandler.</code> armazenado anteriormente <code>completionHandler.</code> </li></ul><br><blockquote>  √â importante.  √â necess√°rio chamar a <code>completionHandler</code> no thread principal usando <a href="https://developer.apple.com/documentation/dispatch/dispatchqueue/1781006-main"><code>DispatchQueue.main.async(...)</code></a> . </blockquote><p>  Ao mesmo tempo, √© preciso lembrar que tudo isso acontece em um aplicativo que funciona em segundo plano.  E isso significa que os recursos (tempo de execu√ß√£o) s√£o limitados.  Salve rapidamente os arquivos onde precisar, altere os estados necess√°rios no aplicativo e desligue - √© tudo o que pode ser feito.  Se voc√™ quiser fazer mais, pode usar <a href="https://developer.apple.com/documentation/uikit/uiapplication/1623031-beginbackgroundtask"><code>UIApplication.beginBackgroundTask()</code></a> ou as novas <a href="https://developer.apple.com/documentation/backgroundtasks">BackgroundTasks</a> . </p><br><h2 id="obschaya-shema-fonovoy-otpravki-dannyh">  Esquema geral de envio de dados gerais </h2><br><p>  O upload de arquivos para o servidor tamb√©m funciona com restri√ß√µes.  No entanto, tudo come√ßa de maneira semelhante: formamos uma solicita√ß√£o, criamos uma tarefa (agora ser√° <a href="https://developer.apple.com/documentation/foundation/urlsessionuploadtask"><code>URLSessionUploadTask)</code></a> , executamos a tarefa.  Qual √© o problema? </p><br><p>  O problema √© como criamos a solicita√ß√£o.  Normalmente, formamos os dados enviados como <code>Data</code> .  <code>URLSession,</code> segundo <code>URLSession,</code> n√£o sabe como trabalhar com isso.  E com uma solicita√ß√£o de streaming ( <code>uploadTask(withStreamedRequest:)</code> ) tamb√©m n√£o sabe como.  √â necess√°rio escrever tudo o que precisa ser enviado para um arquivo e criar uma tarefa de envio a partir do arquivo.  Acontece de alguma forma assim: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileUrl = methodThatSavesFileAndRetursItsUrl(...) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = session.uploadTask(with: request, fromFile: fileUrl) task.resume()</code> </pre> <br><p>  Mas n√£o h√° necessidade de registrar o tamanho, o <code>URLSession</code> pode ver por si pr√≥prio.  Ap√≥s o envio, o mesmo m√©todo delegado <code>urlSession(_:task:didCompleteWithError:)</code> como durante o download.  E assim, se o aplicativo foi morto ou entrou em segundo plano durante o processo de envio, chegar√° o <code>application(_:handleEventsForBackgroundURLSession:completionHandler:),</code> que dever√° ser processado exatamente de acordo com as mesmas regras do download de dados. </p><br><h2 id="chto-takoe-prilozhenie-zaversheno">  O que √© um aplicativo completo? </h2><br><p>  Para testar os downloads e envios em segundo plano, voc√™ precisa simular a conclus√£o do aplicativo (o trabalho em segundo plano com a rede foi especialmente projetado para sobreviver a isso).  Como fazer isso?  Inicialmente - de jeito nenhum.  Ou seja, n√£o existe um m√©todo regular (autorizado, p√∫blico) que permita que isso seja feito.  Vamos ver onde est√° o ancinho. </p><br><ul><li>  Primeiro, apenas fechar o aplicativo (pressionando o bot√£o In√≠cio ou fazendo um gesto apropriado) n√£o funcionar√°.  Isso n√£o mata o aplicativo, mas apenas o envia para segundo plano.  O significado de trabalhar com uma sess√£o em segundo plano √© que ele funciona mesmo que o aplicativo seja "completamente, completamente" eliminado; </li><li>  segundo, √© imposs√≠vel que um depurador (AppCode, Xcode ou apenas LLDB) esteja conectado; ele n√£o permitir√° que o aplicativo morra nem um pouco depois de ser "fechado"; </li><li>  em terceiro lugar, voc√™ n√£o pode matar o aplicativo na barra de tarefas (gerenciador de tarefas, Home duplo ou furto lento "up").  Assim, um aplicativo morto √© considerado morto "permanentemente" e o sistema interrompe, juntamente com essa a√ß√£o, as sess√µes em segundo plano associadas ao aplicativo; </li><li>  quarto, voc√™ precisa testar esse processo em um dispositivo real.  N√£o h√° problemas com o log (veja abaixo) e √© mais depurado.  Argumenta-se que o simulador tamb√©m deve funcionar como deveria.  Mas notei esquisitices inexplic√°veis ‚Äã‚Äãque n√£o consigo explicar com nada al√©m das falhas do simulador.  Em geral, teste no dispositivo; </li><li>  a √∫nica maneira razo√°vel de fazer o que voc√™ quer √© com a fun√ß√£o <code>exit(int)</code> .  Como todos sabem, voc√™ n√£o pode envi√°-lo para o servidor ( <a href="https://developer.apple.com/library/archive/qa/qa1561">isso contradiz diretamente os requisitos</a> ), mas por enquanto estamos apenas testando - n√£o √© assustador.  Conhe√ßo duas op√ß√µes razo√°veis ‚Äã‚Äãpara usar esta fun√ß√£o: <br><ul><li>  chame-o automaticamente no m√©todo <code>AppDelegate.applicationDidEnterBackground(_:)</code> para que o aplicativo seja <code>AppDelegate.applicationDidEnterBackground(_:)</code> imediatamente ap√≥s sair para o Springboard; </li><li>  crie um componente na interface (por exemplo, um bot√£o ou pendure uma a√ß√£o em um gesto), clicando no qual a <code>exit(...).</code> <br>  Nesse caso, o aplicativo ser√° interrompido e o trabalho em segundo plano com a rede deve continuar.  E, ap√≥s algum tempo, devemos receber uma chamada para o <code>application(_:handleEventsForBackgroundURLSession:completionHandler:).</code> </li></ul></li></ul><br><h2 id="kak-protokolirovat-rabotu-prilozheniya-esli-nelzya-polzovatsya-otladochnoy-konsolyu-xcode">  Como registrar o aplicativo se voc√™ n√£o pode usar o console de depura√ß√£o do Xcode? </h2><br><p>  Bem, √© imposs√≠vel.  Voc√™ pode, se voc√™ realmente quiser.  Voc√™ n√£o pode iniciar a partir do Xcode, e se o aplicativo, por exemplo, j√° tiver sido reiniciado devido a um evento do sistema, voc√™ poder√° anexar (anexar ao processo) ao aplicativo e desenfileirar.  Mas essa solu√ß√£o √© t√£o positiva que voc√™ precisa testar de alguma forma o pr√≥prio processo de reinicializa√ß√£o. </p><br><p>  Voc√™ pode usar <a href="https://en.wikipedia.org/wiki/Log_file">protocolos (logs, logs)</a> .  Existem v√°rias op√ß√µes para sua implementa√ß√£o: </p><br><ul><li> <a href="https://developer.apple.com/documentation/swift/1541053-print"><code>print.</code></a>  √â frequentemente usado como "vamos lan√ßar algo rapidamente".  No nosso caso, √© imposs√≠vel usar, j√° que n√£o temos acesso ao console no dispositivo, o aplicativo √© encerrado. </li><li> <a href="https://developer.apple.com/documentation/foundation/1409759-nslog"><code>NSLog.</code></a>  Ele funcionar√°, pois usa o terceiro m√©todo. </li><li> <a href="https://developer.apple.com/documentation/os/logging"><code>os_log.</code></a>  O m√©todo mais correto que permite configurar corretamente os logs, afix√°-los com o tipo desejado, desabilitar ap√≥s a depura√ß√£o, sem cortar o pr√≥prio c√≥digo e assim por diante. </li></ul><br><blockquote>  Aten√ß√£o!  Com o <code>os_log</code> existem problemas (por exemplo, a falta de logs de depura√ß√£o) que s√£o executados apenas no simulador, mas n√£o executados neste dispositivo.  Use o dispositivo </blockquote><p>  Como usar o <code>os_log,</code> leia como configur√°-lo corretamente na <a href="https://developer.apple.com/documentation/os/logging">documenta√ß√£o</a> da <a href="https://developer.apple.com/documentation/os/logging">Apple</a> .  Em particular, voc√™ deve habilitar os logs de <code>debug</code> e <code>info</code> , por padr√£o eles est√£o ocultos. </p><br><h2 id="otslezhivanie-progressa-skachivaniya-ili-otpravki-dannyh">  Acompanhar o andamento do download ou envio de dados </h2><br><p>  No processo de transfer√™ncia de dados, quero entender quanto j√° foi enviado, quanto resta.  Existem duas maneiras de fazer isso.  O primeiro √© usar m√©todos de delega√ß√£o: </p><br><ul><li>  para enviar, voc√™ precisa usar <code>urlSession(_:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:)</code> </li><li>  existe um m√©todo <code>urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)</code> semelhante para fazer o download <code>urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)</code> </li></ul><br><p>  Esses m√©todos s√£o chamados sempre que o pr√≥ximo dado √© baixado ou enviado.  Eles n√£o s√£o necessariamente consistentes com os m√©todos para concluir o processo, mas tamb√©m podem ser chamados ap√≥s os dados terem sido completamente baixados ou enviados, portanto, √© imposs√≠vel determinar que "tudo terminou". </p><br><p>  O segundo m√©todo √© mais interessante.  O fato √© que cada tarefa fornece um objeto do tipo <a href="https://developer.apple.com/documentation/foundation/progress"><code>Progress</code></a> (est√° no campo <code>task.progress</code> ), que fornece a capacidade de monitorar um processo arbitr√°rio, incluindo o processo de transfer√™ncia de dados.  Como ele √© interessante?  Duas coisas: </p><br><ul><li>  dos objetos <code>Progress</code> , voc√™ pode criar uma √°rvore de execu√ß√£o de tarefas, cada n√≥ mostrando o qu√£o avan√ßadas s√£o todas as tarefas que ela cont√©m.  Por exemplo, se voc√™ precisar enviar cinco arquivos, poder√° acompanhar o progresso de cada um, progredir em geral, adicionar outros cinco e monitorar um progresso dos pais, vinculando suas atualiza√ß√µes a algum elemento da interface; </li><li>  voc√™ pode adicionar seu progresso a essa √°rvore e tamb√©m pode pausar e cancelar a√ß√µes associadas ao progresso adicionado. </li></ul><br><p>  Como isso est√° relacionado ao download ou envio de dados em segundo plano?  De jeito nenhum.  Os m√©todos delegados n√£o s√£o chamados e os objetos de progresso morrem quando o aplicativo termina.  Para sess√µes em segundo plano, esse m√©todo n√£o √© adequado. </p><br><h2 id="peredacha-zadach-iz-obychnoy-sessii-v-background-sessiyu">  "Transferir" tarefas de uma sess√£o regular para uma sess√£o em segundo plano </h2><br><p>  Bem, √© mais dif√≠cil trabalhar com uma sess√£o em segundo plano.  Mas isso √© conveniente!  Nem uma √∫nica tarefa ser√° perdida; sempre obteremos todos os dados solicitados; por que nem sempre usamos a sess√£o em segundo plano? </p><br><p>  Infelizmente, ela tem defeitos e s√©rios.  Por exemplo, uma sess√£o em segundo plano √© mais lenta.  Nas minhas experi√™ncias, a velocidade variou v√°rias vezes.  Em segundo lugar, a execu√ß√£o em segundo plano de uma tarefa pode ser atrasada (especialmente se o par√¢metro <code>isDiscretionary</code> estiver <code>isDiscretionary</code> , o que, como mencionei, √© sempre <code>true</code> para tarefas criadas enquanto o aplicativo est√° sendo executado em segundo plano. </p><br><p>  Portanto, toda vez que voc√™ cria uma tarefa, precisa entender exatamente quais crit√©rios para seu trabalho, onde adicion√°-lo, a uma sess√£o regular ou em segundo plano.  Normal corre mais r√°pido, inicia imediatamente.  Segundo plano - mais longo, n√£o imediatamente, mas n√£o ser√° eliminado se o usu√°rio fechar o aplicativo. </p><br><p>  Se n√£o houver um entendimento √≥bvio de que a tarefa deve ser executada na sess√£o em segundo plano (por exemplo, transfer√™ncia n√£o cr√≠tica de uma quantidade muito grande de dados, como sincroniza√ß√£o ou backup), vale a pena fazer o seguinte: </p><br><ul><li>  inicie a tarefa em uma sess√£o regular.  Nesse caso, execute <em>backgroundTask</em> para que o sistema entenda que precisamos de tempo para concluir a tarefa.  Isso leva algum tempo (at√© v√°rios minutos, mas algo foi quebrado no iOS 13 e n√£o est√° claro o que est√° acontecendo com ele) para que a tarefa possa ser conclu√≠da. </li><li>  se n√£o houver tempo, no final da tarefa em <em>segundo plano,</em> transferiremos a tarefa de uma sess√£o regular para uma em segundo plano, onde ela continua a funcionar e termina quando pode. </li></ul><br><p>  Como transferir?  De jeito nenhum.  Basta matar (cancelar) a tarefa usual e criar um plano de fundo semelhante (com a mesma solicita√ß√£o).  Por que isso √© chamado de "transfer√™ncia"?  E por que entre aspas? </p><br><p>  N√£o h√° transfer√™ncia para enviar dados.  Existe exatamente o que √© descrito.  Eles mataram uma tarefa, lan√ßaram outra, todos os dados enviados pela primeira vez foram perdidos. </p><br><p>  Para baixar, a situa√ß√£o √© diferente.  O sistema sabe para qual arquivo a solicita√ß√£o foi baixada.  Se voc√™ executar v√°rias tarefas para baixar o mesmo URL, por exemplo, ele n√£o executar√° a solicita√ß√£o v√°rias vezes.  Os dados s√£o baixados uma vez, ap√≥s o qual o m√©todo delegado final (ou retorno de chamada) ser√° executado v√°rias vezes.  <a href="https://medium.com/%40sdrzn/handling-multiple-urlsession-tasks-efficiently-91c0957a7d77">Um experimento √© descrito aqui</a> que confirma isso.  Provavelmente, o cache HTTP padr√£o √© usado dentro, o mesmo que nos navegadores. </p><br><p>  Aqui est√° o c√≥digo de exemplo que faz isso: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = foregroundSession.downloadTask(with: request) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> backgroundId = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.beginBackgroundTask { task.cancel() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = backgroundSession.downloadTask(with: request) task.resume() } task.resume()</code> </pre> <br><p>  Se a tarefa terminar antes que o <code>expirationHandler</code> funcione, lembre-se de chamar <code>UIApplication.shared.endBackgroundTask(backgroundId)</code> .  Isso √© descrito em mais detalhes na <a href="https://developer.apple.com/documentation/uikit/uiapplication/1623031-beginbackgroundtask">documenta√ß√£o</a> . </p><br><p>  Para ajudar o sistema a continuar o download (por exemplo, o cancelamento pode excluir o arquivo tempor√°rio antes que o download em segundo plano seja retomado), existem m√©todos especiais: </p><br><ul><li>  para obter os dados necess√°rios para a renova√ß√£o, voc√™ precisa cancelar a tarefa anterior usando o m√©todo <a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask/1411634-cancel">cancel (byProducingResumeData :)</a> ; </li><li>   ,    : <a href="https://developer.apple.com/documentation/foundation/urlsession/1409226-downloadtask">downloadTask(withResumeData:) -&gt; URLSessionDownloadTask</a> ,   - : </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = foregroundSession.downloadTask(with: request) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> backgroundId = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.beginBackgroundTask { task.cancel { data <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task: <span class="hljs-type"><span class="hljs-type">URLSessionDownloadTask</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = data { task = backgroundSession.downloadTask(withResumeData: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { task = backgroundSession.downloadTask(with: request) } task.resume() } }</code> </pre> <br><h2 id="grabli-na-kotorye-ya-nastupil"> ,     </h2><br><h3 id="logi">  Logs </h3><br><p>       ‚Äî  ,  .   ‚Äî  ,    .  background    ,    . </p><br><p> ,  ,  background     -,       ,      ,          (   UI,      ). , ,    ‚Äî .     ,   ‚Äî ,  ,  <code>os_log.</code> ( <code>NSLog)</code> </p><br><h3 id="priostanovka-biznes-logiki">  - </h3><br><p>        -  ,         .         ,     -  .    ,      ,   ,      ( )     . ,    ,      -,  ,  .     ‚Äî       ‚Äî ,    .   ‚Äî  ,       -  ( ),       ,      . </p><br><h3 id="testirovanie-na-ustroystve">    </h3><br><p>     .            (  ),    .  ,      ,    ,       . </p><br><h3 id="ogranicheniya">  Limita√ß√µes </h3><br><p>    : </p><br><ul><li>   ,  ; </li><li>  ‚Äî  ,    ; </li><li>        ,     (,    ‚Ä¶); </li></ul><br><h3 id="melochi">  </h3><br><ul><li>        ,    <code>(task.taskIdentifier)</code>  ,     (Dictionary).    ,          1,   . </li><li>   , <code>URLSession.getAllTasks</code> .    ,        background .  ,    .   ,    . ¬Ø\_(„ÉÑ)_/¬Ø </li><li>   ,  ,         ,    ,     . </li></ul><br><p>       ,      background ,      .      ,      -    .      : <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html">https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW1</a> .   , : </p><br><blockquote> If your app extension initiates a background NSURLSession task, you must also set up a shared container that both the extension and its containing app can access. Use the sharedContainerIdentifier property of the NSURLSessionConfiguration class to specify an identifier for the shared container so that you can access it later. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt478566/">https://habr.com/ru/post/pt478566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt478546/index.html">Websockets Alguma experi√™ncia em desenvolvimento e opera√ß√£o. N√≥s modificamos o cliente</a></li>
<li><a href="../pt478550/index.html">Como gerenciar um rel√≥gio? An√°lise da pista front-end do segundo campeonato de programa√ß√£o</a></li>
<li><a href="../pt478552/index.html">Segundo applet, fechando-o e bot√µes transparentes no Processamento 3</a></li>
<li><a href="../pt478554/index.html">Webinar "SRE - hype ou o futuro?" 12 de dezembro √†s 11:00</a></li>
<li><a href="../pt478564/index.html">Como n√≥s do TsIAN domamos terabytes de logs</a></li>
<li><a href="../pt478572/index.html">Bot em redes neurais: como um assistente virtual funciona e aprende</a></li>
<li><a href="../pt478574/index.html">A verdade sobre os freios ferrovi√°rios: Parte 4 - Freios de passageiros</a></li>
<li><a href="../pt478580/index.html">Como o chip gr√°fico da Super Nintendo funcionou: Guia Super PPU</a></li>
<li><a href="../pt478582/index.html">Relat√≥rio Global VPN sobre dispositivos m√≥veis em 2019</a></li>
<li><a href="../pt478584/index.html">Internos da JVM, Parte 2 - Estrutura do Arquivo de Classes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>