<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîÄ üëâ ‚ôèÔ∏è Exce√ß√µes devastadoras üë©üèΩ‚Äçüéì ü§πüèæ üèçÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mais uma vez, por que √© ruim lan√ßar exce√ß√µes em destruidores 


 Muitos especialistas em C ++ (por exemplo, Herb Sutter ) nos ensinam que lan√ßar exce√ß...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exce√ß√µes devastadoras</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433944/"><h2 id="eschyo-raz-o-tom-pochemu-ploho-brosat-isklyucheniya-v-destruktorah">  Mais uma vez, por que √© ruim lan√ßar exce√ß√µes em destruidores </h2><br><p>  Muitos especialistas em C ++ (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Herb Sutter</a> ) nos ensinam que lan√ßar exce√ß√µes em destruidores √© ruim, porque voc√™ pode entrar no destruidor durante a promo√ß√£o da pilha com uma exce√ß√£o j√° lan√ßada e, se outra exce√ß√£o for lan√ßada nesse momento, <em>std</em> ser√° chamado <em>:: terminate ()</em> .  O padr√£o de linguagem C ++ 17 (a seguir, refiro-me √† vers√£o dispon√≠vel gratuitamente do rascunho <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N4713</a> ) sobre este t√≥pico nos diz o seguinte: </p><a name="habracut"></a><br><blockquote>  <strong>18.5.1 A fun√ß√£o std :: terminate () [except.terminate]</strong> <br><br>  1 Em algumas situa√ß√µes, o tratamento de exce√ß√µes deve ser abandonado para t√©cnicas de tratamento de erros menos sutis.  [Nota: <br><br>  Essas situa√ß√µes s√£o: <br><br>  ... <br><br>  (1.4) quando a destrui√ß√£o de um objeto durante o desenrolamento da pilha (18.2) terminar lan√ßando uma exce√ß√£o, ou <br><br>  ... <br><br>  - nota final] </blockquote><p>  Vamos verificar um exemplo simples: </p><br><pre><code class="plaintext hljs">#include &lt;iostream&gt; class PrintInDestructor { public: ~PrintInDestructor() noexcept { std::cerr &lt;&lt; "~PrintInDestructor() invoked\n"; } }; void throw_int_func() { std::cerr &lt;&lt; "throw_int_func() invoked\n"; throw 1; } class ThrowInDestructor { public: ~ThrowInDestructor() noexcept(false) { std::cerr &lt;&lt; "~ThrowInDestructor() invoked\n"; throw_int_func(); } private: PrintInDestructor member_; }; int main(int, char**) { try { ThrowInDestructor bad; throw "BANG!"; } catch (int i) { std::cerr &lt;&lt; "Catched int exception: " &lt;&lt; i &lt;&lt; "\n"; } catch (const char* c) { std::cerr &lt;&lt; "Catched const char* exception: " &lt;&lt; c &lt;&lt; "\n"; } catch (...) { std::cerr &lt;&lt; "Catched unknown exception\n"; } return 0; }</code> </pre> <br><p>  Resultado: </p><br><pre> <code class="plaintext hljs">~ThrowInDestructor() invoked throw_int_func() invoked ~PrintInDestructor() invoked terminate called after throwing an instance of 'int' Aborted</code> </pre> <br><p>  Observe que o destruidor <em>PrintInDestructor</em> ainda √© chamado, ou seja,  depois de lan√ßar a segunda exce√ß√£o, a promo√ß√£o da pilha n√£o √© interrompida.  A Norma (o mesmo par√°grafo 18.5.1) sobre este assunto diz o seguinte: </p><br><blockquote>  2 ... Na situa√ß√£o em que nenhum manipulador correspondente √© encontrado, <br>  √© definido pela implementa√ß√£o se a pilha √© ou n√£o desenrolada antes que std :: terminate () seja chamado.  Em <br>  a situa√ß√£o em que a procura de um manipulador (18.3) encontra o bloco mais externo de uma fun√ß√£o com um <br>  especifica√ß√£o de exce√ß√£o n√£o lan√ßadora (18.4), √© definido pela implementa√ß√£o se a pilha √© desenrolada, <br>  desenrolou parcialmente ou n√£o desenrolou antes que std :: terminate () seja chamado ... </blockquote><p>  Testei este exemplo em v√°rias vers√µes do <strong>GCC</strong> (8.2, 7.3) e <strong>Clang</strong> (6.0, 5.0), em todos os lugares em que a promo√ß√£o da pilha continua.  Se voc√™ se deparar com um compilador onde a defini√ß√£o de implementa√ß√£o √© diferente, escreva sobre isso nos coment√°rios. </p><br><p>  Tamb√©m deve ser observado que <em>std :: terminate ()</em> √© chamado quando a pilha √© desenrolada somente quando uma exce√ß√£o √© lan√ßada para fora do destruidor.  Se houver um bloco try / catch dentro do destruidor que captura a exce√ß√£o e n√£o lan√ßa mais, isso n√£o interrompe a promo√ß√£o da pilha da exce√ß√£o externa. </p><br><pre> <code class="plaintext hljs">class ThrowCatchInDestructor { public: ~ThrowCatchInDestructor() noexcept(false) { try { throw_int_func(); } catch (int i) { std::cerr &lt;&lt; "Catched int in ~ThrowCatchInDestructor(): " &lt;&lt; i &lt;&lt; "\n"; } } private: PrintInDestructor member_; }; int main(int, char**) { try { ThrowCatchInDestructor good; std::cerr &lt;&lt; "ThrowCatchInDestructor instance created\n"; throw "BANG!"; } catch (int i) { std::cerr &lt;&lt; "Catched int exception: " &lt;&lt; i &lt;&lt; "\n"; } catch (const char* s) { std::cerr &lt;&lt; "Catched const char* exception: " &lt;&lt; s &lt;&lt; "\n"; } catch (...) { std::cerr &lt;&lt; "Catched unknown exception\n"; } return 0; }</code> </pre> <br><p>  exibe </p><br><pre> <code class="plaintext hljs">ThrowCatchInDestructor instance created throw_int_func() invoked Catched int in ~ThrowCatchInDestructor(): 1 ~PrintInDestructor() invoked Catched const char* exception: BANG!</code> </pre> <br><p>  Como evitar situa√ß√µes desagrad√°veis?  Em teoria, tudo √© simples: nunca jogue exce√ß√µes no destruidor.  No entanto, na pr√°tica, n√£o √© t√£o simples realizar com perfei√ß√£o esse requisito simples. </p><br><h2 id="esli-nelzya-no-ochen-hochetsya">  Se voc√™ n√£o pode, mas realmente quer ... </h2><br><blockquote>  Notarei imediatamente que n√£o estou tentando justificar o lan√ßamento de exce√ß√µes ao destruidor e, seguindo Sutter, Meyers e outros gurus de C ++, pe√ßo que <strong>tente</strong> nunca fazer isso (pelo menos no novo c√≥digo).  No entanto, na pr√°tica real, um programador pode muito bem encontrar c√≥digo legado, o que n√£o √© t√£o f√°cil de levar a altos padr√µes.  Al√©m disso, as t√©cnicas frequentemente descritas abaixo podem ser √∫teis durante o processo de depura√ß√£o. </blockquote><p>  Por exemplo, estamos desenvolvendo uma biblioteca com uma classe de wrapper que encapsula o trabalho com um determinado recurso.  De acordo com os princ√≠pios da RAII, pegamos o recurso no construtor e devemos liber√°-lo no destruidor.  Mas e se uma tentativa de liberar um recurso falhar?  Op√ß√µes para resolver este problema: </p><br><ul><li>  Ignore o erro.  Ruim, porque estamos escondendo um problema que pode afetar outras partes do sistema. </li><li>  Escreva no log.  Melhor do que simplesmente ignor√°-lo, mas ainda assim ruim, porque  nossa biblioteca n√£o sabe nada sobre as pol√≠ticas de registro adotadas no sistema que a utiliza.  O log padr√£o pode ser redirecionado para / dev / null, como resultado, novamente, n√£o veremos um erro. </li><li>  Leve a libera√ß√£o do recurso para uma fun√ß√£o separada que retorne um valor ou gere uma exce√ß√£o e force o usu√°rio da classe a cham√°-lo por conta pr√≥pria.  √â ruim, porque o usu√°rio pode se esquecer de fazer isso e receberemos um vazamento de recursos. </li><li>  Lance uma exce√ß√£o.  Bom em casos comuns, como  o usu√°rio da classe pode capturar a exce√ß√£o e obter informa√ß√µes sobre o erro da maneira padr√£o.  Ruim durante a promo√ß√£o da pilha, como  leva a <em>std :: terminate ()</em> . </li></ul><br><p>  Como entender se estamos atualmente no processo de promover a pilha por exce√ß√£o ou n√£o?  No C ++, existe uma fun√ß√£o especial <em>std :: uncaught_exception () para isso</em> .  Com sua ajuda, podemos lan√ßar uma exce√ß√£o com seguran√ßa em uma situa√ß√£o normal ou fazer algo menos correto, mas n√£o levando a uma exce√ß√£o durante a promo√ß√£o da pilha. </p><br><pre> <code class="plaintext hljs">class ThrowInDestructor { public: ~ThrowInDestructor() noexcept(false) { if (std::uncaught_exception()) { std::cerr &lt;&lt; "~ThrowInDestructor() stack unwinding, not throwing\n"; } else { std::cerr &lt;&lt; "~ThrowInDestructor() normal case, throwing\n"; throw_int_func(); } } private: PrintInDestructor member_; }; int main(int, char**) { try { ThrowInDestructor normal; std::cerr &lt;&lt; "ThrowInDestructor normal destruction\n"; } catch (int i) { std::cerr &lt;&lt; "Catched int exception: " &lt;&lt; i &lt;&lt; "\n"; } try { ThrowInDestructor stack_unwind; std::cerr &lt;&lt; "ThrowInDestructor stack unwinding\n"; throw "BANG!"; } catch (int i) { std::cerr &lt;&lt; "Catched int exception: " &lt;&lt; i &lt;&lt; "\n"; } catch (const char* s) { std::cerr &lt;&lt; "Catched const char* exception: " &lt;&lt; s &lt;&lt; "\n"; } catch (...) { std::cerr &lt;&lt; "Catched unknown exception\n"; } return 0; }</code> </pre> <br><p>  Resultado: </p><br><pre> <code class="plaintext hljs">ThrowInDestructor normal destruction ~ThrowInDestructor() normal case, throwing throw_int_func() invoked ~PrintInDestructor() invoked Catched int exception: 1 ThrowInDestructor stack unwinding ~ThrowInDestructor() stack unwinding, not throwing ~PrintInDestructor() invoked Catched const char* exception: BANG!</code> </pre> <br><p>  Observe que a fun√ß√£o <em>std :: uncaught_exception ()</em> est√° <em>obsoleta</em> desde o C ++ Standard 17; portanto, para compilar o exemplo, a vorning correspondente deve ser suprimida (consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio com exemplos do artigo</a> ). </p><br><p>  O problema com essa fun√ß√£o √© que ela verifica se estamos girando a pilha por exce√ß√£o.  Mas √© imposs√≠vel entender se o destruidor atual √© chamado durante o processo de promo√ß√£o da pilha.  Como resultado, se houver uma promo√ß√£o de pilha, mas o destruidor de algum objeto for chamado normalmente, <em>std :: uncaught_exception ()</em> ainda retornar√° <em>true</em> . </p><br><pre> <code class="plaintext hljs">class MayThrowInDestructor { public: ~MayThrowInDestructor() noexcept(false) { if (std::uncaught_exception()) { std::cerr &lt;&lt; "~MayThrowInDestructor() stack unwinding, not throwing\n"; } else { std::cerr &lt;&lt; "~MayThrowInDestructor() normal case, throwing\n"; throw_int_func(); } } }; class ThrowCatchInDestructor { public: ~ThrowCatchInDestructor() noexcept(false) { try { MayThrowInDestructor may_throw; } catch (int i) { std::cerr &lt;&lt; "Catched int in ~ThrowCatchInDestructor(): " &lt;&lt; i &lt;&lt; "\n"; } } private: PrintInDestructor member_; }; int main(int, char**) { try { ThrowCatchInDestructor stack_unwind; std::cerr &lt;&lt; "ThrowInDestructor stack unwinding\n"; throw "BANG!"; } catch (int i) { std::cerr &lt;&lt; "Catched int exception: " &lt;&lt; i &lt;&lt; "\n"; } catch (const char* s) { std::cerr &lt;&lt; "Catched const char* exception: " &lt;&lt; s &lt;&lt; "\n"; } catch (...) { std::cerr &lt;&lt; "Catched unknown exception\n"; } return 0; }</code> </pre> <br><p>  Resultado: </p><br><pre> <code class="plaintext hljs">ThrowInDestructor stack unwinding ~MayThrowInDestructor() stack unwinding, not throwing ~PrintInDestructor() invoked Catched const char* exception: BANG!</code> </pre> <br><p>  No novo C ++ 17 Standard, a fun√ß√£o <em>std :: uncaught_exceptions ()</em> foi introduzida para substituir <em>std :: uncaught_exception ()</em> (observe o plural), que em vez de um valor booleano retorna o n√∫mero de exce√ß√µes atualmente ativas (aqui est√° uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">justificativa</a> detalhada). </p><br><p>  √â assim que o problema descrito acima √© resolvido com <em>std :: uncaught_exceptions ()</em> : </p><br><pre> <code class="plaintext hljs">class MayThrowInDestructor { public: MayThrowInDestructor() : exceptions_(std::uncaught_exceptions()) {} ~MayThrowInDestructor() noexcept(false) { if (std::uncaught_exceptions() &gt; exceptions_) { std::cerr &lt;&lt; "~MayThrowInDestructor() stack unwinding, not throwing\n"; } else { std::cerr &lt;&lt; "~MayThrowInDestructor() normal case, throwing\n"; throw_int_func(); } } private: int exceptions_; }; class ThrowCatchInDestructor { public: ~ThrowCatchInDestructor() noexcept(false) { try { MayThrowInDestructor may_throw; } catch (int i) { std::cerr &lt;&lt; "Catched int in ~ThrowCatchInDestructor(): " &lt;&lt; i &lt;&lt; "\n"; } } private: PrintInDestructor member_; }; int main(int, char**) { try { ThrowCatchInDestructor stack_unwind; std::cerr &lt;&lt; "ThrowInDestructor stack unwinding\n"; throw "BANG!"; } catch (int i) { std::cerr &lt;&lt; "Catched int exception: " &lt;&lt; i &lt;&lt; "\n"; } catch (const char* s) { std::cerr &lt;&lt; "Catched const char* exception: " &lt;&lt; s &lt;&lt; "\n"; } catch (...) { std::cerr &lt;&lt; "Catched unknown exception\n"; } return 0; }</code> </pre> <br><p>  Resultado: </p><br><pre> <code class="plaintext hljs">ThrowInDestructor stack unwinding ~MayThrowInDestructor() normal case, throwing throw_int_func() invoked Catched int in ~ThrowCatchInDestructor(): 1 ~PrintInDestructor() invoked Catched const char* exception: BANG!</code> </pre> <br><h2 id="kogda-ochen-ochen-hochetsya-vybrosit-srazu-neskolko-isklyucheniy">  Quando eu realmente quero lan√ßar algumas exce√ß√µes de uma s√≥ vez </h2><br><p>  <em>std :: uncaught_exceptions ()</em> evita chamar <em>std :: terminate ()</em> , mas n√£o ajuda a lidar com v√°rias exce√ß√µes corretamente.  Idealmente, eu gostaria de ter um mecanismo que me permita salvar todas as exce√ß√µes lan√ßadas e depois process√°-las em um s√≥ lugar. </p><br><blockquote>  Quero lembrar mais uma vez que o mecanismo proposto por mim abaixo serve apenas para demonstrar o conceito e n√£o √© recomendado para uso em c√≥digo industrial real. </blockquote><p>  A ess√™ncia da id√©ia √© capturar exce√ß√µes e salv√°-las em um cont√™iner e, em seguida, obter e process√°-las uma por vez.  Para salvar objetos de exce√ß√£o, o C ++ possui um tipo especial <em>std :: exception_ptr</em> .  A estrutura de tipos na Norma n√£o √© divulgada, mas √© dito que √© essencialmente <em>shared_ptr</em> por objeto de exce√ß√£o. </p><br><p>  Como ent√£o processar essas exce√ß√µes?  Existe uma fun√ß√£o <em>std :: rethrow_exception () para isso</em> , que pega um ponteiro <em>std :: exception_ptr</em> e lan√ßa a exce√ß√£o correspondente.  N√≥s s√≥ precisamos peg√°-lo com a se√ß√£o catch correspondente e process√°-lo, ap√≥s o qual podemos passar para o pr√≥ximo objeto de exce√ß√£o. </p><br><pre> <code class="plaintext hljs">using exceptions_queue = std::stack&lt;std::exception_ptr&gt;; // Get exceptions queue for current thread exceptions_queue&amp; get_queue() { thread_local exceptions_queue queue_; return queue_; } // Invoke functor and save exception in queue void safe_invoke(std::function&lt;void()&gt; f) noexcept { try { f(); } catch (...) { get_queue().push(std::current_exception()); } } class ThrowInDestructor { public: ~ThrowInDestructor() noexcept { std::cerr &lt;&lt; "~ThrowInDestructor() invoked\n"; safe_invoke([]() { throw_int_func(); }); } private: PrintInDestructor member_; }; int main(int, char**) { safe_invoke([]() { ThrowInDestructor bad; throw "BANG!"; }); auto&amp; q = get_queue(); while (!q.empty()) { try { std::exception_ptr ex = q.top(); q.pop(); if (ex != nullptr) { std::rethrow_exception(ex); } } catch (int i) { std::cerr &lt;&lt; "Catched int exception: " &lt;&lt; i &lt;&lt; "\n"; } catch (const char* s) { std::cerr &lt;&lt; "Catched const char* exception: " &lt;&lt; s &lt;&lt; "\n"; } catch (...) { std::cerr &lt;&lt; "Catched unknown exception\n"; } } return 0; }</code> </pre> <br><p>  Resultado: </p><br><pre> <code class="plaintext hljs">~ThrowInDestructor() invoked throw_int_func() invoked ~PrintInDestructor() invoked Catched const char* exception: BANG! Catched int exception: 1</code> </pre> <br><p>  No exemplo acima, a pilha √© usada para salvar objetos de exce√ß√£o, no entanto, o tratamento de exce√ß√µes ser√° realizado de acordo com o princ√≠pio FIFO (ou seja, logicamente essa √© a fila - a exce√ß√£o lan√ßada primeiro ser√° a primeira a ser processada). </p><br><h2 id="vyvody">  Conclus√µes </h2><br><p>  Lan√ßar exce√ß√µes em destruidores de objetos √© realmente uma p√©ssima id√©ia, e em qualquer novo c√≥digo eu recomendo fortemente que n√£o fa√ßa isso declarando que n√£o <em>h√°</em> destruidores.  No entanto, com o suporte e a depura√ß√£o do c√≥digo legado, pode ser necess√°rio lidar corretamente com as exce√ß√µes geradas pelos destruidores, inclusive durante a promo√ß√£o da pilha, e o C ++ moderno nos fornece mecanismos para isso.  Espero que as id√©ias apresentadas no artigo o ajudem nesse caminho dif√≠cil. </p><br><h2 id="ssylki">  Refer√™ncias </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reposit√≥rio com exemplos do artigo</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433944/">https://habr.com/ru/post/pt433944/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt433932/index.html">Atiramos no p√©, processando os dados de entrada</a></li>
<li><a href="../pt433934/index.html">Estrutura SAFe ou Scaled Agile</a></li>
<li><a href="../pt433936/index.html">Procurando um presente de alta tecnologia para uma crian√ßa? Pense em um playground, n√£o em um cercadinho</a></li>
<li><a href="../pt433938/index.html">Como Yandex e Google resumem o ano</a></li>
<li><a href="../pt433940/index.html">Quanto custa a revis√£o na AppStore</a></li>
<li><a href="../pt433946/index.html">Cheat sheet para intelig√™ncia artificial - jogue fora o excesso, ensine o principal. T√©cnica de processamento da sequ√™ncia de treinamento</a></li>
<li><a href="../pt433948/index.html">Como tornar o pagamento mais conveniente: a experi√™ncia de um provedor de IaaS</a></li>
<li><a href="../pt433952/index.html">10 raz√µes para escolher uma solu√ß√£o para o SAP HANA da HPE. Parte 2</a></li>
<li><a href="../pt433954/index.html">Oito tecnologias de √°udio e dispositivos de √°udio que entrar√£o no Hall da Fama da TECnology em 2019</a></li>
<li><a href="../pt433956/index.html">Os modders usaram a IA para melhorar a textura nos jogos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>