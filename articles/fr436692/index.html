<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🤝‍👨🏼 👃🏿 👩🏿‍🍳 (in) Guerre finie 👩🏻‍🏭 😁 🔺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons un problème. Le problème avec les tests. Le problème avec les tests des composants React, et c'est assez fondamental. Il s'agit de la diffé...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>(in) Guerre finie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436692/"><p><img src="https://habrastorage.org/webt/4w/m4/cc/4wm4ccdyq2tqs2giqspeys3e9sa.jpeg" alt="infitite war"></p><br><p> Nous avons un problème.  Le problème avec les tests.  Le problème avec les tests des composants React, et c'est assez fondamental.  Il s'agit de la différence entre les <code>unit testing</code> et <code>integration testing</code> .  Il s'agit de la différence entre ce que nous appelons les tests unitaires et ce que nous appelons les tests d'intégration, la taille et la portée. </p><br><p>  Il ne s'agit pas de se tester, mais de l'architecture des composants.  À propos de la différence entre les <strong>composants de</strong> test, les bibliothèques autonomes et les <strong>applications</strong> finales. </p><br><p>  Tout le monde sait comment tester des composants simples (ils sont simples), sait probablement comment tester des applications (E2E).  Comment tester des choses <em>finies</em> et <em>infinies</em> ... </p><a name="habracut"></a><br><h2 id="define-the-problem">  Définissez le problème </h2><br><p>  Il existe 2 façons différentes de tester le composant React - <code>shallow</code> et tout le reste, y compris le <code>mount</code> , la <code>react-testing-library</code> <code>webdriver</code> , le <code>webdriver</code> , etc.  Seul <code>shallow</code> est spécial - les autres se comportent de la même manière. </p><br><p>  Et cette différence concerne <em>la taille et la portée</em> - ce qui serait testé, et juste partiellement <em>comment</em> . </p><br><p>  En bref - <code>shallow</code> enregistrera uniquement les appels à React.createElement, mais sans exécuter d'effets secondaires, y compris le rendu des éléments DOM - c'est un effet secondaire (algébrique) de React.createElement. </p><br><p>  Toute autre commande exécutera le code que vous avez fourni, chaque effet secondaire étant également exécuté.  Comme ce serait en réalité, et c'est le but. </p><br><p>  Et <strong>le problème</strong> est le suivant: <code>you can NOT run each and every side effect</code> . </p><br><h3 id="why-not">  Pourquoi pas? </h3><br><p>  Pureté fonctionnelle?  Pureté et immuabilité - les vaches sacrées d'aujourd'hui.  Et vous en abattez un.  Les axiomes des tests unitaires - aucun effet secondaire, isolement, moquerie, tout sous contrôle. </p><br><ul><li><p>  Mais ce n'est <em>pas un problème</em> pour ... <code>dumb components</code> .  Ils sont stupides, ne contiennent que la couche de présentation, mais pas les "effets secondaires". </p><br></li><li><p>  Mais c'est <em>un problème</em> pour les <code>Containers</code> .  Tant qu'ils ne sont pas stupides, contiennent tout ce qu'ils veulent et entièrement sur les effets secondaires.  Ils sont le problème! </p><br></li></ul><br><p>  Probablement, si nous définissons les règles de "The Right Component", nous pourrions facilement tester - cela nous guidera et nous aidera. </p><br><blockquote>  TRDL: le composant fini </blockquote><br><h2 id="smart-and-dumb-components">  Composants intelligents et stupides </h2><br><p>  Selon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dan Abramov, les</a> composants de présentation d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> sont: </p><br><ul><li>  Sont préoccupés par l'apparence des choses. </li><li>  Peut contenir à la fois des composants de présentation et de conteneur <code>**</code> intérieur, et possède généralement un balisage DOM et des styles qui leur sont propres. </li><li>  Autorisez souvent le confinement via this.props.children. </li><li>  N'ayez aucune dépendance vis-à-vis du reste de l'application, comme les actions Flux ou les magasins. </li><li>  Ne spécifiez pas comment les données sont chargées ou mutées. </li><li>  Recevez des données et des rappels exclusivement via des accessoires. </li><li>  Ils ont rarement leur propre état (lorsqu'ils le font, c'est l'état de l'interface utilisateur plutôt que les données). </li><li>  Sont écrits en tant que composants fonctionnels à moins qu'ils n'aient besoin de crochets d'état, de cycle de vie ou d'optimisation des performances. </li><li>  Exemples: Page, Sidebar, Story, UserInfo, List. </li><li>  .... </li><li>  Et les conteneurs ne sont que des fournisseurs de données / accessoires pour ces composants. </li></ul><br><p>  Selon les origines: <strong>Dans l'application idéale ...</strong> <strong><br></strong>  <strong>Les conteneurs sont l'Arbre.</strong>  <strong>Les composants sont des feuilles d'arbre.</strong> </p><br><h4 id="find-the-black-cat-in-the-dark-room">  Trouvez le chat noir dans la pièce sombre </h4><br><p>  La sauce secrète ici, un changement que nous devons modifier dans cette définition, est cachée à l'intérieur <em>"Peut contenir à la fois des composants de présentation et des conteneurs <code>**</code> "</em> , permettez-moi de citer l'article original: </p><br><blockquote>  Dans une version antérieure de cet article, j'ai affirmé que les composants de présentation ne devraient contenir que d'autres composants de présentation.  Je ne pense plus que ce soit le cas.  Qu'un composant soit un composant de présentation ou un conteneur est son détail d'implémentation.  Vous devriez pouvoir remplacer un composant de présentation par un conteneur sans modifier aucun des sites d'appel.  Par conséquent, les composants de présentation et de conteneur peuvent contenir très bien d'autres composants de présentation ou de conteneur. </blockquote><p>  D'accord, mais qu'en est-il de la règle, qui rend l'unité de composants de présentation testable - <em>«N'a pas de dépendances sur le reste de l'application»</em> ? </p><br><p>  Malheureusement, en incluant des conteneurs dans les composants de présentation, vous rendez les seconds <strong>infinis</strong> et injectez des dépendances dans le reste de l'application. </p><br><p>  Ce n'est probablement pas quelque chose que vous étiez censé faire.  Donc, je n'ai pas d'autre choix, mais pour rendre le composant stupide fini: </p><br><p>  <strong>LES COMPOSANTS DE PRÉSENTATION NE DOIVENT CONTENIR QUE D'AUTRES COMPOSANTS DE PRÉSENTATION</strong> </p><br><p>  Et la seule question que vous devriez poser (en examinant votre base de code actuelle): <em>comment?</em>  : tableflip:?! </p><br><p>  Aujourd'hui, les composants et les conteneurs de présentation ne sont pas seulement enchevêtrés, mais parfois simplement non extraits en tant qu'entités «pures» (bonjour GraphQL). </p><br><h4 id="solution-1---di">  Solution 1 - DI </h4><br><p>  La solution 1 est simple - ne contient pas de conteneurs imbriqués dans le composant stupide - contient des <code>slots</code> .  Acceptez simplement le "contenu" (enfants), comme accessoires, et cela résoudrait le problème: </p><br><ul><li>  vous pouvez tester un composant stupide sans "le reste de votre application" </li><li>  vous pouvez tester l'intégration avec le test smoke / integration / e2e, pas les tests. </li></ul><br><pre> <code class="plaintext hljs">// Test me with mount, with "slots emty". const PageChrome = ({children, aside}) =&gt; ( &lt;section&gt; &lt;aside&gt;{aside}&lt;/aside&gt; {children} &lt;/section&gt; ); // test me with shallow, or real integration test const PageChromeContainer = () =&gt; ( &lt;PageChrome aside={&lt;ASideContainer /&gt;}&gt; &lt;Page /&gt; &lt;/PageChrome&gt; );</code> </pre> <br><p>  Approuvé par Dan lui-même: <br>  {% twitter 1021850499618955272%} </p><br><p>  DI (Dependecy Injection et Dependency Inversion), probablement, est une technique la plus réutilisable ici, capable de vous rendre la vie beaucoup plus facile. </p><br><blockquote>  Pointez ici - Les composants stupides sont stupides! </blockquote><br><h4 id="solution-2---boundaries">  Solution 2 - Limites </h4><br><p>  Il s'agit d'une solution assez déclarative, et pourrait étendre la <code>Solution 1</code> - il suffit de déclarer tous les points d' <em>extension</em> .  Enveloppez-les simplement avec ... </p><br><pre> <code class="plaintext hljs">const Boundary = ({children}) =&gt; ( process.env.NODE_ENV === 'test' ? null : children // or `jest.mock` ); const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;Boundary&gt;&lt;ASideContainer /&gt;&lt;/Boundary&gt;&lt;/aside&gt; &lt;Boundary&gt;&lt;Page /&gt;&lt;/Boundary&gt; &lt;/section&gt; );</code> </pre> <br><p>  Ensuite, vous pouvez désactiver, juste zéro, la <code>Boundary</code> pour réduire la portée du composant et la rendre <em>finie</em> . </p><br><blockquote>  Pointez ici - La limite est au niveau de la composante Dumb.  Le composant stupide contrôle à quel point il est stupide. </blockquote><br><h3 id="solution-3---tier">  Solution 3 - Niveau </h3><br><p>  Est la même que la solution 2, mais avec une frontière plus intelligente, capable de se moquer de la <em>couche</em> ou du <em>niveau</em> , ou tout ce que vous dites: </p><br><pre> <code class="plaintext hljs">const checkTier = tier =&gt; tier === currentTier; const withTier = tier =&gt; WrapperComponent =&gt; (props) =&gt; ( (process.env.NODE_ENV !== 'test' || checkTier(tier)) &amp;&amp; &lt;WrapperComponent{...props} /&gt; ); const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;ASideContainer /&gt;&lt;/aside&gt; &lt;Page /&gt; &lt;/section&gt; ); const ASideContainer = withTier('UI')(...) const Page = withTier('Page')(...) const PageChromeContainer = withTier('UI')(PageChrome);</code> </pre> <br><blockquote>  Même si cela est presque similaire à l'exemple Boundary - le composant Dumb est Dumb et les conteneurs contrôlent la visibilité des autres conteneurs. </blockquote><br><h4 id="solution-4---separate-concerns">  Solution 4 - Préoccupations distinctes </h4><br><p>  Une autre solution consiste simplement à séparer les préoccupations!  Je veux dire - vous l'avez déjà fait, et il est probablement temps de l'utiliser. </p><br><blockquote>  En <code>connect</code> le composant à Redux ou GQL, vous produisez des conteneurs <em>bien connus</em> .  Je veux dire - avec <em>des</em> noms <em>bien connus</em> - <code>Container(WrapperComponent)</code> .  Vous pouvez vous moquer d'eux par leurs noms </blockquote><br><pre> <code class="plaintext hljs">const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;ASideContainer /&gt;&lt;/aside&gt; &lt;Page /&gt; &lt;/section&gt; ); // remove all components matching react-redux pattern reactRemock.mock(/Connect\(\w\)/) // all any other container reactRemock.mock(/Container/)</code> </pre> <br><p>  Cette approche est un peu grossière - elle effacera <em>tout</em> , ce qui rendra plus difficile le test des Contaiers eux-mêmes, et vous pouvez utiliser un mocking un peu plus complexe pour garder le "premier": </p><br><pre> <code class="plaintext hljs">import {createElement, remock} from 'react-remock'; // initially "open" const ContainerCondition = React.createContext(true); reactRemock.mock(/Connect\(\w\)/, (type, props, children) =&gt; ( &lt;ContainerCondition.Consumer&gt; { opened =&gt; ( opened ? ( // "close" and render real component &lt;ContainerCondition.Provider value={false}&gt; {createElement(type, props, ...children)} &lt;ContainerCondition.Provider&gt; ) // it's "closed" : null )} &lt;/ContainerCondition.Consumer&gt; )</code> </pre> <br><blockquote>  Pointez ici: il n'y a pas de logique à l'intérieur ni de présentation, pas de conteneur - toute logique est à l'extérieur. </blockquote><br><h4 id="bonus-solution---separate-concerns">  Solution bonus - Préoccupations distinctes </h4><br><p>  Vous pouvez garder <em>un couplage serré en</em> utilisant <code>defaultProps</code> et annuler ces accessoires dans les tests ... </p><br><pre> <code class="plaintext hljs">const PageChrome = ({Content = Page, Aside = ASideContainer}) =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;Aside/&gt;&lt;/aside&gt; &lt;Content/&gt; &lt;/section&gt; );</code> </pre> <br><h2 id="so">  Alors? </h2><br><p>  Je viens donc de publier quelques façons de réduire la portée de n'importe quel composant et de les rendre beaucoup plus testables.  Le moyen simple de sortir un <code>gear</code> de la <code>gearbox</code> .  Un modèle simple pour vous faciliter la vie. </p><br><p>  Les tests E2E sont excellents, mais il est difficile de simuler certaines conditions, qui pourraient se produire dans une fonction profondément imbriquée et être prêtes pour elles.  Vous devez avoir des tests unitaires pour pouvoir simuler différents scénarios.  Vous devez avoir des tests d'intégration pour vous assurer que tout est correctement câblé. </p><br><p>  Vous savez, comme Dan l'a écrit dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">son autre article</a> : </p><br><blockquote>  Par exemple, si un bouton peut être dans l'un des 5 états différents (normal, actif, en vol stationnaire, danger, désactivé), le code de mise à jour du bouton doit être correct pour 5 × 4 = 20 transitions possibles - ou interdire certaines d'entre elles.  Comment apprivoiser l'explosion combinatoire d'états possibles et rendre la sortie visuelle prévisible? </blockquote><p>  Bien que la bonne solution ici soit les machines à états, être en mesure de choisir un seul atome ou une seule molécule et de jouer avec - est l'exigence de base. </p><br><h3 id="the-main-points-of-this-article">  Les principaux points de cet article </h3><br><ol><li>  Les composants de présentation ne doivent contenir que d'autres composants de présentation. </li><li>  Les conteneurs sont l'Arbre.  Les composants sont des feuilles d'arbre. </li><li>  Vous ne devez pas <em>toujours</em> contenir de conteneurs à l'intérieur des conteneurs de présentation, mais <em>pas</em> uniquement dans les tests. </li></ol><br><blockquote>  Vous pouvez plonger plus profondément dans le problème en lisant l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article moyen</a> , mais ici, sautons tout le sucre. </blockquote><p>  PS: Il s'agit d'une traduction de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version</a> <em>habr de l'</em> article <em>ru-habr</em> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436692/">https://habr.com/ru/post/fr436692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436682/index.html">Ne créez pas votre propre JL (DSL) pour étendre les fonctionnalités de l'application</a></li>
<li><a href="../fr436684/index.html">Anniversaire Android 10 (Q). Que sait-on maintenant?</a></li>
<li><a href="../fr436686/index.html">JPEG du monde 3D. Qu'est-ce que glTF?</a></li>
<li><a href="../fr436688/index.html">Le géant informatique quitte le marché des puces pour les centres de données - dites-nous ce que cela signifie pour l'industrie</a></li>
<li><a href="../fr436690/index.html">[Demande - réponse] sur la propriété intellectuelle et la protection des données</a></li>
<li><a href="../fr436694/index.html">My Pascal Compiler et l'art contemporain polonais</a></li>
<li><a href="../fr436696/index.html">Comment générer du son binaural sur une piste audio mono-canal - la vidéo vous aidera</a></li>
<li><a href="../fr436698/index.html">De combien de façons puis-je écrire factorielle dans Scheme?</a></li>
<li><a href="../fr436700/index.html">Anti-spoofing: comment les systèmes de reconnaissance faciale résistent-ils aux escrocs?</a></li>
<li><a href="../fr436704/index.html">L'histoire de la façon dont nous avons choisi les balances pour l'automatisation des caisses enregistreuses</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>