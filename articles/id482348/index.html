<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥅 😥 💊 Topologi dan analisis komprehensif untuk pengembang game yang tidak curiga: mengompresi vektor 3D tunggal ⭐️ 🌘 🧝🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seperti yang sudah dapat Anda pahami dari artikel saya sebelumnya, saya suka menggunakan pengembangan game sebagai alasan untuk menunjukkan matematika...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Topologi dan analisis komprehensif untuk pengembang game yang tidak curiga: mengompresi vektor 3D tunggal</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482348/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/910/fcb/d9f/910fcbd9f721b1ceea2de3b3a56bcb2c.png" alt="gambar"></div><br>  Seperti yang sudah dapat Anda pahami dari artikel saya sebelumnya, saya suka menggunakan pengembangan game sebagai alasan untuk menunjukkan matematika yang rumit yang jika tidak demikian, kebanyakan orang tidak akan menggunakannya.  Dan artikel ini tidak terkecuali!  Saya ingin menunjukkan teknik yang sangat keren, sesuai dengan poin yang menarik bagi saya: <br><br><ul><li>  prosesnya cukup jelas </li><li>  itu jauh lebih cepat daripada teknik biasa yang melakukan tugas yang sama </li><li>  ia menggunakan properti yang sangat tidak biasa untuk mewakili angka floating-point dalam format floating point, yang menyiratkan bahwa ... </li><li>  <strong>itu tidak bekerja dalam analisis klasik</strong> .  Agar algoritma ini berfungsi dalam teori, Anda harus masuk ke dunia indah matematika non-klasik!  Dan jika ini tidak membangunkan rasa ingin tahu Anda, maka saya tidak tahu harus berbuat apa lagi. </li></ul><br>  Artikel ini cukup panjang dan teoretis, karena memerlukan studi mendalam tentang penjelasannya, jadi luangkan waktu Anda dan baca kembali bagian-bagian yang menurut Anda tidak begitu jelas pertama kali. <br><br><h2>  Sedikit tentang konteks (GPU) </h2><br>  Salah satu aspek penting yang harus Anda perhatikan dalam pengembangan game, dan dalam arti yang lebih luas - di area mana pun dengan penggunaan grafis aktif - adalah bandwidth GPU.  Prosesor sentral dan GPU adalah perangkat fisik yang terpisah, dan mereka membutuhkan sinkronisasi untuk bertukar data.  Jika Anda sudah melakukan pemrosesan paralel, maka Anda tahu bahwa ketika dua perangkat perlu disinkronkan, ini berarti kehilangan banyak waktu.  Interaksi CPU-GPU dalam hal ini tidak berbeda, jadi kami berusaha untuk meminimalkan transfer data, baik dalam jumlah operasi dan jumlah data yang ditransfer. <br><a name="habracut"></a><br>  Meminimalkan jumlah operasi transfer data biasanya dilakukan dengan menggunakan buffering: kami berusaha untuk memasukkan semua data ke dalam jumlah terkecil yang mungkin dari array, dan kemudian kami mentransfer semuanya sekaligus sehingga kita tidak perlu lagi khawatir tentang mereka.  Meminimalkan jumlah data dalam operasi transfer adalah topik yang sangat berbeda, dan solusi untuk masalah ini hampir selalu bersifat individual.  Sebagai contoh ekstrem dari ini, Anda dapat melihat <a href="http://advances.realtimerendering.com/s2013/Tatarchuk-Destiny-SIGGRAPH2013.pdf">bagaimana mesin rendering Destiny mengatur agar sesuai dengan posisi, permukaan normal, bendera material, dan parameter BSDF anisotropik 96-bit penuh, mis.</a>  <a href="http://advances.realtimerendering.com/s2013/Tatarchuk-Destiny-SIGGRAPH2013.pdf">tiga angka floating point</a> (hlm. 62 dan seterusnya).  Namun, hasil yang baik dapat dicapai dengan metode umum, yang kemudian ditambahkan solusi individual untuk pengoptimalan. <br><br>  Hari ini kita akan membahas <strong>kompresi lossless dari masing-masing vektor 3D</strong> .  Kalimat ini mengandung beberapa kata kunci: <br><br><ul><li>  <strong>Vektor 3D tunggal</strong> : <strong>Vektor</strong> 3D memiliki panjang 1 </li><li>  <strong>kompresi lossless</strong> : kurangi ukuran deskripsi vektor 3D tunggal tanpa kehilangan keakuratan.  Ini adalah kebalikan dari <em>kompresi lossy.</em> </li><li>  <strong>Terpisah</strong> : pengodean dan dekode vektor dilakukan tanpa informasi tentang tetangganya.  Jika situasinya berlawanan, maka itu bisa menjadi sesuatu seperti kompresi <em>bets</em> , di mana bukan vektor individu dikompresi, tetapi array mereka </li></ul><br>  Sebelum melanjutkan, saya harus menyebutkan artikel yang sangat bagus <a href="http://jcgt.org/published/0003/02/01/" rel="noopener"><em>"Sebuah Survei Representasi Efisien untuk</em> <em>Vektor</em> <em>Unit Independen</em> <em>"</em></a> oleh Cigolle, Donow, Evangelakos, Mara, McGuire dan Meyer, dari mana saya mendapatkan inspirasi untuk jabatan saya.  Saya harus mengatakan <strong><em>segera</em></strong> bahwa <strong>algoritma yang akan saya bicarakan kurang efisien daripada algoritma <em>Oktober</em> yang disajikan dalam artikel</strong> .  Jika Anda ingin efisiensi maksimum, maka baca artikel dan gunakan <em>oktober</em> .  Tujuan dari posting saya adalah untuk menunjukkan keindahan menggunakan matematika yang sangat tidak biasa, sambil menciptakan, seperti yang akan kita lihat nanti, algoritma yang sangat nyaman. <br><br><h2>  Topologi tepat di gim video Anda </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/a95/4bc/41ca954bca54597431a9a0ebb7a9fe97.png"></div><br>  <i>Dalam kasus unit sphere, hanya θ dan φ yang penting, karena ρ selalu 1, dan karena itu berlebihan.</i> <br><br>  Titik awal algoritme adalah pengamatan bahwa vektor satuan 3D setara dengan titik pada bola.  Seperti yang mungkin Anda ketahui, bola adalah permukaan dua dimensi, yaitu untuk identifikasi unik titik pada bola, hanya diperlukan dua koordinat.  Contoh yang sangat umum dari ini adalah koordinat bola, di mana titik pada bola didefinisikan oleh dua sudut, θ dan φ. <br><br>  Menariknya, properti yang agak tidak menyenangkan adalah bahwa meskipun bola dan kuadrat terisi (satu ruang yang memungkinkan untuk koordinat 2D) adalah objek 2D, sebenarnya tidak ada korespondensi di antara mereka.  Ini berarti bahwa tidak ada cara untuk melampirkan titik unik pada bola ke setiap titik unik persegi (setidaknya secara terus menerus);  mereka dikatakan <em>non-homeomorfik</em> (dengan kata lain, yang satu memiliki batas dan yang lain tidak).  Hasil yang tidak menyenangkan dari ini adalah bahwa beberapa koordinat 2D hilang dalam arti bahwa koordinat yang berbeda sesuai dengan titik-titik identik pada bola (misalnya, dalam kasus koordinat bola, ketika φ adalah 0, titik yang sesuai akan menjadi kutub utara, terlepas dari koordinat θ).  Dalam hal kompresi, kita kehilangan pola bit berharga yang dengannya kita dapat menggambarkan titik-titik bola! <br><br>  Jika Anda ingin lebih banyak matematika dan Anda ingin membuktikan bahwa kuadrat dan bola itu bukan homeomorfis, maka Anda dapat menggunakan fakta bahwa bola itu, berbeda dengan kuadratnya, tidak dapat dikontrak, dan sifat dapat dikontrakkan adalah sifat topologi;  Teorema Borsuk-Ulam juga dapat digunakan sebagai bukti.  Mereka juga memberi tahu saya bahwa kelompok homotopy dapat membantu dengan buktinya, tetapi ini sudah di luar bidang keahlian saya. <br><br>  Namun, masalah ini muncul tidak hanya dengan koordinat bola;  setiap representasi 2D terus menerus dari titik-titik bola akan menderita karenanya.  Namun, ingat ini untuk masa depan. <br><br>  Koordinat bola juga memiliki properti buruk lainnya: <br><br><ul><li>  Mereka memiliki distribusi yang buruk di bola.  Jika koordinat bola acak dihasilkan dan dikonversi kembali ke titik 3D, mereka membentuk kelompok di sekitar kutub dan akan sangat langka di dekat khatulistiwa.  Hal ini disebabkan oleh fakta bahwa vektor 3D di dekat khatulistiwa akan kurang dapat dibedakan secara akurat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/e1d/15a/87ce1d15ad314b007f0093b83a738538.png"></div><br>  <i>Distribusi pada bola 10.000 koordinat bola terdistribusi seragam</i> </li><li>  Pengemasan dan pembongkaran mereka mahal.  Untuk pengemasan (3D → 2D), diperlukan satu operasi <em>acos</em> dan satu <em>atan2</em> , yang merupakan fungsi trigonometri terbalik yang cukup mahal, dan untuk membongkar (2D → 3D) diperlukan dua operasi <em>karena</em> dua operasi dan dua <em>dosa</em> operasi, yang juga jauh dari ekonomis, diperlukan. </li></ul><br>  Lihat artikel di atas untuk mempelajari tentang perbandingan koordinat bola dan metode kompresi lainnya. <br><br><h2>  Tugas menjaga pola bit ... dan kecepatan </h2><br>  Metode yang akan kami pertimbangkan memiliki keuntungan besar - perhitungannya jauh lebih cepat, lebih dari dua kali lipat tolok ukur naif yang tidak dioptimalkan (diuji pada pengemasan dan membongkar 10 juta vektor acak dalam C ++ di Visual Studio 19 pada Intel Core i5 gen ke-7).  Selain itu, metode ini tidak memiliki singularitas, yaitu, setiap titik yang dikemas sesuai dengan satu titik yang tidak dibongkar, berbeda dengan koordinat bola yang disebutkan di atas. <br><br>  Seperti yang disebutkan sebelumnya, tidak ada homeomorfisme antara unit sphere dan unit square, yaitu, kita tidak dapat mengikat setiap titik unik di dalam persegi dengan titik unik lainnya di bola.  Tetapi mari kita pertimbangkan konstruksi berikut - sejauh ini hanya belahan bumi utara, di mana ada titik dengan koordinat Z positif atau nol, yang akan menjadi perhatian kita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/b7a/709/8a0b7a709482f110e7936fc71187e70d.png"></div><br>  <i>Kami "meratakan" belahan bumi utara ke dalam disk, <strong>membuang koordinat Z dari setiap titik</strong> (atau memberikan nilai 0).</i> <br><br>  Kami menemukan cara untuk melampirkan setiap titik di belahan bumi utara ke setiap titik dalam satu disk.  Beberapa poin penting: <br><br><ul><li>  kutub utara jatuh ke (0, 0). </li><li>  setiap titik pada batas hemisfer tetap sama.  Lebih khusus lagi, belahan bumi dan cakram memiliki batas yang sama.  Ini logis, karena titik-titik pada batas belahan memiliki Z = 0, yaitu, membuang koordinat Z, kami tidak mengubah apa pun. </li></ul><br><h3>  Kompresi disk: tugas kompleks yang sederhana </h3><br>  Konstruksi berikut ini membutuhkan pengenalan kecil.  Untuk berjaga-jaga, saya akan mengatakan bahwa bilangan kompleks adalah perpanjangan dari ruang bilangan real (bilangan biasa seperti 0, 1, 129,43, pi, 335/117, akar kuadrat 2, dan seterusnya), yang menggunakan bilangan khusus yang <em>saya</em> sebut <em>imajiner unit</em> .  Bilangan kompleks memiliki bentuk <em>+ ib</em> , di mana <em>a</em> dan <em>b</em> adalah bilangan real (masing-masing, bagian nyata dan imajiner), dan <em>saya</em> memiliki properti i² = -1.  Ini memungkinkan kita untuk mencocokkan bilangan kompleks dengan poin pada bidang 2D.  Jika kita mengambil untuk <em>z sejumlah</em> kompleks dari bentuk <em>z = a + ib</em> , maka kita dapat mewakili <em>z sebagai</em> titik dengan koordinat ( <em>a</em> , <em>b</em> ) pada bidang.  Fungsi ekstraksi "bagian nyata" dan "bagian imajiner" dari bilangan kompleks <em>z</em> dilambangkan dengan <em>Re (z)</em> dan <em>Im (z)</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c7/3d5/9b2/3c73d59b25bb8db10409e8c763b90154.png"></div><br>  <i>Angka kompleks <em>z</em> dan nilainya.</i> <br><br>  Selain bagian nyata dan imajiner dari bilangan kompleks, panjang dan sudut yang dibentuk olehnya dengan sumbu X juga dapat diperhitungkan.Ini disebut <em>representasi kutub</em> .  Panjang kutub dan sudut kutub adalah norma <em>| z |</em>  dan argumen <em>Arg (z)</em> .  Sifat yang nyaman dari kedua representasi adalah bahwa <strong>penambahan bilangan kompleks dilakukan dengan menambahkan bagian nyata dan imajiner</strong> , dan <strong>penggandaan bilangan kompleks dilakukan dengan mengalikan norma dan menambahkan argumen</strong> . <br><br>  Di sini kita tertarik pada dua operasi: mengkuadratkan dan mendapatkan akar kuadrat dari bilangan kompleks.  Mengkuadratkan bilangan kompleks sama persis dengan bilangan real: gandakan saja dengan sendirinya, pada dasarnya <strong>mengkuadratkan norma dan menggandakan argumen</strong> .  Perhatikan bahwa jika norma bilangan kompleks kurang dari 1, maka ketika kuadratkan, panjangnya akan tetap kurang dari satu;  Jadi, jika kita mengambil setiap bilangan kompleks pada disk yang memiliki bagian nyata positif, dan meletakkan semuanya dalam kotak, maka pada dasarnya kita akan mendapatkan seluruh disk. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cf/7f3/af0/0cf7f3af09328146ee38a26f4e72eddb.png"></div><br>  <i>Di sebelah kiri adalah beberapa bilangan kompleks di setengah dari disk dengan bagian nyata positif (koordinat X).</i>  <i>Di sebelah kanan adalah hasil mengkuadratkan semua poin ini.</i>  <i>Setengah disk sekarang mengisi seluruh disk!</i> <br><br>  Satu trik dikaitkan dengan "menggandakan argumen": itu tergantung pada sisi sumbu X di mana titik terletak.  Aturannya ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/ed7/ddd/8cced7ddd2e812dd5d4361131a500f95.png"></div><br>  <i>Angka kompleks dengan bagian imajiner positif (koordinat Y) berputar ke kiri, dan angka kompleks dengan bagian imajiner negatif (koordinat Y) berputar ke kanan.</i> <br><br>  Seperti dalam kasus bilangan real, akar kuadrat adalah kebalikan dari kuadrat: untuk bilangan kompleks <em>z yang</em> diberikan, akar kuadrat (dua dari mereka) adalah bilangan <em>c</em> , sehingga <em>c² = z</em> .  Seperti dalam kasus bilangan real, jika <em>c</em> adalah akar kuadrat dari <em>z</em> , maka <em>-c</em> juga itu.  Bahwa dari bilangan <em>c</em> dan <em>-c</em> , yang argumennya sama dengan setengah dari argumen <em>z</em> , disebut akar kuadrat utama (ini mirip dengan mengambil akar kuadrat positif dari bilangan real daripada akar kuadrat negatif). <br><br>  Jika Anda memahami bahwa ketika bilangan kompleks dikuadratkan, normanya dikuadratkan dan argumennya berlipat ganda, maka Anda dapat dengan mudah menebak bahwa nilai utama dari akar kuadrat mengambil akar kuadrat dari norma dan membagi dua argumen (mengikuti aturan yang ditunjukkan di atas, tetapi dengan panah yang terbalik) .  Seperti dalam kasus kuadrat, ketika mengambil akar kuadrat dari bilangan kompleks dengan norma kurang dari 1, norma tetap kurang dari 1;  oleh karena itu, ia "mengompres" unit disk menjadi angka real positif setengahnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51f/7cc/5f0/51f7cc5f0b9616d7f82f09a29e3c14c7.png"></div><br>  <i>Di sebelah kiri adalah beberapa titik pada satu disk.</i>  <i>Sisi kanan menunjukkan hasil dari mengambil akar kuadrat dari semua poin ini.</i>  <i>Seluruh disk sekarang pas dengan separuhnya!</i> <br><br>  Ini adalah dasar dari algoritma: pada kenyataannya, kami mengompres seluruh unit disk menjadi setengah - setengah dengan bagian nyata yang positif.  Seperti yang Anda ingat, baru-baru ini kami telah meratakan bagian atas bola menjadi disk tunggal;  Sekarang layak melihat apa yang akan kita lakukan dengannya. <br><br><h3>  Menyatukan semuanya </h3><br>  Mari kita simpulkan apa yang baru saja kita lakukan: kita meratakan setengah bola menjadi satu unit disk, membuang koordinat Z dari semua titiknya, dan meremas unit disk menjadi setengahnya sendiri dengan bagian nyata positif menggunakan nilai akar kuadrat utama yang kompleks.  Bahkan, kami meratakan setengah bola menjadi setengah disk!  Sekarang dengan beberapa perubahan, kita dapat melakukan hal yang sama untuk mengompres separuh bola yang tersisa ke dalam setengah disk yang tersisa. <br><br>  Setengah bagian bawah bola (semua titik bola dengan koordinat Z negatif) juga diratakan ke dalam unit disk dengan berulang-ulang menjatuhkan koordinat Z. Namun, untuk semua bilangan kompleks <em>z</em> dalam disk, kami mengambil nilai yang berlawanan dengan akar kuadrat utama dari <em>z</em> (mis. Kita mengambil <em>-c</em> alih-alih <em>c</em> )  Karena nilai utama dari akar kuadrat selalu memiliki bagian nyata yang positif, nilai yang berlawanan akan selalu memiliki bagian nyata yang negatif;  pada kenyataannya, kami meratakan sisa setengah bola ke dalam setengah sisa disk, dan tahap kompresi sekarang selesai! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/910/fcb/d9f/910fcbd9f721b1ceea2de3b3a56bcb2c.png"></div><br>  <i>Langkah kompresi penuh.</i>  <i>Perhatikan bahwa belahan utara dan selatan (biru dan oranye) diratakan menjadi dua salinan dari satu disk, dan kemudian dikompresi menjadi dua bagian dari satu disk.</i> <br><br>  Algoritma kompresi adalah sebagai berikut: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">packUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unit)</span></span></span><span class="hljs-function"> disk </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Complex(unit.x, unit.y) packed = principalSquareRoot(disk) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit.z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? -packed : packed</code> </pre> <br>  Jadi, hanya dalam tiga baris kodesemu, kami menerapkan keseluruhan teori yang kami periksa untuk membuat algoritma yang efektif.  Jika lingkungan Anda tidak memiliki formula untuk nilai utama dari akar kuadrat, maka itu dapat ditemukan <a href="https://en.wikipedia.org/wiki/Square_root" rel="noopener">di Wikipedia</a> (perhatian khusus harus diberikan untuk memilih tanda bagian imajiner).  Berikut ini adalah implementasi referensi C ++ yang saya gunakan dalam kode saya: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Principal complex square root of 'x + iy' float2 csqrt(float x, float y) { float r = sqrt(x * x + y * y); return float2(sqrt((r + x) / 2), (y &lt; 0 ? -1 : 1) * sqrt((r - x) / 2)); }</span></span></code> </pre> <br><h3>  Kembali </h3><br>  Kami mengatasi kompresi, sekarang kami lanjutkan membongkar. <br><br>  Pembongkaran terdiri dari urutan terbalik semua langkah kompresi: <br><br><ul><li>  kami memperluas bagian positif dan negatif dari bagian material dari disk tunggal menjadi dua disk penuh </li><li>  cocokkan setiap disk penuh dengan belahan otak yang sesuai </li></ul><br>  Singkatnya, kita mulai dengan nilai paket <em>p</em> , kuadratkan untuk kembali ke titik pada disk yang diperoleh dari salah satu belahan otak, dan kemudian menggunakan tanda <em>Re (p)</em> untuk mencari tahu di belahan mana titik dari disk tersebut diambil.  Dengan menggunakan persamaan <em>x² + y² + z² = 1</em> , yang mendefinisikan titik-titik pada unit sphere, kita dapat membuat kembali koordinat Z yang hilang dari titik yang dikemas. <br><br>  Perlu dicatat bahwa menghitung kuadrat dari nilai yang dikemas akan selalu memberi kita titik disk yang benar, terlepas dari belahan awal (atas atau bawah), karena <em>z² =</em> <em>(-z) ²</em> . <br><br>  Algoritma dekompresi adalah sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packed)</span></span></span><span class="hljs-function">: disk </span></span>= packed * packed unit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vec3() unit.x = disk.real() unit.y = disk.imag() unit.z = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> - unit.x * unit.x - unit.y * unit.y) * (packed.real() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit</code> </pre> <br>  Jadi kami mendapatkan algoritma yang sangat efisien membuat representasi 2D vektor 3D tunggal, yang, tidak seperti koordinat bola, tidak kehilangan pola bit apa pun dan tidak memiliki singularitas.  Jika Anda tidak memperhitungkan beberapa trik pengoptimalan untuk mempercepat perhitungan, ini adalah versi algoritma yang hampir siap. <br><br>  ... atau tidak?  Jika Anda memperhatikan dengan seksama, Anda memperhatikan ada sesuatu yang salah di sini.  Saya mengatakan bahwa bola dan satuan persegi bukan homeomorfik, namun entah bagaimana mampu mengikat titik unik di disk ke setiap titik unik di bola?  Selain itu, kami belum menyebutkan matematika non-klasik, jadi apa yang terjadi? <br><br>  Faktanya, algoritma kami memiliki kelemahan serius: ia bekerja untuk setiap titik di seluruh bola, kecuali untuk titik-titik di belahan bumi utara dengan Y = 0 dan X &lt;= 0, yang, ketika mengepak dan membongkar, secara keliru dibandingkan dengan titik yang sesuai di belahan bumi utara. <br><br>  Alasan untuk ini adalah bahwa ketika koordinat Z mereka dibuang, bilangan kompleks yang sesuai adalah bilangan real negatif, itu tidak memiliki bagian imajiner.  Ketika kita mengambil nilai utama dari akar kuadrat dari bilangan real negatif, kita akan mendapatkan bilangan kompleks imajiner sepenuhnya yang tidak memiliki bagian nyata (ini mirip dengan fakta bahwa nilai utama dari akar kuadrat dari -1 sama dengan <em>i</em> ).  Kemudian kami mencoba menjaga tanda koordinat Z pada apa yang pada dasarnya nol. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6bc/720/d08/6bc720d085469f478453dc4c961e2036.png"></div><br>  <i>Strip masalah.</i>  <i>Poin dengan Y = 0 dan X &lt;= 0 dikemas ke dalam garis bilangan imajiner murni dengan bagian nyata yang tidak dapat ditentukan.</i> <br><br>  Mari kita lihat apa yang terjadi ketika kita mengemas dua poin tersebut (jangan lupa bahwa x &lt;= 0). <br><br><blockquote><pre>  |  Titik utara |  Titik selatan
  unit |  (x, 0, z) |  (x, 0, -z)
  disk |  x + 0i |  x + 0i
 dikemas |  0 + √ (-x) i |  -0 - √ (-x) i </pre></blockquote><br>  Karena bagian imajiner proyeksi ke disk kedua titik sama dengan nol, kita tidak dapat menyimpan tanda koordinat Z dalam tanda bagian nyata dari nilai utama dari akar kuadrat, karena itu sendiri sama dengan nol.  Kita dapat dengan mudah memikirkan hal ini, menerima kenyataan bahwa algoritme tidak bekerja untuk titik-titik ini - atau kita dapat melanjutkan. <br><br><h2>  Lupakan apa yang kita pelajari </h2><br>  Di setiap bidang dan cabang matematika yang saya tahu, diasumsikan 0 = -0.  Ini mengikuti dari definisi <em>-a</em> , yang merupakan kebalikan dari <em>a</em> , yang menyatakan bahwa <em>"-a adalah satu-satunya angka yang memberikan 0 ketika dijumlahkan dengan a"</em> .  Karena 0 juga merupakan elemen nol sehubungan dengan penjumlahan ( <em>0 + a = a + 0 = a</em> ), satu-satunya hal yang perlu Anda tambahkan ke 0 untuk mendapatkan 0 adalah 0 itu sendiri. <br><br>  Namun, dalam pengembangan perangkat lunak, semuanya berbeda.  Dalam sebagian besar representasi angka floating point, bersama dengan eksponen dan mantissa, bit tambahan digunakan untuk menyimpan karakter.  Ini berarti bahwa ketika eksponen dan mantra adalah 0, maka bit tanda dapat digunakan untuk membedakan antara nol positif dan negatif.  Dalam kebanyakan bahasa pemrograman (jika tidak semua), kedua nol ini diperlakukan sebagai satu nol tunggal (coba <em>0 == -0</em> ), tetapi ada perbedaan, dan ini dapat dilihat jika Anda mencoba untuk output "-0" dan "0 ke terminal "- begitulah cara mereka disimpulkan. <br><br>  Ini sangat penting bagi kami: nilai nol sebenarnya dapat digunakan untuk menyimpan informasi tentang tanda!  Bahkan, bagaimanapun juga itu disimpan dengan benar;  dalam kasus kami, masalahnya adalah tidak dibaca dengan benar.  Jika kita melihat garis kedua dari belakang dalam algoritma pembongkaran, kita akan melihat yang berikut: <br><br><pre> <code class="cpp hljs">packed.real() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Operasi ini membaca tanda bagian nyata dari nilai yang dikemas untuk menentukan belahan mana titik milik - utara atau selatan.  Namun, dalam kasus ketika <em>packed.real ()</em> adalah 0 atau -0, karakter diabaikan oleh operator pembanding dan operator ternary selalu mengembalikan 1. Cara yang benar untuk membaca karakter adalah permintaan <em>nyata</em> untuk status bit tanda, misalnya, menggunakan <em>std :: signbit</em> from C ++ atau <em>np .signbit</em> dari Numpy ke Python - fungsinya tergantung pada bahasa.  Ingat bahwa bit tanda 1 ketika angka negatif, dan 0 ketika angka positif. <br><br>  Dengan demikian, kami mendapatkan fungsi kerja yang dikoreksi dan seratus persen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packed)</span></span></span><span class="hljs-function">: disk </span></span>= packed * packed unit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vec3() unit.x = disk.real() unit.y = disk.imag() unit.z = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> - unit.x * unit.x - unit.y * unit.y) * (signbit(packed.real()) ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit</code> </pre> <br>  Itu saja!  Sekarang algoritma sudah selesai.  Matematika non-klasik dimanifestasikan dalam kenyataan bahwa kita menggunakan fakta bahwa 0 berbeda dari -0, yang salah untuk semua bidang matematika yang saya tahu.  Namun, ada cara untuk membuat keanehan ini logis dalam pengertian teoretis, matematis yang ketat. <br><br><h2>  Spasi yang tidak bermain sesuai aturan: garis lurus dengan dua titik asal </h2><br>  Untuk lebih memahami yang berikut ini, Anda harus tahu konsep kelas dan lingkungan ekivalensi.  Ini opsional, tetapi akan lebih jelas. <br><br>  Kita dapat memastikan konsistensi keanehan ini dengan "tanda nol", dimulai dengan ruang topologis yang menarik: garis lurus dengan dua titik asal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7df/bdc/b66/7dfbdcb665e09552d349b0fb6d606f52.png"></div><br>  <i>Garis lurus dengan dua titik asal adalah sumbu numerik nyata biasa, yang entah bagaimana menumbuhkan 0 ekstra untuk dirinya sendiri.</i> <br><br>  Garis lurus dengan dua titik asal diperoleh ketika kita mengambil dua sumbu numerik sungguhan dan merekatkan setiap angka dengan kebalikannya, kecuali 0. Secara formal, garis lurus dengan dua titik asal adalah ruang hasil bagi R² dengan relasi ekivalen yang mengidentifikasi dua angka jika keduanya sama <em>dan</em> bukan 0. Hasilnya adalah garis lurus bilangan real dengan dua nol yang berbeda berjarak sama dari titik mana pun, tetapi pada saat yang sama berbeda satu sama lain.  Secara formal, setiap dua lingkungan dari masing-masing nol selalu memiliki persimpangan kosong. <br><br>  Kami dapat memperluas ini dan mencoba untuk mendefinisikan objek "seperti disk" yang digunakan dalam artikel ini.  Sebelumnya, kami secara paksa menyimpan tanda koordinat Z titik di bagian nyata dari akar kuadrat utama dari proyeksi ke disk kompleks, bahkan jika bagian nyata ini adalah 0. Ini berarti bahwa kami tidak menggunakan bilangan kompleks, tetapi konsep lain yang serupa dengan mereka: bilangan kompleks, bagian imajiner yang merupakan bilangan real, dan bagian nyata yang merupakan titik pada garis dengan dua titik asal, sehingga kita dapat membedakan bagian nyata sama dengan +0 dan -0.  Bahkan, kami menggunakan <strong>bilangan kompleks dengan dua titik asal!</strong> <br><br>  Dan pada kenyataannya, kami tidak menemukan bijection (pemetaan satu-ke-satu) antara bola dan unit disk, tetapi kami menemukan bijungan antara bola dan unit disk dengan dua titik asal.  Saya belum menguji apakah penistaan ​​ini adalah homeomorfisme (homeomorfisme adalah penambangan berkelanjutan di kedua arah), tetapi mungkin suatu hari nanti saya akan melakukannya. <br><br><h3>  Sedikit topologi di bagian akhir </h3><br>  Sebagai kesimpulan, saya ingin menekankan bahwa meskipun bidang kompleks yang kami gunakan dengan dua titik asal tidak mengikuti dari konstruksi yang sama dengan garis lurus dengan dua titik asal, pada kenyataannya, itu setara dengan bidang kompleks lain dengan dua titik asal yang dibangun serupa dengan garis lurus dengan dua asal. <br><br>  Dalam kasus garis lurus dengan dua titik asal, kami menempelkan dua salinan sumbu numerik nyata di semua tempat kecuali 0. Kita dapat melakukan hal yang sama dengan dua salinan bidang kompleks, menempelkan masing-masing pasangan bilangan kompleks yang sama yang bukan 0, dan juga mendapatkan kompleks sebuah pesawat dengan dua titik asal.  Konstruksi ini berbeda dari konstruksi bidang kompleks baru dari garis lurus dengan dua titik asal dan sumbu numerik nyata yang biasa: yang pertama adalah ruang faktor, dan yang terakhir adalah produk dari ruang.  Namun, satu-satunya perbedaan antara dua ruang yang dihasilkan adalah cara <em>menulis</em> nol yang berbeda di setiap ruang: di pertama mereka dihitung sebagai ( <em>0 + 0i) a</em> dan ( <em>0 + 0i) b</em> (dua nol diambil dari dua ruang berbeda yang tidak direkatkan), dan yang terakhir dibaca sebagai <em>(0a + 0i)</em> dan <em>(0b +</em> <em>0i)</em> .  Faktanya, kedua ruang adalah homeomorfik, sehingga Anda dapat dengan aman menggunakan satu di mana yang lain diperlukan. <br><br><h2>  Kesimpulan </h2><br>  Saya harap Anda menikmati perjalanan ini ke dunia matematika yang aneh dan tidak jelas.  Saya menekankan kembali fakta bahwa, sebenarnya, algoritma ini berperilaku lebih buruk daripada algoritma <em>Oktober</em> dari artikel yang saya sebutkan di awal.  Meskipun dekat atau bahkan lebih cepat dalam waktu eksekusi, distribusi titik pada bola jauh dari yang baik.  Saya menulis artikel ini kemudian untuk menunjukkan bagaimana matematika yang tampaknya asing, mirip dengan omong kosong abstrak, sebenarnya dapat memiliki aplikasi yang sangat menarik di dunia nyata;  selain itu, saya menemukan omong kosong abstrak ini menyenangkan.  Saya harap Anda mempelajari sesuatu yang bermanfaat dari artikel ini, terima kasih sudah membaca! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482348/">https://habr.com/ru/post/id482348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482336/index.html">Pedagang memiliki akses ke konferensi pers Bank Sentral Inggris sebelum siaran publik mereka</a></li>
<li><a href="../id482338/index.html">Visual Studio untuk Mac: kontrol IDE Anda dengan kunci</a></li>
<li><a href="../id482340/index.html">Dari Junior'a ke Middle'a: Parser</a></li>
<li><a href="../id482344/index.html">Bersiaplah untuk pengenalan peringkat sosial di Rusia</a></li>
<li><a href="../id482346/index.html">ASP.NET MVC - bekerja dengan MySQL melalui ADO.NET</a></li>
<li><a href="../id482352/index.html">Ketika saya hampir melemparkan 150k ke angin atau sejarah pemasangan ventilasi paksa di apartemen</a></li>
<li><a href="../id482354/index.html">ConfigureAwait: Pertanyaan yang Sering Diajukan</a></li>
<li><a href="../id482356/index.html">Menggunakan Windows Server tanpa explorer dari sudut pandang pengguna Windows biasa</a></li>
<li><a href="../id482358/index.html">Bagaimana panik bekerja di Rust</a></li>
<li><a href="../id482360/index.html">Detektif Habra: mereka berteman dengan UFO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>