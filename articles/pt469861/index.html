<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßõüèΩ üë©üèΩ‚Äçüè≠ üë®üèª‚Äç‚öïÔ∏è Estruturas de dados para programadores de jogos: dados em massa ‚èÆÔ∏è üëÜüèæ üßëüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qualquer programador se beneficiar√° da compreens√£o das v√°rias estruturas de dados e de como analisar seu desempenho. Mas, na pr√°tica, nunca fui √∫til p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estruturas de dados para programadores de jogos: dados em massa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469861/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e7/1d7/bb3/7e71d7bb314eaffe2d54f349cc854a5f.png" alt="imagem"></div><br>  Qualquer programador se beneficiar√° da compreens√£o das v√°rias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estruturas de dados</a> e de como analisar seu desempenho.  Mas, na pr√°tica, nunca fui √∫til para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvores AVL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvores</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">preto-vermelho, √°rvores de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">prefixo</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">listas de pulos</a> etc.  Uso algumas estruturas de dados para apenas um algoritmo espec√≠fico e para nada mais (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pilhas</a> para implementar uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fila de prioridade</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">algoritmo de pesquisa de caminho A *</a> ). <br><br>  No trabalho di√°rio, costumo fazer com surpreendentemente poucas estruturas de dados.  Na maioria das vezes, eles s√£o √∫teis para mim: <br><br><ul><li>  Matrizes de dados compartilhados (dados em massa) - uma maneira de armazenar efetivamente um grande n√∫mero de objetos. </li><li>  Refer√™ncias fracas (ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">identificadores</a> ) - uma maneira de acessar objetos em dados em massa sem falhas no programa se o objeto for exclu√≠do. </li><li>  Os √≠ndices s√£o uma maneira de acessar rapidamente subconjuntos individuais em dados em massa. </li><li>  Matrizes de matrizes s√£o uma maneira de armazenar objetos de dados em massa com tamanhos din√¢micos. </li></ul><br>  Vou dedicar v√°rios artigos a como geralmente implemento todas essas estruturas.  Vamos come√ßar com os dados em massa mais simples e √∫teis. <a name="habracut"></a><br><br><h2>  Dados em massa </h2><br>  N√£o existe um termo comum para este conceito (ou n√£o o conhe√ßo).  Eu chamo de " <em>dados em massa</em> " qualquer cole√ß√£o grande de objetos semelhantes.  Por exemplo, poderia ser: <br><br><ul><li>  Todas as balas no jogo. </li><li>  Todas as √°rvores do jogo. </li><li>  Todas as moedas do jogo. </li></ul><br>  Ou, se voc√™ estiver escrevendo c√≥digo em um n√≠vel mais alto de abstra√ß√£o, pode ser: <br><br><ul><li>  Todas as entidades no jogo. </li><li>  Todas as malhas do jogo. </li><li>  Todos os sons do jogo. </li></ul><br>  Normalmente, cada sistema (renderiza√ß√£o, som, anima√ß√£o, f√≠sica etc.) em um jogo tem alguns tipos diferentes de objetos que ele precisa rastrear.  Por exemplo, para um sistema de som, poderia ser: <br><br><ul><li>  Todos os recursos sonoros que <em>podem ser</em> reproduzidos. </li><li>  Todos os sons <em>atualmente sendo</em> reproduzidos. </li><li>  Todos os efeitos (atenua√ß√£o, altera√ß√µes de tom etc.) aplicados aos sons. </li></ul><br>  No caso de dados em massa, assumirei o seguinte: <br><br><ul><li>  A ordem de armazenamento dos objetos n√£o √© importante.  I.e.  n√≥s percebemos a matriz como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muitos</a> objetos. </li><li> Cada objeto √© representado como uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estrutura de dados simples (POD-struct) de</a> tamanho fixo que pode ser movido ou duplicado usando <code>memcpy()</code> . </li></ul><br>  Obviamente, voc√™ pode criar situa√ß√µes em que a ordem √© <em>importante</em> .  Por exemplo, se os objetos denotarem elementos para renderiza√ß√£o, antes da renderiza√ß√£o, podemos precisar classific√°-los da frente para tr√°s para reduzir a quantidade de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">redesenho</a> . <br><br>  No entanto, acredito que, na maioria dos casos, √© prefer√≠vel classificar os dados √† <em>medida que s√£o usados</em> , em vez de armazen√°- <em>los</em> em um cont√™iner classificado, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvores preto-vermelho</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvores</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">B.</a>  Por exemplo, podemos classificar os objetos renderizados da frente para tr√°s antes de pass√°-los para o renderizador ou classificar os arquivos em ordem alfab√©tica antes de exibi-los na tela como uma lista.  A classifica√ß√£o dos dados em cada quadro pode parecer dispendiosa, mas em muitos casos isso √© feito em <em>O (n)</em> usando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classifica√ß√£o radix</a> . <br><br>  Como uso apenas estruturas de dados simples, prefiro objetos C ++ a objetos C ++, porque √© mais f√°cil entender o que est√° acontecendo na mem√≥ria e avaliar seu desempenho.  No entanto, h√° situa√ß√µes em que voc√™ precisa armazenar em massa dados que n√£o possuem um tamanho fixo.  por exemplo, o nome ou a lista de objetos filho.  Vou falar sobre esses casos em um post separado, onde analisamos "matrizes de matrizes".  Por enquanto, vamos supor que todos os objetos sejam estruturas de dados simples e de tamanho fixo. <br><br>  Por exemplo, aqui est√° como ser√£o as estruturas de dados em massa do nosso sistema de som hipot√©tico: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resource_t</span></span> *resource; <span class="hljs-comment"><span class="hljs-comment">// Resource manager data uint64_t bytes; // Size of data uint64_t format; // Data format identifier } sound_resource_t; typedef struct { sound_resource_t *resource; // Resource that's playing uint64_t samples_played; // Number of samples played float volume; // Volume of playing sound } playing_sound_t; typedef struct { playing_sound_t *sound; // Faded sound float fade_from; // Volume to fade from float fade_to; // Volume to fade to double fade_from_ts; // Time to start fade double fade_to_ts; // Time to end fade } playing_fade_t;</span></span></code> </pre> <br>  Ao considerar maneiras de armazenar dados em massa, precisamos considerar algumas metas: <br><br><ul><li>  Adicionar e remover objetos deve ser r√°pido. </li><li>  Os dados devem estar localizados em um formato <strong>conveniente para armazenamento em cache</strong> , para que voc√™ possa iterar rapidamente para atualizar o sistema. </li><li>  Ele deve suportar <strong>o mecanismo de link</strong> - deve haver uma maneira de transmitir informa√ß√µes <em>sobre</em> objetos espec√≠ficos em dados em massa.  No exemplo acima, o fade deve poder especificar qual som √© atenuado.  No exemplo, escrevi os links como ponteiros, mas sua implementa√ß√£o depende de como os dados em massa s√£o organizados. </li><li>  Os dados devem ser <strong>amig√°veis ‚Äã‚Äãao alocador</strong> - devem usar v√°rias aloca√ß√µes de mem√≥ria grandes e n√£o alocar objetos individuais no heap. </li></ul><br>  As duas maneiras mais f√°ceis de representar dados em massa s√£o uma matriz est√°tica ou um vetor C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Static array #define MAX_PLAYING_SOUNDS 1024 uint32_t num_playing_sounds; playing_sound_t playing_sounds[MAX_PLAYING_SOUNDS]; // C++ vector std::vector&lt;playing_sound_t&gt; playing_sounds;</span></span></code> </pre> <br>  Trabalhar com uma matriz √© extremamente simples e pode funcionar bem se voc√™ souber exatamente quantos objetos s√£o necess√°rios no aplicativo.  Se voc√™ <em>n√£o sabe disso</em> , desperdice sua mem√≥ria ou ficar√° sem objetos. <br><br>  O vetor <code>std::vector</code> tamb√©m √© uma solu√ß√£o muito digna e simples, mas aqui voc√™ precisa considerar alguns aspectos: <br><br><ul><li>  A implementa√ß√£o padr√£o do <code>std::vector</code> do Visual Studio √© lenta no modo de depura√ß√£o devido a iteradores de depura√ß√£o.  Eles devem ser definidos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">_ITERATOR_DEBUG_LEVEL = 0</a> . </li><li>  Para criar e destruir objetos, o <code>std::vector</code> usa construtores e destruidores e, em alguns casos, pode ser muito mais lento que o <code>memcpy()</code> . </li><li>  <code>std::vector</code> muito mais dif√≠cil de analisar do que implementar um simples <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"buffer extens√≠vel"</a> . </li></ul><br>  Al√©m disso, sem medidas adicionais, nem matrizes nem vetores regulares suportam refer√™ncias a objetos individuais.  Vamos examinar este t√≥pico, bem como outras decis√µes importantes de design envolvidas na cria√ß√£o do sistema de dados em massa. <br><br><h2>  Estrat√©gia de remo√ß√£o </h2><br>  A primeira decis√£o importante: o que deve ser feito ao excluir o objeto <code>a[i]</code> .  Aqui est√£o tr√™s op√ß√µes principais: <br><br><ul><li>  Voc√™ pode mudar todos os elementos subsequentes <code>a[i+1]</code> ‚Üí <code>a[i]</code> , <code>a[i+2]</code> ‚Üí <code>a[i+1]</code> etc. para fechar um slot vazio. </li><li>  Voc√™ pode mover o √∫ltimo elemento da matriz para um slot vazio: <code>a[i] = a[n-1]</code> . </li><li>  Ou voc√™ pode deixar o slot vazio criando um buraco na matriz.  Este buraco pode ser usado posteriormente para colocar um novo objeto. </li></ul><br>  A primeira op√ß√£o √© terr√≠vel - <em>O (n)</em> √© gasto no movimento de todos esses elementos.  O √∫nico benef√≠cio do primeiro m√©todo √© que, se a matriz for classificada, a ordem nela ser√° preservada.  Mas, como mencionado acima, o pedido n√£o nos incomoda.  Observe que se voc√™ usar <code>a.erase()</code> para remover o elemento <code>std::vector</code> , √© exatamente isso que acontecer√°! <br><br>  A segunda op√ß√£o √© frequentemente chamada de "swap-and-pop".  Porque  Como se voc√™ usar um vetor C ++, essa op√ß√£o geralmente √© implementada substituindo (trocando) o elemento que voc√™ deseja excluir pelo √∫ltimo, seguido pela remo√ß√£o ou popping do √∫ltimo elemento: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(a[i], a[a.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>]); a.pop_back();</code> </pre> <br>  Por que tudo isso √© necess√°rio?  Em C ++, se <em>atribuirmos</em> <code>a[i] = a[n-1]</code> , primeiro devemos remover <code>a[i]</code> chamando seu destruidor e depois chamar o construtor de c√≥pia para criar uma c√≥pia de <code>a[n-1]</code> na posi√ß√£o <code>i</code> finalmente, chamamos o destruidor de <code>a[n-1]</code> ao mudar o vetor.  Se o construtor de c√≥pia alocar mem√≥ria e copiar dados, isso pode ser muito ruim.  Se usarmos <code>std::swap</code> vez de atribui√ß√£o, podemos fazer apenas com a movimenta√ß√£o dos construtores e n√£o devemos alocar mem√≥ria. <br><br>  Novamente, √© por isso que C ++ prefiro estruturas de dados simples e opera√ß√µes em C. O C ++ tem muitas armadilhas de desempenho nas quais voc√™ pode cair se n√£o souber o que est√° acontecendo l√° dentro.  Em C, a opera√ß√£o de troca e apagamento ser√° muito simples: <br><br><pre> <code class="cpp hljs">a.data[i] = a.data[--an];</code> </pre> <br>  Ao usar swap e pop, os objetos permanecem compactados.  Para colocar um novo objeto, basta anex√°-lo ao final da matriz. <br><br>  Se usarmos a op√ß√£o ‚Äúcom furos‚Äù I, ao colocar um novo objeto, primeiro precisamos verificar se existem ‚Äúfuros‚Äù livres que possam ser usados.  Vale a pena aumentar o tamanho da matriz somente quando n√£o houver ‚Äúfuros‚Äù livres.  Caso contr√°rio, no processo de exclus√£o e cria√ß√£o de objetos, ele crescer√° indefinidamente. <br><br>  Voc√™ pode usar um <code>std::vector&lt;uint32_t&gt;</code> separado <code>std::vector&lt;uint32_t&gt;</code> para rastrear as posi√ß√µes dos furos, mas h√° uma solu√ß√£o melhor que n√£o requer mem√≥ria adicional. <br><br>  Como os dados do objeto no "furo" n√£o s√£o usados ‚Äã‚Äãpara nada, voc√™ pode us√°-lo para armazenar um ponteiro para o pr√≥ximo furo livre.  Assim, todos os furos na matriz formam uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lista simplesmente conectada</a> e, se necess√°rio, podemos adicionar e remover elementos dela. <br><br>  Esse tipo de estrutura de dados, na qual a mem√≥ria n√£o utilizada √© usada para ligar elementos livres, geralmente √© chamada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lista livre</a> . <br><br>  Em uma lista vinculada tradicional, um <em>elemento</em> especial do <em>cabe√ßalho da</em> lista aponta para o primeiro n√≥ da lista e o √∫ltimo elemento da lista aponta para NULL, o que significa o fim da lista.  Em vez disso, prefiro usar uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lista vinculada circular</a> , na qual o cabe√ßalho √© apenas um item de lista especial e o √∫ltimo item da lista aponta para um elemento de cabe√ßalho: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/fe0/a6b/ffefe0a6b6bd621b9362e84486db65e1.jpg" width="100%"></div><br>  <i>Listas tradicionais e com links para anel.</i> <br><br>  A vantagem dessa abordagem √© que o c√≥digo se torna muito mais simples, reduzindo o n√∫mero de casos especiais no in√≠cio e no final da lista. <br><br>  Observe que se voc√™ usar <code>std::vector</code> para armazenar objetos, os ponteiros para os objetos ser√£o alterados a cada redistribui√ß√£o do vetor.  Isso significa que n√£o podemos usar ponteiros regulares para uma lista vinculada, porque os ponteiros est√£o constantemente mudando.  Para contornar esse problema, voc√™ pode usar √≠ndices como "ponteiros" para a lista vinculada, pois o √≠ndice aponta constantemente para um slot espec√≠fico, mesmo ao redistribuir a matriz.  Falaremos mais sobre realoca√ß√£o na pr√≥xima se√ß√£o. <br><br>  Voc√™ pode alocar espa√ßo para um elemento especial do t√≠tulo da lista, sempre armazenando-o no slot 0 da matriz. <br><br>  O c√≥digo ser√° algo como isto: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The objects that we want to store: typedef struct {...} object_t; // An item in the free list points to the next one. typedef struct { uint32_t next_free; } freelist_item_t; // Each item holds either the object data or the free list pointer. typedef union { object_t; freelist_item_t; } item_t; typedef struct { std::vector&lt;item_t&gt; items; } bulk_data_t; void delete_item(bulk_data_t *bd, uint32_t i) { // Add to the freelist, which is stored in slot 0. bd-&gt;items[i].next = bd-&gt;items[0].next; bd-&gt;items[0].next = i; } uint32_t allocate_slot(bulk_data_t *bd) { const uint32_t slot = bd-&gt;items[0].next; bd-&gt;items[0].next = bd-&gt;items[slot].next; // If the freelist is empty, slot will be 0, because the header // item will point to itself. if (slot) return slot; bd-&gt;items.resize(bd-&gt;items.size() + 1); return bd-&gt;items.size() - 1; }</span></span></code> </pre> <br>  Qual √© a melhor estrat√©gia de remo√ß√£o?  Movendo o √∫ltimo elemento para um slot vazio, garantindo uma compacta√ß√£o apertada da matriz ou mantendo todos os elementos em seus lugares com a cria√ß√£o de ‚Äúorif√≠cios‚Äù na matriz no lugar do elemento exclu√≠do? <br><br>  Ao tomar uma decis√£o, dois aspectos devem ser levados em considera√ß√£o: <br><br><ul><li>  A itera√ß√£o sobre uma matriz densamente compactada √© mais r√°pida, porque ignoramos menos mem√≥ria e n√£o precisamos gastar muito tempo pulando espa√ßos vazios. </li><li>  Se usarmos uma matriz compactada, os elementos se mover√£o.  Isso significa que n√£o podemos usar o √≠ndice de um elemento como um identificador constante para refer√™ncias externas a elementos.  Teremos que atribuir um identificador diferente para cada elemento e usar a tabela de pesquisa para corresponder esses IDs constantes aos √≠ndices de objetos atuais.  Essa tabela de pesquisa pode ser uma tabela de hash ou um <code>std::vector</code> com orif√≠cios, conforme descrito acima (a segunda op√ß√£o √© mais r√°pida).  Seja como for, precisaremos de mem√≥ria adicional para esta tabela e uma etapa indireta extra para identificadores. </li></ul><br>  A escolha da melhor op√ß√£o depende do seu projeto. <br><br>  Voc√™ pode dizer que armazenar uma matriz densamente compactada √© melhor, porque as itera√ß√µes sobre todos os elementos (para atualizar o sistema) ocorrem com mais frequ√™ncia do que os links externos correspondentes.  Por outro lado, podemos dizer que o desempenho de uma ‚Äúmatriz com furos‚Äù √© pior apenas no caso de um grande n√∫mero de furos, e no desenvolvimento de jogos geralmente nos preocupamos com o desempenho nos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">piores casos</a> (queremos ter uma taxa de quadros de 60 Hz, mesmo quando as opera√ß√µes m√°ximas s√£o realizadas no jogo) .  Na pior das hip√≥teses, temos o n√∫mero m√°ximo de objetos reais e, nesse caso, <em>n√£o haver√° furos</em> na matriz.  Os furos ocorrem apenas quando o n√∫mero de objetos diminui, quando exclu√≠mos alguns desses objetos. <br><br>  Tamb√©m existem estrat√©gias que podem ser usadas para acelerar o processamento de matrizes com muitos furos.  Por exemplo, podemos rastrear os comprimentos das seq√º√™ncias cont√≠nuas de furos para pular seq√º√™ncias inteiras de furos por vez, em vez de elemento por elemento.  Como esses dados s√£o necess√°rios apenas para "furos" e n√£o para elementos comuns, voc√™ pode armazen√°-los junto com o ponteiro da lista de libera√ß√£o na mem√≥ria n√£o alocada de objetos e n√£o desperdi√ßar mem√≥ria extra. <br><br>  Na minha opini√£o, se voc√™ n√£o precisa otimizar o c√≥digo para itera√ß√µes r√°pidas, provavelmente √© melhor usar a op√ß√£o "array with holes".  √â mais simples, n√£o requer estruturas de pesquisa adicionais e voc√™ pode usar o √≠ndice do objeto como seu ID, o que √© muito conveniente.  Al√©m disso, a falta de objetos em movimento elimina poss√≠veis erros. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/781/6e3/91f/7816e391f0b8c68dede02d95dffa304f.jpg" width="100%"></div><br>  <i>Estrat√©gias de remo√ß√£o de dados em massa.</i> <br><br><h2>  Ponteiros fracos </h2><br>  Como observa√ß√£o, direi que √© f√°cil implementar o suporte a "indicadores fracos" ou "descritores" para objetos de dados em massa. <br><br>  <em>Um ponteiro fraco</em> √© uma refer√™ncia a um objeto que, de alguma forma, pode determinar que o objeto ao qual se refere foi exclu√≠do.  O conveniente em indicadores fracos √© que eles permitem excluir objetos sem se preocupar com quem pode fazer refer√™ncia a eles.  Sem ponteiros fracos para remover um objeto, precisar√≠amos procurar cada link individual e declar√°-lo inv√°lido.  Isso pode ser especialmente dif√≠cil se os links estiverem armazenados no c√≥digo de script, em outros computadores na rede etc. <br><br>  Lembre-se de que j√° temos um ID que identifica exclusivamente objetos <em>existentes</em> .  Na op√ß√£o "com furos", esse ID √© simplesmente o √≠ndice do elemento (porque os elementos nunca se movem).  No caso de matrizes densamente compactadas, esse √≠ndice de objeto √© um registro na <em>matriz de pesquisa</em> . <br><br>  O pr√≥prio ID n√£o pode ser usado como um ponteiro fraco, porque os IDs podem ser reutilizados.  Se um elemento for exclu√≠do e um novo elemento for criado no mesmo espa√ßo, n√£o poderemos descobrir isso apenas pelo ID.  Para obter um ponteiro fraco, voc√™ precisa combinar o ID com o campo de <code>generation</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> generation; } <span class="hljs-keyword"><span class="hljs-keyword">weak_pointer_t</span></span>;</code> </pre> <br>  O campo de <code>generation</code> √© um campo na estrutura do objeto que rastreia quantas vezes o slot na matriz de dados em massa foi reutilizado.  (No caso de embalagem apertada, ele controla quantas vezes o slot foi reutilizado na matriz de <em>pesquisa</em> .) <br><br>  Quando voc√™ exclui um item, aumentamos o n√∫mero de gera√ß√£o em seu slot.  Para verificar se o ponteiro fraco ainda √© v√°lido, verificamos se a <code>generation</code> na estrutura do ponteiro fraco corresponde √† gera√ß√£o do slot indicado por seu <code>id</code> .  Se eles corresponderem, o objeto de origem que estamos referenciando ainda existe.  Caso contr√°rio, significa que foi exclu√≠do e o slot est√° na lista de libera√ß√£o ou foi reutilizado. <br><br>  Lembre-se de que, como o campo de <code>generation</code> √© necess√°rio para os furos e para os objetos existentes, √© necess√°rio armazen√°-lo fora da uni√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> generation; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">freelist_item_t</span></span>; }; } <span class="hljs-keyword"><span class="hljs-keyword">item_t</span></span>;</code> </pre> <br><h2>  Estrat√©gia de distribui√ß√£o </h2><br>  Se voc√™ usar <code>std::vector</code> para armazenar dados do elemento, quando a matriz estiver cheia e precisar ser aumentada, toda a matriz de elementos ser√° redistribu√≠da.  Os itens existentes s√£o copiados para a nova matriz. <br><br>  <code>std::vector</code> cresce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>geometricamente</em></a> .  Isso significa que toda vez que um vetor precisa aumentar, o n√∫mero de elementos distribu√≠dos √© multiplicado por algum fator (geralmente por √ó 2).  O crescimento geom√©trico (exponencial) √© importante porque mant√©m os custos de aumentar a matriz constantes. <br><br>  Ao redistribuir a matriz, precisamos mover todos os elementos, o que requer <em>O (n)</em> .  No entanto, √† medida que a matriz cresce, adicionamos espa√ßo para outros <em>n</em> elementos, porque dobramos o tamanho.  Isso significa que n√£o precisaremos aumentar o array novamente at√© adicionarmos mais <em>n</em> elementos a ele.  Ou seja, os custos de aumento s√£o iguais a <em>O (n)</em> , mas apenas os executamos * O (n) * pela en√©sima vez que escrevemos no array, ou seja, em m√©dia, o custo de escrever um elemento √© <em>O (n) / O (n) = O (1)</em> <br><br>  O custo de registrar um item √© chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>constante amortizada</em></a> , porque se voc√™ calcular a m√©dia de todos os registros que est√£o sendo executados, os custos ser√£o fixos.  No entanto, n√£o devemos esquecer que, antes da m√©dia, os custos acabam sendo muito espasm√≥dicos.  Ap√≥s todos os registros de <em>O (n)</em> , obtemos um pico de altura <em>O (n)</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/331/5be/1d03315be5a0c1ad8096ac05f11c7893.jpg" width="100%"></div><br>  <i>O custo de escrever para <code>std::vector</code> .</i> <br><br>  Vamos ver tamb√©m o que acontece se n√£o usarmos crescimento geom√©trico.  Suponha que, em vez de dobrar a mem√≥ria durante o crescimento, simplesmente adicionaremos mais 128 slots.  Mover dados antigos ainda nos custa <em>O (n)</em> , mas agora precisamos faz√™-lo a cada 128 itens adicionados, ou seja, os custos m√©dios agora ser√£o <em>O (n) / O (128) = O (n)</em> .  O custo de escrever um elemento em uma matriz √© proporcional ao tamanho da matriz; portanto, quando a matriz se torna grande, ela come√ßa a trabalhar √† velocidade da tartaruga.  Opa! <br><br>  A estrat√©gia de distribui√ß√£o <code>std::vector</code> √© uma boa op√ß√£o padr√£o, funcionando bem na maioria dos casos, mas tem alguns problemas: <br><br><ul><li>  Constante amortizada n√£o √© adequada para software em tempo real.  Se voc√™ possui uma matriz muito grande, digamos, centenas de milh√µes de elementos, o aumento dessa matriz e a movimenta√ß√£o de todos os elementos podem causar um abrandamento percept√≠vel na taxa de quadros.  Isso √© problem√°tico pelo mesmo motivo que a coleta de lixo √© problem√°tica nos jogos.  N√£o importa qu√£o baixos sejam os custos m√©dios, se em alguns quadros os custos puderem subir, causando falhas no jogo. </li><li>  Da mesma forma, essa estrat√©gia de aloca√ß√£o no caso de matrizes grandes pode desperdi√ßar muita mem√≥ria.  Digamos que temos um conjunto de 16 milh√µes de elementos e precisamos escrever outro.  Isso far√° com que a matriz cres√ßa para 32 milh√µes.  Agora, temos 16 milh√µes de elementos na matriz que n√£o estamos usando.  Para uma plataforma com pouca mem√≥ria, isso √© muito. </li><li>  Por fim, a realoca√ß√£o move objetos na mem√≥ria, invalidando todos os ponteiros para objetos.  Isso pode ser uma fonte de erros dif√≠ceis de rastrear. </li></ul><br>  O c√≥digo abaixo √© um exemplo de bugs que podem ocorrer ao mover objetos: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Create two items and return the sum of their costs. float f(bulk_data_t *bd) { const uint32_t slot_1 = allocate_slot(bd); item_t *item_1 = &amp;bd-&gt;items[slot_1]; const uint32_t slot_2 = allocate_slot(bd); item_t *item_2 = &amp;bd-&gt;items[slot_2]; return item_1-&gt;cost + item_2-&gt;cost; }</span></span></code> </pre> <br>  O problema aqui √© que a fun√ß√£o <code>item_2</code> <code>allocate_slot()</code> pode precisar redistribuir a matriz para criar espa√ßo para o <code>item_2</code> .  Nesse caso, o <code>item_1</code> ser√° movido para a mem√≥ria e o ponteiro para o <code>item_1</code> deixar√° de ser v√°lido.  Nesse caso em particular, podemos eliminar o erro movendo o <code>item_1</code> atribui√ß√£o_1, mas erros semelhantes podem parecer mais impercept√≠veis.  Pessoalmente, eles me morderam muitas vezes. <br><br>  Essa situa√ß√£o √© perversa pelo fato de que o bug ser√° lan√ßado apenas quando a matriz for redistribu√≠da exatamente no momento em que o <code>slot_2</code> .  O programa pode funcionar corretamente por um longo tempo at√© que algo mude o padr√£o de distribui√ß√£o, ap√≥s o qual o bug funcionar√°. <br><br>  Todos esses problemas podem ser resolvidos usando uma estrat√©gia de distribui√ß√£o diferente.  Aqui est√£o algumas das op√ß√µes: <br><br><ul><li>       : 16, 32, 64, ‚Ä¶,  <em></em>     . ,  16     ,  32   ,  .‚Ä¶     ,         <code>std::vector</code> . </li><li>           ,     .       ,       .               . ,           <em>O(n)</em>  <code>push()</code> ,        . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">       </a> ,      ,   ,     ,   . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repito, cada m√©todo tem suas pr√≥prias vantagens e desvantagens. O √∫ltimo √© bom porque os elementos ainda est√£o armazenados na mem√≥ria um ao lado do outro, e precisamos rastrear um √∫nico buffer, para que vetores ou listas adicionais n√£o sejam necess√°rios. Requer a configura√ß√£o do tamanho m√°ximo da matriz, mas o espa√ßo dos endere√ßos virtuais √© t√£o grande que voc√™ geralmente pode especificar qualquer n√∫mero enorme sem o menor problema.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ n√£o pode usar uma solu√ß√£o com mem√≥ria virtual, qual abordagem seria melhor - tamanho fixo ou blocos com crescimento geom√©trico? Se a matriz for muito pequena, um tamanho fixo gasta muita mem√≥ria extra. Por exemplo, se um bloco tiver um tamanho de 16 mil elementos, use todos esses 16 mil elementos, mesmo que haja apenas um elemento na matriz. Por outro lado, com o crescimento geom√©trico, voc√™ estar√° desperdi√ßando mem√≥ria com uma matriz muito grande, porque, em m√©dia, o √∫ltimo bloco distribu√≠do estar√° 50% cheio. Para uma grande variedade, isso pode ter muitos megabytes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais uma vez direi que no desenvolvimento de jogos √© mais importante otimizar o c√≥digo para o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pior caso</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ent√£o n√£o estou realmente preocupado em perder mem√≥ria em matrizes pequenas, se matrizes grandes sempre mostrarem bom desempenho. A quantidade total de mem√≥ria desperdi√ßada nunca ser√° superior a * 16 K * n *, em que </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© o n√∫mero de matrizes de dados em massa separadas no projeto e n√£o acho que teremos muitas matrizes diferentes (apenas algumas pe√ßas para cada sistema). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blocos de tamanho fixo t√™m duas outras vantagens. Em primeiro lugar, os c√°lculos para encontrar um elemento por seu √≠ndice s√£o mais simples, √© apenas </font></font><code>blocks\[i / elements_per_block\][i % elements_per_block]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em segundo lugar, alocar mem√≥ria diretamente da mem√≥ria virtual √© muito mais eficiente do que acessar um alocador din√¢mico (alocador de heap), devido √† falta de fragmenta√ß√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concluindo, quero dizer que, se voc√™ usar a op√ß√£o ‚Äúwith holes‚Äù para armazenamento de dados, acho que vale a pena sair da estrat√©gia de distribui√ß√£o </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que os objetos obtenham indicadores constantes que nunca mudam. </font><font style="vertical-align: inherit;">Provavelmente, uma grande variedade de mem√≥ria virtual ser√° a melhor solu√ß√£o, mas se voc√™ n√£o puder implement√°-la, a segunda melhor op√ß√£o ser√° uma sequ√™ncia de blocos de tamanho fixo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que, como essa abordagem torna os ponteiros para objetos permanentes, agora, al√©m dos IDs, podemos usar ponteiros para objetos para se referir a objetos. </font><font style="vertical-align: inherit;">A vantagem disso √© que podemos acessar objetos diretamente, sem realizar pesquisas de √≠ndice. </font><font style="vertical-align: inherit;">Por outro lado, um ponteiro precisa de 64 bits de mem√≥ria e 32 bits geralmente s√£o suficientes para um √≠ndice (4 bilh√µes de objetos s√£o muitos).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98e/f31/c3d/98ef31c3d3388db45f0897c9a390ce5d.jpg" width="100%"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrat√©gias de distribui√ß√£o</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matriz de estruturas e estrutura de matrizes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra decis√£o importante do projeto √© escolher entre uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matriz de estruturas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Matriz de estruturas, AoS) e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma estrutura de matriz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Estrutura de matrizes, SoA). </font><font style="vertical-align: inherit;">A diferen√ßa √© melhor mostrada pelo exemplo. </font><font style="vertical-align: inherit;">Suponha que tenhamos um sistema de part√≠culas no qual as part√≠culas tenham vida √∫til, posi√ß√£o, velocidade e cor:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> pos; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> vel; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> col; } <span class="hljs-keyword"><span class="hljs-keyword">particle_t</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira usual de armazenar seria colocar muitas dessas estruturas em uma matriz. </font><font style="vertical-align: inherit;">√â por isso que chamamos de "conjunto de estruturas". </font><font style="vertical-align: inherit;">Isto √©:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">particle_t</span></span> *particles;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, em vez da matriz usual, voc√™ pode usar qualquer uma das estrat√©gias acima. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na variante da estrutura da matriz (SoA), usamos uma matriz separada para cada campo da estrutura:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *t; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *pos; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *vel; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *col; } particles;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, podemos ir ainda mais longe, porque </font></font><code>vec3_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em si √© uma estrutura:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_y; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_y; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_r; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_g; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_b; } particles;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso parece muito mais complicado do que o nosso esquema AoS original, por que √© realmente necess√°rio? </font><font style="vertical-align: inherit;">Existem dois argumentos para apoiar essa abordagem:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alguns algoritmos funcionam apenas com um subconjunto de campos. </font><font style="vertical-align: inherit;">Por exemplo, um algoritmo </font></font><code>tick()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afeta apenas um campo </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O algoritmo </font></font><code>simulate_physics()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afeta apenas os campos </font></font><code>pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>vel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em um esquema SoA, apenas certas partes de uma estrutura s√£o carregadas na mem√≥ria. </font><font style="vertical-align: inherit;">Se estamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limitados pela mem√≥ria</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (o que geralmente acontece com os processadores modernos), isso pode ter um grande impacto. </font><font style="vertical-align: inherit;">Por exemplo, uma fun√ß√£o </font></font><code>tick()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afeta apenas 1/10 da mem√≥ria, o que significa que ela recebe acelera√ß√£o 10 vezes.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O esquema SoA permite carregar dados diretamente nos registros </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIMD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para processamento. </font><font style="vertical-align: inherit;">Isso pode ter um grande impacto se estivermos limitados √†s </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPUs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Usando o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> podemos processar oito n√∫meros flutuantes por vez, o que fornece uma acelera√ß√£o de 8 vezes.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso significa que, com essas acelera√ß√µes, ele </font></font><code>tick()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se tornar√° 80 mais r√°pido?</font></font> N√£o.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obteremos a primeira acelera√ß√£o de 10 vezes apenas se estivermos completamente limitados pela mem√≥ria e se estivermos completamente limitados pela mem√≥ria, o SIMD n√£o poder√° permitir que trabalhemos mais rapidamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desvantagens da abordagem SoA:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O c√≥digo est√° ficando mais complicado. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mais press√£o no distribuidor, porque precisamos distribuir, em vez de um ponto, dez matrizes separadas. </font></font></li><li>           <code>particle_t *</code> ,         .      . </li><li>           ,            </li><li>             ( ),  <em></em>   .     <em>  </em> ,     . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como um exemplo de que tipo de problemas pode surgir com o cache, lembre-se das part√≠culas de estrutura mostradas acima e imagine que alocamos todas as matrizes usando uma VM (ou seja, elas est√£o alinhadas nas bordas de uma p√°gina de quatro kilobytes). Devido a esse alinhamento, todos os 10 campos de part√≠culas struct ser√£o vinculados a um bloco de cache. Se o cache for associativo m√∫ltiplo de 8 canais, isso significa que todos os campos da part√≠cula n√£o podem estar no cache ao mesmo tempo. Opa! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma maneira de resolver esse problema √© agrupar as part√≠culas pelo tamanho do vetor SIMD. Por exemplo, podemos fazer o seguinte:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_x[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_y[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_z[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_x[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_y[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_z[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_r[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_g[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_b[<span class="hljs-number"><span class="hljs-number">8</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">eight_particles_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">eight_particles_t</span></span> *particles;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse esquema, ainda podemos usar as instru√ß√µes SIMD para processar oito part√≠culas por vez, mas os campos de uma part√≠cula est√£o bem pr√≥ximos na mem√≥ria e n√£o temos problemas com colis√µes de linhas de cache que apareceram anteriormente. Isso √© melhor para um sistema de distribui√ß√£o, porque estamos de volta a uma distribui√ß√£o por toda a matriz de part√≠culas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse caso, o algoritmo </font></font><code>tick()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afetar√° 32 bytes, ignorar√° 288 bytes, afetar√° 32 bytes, etc. Isso significa que n√£o obteremos acelera√ß√£o total de 10x, como no caso de uma matriz separada</font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em primeiro lugar, as linhas de cache geralmente t√™m um tamanho de 64 bytes e, como usamos apenas metade, n√£o podemos acelerar mais de 5 vezes. Al√©m disso, os custos associados ao ignorar bytes podem ocorrer, mesmo se processarmos as linhas de cache completas, mas n√£o tenho 100% de certeza sobre isso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resolver esse problema, voc√™ pode experimentar o tamanho do grupo. Por exemplo, voc√™ pode redimensionar um grupo </font></font><code>[16]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para um campo flutuante que preencha toda a linha de cache. Ou, se voc√™ usar um m√©todo de aloca√ß√£o de bloco, poder√° simplesmente definir qualquer tamanho que caiba no bloco para o tamanho do grupo:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df8/7a2/558/df87a25586d4afb93a536585a84defef.png" width="100%"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AoS e SoA.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quanto √† estrat√©gia de exclus√£o, o SoA n√£o √© a melhor op√ß√£o para a op√ß√£o "com furos", porque se usarmos o SIMD para processar oito elementos ao mesmo tempo, n√£o seremos capazes de perder furos de maneira alguma (a menos que todos os oito elementos sejam "furos") . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como as instru√ß√µes do SIMD processam ‚Äúburacos‚Äù da mesma maneira que dados reais, precisamos garantir que os buracos contenham dados ‚Äúseguros‚Äù. Por exemplo, n√£o queremos que as opera√ß√µes de furo causem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exce√ß√µes nas opera√ß√µes de ponto flutuante</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou criem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√∫meros subnormais</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que reduzem o desempenho. Al√©m disso, n√£o devemos mais manter o ponteiro</font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma lista de libera√ß√£o usando union porque as opera√ß√µes do SIMD a substituir√£o. </font><font style="vertical-align: inherit;">Em vez disso, use o campo struct. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se usarmos a op√ß√£o densamente compactada, a exclus√£o ser√° um pouco mais cara, pois √© necess√°rio mover cada campo individualmente e n√£o uma estrutura inteira por vez. </font><font style="vertical-align: inherit;">Mas como a remo√ß√£o √© muito mais dif√≠cil que as atualiza√ß√µes, isso n√£o ser√° um grande problema.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparando AoS e SoA, posso dizer que, na maioria dos casos, melhorar o desempenho n√£o vale o trabalho de escrever c√≥digos mais pesados. </font><font style="vertical-align: inherit;">Eu o usaria como formato de armazenamento ‚Äúpadr√£o‚Äù para sistemas AoS e mudaria para SoA para sistemas que exigem velocidades de computa√ß√£o SIMD, como sistemas de recorte e part√≠culas. </font><font style="vertical-align: inherit;">Nesses casos, para velocidade m√°xima, eu provavelmente escolheria matrizes densamente compactadas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale a pena considerar outra op√ß√£o - armazenar dados no AoS e gerar dados tempor√°rios de SoA para processamento por algum algoritmo. Por exemplo, eu daria uma passada nos dados do AoS e os gravaria em um buffer SoA tempor√°rio, processaria esse buffer e, em seguida, escreveria os resultados novamente como AoS (se necess√°rio). Como neste caso eu tenho certeza do algoritmo que processar√° esses dados, posso otimizar o formato de armazenamento para eles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembre-se de que essa abordagem funciona bem com a op√ß√£o "armazenamento em bloco". Voc√™ pode processar um mil√©simo mil√©simo de cada vez, convert√™-lo em SoA, executar o algoritmo e gravar os resultados novamente. Para armazenar dados tempor√°rios, voc√™ precisa apenas de um buffer tempor√°rio com 16 mil elementos.</font></font><br><br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qualquer abordagem tem suas vantagens e desvantagens, mas "por padr√£o" eu recomendo armazenar dados em massa para o novo sistema da seguinte maneira: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma matriz de estruturas com "orif√≠cios" e ponteiros constantes, distribu√≠dos como um grande volume reservado na VM (se poss√≠vel) ou como uma matriz de blocos de tamanho fixo (16 mil cada ou em um tamanho ideal para seus dados). </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para casos em que voc√™ precisa de c√°lculos muito r√°pidos de valores para dados: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A estrutura de matrizes de objetos compactados, agrupadas por 8 para processamento SIMD e distribu√≠das como um grande volume reservado em uma VM ou como uma matriz de blocos de tamanho fixo. </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da pr√≥xima vez, consideraremos o t√≥pico de indexa√ß√£o desses dados. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469861/">https://habr.com/ru/post/pt469861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469839/index.html">Vulnerabilidade de spam no Pikabu</a></li>
<li><a href="../pt469843/index.html">"Onde est√£o os jovens punks que nos limpar√£o da face da terra?"</a></li>
<li><a href="../pt469849/index.html">O jogo "Attack 51%": escrevendo um jogo aut√¥nomo simples na plataforma Obyte</a></li>
<li><a href="../pt469855/index.html">Gradle + LLVM</a></li>
<li><a href="../pt469859/index.html">Sem√¢ntica de ponteiro e valor na determina√ß√£o do receptor de um m√©todo</a></li>
<li><a href="../pt469865/index.html">700 funcion√°rios e v√°rios continentes: como a Alconost construiu um modelo de neg√≥cios n√£o oficial</a></li>
<li><a href="../pt469869/index.html">Por que voc√™ deve fazer overclock de RAM (√© f√°cil!)</a></li>
<li><a href="../pt469871/index.html">Quando os teclados eram mesas</a></li>
<li><a href="../pt469875/index.html">Como proteger suas senhas em 2019</a></li>
<li><a href="../pt469877/index.html">Oh, este m√©todo de Newton</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>