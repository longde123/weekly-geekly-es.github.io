<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⬜️ 👩🏻‍🚀 💌 Comprendre RBAC dans Kubernetes 🎅🏼 🤜🏾 🥠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque perev. : Cet article a été écrit par Javier Salmeron, un ingénieur de la célèbre communauté Kubernetes de Bitnami, et publié sur le blog de l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprendre RBAC dans Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/422801/"> <i><b>Remarque</b></i>  <i><b>perev.</b></i>  <i>: Cet article a été écrit par Javier Salmeron, un ingénieur de la célèbre communauté Kubernetes de Bitnami, et publié sur le blog de la CNCF début août.</i>  <i>L'auteur parle des principes de base du mécanisme RBAC (contrôle d'accès basé sur les rôles) qui est apparu dans Kubernetes il y a un an et demi.</i>  <i>Le matériel sera particulièrement utile pour ceux qui connaissent le dispositif des composants clés des K8 (voir les liens vers d'autres articles similaires à la fin).</i> <br><br><img src="https://habrastorage.org/webt/tz/xm/qe/tzxmqenidfjgy8nps6myfacun2i.jpeg"><br>  <i>Diapositive d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">présentation</a> faite par un employé de Google à l'occasion de la sortie de Kubernetes 1.6</i> <br><br>  De nombreux utilisateurs expérimentés de Kubernetes se souviennent de la version de Kubernetes 1.6, lorsque l'autorisation basée sur le contrôle d'accès basé sur les rôles (RBAC) est devenue bêta.  Un mécanisme d'authentification alternatif est donc apparu, qui complétait le contrôle d'accès basé sur les attributs (ABAC), déjà difficile à gérer et à comprendre.  Tout le monde a accueilli avec enthousiasme la nouvelle fonctionnalité, mais en même temps, d'innombrables utilisateurs ont été déçus.  StackOverflow et GitHub regorgeaient de rapports de restrictions RBAC car la plupart de la documentation et des exemples ne tenaient pas compte de RBAC (mais maintenant tout va bien).  L'exemple de référence était Helm: l'exécution de <code>helm init</code> + <code>helm install</code> ne fonctionnait plus.  Du coup, nous devions ajouter des éléments «bizarres» comme <code>ServiceAccounts</code> ou <code>RoleBindings</code> avant même de déployer le graphique avec WordPress ou Redis (voir les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instructions</a> pour en savoir plus). <a name="habracut"></a><br><br>  Laissant de côté ces premières tentatives infructueuses, on ne peut pas nier l'énorme contribution de RBAC pour transformer Kubernetes en une plate-forme prête à la production.  Beaucoup d'entre nous ont réussi à jouer avec Kubernetes avec des privilèges d'administrateur complets, et nous comprenons parfaitement que dans un environnement réel, il est nécessaire: <br><br><ul><li>  Avoir de nombreux utilisateurs avec des propriétés différentes qui fournissent le mécanisme d'authentification souhaité. </li><li>  Ayez un contrôle total sur les opérations que chaque utilisateur ou groupe d'utilisateurs peut effectuer. </li><li>  Ayez un contrôle total sur les opérations que chaque processus du cœur peut effectuer. </li><li>  Limitez la visibilité de certaines ressources dans les espaces de noms. </li></ul><br>  Et à cet égard, RBAC est un élément clé qui fournit des capacités indispensables.  Dans l'article, nous allons rapidement passer en revue les bases <i>(voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette vidéo</a> pour plus de détails; suivez le lien du webinaire Bitnami d'une heure en anglais - <b>environ la traduction</b> )</i> et approfondissez un peu les moments les plus déroutants. <br><br><h2>  La clé pour comprendre RBAC dans Kubernetes </h2><br>  Pour réaliser pleinement l'idée de RBAC, vous devez comprendre que trois éléments y sont impliqués: <br><br><ul><li>  <i>Sujets</i> - un ensemble d'utilisateurs et de processus qui souhaitent avoir accès à l'API Kubernetes; </li><li>  <i>Ressources</i> - Une collection d'objets API Kubernetes disponibles dans un cluster.  Leurs exemples (entre autres) sont <i>Pods</i> , <i>Deployments</i> , <i>Services</i> , <i>Nodes</i> , <i>PersistentVolumes</i> ; </li><li>  <i>Verbes</i> (verbes) - un ensemble d'opérations pouvant être effectuées sur les ressources.  Il existe différents verbes (obtenir, regarder, créer, supprimer, etc.), mais tous sont finalement des opérations CRUD (créer, lire, mettre à jour, supprimer). </li></ul><br><img src="https://habrastorage.org/webt/xc/yp/cy/xcypcyyglvjo5v6igg213nbkfxo.png"><br><br>  Avec ces trois éléments à l'esprit, l'idée clé du RBAC est: <br><br>  «Nous voulons connecter les sujets, les ressources API et les opérations.»  En d'autres termes, nous voulons indiquer pour un <b>utilisateur</b> donné quelles <b>opérations</b> peuvent être effectuées sur une variété de <b>ressources</b> . <br><br><h2>  Comprendre les objets RBAC dans l'API </h2><br>  En combinant ces trois types d'entités, les objets RBAC disponibles dans l'API Kubernetes deviennent clairs: <br><br><ul><li>  <code>Roles</code> connectent les ressources et les verbes.  Ils peuvent être réutilisés pour différents sujets.  Lié à un espace de noms (nous ne pouvons pas utiliser de modèles représentant plus d'un [espace de noms], mais nous pouvons déployer le même objet de rôle dans différents espaces de noms).  Si vous souhaitez appliquer le rôle à l'ensemble du cluster, il existe un objet <code>ClusterRoles</code> similaire. </li><li>  <code>RoleBindings</code> connectent les entités d'entité restantes.  En spécifiant un rôle qui lie déjà les objets API aux verbes, nous sélectionnons maintenant les sujets qui peuvent les utiliser.  L'équivalent pour le niveau de cluster (c'est-à-dire sans liaison aux espaces de noms) est <code>ClusterRoleBindings</code> . </li></ul><br>  Dans l'exemple ci-dessous, nous donnons à l'utilisateur <i>jsalmeron le</i> droit de lire, d'obtenir une liste et de créer des foyers dans l'espace de noms de <i>test</i> .  Cela signifie que <i>jsalmeron</i> pourra exécuter ces commandes: <br><br><pre> <code class="bash hljs">kubectl get pods --namespace <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> kubectl describe pod --namespace <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> pod-name kubectl create --namespace <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -f pod.yaml <span class="hljs-comment"><span class="hljs-comment">#     </span></span></code> </pre> <br>  ... mais pas comme ça: <br><br><pre> <code class="bash hljs">kubectl get pods --namespace kube-system <span class="hljs-comment"><span class="hljs-comment">#    kubectl get pods --namespace test -w #    watch</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/rz/es/71/rzes71nhwjlob2scvnv0m5yfahy.png"><br><br>  Exemples de fichiers YAML: <br><br><pre> <code class="plaintext hljs">kind: Role apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: pod-read-create namespace: test rules: - apiGroups: [""] resources: ["pods"] verbs: ["get", "list", "create"]</code> </pre> <br><pre> <code class="plaintext hljs">kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: salme-pods namespace: test subjects: - kind: User name: jsalmeron apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: pod-read-create apiGroup: rbac.authorization.k8s.io</code> </pre> <br>  Un autre point intéressant est le suivant: maintenant que l'utilisateur peut créer des pods, pouvons-nous en limiter le nombre?  Cela nécessitera d'autres objets qui ne sont pas directement liés à la spécification RBAC et vous permettra de configurer les limites de ressources: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>ResourceQuota</code></a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>LimitRanges</code></a> .  Ils valent vraiment la peine d'être explorés lors de la configuration d'un composant de cluster aussi important [que la création de foyers]. <br><br><h2>  Sujets: Utilisateurs et ... Comptes de service? </h2><br>  L'une des difficultés rencontrées par de nombreux utilisateurs de Kubernetes dans le contexte des sujets est la distinction entre les utilisateurs réguliers et les <code>ServiceAccounts</code> .  En théorie, tout est simple: <br><br><ul><li>  <code>Users</code> - utilisateurs globaux, conçus pour des personnes ou des processus vivant en dehors du cluster; </li><li>  <code>ServiceAccounts</code> - limité par l'espace de noms et destiné aux processus du cluster s'exécutant sur des pods. </li></ul><br>  La similitude des deux types réside dans la nécessité de s'authentifier auprès de l'API pour effectuer certaines opérations sur de nombreuses ressources, et leurs sujets semblent très spécifiques.  Ils peuvent également appartenir à des groupes, donc <code>RoleBinding</code> permet de lier plusieurs sujets (bien qu'un seul groupe soit autorisé pour <code>ServiceAccounts</code> - <code>system:serviceaccounts</code> ).  Cependant, la principale différence est la cause du mal de tête: les utilisateurs n'ont pas d'objets qui leur correspondent dans l'API Kubernetes.  Il s'avère qu'une telle opération existe: <br><br><pre> <code class="bash hljs">kubectl create serviceaccount <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-service-account <span class="hljs-comment"><span class="hljs-comment"># OK</span></span></code> </pre> <br>  ... mais celui-ci est parti: <br><br><pre> <code class="bash hljs">kubectl create user jsalmeron <span class="hljs-comment"><span class="hljs-comment"># !</span></span></code> </pre> <br>  Cette situation a une conséquence grave: si le cluster ne stocke pas d'informations sur les utilisateurs, l'administrateur devra gérer les comptes en dehors du cluster.  Il existe différentes façons de résoudre le problème: certificats TLS, jetons, OAuth2, etc. <br><br>  De plus, vous devrez créer des contextes <code>kubectl</code> que nous puissions accéder au cluster via ces nouveaux comptes.  Pour créer des fichiers avec eux, vous pouvez utiliser les commandes de <code>kubectl config</code> (qui ne nécessitent pas d'accès à l'API Kubernetes, elles peuvent donc être exécutées par n'importe quel utilisateur).  La vidéo ci-dessus présente un exemple de création d'un utilisateur avec des certificats TLS. <br><br><h2>  RBAC dans les déploiements: exemple </h2><br>  Nous avons vu un exemple dans lequel l'utilisateur spécifié se voit accorder des droits sur les opérations du cluster.  Mais qu'en est-il des <i>déploiements</i> nécessitant un accès à l'API Kubernetes?  Envisagez un scénario spécifique pour mieux comprendre. <br><br>  Prenons par exemple l'application d'infrastructure populaire - RabbitMQ.  Nous utiliserons le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">graphique Helm pour RabbitMQ</a> de Bitnami (du référentiel officiel helm / charts), qui utilise le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conteneur bitnami / rabbitmq</a> .  Un plugin pour Kubernetes est intégré au conteneur, qui est responsable de la détection des autres membres du cluster RabbitMQ.  Pour cette raison, le processus à l'intérieur du conteneur nécessite un accès à l'API Kubernetes et nous devons configurer le <code>ServiceAccount</code> avec les privilèges RBAC corrects. <br><br>  En ce qui concerne les <code>ServiceAccounts</code> de <code>ServiceAccounts</code> , suivez cette bonne pratique: <br><br>  - Configurez <b>ServiceAccounts pour chaque déploiement</b> avec un <b>ensemble minimal de privilèges</b> . <br><br>  Pour les applications qui nécessitent un accès à l'API Kubernetes, vous pourriez être tenté de créer une sorte de « <code>ServiceAccount</code> privilégié» qui peut faire presque n'importe quoi dans le cluster.  Bien que cela semble être une solution plus simple, cela peut finalement conduire à une vulnérabilité de sécurité qui pourrait permettre des opérations indésirables.  (La vidéo examine un exemple de Tiller [composant Helm] et les conséquences d'avoir des <code>ServiceAccounts</code> avec de grands privilèges.) <br><br>  En outre, différents <i>déploiements</i> auront des besoins différents en termes d'accès à l'API, il est donc raisonnable que chaque <i>déploiement</i> ait des <code>ServiceAccounts</code> différents. <br><br>  Gardant cela à l'esprit, voyons quelle configuration RBAC est correcte pour <i>le</i> cas <i>de déploiement</i> avec RabbitMQ. <br><br>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation du plugin</a> et <a href="">son code source,</a> vous pouvez voir qu'il demande une liste de <i>Endpoints</i> à l'API Kubernetes.  C'est ainsi que les membres restants du cluster RabbitMQ sont détectés.  Par conséquent, le graphique Bitnami RabbitMQ crée: <br><br><ul><li>  <a href=""><b>ServiceAccount</b></a> pour les foyers avec RabbitMQ: <br><br><pre> <code class="plaintext hljs">{{- if .Values.rbacEnabled }} apiVersion: v1 kind: ServiceAccount metadata: name: {{ template "rabbitmq.fullname" . }} labels: app: {{ template "rabbitmq.name" . }} chart: {{ template "rabbitmq.chart" . }} release: "{{ .Release.Name }}" heritage: "{{ .Release.Service }}" {{- end }}</code> </pre> </li><li>  <a href=""><b>Rôle</b></a> (nous supposons que l'intégralité du cluster RabbitMQ est déployé dans un seul espace de noms), permettant au verbe <i>obtenir</i> pour la ressource <i>Endpoint</i> : <br><br><pre> <code class="plaintext hljs">{{- if .Values.rbacEnabled }} kind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: name: {{ template "rabbitmq.fullname" . }}-endpoint-reader labels: app: {{ template "rabbitmq.name" . }} chart: {{ template "rabbitmq.chart" . }} release: "{{ .Release.Name }}" heritage: "{{ .Release.Service }}" rules: - apiGroups: [""] resources: ["endpoints"] verbs: ["get"] {{- end }}</code> </pre> </li><li>  <a href=""><b>RoleBinding</b></a> connectant un <code>ServiceAccount</code> à un rôle: <br><br><pre> <code class="plaintext hljs">{{- if .Values.rbacEnabled }} kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: {{ template "rabbitmq.fullname" . }}-endpoint-reader labels: app: {{ template "rabbitmq.name" . }} chart: {{ template "rabbitmq.chart" . }} release: "{{ .Release.Name }}" heritage: "{{ .Release.Service }}" subjects: - kind: ServiceAccount name: {{ template "rabbitmq.fullname" . }} roleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: {{ template "rabbitmq.fullname" . }}-endpoint-reader {{- end }}</code> </pre> </li></ul><br><img src="https://habrastorage.org/webt/lx/uw/vg/lxuwvgvlcluwmoln2mx0wgkxdyk.png"><br><br>  Le diagramme montre que nous avons autorisé les processus en cours d'exécution dans les pods RabbitMQ à effectuer des opérations d' <i>obtention</i> sur les objets <i>Endpoint</i> .  Il s'agit de l'ensemble minimal d'opérations requis pour que tout fonctionne.  Dans le même temps, nous savons que le graphique déployé est sûr et n'effectuera pas d'actions indésirables dans le cluster Kubernetes. <br><br><h2>  Réflexions finales </h2><br>  Pour travailler avec Kubernetes en production, les stratégies RBAC ne sont pas facultatives.  Ils ne peuvent pas être considérés comme un ensemble d'objets API que seuls les administrateurs doivent connaître.  Les développeurs en ont réellement besoin pour déployer des applications sécurisées et tirer pleinement parti du potentiel offert par l'API Kubernetes pour les applications natives du cloud.  Plus d'informations sur RBAC peuvent être trouvées à ces liens: <br><br><ul><li>  Documentation Bitnami: « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Configurer RBAC dans votre cluster Kubernetes</a> »; </li><li>  Documentation de Kubernetes: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation de l'autorisation RBAC</a> ". </li></ul><br><h2>  PS du traducteur </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">11 façons de (ne pas) devenir une victime du piratage Kubernetes</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Que se passe-t-il dans Kubernetes au démarrage de kubectl?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment fonctionne le planificateur Kubernetes?"</a>  "; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dans les coulisses du réseau à Kubernetes</a> »; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Notre expérience avec Kubernetes dans les petits projets</a> " <i>(reportage vidéo, qui comprend une introduction au dispositif technique Kubernetes)</i> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422801/">https://habr.com/ru/post/fr422801/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422791/index.html">Comment ne PAS apprendre l'anglais: erreurs courantes</a></li>
<li><a href="../fr422793/index.html">Conférence DEFCON 22. Andrew "Zoz" Brooks. Ne le gâchez pas! 2e partie</a></li>
<li><a href="../fr422795/index.html">Technologie et affaires: un nouveau modèle de coopération avec Zyxel en Russie</a></li>
<li><a href="../fr422797/index.html">Comment nous avons fabriqué un enregistreur vidéo cloud de petite taille à partir d'une caméra IP standard</a></li>
<li><a href="../fr422799/index.html">Comment Microsoft a caché tout le serveur et comment le trouver</a></li>
<li><a href="../fr422803/index.html">Calculateur de coût de stockage, ou comment nous avons ouvert la "boîte noire"</a></li>
<li><a href="../fr422805/index.html">Désabonnement rapide aux listes de diffusion dans Mail.Ru Mail</a></li>
<li><a href="../fr422807/index.html">AliceVision: photogrammétrie en ligne de commande</a></li>
<li><a href="../fr422809/index.html">Mon adresse n'est pas une maison ou une rue: quel sera l'adressage du 21ème siècle</a></li>
<li><a href="../fr422811/index.html">Knocking on Heaven: gérer les achats dans le cloud avec SAP Ariba</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>