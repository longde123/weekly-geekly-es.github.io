<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔮 👨🏻‍💼 🌗 Eclair - perpustakaan logging deklaratif Spring Java 🍞 🚻 🤛🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada banyak pertanyaan tentang pekerjaan layanan pada tahap pengembangan, pengujian dan dukungan, dan semuanya pada pandangan pertama tidak seperti: "A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eclair - perpustakaan logging deklaratif Spring Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/412871/"><img src="https://habrastorage.org/webt/c5/hp/zh/c5hpzhb2lfd56lwayott-mqlusi.jpeg"><br><br>  Ada banyak pertanyaan tentang pekerjaan layanan pada tahap pengembangan, pengujian dan dukungan, dan semuanya pada pandangan pertama tidak seperti: <i>"Apa yang terjadi?"</i>  , <i>"Apakah ada permintaan?"</i>  , <i>"Apa format tanggal?"</i>  , <i>"Mengapa layanan ini tidak merespons?"</i>  dll. <br><br>  Log yang dikompilasi dengan benar akan dapat menjawab secara terperinci ini dan banyak pertanyaan lainnya secara mandiri tanpa partisipasi pengembang.  Untuk mencapai tujuan yang menggiurkan ini, lahirlah perpustakaan Eclair, yang dirancang untuk terlibat dalam dialog dengan semua peserta dalam proses tanpa menarik terlalu banyak selimut. <br><br>  Tentang selimut dan fitur solusinya - di bawah ini. <br><a name="habracut"></a><br><h2>  Apa masalah logging </h2><br><blockquote>  Jika Anda tidak terlalu tertarik untuk memahami tempat, Anda dapat segera melanjutkan ke deskripsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">solusi</a> kami. </blockquote><br><ul><li>  Log aplikasi adalah alibinya. <br>  Paling sering, hanya dia yang bisa membuktikan keberhasilan aplikasi.  Tidak ada keadaan dalam layanan mikro, sistem yang berdekatan bersifat mobile dan rewel.  “Ulangi”, “buat ulang”, “periksa ulang” - semua ini sulit dan / atau tidak mungkin.  Log harus cukup informatif untuk menjawab pertanyaan: <i>"Apa yang terjadi?"</i> Setiap saat <i>.</i>  .  Log harus jelas untuk semua orang: pengembang, penguji, kadang-kadang analis, kadang-kadang administrator, kadang-kadang garis dukungan pertama - apa pun terjadi. </li><li>  Layanan microsoft adalah tentang multithreading. <br>  Permintaan yang datang ke layanan (atau data yang diminta oleh layanan) paling sering diproses oleh beberapa utas.  Log semua utas biasanya dicampur.  Apakah Anda ingin membedakan antara utas paralel dan membedakan antara utas "berurutan"?  Aliran yang sama digunakan kembali untuk pemrosesan permintaan secara berurutan, berulang kali mengeksekusi logikanya sendiri untuk set data yang berbeda.  "Urutan" ini mengalir dari bidang lain, tetapi batas-batasnya harus jelas bagi pembaca. </li><li>  Log harus menyimpan format data asli. <br>  Jika pada kenyataannya layanan dipertukarkan oleh XML, maka log yang sesuai harus menyimpan XML.  Itu tidak selalu kompak dan tidak selalu indah (tapi nyaman).  Lebih mudah untuk melihat kesuksesan, lebih mudah untuk menganalisis kegagalan.  Dalam beberapa kasus, log dapat digunakan untuk memutar atau memproses ulang permintaan secara manual. </li><li>  Bagian dari data dalam log membutuhkan hubungan khusus. <br>  Data yang masuk (permintaan), data yang keluar (jawaban), permintaan ke sistem pihak ketiga dan tanggapan dari mereka sering diminta untuk disimpan secara terpisah.  Mereka tunduk pada persyaratan khusus: berdasarkan umur simpan atau keandalan.  Selain itu, data ini dapat memiliki jumlah yang mengesankan dibandingkan dengan garis log yang khas. </li><li>  Bagian dari data bukan untuk log. <br>  Berikut ini biasanya dikeluarkan dari log reguler: data biner (byte array, base64, ..), data pribadi klien / mitra / individu lain dan badan hukum.  Itu selalu merupakan cerita individu, tetapi sistematis dan tidak cocok untuk kontrol manual. </li></ul><br><h2>  Kenapa tidak tangan </h2><br>  Ambil <code>org.slf4j.Logger</code> ( <code>org.slf4j.Logger</code> ke sana dengan Appenders dari jenis apa pun) dan tulis semua yang diperlukan untuk log tersebut.  Pintu masuk ke metode utama, keluar, jika perlu, mencerminkan kesalahan yang tertangkap, beberapa data.  Apakah ini perlu?  Ya tapi <br><br><ul><li>  Jumlah kode bertambah tidak masuk akal (luar biasa).  Pada awalnya, ini tidak terlalu mencolok, jika Anda hanya mencatat paling dasar (dukungan sukses, omong-omong, dengan pendekatan ini). </li><li>  Memanggil logger dengan tangan Anda dengan cepat menjadi kemalasan.  Mendeklarasikan bidang <code>static</code> dengan logger terlalu malas (well, Lombok bisa melakukan ini untuk kita).  Kami pengembang malas.  Dan kita mendengarkan kemalasan kita, ini kemalasan yang mulia: ini terus mengubah dunia menjadi lebih baik. </li><li>  Layanan Microsoft tidak bagus di semua sisi.  Ya, mereka kecil dan cantik, tetapi ada sisi lain: ada banyak!  Satu aplikasi dari awal hingga akhir sering ditulis oleh satu pengembang.  Warisan tidak tampak di depan matanya.  Senang, tidak dibebani dengan aturan yang dipaksakan, pengembang menganggap itu tugas untuk menemukan format lognya sendiri, prinsipnya dan aturannya sendiri.  Kemudian, secara brilian mengimplementasikan penemuan ini.  Setiap kelas berbeda.  Apakah ini masalah?  Kolosal. </li><li>  Refactoring akan memecah log Anda.  Bahkan Ide Mahakuasa tidak akan menyelamatkannya.  Memperbarui log sama mustahilnya dengan memperbarui Javadoc.  Pada saat yang sama, setidaknya Javadoc hanya dibaca oleh pengembang (tidak, tidak ada yang membaca), tetapi audiens log jauh lebih luas dan tim pengembangan tidak terbatas. </li><li>  MDC (Konteks Diagnostik yang Dipetakan) adalah bagian integral dari aplikasi multi-utas.  Pengisian MDC secara manual membutuhkan pembersihan tepat waktu di akhir pekerjaan di sungai.  Jika tidak, Anda berisiko mengikat salah satu <code>ThreadLocal</code> ke data yang tidak terkait.  Tangan dan mata untuk mengendalikan ini, saya berani katakan, tidak mungkin. </li></ul><br>  Dan inilah cara kami memecahkan masalah ini dalam aplikasi kami. <br><a name="eclair-decision"></a><br><h2>  Apa itu Eclair dan apa yang bisa dilakukannya </h2><br>  Eclair adalah alat yang menyederhanakan penulisan kode yang dicatat.  Ini membantu untuk mengumpulkan meta-informasi yang diperlukan tentang kode sumber, mengaitkannya dengan data yang terbang dalam aplikasi dalam runtime dan mengirimkannya ke repositori log yang biasa, sambil menghasilkan kode minimum. <br><br>  Tujuan utamanya adalah membuat log dapat dipahami oleh semua peserta dalam proses pengembangan.  Oleh karena itu, kenyamanan menulis kode, manfaat Eclair tidak berakhir, tetapi hanya dimulai. <br><br>  Eclair mencatat metode dan parameter yang dijelaskan: <br><br><ul><li>  mencatat entri / keluar metode dari metode / pengecualian / argumen / nilai yang dikembalikan oleh metode </li><li>  memfilter pengecualian untuk mencatatnya secara spesifik ke tipe: <i>hanya jika diperlukan</i> </li><li>  memvariasikan "detail" log, berdasarkan pada pengaturan aplikasi untuk lokasi saat ini: <i>misalnya, dalam kasus yang paling terperinci ia mencetak nilai argumen (semua atau beberapa), dalam versi terpendek - hanya fakta memasukkan metode</i> </li><li>  mencetak data sebagai JSON / XML / dalam format lain (siap bekerja dengan Jackson, JAXB di luar kotak): <i>memahami format mana yang paling disukai untuk parameter tertentu</i> </li><li>  memahami SpEL (Spring Expression Language) untuk instalasi deklaratif dan pembersihan otomatis MDC </li><li>  menulis ke N logger, "logger" dalam pemahaman Eclair adalah kacang dalam konteks yang mengimplementasikan antarmuka <code>EclairLogger</code> : Anda dapat <i>menentukan logger yang harus memproses anotasi berdasarkan nama, dengan alias, atau secara default</i> </li><li>  memberi tahu programmer tentang beberapa kesalahan dalam menggunakan anotasi: <i>misalnya, Eclair tahu itu berfungsi pada proksi dinamis (dengan semua fitur berikutnya), oleh karena itu, dapat menyarankan bahwa anotasi pada metode <code>private</code> tidak akan pernah berfungsi</i> </li><li>  menerima penjelasan meta (seperti Spring menyebutnya): <i>Anda dapat menentukan anotasi untuk masuk, menggunakan beberapa anotasi dasar - untuk mengurangi kode</i> </li><li>  mampu menutupi "sensitif" data saat mencetak: di <i>luar kotak XPath-shielding XML</i> </li><li>  menulis log dalam mode "manual", mendefinisikan penyerang dan "memperluas" argumen yang mengimplementasikan <code>Supplier</code> : <i>memberikan kesempatan untuk menginisialisasi argumen "malas"</i> </li></ul><br><h2>  Bagaimana menghubungkan Eclair </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber diterbitkan di GitHub di</a> bawah lisensi Apache 2.0. <br><br>  Untuk terhubung, Anda memerlukan Java 8, Maven, dan Spring Boot 1.5+.  Artifact yang diselenggarakan oleh Maven Central Repository: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>ru.tinkoff<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>eclair-spring-boot-starter<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>0.8.3<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Starter berisi implementasi standar <code>EclairLogger</code> , yang menggunakan sistem logging yang diinisialisasi oleh Spring Boot dengan beberapa set pengaturan yang terverifikasi. <br><br><h2>  Contohnya </h2><br>  Berikut adalah beberapa contoh penggunaan perpustakaan umum.  Pertama, sebuah fragmen kode diberikan, kemudian log yang sesuai, tergantung pada ketersediaan tingkat logging tertentu.  Serangkaian contoh yang lebih lengkap dapat ditemukan di Wiki proyek di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh</a> . <br><br><h3>  Contoh paling sederhana </h3><br>  Level standarnya adalah DEBUG. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><table><tbody><tr><th>  Jika level tersedia </th><th>  ... maka log akan seperti ini </th></tr><tr><td> <code>TRACE <br> DEBUG</code> </td> <td> <code>DEBUG [] rteeExample.simple &gt; <br> DEBUG [] rteeExample.simple &lt;</code> </td> </tr><tr><td> <code>INFO <br> WARN <br> ERROR</code> </td> <td> <code>-</code> </td> </tr></tbody></table><h3>  Detail log tergantung pada level logging yang tersedia. </h3><br>  Level logging yang tersedia di lokasi saat ini memengaruhi detail log.  Semakin rendah level yang tersedia (yaitu, semakin dekat ke TRACE), semakin detail log. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span>(INFO) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verbose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s, Integer i, Double d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre><table><tbody><tr><th>  Level </th><th>  Log </th></tr><tr><td> <code>TRACE <br> DEBUG</code> </td> <td> <code>INFO [] rteeExample.verbose &gt; s="s", i=4, d=5.6 <br> INFO [] rteeExample.verbose &lt; false</code> </td> </tr><tr><td> <code>INFO</code> </td> <td> <code>INFO [] rteeExample.verbose &gt; <br> INFO [] rteeExample.verbose &lt;</code> </td> </tr><tr><td> <code>WARN <br> ERROR</code> </td> <td> <code>-</code> </td> </tr></tbody></table><h3>  Menyetel penebangan pengecualian </h3><br>  Jenis pengecualian yang dicatat dapat difilter.  Pengecualian yang dipilih dan keturunan mereka akan dijanjikan.  Dalam contoh ini, <code>NullPointerException</code> akan dicatat di tingkat WARN, <code>Exception</code> di tingkat ERROR (secara default), dan <code>Error</code> tidak akan dicatat sama sekali (karena <code>Error</code> tidak termasuk dalam filter anotasi pertama <code>@Log.error</code> dan secara eksplisit dikecualikan dari filter anotasi kedua). <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span>.error(level = WARN, ofType = {NullPointerException.class, IndexOutOfBoundsException.class}) <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>.error(exclude = Error.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filterErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable throwable)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> throwable; } <span class="hljs-comment"><span class="hljs-comment">//       filterErrors(new NullPointerException()); filterErrors(new Exception()); filterErrors(new Error());</span></span></code> </pre><table><tbody><tr><th>  Level </th><th>  Log </th></tr><tr><td> <code>TRACE <br> DEBUG <br> INFO <br> WARN</code> </td> <td> <code>WARN  [] rteeExample.filterErrors ! java.lang.NullPointerException <br> java.lang.NullPointerException: null <br> at rteeExampleTest.filterErrors(ExampleTest.java:0) <br> .. <br> ERROR [] rteeExample.filterErrors ! java.lang.Exception <br> java.lang.Exception: null <br> at rteeExampleTest.filterErrors(ExampleTest.java:0) <br> .. <br></code> </td></tr><tr><td> <code>ERROR</code> </td> <td> <code>ERROR [] rteeExample.filterErrors ! java.lang.Exception <br> java.lang.Exception: null <br> at rteeExampleTest.filterErrors(ExampleTest.java:0) <br> ..</code> </td> </tr></tbody></table><h3>  Tetapkan setiap parameter secara terpisah </h3><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span>.in(INFO) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parameterLevels</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Log(INFO)</span></span></span><span class="hljs-function"> Double d, @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DEBUG)</span></span></span><span class="hljs-function"> String s, @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TRACE)</span></span></span><span class="hljs-function"> Integer i) </span></span>{ }</code> </pre><table><tbody><tr><th>  Level </th><th>  Log </th></tr><tr><td> <code>TRACE</code> </td> <td> <code>INFO [] rteeExample.parameterLevels &gt; d=9.4, s="v", i=7</code> </td> </tr><tr><td> <code>DEBUG</code> </td> <td> <code>INFO [] rteeExample.parameterLevels &gt; d=9.4, s="v"</code> </td> </tr><tr><td> <code>INFO</code> </td> <td> <code>INFO [] rteeExample.parameterLevels &gt; 9.4</code> </td> </tr><tr><td> <code>WARN <br> ERROR</code> </td> <td> <code>-</code> </td> </tr></tbody></table><h3>  Pilih dan sesuaikan format cetakan </h3><br>  "Printer" yang bertanggung jawab untuk format cetak dapat dikonfigurasi oleh pra dan pasca prosesor.  Dalam contoh di atas, <code>maskJaxb2Printer</code> dikonfigurasi sehingga elemen yang cocok dengan ekspresi XPath <code>"//s"</code> -masking menggunakan <code>"********"</code> .  Pada saat yang sama, <code>jacksonPrinter</code> mencetak <code>Dto</code> "apa adanya". <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span>.out(printer = <span class="hljs-string"><span class="hljs-string">"maskJaxb2Printer"</span></span>) <span class="hljs-function"><span class="hljs-function">Dto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Log(printer = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"maskJaxb2Printer"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Dto xml, @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(printer = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"jacksonPrinter"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Dto json, Integer i) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xml; }</code> </pre><table><tbody><tr><th>  Level </th><th>  Log </th></tr><tr><td> <code>TRACE <br> DEBUG</code> </td> <td> <code>DEBUG [] rteeExample.printers &gt; <br> xml=&lt;dto&gt;&lt;i&gt;5&lt;/i&gt;&lt;s&gt;********&lt;/s&gt;&lt;/dto&gt;, json={"i":5,"s":"password"} <br> DEBUG [] rteeExample.printers &lt; <br> &lt;dto&gt;&lt;i&gt;5&lt;/i&gt;&lt;s&gt;********&lt;/s&gt;&lt;/dto&gt;</code> </td> </tr><tr><td> <code>INFO <br> WARN <br> ERROR</code> </td> <td> <code>-</code> </td> </tr></tbody></table><h3>  Banyak penebang dalam konteks </h3><br>  Metode ini dicatat menggunakan beberapa logger pada saat yang sama: oleh logger default (dijelaskan menggunakan <code>@Primary</code> ) dan auditLogger <code>auditLogger</code> .  Anda dapat menentukan beberapa penebang jika Anda ingin memisahkan peristiwa yang dicatat bukan hanya berdasarkan level (TRACE - ERROR), tetapi juga mengirimkannya ke penyimpanan yang berbeda.  Sebagai contoh, logger utama dapat menulis log ke file pada disk menggunakan slf4j, dan <code>auditLogger</code> dapat menulis irisan data khusus ke penyimpanan yang sangat baik (misalnya, dalam Kafka) dalam format spesifiknya sendiri. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span> <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>(logger = <span class="hljs-string"><span class="hljs-string">"auditLogger"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">twoLoggers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br><h3>  Manajemen MDC </h3><br>  MDC yang diatur menggunakan anotasi secara otomatis dihapus setelah keluar dari metode yang dianotasi.  Nilai catatan MDC dapat dihitung secara dinamis menggunakan SpEL.  Berikut ini adalah contoh: string statis yang dirasakan oleh konstanta, mengevaluasi ekspresi <code>1 + 1</code> , memanggil <code>jacksonPrinter</code> , memanggil metode <code>static</code> <code>randomUUID</code> . <br>  MDC dengan atribut <code>global = true</code> tidak dihapus setelah keluar dari metode: seperti yang Anda lihat, satu-satunya catatan yang tersisa di MDC hingga akhir log adalah <code>sum</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ self.mdc(); } <span class="hljs-meta"><span class="hljs-meta">@Mdc</span></span>(key = <span class="hljs-string"><span class="hljs-string">"static"</span></span>, value = <span class="hljs-string"><span class="hljs-string">"string"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Mdc</span></span>(key = <span class="hljs-string"><span class="hljs-string">"sum"</span></span>, value = <span class="hljs-string"><span class="hljs-string">"1 + 1"</span></span>, global = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Mdc</span></span>(key = <span class="hljs-string"><span class="hljs-string">"beanReference"</span></span>, value = <span class="hljs-string"><span class="hljs-string">"@jacksonPrinter.print(new ru.tinkoff.eclair.example.Dto())"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Mdc</span></span>(key = <span class="hljs-string"><span class="hljs-string">"staticMethod"</span></span>, value = <span class="hljs-string"><span class="hljs-string">"T(java.util.UUID).randomUUID()"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Log</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mdc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ self.inner(); } <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>.<span class="hljs-function"><span class="hljs-function">in </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br>  Log saat menjalankan kode di atas: <br> <code>DEBUG [] rteeExample.outer &gt; <br> DEBUG [beanReference={"i":0,"s":null}, sum=2, static=string, staticMethod=01234567-89ab-cdef-ghij-klmnopqrstuv] rteeExample.mdc &gt; <br> DEBUG [beanReference={"i":0,"s":null}, sum=2, static=string, staticMethod=01234567-89ab-cdef-ghij-klmnopqrstuv] rteeExample.inner &gt; <br> DEBUG [beanReference={"i":0,"s":null}, sum=2, static=string, staticMethod=01234567-89ab-cdef-ghij-klmnopqrstuv] rteeExample.mdc &lt; <br> DEBUG [sum=2] rteeExample.outer &lt;</code> <br> <br><h3>  Instalasi MDC Berbasis Parameter </h3><br>  Jika Anda menentukan MDC menggunakan anotasi pada parameter, maka parameter anotasi tersedia sebagai objek root dari konteks evaluasi.  Di sini <code>"s"</code> adalah bidang <code>Dto</code> kelas dengan tipe <code>String</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span>.<span class="hljs-function"><span class="hljs-function">in </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mdcByArgument</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Mdc(key = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"dto"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, value = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"#this"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mdc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"length"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, value = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"s.length()"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Dto dto) </span></span>{ }</code> </pre><br>  Log saat menjalankan kode di atas: <br> <code>DEBUG [length=8, dto=Dto{i=12, s='password'}] rteeExample.mdcByArgument &gt; dto=Dto{i=12, s='password'}</code> <br> <br><h3>  Pencatatan manual </h3><br>  Untuk "manual" logging sudah cukup untuk mengimplementasikan implementasi <code>ManualLogger</code> .  Argumen yang berlalu yang mengimplementasikan <code>Supplier</code> antarmuka akan "diperluas" hanya jika perlu. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ManualLogger logger; <span class="hljs-meta"><span class="hljs-meta">@Log</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ logger.info(<span class="hljs-string"><span class="hljs-string">"Eager logging: {}"</span></span>, Math.PI); logger.debug(<span class="hljs-string"><span class="hljs-string">"Lazy logging: {}"</span></span>, (Supplier) () -&gt; Math.PI); }</code> </pre><table><tbody><tr><th>  Level </th><th>  Log </th></tr><tr><td> <code>TRACE <br> DEBUG</code> </td> <td> <code>DEBUG [] rteeExample.manual &gt; <br> INFO  [] rteeExample.manual - Eager logging: 3.141592653589793 <br> DEBUG [] rteeExample.manual - Lazy logging: 3.141592653589793 <br> DEBUG [] rteeExample.manual &lt;</code> </td> </tr><tr><td> <code>INFO</code> </td> <td> <code>INFO [] rteeExample.manual - Eager logging: 3.141592653589793</code> </td> </tr><tr><td> <code>WARN <br> ERROR</code> </td> <td> <code>-</code> </td> </tr></tbody></table><h2>  Apa yang tidak dilakukan Eclair </h2><br>  Eclair tidak tahu di mana Anda akan menyimpan log Anda, untuk berapa lama dan detail.  Eclair tidak tahu bagaimana Anda berencana menggunakan log Anda.  Eclair dengan hati-hati mengekstrak dari aplikasi Anda semua informasi yang Anda butuhkan dan mengarahkannya ke penyimpanan yang Anda konfigurasi. <br><br>  Contoh konfigurasi <code>EclairLogger</code> mengarahkan log ke Logback logger dengan Appender tertentu: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> EclairLogger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eclairLogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LoggerFacadeFactory factory = loggerName -&gt; { ch.qos.logback.classic.LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory(); ch.qos.logback.classic.Logger logger = context.getLogger(loggerName); <span class="hljs-comment"><span class="hljs-comment">// Appender&lt;ILoggingEvent&gt; appender = ? // logger.addAppender(appender); return new Slf4JLoggerFacade(logger); }; return new SimpleLogger(factory, LoggingSystem.get(SimpleLogger.class.getClassLoader())); }</span></span></code> </pre><br><h2>  Solusi ini bukan untuk semua orang. </h2><br>  Sebelum Anda mulai menggunakan Eclair sebagai alat utama untuk log, Anda harus membiasakan diri dengan sejumlah fitur dari solusi ini.  "Fitur" ini disebabkan oleh fakta bahwa Eclair didasarkan pada mekanisme proxy standar untuk Spring. <br><br>  - Kecepatan eksekusi kode yang dibungkus dengan proxy berikutnya tidak signifikan, tetapi akan turun.  Bagi kami, kerugian ini jarang signifikan.  Jika muncul pertanyaan untuk mengurangi waktu tunggu, ada banyak langkah pengoptimalan yang efektif.  Menolak log informatif yang nyaman dapat dianggap sebagai salah satu langkah, tetapi tidak pada awalnya. <br><br>  - StackTrace "mengasapi" sedikit lagi.  Jika Anda tidak terbiasa dengan tumpukan panjang proxy Spring, ini bisa menjadi gangguan bagi Anda.  Untuk alasan yang sama jelasnya, debugging kelas proksi akan sulit. <br><br>  - <b>Tidak setiap kelas dan setiap metode dapat diproksi</b> : metode <code>private</code> tidak dapat diproksi, Anda akan perlu sendiri untuk mencatat rantai metode dalam satu kacang, Anda tidak dapat membuat proksi apa pun yang bukan kacang, dll. <br><br><h2>  Pada akhirnya </h2><br>  Sangat jelas bahwa alat ini, seperti yang lain, harus dapat digunakan untuk mendapatkan manfaat darinya.  Dan materi ini hanya menerangi sisi di mana kami memutuskan untuk mencari solusi yang sempurna. <br><br>  Kritik, pemikiran, petunjuk, tautan - Saya dengan hangat menyambut partisipasi Anda dalam kehidupan proyek!  Saya akan senang jika Anda merasa Eclair berguna untuk proyek Anda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412871/">https://habr.com/ru/post/id412871/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412861/index.html">Membuat peta jalur pengguna untuk boneka</a></li>
<li><a href="../id412863/index.html">Dialogflower - Google Dialogflow untuk Yandex Alice</a></li>
<li><a href="../id412865/index.html">Cara memotret kamera Motion Eye di Sony Xperia XZ2</a></li>
<li><a href="../id412867/index.html">Cara mengompilasi file DOS COM oleh kompiler GCC</a></li>
<li><a href="../id412869/index.html">Wawancara dengan seorang ahli di bidang teknik jaringan dan kedokteran regeneratif, Profesor Tal Tal Dvir</a></li>
<li><a href="../id412873/index.html">Hard drive dimanjakan oleh suara dari speaker laptop biasa</a></li>
<li><a href="../id412877/index.html">Ruthenium (Ru) - elemen keempat dengan sifat feromagnetik pada suhu kamar</a></li>
<li><a href="../id412879/index.html">Edisi # 24: Pelatihan TI - masalah saat ini dan tantangan dari perusahaan terkemuka</a></li>
<li><a href="../id412881/index.html">Björn Straustrup: Masalah dengan pemrograman</a></li>
<li><a href="../id412885/index.html">Ilmu patologis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>