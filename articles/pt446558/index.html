<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçä ü§° üë¥ Estruturas de dados ex√≥ticas: Merkle modificado Patricia Trie üë©üèΩ‚Äçüéì üë®üèø‚Äçüéì üèåÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Que tipo de diabo devo lembrar de cor todos esses malditos algoritmos e estruturas de dados?" 


 Sobre isso, resume-se aos coment√°rios da maioria do...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estruturas de dados ex√≥ticas: Merkle modificado Patricia Trie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446558/"><p>  <em>"Que tipo de diabo devo lembrar de cor todos esses malditos algoritmos e estruturas de dados?"</em> </p><br><p>  Sobre isso, resume-se aos coment√°rios da maioria dos artigos sobre a passagem de entrevistas t√©cnicas.  A tese principal, como regra, √© que tudo o que √© usado de uma maneira ou de outra j√° foi implementado dez vezes e √© mais improv√°vel que esse programador comum precise lidar com isso.  Bem, at√© certo ponto isso √© verdade.  Mas, como se viu, nem tudo foi implementado, e eu, infelizmente (ou felizmente?), Ainda tive que criar uma estrutura de dados. </p><br><p>  Merkle modificado misterioso Patricia Trie. </p><br><p>  Como n√£o h√° informa√ß√µes sobre essa √°rvore no habr e no meio - um pouco mais, quero lhe dizer que tipo de animal √© e com que √© comido. </p><br><p><img src="https://habrastorage.org/webt/mc/ar/6q/mcar6qnrhs1vh6noextlta_dpfo.png" alt="KDPV"></p><a name="habracut"></a><br><h2 id="chto-eto">  O que √© isso </h2><br><p>  <em>Isen√ß√£o de responsabilidade: a principal fonte de informa√ß√µes para implementa√ß√£o para mim foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o Livro Amarelo</a> , bem como os c√≥digos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">-</a> fonte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parity-ethereum</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">go-ethereum</a> .</em>  <em>Havia um m√≠nimo de informa√ß√µes te√≥ricas sobre a justificativa de certas decis√µes; portanto, todas as conclus√µes sobre os motivos para tomar certas decis√µes s√£o minhas.</em>  <em>Caso eu esteja enganado em alguma coisa - terei prazer em corrigir os coment√°rios.</em> </p><br><p>  <em>Uma √°rvore</em> √© uma estrutura de dados que √© um gr√°fico ac√≠clico conectado.  Tudo √© simples aqui, todos est√£o familiarizados com isso. </p><br><p>  <em>A √°rvore de prefixos</em> √© a √°rvore raiz na qual os pares de valores-chave podem ser armazenados devido ao fato de os n√≥s serem divididos em dois tipos: aqueles que cont√™m parte do caminho (prefixo) e os n√≥s folha que cont√™m o valor armazenado.  Um valor est√° presente em uma √°rvore se, e somente se, usando a chave, pudermos percorrer todo o caminho desde a raiz da √°rvore e encontrar um n√≥ com um valor no final. </p><br><p>  <em>A √°rvore PATRICIA</em> √© uma √°rvore de prefixo na qual os prefixos s√£o bin√°rios - ou seja, cada n√≥-chave armazena informa√ß√µes sobre um bit. </p><br><p>  <em>A</em> √°rvore <em>Merkle</em> √© uma √°rvore de hash constru√≠da sobre algum tipo de cadeia de dados, agregando esses mesmos hashes em um (raiz), armazenando informa√ß√µes sobre o estado de todos os blocos de dados.  Ou seja, o hash raiz √© um tipo de "assinatura digital" do estado da cadeia de blocos.  Essa coisa √© usada ativamente na blockchain, e mais sobre ela pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p><img src="https://habrastorage.org/webt/ui/x4/nr/uix4nregm5i_dcxm5cgxsv27hjg.png" alt="Trabalho duro √© ..."></p><br><p>  Total: Merkle modificado Patricia Trie (daqui em diante MPT) √© uma √°rvore de hash que armazena pares de valores-chave, enquanto as chaves s√£o apresentadas em formato bin√°rio.  E o que exatamente √© "Modificado", descobriremos um pouco mais tarde quando discutirmos a implementa√ß√£o. </p><br><h2 id="zachem-eto">  Por que isso? </h2><br><p>  O MPT √© usado no projeto Ethereum para armazenar dados sobre contas, transa√ß√µes, resultados de sua execu√ß√£o e outros dados necess√°rios para o funcionamento do sistema. <br>  Ao contr√°rio do Bitcoin, no qual o estado est√° impl√≠cito e √© calculado por cada n√≥ de forma independente, o saldo de cada conta (assim como os dados a ela associados) s√£o armazenados diretamente no blockchain no ar.  Al√©m disso, a localiza√ß√£o e a imutabilidade dos dados devem ser fornecidas criptograficamente - poucas pessoas usar√£o criptomoeda na qual o saldo de uma conta aleat√≥ria pode mudar sem raz√µes objetivas. </p><br><p>  O principal problema enfrentado pelos desenvolvedores do Ethereum √© a cria√ß√£o de uma estrutura de dados que pode efetivamente armazenar pares de valores-chave e, ao mesmo tempo, fornecer verifica√ß√£o dos dados armazenados.  Ent√£o MPT apareceu. </p><br><h2 id="kak-eto">  Como √© isso? </h2><br><p>  MPT √© um prefixo PATRICIA em que as chaves s√£o seq√º√™ncias de bytes. </p><br><p>  As arestas nesta √°rvore s√£o sequ√™ncias de mordidelas (meio bytes).  Assim, um n√≥ pode ter at√© dezesseis descendentes (correspondendo a ramifica√ß√µes de 0x0 a 0xF). </p><br><p>  Os n√≥s s√£o divididos em 3 tipos: </p><br><ul><li>  N√≥ da filial.  O n√≥ usado para ramifica√ß√£o.  Cont√©m at√© 1 a 16 links para n√≥s filho.  Tamb√©m pode conter um valor. </li><li>  N√≥ de extens√£o.  Um n√≥ auxiliar que armazena parte do caminho comum a v√°rios n√≥s filhos, al√©m de um link para o n√≥ da filial, que fica abaixo. </li><li>  N√≥ folha.  Um n√≥ que cont√©m parte do caminho e valor armazenado.  √â o fim da cadeia. </li></ul><br><p> Como j√° mencionado, o MPT √© constru√≠do sobre outro reposit√≥rio kv, que armazena n√≥s na forma de "link" =&gt; "n√≥ codificado <code>RLP</code> ". </p><br><p>  <em>E aqui chegamos a um novo conceito: RLP.</em>  <em>Em resumo, esse √© um m√©todo de codifica√ß√£o de dados que representa listas ou sequ√™ncias de bytes.</em>  <em>Exemplo: <code>[ "cat", "dog" ] = [ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]</code> .</em>  <em>N√£o entrarei em detalhes em particular, e na implementa√ß√£o utilizo uma biblioteca pronta, pois a cobertura deste t√≥pico tamb√©m inflar√° um artigo j√° bastante grande.</em>  <em>Se voc√™ ainda estiver interessado, pode ler mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .</em>  <em>N√≥s nos limitamos ao fato de podermos codificar dados no <code>RLP</code> e decodific√°-los de volta.</em> </p><br><p>  Um link para um n√≥ √© definido da seguinte maneira: se o comprimento do n√≥ codificado <code>RLP</code> for 32 ou mais bytes, o link ser√° um hash <code>keccak</code> da representa√ß√£o <code>RLP</code> do n√≥.  Se o comprimento for menor que 32 bytes, o link ser√° a representa√ß√£o <code>RLP</code> do pr√≥prio n√≥. </p><br><p>  Obviamente, no segundo caso, voc√™ n√£o precisa salvar o n√≥ no banco de dados, porque  ele ser√° salvo inteiramente dentro do n√≥ pai. </p><br><p><img src="https://habrastorage.org/webt/rs/vz/0j/rsvz0j-fmp0f3p35phzmkxzbzlw.png" alt="N√≥s s√£o diferentes"></p><br><p>  A combina√ß√£o de tr√™s tipos de n√≥s permite que voc√™ armazene dados de maneira eficaz no caso de poucas chaves (a maioria dos caminhos ser√° armazenada nos n√≥s de extens√£o e folha, e haver√° poucos n√≥s de ramifica√ß√£o) e no caso de muitos n√≥s (os caminhos n√£o ser√£o armazenados explicitamente, mas eles "se reunir√£o" durante a passagem pelos n√≥s de ramifica√ß√£o). </p><br><p>  Um exemplo completo de uma √°rvore usando todos os tipos de n√≥s: </p><br><p><img src="https://habrastorage.org/webt/tm/8y/_p/tm8y_p43ggyutxiw5a7murovrpa.png" alt="A √°rvore est√° cheia, mas n√£o grossa"></p><br><p>  Como voc√™ deve ter notado, as partes armazenadas dos caminhos t√™m prefixos.  Os prefixos s√£o necess√°rios para v√°rios prop√≥sitos: </p><br><ol><li>  Para distinguir n√≥s de extens√£o de n√≥s folha. </li><li>  Para alinhar seq√º√™ncias de um n√∫mero √≠mpar de petiscos. </li></ol><br><p>  As regras para criar prefixos s√£o muito simples: </p><br><ul><li>  O prefixo leva 1 mordidela.  Se o comprimento do caminho (excluindo o prefixo) for √≠mpar, o caminho come√ßar√° imediatamente ap√≥s o prefixo.  Se o comprimento do caminho for par, para alinhar ap√≥s o prefixo, o nibble 0x0 ser√° adicionado primeiro. </li><li>  O prefixo √© inicialmente 0x0. </li><li>  Se o comprimento do caminho for √≠mpar, 0x1 ser√° adicionado ao prefixo, se for par - 0x0. </li><li>  Se o caminho levar a um n√≥ Folha, 0x2 ser√° adicionado ao prefixo, se 0x0 for adicionado ao n√≥ Extens√£o. </li></ul><br><p>  Em beatiks, eu acho, ser√° mais claro: </p><br><pre> <code class="plaintext hljs">0b0000 =&gt;  , Extension  0b0001 =&gt;  , Extension  0b0010 =&gt;  , Leaf  0b0011 =&gt;  , Leaf </code> </pre> <br><h3 id="udalenie-kotoroe-ne-udalenie">  Exclus√£o que n√£o √© exclus√£o </h3><br><p>  Apesar do fato de a √°rvore ter a opera√ß√£o de excluir n√≥s, de fato, tudo o que foi adicionado permanece na √°rvore para sempre. </p><br><p>  Isso √© necess√°rio para n√£o criar uma √°rvore completa para cada bloco, mas armazenar apenas a diferen√ßa entre as vers√µes antiga e nova da √°rvore. </p><br><p>  Assim, usando diferentes hashes de raiz como ponto de entrada, podemos obter qualquer um dos estados em que a √°rvore j√° esteve. </p><br><p><img src="https://habrastorage.org/webt/lv/-e/mr/lv-emrvfxac4ccdfi38ps6ajvfs.png" alt="O que est√° escrito com uma caneta ..."></p><br><p>  Essas nem todas s√£o otimiza√ß√µes.  H√° mais, mas n√£o vamos falar sobre isso - e, portanto, o artigo √© amplo.  No entanto, voc√™ pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ler por</a> si mesmo. </p><br><h2 id="realizaciya">  Implementa√ß√£o </h2><br><p>  A teoria acabou, vamos para a pr√°tica.  Usaremos a lingua franca do mundo da TI, que √© <code>python</code> . </p><br><p>  Como haver√° muito c√≥digo e, para o formato do artigo, muito precisar√° ser reduzido e dividido, deixarei imediatamente um link para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> . <br>  Se necess√°rio, voc√™ pode ver a imagem inteira. </p><br><p>  Primeiro, definimos a interface em √°rvore que queremos obter como resultado: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  A interface √© extremamente simples.  As opera√ß√µes dispon√≠veis est√£o recebendo, excluindo, inserindo e alterando (combinadas na atualiza√ß√£o), al√©m de obter o hash raiz. </p><br><p>  O armazenamento ser√° transferido para o m√©todo <code>__init__</code> - uma estrutura de dados semelhante a um <code>dict</code> na qual armazenaremos os n√≥s e a <code>root</code> - o "topo" da √°rvore.  Se <code>None</code> for passado como <code>root</code> , assumimos que a √°rvore est√° vazia e funciona do zero. </p><br><p>  _ Observa√ß√£o: voc√™ pode estar se perguntando por que as vari√°veis ‚Äã‚Äãnos m√©todos s√£o nomeadas como <code>encoded_key</code> e <code>encoded_value</code> , e n√£o apenas <code>key</code> / <code>value</code> .  A resposta √© simples: de acordo com a especifica√ß√£o, todas as chaves e valores devem ser codificados no <code>RLP</code> .  N√£o nos incomodaremos com isso e deixaremos essa ocupa√ß√£o nos ombros dos usu√°rios da biblioteca. </p><br><p>  No entanto, antes de come√ßarmos a implementar a pr√≥pria √°rvore, duas coisas importantes devem ser feitas: </p><br><ol><li>  Implemente a classe <code>NibblePath</code> , que √© uma cadeia de petiscos, para n√£o codific√°-los manualmente. </li><li>  Implementar a classe <code>Node</code> dentro da estrutura desta classe - <code>Extension</code> , <code>Leaf</code> e <code>Branch</code> . </li></ol><br><h3 id="nibblepath">  Nibblepath </h3><br><p>  Ent√£o, <code>NibblePath</code> .  Como iremos mover ativamente a √°rvore, a base da funcionalidade de nossa classe deve ser a capacidade de definir o "deslocamento" desde o in√≠cio do caminho, al√©m de receber uma mordidela espec√≠fica.  Sabendo disso, definimos a base da nossa classe (bem como algumas constantes √∫teis para trabalhar com os prefixos abaixo): </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> ODD_FLAG = <span class="hljs-number"><span class="hljs-number">0x10</span></span> LEAF_FLAG = <span class="hljs-number"><span class="hljs-number">0x20</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, data, offset=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self._data = data <span class="hljs-comment"><span class="hljs-comment"># ,   . self._offset = offset #      def consume(self, amount): # "" N      . self._offset += amount return self def at(self, idx): #      idx = idx + self._offset #    ,   ,    , #   ,    -      . byte_idx = idx // 2 nibble_idx = idx % 2 #   . byte = self._data[byte_idx] #      . nibble = byte &gt;&gt; 4 if nibble_idx == 0 else byte &amp; 0x0F return nibble</span></span></code> </pre> <br><p>  Muito simples, n√£o √©? </p><br><p>  Resta escrever apenas fun√ß√µes para codificar e decodificar uma sequ√™ncia de petiscos. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def decode_with_type(data): #   : # ,     ,    . is_odd_len = data[0] &amp; NibblePath.ODD_FLAG == NibblePath.ODD_FLAG is_leaf = data[0] &amp; NibblePath.LEAF_FLAG == NibblePath.LEAF_FLAG #    ,     #    . offset  , #       "" . offset = 1 if is_odd_len else 2 return NibblePath(data, offset), is_leaf def encode(self, is_leaf): output = [] #    ,       . nibbles_len = len(self._data) * 2 - self._offset is_odd = nibbles_len % 2 == 1 #  . prefix = 0x00 #    ,    . #      (self.at(0))     . #           (0x0). prefix += self.ODD_FLAG + self.at(0) if is_odd else 0x00 #  ,  Leaf node,  . prefix += self.LEAF_FLAG if is_leaf else 0x00 output.append(prefix) # ,      ,  . pos = nibbles_len % 2 #          , #     2 ,    , #     , #    . while pos &lt; nibbles_len: byte = self.at(pos) * 16 + self.at(pos + 1) output.append(byte) pos += 2 return bytes(output)</span></span></code> </pre> <br><p>  Em princ√≠pio, este √© o m√≠nimo necess√°rio para um trabalho conveniente com mordidelas.  Obviamente, na implementa√ß√£o atual ainda existem v√°rios m√©todos auxiliares (como <code>combine</code> , mesclar dois caminhos em um), mas sua implementa√ß√£o √© muito trivial.  Se estiver interessado, a vers√£o completa pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><h3 id="node">  N√≥ </h3><br><p>  Como j√° sabemos, nossos n√≥s s√£o divididos em tr√™s tipos: Folha, Extens√£o e Ramo.  Todos eles podem ser codificados e decodificados, e a √∫nica diferen√ßa s√£o os dados armazenados dentro.  Para ser honesto, √© isso que os tipos de dados alg√©bricos s√£o solicitados e, em <code>Rust</code> , por exemplo, eu escreveria algo no esp√≠rito: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { Leaf(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]), Extension(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, NodeReference), Branch([<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;NodeReference&gt;; <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;), }</code> </pre> <br><p>  No entanto, como n√£o existe ADT no python, definiremos a classe <code>Node</code> e, dentro dela, existem tr√™s classes correspondentes aos tipos de n√≥s.  Implementamos a codifica√ß√£o diretamente nas classes de n√≥s e a decodifica√ß√£o na classe <code>Node</code> . </p><br><p>  A implementa√ß√£o, no entanto, √© elementar: </p><br><p>  Folha: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Leaf</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, data)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -  . return rlp.encode([self.path.encode(True), self.data])</span></span></code> </pre> <br><p>  Extens√£o: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extension</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, next_ref)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.next_ref = next_ref <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -    . next_ref = _prepare_reference_for_encoding(self.next_ref) return rlp.encode([self.path.encode(False), next_ref])</span></span></code> </pre> <br><p>  Filial: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Branch</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches, data=None)</span></span></span><span class="hljs-function">:</span></span> self.branches = branches self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    ,  #  16 -     (  ), #   -   (  ). branches = list(map(_prepare_reference_for_encoding, self.branches)) return rlp.encode(branches + [self.data])</span></span></code> </pre> <br><p>  Tudo √© muito simples.  A √∫nica coisa que pode causar perguntas √© a fun√ß√£o <code>_prepare_reference_for_encoding</code> . </p><br><p>  <em>Ent√£o eu confesso, tive que usar uma muleta pequena.</em>  <em>O fato √© que a biblioteca <code>rlp</code> decodifica os dados recursivamente, e o link para outro n√≥, como sabemos, pode ser dados <code>rlp</code> (caso o n√≥ codificado tenha menos de 32 caracteres).</em>  <em>Trabalhar com links em dois formatos - bytes de hash e um n√≥ decodificado - √© muito inconveniente.</em>  <em>Portanto, escrevi duas fun√ß√µes que, ap√≥s decodificar o n√≥, retornam os links no formato de bytes e decodificam-nos, se necess√°rio, antes de salvar.</em>  <em>Essas fun√ß√µes s√£o:</em> </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_prepare_reference_for_encoding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    ( ,   ) --  . #       :) if 0 &lt; len(ref) &lt; 32: return rlp.decode(ref) return ref def _prepare_reference_for_usage(ref): #     -   . #          . if isinstance(ref, list): return rlp.encode(ref) return ref</span></span></code> </pre> <br><p>  Termine com n√≥s escrevendo uma classe <code>Node</code> .  Haver√° apenas dois m√©todos: decodificar o n√≥ e transform√°-lo em um link. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># class Leaf(...) # class Extension(...) # class Branch(...) def decode(encoded_data): data = rlp.decode(encoded_data) # 17  -  Branch . if len(data) == 17: branches = list(map(_prepare_reference_for_usage, data[:16])) node_data = data[16] return Node.Branch(branches, node_data) #    17,   2.   - . #      ,     . path, is_leaf = NibblePath.decode_with_type(data[0]) if is_leaf: return Node.Leaf(path, data[1]) else: ref = _prepare_reference_for_usage(data[1]) return Node.Extension(path, ref) def into_reference(node): #    . #      32 , #   -   . #       . encoded_node = node.encode() if len(encoded_node) &lt; 32: return encoded_node else: return keccak_hash(encoded_node)</span></span></code> </pre> <br><h2 id="pereryv">  Uma pausa </h2><br><p>  Fuh!  H√° muita informa√ß√£o.  Eu acho que √© hora de relaxar.  Aqui est√° outro gato para voc√™: </p><br><p><img src="https://habrastorage.org/webt/cn/qu/jt/cnqujtdcxdavek8wvwghernczvk.png" alt="Voc√™ pode comer algo durante o intervalo"></p><br><p>  Milota, certo?  Ok, de volta √†s nossas √°rvores. </p><br><h2 id="merklepatriciatrie">  MerklePatriciaTrie </h2><br><p>  Hurrah - elementos auxiliares est√£o prontos, passamos aos mais deliciosos.  Por precau√ß√£o, lembrarei a interface da nossa √°rvore.  Ao mesmo tempo, implementamos o m√©todo <code>__init__</code> . </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> self._storage = storage self._root = root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  Mas com os m√©todos restantes, trataremos um por um. </p><br><h3 id="get">  obter </h3><br><p>  O m√©todo <code>get</code> (como, em princ√≠pio, os outros m√©todos) consistir√° em duas partes.  O pr√≥prio m√©todo preparar√° os dados e trar√° o resultado para a forma esperada, enquanto o trabalho real ocorrer√° dentro do m√©todo auxiliar. </p><br><p>  O m√©todo b√°sico √© extremamente simples: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def get(self, encoded_key): if not self._root: raise KeyError path = NibblePath(encoded_key) #       #  ,    ,    . result_node = self._get(self._root, path) if type(result_node) is Node.Extension or len(result_node.data) == 0: raise KeyError return result_node.data</span></span></code> </pre> <br><p>  No entanto, <code>_get</code> n√£o <code>_get</code> muito mais complicado: para chegar ao n√≥ desejado, precisamos ir da raiz para todo o caminho fornecido.  Se no final encontramos um n√≥ com dados (Folha ou Ramo) - viva, os dados s√£o recebidos.  Se n√£o foi poss√≠vel passar, a chave necess√°ria est√° faltando na √°rvore. </p><br><p>  Implementa√ß√£o: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get(self, node_ref, path): #      . node = self._get_node(node_ref) #    --   . #   ,      . if len(path) == 0: return node if type(node) is Node.Leaf: #     Leaf-,     , #      . if node.path == path: return node elif type(node) is Node.Extension: #    -- Extension,    . if path.starts_with(node.path): rest_path = path.consume(len(node.path)) return self._get(node.next_ref, rest_path) elif type(node) is Node.Branch: #    -- Branch,     . #   ,           #  :      . branch = node.branches[path.at(0)] if len(branch) &gt; 0: return self._get(branch, path.consume(1)) #    ,        , #     . raise KeyError</span></span></code> </pre> <br><p>  Bem, ao mesmo tempo, escreveremos m√©todos para salvar e carregar n√≥s.  Eles s√£o simples: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get_node(self, node_ref): raw_node = None if len(node_ref) == 32: raw_node = self._storage[node_ref] else: raw_node = node_ref return Node.decode(raw_node) def _store_node(self, node): reference = Node.into_reference(node) if len(reference) == 32: self._storage[reference] = node.encode() return reference</span></span></code> </pre> <br><h3 id="update">  atualizar </h3><br><p>  O m√©todo de <code>update</code> j√° √© mais interessante.  Basta ir at√© o final e inserir o n√≥ Leaf nem sempre funcionar√°.  √â prov√°vel que o ponto de separa√ß√£o de chaves esteja em algum lugar dentro do n√≥ Folha ou Extens√£o j√° salvo.  Nesse caso, voc√™ precisar√° separ√°-los e criar v√°rios novos n√≥s. </p><br><p>  Em geral, toda a l√≥gica pode ser descrita pelas seguintes regras: </p><br><ol><li>  Enquanto o caminho coincide inteiramente com os n√≥s existentes, descemos recursivamente a √°rvore. </li><li>  Se o caminho estiver conclu√≠do e estivermos no n√≥ Ramifica√ß√£o ou Folha, significa que a <code>update</code> simplesmente atualiza o valor correspondente a essa chave. </li><li>  Se os caminhos estiverem divididos (ou seja, n√£o atualizamos o valor, mas inserimos um novo), e estamos no n√≥ Filial - crie um n√≥ Folha e especifique um link para ele no ramo ramo correspondente. </li><li>  Se os caminhos estiverem divididos e estivermos em um n√≥ Folha ou Extens√£o, precisamos criar um n√≥ Filial que separa os caminhos e, se necess√°rio, um n√≥ Extens√£o para a parte comum do caminho. </li></ol><br><p>  Vamos gradualmente expressar isso no c√≥digo.  Por que gradualmente?  Como o m√©todo √© grande e ser√° dif√≠cil entend√™-lo em massa. <br>  No entanto, deixarei um link para o m√©todo completo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def update(self, encoded_key, encoded_value): path = NibblePath(encoded_key) result = self._update(self._root, path, encoded_value) self._root = result def _update(self, node_ref, path, value): #       (,   ), #       . if not node_ref: return self._store_node(Node.Leaf(path, value)) #          #    . node = self._get_node(node_ref) if type(node) == Node.Leaf: ... elif type(node) == Node.Extension: ... elif type(node) == Node.Branch: ...</span></span></code> </pre> <br><p>  N√£o h√° l√≥gica geral suficiente, o mais interessante √© <code>if</code> s. </p><br><h5 id="if-typenode--nodeleaf"> <code>if type(node) == Node.Leaf</code> </h5> <br><p>  Primeiro, vamos lidar com os n√≥s Leaf.  Apenas 2 cen√°rios s√£o poss√≠veis com eles: </p><br><ol><li><p>  O restante do caminho que estamos seguindo √© exatamente o mesmo que o caminho armazenado no n√≥ Folha.  Nesse caso, basta alterar o valor, salvar o novo n√≥ e retornar um link para ele. </p><br></li><li><p>  Os caminhos s√£o diferentes. <br>  Nesse caso, voc√™ precisa criar um n√≥ Filial que separa os dois caminhos. <br>  Se um dos caminhos estiver vazio, seu valor ser√° transferido diretamente para o n√≥ Filial. <br>  Caso contr√°rio, teremos que criar dois n√≥s Leaf encurtados pelo comprimento da parte comum dos caminhos + 1 petisco (esse petisco ser√° indicado pelo √≠ndice da ramifica√ß√£o correspondente do n√≥ Branch). </p><br></li></ol><br><p>  Voc√™ tamb√©m precisar√° verificar se h√° uma parte comum do caminho para entender se tamb√©m precisamos criar um n√≥ de extens√£o. </p><br><p>  No c√≥digo, ficar√° assim: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.path == path: <span class="hljs-comment"><span class="hljs-comment">#  .       . node.data = value return self._store_node(node) #    . #    . common_prefix = path.common_prefix(node.path) #      . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch . branch_reference = self._create_branch_node(path, value, node.path, node.data) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  O procedimento <code>_create_branch_node</code> √© o seguinte: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_branch_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path_a, value_a, path_b, value_b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    Branch-. branches = [b''] * 16 # ,     Branch- . branch_value = b'' if len(path_a) == 0: branch_value = value_a elif len(path_b) == 0: branch_value = value_b #    Leaf-,  . self._create_branch_leaf(path_a, value_a, branches) self._create_branch_leaf(path_b, value_b, branches) #  Branch-     . return self._store_node(Node.Branch(branches, branch_value)) def _create_branch_leaf(self, path, value, branches): # ,     Leaf-. if len(path) &gt; 0: #    ( ). idx = path.at(0) #  Leaf-   ,     . leaf_ref = self._store_node(Node.Leaf(path.consume(1), value)) branches[idx] = leaf_ref</span></span></code> </pre> <br><h5 id="if-typenode--nodeextension"> <code>if type(node) == Node.Extension</code> </h5> <br><p>  No caso do n√≥ Extension, tudo se parece com um n√≥ Leaf. </p><br><ol><li><p>  Se o caminho do n√≥ Extension for um prefixo para o nosso caminho, simplesmente seguiremos recursivamente. </p><br></li><li><p>  Caso contr√°rio, precisamos fazer a separa√ß√£o usando o n√≥ Filial, como no caso descrito acima. </p><br></li></ol><br><p>  Por conseguinte, o c√≥digo: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.starts_with(node.path): <span class="hljs-comment"><span class="hljs-comment">#         . new_reference = \ self._update(node.next_ref, path.consume(len(node.path)), value) return self._store_node(Node.Extension(node.path, new_reference)) #  Extension-. #     . common_prefix = path.common_prefix(node.path) #  . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch- ,  ,    . branches = [b''] * 16 branch_value = value if len(path) == 0 else b'' #     Leaf-  Extension- . self._create_branch_leaf(path, value, branches) self._create_branch_extension(node.path, node.next_ref, branches) branch_reference = self._store_node(Node.Branch(branches, branch_value)) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  O procedimento <code>_create_branch_extension</code> logicamente equivalente ao procedimento <code>_create_branch_leaf</code> , mas funciona com o n√≥ Extension. </p><br><h5 id="if-typenode--nodebranch"> <code>if type(node) == Node.Branch</code> </h5> <br><p>  Mas com o n√≥ Branch, tudo √© simples.  Se o caminho estiver vazio, simplesmente salvamos o novo valor no n√≥ Branch atual.  Se o caminho n√£o estiver vazio, "morderemos" uma mordidela dele e recursivamente diminuiremos. </p><br><p>  O c√≥digo, eu acho, n√£o precisa de coment√°rios. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(Node.Branch(node.branches, value)) idx = path.at(<span class="hljs-number"><span class="hljs-number">0</span></span>) new_reference = self._update(node.branches[idx], path.consume(<span class="hljs-number"><span class="hljs-number">1</span></span>), value) node.branches[idx] = new_reference <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(node)</code> </pre> <br><h3 id="delete">  excluir </h3><br><p>  Fuh!  O √∫ltimo m√©todo permanece.  Ele √© o mais alegre.  A complexidade da exclus√£o √© que precisamos retornar a estrutura ao estado em que ela teria ca√≠do se tiv√©ssemos feito toda a cadeia de <code>update</code> , excluindo apenas a chave exclu√≠da. </p><br><p>   ,       ,     ,      ,    .   "",   ,      . </p><br><p>         .  ,   N-        ,    N+1 .      enum ‚Äî <code>DeleteAction</code> ,    . </p><br><p>    <code>delete</code>   : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... # Enum, ,         . class _DeleteAction(Enum): #    . #     , #        (_DeleteAction, None). DELETED = 1, #    (,    ). #     ,    #    : (_DeleteAction, ___). UPDATED = 2, #    Branch-  .   -- #    : # (_DeleteAction, (___, ___)) USELESS_BRANCH = 3 def delete(self, encoded_key): if self._root is None: return path = NibblePath(encoded_key) action, info = self._delete(self._root, path) if action == MerklePatriciaTrie._DeleteAction.DELETED: #   . self._root = None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #   . new_root = info self._root = new_root elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #   . _, new_root = info self._root = new_root def _delete(self, node_ref, path): node = self._get_node(node_ref) if type(node) == Node.Leaf: pass elif type(node) == Node.Extension: pass elif type(node) == Node.Branch: pass</span></span></code> </pre> <br><p>      ,      <code>get</code>  <code>update</code> .     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . </p><br><h4 id="if-typenode--nodeleaf-1"> <code>if type(node) == Node.Leaf</code> </h4> <br><p>   .     .      ‚Äî     ,     ,   . </p><br><p>  : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path == node.path: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MerklePatriciaTrie._DeleteAction.DELETED, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError</code> </pre> <br><p>    ,  "" ‚Äî    .       ,      .              . </p><br><h4 id="if-typenode--nodeextension-1"> <code>if type(node) == Node.Extension</code> </h4> <br><p> C Extension-   : </p><br><ol><li>  ,     Extension-      .   ‚Äî    . </li><li>   <code>_delete</code> , ""   . </li><li>    .  : </li></ol><br><ul><li>    .         . </li><li>    .      . </li><li>      Branch-.          .      ,  Branch-   .      ,   ,    Leaf-.    ‚Äî   Extension-. </li></ul><br><p>     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.starts_with(node.path): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-comment"><span class="hljs-comment">#   . #       . action, info = self._delete(node.next_ref, path.consume(len(node.path))) if action == MerklePatriciaTrie._DeleteAction.DELETED: return action, None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #    ,     . child_ref = info new_ref = self._store_node(Node.Extension(node.path, child_ref)) return action, new_ref elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #     Branch-. stored_path, stored_ref = info # ,     Branch-. child = self._get_node(stored_ref) new_node = None if type(child) == Node.Leaf: #  branch-  . #     Leaf-  Extension. path = NibblePath.combine(node.path, child.path) new_node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: #  Branch-  Extension-. #       . path = NibblePath.combine(node.path, child.path) new_node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: #  Branch-      Branch-. #    Extension-    . path = NibblePath.combine(node.path, stored_path) new_node = Node.Extension(path, stored_ref) new_reference = self._store_node(new_node) return MerklePatriciaTrie._DeleteAction.UPDATED, new_reference</span></span></code> </pre> <br><h4 id="if-typenode--nodebranch-1"> <code>if type(node) == Node.Branch</code> </h4> <br><p>   . </p><br><p> , .    Branch-,     ‚Ä¶ </p><br><p>  Porque   Branch-      Leaf- ( )     Extension- (    ). <br> ,        .      ,    ‚Äî     Leaf-.          ‚Äî      Extension-.         ,    ,    2   ‚Äî  Branch-   . </p><br><p>     ?  : </p><br><p>    : </p><br><ol><li>    ,   . </li><li>    ,  <code>_delete</code>   . </li></ol><br><p>      : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: action = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> idx = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) != <span class="hljs-number"><span class="hljs-number">0</span></span>: node.data = <span class="hljs-string"><span class="hljs-string">b''</span></span> action = MerklePatriciaTrie._DeleteAction.DELETED <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-comment"><span class="hljs-comment">#   ,    . #    . idx = path.at(0) if len(node.branches[idx]) == 0: raise KeyError action, info = self._delete(node.branches[idx], path.consume(1)) #  ,   ,  . #      -    #    . node.branches[idx] = b''</span></span></code> </pre> <br><p>     <code>_DeleteAction</code>       . </p><br><ol><li>       Branch-  ,      (    ,   ).            . </li></ol><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.UPDATED: <span class="hljs-comment"><span class="hljs-comment">#   . next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #    . _, next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><ol><li>     ( ,  ),   ,      . </li></ol><br><p>      .  : </p><br><ul><li>       .  ,   ,    ,       .  ,  . </li><li>   ,   .   Leaf-   .      . </li><li>  ,   .    ,   ,      . </li><li>   , ,  Branch-   .    ,  <code>_DeleteAction</code> ‚Äî <code>UPDATED</code> . </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.DELETED: non_empty_count = sum(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(x) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, node.branches)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> non_empty_count == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Branch- ,  . return MerklePatriciaTrie._DeleteAction.DELETED, None elif non_empty_count == 0 and len(node.data) != 0: #  ,   . path = NibblePath([]) reference = self._store_node(Node.Leaf(path, node.data)) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference) elif non_empty_count == 1 and len(node.data) == 0: #  ,   . return self._build_new_node_from_last_branch(node.branches) else: #  1+   ,  2+ . # Branch-  ,   - UPDATED. reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><p>  <code>_build_new_node_from_last_branch</code>           . </p><br><p>    ‚Äî Leaf  Extension,           ,   . </p><br><p>     ‚Äî Branch,      Extension ,        ,      Branch. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_build_new_node_from_last_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    . idx = 0 for i in range(len(branches)): if len(branches[i]) &gt; 0: idx = i break #     . prefix_nibble = NibblePath([idx], offset=1) #     child = self._get_node(branches[idx]) path = None node = None #   . if type(child) == Node.Leaf: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: path = prefix_nibble node = Node.Extension(path, branches[idx]) #  . reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference)</span></span></code> </pre> <br><h3 id="ostalnoe">  O resto </h3><br><p>      .  , ‚Ä¶    <code>root</code> . </p><br><p>  Aqui: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def root(self): return self._root</span></span></code> </pre> <br><p>   ,   . </p><br><p>  ‚Ä¶  .  ,   ,      Ethereum         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . ,   , ,   .      ,    :) </p><br><p> ,      ,    <code>pip install -U eth_mpt</code> ‚Äî  . </p><br><p><img src="https://habrastorage.org/webt/qm/wo/fx/qmwofx6jaxe_0t50akn0sdnt-0m.png" alt="That's all folks!"></p><br><h2 id="rezultaty">  Resultados </h2><br><p>      ? </p><br><p> , -,      ,  -       ,      ,   .    ‚Äî  ,       . </p><br><p> -,   ,  ,            ‚Äî .  ,        skip list  interval tree,     ‚Äî , , . </p><br><p> -,     ,            .   ,           -  . </p><br><p> -,     ‚Äî   . </p><br><p>   ,  ,        ‚Äî    ! </p><br><h2 id="arty">  </h2><br><p>      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3</a> .   !    ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446558/">https://habr.com/ru/post/pt446558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446546/index.html">A Microsoft estende a vantagem de IP do Azure com novos benef√≠cios de IP para inovadores e inicializa√ß√µes da IoT do Azure</a></li>
<li><a href="../pt446548/index.html">An√°lise de estat√≠sticas sobre campanhas publicit√°rias - crie uma nova m√©trica no DataFrame (python)</a></li>
<li><a href="../pt446550/index.html">Problemas de padr√£o do coordenador e o que o RouteComposer tem a ver com isso</a></li>
<li><a href="../pt446552/index.html">Trabalhando com comandos APDU usando o exemplo EToken</a></li>
<li><a href="../pt446554/index.html">Programa residente Yandex ou Como um back-end experiente se tornar um engenheiro de ML</a></li>
<li><a href="../pt446560/index.html">"Courtesy Exchange": a ess√™ncia do conflito entre as duas mais famosas empresas de streaming</a></li>
<li><a href="../pt446562/index.html">Assincronia na programa√ß√£o</a></li>
<li><a href="../pt446566/index.html">Projeto Zero. Como a Amazon quer lidar com falsifica√ß√µes</a></li>
<li><a href="../pt446568/index.html">Atualiza√ß√£o do CMS em grande escala do Umbraco 8: o que h√° de novo</a></li>
<li><a href="../pt446570/index.html">A hist√≥ria da primeira GPU: Rendition V√©rit√© 1000</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>