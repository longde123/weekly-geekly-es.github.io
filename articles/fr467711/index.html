<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïµüèΩ ‚úãüèø üòµ IoT, brouillard et nuages: parler de technologie? üí± üÜñ üßëüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le d√©veloppement des technologies dans le domaine des logiciels et du mat√©riel, l'√©mergence de nouveaux protocoles de communication ont conduit √† l'ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IoT, brouillard et nuages: parler de technologie?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/cloud4y/blog/467711/"><img src="https://habrastorage.org/webt/e-/-2/xi/e--2xiob3rxaedvmvmjlklvkvoo.png"><br><br>  <i>Le d√©veloppement des technologies dans le domaine des logiciels et du mat√©riel, l'√©mergence de nouveaux protocoles de communication ont conduit √† l'expansion de l'Internet des objets (IoT).</i>  <i>Le nombre d'appareils augmente de jour en jour et ils g√©n√®rent une √©norme quantit√© de donn√©es.</i>  <i>Par cons√©quent, un besoin se fait sentir d'une architecture de syst√®me pratique capable de traiter, de stocker et de transmettre ces donn√©es.</i> <i><br><br></i>  <i>Maintenant, ils utilisent les services cloud √† ces fins.</i>  <i>Cependant, le paradigme brumeux (Fog) en constante √©volution est en mesure de compl√©ter les solutions cloud en faisant √©voluer et en optimisant l'infrastructure IoT.</i> <a name="habracut"></a><br><br>  Les nuages ‚Äã‚Äãpeuvent fermer la plupart des demandes IoT.  Par exemple, pour fournir des services de surveillance, un traitement rapide de toute quantit√© de donn√©es g√©n√©r√©es par les appareils, ainsi que leur visualisation.  L'informatique brumeuse est plus efficace pour r√©soudre les probl√®mes en temps r√©el.  Ils fournissent une r√©ponse rapide aux demandes et un d√©lai minimum dans le traitement des donn√©es.  Autrement dit, le brouillard compl√®te exactement les ¬´nuages¬ª, √©tend ses capacit√©s. <br><br>  Cependant, la question principale est diff√©rente: comment tout cela devrait-il interagir dans le contexte de l'IoT?  Quels protocoles de communication seront les plus efficaces lorsque vous travaillez dans un syst√®me IoT-Fog-Cloud unifi√©? <br><br>  Malgr√© l'apparente domination de HTTP, l'IoT, le brouillard et le cloud utilisent un grand nombre d'autres solutions.  En effet, l'IoT doit combiner les fonctionnalit√©s d'une vari√©t√© de capteurs d'appareils avec la s√©curit√©, l'interop√©rabilit√© et d'autres exigences des utilisateurs. <br><br>  Voici juste une id√©e unique de l'architecture de r√©f√©rence et la norme de communication n'est tout simplement pas l√†.  Par cons√©quent, la cr√©ation d'un nouveau protocole ou le raffinement d'un protocole existant pour des t√¢ches IoT sp√©cifiques est l'une des t√¢ches les plus importantes pour la communaut√© informatique. <br><br>  Quels protocoles sont utilis√©s actuellement et que peuvent-ils offrir?  Faisons les choses correctement.  Mais d'abord, discutons des principes d'un √©cosyst√®me dans lequel les nuages, le brouillard et l'Internet des objets interagissent. <br><br><h3>  Architecture IoT Fog-to-Cloud (F2C) </h3><br>  Vous devez avoir remarqu√© combien d'efforts ont √©t√© d√©ploy√©s pour explorer les avantages et les avantages de la gestion de l'IoT, des nuages ‚Äã‚Äãet du brouillard de mani√®re rationnelle et coordonn√©e.  Sinon, il existe d√©j√† trois initiatives de normalisation: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenFog Consortium</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Edge Computing Consortium</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mF2C H2020 EU project</a> . <br><br>  Si auparavant seuls 2 niveaux, les nuages ‚Äã‚Äãet les terminaux √©taient pris en compte, l'architecture propos√©e introduisait un nouveau niveau: le calcul du brouillard.  Dans ce cas, le niveau de brouillard peut √™tre divis√© en plusieurs sous-niveaux, selon les sp√©cificit√©s des ressources ou un ensemble de politiques qui d√©terminent l'utilisation de diff√©rents appareils dans ces sous-niveaux. <br><br>  √Ä quoi pourrait ressembler cette abstraction?  Voici un √©cosyst√®me IoT-Fog-Cloud typique.  Les appareils IoT envoient des donn√©es vers des serveurs et des appareils informatiques plus puissants pour r√©soudre les t√¢ches qui n√©cessitent une faible latence.  Dans le m√™me syst√®me, les nuages ‚Äã‚Äãsont responsables de la r√©solution de probl√®mes n√©cessitant une grande quantit√© de ressources informatiques ou d'espace de stockage de donn√©es. <br><br><img src="https://habrastorage.org/webt/b1/cr/tf/b1crtfzorujkb5afwoq2m-uwlua.png"><br><br>  Les smartphones, les montres connect√©es et autres gadgets peuvent √©galement faire partie de l'IoT.  Mais de tels appareils, en r√®gle g√©n√©rale, utilisent des protocoles de communication propri√©taires de grands d√©veloppeurs.  Les donn√©es IoT g√©n√©r√©es sont transmises au niveau de brouillard via le protocole HTTP REST, qui offre flexibilit√© et interop√©rabilit√© lors de la cr√©ation de services RESTful.  Ceci est important compte tenu du besoin de compatibilit√© descendante avec l'infrastructure informatique existante ex√©cut√©e sur des ordinateurs locaux, des serveurs ou un cluster de serveurs.  Les ressources locales, appel√©es ¬´n≈ìuds du brouillard¬ª, filtrent les donn√©es re√ßues et les traitent localement ou les envoient au cloud pour des calculs ult√©rieurs. <br><br>  Les nuages ‚Äã‚Äãprennent en charge divers protocoles de communication, parmi lesquels AMQP et REST HTTP sont le plus souvent trouv√©s.  √âtant donn√© que HTTP est bien connu et emprisonn√© pour Internet, la question peut se poser: ¬´Mais dois-je l'utiliser pour travailler avec l'IoT et le brouillard?¬ª.  Cependant, ce protocole a des probl√®mes de performances.  Plus d'informations √† ce sujet plus tard. <br><br>  En g√©n√©ral, il existe 2 mod√®les de protocoles de communication adapt√©s au syst√®me dont nous avons besoin.  Il s'agit d'une demande-r√©ponse et d'une publication-abonnement.  Le premier mod√®le est plus largement connu, notamment dans l'architecture serveur-client.  Le client demande des informations au serveur, il re√ßoit la demande, la traite et renvoie un message de r√©ponse.  Les protocoles REST HTTP et CoAP fonctionnent sur ce mod√®le. <br><br>  Le deuxi√®me mod√®le est n√© de la n√©cessit√© de fournir une communication asynchrone, distribu√©e et faible entre les sources qui g√©n√®rent les donn√©es et les destinataires de ces donn√©es. <br><br><img src="https://habrastorage.org/webt/jo/uh/ze/jouhzen4ifrik_e1pqtb9gtwtxa.png"><br><br>  Le mod√®le implique trois participants: l'√©diteur (source de donn√©es), le courtier (r√©partiteur) et l'abonn√© (destinataire).  Ici, le client agissant en tant qu'abonn√© ne doit pas demander d'informations au serveur.  Au lieu d'envoyer des demandes, il s'abonne √† certains √©v√©nements du syst√®me via un courtier charg√© de filtrer tous les messages entrants et de les acheminer entre √©diteurs et abonn√©s.  Et l'√©diteur, lorsqu'un √©v√©nement se produit concernant un certain sujet, le publie au courtier, qui envoie les donn√©es d'abonn√© sur le sujet demand√©. <br><br>  En substance, cette architecture est pilot√©e par les √©v√©nements.  Et ce mod√®le d'interaction est int√©ressant pour les applications IoT, cloud, brouillard en raison de sa capacit√© √† fournir une √©volutivit√© et √† simplifier l'interconnexion entre diff√©rents appareils, pour prendre en charge la communication dynamique plusieurs-√†-plusieurs et la communication asynchrone.  Parmi les protocoles de messagerie standardis√©s les plus connus utilisant le mod√®le de publication-abonnement figurent MQTT, AMQP et DDS. <br><br>  De toute √©vidence, le mod√®le de publication-abonnement pr√©sente de nombreux avantages: <br><br><ul><li>  Les √©diteurs et les abonn√©s n'ont pas besoin de se conna√Ætre mutuellement; </li><li>  Un abonn√© peut recevoir des informations de nombreuses publications diff√©rentes, et un √©diteur peut envoyer des donn√©es √† de nombreux abonn√©s diff√©rents (le principe ¬´plusieurs √† plusieurs¬ª); </li><li>  L'√©diteur et l'abonn√© ne sont pas tenus d'√™tre actifs simultan√©ment pour l'√©change de donn√©es, car le courtier (fonctionnant comme un syst√®me de file d'attente) pourra stocker un message pour les clients qui ne sont actuellement pas connect√©s au r√©seau. </li></ul><br>  Cependant, le mod√®le demande-r√©ponse a √©galement ses propres forces.  Dans les cas o√π les capacit√©s du c√¥t√© serveur pour le traitement des demandes de plusieurs clients ne sont pas un probl√®me, il est logique d'utiliser des solutions fiables d√©j√† √©prouv√©es. <br><br>  Il existe √©galement des protocoles qui prennent en charge les deux mod√®les.  Par exemple, XMPP et HTTP 2.0 qui prennent en charge l'option push du serveur.  L'IETF a √©galement publi√© CoAP.  Pour tenter de r√©soudre le probl√®me de messagerie, plusieurs autres solutions ont √©t√© cr√©√©es, telles que le protocole WebSockets ou en utilisant le protocole HTTP via QUIC (Quick UDP Internet Connections). <br><br>  Dans le cas de WebSockets, bien qu'il soit utilis√© pour le transfert de donn√©es en temps r√©el du serveur vers le client Web et fournit des connexions constantes avec une communication bidirectionnelle simultan√©e, il n'est pas destin√© aux appareils avec des ressources informatiques limit√©es.  QUIC m√©rite √©galement l'attention, car le nouveau protocole de transport fournit de nombreuses nouvelles fonctionnalit√©s.  Mais comme QUIC n'est pas encore standardis√©, il est pr√©matur√© de pr√©dire son application possible et son impact sur les solutions IoT.  Nous laissons donc WebSockets et QUIC en m√©moire en vue de l'avenir, mais nous n'allons pas encore √©tudier plus en d√©tail. <br><br><h3>  Qui dans le monde est le plus doux: nous comparons les protocoles </h3><br>  Parlons maintenant des forces et des faiblesses des protocoles.  Pour l'avenir, nous faisons imm√©diatement une r√©serve qu'il n'y a pas de leader clair.  Chaque protocole pr√©sente certains avantages / inconv√©nients. <br><br>  <b>Temps de r√©ponse</b> <br><br>  L'une des caract√©ristiques les plus importantes des protocoles de communication, notamment en ce qui concerne l'Internet des objets, est le temps de r√©ponse.  Mais parmi les protocoles existants, il n'y a pas d'exception d√©montrant un niveau minimum de retard lorsque l'on travaille dans des conditions diff√©rentes.  Mais il y a tout un tas de recherches et de comparaisons des capacit√©s de protocole. <br><br>  Par exemple, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©sultats de la</a> comparaison de l'efficacit√© de HTTP et de MQTT lors de l'utilisation de l'IoT ont montr√© que le temps de r√©ponse pour les demandes de MQTT est inf√©rieur √† celui de HTTP.  Et en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©tudiant le</a> temps de r√©ception et de transmission (RTT) du MQTT et du CoAP, il s'est av√©r√© que le RTT CoAP moyen est 20% inf√©rieur √† celui du MQTT. <br><br>  Une autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exp√©rience</a> avec RTT pour les protocoles MQTT et CoAP a √©t√© r√©alis√©e dans deux sc√©narios: un r√©seau local et un r√©seau IoT.  Il s'est av√©r√© que le RTT moyen est 2-3 fois plus √©lev√© dans le r√©seau IoT.  MQTT avec QoS0 a montr√© un r√©sultat inf√©rieur √† celui de CoAP, et MQTT avec QoS1 a montr√© un RTT plus √©lev√© en raison de l'ACK aux niveaux d'application et de transport.  Pour diff√©rents niveaux de QoS, les retards du r√©seau sans congestion pour MQTT √©taient de quelques millisecondes et pour CoAP, des centaines de microsecondes.  Cependant, il convient de se rappeler que lorsque vous travaillez dans des r√©seaux moins fiables, MQTT ex√©cut√© au-dessus de TCP affichera un r√©sultat diff√©rent. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La comparaison du</a> temps de r√©ponse pour les protocoles AMQP et MQTT en augmentant la charge utile a montr√© qu'avec une petite charge, le niveau de retard est presque le m√™me.  Mais lors de la transmission de grandes quantit√©s de donn√©es, MQTT affiche un temps de r√©ponse inf√©rieur.  Dans une autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©tude,</a> CoAP a √©t√© compar√© √† HTTP dans un sc√©nario de communication de machine √† machine avec des appareils d√©ploy√©s au-dessus de v√©hicules √©quip√©s de capteurs de gaz, de capteurs m√©t√©orologiques, de localisation (GPS) et d'une interface de r√©seau mobile (GPRS).  Le temps n√©cessaire pour envoyer un message CoAP sur un r√©seau mobile √©tait presque trois fois plus court que le temps n√©cessaire pour utiliser les messages HTTP. <br><br>  Des √©tudes ont compar√© non pas deux, mais trois protocoles.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comparer les</a> performances des protocoles IoT MQTT, DDS et CoAP dans un cas d'utilisation m√©dicale √† l'aide d'un √©mulateur de r√©seau.  DDS a surpass√© MQTT en termes de latence de t√©l√©m√©trie exp√©riment√©e dans diverses conditions de r√©seau m√©diocres.  CoAP bas√© sur UDP fonctionnait bien pour les applications n√©cessitant une r√©ponse rapide, mais comme il √©tait bas√© sur UDP, il y avait une perte de paquets impr√©visible importante. <br><br>  <b>D√©bit</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La comparaison du</a> MQTT et du CoAP en termes d'utilisation de la bande passante a √©t√© effectu√©e en tant que calcul de la quantit√© totale de donn√©es transmises par message.  CoAP a montr√© moins de bande passante que MQTT lors de l'envoi de petits messages.  Mais en comparant l'efficacit√© des protocoles en termes de rapport entre le nombre d'octets d'informations utiles et le nombre total d'octets transmis, CoAP √©tait plus efficace. <br><br>  Lors de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyse de l'</a> utilisation du MQTT, du DDS (avec TCP comme protocole de transport) et de la bande passante CoAP, il s'est av√©r√© que CoAP avait tendance √† montrer une consommation de bande passante relativement inf√©rieure, qui n'augmentait pas avec une augmentation de la perte de paquets r√©seau ou un d√©lai r√©seau accru, contrairement √† MQTT et DDS, o√π dans les sc√©narios mentionn√©s, il y a eu une augmentation de l'utilisation de la capacit√© des canaux.  Dans un autre sc√©nario, un grand nombre d'appareils transmettaient des donn√©es simultan√©ment, ce qui est un cas typique dans les environnements IoT.  Les r√©sultats ont montr√© que pour une charge plus √©lev√©e, il est pr√©f√©rable d'utiliser CoAP. <br><br>  Avec une charge l√©g√®re, CoAP a utilis√© le moins de bande passante, suivi de MQTT et HTTP REST.  Cependant, lorsque la taille de la charge utile a augment√©, REST HTTP a obtenu les meilleurs r√©sultats. <br><br>  <b>Consommation d'√©nergie</b> <br><br>  La question de la consommation d'√©nergie est toujours d'une grande importance, notamment dans le syst√®me IoT.  Si nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comparons la</a> consommation d'√©nergie de MQTT et HTTP, alors HTTP ¬´mange¬ª beaucoup plus.  Et CoAP est plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©conome en √©nergie</a> que MQTT, vous permettant de g√©rer l'√©nergie.  De plus, dans des sc√©narios simples, MQTT est plus adapt√© √† l'√©change d'informations sur Internet des objets, surtout s'il n'y a pas de restrictions de puissance. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une autre</a> exp√©rience, qui a compar√© les capacit√©s d'AMQP et de MQTT sur un banc d'essai pour un r√©seau sans fil mobile ou instable, a montr√© qu'AMQP offre plus d'options de s√©curit√©, tandis que MQTT est plus √©conome en √©nergie. <br><br>  <b>La s√©curit√©</b> <br><br>  La s√©curit√© est un autre probl√®me critique soulev√© lors de l'√©tude du sujet de l'Internet des objets et de l'informatique brumeuse / cloud.  Le m√©canisme de s√©curit√© est g√©n√©ralement bas√© sur TLS dans HTTP, MQTT, AMQP et XMPP, sur ou DTLS dans CoAP, et prend √©galement en charge les deux versions de DDS. <br><br>  TLS et DTLS commencent par le processus d'√©tablissement de la communication entre les c√¥t√©s client et serveur pour √©changer les suites de chiffrement et les cl√©s prises en charge.  Les deux parties n√©gocient des kits pour garantir la poursuite de la communication via un canal s√©curis√©.  La diff√©rence entre les deux r√©side dans de petites modifications qui permettent au DTLS bas√© sur UDP de fonctionner sur une connexion peu fiable. <br><br>  Lors <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des attaques de test</a> sur plusieurs impl√©mentations TLS et DTLS diff√©rentes, il s'est av√©r√© que TLS a fait un meilleur travail.  Les attaques contre DTLS ont √©t√© plus r√©ussies en raison de sa tol√©rance aux erreurs. <br><br>  Cependant, le plus gros probl√®me avec ces protocoles est qu'ils n'ont pas √©t√© initialement con√ßus pour √™tre utilis√©s dans l'IoT et n'impliquaient pas de travail dans le brouillard ou le cloud.  Gr√¢ce √† un √©change coh√©rent (prise de contact), ils ajoutent du trafic suppl√©mentaire √† chaque connexion, ce qui √©puise les ressources informatiques.  En moyenne, la charge de travail augmente de 6,5% pour TLS et de 11% pour DTLS par rapport √† la communication sans niveau de s√©curit√©.  Dans les environnements riches en ressources qui sont g√©n√©ralement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bas√©s</a> sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cloud</a> , cela ne sera pas un probl√®me, mais cela devient une limitation importante entre l'IoT et le niveau de brouillard. <br><br>  Que choisir?  Il n'y a pas de r√©ponse d√©finitive.  MQTT et HTTP semblent √™tre les protocoles les plus prometteurs, car ils sont consid√©r√©s comme des solutions relativement plus matures et plus stables pour l'IoT par rapport √† d'autres protocoles. <br><br><h3>  Solutions de protocole de communications unifi√©es </h3><br>  La pratique d'une solution √† protocole unique pr√©sente de nombreux inconv√©nients.  Par exemple, un protocole qui satisfait un environnement limit√© peut ne pas fonctionner dans un domaine qui a des exigences de s√©curit√© strictes.  Dans cet esprit, il nous reste √† rejeter presque toutes les solutions possibles bas√©es sur un protocole dans l'√©cosyst√®me Fog-to-Cloud dans IoT, √† l'exception de MQTT et REST HTTP. <br><br>  <b>REST HTTP en tant que solution √† protocole unique</b> <br><br>  Il existe un bon exemple d'interaction entre la demande et la r√©ponse HTTP IoT-to-Fog REST: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la batterie de serveurs intelligente</a> .  Les animaux sont √©quip√©s de capteurs portables (client IoT, C) et contr√¥l√©s via le cloud computing par un syst√®me d'√©levage intelligent (serveur Fog, S). <br><br>  Le titre de la m√©thode POST indique la ressource √† modifier (/ ferme / animaux), ainsi que la version HTTP et le type de contenu, qui dans ce cas est un objet JSON repr√©sentant la ferme d'√©levage que le syst√®me doit g√©rer (Dulcin√©e / vache).  Une r√©ponse du serveur indique que la demande a abouti en envoyant un code d'√©tat HTTPS 201 (ressource cr√©√©e).  La m√©thode GET doit indiquer uniquement la ressource demand√©e dans l'URI (par exemple, / farm / animals / 1), qui renvoie la repr√©sentation JSON de l'animal avec cet identifiant depuis le serveur. <br><br>  La m√©thode PUT est utilis√©e lorsque vous devez mettre √† jour un enregistrement de ressource sp√©cifique.  Dans ce cas, l'URI est indiqu√© dans la ressource pour le param√®tre √† modifier et la valeur actuelle (par exemple, indiquant que la vache marche actuellement, / farm / animals / 1? State = walking).  Enfin, la m√©thode DELETE est utilis√©e √©galement pour la m√©thode GET, mais supprime simplement la ressource √† la suite de l'op√©ration. <br><br>  <b>MQTT comme solution √† protocole unique</b> <br><br><img src="https://habrastorage.org/webt/ur/72/0u/ur720umujcr7x5dqvpju9ri72vs.png"><br><br>  Prenez la m√™me ferme intelligente, mais au lieu de REST HTTP, nous utilisons le protocole MQTT.  Le serveur local sur lequel la biblioth√®que Mosquitto est install√©e fait office de courtier.  Dans cet exemple, un ordinateur simple (appel√© serveur de ferme) Raspberry Pi sert de client MQTT, impl√©ment√© via l'installation de la biblioth√®que MQTT Paho, qui est enti√®rement compatible avec le courtier Mosquitto. <br><br>  Ce client correspond √† la couche d'abstraction IoT repr√©sentant un appareil dot√© de capacit√©s de d√©tection et de calcul.  L'interm√©diaire, en revanche, correspond √† un niveau d'abstraction plus √©lev√©, repr√©sentant le n≈ìud informatique du brouillard, qui se caract√©rise par une grande puissance en termes de traitement et de stockage des donn√©es. <br><br>  Dans le sc√©nario Smart Farm propos√©, le Raspberry Pi se connecte √† l'acc√©l√©rom√®tre, au GPS et aux capteurs de temp√©rature et publie les donn√©es de ces capteurs dans le n≈ìud de brouillard.  Comme vous le savez probablement, MQTT traite les sujets comme une hi√©rarchie.  Un √©diteur MQTT peut publier dans un ensemble sp√©cifique de sujets.  Dans notre cas, il y en a trois.  Pour un capteur qui mesure la temp√©rature dans une √©table, le client s√©lectionne un th√®me (ferme animale / hangar / temp√©rature).  Pour les capteurs qui mesurent la position GPS et le mouvement des animaux √† travers l'acc√©l√©rom√®tre, le client publiera des mises √† jour (ferme animale / animal / GPS) et (ferme animale / animal / mouvement). <br><br>  Ces informations seront transmises au courtier, qui pourra les stocker temporairement dans une base de donn√©es locale au cas o√π un autre abonn√© int√©ress√© appara√Ætrait ult√©rieurement. <br><br>  En plus du serveur local agissant en tant que courtier MQTT dans le brouillard et auquel Raspberry Pi, agissant en tant que clients MQTT, envoie des donn√©es √† partir de capteurs, il peut y avoir un autre courtier MQTT au niveau du cloud.  Dans ce cas, les informations transmises au courtier local peuvent √™tre temporairement stock√©es dans la base de donn√©es locale et / ou envoy√©es au cloud.  Le courtier MQTT brumeux dans cette situation est utilis√© pour lier toutes les donn√©es avec le courtier MQTT cloud.  Avec cette architecture, un utilisateur d'application mobile peut √™tre abonn√© aux deux courtiers. <br><br>  En cas d'√©chec de connexion avec l'un des courtiers (par exemple, cloud), l'utilisateur final recevra des informations d'un autre (brumeux).  C'est une caract√©ristique des syst√®mes combin√©s de brouillard et de cloud computing.  Par d√©faut, l'application mobile peut √™tre configur√©e pour se connecter au courtier MQTT brumeux pour la premi√®re fois, et en cas d'√©chec, pour se connecter au courtier MQTT dans le cloud.  Cette solution n'est que l'une des nombreuses fonctionnalit√©s des syst√®mes IoT-F2C. <br><br><h3>  Solutions multiprotocoles </h3><br>  Les solutions √† protocole unique sont populaires en raison de leur mise en ≈ìuvre plus facile.  Mais il est √©vident que dans les syst√®mes IoT-F2C, il est logique de combiner diff√©rents protocoles.  Le fait est que diff√©rents protocoles peuvent fonctionner √† diff√©rents niveaux.  Prenons, par exemple, trois abstractions: IoT, fog et cloud computing.  Les appareils IoT sont g√©n√©ralement consid√©r√©s comme limit√©s.  Pour cette revue, regardons les niveaux IoT comme les plus limit√©s, le cloud le moins limit√© et le calcul du brouillard comme ¬´quelque part au milieu¬ª.  Il s'av√®re ensuite qu'entre l'IoT et les abstractions de brouillard, les d√©cisions de protocole actuelles incluent MQTT, CoAP et XMPP.  Entre le brouillard et le cloud, d'autre part, AMQP est l'un des principaux protocoles utilis√©s avec HTTP REST, qui en raison de sa flexibilit√© est √©galement utilis√© entre l'IoT et les couches de brouillard. <br><br>  Le probl√®me principal ici est l'interop√©rabilit√© des protocoles et la simplicit√© de traduction des messages d'un protocole √† l'autre.  Id√©alement, √† l'avenir, l'architecture du syst√®me IoT avec des ressources cloud et de brouillard sera ind√©pendante du protocole de communication utilis√© et fournira une bonne interop√©rabilit√© entre les diff√©rents protocoles. <br><br><img src="https://habrastorage.org/webt/yl/p7/xr/ylp7xrpyjurp0kczobbyoia62jk.jpeg"><br><br>  Comme ce n'est pas le cas pour le moment, il est logique de combiner des protocoles qui ne pr√©sentent pas de diff√©rences significatives.  √Ä cette fin, une solution potentielle est bas√©e sur une combinaison de deux protocoles qui adh√®rent au m√™me style architectural, REST HTTP et CoAP.  Une autre solution propos√©e est bas√©e sur une combinaison de deux protocoles offrant une interaction publication-abonnement, MQTT et AMQP.  L'utilisation de concepts proches (MQTT et AMQP utilisent des courtiers, CoAP et HTTP utilisent REST), simplifie la mise en ≈ìuvre de ces combinaisons et n√©cessite moins d'efforts d'int√©gration. <br><br><img src="https://habrastorage.org/webt/8p/sf/nf/8psfnfqz8nru91-zhamwpurr8ce.png"><br><br>  La figure (a) montre deux mod√®les bas√©s sur la demande-r√©ponse, HTTP et CoAP, et leur placement possible dans la solution IoT-F2C.  HTTP           , ,         .  ,   ,      , REST HTTP   . <br><br>   ,      ,       IoT,    CoAP.     CoAP        HTTP,        REST. <br><br>   ()     ¬´-¬ª   ,  MQTT  AMQP.              ,       . MQTT           ,        IoT  . AMQP      ,          .  MQTT  IoT    XMPP,     .         . <br><br><h3>  Conclusions </h3><br> ,             ,           .  ,     ,    ,  MQTT  RESTful HTTP.          ,             -. <br><br>      , MQTT  ,             IoT   .   ,         , ,        , RESTful HTTP   . CoAP     ,          IoT,   ,          ,  MQTT  HTTP.    ,      . <br><br> <b>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cloud4Y</a></b> <br><br> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a> <br> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AI    </a> <br> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  .      </a> <br> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4      </a> <br> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    ,    </a> <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Telegram</a> -,     !           . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467711/">https://habr.com/ru/post/fr467711/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467699/index.html">Comment ne pas faire le strlen le plus rapide et trouver une faille dans la communaut√© Visual Studio 2019</a></li>
<li><a href="../fr467701/index.html">Cat√©gories au lieu de r√©pertoires. Un outil pour un stockage de fichiers pratique</a></li>
<li><a href="../fr467703/index.html">IT Africa: les entreprises technologiques et les startups les plus int√©ressantes du continent</a></li>
<li><a href="../fr467705/index.html">Paramagnons et magnons: l'√©nergie de la chaleur</a></li>
<li><a href="../fr467707/index.html">Comment configurer Linux pour entrer dans le domaine √† l'aide des algorithmes GOST</a></li>
<li><a href="../fr467719/index.html">Une fa√ßon d'obtenir l'historique des verrous dans PostgreSQL</a></li>
<li><a href="../fr467723/index.html">Check Point Gaia R80.40. Qu'est-ce qui sera nouveau?</a></li>
<li><a href="../fr467727/index.html">Salut, SaaS | Tendances SaaS 2019 par Blissfully</a></li>
<li><a href="../fr467729/index.html">Chips ou ride? Petites choses uniques dans les smartphones</a></li>
<li><a href="../fr467733/index.html">En tant que d√©veloppeur, je ne connais jamais ma propre valeur, car il n'y en a pas. Mais tout le syst√®me est construit comme s'il √©tait</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>