<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽 🚎 😉 Dukungan untuk instruksi khusus peranti keras di .NET Core (sekarang bukan hanya SIMD) 💪🏻 🗣️ 🔓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Beberapa tahun yang lalu, kami memutuskan bahwa sudah waktunya untuk mendukung kode SIMD di .NET . Kami memperkenalkan System.Numerics...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dukungan untuk instruksi khusus peranti keras di .NET Core (sekarang bukan hanya SIMD)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/467663/"><h2 id="vvedenie">  Pendahuluan </h2><br><p> Beberapa tahun yang lalu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kami memutuskan bahwa sudah waktunya untuk mendukung kode SIMD di .NET</a> .  Kami memperkenalkan <code>System.Numerics</code> namespace dengan tipe <code>Vector2</code> , <code>Vector3</code> , <code>Vector4</code> dan <code>Vector&lt;T&gt;</code> .  Jenis-jenis ini mewakili API tujuan umum untuk membuat, mengakses, dan memanipulasi instruksi vektor bila memungkinkan.  Mereka juga menyediakan kompatibilitas perangkat lunak untuk kasus-kasus di mana perangkat keras tidak mendukung instruksi yang sesuai.  Ini memungkinkan, dengan refactoring minimal, untuk membuat vektor sejumlah algoritma.  Namun, secara umum pendekatan ini mempersulit penerapan untuk mendapatkan keuntungan penuh dari semua yang tersedia, pada perangkat keras modern, instruksi vektor.  Selain itu, perangkat keras modern menyediakan sejumlah instruksi khusus, non-vektor, yang dapat secara signifikan meningkatkan kinerja.  Pada artikel ini, saya akan berbicara tentang bagaimana kami menghindari batasan-batasan ini dalam .NET Core 3.0. </p><br><p><img src="https://habrastorage.org/webt/4d/mx/lt/4dmxlt8xgnpgncvellsujvoe_rk.jpeg"><br>  <strong>Catatan: Belum</strong> <em>ada istilah untuk terjemahan <strong>Intrisics</strong> .</em>  <em>Di akhir artikel ada suara untuk opsi terjemahan.</em>  <em>Jika kami memilih opsi yang baik, kami akan mengubah artikel</em> </p><a name="habracut"></a><br><h2 id="chto-takoe-vstroennye-funkcii">  Apa fungsi bawaan </h2><br><p>  Di .NET Core 3.0, kami menambahkan fungsionalitas baru yang disebut fungsi bawaan <em>perangkat keras khusus</em> (WF jauh).  <em>Fungsionalitas</em> ini menyediakan akses ke banyak instruksi perangkat keras tertentu yang tidak dapat hanya diwakili oleh mekanisme tujuan umum.  Mereka berbeda dari instruksi SIMD yang ada dalam hal mereka tidak memiliki tujuan umum ( <em>WF</em> baru bukan lintas platform dan arsitektur mereka tidak memberikan kompatibilitas perangkat lunak).  Sebagai gantinya, mereka secara langsung menyediakan fungsionalitas platform dan perangkat keras khusus untuk pengembang .NET.  Fungsi SIMD yang ada, misalnya, lintas platform, memberikan kompatibilitas perangkat lunak, dan sedikit disarikan dari perangkat keras yang mendasarinya.  Abstraksi ini bisa mahal, selain itu, dapat mencegah pengungkapan beberapa fungsionalitas (ketika, misalnya, fungsionalitas tidak ada, atau sulit untuk ditiru pada semua platform target). </p><br><p>  <em>Fungsi bawaan baru</em> , dan tipe yang didukung, terletak di bawah <code>System.Runtime.Intrinsics</code> .  Untuk .NET Core 3.0, saat ini, ada satu <code>System.Runtime.Intrinsics.X86</code> .  Kami sedang berupaya mendukung <em>fungsi bawaan</em> untuk platform lain seperti <code>System.Runtime.Intrinsics.Arm</code> . </p><br><p>  Di bawah ruang nama khusus platform, <em>WF</em> dikelompokkan ke dalam kelas yang mewakili kelompok instruksi perangkat keras yang terintegrasi secara logis (sering disebut arsitektur set instruksi (ISA)).  Setiap kelas menyediakan properti <code>IsSupported</code> menunjukkan apakah perangkat keras yang menjalankan kode mendukung set instruksi ini.  Selanjutnya, setiap kelas tersebut berisi serangkaian metode yang dipetakan ke serangkaian instruksi yang sesuai.  Kadang-kadang ada subkelas tambahan yang sesuai dengan bagian dari set instruksi yang sama, yang mungkin dibatasi (didukung) oleh perangkat keras tertentu.  Sebagai contoh, kelas <code>Lzcnt</code> menyediakan akses ke <em>instruksi untuk menghitung nol terkemuka</em> .  Dia memiliki subclass yang disebut <code>X64</code> , yang berisi bentuk instruksi ini hanya digunakan pada mesin dengan arsitektur 64-bit. </p><br><p>  Beberapa kelas ini secara alami bersifat hierarkis.  Misalnya, jika <code>Lzcnt.X64.IsSupported</code> mengembalikan true, maka <code>Lzcnt.IsSupported</code> juga harus mengembalikan true, karena ini adalah subkelas eksplisit.  Atau, misalnya, jika <code>Sse2.IsSupported</code> mengembalikan true, maka <code>Sse.IsSupported</code> harus mengembalikan true, karena <code>Sse2</code> secara eksplisit mewarisi dari <code>Sse</code> .  Namun, perlu dicatat bahwa kesamaan nama kelas bukan merupakan indikator milik mereka dalam hierarki warisan yang sama.  Misalnya, <code>Bmi2</code> tidak diwarisi dari <code>Bmi1</code> , sehingga nilai yang dikembalikan oleh <code>IsSupported</code> untuk dua set instruksi ini akan berbeda.  Prinsip dasar dalam pengembangan kelas-kelas ini adalah presentasi eksplisit spesifikasi ISA.  SSE2 membutuhkan dukungan untuk SSE1, sehingga kelas yang mewakilinya terkait dengan warisan.  Pada saat yang sama, BMI2 tidak memerlukan dukungan untuk BMI1, jadi kami tidak menggunakan warisan.  Berikut ini adalah contoh dari API di atas. </p><br><pre> <code class="plaintext hljs">namespace System.Runtime.Intrinsics.X86 { public abstract class Sse { public static bool IsSupported { get; } public static Vector128&lt;float&gt; Add(Vector128&lt;float&gt; left, Vector128&lt;float&gt; right); // Additional APIs public abstract class X64 { public static bool IsSupported { get; } public static long ConvertToInt64(Vector128&lt;float&gt; value); // Additional APIs } } public abstract class Sse2 : Sse { public static new bool IsSupported { get; } public static Vector128&lt;byte&gt; Add(Vector128&lt;byte&gt; left, Vector128&lt;byte&gt; right); // Additional APIs public new abstract class X64 : Sse.X64 { public static bool IsSupported { get; } public static long ConvertToInt64(Vector128&lt;double&gt; value); // Additional APIs } } }</code> </pre> <br><p>  Anda dapat melihat lebih banyak di kode sumber di tautan berikut <a href="">source.dot.net atau dotnet / coreclr di GitHub</a> </p><br><p>  Pemeriksaan <code>IsSupported</code> diproses oleh kompiler JIT sebagai konstanta runtime (ketika optimasi diaktifkan), sehingga Anda tidak perlu kompilasi silang untuk mendukung beberapa ISA, platform, atau arsitektur.  Sebagai gantinya, Anda hanya perlu menulis kode menggunakan ekspresi <code>if</code> , akibatnya cabang kode yang tidak digunakan (mis. Cabang-cabang yang tidak dapat dijangkau karena nilai variabel dalam pernyataan kondisional) akan dibuang ketika kode asli dihasilkan. </p><br><p>  Penting bahwa verifikasi <code>IsSupported</code> sesuai mendahului penggunaan perintah perangkat keras <code>IsSupported</code> .  Jika tidak ada pemeriksaan seperti itu, maka kode menggunakan perintah khusus platform yang berjalan pada platform / arsitektur di mana perintah ini tidak didukung akan melempar pengecualian runtime <code>PlatformNotSupportedException</code> . </p><br><h2 id="kakie-preimuschestva-oni-dayut">  Apa manfaat yang mereka berikan? </h2><br><p>  Tentu saja, <em>fungsi bawaan perangkat keras khusus</em> tidak untuk semua orang, tetapi mereka dapat digunakan untuk meningkatkan kinerja dalam operasi yang sarat dengan perhitungan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>ML.NET</code></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>ML.NET</code></a> menggunakan metode ini untuk mempercepat operasi seperti menyalin di memori, mencari indeks elemen dalam array atau string, mengubah ukuran gambar, atau bekerja dengan vektor / matriks / tensor.  Vektorisasi manual dari beberapa kode yang ternyata menjadi hambatan juga bisa lebih sederhana daripada yang terdengar.  Vektorisasi kode, pada kenyataannya, adalah untuk melakukan beberapa operasi pada suatu waktu, secara umum, menggunakan instruksi SIMD (satu aliran instruksi, banyak aliran data). </p><br><p>  Sebelum Anda memutuskan untuk membuat vektor beberapa kode, Anda perlu melakukan profil untuk memastikan bahwa kode ini benar-benar bagian dari "hot spot" (dan, oleh karena itu, optimasi Anda akan memberikan peningkatan kinerja yang signifikan).  Penting juga untuk melakukan profil pada setiap tahap vektorisasi, karena vektorisasi tidak semua kode mengarah pada peningkatan produktivitas. </p><br><h2 id="vektorizaciya-prostogo-algoritma">  Vektorisasi dari algoritma sederhana </h2><br><p>  Untuk menggambarkan penggunaan <em>fungsi bawaan,</em> kami menggunakan algoritme untuk menjumlahkan semua elemen array atau rentang.  Jenis kode ini adalah kandidat yang ideal untuk vektorisasi, karena  pada setiap iterasi, operasi sepele yang sama dilakukan. </p><br><p>  Contoh implementasi dari algoritma semacam itu mungkin terlihat sebagai berikut: </p><br><pre> <code class="plaintext hljs">public int Sum(ReadOnlySpan&lt;int&gt; source) { int result = 0; for (int i = 0; i &lt; source.Length; i++) { result += source[i]; } return result; }</code> </pre> <br><p>  Kode ini cukup sederhana dan mudah, tetapi pada saat yang sama cukup lambat untuk data input besar, seperti  tidak hanya satu operasi sepele per iterasi. </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.11.5, OS=Windows 10.0.18362 AMD Ryzen 7 1800X, 1 CPU, 16 logical and 8 physical cores .NET Core SDK=3.0.100-preview9-013775 [Host] : .NET Core 3.0.0-preview9-19410-10 (CoreCLR 4.700.19.40902, CoreFX 4.700.19.40917), 64bit RyuJIT [AttachedDebugger] DefaultJob : .NET Core 3.0.0-preview9-19410-10 (CoreCLR 4.700.19.40902, CoreFX 4.700.19.40917), 64bit RyuJIT</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  Hitung </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Jumlah </td><td>  1 </td><td>  2,477 ns </td><td>  0,0192 ns </td><td>  0,0179 ns </td></tr><tr><td>  Jumlah </td><td>  2 </td><td>  2.164 ns </td><td>  0,0265 ns </td><td>  0,0235 ns </td></tr><tr><td>  Jumlah </td><td>  4 </td><td>  3,224 ns </td><td>  0,0302 ns </td><td>  0,0267 ns </td></tr><tr><td>  Jumlah </td><td>  8 </td><td>  4.347 ns </td><td>  0,0665 ns </td><td>  0,0622 ns </td></tr><tr><td>  Jumlah </td><td>  16 </td><td>  8,444 ns </td><td>  0,2042 ns </td><td>  0,3734 ns </td></tr><tr><td>  Jumlah </td><td>  32 </td><td>  13.963 ns </td><td>  0,2182 ns </td><td>  0,2041 ns </td></tr><tr><td>  Jumlah </td><td>  64 </td><td>  50,344 ns </td><td>  0,2955 ns </td><td>  0,2620 ns </td></tr><tr><td>  Jumlah </td><td>  128 </td><td>  60.139 ns </td><td>  0,3890 ns </td><td>  0,3639 ns </td></tr><tr><td>  Jumlah </td><td>  256 </td><td>  106,416 ns </td><td>  0,6404 ns </td><td>  0,5990 ns </td></tr><tr><td>  Jumlah </td><td>  512 </td><td>  291.450 ns </td><td>  3.5148 ns </td><td>  3,2878 ns </td></tr><tr><td>  Jumlah </td><td>  1024 </td><td>  574.243 ns </td><td>  9.5851 ns </td><td>  8,4970 ns </td></tr><tr><td>  Jumlah </td><td>  2048 </td><td>  1 137.819 ns </td><td>  5,9363 ns </td><td>  5,5529 ns </td></tr><tr><td>  Jumlah </td><td>  4096 </td><td>  2 228.341 ns </td><td>  22.8882 ns </td><td>  21.4097 ns </td></tr><tr><td>  Jumlah </td><td>  8192 </td><td>  2 973.040 ns </td><td>  14.2863 ns </td><td>  12.6644 ns </td></tr><tr><td>  Jumlah </td><td>  16384 </td><td>  5 883.504 ns </td><td>  15.9619 ns </td><td>  14.9308 ns </td></tr><tr><td>  Jumlah </td><td>  32768 </td><td>  11 699.237 ns </td><td>  104.0970 ns </td><td>  97.3724 ns </td></tr></tbody></table></div><br><h2 id="povyshenie-proizvoditelnosti-za-schet-razvertyvaniya-ciklov">  Tingkatkan Produktivitas Melalui Siklus Penempatan </h2><br><p>  Prosesor modern memiliki berbagai opsi untuk meningkatkan kinerja kode.  Untuk aplikasi single-threaded, salah satu opsi tersebut adalah melakukan beberapa operasi primitif dalam satu siklus prosesor. </p><br><p>  Sebagian besar prosesor modern dapat melakukan empat operasi tambahan dalam satu siklus clock (dalam kondisi optimal), sebagai akibatnya, dengan "tata letak" kode yang benar, Anda kadang-kadang dapat meningkatkan kinerja, bahkan dalam implementasi single-threaded. </p><br><p>  Meskipun JIT dapat melakukan loop unrolling sendiri, JIT konservatif dalam membuat keputusan semacam ini, karena ukuran kode yang dihasilkan.  Oleh karena itu, mungkin menguntungkan untuk menggunakan loop, dalam kode, secara manual. </p><br><p>  Anda dapat memperluas loop dalam kode di atas sebagai berikut: </p><br><pre> <code class="plaintext hljs">public unsafe int SumUnrolled(ReadOnlySpan&lt;int&gt; source) { int result = 0; int i = 0; int lastBlockIndex = source.Length - (source.Length % 4); // Pin source so we can elide the bounds checks fixed (int* pSource = source) { while (i &lt; lastBlockIndex) { result += pSource[i + 0]; result += pSource[i + 1]; result += pSource[i + 2]; result += pSource[i + 3]; i += 4; } while (i &lt; source.Length) { result += pSource[i]; i += 1; } } return result; }</code> </pre> <br><p>  Kode ini sedikit lebih rumit, tetapi lebih baik menggunakan fitur perangkat keras. </p><br><p>  Untuk loop yang sangat kecil, kode ini berjalan sedikit lebih lambat.  Tetapi tren ini sudah berubah untuk input data dari delapan elemen, setelah itu kecepatan eksekusi mulai meningkat (waktu eksekusi kode yang dioptimalkan, untuk 32 ribu elemen, lebih sedikit 26% dari waktu versi aslinya).  Perlu dicatat bahwa optimasi seperti itu tidak selalu meningkatkan produktivitas.  Misalnya, ketika bekerja dengan koleksi dengan elemen tipe <code>float</code> "yang digunakan" dari algoritma memiliki kecepatan yang hampir sama dengan yang asli.  Karena itu, sangat penting untuk melakukan profiling. </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  Hitung </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sumunrolled </td><td>  1 </td><td>  2,922 ns </td><td>  0,0651 ns </td><td>  0,0609 ns </td></tr><tr><td>  Sumunrolled </td><td>  2 </td><td>  3,576 ns </td><td>  0,0116 ns </td><td>  0,0109 ns </td></tr><tr><td>  Sumunrolled </td><td>  4 </td><td>  3,708 ns </td><td>  0,0157 ns </td><td>  0,0139 ns </td></tr><tr><td>  Sumunrolled </td><td>  8 </td><td>  4,832 ns </td><td>  0,0486 ns </td><td>  0,0454 ns </td></tr><tr><td>  Sumunrolled </td><td>  16 </td><td>  7,490 ns </td><td>  0,1131 ns </td><td>  0,1058 ns </td></tr><tr><td>  Sumunrolled </td><td>  32 </td><td>  11.277 ns </td><td>  0,0910 ns </td><td>  0,0851 ns </td></tr><tr><td>  Sumunrolled </td><td>  64 </td><td>  19.761 ns </td><td>  0,2016 ns </td><td>  0,1885 ns </td></tr><tr><td>  Sumunrolled </td><td>  128 </td><td>  36.639 ns </td><td>  0,3043 ns </td><td>  0,2847 ns </td></tr><tr><td>  Sumunrolled </td><td>  256 </td><td>  77.969 ns </td><td>  0,8409 ns </td><td>  0,7866 ns </td></tr><tr><td>  Sumunrolled </td><td>  512 </td><td>  146.357 ns </td><td>  1.3209 ns </td><td>  1.2356 ns </td></tr><tr><td>  Sumunrolled </td><td>  1024 </td><td>  287.354 ns </td><td>  0,9223 ns </td><td>  0,8627 ns </td></tr><tr><td>  Sumunrolled </td><td>  2048 </td><td>  566.405 ns </td><td>  4.0155 ns </td><td>  3,5596 ns </td></tr><tr><td>  Sumunrolled </td><td>  4096 </td><td>  1 131.016 ns </td><td>  7,3601 ns </td><td>  6.5246 ns </td></tr><tr><td>  Sumunrolled </td><td>  8192 </td><td>  2 259.836 ns </td><td>  8,6539 ns </td><td>  8.0949 ns </td></tr><tr><td>  Sumunrolled </td><td>  16384 </td><td>  4 501.295 ns </td><td>  6.4186 ns </td><td>  6,0040 ns </td></tr><tr><td>  Sumunrolled </td><td>  32768 </td><td>  8 979.690 ns </td><td>  19,5265 ns </td><td>  18.2651 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4b7/180/775/4b71807758bdae4be2fba1eb6af8360b.png"></p><br><h2 id="povyshenie-proizvoditelnosti-za-schet-vektorizacii-ciklov">  Tingkatkan produktivitas melalui vektorisasi loop </h2><br><p>  Meski begitu, tapi kami masih bisa sedikit mengoptimalkan kode ini.  Instruksi SIMD adalah opsi lain yang disediakan oleh prosesor modern untuk meningkatkan kinerja.  Menggunakan instruksi tunggal, mereka memungkinkan Anda untuk melakukan beberapa operasi dalam satu siklus clock tunggal.  Ini mungkin lebih baik daripada loop terbuka berlangsung, karena, pada kenyataannya, hal yang sama dilakukan, tetapi dengan jumlah yang lebih kecil dari kode yang dihasilkan. </p><br><p>  Untuk memperjelas, setiap operasi penambahan, dalam siklus yang digunakan, membutuhkan 4 byte.  Jadi, kita membutuhkan 16 byte untuk 4 operasi penambahan dalam bentuk diperluas.  Pada saat yang sama, instruksi penambahan SIMD juga melakukan 4 operasi tambahan, tetapi hanya membutuhkan 4 byte.  Ini berarti kami memiliki lebih sedikit instruksi untuk CPU.  Selain itu, dalam kasus instruksi SIMD, CPU dapat membuat <em>asumsi</em> dan melakukan optimasi, tetapi ini di luar ruang lingkup artikel ini.  Apa yang lebih baik adalah bahwa prosesor modern dapat menjalankan lebih dari satu instruksi SIMD pada suatu waktu, yaitu, dalam beberapa kasus, Anda dapat menerapkan strategi campuran, pada saat yang sama melakukan pemindaian siklus parsial dan vektorisasi. </p><br><p>  Secara umum, Anda harus mulai dengan melihat kelas tujuan umum <code>Vector&lt;T&gt;</code> untuk tugas Anda.  Dia, seperti <em>WF</em> baru, akan menanamkan instruksi SIMD, tetapi pada saat yang sama, mengingat keserbagunaan kelas ini, ia dapat mengurangi jumlah pengkodean "manual". </p><br><p>  Kode mungkin terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">public int SumVectorT(ReadOnlySpan&lt;int&gt; source) { int result = 0; Vector&lt;int&gt; vresult = Vector&lt;int&gt;.Zero; int i = 0; int lastBlockIndex = source.Length - (source.Length % Vector&lt;int&gt;.Count); while (i &lt; lastBlockIndex) { vresult += new Vector&lt;int&gt;(source.Slice(i)); i += Vector&lt;int&gt;.Count; } for (int n = 0; n &lt; Vector&lt;int&gt;.Count; n++) { result += vresult[n]; } while (i &lt; source.Length) { result += source[i]; i += 1; } return result; }</code> </pre> <br><p>  Kode ini bekerja lebih cepat, tetapi kami dipaksa untuk merujuk ke setiap elemen secara terpisah saat menghitung jumlah akhir.  Juga, <code>Vector&lt;T&gt;</code> tidak memiliki ukuran yang ditentukan secara tepat, dan dapat bervariasi, tergantung pada peralatan di mana kode berjalan.  <em>fungsi bawaan khusus perangkat keras</em> menyediakan <em>fungsionalitas</em> tambahan yang sedikit dapat meningkatkan kode ini dan membuatnya sedikit lebih cepat (dengan biaya kompleksitas kode tambahan dan persyaratan pemeliharaan). </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  Hitung </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th></tr></thead><tbody><tr><td>  SumVectorT </td><td>  1 </td><td>  4,517 ns </td><td>  0,0752 ns </td><td>  0,0703 ns </td></tr><tr><td>  SumVectorT </td><td>  2 </td><td>  4,853 ns </td><td>  0,0609 ns </td><td>  0,0570 ns </td></tr><tr><td>  SumVectorT </td><td>  4 </td><td>  5,047 ns </td><td>  0,0909 ns </td><td>  0,0850 ns </td></tr><tr><td>  SumVectorT </td><td>  8 </td><td>  5,671 ns </td><td>  0,0251 ns </td><td>  0,0223 ns </td></tr><tr><td>  SumVectorT </td><td>  16 </td><td>  6.579 ns </td><td>  0,0330 ns </td><td>  0,0276 ns </td></tr><tr><td>  SumVectorT </td><td>  32 </td><td>  10.460 ns </td><td>  0,0241 ns </td><td>  0,0226 ns </td></tr><tr><td>  SumVectorT </td><td>  64 </td><td>  17.148 ns </td><td>  0,0407 ns </td><td>  0,0381 ns </td></tr><tr><td>  SumVectorT </td><td>  128 </td><td>  23.239 ns </td><td>  0,0853 ns </td><td>  0,0756 ns </td></tr><tr><td>  SumVectorT </td><td>  256 </td><td>  62.146 ns </td><td>  0,8319 ns </td><td>  0,7782 ns </td></tr><tr><td>  SumVectorT </td><td>  512 </td><td>  114.863 ns </td><td>  0,4175 ns </td><td>  0,3906 ns </td></tr><tr><td>  SumVectorT </td><td>  1024 </td><td>  172.129 ns </td><td>  1,8673 ns </td><td>  1.7467 ns </td></tr><tr><td>  SumVectorT </td><td>  2048 </td><td>  429.722 ns </td><td>  1,0461 ns </td><td>  0,9786 ns </td></tr><tr><td>  SumVectorT </td><td>  4096 </td><td>  654.209 ns </td><td>  3,6215 ns </td><td>  3,0241 ns </td></tr><tr><td>  SumVectorT </td><td>  8192 </td><td>  1 675.046 ns </td><td>  14,5231 ns </td><td>  13,5849 ns </td></tr><tr><td>  SumVectorT </td><td>  16384 </td><td>  2 514.778 ns </td><td>  5.3369 ns </td><td>  4,9921 ns </td></tr><tr><td>  SumVectorT </td><td>  32768 </td><td>  6,689.829 ns </td><td>  13,9947 ns </td><td>  13.0906 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00e/0be/5d4/00e0be5d469067af095f34beccf8c45c.png"></p><br><p>  <em>CATATAN</em> Untuk artikel ini, saya secara paksa membuat ukuran <code>Vector&lt;T&gt;</code> sama dengan 16 byte menggunakan parameter konfigurasi internal ( <code>COMPlus_SIMD16ByteOnly=1</code> ).  Tweak ini menormalkan hasil ketika membandingkan <code>SumVectorT</code> dengan <code>SumVectorizedSse</code> , dan memungkinkan kami untuk menjaga kode tetap sederhana.  Secara khusus, ia menghindari penulisan lompatan bersyarat <code>if (Avx2.IsSupported) { }</code> .  Kode ini hampir identik dengan kode untuk <code>Sse2</code> , tetapi berkaitan dengan <code>Vector256&lt;T&gt;</code> (32-byte) dan memproses lebih banyak elemen dalam satu iterasi dari loop. </p><br><p>  Dengan demikian, menggunakan fungsi bawaan yang baru, kode dapat ditulis ulang sebagai berikut: </p><br><pre> <code class="plaintext hljs">public int SumVectorized(ReadOnlySpan&lt;int&gt; source) { if (Sse2.IsSupported) { return SumVectorizedSse2(source); } else { return SumVectorT(source); } } public unsafe int SumVectorizedSse2(ReadOnlySpan&lt;int&gt; source) { int result; fixed (int* pSource = source) { Vector128&lt;int&gt; vresult = Vector128&lt;int&gt;.Zero; int i = 0; int lastBlockIndex = source.Length - (source.Length % 4); while (i &lt; lastBlockIndex) { vresult = Sse2.Add(vresult, Sse2.LoadVector128(pSource + i)); i += 4; } if (Ssse3.IsSupported) { vresult = Ssse3.HorizontalAdd(vresult, vresult); vresult = Ssse3.HorizontalAdd(vresult, vresult); } else { vresult = Sse2.Add(vresult, Sse2.Shuffle(vresult, 0x4E)); vresult = Sse2.Add(vresult, Sse2.Shuffle(vresult, 0xB1)); } result = vresult.ToScalar(); while (i &lt; source.Length) { result += pSource[i]; i += 1; } } return result; }</code> </pre> <br><p>  Kode ini, sekali lagi, sedikit lebih rumit, tetapi secara signifikan lebih cepat untuk semua orang kecuali set input terkecil.  Untuk 32 ribu elemen, kode ini mengeksekusi 75% lebih cepat dari siklus yang diperluas, dan 81% lebih cepat dari kode sumber contoh. </p><br><p>  Anda perhatikan bahwa kami menulis beberapa cek yang <code>IsSupported</code> .  Yang pertama memeriksa apakah perangkat keras saat ini mendukung sekumpulan <em>fungsi</em> bawaan yang diperlukan, jika tidak, maka optimasi dilakukan melalui kombinasi sapuan dan <code>Vector&lt;T&gt;</code> .  Opsi terakhir akan dipilih untuk platform seperti ARM / ARM64 yang tidak mendukung set instruksi yang diperlukan, atau jika set telah dinonaktifkan untuk platform.  Tes <code>IsSupported</code> kedua, dalam metode <code>SumVectorizedSse2</code> , digunakan untuk optimasi tambahan jika perangkat keras mendukung <code>Ssse3</code> instruksi <code>Ssse3</code> . </p><br><p>  Jika tidak, sebagian besar logikanya pada dasarnya sama dengan loop yang diperluas.  <code>Vector128&lt;T&gt;</code> adalah tipe 128-bit yang mengandung <code>Vector128&lt;T&gt;.Count</code> .  Dalam hal ini, <code>uint</code> , yang itu sendiri adalah 32-bit, dapat memiliki 4 (128/32) elemen, ini adalah bagaimana kami meluncurkan loop. </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  Hitung </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Dirangkum </td><td>  1 </td><td>  4,555 ns </td><td>  0,0192 ns </td><td>  0,0179 ns </td></tr><tr><td>  Dirangkum </td><td>  2 </td><td>  4,848 ns </td><td>  0,0147 ns </td><td>  0,0137 ns </td></tr><tr><td>  Dirangkum </td><td>  4 </td><td>  5,381 ns </td><td>  0,0210 ns </td><td>  0,0186 ns </td></tr><tr><td>  Dirangkum </td><td>  8 </td><td>  4,838 ns </td><td>  0,0209 ns </td><td>  0,0186 ns </td></tr><tr><td>  Dirangkum </td><td>  16 </td><td>  5.107 ns </td><td>  0,0175 ns </td><td>  0,0146 ns </td></tr><tr><td>  Dirangkum </td><td>  32 </td><td>  5,646 ns </td><td>  0,0230 ns </td><td>  0,0204 ns </td></tr><tr><td>  Dirangkum </td><td>  64 </td><td>  6,763 ns </td><td>  0,0338 ns </td><td>  0,0316 ns </td></tr><tr><td>  Dirangkum </td><td>  128 </td><td>  9.308 ns </td><td>  0,1041 ns </td><td>  0,0870 ns </td></tr><tr><td>  Dirangkum </td><td>  256 </td><td>  15.634 ns </td><td>  0,0927 ns </td><td>  0,0821 ns </td></tr><tr><td>  Dirangkum </td><td>  512 </td><td>  34,706 ns </td><td>  0,2851 ns </td><td>  0,2381 ns </td></tr><tr><td>  Dirangkum </td><td>  1024 </td><td>  68.110 ns </td><td>  0,4016 ns </td><td>  0,3756 ns </td></tr><tr><td>  Dirangkum </td><td>  2048 </td><td>  136.533 ns </td><td>  1.3104 ns </td><td>  1.2257 ns </td></tr><tr><td>  Dirangkum </td><td>  4096 </td><td>  277.930 ns </td><td>  0,5913 ns </td><td>  0,5531 ns </td></tr><tr><td>  Dirangkum </td><td>  8192 </td><td>  554.720 ns </td><td>  3,5133 ns </td><td>  3,2864 ns </td></tr><tr><td>  Dirangkum </td><td>  16384 </td><td>  1 110.730 ns </td><td>  3,3043 ns </td><td>  3.0909 ns </td></tr><tr><td>  Dirangkum </td><td>  32768 </td><td>  2 200,996 ns </td><td>  21.0538 ns </td><td>  19.6938 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/311/e70/320/311e7032050337fe946103244e749076.png"></p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  <em>Fungsi</em> bawaan yang baru memberi Anda kesempatan untuk memanfaatkan fungsionalitas khusus perangkat keras dari mesin tempat Anda menjalankan kode.  Ada sekitar 1.500 API untuk X86 dan X64 yang didistribusikan lebih dari 15 set, ada terlalu banyak untuk dijelaskan dalam satu artikel.  Dengan membuat profil kode untuk mengidentifikasi kemacetan, Anda dapat menentukan bagian dari kode yang mendapat manfaat dari vektorisasi dan mengamati peningkatan kinerja yang cukup baik.  Ada banyak skenario di mana vektorisasi dapat diterapkan dan loop unfolding hanyalah awal. </p><br><p>  Siapa pun yang ingin melihat lebih banyak contoh dapat mencari penggunaan <em>fungsi</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bawaan</a> dalam kerangka kerja (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotnet</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aspnet</a> ), atau di artikel komunitas lainnya.  Dan meskipun <em>WF</em> saat ini sangat luas, masih ada banyak fungsi yang perlu diperkenalkan.  Jika Anda memiliki fungsi yang ingin Anda perkenalkan, jangan ragu untuk mendaftarkan permintaan API Anda melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotnet / corefx di GitHub</a> .  Proses peninjauan API dijelaskan di <a href="">sini</a> dan ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh yang bagus</a> dari templat permintaan API yang ditentukan pada langkah 1. </p><br><h2 id="osobye-blagodarnosti">  Terima kasih khusus </h2><br><p>  Saya ingin menyampaikan terima kasih khusus kepada anggota komunitas kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fei Peng (@fiigii)</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jacek Blaszczynski (@ 4creators)</a> atas bantuan mereka dalam mengimplementasikan <em>WF</em> , serta kepada semua anggota komunitas atas umpan balik yang berharga mengenai pengembangan, implementasi dan kemudahan penggunaan fungsi ini. </p><br><hr><br><h3 id="posleslovie-k-perevodu">  Kata penutup untuk terjemahan </h3><br><p>  Saya suka mengamati perkembangan platform .NET, dan, khususnya, bahasa C #.  Berasal dari dunia C ++, dan memiliki sedikit pengalaman berkembang di Delphi dan Java, saya sangat nyaman memulai program menulis dalam C #.  Pada tahun 2006, bahasa pemrograman ini (yaitu bahasa itu) bagi saya lebih ringkas dan praktis daripada Jawa dalam dunia pengumpulan sampah yang dikelola dan lintas-platform.  Karena itu, pilihan saya jatuh pada C #, dan saya tidak menyesalinya.  Tahap pertama dalam evolusi suatu bahasa hanyalah penampilannya.  Pada tahun 2006, C # menyerap semua yang terbaik pada waktu itu dalam bahasa dan platform terbaik: C ++ / Java / Delphi.  Pada 2010, F # go public.  Itu adalah platform eksperimental untuk mempelajari paradigma fungsional dengan tujuan memperkenalkannya ke dunia .NET.  Hasil percobaan adalah tahap berikutnya dalam evolusi C # - perluasan kemampuannya terhadap FP, melalui pengenalan fungsi anonim, ekspresi lambda, dan, pada akhirnya, LINQ.  Perpanjangan bahasa ini menjadikan C # yang paling canggih, dari sudut pandang saya, bahasa tujuan umum.  Langkah evolusi selanjutnya terkait dengan mendukung konkurensi dan asinkron.  Tugas / Tugas &lt;T&gt;, seluruh konsep TPL, pengembangan LINQ - PLINQ, dan, akhirnya, async / menunggu.  ,   - ,       .NET   C# —      .    Span&lt;T&gt;  Memory&lt;T&gt;, ValueTask/ValueTask&lt;T&gt;, IAsyncDispose, ref readonly struct   in,  foreach, IO.Streams.         GC    .   ,       —       .  ,     .NET   C#,  ,          .   (       )         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467663/">https://habr.com/ru/post/id467663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467653/index.html">Habrastatistics: menganalisis komentar pembaca</a></li>
<li><a href="../id467655/index.html">Bagaimana saya menghabiskan musim panas dengan C # 8</a></li>
<li><a href="../id467657/index.html">Inventarisasi dari I hingga Z. Kami menghitung lisensi perangkat lunak</a></li>
<li><a href="../id467659/index.html">Secara signifikan mempercepat pelaksanaan tugas dengan contoh konfigurasi tambahan memori HyperX FURY DDR4 yang diperbarui</a></li>
<li><a href="../id467661/index.html">Dosimeter untuk Seryozha. Bagian I. Polimaster - Pemburu Nuclide</a></li>
<li><a href="../id467665/index.html">Troli truk ROS. Bagian 5. Bekerja di rviz dan gazebo: xacro, sensor baru</a></li>
<li><a href="../id467667/index.html">Perencanaan Proyek Organisasi (Bagian 4)</a></li>
<li><a href="../id467669/index.html">Tonton saya secara penuh: peras video langsung paling banyak di platform seluler</a></li>
<li><a href="../id467671/index.html">Komputer NLX Retro</a></li>
<li><a href="../id467673/index.html">Fitur Go bawaan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>