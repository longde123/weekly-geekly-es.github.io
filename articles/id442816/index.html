<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⁉️ 👩‍✈️ 👒 Buat pengontrol gim Anda sendiri 🛐 👩‍❤️‍💋‍👨 👂🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sumber inspirasi 
 Di pameran game, pengembang Object in Space menunjukkan demo permainan mereka dengan pengontrol di kokpit pesawat ruang angkasa bes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buat pengontrol gim Anda sendiri</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442816/"><h2>  Sumber inspirasi </h2><br>  Di pameran game, pengembang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">Object in Space</a> menunjukkan demo permainan mereka dengan pengontrol di kokpit pesawat ruang angkasa besar.  Itu dilengkapi dengan tombol menerangi, perangkat analog, indikator lampu status, switch, dll ... Ini sangat mempengaruhi perendaman dalam permainan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/44d/1ad/e9644d1ad417a9a97f888feea64d0e8a.jpg"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">Tutorial Arduino telah</a> diposting di situs web game dengan deskripsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">protokol komunikasi</a> untuk pengontrol seperti itu. <br><br>  <strong>Saya ingin membuat yang sama untuk permainan saya</strong> <br><br>  Dalam contoh ini, saya akan menghabiskan sekitar $ 40 untuk menambahkan saklar yang indah, besar dan berat ke kokpit simulator balap.  Biaya utama terkait dengan sakelar ini - jika saya menggunakan sakelar / tombol sederhana, harganya akan setengahnya!  Ini adalah peralatan nyata yang dapat menahan daya 240 watt, dan saya hanya akan mengeluarkan sekitar 0,03 watt. <br><br>  Peringatan: Saya memutuskan untuk menghemat uang, jadi saya meninggalkan tautan ke situs web China yang murah tempat saya membeli banyak komponen / alat yang berbeda.  Salah satu kelemahan dari membeli komponen murah adalah seringnya mereka tidak memiliki dokumentasi, jadi pada artikel ini saya akan menyelesaikan masalah ini. <br><a name="habracut"></a><br><h2>  Komponen utama </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">Arduino Mega2560</a> - $ 9 <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">Panel Balap Ignition Switch</a> - $ 26 <br></li><li>  Sekelompok kabel penghubung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">"pria ke pria"</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">"pria ke wanita"</a> , dll ...) - $ 2 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/e18/fb6/f5ce18fb6e69f6d2dd322d5295a8c7db.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c43/2d0/b89/c432d0b89b271194d7e3c72a96f4a458.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/485/de1/454485de13be106ba6733352efa8c249.jpg"></div><br><h2>  Alat Unggulan </h2><br><ul><li>  Menyolder besi ( <em>ada baiknya memilih yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagus</a> , tetapi juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">murah untuk</a> mengatasi pekerjaan</em> ) </li><li>  Solder ( <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan rosin 60/40</a> - mudah digunakan, meskipun berbahaya bagi lingkungan</em> .) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Heat shrink tubing</a> ( <em>dan pengering rambut industri, pengering rambut, atau pemantik</em> ) atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pita listrik</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lem pistol</a> ( <em>dan tongkat untuk itu</em> ), atau semacam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">epoksi</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Multimeter</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jepit / tang untuk pengupasan kabel</a> , atau hanya gunting, jika Anda perlu menghemat uang. </li></ul><br><h2>  Perangkat lunak </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">Arduino IDE</a> untuk pemrograman prosesor Arduino </li><li>  Untuk membuat pengontrol yang muncul sebagai pengontrol / joystick USB nyata: <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">FLIP</a> untuk menginstal firmware baru di pengontrol USB Arduino </li><li>  Perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">Arduino-usb</a> di github </li></ul></li><li>  Untuk membuat pengontrol yang berkomunikasi game secara langsung ( <em>atau yang muncul sebagai pengontrol / joystick USB virtual</em> ) <ul><li>  Perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">ois_protocol</a> saya di github <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">Driver VJoy</a> jika Anda ingin menggunakan controller sebagai pengendali USB virtual / joystick. </li></ul></li></ul><br><h2>  Peringatan </h2><br>  Saya belajar elektronik di sekolah menengah, belajar cara menggunakan besi solder, belajar bahwa kabel merah harus terhubung ke merah, dan hitam ke hitam ... Volts, ampere, resistance dan persamaan yang menghubungkan mereka - itu saja yang pelatihan formal saya di elektronik telah habis. <br><br>  Bagi saya itu adalah proyek pelatihan, jadi mungkin ada saran atau kesalahan buruk! <br><br><h1>  Bagian 1. Menyatukan pengontrol! </h1><br><h2>  Kami bekerja dengan sakelar tanpa dokumentasi ... </h2><br>  Seperti yang dinyatakan di atas, saya membeli suku cadang murah dari pengecer dengan margin rendah, jadi hal pertama yang harus dilakukan adalah mencari tahu bagaimana sakelar / tombol ini bekerja. <br><br><h3>  Tombol / sakelar sederhana </h3><br>  Dengan tombol, semuanya sederhana - tidak ada LED di dalamnya dan hanya dua kontak.  Alihkan multimeter ke mode kontinuitas / panggilan ( <img src="https://habrastorage.org/getpro/habr/post_images/628/15d/e9f/62815de9fa4516b533fa2a44197455da.gif">  ) dan sentuh probe dari kontak yang berbeda - OL (loop terbuka, sirkuit terbuka) akan ditampilkan di layar: ini berarti tidak ada koneksi antara kedua probe.  Kemudian kami menekan tombol, masih menyentuh probe kontak - sesuatu seperti 0.1Ω sekarang akan muncul di layar dan multimeter akan mulai berbunyi bip ( <em>menunjukkan bahwa ada resistansi yang sangat rendah antara probe - sirkuit tertutup</em> ). <br><br>  Sekarang kita tahu bahwa ketika tombol ditekan, sirkuit menutup, dan ketika ditekan, itu terbuka.  Dalam diagram, ini dapat digambarkan sebagai saklar sederhana: <img src="https://habrastorage.org/getpro/habr/post_images/ff1/078/8d9/ff10788d996450509595baba45cad58e.png"><br><br><h2>  Kami menghubungkan sakelar ke Arduino </h2><br>  Temukan dua pin pada papan Arduino: berlabel GND dan berlabel "2" (atau nomor sewenang-wenang lainnya - ini adalah pin I / O tujuan umum yang dapat kita kontrol melalui perangkat lunak). <br><br>  Jika kita menghubungkan saklar dengan cara ini, dan kemudian kita memesan Arduino untuk mengkonfigurasi pin "2" sebagai pin INPUT, kita mendapatkan sirkuit yang ditunjukkan di sebelah kiri (pada gambar di bawah).  Ketika tombol ditekan, pin 2 akan langsung terhubung ke ground / 0V, dan ketika ditekan, pin 2 tidak akan terhubung ke apa pun.  Keadaan ini ( <em>tidak terhubung dengan apa pun</em> ) disebut "mengambang" (keadaan impedansi tinggi) dan, sayangnya, ini bukan kondisi yang sangat baik untuk tujuan kami.  Ketika kami membaca data dari kontak di perangkat lunak ( <em>menggunakan digitalRead (2)</em> ), kami mendapatkan RENDAH jika kontak di-ground, dan hasil yang tidak terduga (RENDAH atau TINGGI) jika kontaknya mengambang! <br><br>  Untuk memperbaikinya, kita dapat mengonfigurasi kontak agar berada dalam mode INPUT_PULLUP, yang terhubung ke resistor di dalam prosesor dan membuat sirkuit yang ditunjukkan di sebelah kanan.  Di sirkuit ini, dengan sakelar terbuka, pin 2 memiliki lintasan + 5V, jadi ketika terbaca, hasilnya akan selalu TINGGI.  Ketika sakelar ditutup, kontak masih akan memiliki jalur dengan resistansi tinggi ke + 5V, serta jalur tanpa resistansi ke ground / 0V, yang “menang”, jadi ketika kita membaca kontak, kita mendapatkan RENDAH. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/a26/fa9/450a26fa93dae881e4f2aca3f68d52ad.png"></div><br>  Untuk pengembang perangkat lunak, urutannya mungkin terbalik - ketika kita mengklik tombol, kita membaca false / LOW, dan ketika tertekan, kita membaca true / HIGH. <br><br>  Anda dapat melakukan yang sebaliknya, tetapi prosesor hanya memiliki resistor pull-up bawaan dan tidak ada resistor pull-down, jadi kami akan tetap menggunakan model ini. <br><br>  Program paling sederhana untuk Arduino, yang membaca status sakelar dan memberi tahu PC tentang statusnya, terlihat seperti yang ditunjukkan di bawah ini.  Anda dapat mengklik tombol unduh di IDE Arduino dan kemudian membuka Serial Monitor (di menu Tools) untuk melihat hasilnya. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Serial.begin(<span class="hljs-number"><span class="hljs-number">9600</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">2</span></span>, INPUT_PULLUP); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> state = digitalRead(pin); Serial.println( state == HIGH ? <span class="hljs-string"><span class="hljs-string">"Released"</span></span> : <span class="hljs-string"><span class="hljs-string">"Pressed"</span></span> ); delay(<span class="hljs-number"><span class="hljs-number">100</span></span>);<span class="hljs-comment"><span class="hljs-comment">//artifically reduce the loop rate so the output is at a human readable rate... }</span></span></code> </pre> <br><h2>  Switch lain dengan hampir tidak ada dokumentasi ... </h2><br><h3>  Saklar LED tiga pin </h3><br>  Untungnya, pada sakelar utama panel saya ada tiga tanda kontak: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43a/9c1/8e7/43a9c18e7e7c13e8ce02744fe8320bb6.jpg"></div><br>  Saya tidak sepenuhnya yakin cara kerjanya, jadi kami akan mengalihkan multimeter kembali ke mode kontinu dan menyentuh semua pasangan kontak saat sakelar dihidupkan dan dimatikan ... namun, kali ini multimeter tidak berbunyi bip sama sekali ketika kami menyentuh probe [GND] dan [+] dengan “ nyalakan!  Satu-satunya konfigurasi di mana multimeter berbunyi bip ( <em>mendeteksi koneksi</em> ) adalah ketika sakelar "aktif" dan probe menyala [+] dan [lampu]. <br><br>  LED di dalam sakelar memblokir pengukuran kontinuitas, jadi dari pengujian di atas kita dapat mengasumsikan bahwa LED terhubung langsung ke pin [GND], dan bukan ke kontak [+] dan [lampu].  Selanjutnya, kita akan mengalihkan multimeter ke mode uji dioda (simbol <img src="https://habrastorage.org/getpro/habr/post_images/aa4/e65/abe/aa4e65abeb894a55aa7074cbb67543aa.jpg">  ) dan periksa kembali pasangan kontak, tetapi kali ini polaritas penting ( <em>probe merah dan hitam</em> ).  Sekarang jika kita menghubungkan probe merah ke [lampu], dan hitam ke [GND], maka LED akan menyala dan 2.25V akan ditampilkan pada multimeter.  Ini adalah tegangan langsung dari dioda, atau tegangan minimum yang diperlukan untuk menyalakannya.  Terlepas dari posisi sakelar, 2.25V dari [lampu] ke [GND] menyebabkan LED menyala.  Jika kita menghubungkan probe merah ke [+], dan hitam ke [GND], maka LED hanya akan menyala ketika sakelar dihidupkan. <br><br>  Dari bacaan ini, kita dapat mengasumsikan bahwa bagian dalam saklar ini terlihat seperti diagram di bawah ini: <br><br><ol><li>  [+] dan [lampu] dihubung pendek saat sakelar hidup / tertutup. <br></li><li>  Tegangan positif dari [lampu] ke [GND] selalu menyalakan LED. <br></li><li>  Tegangan positif dari [+] ke [GND] menyalakan LED hanya ketika sakelar dihidupkan / ditutup. </li></ol><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd6/34a/728/bd634a728856e82e71eecafa5d42d8a4.png"></div><br>  Jujur saja, kita hanya bisa menebak tentang keberadaan resistor.  LED <strong>harus</strong> terhubung ke resistor yang sesuai untuk membatasi arus yang disediakan padanya, atau akan terbakar.  Milik saya tidak terbakar dan sepertinya berfungsi dengan benar.  Di forum situs web penjual, saya menemukan posting yang membahas tentang resistor yang dipasang yang mendukung hingga 12 V, dan ini menghemat waktu saya dalam memeriksa / menghitung resistor yang sesuai. <br><br><h3>  Kami menghubungkan sakelar ke Arduino </h3><br>  Cara termudah adalah menggunakan sakelar dengan Arduino, mengabaikan pin [lampu]: hubungkan [GND] ke GND di Arduino dan hubungkan [+] ke salah satu kontak Arduino yang bernomor, misalnya 3. <br><br>  Jika kita mengonfigurasi pin 3 sebagai INPUT_PULLUP ( <em>sama seperti untuk tombol sebelumnya</em> ), maka kita akan mendapatkan hasil yang ditunjukkan di bawah ini.  Kiri atas menunjukkan nilai yang akan kita terima dengan mengeksekusi "digitalRead (3)" dalam kode Arduino. <br><br>  Saat sakelar hidup / tertutup, kita membaca RENDAH dan LED menyala!  Untuk menggunakan sakelar seperti itu dalam konfigurasi ini, kita dapat menggunakan kode Arduino yang sama seperti pada contoh tombol. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd5/cc5/8ba/fd5cc58ba50f376abbd42806718b0f92.png"></div><br><h3>  Masalah solusi ini </h3><br>  Setelah terhubung ke Arduino, sirkuit penuh terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92c/305/f91/92c305f91bf0cf6fac213e2eba1db65e.png"></div><br>  Namun, di sini kita dapat melihat bahwa ketika saklar ditutup, di samping resistor pembatas arus kecil di depan LED (saya berasumsi bahwa resistansi adalah 100 Ohm), ada juga resistor pull-up sebesar 20 kΩ, yang selanjutnya mengurangi jumlah arus yang mengalir melalui LED.  Ini berarti bahwa meskipun rangkaian berfungsi, LED tidak akan terlalu terang. <br><br>  Kelemahan lain dari skema ini adalah bahwa kita tidak memiliki kontrol perangkat lunak atas LED - itu dinyalakan ketika saklar dihidupkan, dan dinonaktifkan dalam kasus yang berlawanan. <br><br>  Anda dapat melihat apa yang terjadi jika kami menghubungkan pin [lampu] ke 0V atau + 5V. <br><br>  Jika [lampu] terhubung ke 0V, maka LED selalu mati ( <em>terlepas dari posisi sakelar</em> ), dan pengenalan posisi Arduino masih dilakukan.  Ini memungkinkan kita untuk menonaktifkan LED secara terprogram! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/de7/6d3/a55de76d395358050d3c96139e47df73.png"></div><br>  Jika [lampu] terhubung ke + 5V, maka LED terus menyala ( <em>terlepas dari posisi sakelar</em> ), <strong>namun,</strong> pengakuan posisi Arduino rusak - TINGGI akan selalu dibaca dari kontak. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/310/ea5/4a8/310ea54a861f7f89bc624261abd71ce5.png"></div><br><h3>  Kami menghubungkan saklar ini ke Arduino dengan benar </h3><br>  Kita dapat mengatasi keterbatasan yang dijelaskan di atas ( <em>arus rendah / kecerahan LED dan kurangnya kontrol program terhadap LED</em> ) dengan menulis lebih banyak kode!  Untuk menyelesaikan konflik antara kemampuan mengontrol LED dan pengenalan posisi yang rusak karena itu, kita dapat memisahkan dua tugas tepat waktu, yaitu mematikan sementara LED saat membaca kontak sensor (3). <br><br>  Pertama, hubungkan pin [lampu] ke pin Arduino yang bertujuan umum lainnya, misalnya, ke 4 sehingga Anda dapat mengontrol lampu. <br><br>  Untuk membuat program yang akan dengan benar membaca posisi sakelar dan mengontrol LED (kita akan membuatnya berkedip), kita hanya perlu mematikan LED sebelum membaca status sakelar.  LED akan mati hanya dalam sepersekian milidetik, sehingga flicker tidak akan terlihat: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pinSwitch = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pinLed = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//connect to the PC Serial.begin(9600); //connect our switch's [+] connector to a digital sensor, and to +5V through a large resistor pinMode(pinSwitch, INPUT_PULLUP); //connect our switch's [lamp] connector to 0V or +5V directly pinMode(pinLed, OUTPUT); } void loop() { int lampOn = (millis()&gt;&gt;8)&amp;1;//make a variable that alternates between 0 and 1 over time digitalWrite(pinLed, LOW);//connect our [lamp] to +0V so the read is clean int state = digitalRead(pinSwitch); if( lampOn ) digitalWrite(pinLed, HIGH);//connect our [lamp] to +5V Serial.println(state);//report the switch state to the PC }</span></span></code> </pre> <br>  Dalam Arduino Mega, pin 2-13 dan 44-46 dapat menggunakan fungsi analogWrite, yang sebenarnya tidak menghasilkan tegangan dari 0V ke + 5V, tetapi diperkirakan menggunakan gelombang persegi.  Jika diinginkan, Anda dapat menggunakannya untuk mengontrol kecerahan LED!  Kode ini akan membuat cahaya berdenyut, bukan hanya berkedip: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lampState = (millis()&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">0xFF</span></span>;<span class="hljs-comment"><span class="hljs-comment">//make a variable that alternates between 0 and 255 over time digitalWrite(pinLed, LOW);//connect our [lamp] to +0V so the read is clean int state = digitalRead(pinSwitch); if( lampState &gt; 0 ) analogWrite(pinLed, lampState); }</span></span></code> </pre> <br><h2>  Tips Perakitan </h2><br>  Posnya sudah cukup besar, jadi saya tidak akan menambahkan tutorial solder, Anda dapat google itu! <br><br>  Namun, saya akan memberikan tips paling mendasar: <br><br><ul><li>  Saat menghubungkan kabel dengan kontak logam besar, pertama-tama pastikan bahwa besi solder panas dan kontak logam untuk sementara waktu.  Arti penyolderan adalah untuk membentuk koneksi permanen dengan membuat paduan, tetapi jika hanya satu bagian dari koneksi yang panas, maka Anda dapat dengan mudah mendapatkan "koneksi dingin" yang terlihat seperti koneksi, tetapi sebenarnya tidak terhubung. <br></li><li>  Saat menyambungkan kedua kabel, pasanglah salah satu di antaranya sepotong tabung panas-menyusut - setelah sambungan, pipa tidak dapat dipasang.  Ini terlihat jelas, tetapi saya terus-menerus melupakannya dan saya harus menggunakan pita listrik sebagai ganti tabung ... Tarik tabung menyusut dari sambungan sehingga tidak memanas di depan waktu.  Setelah memeriksa sambungan yang disolder, geser tabung ke atasnya dan panaskan. <br></li><li>  Kabel penghubung kecil tipis yang saya sebutkan di awal sangat cocok untuk koneksi tanpa solder (misalnya, ketika terhubung ke Arduino!), Tapi agak rapuh.  Setelah menyolder, gunakan lem untuk memperbaikinya dan menghilangkan semua tekanan dari koneksi itu sendiri.  Misalnya, kabel merah pada gambar di bawah ini dapat ditarik secara tidak sengaja selama operasi, jadi setelah menyolder saya memperbaikinya dengan setetes lem panas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0d/fa0/1d4/a0dfa01d48145b489d680cc6e7f43bc8.jpg"></div></li></ul><br><h1>  Bagian 2. Kami mengubah perangkat menjadi pengontrol permainan! </h1><br>  Agar OS mengenali perangkat sebagai pengontrol permainan USB, Anda memerlukan kode yang cukup sederhana, tetapi, sayangnya, Anda juga perlu mengganti firmware chip USB Arduino dengan yang lain, yang dapat diambil di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">https://github.com/harlequin-tech/arduino-usb</a> . <br><br>  Tetapi setelah mengunggah firmware ini ke Arduino, perangkat menjadi USB joystick dan tidak lagi menjadi Arduino.  Oleh karena itu, untuk memprogram ulang, Anda perlu mem-flash firmware Arduino yang asli.  Iterasi ini cukup menyakitkan - muat kode Arduino, flash firmware joystick, tes, flash firmware Arduino, ulangi ... <br><br>  Contoh program untuk Arduino yang dapat digunakan dengan firmware ini ditunjukkan di bawah ini - ini mengkonfigurasi tiga tombol sebagai input, membaca nilainya, menyalin nilai-nilai ke struktur data yang diharapkan oleh firmware ini, dan kemudian mengirimkan data.  Cuci bersih, sabun, ulangi. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// define DEBUG if you want to inspect the output in the Serial Monitor // don't define DEBUG if you're ready to use the custom firmware #define DEBUG //Say we've got three buttons, connected to GND and pins 2/3/4 int pinButton1 = 2; int pinButton2 = 3; int pinButton3 = 4; void setup() { //configure our button's pins properly pinMode(pinButton1, INPUT_PULLUP); pinMode(pinButton2, INPUT_PULLUP); pinMode(pinButton3, INPUT_PULLUP); #if defined DEBUG Serial.begin(9600); #else Serial.begin(115200);//The data rate expected by the custom USB firmware delay(200); #endif } //The structure expected by the custom USB firmware #define NUM_BUTTONS 40 #define NUM_AXES 8 // 8 axes, X, Y, Z, etc typedef struct joyReport_t { int16_t axis[NUM_AXES]; uint8_t button[(NUM_BUTTONS+7)/8]; // 8 buttons per byte } joyReport_t; void sendJoyReport(struct joyReport_t *report) { #ifndef DEBUG Serial.write((uint8_t *)report, sizeof(joyReport_t));//send our data to the custom USB firmware #else // dump human readable output for debugging for (uint8_t ind=0; ind&lt;NUM_AXES; ind++) { Serial.print("axis["); Serial.print(ind); Serial.print("]= "); Serial.print(report-&gt;axis[ind]); Serial.print(" "); } Serial.println(); for (uint8_t ind=0; ind&lt;NUM_BUTTONS/8; ind++) { Serial.print("button["); Serial.print(ind); Serial.print("]= "); Serial.print(report-&gt;button[ind], HEX); Serial.print(" "); } Serial.println(); #endif } joyReport_t joyReport = {}; void loop() { //check if our buttons are pressed: bool button1 = LOW == digitalRead( pinButton1 ); bool button2 = LOW == digitalRead( pinButton2 ); bool button3 = LOW == digitalRead( pinButton3 ); //write the data into the structure joyReport.button[0] = (button1?0x01:0) | (button2?0x02:0) | (button3?0x03:0); //send it to the firmware sendJoyReport(joyReport) }</span></span></code> </pre> <br><h1>  Bagian 3. Kami mengintegrasikan perangkat dengan permainan kami sendiri! </h1><br>  Jika Anda memiliki kendali atas gim yang berinteraksi dengan perangkat, maka sebagai alternatif Anda dapat berkomunikasi dengan pengontrol secara langsung - tidak perlu membuatnya terlihat oleh OS sebagai joystick!  Di awal posting, saya menyebutkan Object In Space;  ini adalah pendekatan yang digunakan pengembangnya.  Mereka menciptakan protokol komunikasi ASCII sederhana yang memungkinkan pengontrol dan permainan untuk berkomunikasi satu sama lain.  Cukup daftarkan port serial sistem (ini <em>adalah port COM pada Windows; ngomong-ngomong, <a href="" rel="external nofollow">lihat betapa buruknya tampilannya di C</a></em> ), cari port yang terhubung dengan perangkat yang disebut "Arduino", dan mulai membaca / menulis ASCII dari tautan ini. <br><br>  Di sisi Arduino, kami hanya menggunakan fungsi Serial.print yang digunakan dalam contoh di atas. <br><br>  Di awal posting ini, saya juga menyebutkan perpustakaan saya untuk menyelesaikan masalah ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">https://github.com/hodgman/ois_protocol</a> . <br><br>  Ini berisi kode C ++ yang dapat diintegrasikan ke dalam game dan digunakan sebagai "server", dan kode Arduino yang dapat dieksekusi di controller untuk menggunakannya sebagai "klien". <br><br><h2>  Sesuaikan Arduino </h2><br>  Di <a href="" rel="external nofollow">example_hardware.h,</a> saya membuat kelas untuk mengabstraksi tombol individu / tombol radio;  misalnya, "Beralih" adalah tombol sederhana dari contoh pertama, dan "LedSwitch2Pin" adalah saklar dengan LED yang dikendalikan dari contoh kedua. <br><br>  Kode contoh untuk bilah tombol saya di <a href="" rel="external nofollow">example.ino</a> . <br><br>  Sebagai contoh kecil, katakanlah kita memiliki satu tombol yang perlu dikirim ke gim, dan satu LED yang dikendalikan gim.  Kode Arduino yang diperlukan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ois_protocol.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//instantiate the library OisState ois; //inputs are values that the game will send to the controller struct { OisNumericInput myLedInput{"Lamp", Number}; } inputs; //outputs are values the controller will send to the game struct { OisNumericOutput myButtonOutput{"Button", Boolean}; } outputs; //commands are named events that the controller will send to the game struct { OisCommand quitCommand{"Quit"}; } commands; int pinButton = 2; int pinLed = 3; void setup() { ois_setup_structs(ois, "My Controller", 1337, 42, commands, inputs, outputs); pinMode(pinButton, INPUT_PULLUP); pinMode(pinLed, OUTPUT); } void loop() { //read our button, send it to the game: bool buttonPressed = LOW == digitalRead(pin); ois_set(ois, outputs.myButtonOutput, buttonPressed); //read the LED value from the game, write it to the LED pin: analogWrite(pinLed, inputs.myLedInput.value); //example command / event: if( millis() &gt; 60 * 1000 )//if 60 seconds has passed, tell the game to quit ois_execute(ois, commands.quitCommand); //run the library code (communicates with the game) ois_loop(ois); }</span></span></span></span></code> </pre> <br><h2>  Sesuaikan gim </h2><br>  Kode permainan ditulis dalam gaya "tajuk tunggal".  Untuk mengimpor perpustakaan, sertakan <a href="" rel="external nofollow">oisdevice.h</a> dalam game. <br><br>  Dalam file CPP tunggal, sebelum mengeksekusi header #include, tulis #define OIS_DEVICE_IMPL dan #define OIS_SERIALPORT_IMPL - ini akan menambahkan kode sumber kelas ke file CPP.  Jika Anda memiliki pernyataan, log, string atau vektor Anda sendiri, maka ada beberapa makro OIS_ * lain yang dapat Anda tentukan sebelum mengimpor header untuk memanfaatkan kapabilitas mesin. <br><br>  Untuk daftar port COM dan membuat koneksi dengan perangkat tertentu, Anda dapat menggunakan kode berikut: <br><br><pre> <code class="cpp hljs">OIS_PORT_LIST portList; OIS_STRING_BUILDER sb; SerialPort::EnumerateSerialPorts(portList, sb, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = portList.begin(); it != portList.end(); ++it ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> label = it-&gt;name + <span class="hljs-string"><span class="hljs-string">'('</span></span> + it-&gt;path + <span class="hljs-string"><span class="hljs-string">')'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-comment"><span class="hljs-comment">/*device selection choice*/</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gameVersion = <span class="hljs-number"><span class="hljs-number">1</span></span>; OisDevice* device = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OisDevice(it-&gt;id, it-&gt;path, it-&gt;name, gameVersion, <span class="hljs-string"><span class="hljs-string">"Game Title"</span></span>); ... } }</code> </pre> <br>  Setelah menerima instance OisDevice, Anda harus secara teratur memanggil fungsi anggota Poll-nya (misalnya, di setiap frame), Anda bisa mendapatkan status saat ini dari output pengontrol menggunakan DeviceOutputs (), menggunakan peristiwa perangkat menggunakan PopEvents () dan mengirim nilai ke perangkat menggunakan SetInput (). <br><br>  Contoh aplikasi melakukan semua ini dapat ditemukan di sini: <a href="" rel="external nofollow">example_ois2vjoy / main.cpp</a> . <br><br><h1>  Bagian 4. Bagaimana jika saya ingin bagian 2 dan 3 secara bersamaan? </h1><br>  Agar pengontrol bekerja di gim lain (bagian 2), Anda perlu menginstal firmware Anda sendiri dan satu program Arduino, tetapi agar pengontrol dapat diprogram sepenuhnya oleh gim, kami menggunakan firmware Arduino standar dan program Arduino lainnya.  Tetapi bagaimana jika kita ingin memiliki kedua kemungkinan sekaligus? <br><br>  Contoh aplikasi yang saya berikan tautan di atas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">ois2vjoy</a> ) menyelesaikan masalah ini. <br><br>  Aplikasi ini berkomunikasi dengan perangkat OIS (program dari Bagian 3), dan kemudian pada PC mengubah data ini menjadi data pengontrol / joystick normal, yang kemudian ditransfer ke perangkat pengontrol <em>virtual</em> / joystick.  Ini berarti Anda dapat mengizinkan pengontrol Anda untuk terus menggunakan pustaka OIS (tidak ada firmware lain yang diperlukan), dan jika kami ingin menggunakannya sebagai pengontrol / joystick biasa, maka jalankan saja aplikasi ois2vjoy di PC, yang melakukan konversi. <br><br><h1>  Bagian 5. Penyelesaian </h1><br>  Saya harap seseorang menemukan artikel ini bermanfaat atau menarik.  Terima kasih sudah membaca sampai akhir! <br><br>  Jika Anda penasaran, maka saya mengundang Anda untuk berpartisipasi dalam pengembangan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">ois_protocol</a> !  Saya pikir akan bagus untuk mengembangkan protokol tunggal untuk mendukung semua jenis pengendali buatan sendiri dalam game dan mendorong game untuk secara langsung mendukung pengendali buatan sendiri! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442816/">https://habr.com/ru/post/id442816/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442806/index.html">Program pendahuluan DUMP-2019 siap. Pembicara dari Evil Martians, Tinkoff.ru, HTML Academy, SkyEng, 2GIS</a></li>
<li><a href="../id442808/index.html">Kami mengundang Anda ke Pesta Droid - pertemuan yang membahas masalah praktis pengembangan aplikasi dan perangkat Android</a></li>
<li><a href="../id442810/index.html">Mitos Fisika Populer, melanjutkan: Gravity</a></li>
<li><a href="../id442812/index.html">"Saya tidak melihat alasan untuk menggunakan Python untuk bekerja dengan Spark, kecuali kemalasan"</a></li>
<li><a href="../id442814/index.html">10 tahun telah berlalu, dan belum ada yang tahu cara menggunakan blockchain. Dan di sini lagi?</a></li>
<li><a href="../id442818/index.html">10 kesalahan umum dalam bahasa Inggris tertulis dan cara menghadapinya</a></li>
<li><a href="../id442820/index.html">Coroutine Kustom dalam Persatuan dengan Preferensi dan Pelacur</a></li>
<li><a href="../id442822/index.html">Pusat data di laut dan di orbit: apakah mereka memiliki arti praktis?</a></li>
<li><a href="../id442824/index.html">Selamat datang di Lembah Silikon</a></li>
<li><a href="../id442826/index.html">Rekayasa sosial sebagai dramaturgi, atau apa kesamaan domain phishing dan senapan Chekhov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>