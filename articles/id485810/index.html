<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â–¶ï¸ ğŸ˜ˆ ğŸ¤œğŸ½ Elixir menghubungkan waktu kompilasi ğŸ§‘ğŸ¼ ğŸ”³ ğŸ˜¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Elixir dilengkapi dengan infrastruktur makro yang canggih, dirancang dengan sangat baik. Dengan tangan ringan Chris McCord, ada undang-undang tidak te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elixir menghubungkan waktu kompilasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485810/"><p>  <em>Elixir</em> dilengkapi dengan infrastruktur makro yang canggih, dirancang dengan sangat baik.  Dengan tangan ringan Chris McCord, ada undang-undang tidak tertulis di komunitas yang tidak dapat dihindarkan segera disuarakan mengenai makro: "Aturan pertama untuk menggunakan makro adalah bahwa Anda tidak boleh menggunakannya."  Kadang-kadang dengan komentar yang tidak jelas diketik dalam font abu-abu pucat dari ukuran keempat: "hanya jika Anda tidak bisa menghindarinya, dan Anda sangat mengerti apa yang akan Anda lakukan dan apa yang Anda riskan."  Hal ini disebabkan fakta bahwa makro memiliki akses ke seluruh <em>AST dari</em> modul di mana mereka digunakan, dan, secara umum, mereka dapat mengubah kode yang dihasilkan di luar pengakuan. </p><br><p> Pada prinsipnya, saya setuju bahwa Anda tidak boleh menggunakan makro dalam proses pengenalan dengan bahasa.  Sejauh ini, Anda tidak bisa, terbangun pada pukul tiga pagi dengan hangover, menjawab pertanyaan apakah kode ini dieksekusi pada tahap kompilasi, atau dalam runtime.  <em>Elixir</em> adalah bahasa yang dikompilasi, dan selama proses kompilasi kode "tingkat atas" dieksekusi, pohon sintaksis sepenuhnya diperluas sampai kita menemukan diri kita dalam situasi di mana tidak ada lagi yang bisa dibuka, dan hasil ini akhirnya dikompilasi dalam <em>BEAM</em> .  Ketika kompilator menemukan panggilan makro dalam kode sumber, itu sepenuhnya memaparkan <em>AST</em> untuk itu <em>dan crams bukannya panggilan yang sebenarnya</em> .  Mustahil untuk dipahami, hanya bisa diingat. </p><a name="habracut"></a><br><p>  Tetapi begitu kita merasa bebas dalam sintaks, kita pasti ingin menggunakan kekuatan penuh dari toolkit;  di sini tanpa makro - tidak ada tempat.  Hal utama adalah jangan menyalahgunakannya.  Makro dapat secara dramatis mengurangi (ke nilai negatif) jumlah kode boilerplate yang mungkin diperlukan, dan mereka memberikan cara alami dan sangat nyaman untuk memanipulasi <em>AST</em> .  <em>Phoenix</em> , <em>Ecto</em> , dan semua perpustakaan terkenal menggunakan makro sangat banyak. </p><br><p>  Hal di atas berlaku untuk semua perpustakaan / paket universal.  Dalam pengalaman saya, proyek biasa mungkin tidak diperlukan makro, atau diperlukan dalam area aplikasi yang sangat terbatas.  Perpustakaan, sebaliknya, sering terdiri dari makro dalam rasio 80/20 ke kode biasa. </p><br><p>  Saya tidak akan mengatur kotak pasir di sini dan memahat muffin makro bagi mereka yang belum tahu apa yang mereka makan;  jika menarik untuk mulai belajar dari dasar-dasar, untuk memahami apa itu pada prinsipnya, atau bagaimana dan mengapa mereka digunakan dalam <em>Elixir</em> itu sendiri, yang terbaik adalah segera menutup halaman ini dan membaca buku brilian <a href="https://pragprog.com/book/cmelixir/metaprogramming-elixir">Metaprogramming Elixir oleh</a> Chris McCord, pencipta <a href="https://phoenixframework.org/">Phoenix Framework</a> .  Saya hanya ingin menunjukkan beberapa trik untuk membuat ekosistem makro yang ada menjadi lebih baik. </p><br><hr><br><p>  Makro sengaja didokumentasikan dengan buruk.  Pisau ini terlalu tajam untuk diiklankan untuk anak-anak. </p><br><p> Ada dua cara untuk menggunakan makro.  Yang paling sederhana adalah Anda menginstruksikan kompiler bahwa modul ini akan menggunakan makro dari yang lain menggunakan direktif <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html%3F"><code>Kernel.SpecialForms.require/2</code></a> , dan memanggil makro itu sendiri setelah itu (untuk makro yang didefinisikan dalam modul yang sama, kebutuhan eksplisit tidak diperlukan).  Pada artikel ini kami tertarik dengan cara lain yang lebih rumit.  Ketika panggilan kode eksternal <code>use MyLib</code> , diharapkan modul <code>__using__/1</code> kami <code>MyLib</code> mengimplementasikan <code>__using__/1</code> makro, yang akan <code>use MyLib</code> oleh kompiler ketika bertemu <code>use MyLib</code> .  Gula sintaksis, ya.  Konvensi tentang konfigurasi.  Kereta melewati Jose tidak lewat tanpa bekas. </p><br><p>  <em>Perhatian:</em> jika paragraf di atas membingungkan Anda, dan semua hal di atas terdengar konyol, silakan berhenti makan kaktus ini, dan bacalah buku yang saya sebutkan di atas sebagai ganti catatan kue pendek saya. </p><br><p>  <code>__using__/1</code> mengambil argumen, sehingga pemilik perpustakaan dapat mengizinkan pengguna untuk mengirimkan beberapa parameter ke sana.  Ini adalah contoh dari salah satu proyek internal saya yang menggunakan panggilan makro dengan parameter: </p><br><pre> <code class="ruby hljs">defmodule User <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use MyApp.ActiveRecord, <span class="hljs-symbol"><span class="hljs-symbol">repo:</span></span> MyApp.Repo, <span class="hljs-symbol"><span class="hljs-symbol">roles:</span></span> ~w<span class="hljs-params"><span class="hljs-params">|supervisor client subscriber|</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">preload:</span></span> ~w<span class="hljs-params"><span class="hljs-params">|setting companies|</span></span>a</code> </pre> <br><p>  Argumen jenis <code>keyword()</code> akan diteruskan ke <code>MyApp.ActiveRecord.__using__/1</code> , dan di sana saya menggunakannya untuk membuat berbagai pembantu untuk bekerja dengan model ini.  ( <em>Catatan:</em> kode ini telah lama diminum karena <em>ActiveRecord</em> kehilangan dalam semua hal panggilan <em>Ecto</em> asli). </p><br><hr><br><p>  Terkadang kami ingin membatasi penggunaan makro untuk subset modul (misalnya, izinkan hanya digunakan dalam struktur).  Pemeriksaan eksplisit di dalam <code>__using__/1</code> tidak akan berfungsi, seperti yang kita inginkan, karena selama kompilasi modul kita tidak memiliki akses ke <code>__ENV__</code> nya (dan itu akan menjadi - itu masih jauh dari selesai pada saat kompiler menemukan panggilan <code>__using__/1</code> Ini akan ideal untuk melakukan pemeriksaan ini setelah kompilasi selesai. </p><br><p>  Tidak masalah!  Ada dua <a href="https://hexdocs.pm/elixir/Module.html">atribut modul</a> yang mengkonfigurasi hal itu.  Selamat datang untuk mengunjungi kami, <a href="https://hexdocs.pm/elixir/Module.html">panggilan balik waktu kompilasi yang</a> terhormat. </p><br><p>  Berikut adalah kutipan singkat dari dokumentasi. </p><br><blockquote>  <code>@after_compile</code> panggilan balik akan dipanggil segera setelah kompilasi modul saat ini. <br><br>  Menerima modul atau tuple <code>{module, function_name}</code> .  Callback itu sendiri harus mengambil dua argumen: lingkungan modul dan bytecode-nya.  Ketika hanya modul yang dilewatkan sebagai argumen, diasumsikan bahwa modul ini mengekspor fungsi <code>__after_compile__/2</code> ada. <br><br>  Panggilan balik yang terdaftar terlebih dahulu akan dieksekusi terakhir. <br><pre> <code class="plaintext hljs">defmodule MyModule do @after_compile __MODULE__ def __after_compile__(env, _bytecode) do IO.inspect env end end</code> </pre> <br></blockquote><p>  Saya sangat tidak menyarankan menyuntikkan <code>__after_compile__/2</code> langsung ke kode yang dihasilkan, karena ini dapat menyebabkan konflik dengan niat pengguna akhir (yang mungkin ingin menggunakan penangan mereka sendiri).  Tentukan fungsi di suatu tempat di dalam <code>MyLib.Helpers</code> Anda. <code>MyLib.Helpers</code> atau sesuatu, dan berikan tuple ke <code>@after_compile</code> : </p><br><pre> <code class="ruby hljs">quote <span class="hljs-symbol"><span class="hljs-symbol">location:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:keep</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @after_compile({MyLib.Helpers, <span class="hljs-symbol"><span class="hljs-symbol">:after_mymodule_callback</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><hr><br><p>  Callback ini akan dipanggil segera setelah mengkompilasi modul yang sesuai, yang menggunakan perpustakaan kami, dan akan menerima dua parameter: struktur <code>__ENV__</code> dan kode byte dari modul yang dikompilasi.  Yang terakhir ini jarang digunakan oleh manusia biasa;  yang pertama menyediakan semua yang kita butuhkan.  Berikut ini adalah contoh bagaimana saya melindungi diri dari mencoba memanggil <code>use Iteraptable</code> dari modul yang tidak menerapkan struktur.  Bahkan, kode verifikasi hanya memanggil dari <code>__struct__</code> __struct__ pada modul yang dikompilasi dan delegasi dangkal <em>Elixir</em> hak untuk melempar pengecualian dengan teks yang jelas menjelaskan penyebab masalah: </p><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">struct_checker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(env, _bytecode)</span></span></span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> env.<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.__struct_<span class="hljs-number"><span class="hljs-number">_</span></span></code> </pre> <br><p>  Kode di atas akan mengeluarkan pengecualian jika modul yang dikompilasi bukan struktur.  Tentu saja, kode verifikasi bisa jauh lebih rumit, tetapi gagasan utamanya adalah apakah <em>modul yang Anda gunakan</em> mengharapkan sesuatu dari modul <em>yang menggunakannya</em> .  Jika demikian, masuk akal untuk tidak melupakan <code>@after_compile</code> dan mengutuk dari sana jika semua persyaratan yang diperlukan tidak terpenuhi.  Melempar pengecualian adalah pendekatan yang tepat dalam kasus ini sedikit lebih dari biasanya, karena kode ini dieksekusi pada tahap kompilasi. </p><br><hr><br><p>  Sebuah cerita lucu terhubung dengan <code>@after_callback</code> , yang sepenuhnya menjelaskan mengapa saya menyukai <em>OSS</em> secara umum dan <em>Elixir</em> pada khususnya.  Sekitar setahun yang lalu, saya membuat kesalahan dalam copy-paste dan disalin dari suatu tempat <code>@after_callback</code> bukannya <code>@before_callback</code> .  Perbedaan di antara mereka mungkin jelas: yang kedua dipanggil <em>sebelum kompilasi</em> , dan dari sana setiap orang dapat mengubah sintaksis pohon di luar pengakuan.  Dan saya - oh, bagaimana - saya mengubahnya.  Tapi ini tidak mengarah ke hasil apa pun dalam kode yang dikompilasi: itu tidak berubah sama sekali.  Setelah tiga cangkir kopi, saya perhatikan salah ketik, diganti <code>after</code> dengan <code>before</code> dan semuanya dimulai;  tetapi pertanyaan itu menyiksaku: mengapa kompiler tetap diam, seperti partisan.  Ternyata <code>Module.open?/1</code> mengembalikan <code>true</code> dari callback ini (yang, pada prinsipnya, tidak jauh dari kebenaran - modul masih belum ditutup, akses ke atributnya tidak ditutup, dan banyak perpustakaan menggunakan bug tidak berdokumen ini). </p><br><p>  Yah, saya membuat sketsa perbaikan, mengirim permintaan tarik ke kerak bahasa (ke kompiler, jika benar-benar ketat), dan kurang dari sehari kemudian, dia <a href="https://github.com/elixir-lang/elixir/pull/9278/files">berakhir di master</a> . </p><br><p>  Jadi saat itulah saya membutuhkan pengaturan pengguna di <code>IO.inspect/2</code> , dan dalam beberapa kasus.  Apa yang akan terjadi jika saya menemukan ini di Jawa?  - Menakutkan membayangkan. </p><br><hr><br><p>  Selamat menikmati makro! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485810/">https://habr.com/ru/post/id485810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485792/index.html">Ivan Lilekvist dan Kim Dotkom, sebuah wawancara besar: kisah Megaupload, ekstradisi ke Amerika Serikat, kebebasan, bitcoin. Bagian 2</a></li>
<li><a href="../id485794/index.html">Apakah Anda mengembangkan .NET Core? Ayo pergi ke Ubuntu, saya sudah menyiapkan semuanya</a></li>
<li><a href="../id485800/index.html">Digitalisasi vs. Otomasi</a></li>
<li><a href="../id485804/index.html">Dan lagi, CAPTCHA atau nginx juga tahu cara menyulam</a></li>
<li><a href="../id485806/index.html">Coronavirus: dari SARS hingga 2019-nCoV</a></li>
<li><a href="../id485812/index.html">7 tahapan pengujian evolusi di sebuah perusahaan</a></li>
<li><a href="../id485820/index.html">Orang yang Sangat Diserang: Cari tahu siapa target utama penjahat cyber di perusahaan Anda.</a></li>
<li><a href="../id485824/index.html">Cara membuat bot yang mengubah foto menjadi komik. Bagian tiga. Server + GPU hosting gratis tanpa server</a></li>
<li><a href="../id485828/index.html">Apa hukum di bidang hukum digital dapat muncul tahun ini</a></li>
<li><a href="../id485834/index.html">Operation Night Fury: dengan partisipasi Grup-IB di Indonesia, menahan penjahat cyber yang menginfeksi ratusan toko online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>