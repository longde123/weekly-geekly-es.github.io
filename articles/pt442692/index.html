<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇ üë®üèø‚Äç‚öñÔ∏è üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© Blockchain sem intermedi√°rios: como enviamos t√≠tulos para um registro distribu√≠do üë∞üèª üåπ ü§òüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Toda atividade econ√¥mica √© constru√≠da historicamente sobre intermedi√°rios. Qualquer transa√ß√£o simples, mesmo entre as duas partes, √© acompanhada pelo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blockchain sem intermedi√°rios: como enviamos t√≠tulos para um registro distribu√≠do</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/442692/">  Toda atividade econ√¥mica √© constru√≠da historicamente sobre intermedi√°rios.  Qualquer transa√ß√£o simples, mesmo entre as duas partes, √© acompanhada pelo envolvimento de v√°rios intermedi√°rios - bancos, trocas, c√¢maras de compensa√ß√£o, etc.  A exclus√£o de intermedi√°rios provavelmente tornaria a intera√ß√£o mais eficiente.  Ent√£o, por que n√£o tentar criar uma nova infraestrutura descentralizada com base no blockchain, onde os participantes da transa√ß√£o possam trabalhar diretamente?  Neste post, falaremos sobre como iniciamos nossa jornada para essa infraestrutura: desenvolvemos transa√ß√µes de blockchain e, eventualmente, realizamos opera√ß√µes compromissadas - um empr√©stimo de dinheiro garantido por valores mobili√°rios. <br><br><img src="https://habrastorage.org/webt/5y/08/en/5y08enodezvkfd1qngslkh-pl4y.png"><br><a name="habracut"></a><br><h2>  Obriga√ß√µes de curto prazo </h2><br>  Nossa primeira transa√ß√£o financeira de balc√£o na blockchain foi a emiss√£o de um t√≠tulo de curto prazo da operadora m√≥vel MTS com a participa√ß√£o do National Settlement Depository (NSD).  Este √© um tipo de "banco central" de todos os deposit√°rios.  Os deposit√°rios s√£o intermedi√°rios de infraestrutura que mant√™m registros dos propriet√°rios de t√≠tulos e os emitem. <br><br>  Nessa transa√ß√£o, a MTS, ao chamar a fun√ß√£o do contrato inteligente, registrou na blockchain uma express√£o de vontade de vender t√≠tulos para o Sberbank, e confirmou na blockchain seu acordo com os termos da transa√ß√£o.  As contra-ordens assinadas por ambas as partes foram recebidas pela NSD, que as executou em seus sistemas cont√°beis.  Al√©m disso, o blockchain exibia as contas dos participantes da transa√ß√£o em valores mobili√°rios e dinheiro. <br><br>  Nesse projeto, selecionamos a plataforma <i>Hyperledger Fabric 1.1 de</i> c√≥digo aberto, projetada para criar solu√ß√µes de blockchain corporativas fechadas.  Bloqueios p√∫blicos n√£o s√£o adequados aqui, porque precisamos garantir a privacidade dos dados.  Enfrentamos essas limita√ß√µes no piloto de factoring do Sberbank com o M. Video, que foi implementado no blockchain Ethereum.  Por outro lado, o Hyperledger Fabric permite colocar todos os participantes de uma transa√ß√£o em um canal dedicado, onde eles podem trocar todas as informa√ß√µes necess√°rias e process√°-las com contratos inteligentes com todos os recursos. <br><br>  O c√≥digo-fonte do projeto de emiss√£o de t√≠tulos do MTS foi carregado publicamente no GitHub.  Mesmo sem entrar no algoritmo do trabalho, voc√™ pode entender que, no ciclo de vida de uma transa√ß√£o, o blockchain recebeu um papel bastante modesto como transporte de ordens de compensa√ß√£o.  Por outro lado, com base nessas instru√ß√µes, os saldos das contas foram alterados - portanto, do ponto de vista da l√≥gica de neg√≥cios, isso era mais interessante do que um simples servi√ßo de gerenciamento de documentos eletr√¥nicos. <br><br>  A principal vantagem da solu√ß√£o foi a versatilidade.  O esquema ‚Äúduas contrapartes e um registrador‚Äù abrange quase todas as transa√ß√µes no mercado de balc√£o, e com pequenas altera√ß√µes - a maioria das transa√ß√µes comerciais em geral. <br><br><h2>  REPO 1.0 </h2><br>  Em um novo projeto na blockchain, decidimos mostrar como implementar um acordo de recompra em um sistema descentralizado - um empr√©stimo de dinheiro contra valores mobili√°rios.  Normalmente, essas e outras transa√ß√µes de balc√£o passam por intermedi√°rios - deposit√°rio, c√¢maras de compensa√ß√£o, corretores. <br><br>  Nesse projeto, celebramos um acordo de recompra entre o Sberbank e um parceiro estrangeiro.  Ele j√° usava o Hyperledger Fabric vers√£o 1.2.  Comparado aos t√≠tulos do MTS, tivemos duas diferen√ßas: <br><br><ul><li>  Apenas duas partes da transa√ß√£o conectaram-se √† blockchain, cujos deposit√°rios - Euroclear e Clearstream - receberam todos os pedidos por meio dos canais tradicionais de transmiss√£o de dados do back office do Sberbank e de sua contraparte. <br></li><li>  No contrato inteligente, implementamos uma l√≥gica de neg√≥cios complexa: as cota√ß√µes di√°rias da seguran√ßa que serviram de garantia para o empr√©stimo foram baixadas para o blockchain e o contrato inteligente calculou a necessidade e o valor do reembolso antecipado, levando em considera√ß√£o o custo alterado das garantias, descontos, calend√°rio de trocas de sa√≠da e outros par√¢metros.  Essa sincroniza√ß√£o P2P de algoritmos de c√°lculo entre participantes n√£o pode ser obtida sem um registro distribu√≠do.  Isso √© muito mais conveniente do que um c√°lculo independente de obriga√ß√µes e valores de cada lado - sem reconcilia√ß√µes demoradas, sem confirma√ß√µes. <br></li></ul><br>  Entre as contrapartes organizou um bate-papo e um fluxo de trabalho dentro do canal.  Os dados neles foram armazenados no blockchain.  Ap√≥s cada altera√ß√£o no registro distribu√≠do, os membros do canal receberam um alerta por email. <br><br>  "REPO 1.0", trabalhamos do lado jur√≠dico.  Com a ajuda de um grande escrit√≥rio de advocacia, foi realizada uma an√°lise dos casos da High Court of London.  Al√©m disso, o SDE do banco e de sua contraparte usava algoritmos criptogr√°ficos diferentes. <br><br><h3>  Como o REPO 1.0 funciona? </h3><br>  Cada parte da transa√ß√£o possui seu pr√≥prio n√≥ blockchain.  Todos os n√≥s est√£o conectados um ao outro em uma rede P2P.  Suponha que voc√™ precise fazer um acordo.  Implementamos um contrato inteligente entre as partes da transa√ß√£o, onde o instrumento financeiro √© totalmente descrito. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f42/e38/b7e/f42e38b7e23eac1217952790f217a4e9.png"><br><br>  Ap√≥s a cria√ß√£o do contrato do nosso lado, ele √© assinado pelo trader.  O cliente tamb√©m revisa e assina o contrato.  Em seguida, as assinaturas s√£o revisadas e verificadas.  Nesse caso, a transa√ß√£o foi conduzida de acordo com a lei inglesa, os dados da assinatura digital eletr√¥nica foram inseridos no documento GMRA.  Para assinar pelo cliente, √© necess√°ria a verifica√ß√£o de que uma pessoa autorizada esteja presente no certificado de assinatura.  Finalmente, o cliente aceita o contrato e concorda com todas as condi√ß√µes.  Voc√™ pode anexar qualquer n√∫mero de documentos a um contrato assinado. <br><br>  Depois disso, o contrato recebe o status de "em trabalho".  O contrato "em andamento" √© recalculado automaticamente ao carregar novos pre√ßos de mercado.  Se houver um t√≠tulo no contrato, o pre√ßo de mercado √© calculado, o Loan-To-Value (LTV) √© recalculado - a raz√£o entre o valor do empr√©stimo e o valor do t√≠tulo em t√≠tulos.  LTV √© um dos termos principais de uma transa√ß√£o compromissada, cujo significado √© prescrito no contrato.  O pre√ßo das a√ß√µes subiu bastante - e o LTV est√° se tornando menor do que o indicado na GMRA (quando se trata da lei inglesa).  Dessa forma, o banco devolve t√≠tulos ao cliente (como uma das op√ß√µes), uma vez que, considerando novos pre√ßos, verifica-se que o banco possui maior seguran√ßa. <br><br>  Por√©m, se o LTV aumentar, o programa permite que voc√™ imprima um aviso colateral - uma notifica√ß√£o ao cliente sobre a necessidade de garantir seguran√ßa adicional (a√ß√µes ou dinheiro) para que o valor do LTV retorne ao valor inicial.  Anteriormente, o aviso colateral s√≥ podia ser enviado por correio, documentos separados eram criados para isso e, durante a cria√ß√£o desses documentos, o LTV podia mudar novamente.  Agora que vemos os mesmos c√°lculos com o cliente online, podemos interagir facilmente. <br><br>  Al√©m disso, o programa diariamente fixa o pre√ßo da recompra de valores mobili√°rios, levando em considera√ß√£o os juros.  Se o cliente discorda dele ao carregar o pre√ßo de mercado, ele analisa o registro completo do rec√°lculo - o que foi, o que se tornou, qual o pre√ßo carregado, de onde veio.  E ent√£o a discuss√£o no bate-papo come√ßa. <br><br><h2>  REPO 2.0 </h2><br>  Quer√≠amos que nosso REPO no blockchain fosse capaz de iniciar o movimento de ativos reais com base em nossa l√≥gica interna.  Mas no REPO 1.0, devido a dificuldades organizacionais na conex√£o de deposit√°rios ocidentais, ainda n√£o conseguimos isso.  Ent√£o come√ßamos o novo piloto Repo 2.0.  Ele tinha dois objetivos: <br><br><ul><li>  A transa√ß√£o deve ser realizada com a participa√ß√£o de duas partes e do deposit√°rio, para aproveitar ao m√°ximo a infraestrutura do projeto de t√≠tulos do MTS. <br></li><li>  O blockchain precisa ter o poder de reavaliar as garantias e configurar uma chamada de margem que pode ser executada automaticamente por um deposit√°rio conectado a uma rede distribu√≠da. <br></li></ul><br>  O NSD imediatamente quis se conectar ao projeto.  Para conseguir uma transa√ß√£o iniciada no blockchain no campo conservador das leis federais que regem o mercado financeiro dom√©stico, trabalhamos com advogados para um contrato suplementar de cinco p√°ginas ao contrato de gerenciamento de documentos eletr√¥nicos.  Foi assinado por todas as partes da transa√ß√£o e pelo NSD. <br><br>  A NSD atuou como uma c√¢mara de compensa√ß√£o nessa transa√ß√£o.  Ele executou todas as instru√ß√µes sobre movimenta√ß√£o de fundos e valores mobili√°rios.  Esta transa√ß√£o foi conclu√≠da sob a lei russa. <br><br>  O cliente aceitou o contrato com uma assinatura eletr√¥nica.  Em seguida, o contrato foi aceito pelo Sberbank com sua assinatura - ele verificou a conformidade de todos os par√¢metros com os valores necess√°rios e a autoridade da pessoa que aceitou do cliente.  Depois disso, o contrato entrou em funcionamento.  A NSD carregou dados de mercado, contrato inteligente recalculado. <br><br><h3>  Como o REPO 2.0 funciona? </h3><br>  Para implantar a rede e interagir com a interface do cliente com o c√≥digo da cadeia, usamos a solu√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fabric Starter</a> .  Em vez da interface grpc padr√£o para HLF, ela fornece uma API REST, que no nosso caso reduziu significativamente a complexidade da integra√ß√£o. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07a/86a/997/07a86a997c7017a122b03aad7995f6ad.png"><br><br>  A rede subiu da seguinte maneira.  Cada um dos tr√™s lados ap√≥s a pr√©-instala√ß√£o no servidor Docker lan√ßou o Fabric Starter, que criou cont√™ineres com os componentes do n√≥.  Esses componentes inclu√≠am um ponto externo para interagir com outras organiza√ß√µes e um servi√ßo de API REST por meio do qual o n√≥ interagia com o aplicativo cliente.  Ao iniciar o Starter, a rede blockchain tamb√©m foi configurada e um canal privado foi criado no qual o c√≥digo da cadeia com pol√≠tica de endosso foi instalado.  No nosso caso, cada transa√ß√£o deve ter as assinaturas dos tr√™s participantes. <br><br>  Durante a fase de teste, o Docker Swarm foi usado para organizar a conex√£o dos servidores dos participantes; no entanto, com o objetivo de fazer um acordo real, eles mudaram para o DNS.  A pr√≥pria plataforma √© respons√°vel pelo transporte de mensagens; os dados s√£o transmitidos pela Internet com criptografia TLS. <br><br><h2>  O lado t√©cnico da quest√£o </h2><br>  O processo de desenvolvimento de um aplicativo distribu√≠do no HLF come√ßa tradicionalmente - com estruturas de dados e um c√≥digo de cadeia (de fato, um conjunto de procedimentos armazenados), cuja chamada leva √† preserva√ß√£o, modifica√ß√£o ou leitura dessas estruturas do raz√£o.  A plataforma permite o uso de v√°rias linguagens de programa√ß√£o para o desenvolvimento de c√≥digos de cadeia e DBMSs para armazenamento local.  Preferimos Go e CouchDB, respectivamente. <br><br>  A ess√™ncia central dos projetos de recompra em nosso modelo de dados √© o pr√≥prio contrato e suas obriga√ß√µes subsidi√°rias.  Eles foram criados para cada um dos dois pilotos, bem como para chamadas de margem.  Essa arquitetura foi um passo √† frente em compara√ß√£o com o modelo de t√≠tulos MTS, baseado na ess√™ncia da ‚ÄúOrdem‚Äù.  Objetos independentes tamb√©m foram criados para t√≠tulos, que foram, portanto, parcialmente tokenizados.  Mas, com o desenvolvimento do experimento com gerenciamento de contas e tokeniza√ß√£o virtual de dinheiro, decidimos adiar para uma das pr√≥ximas vers√µes da solu√ß√£o. <br><br>  As principais fun√ß√µes da nossa solu√ß√£o: <br><br><ul><li>  Crie um contrato. <br></li><li>  Assine um contrato com sua EDS confirmando a aceita√ß√£o dos termos do contrato. <br></li><li>  Fa√ßa o download dos pre√ßos de mercado e comece a recalcular o valor da garantia.  Seu desvio do limite definido causou a cria√ß√£o de uma nova obriga√ß√£o de chamada de margem. <br></li><li>  Reflita o status da obriga√ß√£o. <br></li></ul><br>  No lado t√©cnico, o procedimento de reavalia√ß√£o √© mais interessante aqui.  Vamos analis√°-lo em mais detalhes. <br><br>  No processo comercial, o procedimento deve ser iniciado uma vez por dia, ap√≥s o Oracle (no piloto do "REPO 2.0" realizado pela NSD) fazer o upload das cota√ß√µes atualizadas dos t√≠tulos no sistema. <br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *CIBContract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recalculationData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface, loadData *loadDataType, curDay </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> {...}</code> </pre> <br>  O ciclo principal do procedimento passa por todos os t√≠tulos cujas cota√ß√µes foram atualizadas. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, securities := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> loadData.Securities {...}</code> </pre> <br>  Em seguida, v√°rias verifica√ß√µes s√£o realizadas.  Por exemplo, se a troca com a qual os dados de mercado foram recebidos √© hoje um dia de folga, a recontagem n√£o deve ocorrer. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t.checkHoliday(stub, contract.Settings.Calendars) == <span class="hljs-string"><span class="hljs-string">"yes"</span></span> { hisYes := historyType{curDay, <span class="hljs-string"><span class="hljs-string">"LoadData. Calendar"</span></span>, <span class="hljs-string"><span class="hljs-string">"System"</span></span>, <span class="hljs-string"><span class="hljs-string">"LoadData. Today is holiday ! No load market data to contract !"</span></span>} ... contract.History = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(contract.History, hisYes) ‚Ä¶ err = stub.PutState(contrID, contractJSONasBytes) }</code> </pre><br>  Para calcular o pre√ßo atualizado do t√≠tulo, o rendimento acumulado do cupom (NDC) √© adicionado ao pre√ßo l√≠quido carregado.  O piloto implementou o suporte ao esquema 30/360 para o c√°lculo de NKD. <br><br><pre> <code class="go hljs">priceIzm = <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(securities.Price + <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(securities.CouponRate)*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Year()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Year()))*<span class="hljs-number"><span class="hljs-number">360</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Month()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Month()))*<span class="hljs-number"><span class="hljs-number">30</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Day()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Day())))*<span class="hljs-number"><span class="hljs-number">100</span></span>/<span class="hljs-number"><span class="hljs-number">360</span></span>/<span class="hljs-number"><span class="hljs-number">100</span></span>) curCurrVal = priceIzm</code> </pre><br>  Se a moeda da transa√ß√£o for diferente da moeda na qual o t√≠tulo √© cotado, uma convers√£o de c√¢mbio √© realizada. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> contract.GeneralTerms.PurchasePrice.Currency != securities.Currency { curCurrName = securities.Currency + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + contract.GeneralTerms.PurchasePrice.Currency               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, currency := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> loadData.Currencies {              <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currency.Name == curCurrName {                           curCurrVal = priceIzm * currency.Value } } }</code> </pre><br>  Agora precisamos calcular o LTV.  Mantenha o antigo valor do coeficiente para a hist√≥ria. <br><br><pre> <code class="go hljs">oldCurLTV := contract.MarginingTerms.CurrentLTV</code> </pre> <br>  √â necess√°rio levar em considera√ß√£o as chamadas de margem executadas durante a vida √∫til da transa√ß√£o.  Os requisitos podem vir de ambos os lados e de duas formas: <br><br><ul><li>  T√≠tulos.  O mutu√°rio faz uma seguran√ßa adicional no caso de uma queda no pre√ßo de mercado da garantia.  O credor retorna parte da garantia em caso de aumento de pre√ßo. <br></li><li>  Dinheiro  O mutu√°rio antecipa o pagamento da parcela do empr√©stimo que deixou de ser coberta por garantias mais baratas.  O credor aumenta o montante do empr√©stimo em resposta a um aumento no valor das garantias. <br></li></ul><br>  No primeiro caso, a quantidade de t√≠tulos em garantia √© simplesmente atualizada.  E, no caso de ganhar dinheiro com eles, tamb√©m √© necess√°rio acumular a lucratividade especificada nos termos adicionais da transa√ß√£o. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, addCollateral := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> contract.MarginingTerms.AddCollateral { currSumCollateral := addCollateral.Sum + (addCollateral.Sum*contract.MarginingTerms.RateOnCashMargin*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(deltaColDate) / <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.Basis))/<span class="hljs-number"><span class="hljs-number">100</span></span> ... allSumCollateral = allSumCollateral + currSumCollateral ... ht := historyType{curDay, System<span class="hljs-string"><span class="hljs-string">", "</span></span>LoadData. Recalculation data(addCollateral) Contract <span class="hljs-string"><span class="hljs-string">" + contrID + "</span></span> - currSumCollateral: <span class="hljs-string"><span class="hljs-string">" + strconv.FormatFloat(float64(currSumCollateral), 'f', 2, 64) ... }        ... contract.History = append(contract.History, ht) }</span></span></code> </pre> <br>  Calculamos o valor total da recompra - na verdade, esse √© o valor do empr√©stimo com juros, que precisamos reembolsar. <br><br><pre> <code class="go hljs">rePurchasePriceCur := contract.GeneralTerms.PurchasePrice.Sum + (contract.GeneralTerms.PurchasePrice.Sum*contract.GeneralTerms.RepoRate*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(deltaSigningDate)/<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.Basis))/<span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre><br>  Agora calculamos o coeficiente LTV.  Para fazer isso, subtraia o t√≠tulo em dinheiro do pre√ßo de recompra e divida o valor resultante pelo valor total dos t√≠tulos no t√≠tulo.  Os valores creditados pelo credor s√£o marcados com um "-" e ser√£o adicionados ao pre√ßo da recompra. <br><br><pre> <code class="go hljs">contract.MarginingTerms.CurrentLTV = (rePurchasePriceCur - allSumCollateral) * <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) / (<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.GeneralTerms.PurchasedSecurities.Quantity) * curCurrVal)</code> </pre><br>  Por fim, calculamos os gatilhos do contrato.  O mesmo procedimento criar√° objetos de ordem de chamada de margem se o valor LTV se desviar do corredor especificado. <br><br><pre> <code class="go hljs">contract = t.checkTriggerEvents(stub, <span class="hljs-string"><span class="hljs-string">"LoadData"</span></span>, contract, curDay, securities)</code> </pre><br>  E escreva informa√ß√µes no hist√≥rico para exibi√ß√£o na interface do usu√°rio. <br><br><pre> <code class="go hljs">ht := historyType{curDay, <span class="hljs-string"><span class="hljs-string">"System"</span></span>, <span class="hljs-string"><span class="hljs-string">"LoadData. Recalculation data(change curLTV, ADTV) Contract "</span></span> + contrID + <span class="hljs-string"><span class="hljs-string">" - oldCurLTV: "</span></span> + strconv.FormatFloat(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(oldCurLTV), <span class="hljs-string"><span class="hljs-string">'f'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>) + <span class="hljs-string"><span class="hljs-string">", newCurLTV: "</span></span> + strconv.FormatFloat(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.CurrentLTV), <span class="hljs-string"><span class="hljs-string">'f'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>)...} contract.History = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(contract.History, ht)</code> </pre> <br><h2>  Resumir </h2><br>  Esse esquema pode funcionar n√£o apenas com valores mobili√°rios e contratos, mas tamb√©m em outros cen√°rios.  Por exemplo, com suprimentos de eletricidade, onde existem tarifas diferentes, conex√µes diferentes em momentos diferentes.  Ou com factoring - empr√©stimos a fornecedores por sinais de remessa de mercadorias.  Existem muitos casos de usu√°rios em economia, quando todos usam suas pr√≥prias fontes de dados que precisam ser verificadas. <br><br>  Nosso objetivo √© criar uma rede que conecte os bancos entre si e com seus clientes em todo o pa√≠s e usando contratos inteligentes para descrever nele contratos n√£o de criptografia, mas da economia tradicional - instrumentos financeiros.  Essa rede ser√° est√°vel, aberta e, como deveria estar em uma rede P2P, ningu√©m aqui ter√° um status especial. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt442692/">https://habr.com/ru/post/pt442692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt442682/index.html">O que digitar e como montar um projeto C ++</a></li>
<li><a href="../pt442684/index.html">Desempenho equilibrado do site. Parte 3: Conte√∫do</a></li>
<li><a href="../pt442686/index.html">Tutorial do DataPower</a></li>
<li><a href="../pt442688/index.html">An√°lise de dados Scala - uma necessidade urgente ou uma oportunidade agrad√°vel?</a></li>
<li><a href="../pt442690/index.html">Miss√£o lunar "Bereshit" - selfie no fundo da Terra</a></li>
<li><a href="../pt442694/index.html">Um dos gigantes do streaming lan√ßado na √çndia e atraiu um milh√£o de usu√°rios em uma semana</a></li>
<li><a href="../pt442696/index.html">S for Security: seguran√ßa das coisas na Internet e relat√≥rios no InoThings ++ 2019</a></li>
<li><a href="../pt442698/index.html">Aplicativo de metr√¥ de Moscou para a Windows Store</a></li>
<li><a href="../pt442700/index.html">Vale a pena lidar com usinas de energia solar m√≥veis?</a></li>
<li><a href="../pt442702/index.html">Sobre a magistratura Tinkoff.ru no MIPT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>