<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì≤ üë®üèæ ü§≥üèΩ Verbessern der Funktionalit√§t von Reaktionskomponenten mit React.memo () üë®üèª‚Äç‚úàÔ∏è ‚òïÔ∏è ü§¥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir pr√§sentieren Ihnen eine √úbersetzung des Artikels von Chidume Nnamdi, der auf blog.bitsrc.io ver√∂ffentlicht wurde. Wenn Sie lernen m√∂chten, wie Sie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verbessern der Funktionalit√§t von Reaktionskomponenten mit React.memo ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/442116/">  Wir pr√§sentieren Ihnen eine √úbersetzung des Artikels von Chidume Nnamdi, der auf blog.bitsrc.io ver√∂ffentlicht wurde.  Wenn Sie lernen m√∂chten, wie Sie unn√∂tiges Rendern vermeiden und wie neue Tools in React n√ºtzlich sind, sind Sie bei cat willkommen. <br><br><img src="https://habrastorage.org/webt/pd/cr/7a/pdcr7arl6hgkxg17v5c4laoxsj8.jpeg"><a name="habracut"></a><br><br>  Das React.js-Team arbeitet hart daran, dass React so schnell wie m√∂glich ausgef√ºhrt wird.  Damit Entwickler ihre React-Anwendungen beschleunigen k√∂nnen, wurden die folgenden Tools hinzugef√ºgt: <br><br><ul><li>  React.lazy und Suspense f√ºr verz√∂gertes Laden von Komponenten; </li><li>  Reine Komponente </li><li>  Lifecycle-Hooks solltenComponentUpdate (...) {...}. </li></ul><br>  In diesem Artikel werden wir unter anderem ein weiteres Optimierungstool betrachten, das in React v16.6 hinzugef√ºgt wurde, um Komponentenfunktionen zu beschleunigen - <b>React.memo</b> . <br><br>  Tipp: Verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bit</a> , um React-Komponenten zu installieren und freizugeben.  Verwenden Sie Ihre Komponenten, um neue Anwendungen zu erstellen und diese mit dem Team zu teilen, um die Arbeit zu beschleunigen.  Probieren Sie es aus! <br><br><img src="https://habrastorage.org/webt/uk/nn/k8/uknnk8ugyblbcsges3q5aag8n3m.gif"><br><br><h3>  Zus√§tzliches Rendern </h3><br>  In React entspricht jede Komponente einer Ansichtseinheit.  Komponenten haben auch Zust√§nde.  Wenn sich der Statuswert aufgrund von Benutzeraktionen √§ndert, erkennt die Komponente, dass ein erneutes Zeichnen erforderlich ist.  Die React-Komponente kann beliebig oft neu gezeichnet werden.  In einigen F√§llen ist dies erforderlich, aber meistens k√∂nnen Sie auf einen Renderer verzichten, zumal dies die Anwendung erheblich verlangsamt. <br><br>  Betrachten Sie die folgende Komponente: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div &gt; {</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count} &lt;button onClick={(</span></span></span><span class="hljs-function">)=&gt;</span></span><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({<span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>})}&gt;Click Me&lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div&gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre> <br>  Der Anfangswert des Status {count: 0} ist 0. Wenn Sie auf die Schaltfl√§che Click me klicken, wird der Count-Status zu 1. Auf unserem Bildschirm √§ndert sich 0 ebenfalls zu 1. Wenn wir jedoch erneut auf die Schaltfl√§che klicken, beginnen Probleme: Die Komponente sollte nicht neu gezeichnet werden, da dies der Fall ist Der Zustand hat sich nicht ge√§ndert.  Der Z√§hlerwert "to" ist 1, der neue Wert ist auch eins, was bedeutet, dass das DOM nicht aktualisiert werden muss. <br><br>  Um das Update unseres TestC zu sehen, bei dem derselbe Status zweimal festgelegt wird, habe ich zwei Lebenszyklusmethoden hinzugef√ºgt.  React startet den componentWillUpdate-Zyklus, wenn die Komponente aufgrund einer Status√§nderung aktualisiert / neu gezeichnet wird.  Der Reaktionszyklus componentdidUpdate beginnt, wenn eine Komponente erfolgreich gerendert wurde. <br><br>  Wenn wir die Komponente im Browser starten und mehrmals versuchen, auf die Schaltfl√§che "Klick mich" zu klicken, erhalten wir das folgende Ergebnis: <br><br><img src="https://habrastorage.org/webt/qj/l9/zx/qjl9zx25xiry_bzjrwasb9t4b5k.png"><br><br>  Das Wiederholen des Eintrags componentWillUpdate in unserer Konsole zeigt an, dass die Komponente auch dann neu gezeichnet wird, wenn sich der Status nicht √§ndert.  Dies ist ein zus√§tzlicher Render. <br><br><h3>  Pure Component / shouldComponentUpdate </h3><br>  Mit dem Lifecycle-Hook shouldComponentUpdate wird unn√∂tiges Rendern in React-Komponenten vermieden. <br><br>  React startet die <b>shouldComponentUpdate-</b> Methode zu Beginn des Komponenten-Renderings und erh√§lt gr√ºnes Licht von dieser Methode, um den Prozess fortzusetzen, oder ein Signal, dass der Prozess <b>gesperrt ist</b> . <br><br>  Lassen Sie unser shouldComponentUpdate so aussehen: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><ul><li>  <code>nextProps</code> : Der n√§chste <code>props</code> , den die Komponente erh√§lt. </li><li>  <code>nextState</code> : Der n√§chste <code>nextState</code> , den die Komponente erh√§lt. </li></ul><br>  Daher erlauben wir React, die Komponente zu rendern, da der R√ºckgabewert <code>true</code> . <br><br>  Angenommen, wir schreiben Folgendes: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  In diesem Fall verbieten wir React, die Komponente zu rendern, da <code>false</code> zur√ºckgegeben wird. <br>  Aus dem Obigen folgt, dass wir zum Rendern der Komponente <code>true</code> .  Jetzt k√∂nnen wir die TestC-Komponente wie folgt umschreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.count === nextState.count) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count } &lt;button onClick = { (</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }) }&gt; Click Me &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div&gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre><br>  Wir haben der TestC-Komponente einen shouldComponentUpdate-Hook hinzugef√ºgt.  Jetzt wird der <code>count</code> im aktuellen <code>this.state.count</code> mit dem <code>count</code> im n√§chsten <code>nextState.count</code> <code>this.state.count</code> verglichen.  Wenn sie gleich sind <code>===</code> , wird nicht neu <code>===</code> und <code>false</code> zur√ºckgegeben.  Wenn sie nicht gleich sind, wird <code>true</code> zur√ºckgegeben und ein Renderer gestartet, um den neuen Wert anzuzeigen. <br><br>  Wenn wir den Code in einem Browser testen, sehen wir ein bekanntes Ergebnis: <br><br><img src="https://habrastorage.org/webt/jp/wd/2x/jpwd2xhiz5zckb5f2c-xwosbife.png"><br><br>  Wenn <code>Click Me</code> mehrmals auf die Schaltfl√§che "Klicken" <code>Click Me</code> , sehen wir nur Folgendes (nur einmal angezeigt!): <br><br> <code>componentWillUpdate <br> componentDidUpdate</code> <br> <br><img src="https://habrastorage.org/webt/gy/xc/ir/gyxcir1kjjyki18hzqxdfz5hzeu.png"><br><br>  Sie k√∂nnen den Status der TestC-Komponente auf der Registerkarte React DevTools √§ndern.  Klicken Sie auf die Registerkarte Reagieren, w√§hlen Sie rechts TestC aus, und Sie sehen den Z√§hlerstatuswert: <br><br><img src="https://habrastorage.org/webt/pi/qg/ix/piqgixsafppm6jygqftfm8nkpyq.png"><br><br>  Dieser Wert kann ge√§ndert werden.  Klicken Sie auf den Z√§hlertext, geben Sie 2 ein und dr√ºcken Sie die Eingabetaste. <br><br><img src="https://habrastorage.org/webt/v3/4m/tl/v34mtl_unwz6gmkip2kxw_4a1km.png"><br><br>  Der Z√§hlstatus √§ndert sich und in der Konsole sehen wir: <br><br><pre> <code class="javascript hljs">componentWillUpdate componentDidUpdate componentWillUpdate componentDidUpdate</code> </pre><br><img src="https://habrastorage.org/webt/ql/3y/_i/ql3y_ijc3qwx9byxo_lu8ckbg-g.png"><br><br>  Der vorherige Wert war 1 und der neue Wert war 2, daher war ein erneutes Zeichnen erforderlich. <br>  Fahren wir mit der <b>reinen Komponente fort</b> . <br><br>  Pure Component wurde in React in Version v15.5 angezeigt.  Es wird verwendet, um Standardwerte zu vergleichen ( <code>change detection</code> ).  Mit der <code>extend React.PureComponent</code> Sie Komponenten nicht die Lebenszyklusmethode " <code>shouldComponentUpdate</code> hinzuf√ºgen: Die √Ñnderungsverfolgung erfolgt von selbst. <br><br>  F√ºgen Sie der TestC-Komponente eine PureComponent hinzu. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } <span class="hljs-comment"><span class="hljs-comment">/*shouldComponentUpdate(nextProps, nextState) { if (this.state.count === nextState.count) { return false } return true }*/</span></span> render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count } &lt;button onClick = { (</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }) }&gt; Click Me &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div &gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre><br>  Wie Sie sehen k√∂nnen, <code>shouldComponentUpdate</code> wir <code>shouldComponentUpdate</code> in einen Kommentar.  Wir brauchen es nicht mehr: Die ganze Arbeit erledigt <code>React.PureComponent</code> . <br><br>  Wenn Sie den Browser neu starten, um die neue L√∂sung zu testen, und mehrmals auf die Schaltfl√§che "Klicken" <code>Click Me</code> Folgendes: <br><br><img src="https://habrastorage.org/webt/jp/wd/2x/jpwd2xhiz5zckb5f2c-xwosbife.png"><br><br><img src="https://habrastorage.org/webt/gy/xc/ir/gyxcir1kjjyki18hzqxdfz5hzeu.png"><br><br>  Wie Sie sehen k√∂nnen, wurde nur eine <code>component*Update</code> Eintrag in der Konsole angezeigt. <br><br>  Nachdem wir gesehen haben, wie Sie in React mit dem Neuzeichnen in den Komponentenklassen von ES6 arbeiten, fahren wir mit den Komponentenfunktionen fort.  Wie kann man mit ihnen die gleichen Ergebnisse erzielen? <br><br><h3>  Funktionskomponenten </h3><br>  Wir wissen bereits, wie die Arbeit mit Klassen mithilfe der Lebenszyklusmethode Pure Component und <code>shouldComponentUpdate</code> optimiert <code>shouldComponentUpdate</code> .  Niemand argumentiert, dass Klassenkomponenten die Hauptkomponenten von React sind, aber Sie k√∂nnen Funktionen als Komponenten verwenden. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> I am a functional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) }</code> </pre> <br>  Es ist wichtig, sich daran zu erinnern, dass Funktionskomponenten im Gegensatz zu Klassenkomponenten keinen Status haben (obwohl dies jetzt, da <code>useState</code> Hooks <code>useState</code> sind, argumentiert werden kann), was bedeutet, dass wir ihre Neuzeichnung nicht konfigurieren k√∂nnen.  Die Lebenszyklusmethoden, die wir bei der Arbeit mit Klassen verwendet haben, stehen uns hier nicht zur Verf√ºgung.  Wenn wir Funktionskomponenten Hooks f√ºr den Lebenszyklus hinzuf√ºgen k√∂nnen, k√∂nnen wir die Methode <code>shouldComponentUpdate</code> hinzuf√ºgen, um React mitzuteilen, dass ein Funktionsrenderer ben√∂tigt wird.  (Vielleicht hat der Autor im letzten Satz einen sachlichen Fehler gemacht. - Ungef√§hr Ed.) Und nat√ºrlich k√∂nnen wir die <code>extend React.PureComponent</code> nicht verwenden. <br><br>  Wir verwandeln unsere Komponentenklasse ES6 TestC in eine Komponentenfunktion. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TestC = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Rendering TestC :`</span></span> props) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {props.count} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC; <span class="hljs-comment"><span class="hljs-comment">// App.js &lt;TestC count={5} /&gt;</span></span></code> </pre> <br>  Nach dem Rendern in der Konsole wird der Eintrag <code>Rendering TestC :5</code> . <br><br><img src="https://habrastorage.org/webt/zl/ul/q4/zlulq4t7iokqfn9my1s9yka6v_w.png"><br><br>  √ñffnen Sie DevTools und klicken Sie auf die Registerkarte Reagieren.  Hier werden wir versuchen, den Wert der Eigenschaften der TestC-Komponente zu √§ndern.  W√§hlen Sie TestC aus, und die Z√§hlereigenschaften mit allen Eigenschaften und Werten von TestC werden rechts ge√∂ffnet.  Wir sehen nur den Z√§hler mit dem aktuellen Wert 5. <br><br>  Klicken Sie auf die Nummer 5, um den Wert zu √§ndern.  Stattdessen wird ein Eingabefenster angezeigt. <br><br><img src="https://habrastorage.org/webt/1h/u-/31/1hu-31ov7pulpn2iuqatr667rns.png"><br><br>  Wenn wir den numerischen Wert √§ndern und die Eingabetaste dr√ºcken, √§ndern sich die Eigenschaften der Komponente entsprechend dem eingegebenen Wert.  Angenommen, bei 45. <br><br><img src="https://habrastorage.org/webt/bn/9t/yx/bn9tyxzi3bznqpx_6onqz2athra.png"><br><br>  Wechseln Sie zur Registerkarte Konsole. <br><br><img src="https://habrastorage.org/webt/1m/8a/k8/1m8ak8oggdsmsahkqbg8npptrau.png"><br><br>  Die TestC-Komponente wurde neu gezeichnet, da der vorherige Wert von 5 auf den aktuellen Wert von 45 ge√§ndert wurde. Gehen Sie zur√ºck zur Registerkarte Reagieren, √§ndern Sie den Wert auf 45 und kehren Sie dann zur Konsole zur√ºck. <br><br><img src="https://habrastorage.org/webt/ea/mu/vy/eamuvycxua6dksm8yp_o2b0bcym.png"><br><br>  Wie Sie sehen, wird die Komponente erneut gezeichnet, obwohl der vorherige und der neue Wert identisch sind.  :( <br><br>  Wie verwalte ich einen Renderer? <br><br><h3>  L√∂sung: React.memo () </h3><br>  <code>React.memo()</code> ist eine neue Funktion, die in React v16.6 eingef√ºhrt wurde.  Das Funktionsprinzip √§hnelt dem Prinzip von <code>React.PureComponent</code> : Hilfe beim Verwalten des Neuzeichnens von Komponentenfunktionen.  <code>React.memo(...)</code> f√ºr Klassenkomponenten ist <code>React.PureComponent</code> f√ºr Funktionskomponenten. <br><br>  <b>Wie arbeite ich mit React.memo (...)?</b> <br>  Ziemlich einfach.  Angenommen, wir haben eine Komponentenfunktion. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Funcomponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Hiya!! I am a Funtional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) }</code> </pre><br>  Wir m√ºssen FuncComponent nur als Argument an die Funktion React.memo √ºbergeben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Funcomponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Hiya!! I am a Funtional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemodFuncComponent = React.memo(FunComponent)</code> </pre> <br>  React.memo gibt <code>purified MemodFuncComponent</code> .  Dies werden wir im JSX-Markup zeichnen.  Wenn sich die Eigenschaften und der Status einer Komponente √§ndern, vergleicht React die vorherigen und aktuellen Eigenschaften und Zust√§nde der Komponente.  Und nur wenn sie nicht identisch sind, wird die Komponentenfunktion neu gezeichnet. <br><br>  Wenden Sie dies auf die TestC-Funktionskomponente an. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> TestC = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Rendering TestC :'</span></span>, props) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { props.count } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span></span><span class="xml"> ) } TestC = React.memo(TestC);</span></span></code> </pre> <br>  √ñffnen Sie einen Browser und laden Sie die Anwendung herunter.  √ñffnen Sie DevTools und wechseln Sie zur Registerkarte Reagieren.  W√§hlen Sie <code>&lt;Memo(TestC)&gt;</code> . <br><br>  Wenn wir im Block rechts die Eigenschaften des Z√§hlers auf 89 √§ndern, wird die Anwendung neu gezeichnet. <br><br><img src="https://habrastorage.org/webt/kf/tl/ms/kftlmsn1bznnmh9loxbedc_acqi.png"><br><br>  Wenn wir den Wert auf den vorherigen Wert √§ndern, 89, dann ... <br><br><img src="https://habrastorage.org/webt/j4/ak/tq/j4aktqq4qfwkizulxk2h-em4ism.png"><br><br>  Es wird kein Neuzeichnen geben! <br><br>  Ehre sei React.memo (...)!  :) :) <br><br>  Ohne <code>React.memo(...)</code> in unserem ersten Beispiel wird die TestC-Komponentenfunktion neu gezeichnet, selbst wenn der vorherige Wert auf den identischen Wert ge√§ndert wird.  Dank <code>React.memo(...)</code> k√∂nnen wir jetzt unn√∂tiges Rendern von Komponentenfunktionen vermeiden. <br><br><h3>  Fazit </h3><br><ul><li>  Lassen Sie uns die Liste durchgehen? </li><li>  <code>React.PureComponent</code> - Silber; </li><li>  <code>React.memo(...)</code> - Gold; </li><li>  <code>React.PureComponent</code> arbeitet mit ES6-Klassen. </li><li>  <code>React.memo(...)</code> arbeitet mit Funktionen; </li><li>  <code>React.PureComponent</code> optimiert das Neuzeichnen von ES6-Klassen. </li><li>  <code>React.memo(...)</code> optimiert das Neuzeichnen von Funktionen. </li><li>  Feature-Optimierung ist eine gro√üartige Idee; </li><li>  <code>React</code> wird nie wieder dieselbe sein. </li></ul><br>  Wenn Sie Fragen zum Artikel oder zus√§tzliche Informationen, Korrekturen oder Einw√§nde haben, z√∂gern Sie nicht, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mir</a> Kommentare, E-Mails oder private Nachrichten zu schreiben. <br><br>  Vielen Dank! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442116/">https://habr.com/ru/post/de442116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442104/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 5</a></li>
<li><a href="../de442108/index.html">Leitfaden f√ºr Entwickler zum Erstellen von AI-Anwendungen</a></li>
<li><a href="../de442110/index.html">Antipatterns Vim</a></li>
<li><a href="../de442112/index.html">Neue Programmiersprachen zerst√∂ren leise unsere Verbindung zur Realit√§t</a></li>
<li><a href="../de442114/index.html">Leitfaden zur automatischen Pr√ºfung intelligenter Vertr√§ge. Teil 3: Mithril</a></li>
<li><a href="../de442118/index.html">Der Coinhive-Mining-Pool funktioniert nicht mehr</a></li>
<li><a href="../de442120/index.html">Schulung von TensorFlow-Modellen mit Azure Machine Learning Service</a></li>
<li><a href="../de442122/index.html">Ein einfaches Moskauer Levelord: ein Interview mit dem Sch√∂pfer von Herzog Nukem</a></li>
<li><a href="../de442124/index.html">Facebook gibt den Nutzern die M√∂glichkeit, ihre Geschichte zu bereinigen</a></li>
<li><a href="../de442128/index.html">Leben auf Partikeln</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>