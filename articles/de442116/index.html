<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📲 👨🏾 🤳🏽 Verbessern der Funktionalität von Reaktionskomponenten mit React.memo () 👨🏻‍✈️ ☕️ 🤴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir präsentieren Ihnen eine Übersetzung des Artikels von Chidume Nnamdi, der auf blog.bitsrc.io veröffentlicht wurde. Wenn Sie lernen möchten, wie Sie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verbessern der Funktionalität von Reaktionskomponenten mit React.memo ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/442116/">  Wir präsentieren Ihnen eine Übersetzung des Artikels von Chidume Nnamdi, der auf blog.bitsrc.io veröffentlicht wurde.  Wenn Sie lernen möchten, wie Sie unnötiges Rendern vermeiden und wie neue Tools in React nützlich sind, sind Sie bei cat willkommen. <br><br><img src="https://habrastorage.org/webt/pd/cr/7a/pdcr7arl6hgkxg17v5c4laoxsj8.jpeg"><a name="habracut"></a><br><br>  Das React.js-Team arbeitet hart daran, dass React so schnell wie möglich ausgeführt wird.  Damit Entwickler ihre React-Anwendungen beschleunigen können, wurden die folgenden Tools hinzugefügt: <br><br><ul><li>  React.lazy und Suspense für verzögertes Laden von Komponenten; </li><li>  Reine Komponente </li><li>  Lifecycle-Hooks solltenComponentUpdate (...) {...}. </li></ul><br>  In diesem Artikel werden wir unter anderem ein weiteres Optimierungstool betrachten, das in React v16.6 hinzugefügt wurde, um Komponentenfunktionen zu beschleunigen - <b>React.memo</b> . <br><br>  Tipp: Verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bit</a> , um React-Komponenten zu installieren und freizugeben.  Verwenden Sie Ihre Komponenten, um neue Anwendungen zu erstellen und diese mit dem Team zu teilen, um die Arbeit zu beschleunigen.  Probieren Sie es aus! <br><br><img src="https://habrastorage.org/webt/uk/nn/k8/uknnk8ugyblbcsges3q5aag8n3m.gif"><br><br><h3>  Zusätzliches Rendern </h3><br>  In React entspricht jede Komponente einer Ansichtseinheit.  Komponenten haben auch Zustände.  Wenn sich der Statuswert aufgrund von Benutzeraktionen ändert, erkennt die Komponente, dass ein erneutes Zeichnen erforderlich ist.  Die React-Komponente kann beliebig oft neu gezeichnet werden.  In einigen Fällen ist dies erforderlich, aber meistens können Sie auf einen Renderer verzichten, zumal dies die Anwendung erheblich verlangsamt. <br><br>  Betrachten Sie die folgende Komponente: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div &gt; {</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count} &lt;button onClick={(</span></span></span><span class="hljs-function">)=&gt;</span></span><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({<span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>})}&gt;Click Me&lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div&gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre> <br>  Der Anfangswert des Status {count: 0} ist 0. Wenn Sie auf die Schaltfläche Click me klicken, wird der Count-Status zu 1. Auf unserem Bildschirm ändert sich 0 ebenfalls zu 1. Wenn wir jedoch erneut auf die Schaltfläche klicken, beginnen Probleme: Die Komponente sollte nicht neu gezeichnet werden, da dies der Fall ist Der Zustand hat sich nicht geändert.  Der Zählerwert "to" ist 1, der neue Wert ist auch eins, was bedeutet, dass das DOM nicht aktualisiert werden muss. <br><br>  Um das Update unseres TestC zu sehen, bei dem derselbe Status zweimal festgelegt wird, habe ich zwei Lebenszyklusmethoden hinzugefügt.  React startet den componentWillUpdate-Zyklus, wenn die Komponente aufgrund einer Statusänderung aktualisiert / neu gezeichnet wird.  Der Reaktionszyklus componentdidUpdate beginnt, wenn eine Komponente erfolgreich gerendert wurde. <br><br>  Wenn wir die Komponente im Browser starten und mehrmals versuchen, auf die Schaltfläche "Klick mich" zu klicken, erhalten wir das folgende Ergebnis: <br><br><img src="https://habrastorage.org/webt/qj/l9/zx/qjl9zx25xiry_bzjrwasb9t4b5k.png"><br><br>  Das Wiederholen des Eintrags componentWillUpdate in unserer Konsole zeigt an, dass die Komponente auch dann neu gezeichnet wird, wenn sich der Status nicht ändert.  Dies ist ein zusätzlicher Render. <br><br><h3>  Pure Component / shouldComponentUpdate </h3><br>  Mit dem Lifecycle-Hook shouldComponentUpdate wird unnötiges Rendern in React-Komponenten vermieden. <br><br>  React startet die <b>shouldComponentUpdate-</b> Methode zu Beginn des Komponenten-Renderings und erhält grünes Licht von dieser Methode, um den Prozess fortzusetzen, oder ein Signal, dass der Prozess <b>gesperrt ist</b> . <br><br>  Lassen Sie unser shouldComponentUpdate so aussehen: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><ul><li>  <code>nextProps</code> : Der nächste <code>props</code> , den die Komponente erhält. </li><li>  <code>nextState</code> : Der nächste <code>nextState</code> , den die Komponente erhält. </li></ul><br>  Daher erlauben wir React, die Komponente zu rendern, da der Rückgabewert <code>true</code> . <br><br>  Angenommen, wir schreiben Folgendes: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  In diesem Fall verbieten wir React, die Komponente zu rendern, da <code>false</code> zurückgegeben wird. <br>  Aus dem Obigen folgt, dass wir zum Rendern der Komponente <code>true</code> .  Jetzt können wir die TestC-Komponente wie folgt umschreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.count === nextState.count) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count } &lt;button onClick = { (</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }) }&gt; Click Me &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div&gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre><br>  Wir haben der TestC-Komponente einen shouldComponentUpdate-Hook hinzugefügt.  Jetzt wird der <code>count</code> im aktuellen <code>this.state.count</code> mit dem <code>count</code> im nächsten <code>nextState.count</code> <code>this.state.count</code> verglichen.  Wenn sie gleich sind <code>===</code> , wird nicht neu <code>===</code> und <code>false</code> zurückgegeben.  Wenn sie nicht gleich sind, wird <code>true</code> zurückgegeben und ein Renderer gestartet, um den neuen Wert anzuzeigen. <br><br>  Wenn wir den Code in einem Browser testen, sehen wir ein bekanntes Ergebnis: <br><br><img src="https://habrastorage.org/webt/jp/wd/2x/jpwd2xhiz5zckb5f2c-xwosbife.png"><br><br>  Wenn <code>Click Me</code> mehrmals auf die Schaltfläche "Klicken" <code>Click Me</code> , sehen wir nur Folgendes (nur einmal angezeigt!): <br><br> <code>componentWillUpdate <br> componentDidUpdate</code> <br> <br><img src="https://habrastorage.org/webt/gy/xc/ir/gyxcir1kjjyki18hzqxdfz5hzeu.png"><br><br>  Sie können den Status der TestC-Komponente auf der Registerkarte React DevTools ändern.  Klicken Sie auf die Registerkarte Reagieren, wählen Sie rechts TestC aus, und Sie sehen den Zählerstatuswert: <br><br><img src="https://habrastorage.org/webt/pi/qg/ix/piqgixsafppm6jygqftfm8nkpyq.png"><br><br>  Dieser Wert kann geändert werden.  Klicken Sie auf den Zählertext, geben Sie 2 ein und drücken Sie die Eingabetaste. <br><br><img src="https://habrastorage.org/webt/v3/4m/tl/v34mtl_unwz6gmkip2kxw_4a1km.png"><br><br>  Der Zählstatus ändert sich und in der Konsole sehen wir: <br><br><pre> <code class="javascript hljs">componentWillUpdate componentDidUpdate componentWillUpdate componentDidUpdate</code> </pre><br><img src="https://habrastorage.org/webt/ql/3y/_i/ql3y_ijc3qwx9byxo_lu8ckbg-g.png"><br><br>  Der vorherige Wert war 1 und der neue Wert war 2, daher war ein erneutes Zeichnen erforderlich. <br>  Fahren wir mit der <b>reinen Komponente fort</b> . <br><br>  Pure Component wurde in React in Version v15.5 angezeigt.  Es wird verwendet, um Standardwerte zu vergleichen ( <code>change detection</code> ).  Mit der <code>extend React.PureComponent</code> Sie Komponenten nicht die Lebenszyklusmethode " <code>shouldComponentUpdate</code> hinzufügen: Die Änderungsverfolgung erfolgt von selbst. <br><br>  Fügen Sie der TestC-Komponente eine PureComponent hinzu. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } <span class="hljs-comment"><span class="hljs-comment">/*shouldComponentUpdate(nextProps, nextState) { if (this.state.count === nextState.count) { return false } return true }*/</span></span> render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count } &lt;button onClick = { (</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }) }&gt; Click Me &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div &gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre><br>  Wie Sie sehen können, <code>shouldComponentUpdate</code> wir <code>shouldComponentUpdate</code> in einen Kommentar.  Wir brauchen es nicht mehr: Die ganze Arbeit erledigt <code>React.PureComponent</code> . <br><br>  Wenn Sie den Browser neu starten, um die neue Lösung zu testen, und mehrmals auf die Schaltfläche "Klicken" <code>Click Me</code> Folgendes: <br><br><img src="https://habrastorage.org/webt/jp/wd/2x/jpwd2xhiz5zckb5f2c-xwosbife.png"><br><br><img src="https://habrastorage.org/webt/gy/xc/ir/gyxcir1kjjyki18hzqxdfz5hzeu.png"><br><br>  Wie Sie sehen können, wurde nur eine <code>component*Update</code> Eintrag in der Konsole angezeigt. <br><br>  Nachdem wir gesehen haben, wie Sie in React mit dem Neuzeichnen in den Komponentenklassen von ES6 arbeiten, fahren wir mit den Komponentenfunktionen fort.  Wie kann man mit ihnen die gleichen Ergebnisse erzielen? <br><br><h3>  Funktionskomponenten </h3><br>  Wir wissen bereits, wie die Arbeit mit Klassen mithilfe der Lebenszyklusmethode Pure Component und <code>shouldComponentUpdate</code> optimiert <code>shouldComponentUpdate</code> .  Niemand argumentiert, dass Klassenkomponenten die Hauptkomponenten von React sind, aber Sie können Funktionen als Komponenten verwenden. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> I am a functional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) }</code> </pre> <br>  Es ist wichtig, sich daran zu erinnern, dass Funktionskomponenten im Gegensatz zu Klassenkomponenten keinen Status haben (obwohl dies jetzt, da <code>useState</code> Hooks <code>useState</code> sind, argumentiert werden kann), was bedeutet, dass wir ihre Neuzeichnung nicht konfigurieren können.  Die Lebenszyklusmethoden, die wir bei der Arbeit mit Klassen verwendet haben, stehen uns hier nicht zur Verfügung.  Wenn wir Funktionskomponenten Hooks für den Lebenszyklus hinzufügen können, können wir die Methode <code>shouldComponentUpdate</code> hinzufügen, um React mitzuteilen, dass ein Funktionsrenderer benötigt wird.  (Vielleicht hat der Autor im letzten Satz einen sachlichen Fehler gemacht. - Ungefähr Ed.) Und natürlich können wir die <code>extend React.PureComponent</code> nicht verwenden. <br><br>  Wir verwandeln unsere Komponentenklasse ES6 TestC in eine Komponentenfunktion. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TestC = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Rendering TestC :`</span></span> props) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {props.count} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC; <span class="hljs-comment"><span class="hljs-comment">// App.js &lt;TestC count={5} /&gt;</span></span></code> </pre> <br>  Nach dem Rendern in der Konsole wird der Eintrag <code>Rendering TestC :5</code> . <br><br><img src="https://habrastorage.org/webt/zl/ul/q4/zlulq4t7iokqfn9my1s9yka6v_w.png"><br><br>  Öffnen Sie DevTools und klicken Sie auf die Registerkarte Reagieren.  Hier werden wir versuchen, den Wert der Eigenschaften der TestC-Komponente zu ändern.  Wählen Sie TestC aus, und die Zählereigenschaften mit allen Eigenschaften und Werten von TestC werden rechts geöffnet.  Wir sehen nur den Zähler mit dem aktuellen Wert 5. <br><br>  Klicken Sie auf die Nummer 5, um den Wert zu ändern.  Stattdessen wird ein Eingabefenster angezeigt. <br><br><img src="https://habrastorage.org/webt/1h/u-/31/1hu-31ov7pulpn2iuqatr667rns.png"><br><br>  Wenn wir den numerischen Wert ändern und die Eingabetaste drücken, ändern sich die Eigenschaften der Komponente entsprechend dem eingegebenen Wert.  Angenommen, bei 45. <br><br><img src="https://habrastorage.org/webt/bn/9t/yx/bn9tyxzi3bznqpx_6onqz2athra.png"><br><br>  Wechseln Sie zur Registerkarte Konsole. <br><br><img src="https://habrastorage.org/webt/1m/8a/k8/1m8ak8oggdsmsahkqbg8npptrau.png"><br><br>  Die TestC-Komponente wurde neu gezeichnet, da der vorherige Wert von 5 auf den aktuellen Wert von 45 geändert wurde. Gehen Sie zurück zur Registerkarte Reagieren, ändern Sie den Wert auf 45 und kehren Sie dann zur Konsole zurück. <br><br><img src="https://habrastorage.org/webt/ea/mu/vy/eamuvycxua6dksm8yp_o2b0bcym.png"><br><br>  Wie Sie sehen, wird die Komponente erneut gezeichnet, obwohl der vorherige und der neue Wert identisch sind.  :( <br><br>  Wie verwalte ich einen Renderer? <br><br><h3>  Lösung: React.memo () </h3><br>  <code>React.memo()</code> ist eine neue Funktion, die in React v16.6 eingeführt wurde.  Das Funktionsprinzip ähnelt dem Prinzip von <code>React.PureComponent</code> : Hilfe beim Verwalten des Neuzeichnens von Komponentenfunktionen.  <code>React.memo(...)</code> für Klassenkomponenten ist <code>React.PureComponent</code> für Funktionskomponenten. <br><br>  <b>Wie arbeite ich mit React.memo (...)?</b> <br>  Ziemlich einfach.  Angenommen, wir haben eine Komponentenfunktion. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Funcomponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Hiya!! I am a Funtional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) }</code> </pre><br>  Wir müssen FuncComponent nur als Argument an die Funktion React.memo übergeben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Funcomponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Hiya!! I am a Funtional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemodFuncComponent = React.memo(FunComponent)</code> </pre> <br>  React.memo gibt <code>purified MemodFuncComponent</code> .  Dies werden wir im JSX-Markup zeichnen.  Wenn sich die Eigenschaften und der Status einer Komponente ändern, vergleicht React die vorherigen und aktuellen Eigenschaften und Zustände der Komponente.  Und nur wenn sie nicht identisch sind, wird die Komponentenfunktion neu gezeichnet. <br><br>  Wenden Sie dies auf die TestC-Funktionskomponente an. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> TestC = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Rendering TestC :'</span></span>, props) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { props.count } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span></span><span class="xml"> ) } TestC = React.memo(TestC);</span></span></code> </pre> <br>  Öffnen Sie einen Browser und laden Sie die Anwendung herunter.  Öffnen Sie DevTools und wechseln Sie zur Registerkarte Reagieren.  Wählen Sie <code>&lt;Memo(TestC)&gt;</code> . <br><br>  Wenn wir im Block rechts die Eigenschaften des Zählers auf 89 ändern, wird die Anwendung neu gezeichnet. <br><br><img src="https://habrastorage.org/webt/kf/tl/ms/kftlmsn1bznnmh9loxbedc_acqi.png"><br><br>  Wenn wir den Wert auf den vorherigen Wert ändern, 89, dann ... <br><br><img src="https://habrastorage.org/webt/j4/ak/tq/j4aktqq4qfwkizulxk2h-em4ism.png"><br><br>  Es wird kein Neuzeichnen geben! <br><br>  Ehre sei React.memo (...)!  :) :) <br><br>  Ohne <code>React.memo(...)</code> in unserem ersten Beispiel wird die TestC-Komponentenfunktion neu gezeichnet, selbst wenn der vorherige Wert auf den identischen Wert geändert wird.  Dank <code>React.memo(...)</code> können wir jetzt unnötiges Rendern von Komponentenfunktionen vermeiden. <br><br><h3>  Fazit </h3><br><ul><li>  Lassen Sie uns die Liste durchgehen? </li><li>  <code>React.PureComponent</code> - Silber; </li><li>  <code>React.memo(...)</code> - Gold; </li><li>  <code>React.PureComponent</code> arbeitet mit ES6-Klassen. </li><li>  <code>React.memo(...)</code> arbeitet mit Funktionen; </li><li>  <code>React.PureComponent</code> optimiert das Neuzeichnen von ES6-Klassen. </li><li>  <code>React.memo(...)</code> optimiert das Neuzeichnen von Funktionen. </li><li>  Feature-Optimierung ist eine großartige Idee; </li><li>  <code>React</code> wird nie wieder dieselbe sein. </li></ul><br>  Wenn Sie Fragen zum Artikel oder zusätzliche Informationen, Korrekturen oder Einwände haben, zögern Sie nicht, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mir</a> Kommentare, E-Mails oder private Nachrichten zu schreiben. <br><br>  Vielen Dank! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442116/">https://habr.com/ru/post/de442116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442104/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 5</a></li>
<li><a href="../de442108/index.html">Leitfaden für Entwickler zum Erstellen von AI-Anwendungen</a></li>
<li><a href="../de442110/index.html">Antipatterns Vim</a></li>
<li><a href="../de442112/index.html">Neue Programmiersprachen zerstören leise unsere Verbindung zur Realität</a></li>
<li><a href="../de442114/index.html">Leitfaden zur automatischen Prüfung intelligenter Verträge. Teil 3: Mithril</a></li>
<li><a href="../de442118/index.html">Der Coinhive-Mining-Pool funktioniert nicht mehr</a></li>
<li><a href="../de442120/index.html">Schulung von TensorFlow-Modellen mit Azure Machine Learning Service</a></li>
<li><a href="../de442122/index.html">Ein einfaches Moskauer Levelord: ein Interview mit dem Schöpfer von Herzog Nukem</a></li>
<li><a href="../de442124/index.html">Facebook gibt den Nutzern die Möglichkeit, ihre Geschichte zu bereinigen</a></li>
<li><a href="../de442128/index.html">Leben auf Partikeln</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>