<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↪️ 🏟️ 🗺️ Air Terjun Kompleks dan Arsitektur Sesuai Permintaan 👶🏽 🔝 🤦🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika berbicara tentang "kode buruk" orang hampir pasti berarti "kode kompleks" di antara masalah populer lainnya. Hal tentang kompleksitas adalah ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Air Terjun Kompleks dan Arsitektur Sesuai Permintaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472876/"><p><img src="https://habrastorage.org/webt/g9/_9/wk/g9_9wkgu4h6i8xyelaq9p5nwmjy.png" alt="Logo"></p><br><p>  Ketika berbicara tentang "kode buruk" orang hampir pasti berarti "kode kompleks" di antara masalah populer lainnya.  Hal tentang kompleksitas adalah bahwa ia muncul entah dari mana.  Suatu hari Anda memulai proyek yang cukup sederhana, hari lain Anda menemukannya dalam reruntuhan.  Dan tidak ada yang tahu bagaimana dan kapan itu terjadi. </p><br><p>  Tapi, ini akhirnya terjadi karena suatu alasan!  Kompleksitas kode memasuki basis kode Anda dengan dua cara yang mungkin: dengan potongan besar dan tambahan tambahan.  Dan orang-orang buruk dalam meninjau dan menemukan keduanya. </p><a name="habracut"></a><br><p>  Ketika sejumlah besar kode masuk, peninjau akan ditantang untuk menemukan lokasi yang tepat di mana kode itu kompleks dan apa yang harus dilakukan.  Kemudian, ulasan harus membuktikan poinnya: mengapa kode ini rumit sejak awal.  Dan pengembang lain mungkin tidak setuju.  Kita semua tahu jenis ulasan kode ini! </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/198/8ff/e0e/1988ffe0e3d5dc3b29b4743630b52e06.png" alt="Jumlah baris untuk rasio ulasan dan komentar"></p><br><p> Cara kerumitan kedua yang masuk ke kode Anda adalah penambahan tambahan: ketika Anda mengirimkan satu atau dua baris ke fungsi yang ada.  Dan sangat sulit untuk mengetahui bahwa fungsi Anda baik-baik saja satu komit yang lalu, tetapi sekarang terlalu kompleks.  Dibutuhkan sebagian besar konsentrasi, keterampilan meninjau, dan praktik navigasi kode yang baik untuk benar-benar melihatnya.  Kebanyakan orang (seperti saya!) Tidak memiliki keterampilan ini dan memungkinkan kompleksitas untuk memasuki basis kode secara teratur. </p><br><p>  Jadi, apa yang dapat dilakukan untuk mencegah kode Anda menjadi rumit?  Kita perlu menggunakan otomatisasi!  Mari kita selami kedalaman kode dan cara menemukan dan menyelesaikannya. </p><br><p>  Dalam artikel ini, saya akan memandu Anda melalui tempat-tempat di mana kompleksitas hidup dan bagaimana cara untuk melawannya di sana.  Kemudian kita akan membahas seberapa baik kode sederhana dan otomasi memungkinkan peluang gaya pengembangan "Continous Refactoring" dan "Architecture on Demand". </p><br><h2 id="complexity-explained">  Kompleksitas dijelaskan </h2><br><p>  Orang mungkin bertanya: apa sebenarnya "kompleksitas kode" itu?  Dan meskipun terdengar akrab, ada hambatan tersembunyi dalam memahami lokasi kompleksitas yang tepat.  Mari kita mulai dengan bagian paling primitif dan kemudian pindah ke entitas tingkat yang lebih tinggi. </p><br><p>  Ingat, bahwa artikel ini bernama "Air Terjun Kompleksitas"?  Saya akan menunjukkan kepada Anda bagaimana kompleksitas dari primitif paling sederhana meluap ke abstraksi tertinggi. </p><br><p> Saya akan menggunakan <code>python</code> sebagai bahasa utama untuk contoh saya dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>wemake-python-styleguide</code></a> sebagai alat linting utama untuk menemukan pelanggaran dalam kode saya dan menggambarkan poin saya. </p><br><h3 id="expressions">  Ekspresi </h3><br><p>  Semua kode Anda terdiri dari ekspresi sederhana seperti <code>a + 1</code> dan <code>print(x)</code> .  Meskipun ekspresi itu sendiri sederhana, mereka mungkin meluap kode Anda dengan kerumitan di beberapa titik.  Contoh: bayangkan Anda memiliki kamus yang mewakili beberapa model <code>User</code> dan Anda menggunakannya seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">format_username</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user)</span></span></span><span class="hljs-function"> -&gt; str:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> user[<span class="hljs-string"><span class="hljs-string">'username'</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user[<span class="hljs-string"><span class="hljs-string">'email'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(user[<span class="hljs-string"><span class="hljs-string">'username'</span></span>]) &gt; <span class="hljs-number"><span class="hljs-number">12</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user[<span class="hljs-string"><span class="hljs-string">'username'</span></span>][:<span class="hljs-number"><span class="hljs-number">12</span></span>] + <span class="hljs-string"><span class="hljs-string">'...'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'@'</span></span> + user[<span class="hljs-string"><span class="hljs-string">'username'</span></span>]</code> </pre> <br><p>  Terlihat sangat sederhana, bukan?  Bahkan, itu berisi dua masalah kompleksitas berbasis ekspresi.  Itu terlalu sering <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>overuses 'username'</code> string <code>overuses 'username'</code></a> dan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">angka ajaib</a> <code>12</code> (mengapa kita menggunakan nomor ini di tempat pertama, mengapa tidak <code>13</code> atau <code>10</code> ?).  Sulit untuk menemukan hal-hal semacam ini sendirian.  Begini tampilan versi yang lebih baik: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#: That's how many chars fit in the preview box. LENGTH_LIMIT: Final = 12 def format_username(user) -&gt; str: username = user['username'] if not username: return user['email'] elif len(username) &gt; LENGTH_LIMIT: # See? It is now documented return username[:LENGTH_LIMIT] + '...' return '@' + username</span></span></code> </pre> <br><p>  Ada berbagai masalah dengan ekspresi juga.  Kami juga dapat memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekspresi yang terlalu sering digunakan</a> : ketika Anda menggunakan atribut <code>some_object.some_attr</code> mana saja alih-alih membuat variabel lokal baru.  Kami juga dapat memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kondisi logika yang terlalu kompleks</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akses dot yang terlalu dalam</a> . </p><br><p>  <strong>Solusi</strong> : buat variabel, argumen, atau konstanta baru.  Buat dan gunakan fungsi atau metode utilitas baru jika Anda harus. </p><br><h3 id="lines">  Garis </h3><br><p>  Ekspresi dari baris kode (tolong, jangan bingung baris dengan pernyataan: pernyataan tunggal dapat mengambil beberapa baris dan beberapa pernyataan mungkin terletak pada satu baris). </p><br><p>  Metrik kompleksitas pertama dan paling jelas untuk sebuah garis adalah panjangnya.  Ya, Anda mendengarnya dengan benar.  Itu sebabnya kami (programmer) lebih suka tetap berpegang pada aturan <code>80</code> karakter per baris dan bukan karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya digunakan</a> dalam teletypewriter.  Ada banyak desas-desus tentang hal itu akhir-akhir ini, mengatakan bahwa tidak masuk akal untuk menggunakan <code>80</code> karakter untuk kode Anda dalam 2k19.  Tapi, itu jelas tidak benar. </p><br><p>  Idenya sederhana.  Anda dapat memiliki logika dua kali lebih banyak dalam satu baris dengan <code>160</code> karakter dibandingkan dengan hanya <code>80</code> karakter.  Itu sebabnya batas ini harus ditetapkan dan ditegakkan.  Ingat, ini <em>bukan pilihan gaya</em> .  Ini adalah metrik kompleksitas! </p><br><p>  Metrik kompleksitas jalur utama kedua kurang dikenal dan kurang digunakan.  Ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kompleksitas Jones</a> .  Gagasan di baliknya sederhana: kita menghitung node kode (atau <code>ast</code> ) dalam satu baris untuk mendapatkan kompleksitasnya.  Mari kita lihat contohnya.  Kedua garis ini pada dasarnya berbeda dalam hal kompleksitas tetapi memiliki lebar yang sama persis dalam karakter: </p><br><pre> <code class="python hljs">print(first_long_name_with_meaning, second_very_long_name_with_meaning, third) print(first * <span class="hljs-number"><span class="hljs-number">5</span></span> + math.pi * <span class="hljs-number"><span class="hljs-number">2</span></span>, matrix.trans(*matrix), display.show(matrix, <span class="hljs-number"><span class="hljs-number">2</span></span>))</code> </pre> <br><p>  Mari kita hitung simpul di yang pertama: satu panggilan, tiga nama.  Empat node secara total.  Yang kedua memiliki dua puluh satu <code>ast</code> node.  Nah, perbedaannya jelas.  Itu sebabnya kami menggunakan metrik Kompleksitas Jones untuk memungkinkan garis panjang pertama dan melarang yang kedua berdasarkan kompleksitas internal, bukan hanya pada panjang mentah. </p><br><p>  Apa yang harus dilakukan dengan garis dengan skor Kompleksitas Jones yang tinggi? </p><br><p>  <strong>Solusi</strong> : Bagi mereka menjadi beberapa baris atau buat variabel perantara baru, fungsi utilitas, kelas baru, dll. </p><br><pre> <code class="python hljs">print( first * <span class="hljs-number"><span class="hljs-number">5</span></span> + math.pi * <span class="hljs-number"><span class="hljs-number">2</span></span>, matrix.trans(*matrix), display.show(matrix, <span class="hljs-number"><span class="hljs-number">2</span></span>), )</code> </pre> <br><p>  Sekarang cara ini lebih mudah dibaca! </p><br><h3 id="structures">  Struktur </h3><br><p>  Langkah selanjutnya adalah menganalisis struktur bahasa seperti <code>if</code> , <code>for</code> , <code>with</code> , dll yang dibentuk dari garis dan ekspresi.  Saya harus mengatakan bahwa poin ini sangat spesifik bahasa.  Saya akan menampilkan beberapa aturan dari kategori ini menggunakan <code>python</code> juga. </p><br><p>  Kami akan mulai dengan <code>if</code> .  Apa yang bisa lebih mudah daripada orang tua yang baik <code>if</code> ?  Sebenarnya, <code>if</code> mulai rumit sangat cepat.  Berikut adalah contoh bagaimana seseorang dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>reimplement switch</code></a> dengan <code>if</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(some, int): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, float): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, complex): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, str): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, bytes): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, list): ...</code> </pre> <br><p>  Apa masalah dengan kode ini?  Nah, bayangkan bahwa kita memiliki puluhan tipe data yang harus dicakup termasuk data bea cukai yang belum kita sadari.  Maka kode kompleks ini adalah indikator bahwa kita memilih pola yang salah di sini.  Kita perlu memperbaiki kode kita untuk memperbaiki masalah ini.  Misalnya, seseorang dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>typeclass</code> es</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>typeclass</code></a> .  Mereka pekerjaan yang sama, tetapi lebih baik. </p><br><p>  <code>python</code> tidak pernah berhenti untuk menghibur kita.  Misalnya, Anda dapat menulis <code>with</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jumlah kasus yang sewenang-wenang</a> , yang terlalu rumit secara mental dan membingungkan: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> first(), second(), third(), fourth(): ...</code> </pre> <br><p>  Anda juga dapat menulis pemahaman dengan sejumlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>if</code></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>for</code></a> ekspresi, yang dapat menyebabkan kode yang kompleks dan tidak dapat dibaca: </p><br><pre> <code class="python hljs">[ (x, y, z) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x_coords <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> y_coords <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> z <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> z_coords <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x + y &lt;= z <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x + z &lt;= y <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y + z &lt;= x ]</code> </pre> <br><p>  Bandingkan dengan versi yang sederhana dan mudah dibaca: </p><br><pre> <code class="python hljs">[ (x, y, z) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x, y, x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> itertools.product(x_coords, y_coords, z_coords) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> valid_coordinates(x, y, z) ]</code> </pre> <br><p>  Anda juga dapat secara tidak sengaja memasukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>multiple statements inside a try</code></a> , yang tidak aman karena dapat meningkatkan dan menangani pengecualian di tempat yang diharapkan: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: user = fetch_user() <span class="hljs-comment"><span class="hljs-comment"># Can also fail, but don't expect that log.save_user_operation(user.email) # Can fail, and we know it except MyCustomException as exc: ...</span></span></code> </pre> <br><p>  Dan itu bahkan tidak 10% dari kasus yang dapat dan akan salah dengan kode <code>python</code> Anda.  Ada banyak, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih</a> banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lagi kasus tepi</a> yang harus dilacak dan dianalisis. </p><br><p>  <strong>Solusi</strong> : Satu-satunya solusi yang mungkin adalah menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">linter yang bagus</a> untuk bahasa pilihan Anda.  Dan refactor tempat kompleks yang menyoroti ini.  Jika tidak, Anda harus menemukan kembali roda dan menetapkan kebijakan khusus untuk masalah yang sama persis. </p><br><h3 id="functions">  Fungsi </h3><br><p>  Ekspresi, pernyataan, dan struktur membentuk fungsi.  Kompleksitas dari entitas ini mengalir ke fungsi.  Dan di situlah hal-hal mulai menarik.  Karena fungsi memiliki lusinan metrik kompleksitas: baik dan buruk. </p><br><p>  Kita akan mulai dengan yang paling dikenal: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompleksitas siklomatik</a> dan panjang fungsi diukur dalam baris kode.  Kompleksitas siklus menunjukkan berapa banyak putaran yang dapat dilakukan oleh alur eksekusi Anda: hampir sama dengan jumlah unit test yang diperlukan untuk sepenuhnya mencakup kode sumber.  Ini adalah metrik yang baik karena menghormati semantik dan membantu pengembang untuk melakukan refactoring.  Di sisi lain, panjang fungsi adalah metrik yang buruk.  Itu tidak cocok dengan metrik Kompleksitas Jones yang telah dijelaskan sebelumnya karena kita sudah tahu: banyak baris lebih mudah dibaca daripada satu baris besar dengan semua yang ada di dalamnya.  Kami akan berkonsentrasi hanya pada metrik yang baik dan mengabaikan yang buruk. </p><br><p>  Berdasarkan pengalaman saya, beberapa metrik kompleksitas yang berguna harus dihitung alih-alih panjang fungsi reguler: </p><br><ul><li>  Jumlah dekorator fungsi;  lebih rendah lebih baik </li><li>  Jumlah argumen;  lebih rendah lebih baik </li><li>  Jumlah anotasi;  lebih tinggi lebih baik </li><li>  Jumlah variabel lokal;  lebih rendah lebih baik </li><li>  Jumlah pengembalian, hasil, menunggu;  lebih rendah lebih baik </li><li>  Jumlah pernyataan dan ekspresi;  lebih rendah lebih baik </li></ul><br><p>  Kombinasi dari semua pemeriksaan ini benar-benar memungkinkan Anda untuk menulis fungsi sederhana (semua aturan juga berlaku untuk metode). </p><br><p>  Ketika Anda akan mencoba melakukan beberapa hal buruk dengan fungsi Anda, Anda pasti akan mematahkan setidaknya satu metrik.  Dan ini akan mengecewakan linter kami dan menghancurkan build Anda.  Akibatnya, fungsi Anda akan disimpan. </p><br><p>  <strong>Solusi</strong> : ketika satu fungsi terlalu kompleks, satu-satunya solusi yang Anda miliki adalah dengan membagi fungsi ini menjadi beberapa fungsi. </p><br><h3 id="classes">  Kelas </h3><br><p>  Level abstraksi berikutnya setelah fungsi adalah kelas.  Dan seperti yang sudah Anda duga mereka bahkan lebih kompleks dan cair daripada fungsi.  Karena kelas mungkin berisi beberapa fungsi di dalam (yang disebut metode) dan memiliki fitur unik lainnya seperti warisan dan mixin, atribut tingkat kelas dan dekorator tingkat kelas.  Jadi, kita harus memeriksa semua metode sebagai fungsi dan tubuh kelas itu sendiri. </p><br><p>  Untuk kelas kita harus mengukur metrik berikut: </p><br><ul><li>  Jumlah dekorator tingkat kelas;  lebih rendah lebih baik </li><li>  Jumlah kelas dasar;  lebih rendah lebih baik </li><li>  Jumlah atribut publik tingkat kelas;  lebih rendah lebih baik </li><li>  Jumlah atribut publik tingkat instance;  lebih rendah lebih baik </li><li>  Jumlah metode;  lebih rendah lebih baik </li></ul><br><p>  Ketika salah satu dari ini terlalu rumit - kita harus membunyikan alarm dan gagal membangun! </p><br><p>  <strong>Solusi</strong> : refactor kelas gagal Anda!  Membagi satu kelas kompleks yang ada menjadi beberapa kelas sederhana atau membuat fungsi utilitas baru dan menggunakan komposisi. </p><br><p>  Disebutkan: seseorang juga dapat melacak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metrik</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kohesi</a> dan kopling untuk memvalidasi kompleksitas desain OOP Anda. </p><br><h3 id="modules">  Modul </h3><br><p>  Modul memang berisi banyak pernyataan, fungsi, dan kelas.  Dan seperti yang mungkin telah Anda sebutkan, kami biasanya menyarankan untuk membagi fungsi dan kelas menjadi yang baru.  Itu sebabnya kita harus mengawasi kompleksitas modul: itu benar-benar mengalir ke modul dari kelas dan fungsi. </p><br><p>  Untuk menganalisis kompleksitas modul kita harus memeriksa: </p><br><ul><li>  Jumlah impor dan nama yang diimpor;  lebih rendah lebih baik </li><li>  Jumlah kelas dan fungsi;  lebih rendah lebih baik </li><li>  Kompleksitas rata-rata fungsi dan kelas di dalamnya;  lebih rendah lebih baik </li></ul><br><p>  Apa yang kita lakukan dalam modul yang kompleks? </p><br><p>  <strong>Solusi</strong> : ya, Anda benar.  Kami membagi satu modul menjadi beberapa modul. </p><br><h3 id="packages">  Paket </h3><br><p>  Paket berisi beberapa modul.  Untungnya, hanya itu yang mereka lakukan. </p><br><p>  Jadi, sejumlah modul dalam satu paket dapat segera mulai menjadi terlalu besar, sehingga Anda akan berakhir dengan terlalu banyak modul.  Dan itu adalah satu-satunya kompleksitas yang dapat ditemukan dengan paket. </p><br><p>  <strong>Solusi</strong> : Anda harus membagi paket menjadi sub-paket dan paket dari berbagai tingkatan. </p><br><h2 id="complexity-waterfall-effect">  Efek air terjun yang kompleks </h2><br><p>  Kami sekarang telah membahas hampir semua jenis abstraksi yang mungkin ada dalam basis kode Anda.  Apa yang telah kita pelajari darinya?  Takeaway utama, untuk saat ini, adalah bahwa sebagian besar masalah dapat diselesaikan dengan mengeluarkan kompleksitas ke tingkat abstraksi yang sama atau atas. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9b6/8ad/453/9b68ad45340cdf61f51a8deb2c07930d.png" alt="Air terjun yang kompleks"></p><br><p>  Ini membawa kita pada ide terpenting dari artikel ini: jangan biarkan kode Anda dipenuhi dengan kerumitan.  Saya akan memberikan beberapa contoh bagaimana biasanya terjadi. </p><br><p>  Bayangkan Anda sedang mengimplementasikan fitur baru.  Dan itulah satu-satunya perubahan yang Anda lakukan: </p><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">+++ if user.is_active and user.has_sub() and sub.is_due(tz.now() + delta): --- if user.is_active and user.has_sub():</span></span></code> </pre> <br><p>  Terlihat ok, saya akan memberikan kode ini saat ditinjau.  Dan tidak ada hal buruk yang akan terjadi.  Tapi, poin yang saya lewatkan adalah bahwa kompleksitas meluap garis ini!  Itulah yang akan <code>wemake-python-styleguide</code> oleh <code>wemake-python-styleguide</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c87/b9e/0e5/c87b9e0e584a8cd01235e0ae7695a6c0.png" alt="wemake-python-styleguide-output"></p><br><p>  Ok, kita sekarang harus menyelesaikan kompleksitas ini.  Mari kita membuat variabel baru: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">can_be_purchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user_id)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> ... is_sub_paid = sub.is_due(tz.now() + delta) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> user.is_active <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> user.has_sub() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_sub_paid: ... ... ...</code> </pre> <br><p>  Sekarang, kompleksitas garis terpecahkan.  Tapi tunggu sebentar.  Bagaimana jika fungsi kita memiliki terlalu banyak variabel sekarang?  Karena kami telah membuat variabel baru tanpa memeriksa nomor mereka di dalam fungsi terlebih dahulu.  Dalam hal ini kita harus membagi metode ini menjadi beberapa yang seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">can_be_purchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user_id)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._has_paid_sub(user, sub, delta): ... ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_has_paid_sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user, sub, delta)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> is_sub_paid = sub.is_due(tz.now() + delta) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user.is_active <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> user.has_sub() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_sub_paid ...</code> </pre> <br><p>  Sekarang kita selesai!  Benar?  Tidak, karena kita sekarang harus memeriksa kompleksitas kelas <code>Product</code> .  Bayangkan, itu sekarang memiliki terlalu banyak metode karena kita telah membuat <code>_has_paid_sub</code> baru. </p><br><p>  Ok, kita jalankan linter kita untuk memeriksa kompleksitasnya lagi.  Dan ternyata kelas <code>Product</code> kami memang terlalu rumit saat ini.  Tindakan kita?  Kami membaginya menjadi beberapa kelas! </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Policy</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubcsriptionPolicy</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Policy)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">can_be_purchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user_id)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._has_paid_sub(user, sub, delta): ... ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_has_paid_sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user, sub, delta)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> is_sub_paid = sub.is_due(tz.now() + delta) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user.is_active <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> user.has_sub() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_sub_paid <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> _purchasing_policy: Policy ... ...</code> </pre> <br><p>  Tolong beritahu saya bahwa itu adalah iterasi terakhir!  Maaf, tapi sekarang kita harus memeriksa kompleksitas modul.  Dan coba tebak?  Kami sekarang memiliki terlalu banyak anggota modul.  Jadi, kita harus membagi modul menjadi yang terpisah!  Kemudian kami memeriksa kompleksitas paket.  Dan juga mungkin membaginya menjadi beberapa sub paket. </p><br><p>  Pernahkah Anda melihatnya?  Karena aturan kompleksitas yang terdefinisi dengan baik, modifikasi single-line kami ternyata menjadi sesi refactoring besar dengan beberapa modul dan kelas baru.  Dan kami sendiri belum membuat keputusan: semua tujuan refactoring kami didorong oleh kompleksitas internal dan orang-orang yang mengungkapkannya. </p><br><p>  Itulah yang saya sebut proses "Continuous Refactoring".  Anda terpaksa melakukan refactoring.  Selalu. </p><br><p>  Proses ini juga memiliki satu konsekuensi menarik.  Ini memungkinkan Anda untuk memiliki "Architecture on Demand".  Biarkan saya jelaskan.  Dengan filosofi "Arsitektur Sesuai Permintaan" Anda selalu memulai dari yang kecil.  Misalnya dengan satu file <code>logic/domains/user.py</code>  Dan Anda mulai meletakkan semua yang terkait <code>User</code> sana.  Karena pada saat ini Anda mungkin tidak tahu seperti apa arsitektur Anda nantinya.  Dan kamu tidak peduli.  Anda hanya memiliki tiga fungsi. </p><br><p>  Beberapa orang jatuh ke dalam perangkap kompleksitas arsitektur vs kode.  Mereka dapat terlalu menyulitkan arsitektur mereka dari awal dengan lapisan repositori / layanan / domain penuh.  Atau mereka dapat terlalu memperumit kode sumber tanpa pemisahan yang jelas.  Berjuang dan hidup seperti ini selama bertahun-tahun (jika mereka akan bisa hidup selama bertahun-tahun dengan kode seperti ini!). </p><br><p>  Konsep "Architecture on Demand" memecahkan masalah ini.  Anda memulai dari yang kecil, ketika saatnya tiba - Anda membelah dan memperbaiki hal-hal: </p><br><ol><li>  Anda mulai dengan <code>logic/domains/user.py</code> dan meletakkan semuanya di sana </li><li>  Kemudian Anda membuat <code>logic/domains/user/repository.py</code> ketika Anda memiliki hal-hal terkait database yang cukup </li><li>  Kemudian Anda membaginya menjadi <code>logic/domains/user/repository/queries.py</code> dan <code>logic/domains/user/repository/commands.py</code> ketika kerumitan memberitahu Anda untuk melakukannya </li><li>  Kemudian Anda membuat <code>logic/domains/user/services.py</code> dengan hal-hal terkait <code>http</code> </li><li>  Kemudian Anda membuat modul baru yang disebut <code>logic/domains/order.py</code> </li><li>  Dan seterusnya dan seterusnya </li></ol><br><p>  Itu dia.  Ini adalah alat yang sempurna untuk menyeimbangkan arsitektur dan kompleksitas kode Anda.  Dan dapatkan sebanyak mungkin arsitektur yang Anda butuhkan saat ini. </p><br><h2 id="conclusion">  Kesimpulan </h2><br><p>  Linter yang baik tidak hanya menemukan koma yang hilang dan kutipan yang buruk.  Linter yang baik memungkinkan Anda untuk bergantung pada itu dengan keputusan arsitektur dan membantu Anda dengan proses refactoring. </p><br><p>  Misalnya, <code>wemake-python-styleguide</code> mungkin membantu Anda dengan kompleksitas kode sumber <code>python</code> , ini memungkinkan Anda untuk: </p><br><ul><li>  Berhasil melawan kompleksitas di semua level </li><li>  Menegakkan sejumlah besar standar penamaan, praktik terbaik, dan pemeriksaan konsistensi </li><li>  Mudah mengintegrasikannya ke basis kode lama dengan bantuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opsi <code>diff</code></a> atau alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>flakehell</code></a> , sehingga pelanggaran lama akan dimaafkan, tetapi yang baru tidak akan diizinkan </li><li>  Aktifkan ke [CI] () Anda, bahkan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tindakan Github</a> </li></ul><br><p>  Jangan biarkan kompleksitas meluap kode Anda, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gunakan linter yang bagus</a> ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472876/">https://habr.com/ru/post/id472876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472866/index.html">Jimat untuk komunikasi yang stabil</a></li>
<li><a href="../id472868/index.html">Manajemen server telepon: Klien seluler RUVDS</a></li>
<li><a href="../id472870/index.html">Mengapa Agile terhenti tanpa mengubah arsitektur dan alat pengembangan - presentasi konferensi</a></li>
<li><a href="../id472872/index.html">Bagaimana meningkatkan startup hingga 50 karyawan tanpa kehilangan budaya</a></li>
<li><a href="../id472874/index.html">Cerita kapal luar angkasa: melalui menara air ke bintang-bintang</a></li>
<li><a href="../id472884/index.html">Bagaimana stereotip pengembang pemula runtuh di awal game</a></li>
<li><a href="../id472886/index.html">Bagaimana menerapkan penganalisa statis dalam pengembangan sehingga semua orang senang?</a></li>
<li><a href="../id472890/index.html">DeepPavlov untuk pengembang: Alat # 1 NLP dan membuat chatbots</a></li>
<li><a href="../id472892/index.html">Mengapa antivirus tradisional tidak cocok untuk cloud publik. Dan apa yang harus dilakukan?</a></li>
<li><a href="../id472894/index.html">DartUP 2019: konferensi tentang Dart dan Flutter di St. Petersburg pada 23 November</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>