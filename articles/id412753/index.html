<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑 🧠 👩🏿‍🏫 Luncurkan tampilan pada STM32 via LTDC ... pada register 😔 🎴 👩🏾‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salam! Baru-baru ini, sebuah proyek diperlukan untuk meluncurkan tampilan yang memiliki antarmuka LVDS. Untuk mengimplementasikan tugas, controller ST...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Luncurkan tampilan pada STM32 via LTDC ... pada register</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412753/"> Salam!  Baru-baru ini, sebuah proyek diperlukan untuk meluncurkan tampilan yang memiliki antarmuka LVDS.  Untuk mengimplementasikan tugas, controller STM32F746 dipilih, karena  Saya sudah banyak bekerja dengannya dan dia memiliki modul LTDC yang memungkinkan Anda untuk bekerja secara langsung dengan layar tanpa pengontrol.  Dalam hal ini, pengontrol sudah diterapkan di dalam mikrokontroler.  Juga, argumen terakhir adalah bahwa ada debugging STM32F746-Disco pada batu ini, yang saya miliki, yang berarti bahwa saya dapat mulai bekerja pada proyek tanpa menunggu papan, komponen, dll untuk datang kepada saya. <br><br>  Hari ini saya akan memberi tahu Anda cara menjalankan modul LTDC, bekerja dengan register (CMSIS).  HAL dan perpustakaan lain tidak suka dan tidak menggunakan untuk alasan agama, tetapi ini juga menarik.  Anda akan melihat bahwa menaikkan peripheral kompleks pada register sesederhana SPI biasa.  Menarik?  Ayo pergi! <br><br><img src="https://habrastorage.org/webt/1q/dg/rd/1qdgrdp09rbyqcdhtzsvz8aqkbc.jpeg"><br><a name="habracut"></a><br><h2>  1. Sedikit tentang LTDC </h2><br>  Modul periferal ini pada dasarnya adalah pengontrol, yang biasanya berdiri di sisi tampilan, misalnya, SSD1963 dan sejenisnya.  Jika kita melihat struktur LTDC, kita akan melihat bahwa secara fisik ini adalah bus paralel dengan 24 bit + akselerator perangkat keras grafis + sebuah array data dalam RAM, yang sebenarnya merupakan buffer layar (frame buffer). <br><br><img src="https://habrastorage.org/webt/wm/g-/7k/wmg-7k_nhwtycbwgiefmyyagmxo.png"><br><br>  Pada output, kami memiliki bus paralel biasa, yang berisi 24 bit warna (8 bit per warna model RGB), garis sinkronisasi, garis on / off display dan jam piksel.  Yang terakhir, pada kenyataannya, adalah sinyal jam di mana piksel dimuat ke layar, yaitu, jika kita memiliki frekuensi 9,5 MHz, maka dalam 1 detik kita dapat memuat 9,5 juta piksel.  Ini dalam teori, tentu saja, dalam praktiknya, jumlahnya agak lebih sederhana karena pengaturan waktu dan hal-hal lain. <br><br>  <u>Untuk pengantar yang lebih rinci tentang LTDC, saya menyarankan Anda untuk membaca beberapa dokumen:</u> <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ikhtisar kemampuan LTDC di F4, dalam F7 kami semuanya sama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Catatan Aplikasi 4861. "LCD-TFT display controller (LTDC) pada STM32 MCUs"</a> </li></ol><br><h2>  2. Apa yang perlu kita lakukan? </h2><br>  ST mikrokontroler telah mendapatkan popularitas karena alasan yang baik, persyaratan paling penting untuk setiap komponen elektronik adalah dokumentasi, dan semuanya baik-baik saja dengan itu.  Situs ini tentu saja mengerikan, tetapi saya akan meninggalkan tautan ke semua dokumentasi.  Pabrikan menyelamatkan kita dari siksaan dan penemuan sepeda, oleh karena itu, pada halaman 520 dalam <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual rujukan RM0385,</a></i> langkah-langkah hitam dan putih diberikan, apa yang perlu kita lakukan: <br><br><img src="https://habrastorage.org/webt/bz/nx/ul/bznxulxfphrlrfmc_47lhv9wvgy.png"><br><br>  Faktanya, Anda tidak perlu melakukan setengah dari yang dijelaskan: itu tidak diperlukan untuk memulai, atau sudah dikonfigurasi secara default.  Untuk permulaan minimum, yang memungkinkan kita menggambar piksel, menampilkan gambar, grafik, teks, dll., Cukup melakukan hal berikut: <br><br><ul><li>  Aktifkan Pencatatan LTDC </li><li>  Atur sistem jam dan frekuensi output data (pixel clock) </li><li>  Konfigurasikan I / O Ports (GPIO) agar berfungsi dengan LTDC </li><li>  Siapkan pengaturan waktu untuk model tampilan kami </li><li>  <s>Sesuaikan polaritas sinyal.</s>  <s>Sudah dilakukan secara default</s> </li><li>  <s>Tentukan warna latar belakang tampilan.</s>  <s>Kami belum akan melihatnya, Anda dapat membiarkannya “nol”</s> </li><li>  Atur ukuran aktual dari area tampilan yang terlihat untuk lapisan tertentu </li><li>  Pilih format warna: ARGB8888, RGB 888, RGB565, dll. </li><li>  Tentukan alamat array yang akan bertindak sebagai frame buffer </li><li>  Tunjukkan jumlah data dalam satu baris (panjang lebar) </li><li>  Tunjukkan jumlah garis (tinggi tampilan) </li><li>  Sertakan layer yang sedang kami kerjakan </li><li>  Aktifkan modul LTDC </li></ul><br>  Menakutkan  Dan saya takut, tetapi ternyata berhasil selama 20 menit dengan semua proses.  Ada tugas, rencana itu direncanakan dan tinggal memenuhi saja. <br><br><h2>  3. Menyiapkan sistem jam </h2><br>  Item pertama yang perlu kita kirim sinyal clock ke modul LTDC, ini dilakukan dengan menulis ke register RCC: <br><br><pre><code class="cpp hljs">RCC-&gt;APB2ENR |= RCC_APB2ENR_LTDCEN;</code> </pre> <br>  Selanjutnya, Anda perlu mengonfigurasi frekuensi jam dari kuarsa eksternal (HSE) ke frekuensi 216 MHz, yaitu maksimum.  Langkah pertama adalah menyalakan sumber jam dari resonator kuarsa dan menunggu bendera siap: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_HSEON; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!(RCC-&gt;CR &amp; RCC_CR_HSERDY));</code> </pre><br>  Sekarang atur penundaan untuk memori flash pengontrol, sebagai  dia tidak tahu bagaimana bekerja pada frekuensi inti.  Nilainya, seperti data lainnya, diambil dari manual referensi: <br><br><pre> <code class="cpp hljs">FLASH-&gt;ACR |= FLASH_ACR_LATENCY_5WS;</code> </pre><br>  Sekarang, untuk mendapatkan frekuensi yang diinginkan, saya akan membagi 25 MHz dari input menjadi 25 dan mendapatkan 1 MHz.  Selanjutnya, hanya di PLL saya kalikan dengan 432, karena  di masa depan ada pembagi frekuensi dengan nilai minimum / 2 dan Anda harus menerapkan frekuensi dua kali ke sana.  Setelah itu, kami menghubungkan input PLL ke resonator kuarsa kami (HSE): <br><br><pre> <code class="cpp hljs">RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLM_0 | RCC_PLLCFGR_PLLM_3 | RCC_PLLCFGR_PLLM_4; RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLN_4 | RCC_PLLCFGR_PLLN_5 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLN_8; RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLSRC;</code> </pre><br>  Sekarang aktifkan PLL dan tunggu tanda siap: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_PLLON; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == <span class="hljs-number"><span class="hljs-number">0</span></span>){}</code> </pre><br>  Kami menetapkan output PLL kami sebagai sumber frekuensi sistem dan menunggu tanda siap: <br><br><pre> <code class="cpp hljs">RCC-&gt;CFGR |= RCC_CFGR_SW_PLL; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((RCC-&gt;CFGR &amp; RCC_CFGR_SWS) != RCC_CFGR_SWS_1) {}</code> </pre><br>  Ini mengakhiri pengaturan jam umum dan kami beralih ke pengaturan frekuensi jam (PLLSAI) untuk tampilan kami (jam piksel).  Sinyal untuk PLLSAI menurut datasheet diambil setelah pembagi / 25, yaitu, pada input kita memiliki 1 MHz.  Kita perlu mendapatkan frekuensi sekitar 9,5 MHz, untuk ini kita kalikan frekuensi 1 MHz dengan 192, dan kemudian menggunakan dua pembagi dengan 5 dan 4 kita mendapatkan nilai yang diinginkan PLLSAI = 1 MHz * 192/5/4 = 9,6 MHz: <br><br><pre> <code class="cpp hljs">RCC-&gt;PLLSAICFGR |= RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7; RCC-&gt;PLLSAICFGR |= RCC_PLLSAICFGR_PLLSAIR_0 | RCC_PLLSAICFGR_PLLSAIR_2; RCC-&gt;DCKCFGR1 |= RCC_DCKCFGR1_PLLSAIDIVR_0; RCC-&gt;DCKCFGR1 &amp;= ~RCC_DCKCFGR1_PLLSAIDIVR_1;</code> </pre><br>  Sebagai langkah terakhir, kami mengaktifkan PLLSAI untuk tampilan dan menunggu bendera siap-bekerja: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_PLLSAION; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((RCC-&gt;CR &amp; RCC_CR_PLLSAIRDY) == <span class="hljs-number"><span class="hljs-number">0</span></span>) {}</code> </pre><br>  Ini melengkapi pengaturan dasar sistem jam, agar tidak lupa dan kemudian tidak menderita, mari aktifkan clocking pada semua port input / output (GPIO).  Kami tidak memiliki daya baterai, setidaknya untuk debugging, jadi kami tidak menghemat: <br><br><pre> <code class="cpp hljs">RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOAEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOBEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOCEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIODEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOEEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOFEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOGEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOHEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOJEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOKEN;</code> </pre><br><h2>  4. Mengkonfigurasi I / O Ports (GPIO) </h2><br>  Menyiapkan gpio sangat sederhana - kami memiliki semua kaki dari LTDC bus untuk dikonfigurasikan sebagai output alternatif dan pada frekuensi tinggi.  Untuk melakukan ini, dalam manual referensi pada halaman 201 kami memiliki tip ini: <br><br><img src="https://habrastorage.org/webt/m5/bw/e9/m5bwe9v-fev5yahji9hqc9iofno.png"><br><br>  Tabel menunjukkan bit mana dalam register yang perlu Anda atur untuk mendapatkan pengaturan yang diperlukan.  Perlu dicatat bahwa semua kawat gigi dinonaktifkan.  Di mana mencari fungsi alternatif apa yang akan dimasukkan?  Dan untuk ini, buka halaman 76 di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lembar data</a> pada controller kami dan lihat tabel berikut: <br><br><img src="https://habrastorage.org/webt/d1/6a/6-/d16a6-uye3sjdb7rrf_m-qnz2os.png"><br><br>  Seperti yang dapat Anda lihat, logika tabelnya adalah yang paling sederhana: kami menemukan fungsi yang kami butuhkan, dalam kasus kami LTDC B0, kemudian kami melihat GPIOnya (PE4, misalnya) dan di bagian atas kami melihat jumlah fungsi alternatif yang akan kami gunakan untuk mengonfigurasi (AF14 bersama kami).  Untuk mengkonfigurasi output kami sebagai output push-pull dengan fungsi alternatif, LTDC B0, kita perlu menulis kode berikut: <br><br><pre> <code class="cpp hljs">GPIOE-&gt;MODER &amp;= ~GPIO_MODER_MODER4; GPIOE-&gt;MODER |= GPIO_MODER_MODER4_1; GPIOE-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR4_1; GPIOE-&gt;AFR[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;= ~GPIO_AFRL_AFRL4_0; GPIOE-&gt;AFR[<span class="hljs-number"><span class="hljs-number">0</span></span>] |= GPIO_AFRL_AFRL4_1 | GPIO_AFRL_AFRL4_2 | GPIO_AFRL_AFRL4_3;</code> </pre><br>  Saya memberi contoh untuk pin PE4, yang sesuai dengan pin B0 pada bus LTDC, yaitu, itu adalah sedikit warna biru nol.  Untuk semua kesimpulan lainnya, pengaturannya identik, hanya 2 kesimpulan yang pantas mendapatkan perhatian khusus, salah satu yang siap termasuk tampilan, dan yang lainnya lampu latar.  Mereka dikonfigurasikan sebagai output push-pull normal, yang digunakan semua orang untuk mengedipkan LED.  Setup terlihat seperti ini: <br><br><pre> <code class="cpp hljs">GPIOK-&gt;MODER &amp;= ~GPIO_MODER_MODER3; GPIOK-&gt;MODER |= GPIO_MODER_MODER3_0;</code> </pre><br>  Pengaturan ini untuk output PK3, yang menghidupkan dan mematikan lampu latar kami.  Omong-omong, Anda juga dapat PUSH untuk menyesuaikan kecerahan dengan lancar.  Untuk PI12, yang termasuk display (DISP), semuanya sama.  Kecepatan pada 2 pin ini rendah secara default, karena  beberapa tindakan frekuensi tinggi tidak diperlukan dari mereka. <br><br>  Anda dapat melihat semua port I / O lainnya pada papan sirkuit papan debug, atau pada diagram sirkuit perangkat Anda sendiri. <br><br><h2>  5. Pengaturan waktu dan pengaturannya </h2><br>  Pengaturan waktu dari sudut pandang fisik adalah penundaan biasa.  Saya pikir Anda telah berulang kali mengamati berbagai penyimpangan tipe delay (1) ketika Anda melihat contoh kode pada layar dengan pengontrol SPI / I2C mirip dengan ILI9341.  Di sana, penundaan diperlukan agar pengontrol, misalnya, memiliki waktu untuk menerima perintah, menjalankannya, dan kemudian melakukan sesuatu dengan data.  Dalam kasus LTDC, semuanya hampir sama, hanya saja kami tidak akan membuat kruk dan mengapa tidak - mikrokontroler kami sendiri dapat mengkonfigurasi pengaturan waktu yang diperlukan dalam perangkat keras.  Mengapa mereka diperlukan pada layar di mana tidak ada pengontrol?  Ya, sangat penting bahwa setelah mengisi garis piksel pertama, buka baris berikutnya dan kembali ke awal.  Hal ini disebabkan oleh teknologi produksi layar, dan oleh karena itu setiap model tampilan tertentu memiliki timing sendiri. <br><br>  Untuk mengetahui nilai apa yang kami butuhkan, kunjungi situs web ST dan lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diagram STM32F746-Disco debug board</a> .  Di sana kita dapat melihat bahwa tampilannya adalah <i>RK043FN48H-CT672B</i> dan dokumentasi untuk itu tersedia, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Kami paling tertarik dengan tabel di halaman 13 di bagian 7.3.1: <br><br><img src="https://habrastorage.org/webt/t7/fk/ou/t7fkoukmcua7rsnn6bmema1dhio.png"><br><br>  Ini adalah nilai-nilai kami yang akan kami butuhkan saat menyiapkan.  Juga dalam dokumentasi ada banyak lagi yang menarik, misalnya, diagram sinyal pada bus dan sebagainya, yang mungkin Anda perlukan jika, misalnya, Anda ingin menaikkan tampilan ke FPGA atau CPLD. <br><br>  Buka pengaturan.  Pertama-tama, agar tidak menyimpan nilai-nilai ini di kepala saya, saya akan mengaturnya dalam bentuk definisi: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HSYNC ((uint16_t)30) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HBP ((uint16_t)13) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HFP ((uint16_t)32) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VSYNC ((uint16_t)10) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VBP ((uint16_t)2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VFP ((uint16_t)2)</span></span></code> </pre><br>  Ada fitur yang menarik.  Timing <i>Pulse Width</i> , yang disebut <i>DISPLAY_HSYNC</i> , memiliki nilai dalam tabel hanya untuk frekuensi clock pixel 5 MHz, tetapi untuk 9 dan 12 MHz tidak.  Waktu ini perlu dipilih untuk tampilan Anda, saya mendapat nilai 30 ini, ketika dalam contoh dari ST itu berbeda.  Pada permulaan pertama, jika Anda memiliki kesalahan dengan pengaturannya, gambar akan bergeser ke kiri atau ke kanan.  Jika ke kanan, kita mengurangi waktunya, jika ke kiri, kita menambahnya.  Bahkan, itu mempengaruhi asal zona terlihat, yang akan kita lihat nanti.  Perlu diingat, dan gambar berikut dari halaman 24 AN4861 kami akan membantu untuk memahami seluruh paragraf ini: <br><br><img src="https://habrastorage.org/webt/nu/cd/gc/nucdgcesjmx8gqq-bjwfnusk0vc.png"><br><br>  Sebuah abstraksi kecil nyaman di sini.  Kami memiliki 2 zona tampilan: terlihat dan umum.  Zona yang terlihat memiliki dimensi dengan resolusi yang dinyatakan 480 x 272 piksel, dan zona total adalah waktu + yang terlihat, yang mana ada 3 di setiap sisi.  Perlu juga dipahami (ini bukan lagi abstraksi) bahwa satu sistem centang adalah 1 piksel, sehingga total area adalah 480 piksel + HSYNC + HBP + HFP. <br><br>  Penting juga untuk menyadari bahwa semakin sedikit timing, semakin baik - tampilan akan diperbarui lebih cepat dan frame rate akan meningkat sedikit.  Karena itu, setelah dijalankan pertama kali, bereksperimenlah dengan timing dan kurangi sebanyak mungkin dengan tetap menjaga stabilitas. <br><br>  Untuk mengatur timing, saya membuat sendiri "lembar contekan" kecil untuk masa depan di dalam proyek, itu juga akan membantu Anda memahami apa yang spesifik angka dan di mana untuk menulisnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *************************** Timings for TFT display********************************** * * HSW = (DISPLAY_HSYNC - 1) * VSH = (DISPLAY_VSYNC - 1) * AHBP = (DISPLAY_HSYNC + DISPLAY_HBP - 1) * AVBP = (DISPLAY_VSYNC + DISPLAY_VBP - 1) * AAW = (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - 1) * AAH = (DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP - 1) * TOTALW = (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP + DISPLAY_VFP - 1) * TOTALH = (DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP + DISPLAY_HFP - 1) * */</span></span></code> </pre><br>  Dari mana "cheat sheet" ini berasal ... Pertama, Anda melihat "formula" serupa beberapa paragraf sebelumnya.  Kedua, buka halaman 56 dari AN4861 kami: <br><br><img src="https://habrastorage.org/webt/sz/zf/yc/szzfyccwyqfw_t9ki0dazyck3ys.png"><br><br>  Benar, saya harap Anda mengerti arti fisik dari timing sebelum munculnya lembar contekan ini dan saya yakin Anda sendiri yang bisa menyusunnya.  Tidak ada yang rumit di dalamnya, dan gambar dari RM dan AN membantu secara visual memahami efek pengaturan waktu pada proses pembentukan gambar. <br><br>  Sekarang saatnya menulis kode yang mengatur timing ini.  Dalam "lembar contekan" ditunjukkan bit-bit register tempat menulis, misalnya, TOTALH, dan setelah tanda sama dengan rumus yang memberikan output sejumlah tertentu.  Oke  Lalu kami menulis: <br><br><pre> <code class="cpp hljs">LTDC-&gt;SSCR |= ((DISPLAY_HSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_VSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>)); LTDC-&gt;BPCR |= ((DISPLAY_HSYNC+DISPLAY_HBP<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_VSYNC+DISPLAY_VBP<span class="hljs-number"><span class="hljs-number">-1</span></span>)); LTDC-&gt;AWCR |= ((DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - <span class="hljs-number"><span class="hljs-number">1</span></span>)); LTDC-&gt;TWCR |= ((DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP + DISPLAY_HFP <span class="hljs-number"><span class="hljs-number">-1</span></span>)&lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> |(DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP + DISPLAY_VFP - <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><br>  Dan itu semua dengan pengaturan waktu!  Di bagian ini, Anda hanya dapat mengonfigurasi warna latar belakang.  Saya memilikinya hitam secara default, jadi ini ditulis dalam nol.  Jika Anda ingin mengubah warna lapisan latar belakang (background), maka Anda dapat menuliskan nilai apa pun, misalnya, <i>0xFFFFFFFF</i> dan isi semuanya dengan warna putih: <br><br><pre> <code class="cpp hljs">LTDC-&gt;BCCR = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  Ada ilustrasi yang bagus dalam <i>manual referensi</i> , yang dengan jelas menunjukkan bahwa kita sebenarnya memiliki 3 lapisan: latar belakang, lapisan 1 dan lapisan 2. Lapisan latar belakang "dikebiri" dan hanya dapat diisi dengan satu warna tertentu, tetapi juga bisa sangat berguna dalam implementasi desain GUI masa depan.  Juga, ilustrasi ini dengan jelas menunjukkan prioritas lapisan, yang berarti bahwa kita akan melihat warna isian di latar hanya ketika lapisan yang tersisa kosong atau transparan. <br><br>  Sebagai contoh, saya akan menunjukkan salah satu halaman proyek di mana, selama implementasi templat, latar belakang diisi dengan satu warna dan pengontrol tidak menggambar ulang seluruh halaman, tetapi hanya sektor individual, yang diperbolehkan menerima sekitar 50-60 fps untuk banyak tugas lain: <br><br><img src="https://habrastorage.org/webt/7b/yn/il/7byniliyqlnqy0yyzpfk8um7_mg.jpeg"><br><br><h2>  6. Bagian terakhir dari pengaturan LTDC </h2><br>  Pengaturan LTDC dibagi menjadi 2 bagian: yang pertama adalah umum untuk seluruh modul LTDC dan terletak di <i>grup</i> register <i>LTDC</i> , dan yang kedua dikonfigurasi dalam salah satu dari dua lapisan dan berada dalam kelompok <i>LTDC_Layer1</i> dan <i>LTDC_Layer2</i> . <br><br>  Kami membuat pengaturan umum pada paragraf sebelumnya, ini termasuk mengatur timing, layer background.  Sekarang kita beralih ke pengaturan layer dan daftar kita membutuhkan ukuran nyata dari zona terlihat dari layer, yang dijelaskan dalam bentuk 4 koordinat (x0, y0, x1, y2), yang memungkinkan kita untuk mendapatkan dimensi persegi panjang.  Ukuran lapisan yang terlihat mungkin kurang dari resolusi tampilan, tidak ada yang mengganggu untuk membuat ukuran lapisan 100 per 100 piksel.  Untuk menyesuaikan ukuran zona yang terlihat, tulis kode berikut: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;WHPCR |= (((DISPLAY_WIDTH + DISPLAY_HBP + DISPLAY_HSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (DISPLAY_HBP + DISPLAY_HSYNC)); LTDC_Layer2-&gt;WVPCR |= (((DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) |(DISPLAY_VSYNC + DISPLAY_VBP));</code> </pre><br>  Seperti yang Anda lihat, semuanya sama seperti timing.  Titik awal (x0, y0) dari zona terlihat terdiri dari jumlah dua pengaturan waktu: HSYNC + HBP dan VSYNC + VBP.  Untuk menghitung koordinat titik akhir (x1, y1), lebar dan tinggi piksel ditambahkan ke data nilai. <br><br>  Sekarang Anda perlu mengkonfigurasi format data yang diterima.  Kualitas maksimum diperoleh saat menggunakan format ARGB8888, tetapi pada saat yang sama kami mendapatkan jumlah maksimum memori yang digunakan.  Satu piksel menempati 32 bit atau 4 byte, yang berarti seluruh layar membutuhkan 4 * 480 * 272 = 522.240 byte, artinya, setengah dari memori flash kami bukan pengontrol terlemah.  Jangan takut - menghubungkan SDRAM eksternal dan memori Flash melalui QSPI memecahkan masalah memori dan tidak ada batasan pada format ini, kami bersukacita dalam kualitas yang baik.  Jika Anda ingin menghemat ruang atau tampilan Anda tidak mendukung format 24-bit, maka model yang lebih cocok digunakan untuk ini, misalnya, RGB565.  Format yang sangat populer untuk tampilan dan kamera, dan yang paling penting saat menggunakannya, 1 piksel hanya membutuhkan 5 + 6 + 5 = 16 bit atau 2 byte.  Dengan demikian, jumlah memori yang ditempati oleh lapisan akan 2 kali lebih sedikit.  Secara default, controller sudah memiliki format ARGB8888 yang dikonfigurasi dan terlihat seperti ini: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;PFCR = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Jika Anda memerlukan format yang berbeda dari ARGB8888, lalu buka halaman 533 dan 534 dalam <i>manual referensi</i> dan pilih format yang diinginkan dari daftar di bawah ini: <br><br><img src="https://habrastorage.org/webt/be/fg/qa/befgqaa2-iokyso1coeqhaii9zu.png"><br><br>  Sekarang buat sebuah array dan berikan alamatnya ke LTDC, itu akan berubah menjadi frame buffer dan akan menjadi "refleksi" dari layer kita.  Misalnya, Anda perlu mengisi piksel ke-1 di baris ke-1 dengan warna putih, untuk ini Anda hanya perlu menuliskan nilai warna (0xFFFFFFFF) ke elemen pertama array ini.  Perlu mengisi piksel 1 di baris ke-2?  Kemudian kita juga menulis nilai warna pada elemen dengan angka (480 +1).  480 - buat jeda baris, lalu tambahkan angka pada baris yang kita butuhkan. <br><br>  Pengaturan ini terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_WIDTH ((uint16_t)480) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HEIGHT ((uint16_t)272) const uint32_t imageLayer2[DISPLAY_WIDTH * DISPLAY_HEIGHT]; LTDC_Layer2-&gt;CFBAR = (uint32_t)imageLayer2;</span></span></code> </pre><br>  Dalam cara yang baik, setelah mengkonfigurasi LTDC, Anda juga perlu mengkonfigurasi SDRAM untuk menghapus pengubah <i>konstanta</i> dan mendapatkan buffer bingkai dalam RAM, karena  RAM milik MK sendiri tidak cukup bahkan untuk satu layer dengan 4 byte.  Meskipun ini tidak ada salahnya untuk menguji konfigurasi periferal yang benar. <br><br>  Selanjutnya, Anda perlu menentukan nilai lapisan alfa, yaitu transparansi untuk lapisan <i>Layer2</i> kami, untuk ini kami menulis nilai dari 0 hingga 255, di mana 0 adalah lapisan yang sepenuhnya transparan, 255 sepenuhnya buram, yang 100% terlihat: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CACR = <span class="hljs-number"><span class="hljs-number">255</span></span>;</code> </pre> <br>  Menurut rencana kami, sekarang perlu untuk mencatat ukuran area tampilan kami yang terlihat dalam byte, untuk ini kami menulis nilai yang sesuai ke dalam register: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CFBLR |= (((PIXEL_SIZE * DISPLAY_WIDTH) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (PIXEL_SIZE * DISPLAY_WIDTH + <span class="hljs-number"><span class="hljs-number">3</span></span>)); LTDC_Layer2-&gt;CFBLNR |= DISPLAY_HEIGHT;</code> </pre><br>  Dua langkah terakhir tetap, yaitu penyertaan layer 2 dan modul perangkat LTDC itu sendiri.  Untuk melakukan ini, tuliskan bit yang sesuai: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CR |= LTDC_LxCR_LEN; LTDC-&gt;GCR |= LTDC_GCR_LTDCEN;</code> </pre><br>  Ini melengkapi konfigurasi modul kami dan Anda dapat bekerja dengan tampilan kami! <br><br><h2>  7. Sedikit tentang bekerja dengan LTDC </h2><br>  Semua bekerja dengan tampilan sekarang hanya untuk menulis data ke array <i>imageLayer2</i> , ia memiliki ukuran 480 oleh 272 elemen, yang sepenuhnya sesuai dengan resolusi kami dan mengisyaratkan kebenaran sederhana - <b>1 elemen array = 1 piksel pada layar</b> . <br><br>  Sebagai contoh, saya menulis gambar ke array yang saya konversi di <b>LCD Image Converter</b> , tetapi dalam kenyataannya tidak mungkin bahwa tugas Anda akan terbatas pada ini.  Ada dua cara: menggunakan GUI yang sudah jadi dan menulisnya sendiri.  Untuk tugas-tugas yang relatif sederhana seperti output teks, grafik, dan sejenisnya, saya menyarankan Anda untuk menulis GUI Anda sendiri, itu akan memakan waktu sedikit dan memberi Anda pemahaman penuh tentang operasinya.  Ketika tugas itu besar dan sulit, dan tidak ada waktu untuk mengembangkan GUI Anda sendiri, saya menyarankan Anda untuk memperhatikan solusi yang sudah jadi, misalnya, uGFX dan sejenisnya. <br><br>  Simbol teks, garis, dan elemen lain pada dasarnya adalah array piksel, jadi untuk mengimplementasikannya, Anda perlu mengimplementasikan logika sendiri, tetapi Anda harus mulai dengan fungsi paling dasar - "output piksel".  Itu harus mengambil 3 argumen: koordinat sepanjang X, koordinat sepanjang Y dan, sesuai, warna di mana piksel yang diberikan dicat.  Ini mungkin terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ColorDisplay { RED = <span class="hljs-number"><span class="hljs-number">0xFFFF0000</span></span>, GREEN = <span class="hljs-number"><span class="hljs-number">0xFF00FF00</span></span>, BLUE = <span class="hljs-number"><span class="hljs-number">0xFF0000FF</span></span>, BLACK = <span class="hljs-number"><span class="hljs-number">0xFF000000</span></span>, WHITE = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span> } Color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPixel</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> setX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> setY, Color Color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> numBuffer = ((setY - <span class="hljs-number"><span class="hljs-number">1</span></span>) * DISPLAY_WIDTH) + setX; imageLayer2[numBuffer] = Color; }</code> </pre><br>  Setelah kami mengambil koordinat menjadi fungsi, kami menghitung ulang mereka ke dalam jumlah array yang sesuai dengan koordinat yang diberikan dan kemudian menulis warna yang diterima ke elemen yang diterima.  Berdasarkan fungsi ini, Anda sudah dapat mengimplementasikan fungsi untuk menampilkan geometri, teks, dan "barang" GUI lainnya.  Saya pikir ide itu bisa dimengerti, tetapi bagaimana menghidupkannya adalah atas kebijaksanaan Anda. <br><br><h2>  Ringkasan </h2><br>  Seperti yang Anda lihat, implementasi peripheral on register (CMSIS) yang rumit bukan tugas yang sulit, Anda hanya perlu memahami cara kerjanya di dalam.  Tentu saja, sekarang modis untuk mengembangkan firmware tanpa memahami apa yang terjadi, tetapi ini adalah jalan buntu jika Anda berencana untuk menjadi seorang insinyur, dan bukan ... <br><br>  Jika Anda membandingkan kode yang dihasilkan dengan solusi dalam HAL atau SPL, Anda akan melihat bahwa kode yang ditulis dalam register lebih kompak.  Menambahkan beberapa komentar di mana Anda membutuhkannya dan membungkusnya dalam fungsi, kami mendapatkan keterbacaan setidaknya tidak lebih buruk daripada HAL / SPL, dan jika Anda ingat bahwa <i>manual referensi</i> mendokumentasikan register, maka bekerja dengan CMSIS lebih nyaman. <br><br>  1) Proyek dengan sumber-sumber di TrueSTUDIO dapat diunduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> <br><br>  2) Bagi mereka yang lebih nyaman melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> <br><br>  3) Utilitas pengunduhan untuk mengonversi gambar menjadi kode Pengonversi Gambar LCD <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412753/">https://habr.com/ru/post/id412753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412741/index.html">Bagaimana berhenti takut bahwa kecerdasan buatan akan meninggalkan Anda tanpa kerja</a></li>
<li><a href="../id412743/index.html">Profesi: Detektif Cyber</a></li>
<li><a href="../id412747/index.html">MIS. Penyimpanan data medis</a></li>
<li><a href="../id412749/index.html">Elektronik sebagai Seni: Arus Listrik</a></li>
<li><a href="../id412751/index.html">Kebotakan: Teori dan praktik pengobatan, bagian 1 "Dihydrotestosterone saya, musuh saya"</a></li>
<li><a href="../id412755/index.html">Telegram merilis Proxy Server MTProto resmi</a></li>
<li><a href="../id412757/index.html">Lampu LED di Jepang</a></li>
<li><a href="../id412759/index.html">Server proxy-MTProto baru dari Telegram</a></li>
<li><a href="../id412763/index.html">Menggunakan Papan Reload Firefly-RK3288 dengan RockChip RK3288 SoC Microchip Digital I2C Thermal Sensor - MCP9808</a></li>
<li><a href="../id412765/index.html">Pengantar sistem kartu ubin Unity baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>