<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÖ üë®‚ÄçüöÄ üôçüèº 100,500 m√©todos de almacenamiento en cach√© en Oracle Database ü§ü üõåüèª ‚ôøÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para saber qu√© son los cach√©s, qu√© es el Cach√© de resultados, c√≥mo se hace en Oracle y en otras bases de datos no es muy interesante y bastante repeti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>100,500 m√©todos de almacenamiento en cach√© en Oracle Database</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/414401/">  Para saber qu√© son los cach√©s, qu√© es el Cach√© de resultados, c√≥mo se hace en Oracle y en otras bases de datos no es muy interesante y bastante repetitivo.  Pero todo adquiere colores completamente diferentes cuando se trata de ejemplos espec√≠ficos.  <strong>Alexander Tokarev</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">shtock</a> ) construy√≥ su informe sobre Highload ++ 2017 basado en casos.  Y fue precisamente sobre la base de los casos que dijo cu√°ndo podr√≠a ser conveniente un cach√© hecho en casa, cu√°l es el dolor del cach√© de resultados del lado del servidor y c√≥mo reemplazarlo por uno del lado del cliente, y en general present√≥ una serie de consejos √∫tiles para configurar el cach√© de resultados en Oracle. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/hTCXaAKIArk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre el orador:</strong> Alexander Tokarev trabaja en DataArt y se ocupa de cuestiones relacionadas con las bases de datos, tanto en t√©rminos de construir sistemas desde cero como de optimizar los existentes. <br><br>  Comencemos con algunas preguntas ret√≥ricas.  ¬øHas trabajado con Oracle Result Cache?  ¬øCree que Oracle es una base de datos adecuada para todas las ocasiones?  Seg√∫n la experiencia de Alexander, la mayor√≠a de las personas responden negativamente a la √∫ltima pregunta: <strong>cien so√±adores tienen un so√±ador</strong> .  Pero gracias a su fe, el progreso se est√° moviendo. <br><br>  Por cierto, Oracle ya tiene 14 bases de datos, hasta ahora 14, lo que suceder√° en el futuro es desconocido. <br><br>  Como ya se mencion√≥, todos los problemas y soluciones se ilustrar√°n con casos espec√≠ficos.  Estos ser√°n dos casos de proyectos de DataArt y un ejemplo de un tercero. <br><a name="habracut"></a><br><h2>  Cach√©s de bases de datos <br></h2><br>  Para empezar, qu√© cach√©s est√°n en las bases de datos.  Todo est√° claro aqu√≠: <br><br><ul><li>  Buffer cache - data cache - cache para p√°ginas de datos / bloques de datos; </li><li>  Cach√© de declaraciones: cach√© de declaraciones y sus planes: cach√© de plan de consultas; </li><li>  Cach√© de resultados - cach√© de resultados de filas - filas de consultas; </li><li>  Cach√© del sistema operativo: cach√© del sistema operativo. </li></ul><br>  Adem√°s, la cach√© de resultados, en general, se usa solo en Oracle.  Una vez estuvo en MySQL, pero luego fue heroicamente cortado.  En PostgreSQL tampoco est√° all√≠, est√° presente de una forma u otra solo en el producto pgpool de terceros. <br><br><h2>  Caso 1. B√≥veda del minorista <br></h2><br><img src="https://habrastorage.org/webt/qo/cq/t5/qocqt5zzctiqj1hh5n-6hc9skkm.jpeg"><br><br>  Arriba est√° el diagrama del producto que acompa√±amos: el repositorio (Oracle 11, 20 Tb, 300 usuarios), y contiene alg√∫n tipo de informe triste, en el que hab√≠a 350 productos √∫nicos por 5000 l√≠neas de datos.  Conseguirlo tard√≥ unos 20 minutos, y los usuarios estaban tristes. <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La presentaci√≥n de</a> este informe, como todos los dem√°s, est√° disponible en el sitio de la conferencia Highload ++. </blockquote><br>  Este informe tiene SELECCIONAR, UNIRSE y una funci√≥n.  Una funci√≥n como funci√≥n, todo estar√≠a bien, solo que calcula un par√°metro misterioso llamado "valor de precio de transferencia", funciona durante 0.2 s, parece que no es nada, pero se llama tantas veces como haya filas en la tabla.  Esta funci√≥n tiene 400 filas de SQL + PL / SQL, ya que  el producto est√° en soporte, da miedo cambiarlo. <br><br>  Por la misma raz√≥n, no se pudo utilizar result_cache. <br><br><img src="https://habrastorage.org/webt/1o/u5/ct/1ou5ctbufxqrsme66mbz60bieuy.jpeg"><br><br>  Para resolver el problema, utilizamos el <strong>enfoque</strong> est√°ndar <strong>con el almacenamiento en cach√© hecho a mano</strong> : dejamos los primeros 3 bloques del circuito, tal como estaban, simplemente cambie el nombre de nuestra funci√≥n sku_detail () a sku_full () y declaremos una matriz asociativa, donde respectivamente: <br><br><ul><li>  las claves son nuestros SKU (art√≠culos b√°sicos), <br></li><li>  Los valores son el precio de conversi√≥n de transferencia calculado. <br></li></ul><br>  Hacemos que la funci√≥n de cach√© (sku) sea obvia: si no hay tal identificaci√≥n en nuestra matriz asociativa, nuestra funci√≥n se inicia, el resultado se almacena en cach√©, se guarda y se devuelve.  En consecuencia, si tal identificaci√≥n es, entonces todo esto no sucede.  De hecho, tenemos <strong>cach√© bajo demanda</strong> . <br><br>  Por lo tanto, hemos reducido el n√∫mero de llamadas a funciones a la cantidad que realmente se necesita.  <strong>El tiempo de procesamiento de informes disminuy√≥ a 4 minutos</strong> , todos los usuarios se sintieron bien. <br><br><h3>  <strong>Memoria de cach√© hecha a mano</strong> <br></h3><br>  Las desventajas y ventajas de este sistema son claras a partir de esta gran imagen inteligente, que abordaremos mucho: esta es la arquitectura de memoria. <br><br><img src="https://habrastorage.org/webt/ku/e4/2o/kue42onfhkjjpxxyk0klg0-at50.jpeg"><br><br>  Es importante comprender en qu√© √°rea de memoria se encuentran las colecciones.  Se colocan en un √°rea de memoria llamada PGA.  <strong>El √°rea global del programa se</strong> instancia en cada conexi√≥n a la base de datos.  Esto es lo que determina las ventajas y desventajas, ya que m√°s conexiones: m√°s memoria y <strong>memoria costosa, servidor</strong> , administradores son tiernos. <br><br><img src="https://habrastorage.org/webt/7c/gi/hd/7cgihdigefzcded25cmfondxkcc.jpeg"><br><br><ul><li>  <strong>Pros:</strong> todo funciona muy r√°pido, muy f√°cil de hacer, no se necesita configuraci√≥n, no hay problemas con la participaci√≥n entre procesos. <br></li><li>  <strong>Las desventajas</strong> son comprensibles: si la l√≥gica almacenada est√° prohibida en el proyecto, no se pueden usar, no existe un mecanismo para la invalidaci√≥n autom√°tica, y dado que la memoria en el cach√© se asigna dentro de una sesi√≥n de la base de datos, no una instancia, su <strong>consumo se exagera</strong> .  Adem√°s, en el caso del uso del grupo de conexiones, debe recordar vaciar los cach√©s si debe haber un almacenamiento en cach√© diferente para cada sesi√≥n. <br></li></ul><br>  Hay otras opciones para cach√©s hechos a mano basados ‚Äã‚Äãen vistas materializadas, tablas temporales, pero de ellos hay una gran carga en el sistema de entrada-salida, por lo que aqu√≠ no los consideramos.  Son m√°s aplicables a otras bases de datos en las que estos problemas generalmente se resuelven almacenando el procedimiento almacenado en alguna tabla intermedia y tomando los datos de esta antes de acceder a una solicitud pesada.  Y solo si no se encontr√≥ lo que se necesita, se llama a la solicitud inicial. <br><br><img src="https://habrastorage.org/webt/mh/8u/xg/mh8uxg2hjytjwrp0fbds1gvoc4k.jpeg"><br><br>  Lo anterior es una ilustraci√≥n de este enfoque del problema de almacenamiento en cach√© para obtener una lista de productos relacionados en MsSQL.  En general, el enfoque es relativamente similar, pero no funciona en la memoria de la base de datos tanto en t√©rminos de obtenci√≥n de datos como de llenado primario, debido a esto <strong>puede ser m√°s lento</strong> . <br><br>  En general, result_cache casero se utiliza activamente, pero result_cache en la base de datos es un enfoque diferente para la implementaci√≥n de esta tarea.  Lo y c√≥mo no funcion√≥ la victoria r√°pida lo consideraremos m√°s a fondo. <br><br><h2>  Caso 2. Tramitaci√≥n de documentaci√≥n financiera. <br></h2><br>  Entonces, nuestro segundo caso. <br><br><img src="https://habrastorage.org/webt/dd/zn/wy/ddznwymy92vgt32eox6fvwanepq.jpeg"><br><br>  Este es un sistema de procesamiento de documentaci√≥n financiera semiautomatizado, una empresa triste con una arquitectura cl√°sica, que incluye: <br><br><ul><li>  cliente ligero <br></li><li>  4.000 usuarios que viven en diferentes partes del mundo; <br></li><li>  equilibrador <br></li><li>  2 JBoss para calcular la l√≥gica de negocios; <br></li><li>  cl√∫ster en memoria; <br></li><li>  n√∫cleo de Oracle; <br></li><li>  Copia de seguridad de Oracle <br></li></ul><br>  Una de las muchas tareas de este sistema es el <strong>c√°lculo de recomendaciones</strong> . <br><br><img src="https://habrastorage.org/webt/dm/rt/cf/dmrtcfcgvy2q94g-jl52qnhatbo.jpeg"><br><br>  Hay documentos, para cada indicador que el sistema no reconoce autom√°ticamente, se ofrece un conjunto de indicadores de documentos de clientes anteriores, de una industria similar o de una rentabilidad similar, mientras que el indicador se compara con el valor reconocido para no ofrecer demasiado.  Lo que es importante, los <strong>documentos son multiling√ºes</strong> . <br><br>  El usuario selecciona el valor deseado y repite la operaci√≥n para cada l√≠nea vac√≠a. <br><br>  Simplificada, esta tarea consiste en lo siguiente: los documentos llegan en forma de pares clave-valor de diferentes sistemas de reconocimiento, y los par√°metros se reconocen en alg√∫n lugar, pero no en alg√∫n lugar.  Es necesario asegurarse de que al final los usuarios procesen los documentos y se reconozcan todos los valores.  La recomendaci√≥n est√° dirigida precisamente a simplificar esta tarea y tiene en cuenta: <br><br><ol><li>  Multiling√ºismo: unos 30 idiomas.  Cada idioma tiene sus propias caracter√≠sticas, sin√≥nimos y otras caracter√≠sticas. </li><li>  Los datos previos de este cliente, o, en ausencia de los mismos, los datos de un cliente de la misma industria o un cliente similar en ganancias. </li></ol><br>  De hecho, se trata de 12 reglas muy complejas. <br><br>  <strong>Suposiciones iniciales:</strong> <br><br><ul><li>  No m√°s de 100 usuarios a la vez; </li><li>  2-3 columnas para reconocimiento; </li><li>  100 lineas. </li></ul><br>  <strong>No hay mucha carga</strong> , todo es aburrido. <br><br>  Entonces, es hora de su lanzamiento.  Se produjo la congelaci√≥n de c√≥digo, Java tiene miedo de tocar y se tarda al menos 5 minutos en procesar un documento. <br><br>  Acuden al equipo de desarrollo de la base de datos pidiendo ayuda.  Por supuesto, porque <em>si algo se ralentiza en la JVM, entonces, por s√≠ solo, debe cambiar o reparar la base de datos</em> . <br><br><img src="https://habrastorage.org/webt/ae/q_/tm/aeq_tm3cua2tkk3ohgxl7rntova.jpeg"><br><br>  Estudiamos los documentos y nos dimos cuenta de que en pares clave-valor los valores a menudo se repiten, 5-10 veces.  En consecuencia, decidimos usar la base de datos para almacenar en cach√©, porque ya se ha probado. <br><br>  Decidimos usar la cach√© de resultados del lado del servidor de Oracle porque: <br><br><ol><li>  Se han agotado las oportunidades para optimizar SQL, porque utiliza el motor de b√∫squeda de texto completo de Oracle; <br></li><li>  el cach√© se usar√° para par√°metros duplicados; <br></li><li>  La mayor√≠a de los datos para las recomendaciones se recalculan una vez por hora, ya que utilizan un √≠ndice de texto completo; <br></li><li>  <strong>PL / SQL est√° prohibido</strong> . <br></li></ol><br><h3>  <strong>Cach√© de resultados de Oracle</strong> <br></h3><br>  Cach√© de resultados (almacenamiento en cach√© de resultados de Oracle) tiene las siguientes propiedades: <br><br><ul><li>  Esta es el √°rea de memoria en la que se examinan todos los resultados de la consulta; </li><li>  lee de forma coherente y se produce su invalidaci√≥n autom√°tica; </li><li>  Se requieren cambios m√≠nimos en la aplicaci√≥n.  Puede hacer que la aplicaci√≥n no necesite ser cambiada; </li><li>  bono: puede almacenar en cach√© la l√≥gica PL / SQL, pero est√° prohibido aqu√≠. </li></ul><br>  <strong>¬øC√≥mo habilitarlo?</strong> <br><br><h4>  M√©todo n√∫mero 1 <br></h4><br><img src="https://habrastorage.org/webt/qo/im/jv/qoimjvcbfclnfsp_pncn6uf-74g.jpeg"><br><br>  Es muy simple <strong>especificar la instrucci√≥n result_cache</strong> .  La diapositiva muestra que ha aparecido el identificador del resultado.  En consecuencia, la primera vez que se ejecuta la consulta, la base de datos har√° alg√∫n trabajo; durante la ejecuci√≥n posterior, en este caso no se necesita trabajo.  Todo esta bien. <br><br><h4>  M√©todo n√∫mero 2 <br></h4><br><img src="https://habrastorage.org/webt/5x/uy/d5/5xuyd5seajh5kshz1xmdvmd6fu0.jpeg"><br><br>  La segunda forma permite a los desarrolladores de aplicaciones no hacer nada: estas son las llamadas anotaciones.  Indicamos una marca de verificaci√≥n para la tabla en la que la solicitud debe colocarse en result_cache.  En consecuencia, no hay ninguna pista, no tocamos la aplicaci√≥n, y todo ya est√° en result_cache. <br><br><blockquote>  Por cierto, ¬øqu√© crees que si una consulta se refiere a dos tablas, una de las cuales est√° marcada como result_cache y la segunda no, es el resultado de dicha consulta en cach√©? <br><br>  La respuesta es no, en absoluto. <br></blockquote><br>  Para que se almacene en cach√©, todas las tablas que participan en la consulta deben tener una anotaci√≥n result_cache. <br><br><h3>  <strong>Seguimiento de dependencias</strong> <br></h3><br>  Hay vistas relevantes en las que puede ver qu√© dependencias son. <br><br><img src="https://habrastorage.org/webt/ni/12/bp/ni12bpiy04zhswxncy1rsq1h29s.jpeg"><br><br>  En el ejemplo anterior, la consulta JOIN es una tabla en la que hay una dependencia.  Por qu√©  Debido a que Oracle determina la dependencia no solo analizando, sino que la implementa de <strong>acuerdo con los resultados del plan de trabajo</strong> . <br><br>  En este caso, se eligi√≥ dicho plan porque solo se usa una tabla y, de hecho, la tabla de trabajos est√° vinculada a la tabla de empleados a trav√©s de restricciones de clave externa.  Si eliminamos la restricci√≥n de clave externa que permite esta transformaci√≥n de eliminaci√≥n de uni√≥n, entonces veremos dos dependencias, porque el plan cambiar√° de esta manera. <br><br>  <strong>Oracle no rastrea lo que no necesita ser rastreado</strong> . <br><br>  En PL / SQL, la dependencia se ejecuta en tiempo de ejecuci√≥n para que pueda usar SQL din√°mico y hacer otras cosas. <br><br><img src="https://habrastorage.org/webt/3j/nh/fk/3jnhfkrft2dgbs-4nyvnwg6nfkm.jpeg"><br><br>  Tenga en cuenta que puede almacenar en cach√© no solo la solicitud completa, sino <strong>que tambi√©n puede almacenar en cach√© la vista en l√≠nea con y desde</strong> .  Supongamos, por un lado, que necesitamos un cach√©, y el otro ser√≠a mejor leer de la base de datos para no forzarlo.  Tomamos una vista en l√≠nea, nuevamente la declaramos como result_cache y vemos que solo una parte est√° en cach√©, y por la segunda accedemos a la base de datos cada vez. <br><br><img src="https://habrastorage.org/webt/zq/ze/7z/zqze7zgbnbljnme7a9j8qfbewdo.jpeg"><br><br>  Y finalmente, las <strong>bases de datos tambi√©n tienen encapsulaci√≥n</strong> , aunque nadie cree en ella.  Tomamos una vista, ponemos result_cache en ella, y nuestros programadores ni siquiera se dan cuenta de que est√° en cach√©.  A continuaci√≥n vemos que, de hecho, solo una parte funciona. <br><br><img src="https://habrastorage.org/webt/-x/-a/mt/-x-amt3jzaygadispddtfx_fojy.jpeg"><br><br><h3>  Discapacidad <br></h3><br>  Entonces, veamos cuando Oracle invalida result_cache. El estado Publicado muestra el estado actual de validez de cach√©.  Cuando la solicitud de result_cache, como dije, no hay trabajos en la base de datos <br><br><img src="https://habrastorage.org/webt/uv/9b/at/uv9batcfvtszo6tudxpovnhzy8s.jpeg"><br><br>  Cuando realizamos la actualizaci√≥n, el estado sigue siendo Publicado, porque la actualizaci√≥n no se ha confirmado y otras sesiones deber√≠an ver el antiguo resultado_cach√©.  Esta es la consistencia de lectura notoria. <br><br>  Pero en la sesi√≥n actual veremos que la carga se ha ido, ya que es en esta sesi√≥n que se ignora el cach√©.  Esto es bastante razonable, hagamos commit: el resultado ser√° inv√°lido, todo funciona por s√≠ solo. <br><br><img src="https://habrastorage.org/webt/-r/sn/rt/-rsnrtdyj9bk6vthaott4qondaq.jpeg"><br><br>  Parecer√≠a, ¬°un sue√±o!  La dependencia se considera correcta, solo seg√∫n la solicitud.  Pero no, se revelaron varios matices.  <strong>Oracle produce discapacidades y en varios casos no obvios</strong> : <br><br><ol><li>  Con cualquier llamada SELECCIONAR PARA ACTUALIZAR, las dependencias desaparecen. </li><li>  Si la tabla tiene claves for√°neas no indexadas, y se produce una actualizaci√≥n en la tabla marcada como resultado_cach√©, que no afect√≥ nada en absoluto, pero algo ha cambiado en la tabla primaria, la cach√© tambi√©n se invalidar√°. </li><li>  Esto es lo m√°s interesante que arruina la vida tanto como sea posible: si hay alguna actualizaci√≥n fallida en la tabla marcada como result_cache, nada funcion√≥, pero luego en la misma transacci√≥n se aplicaron otros cambios que de alguna manera afectaron la primera tabla, de todos modos result_cache se restablecer√°. </li></ol><br>  Todav√≠a hay un antipattern sobre result_cache, cuando los desarrolladores, habiendo escuchado que hay algo tan genial, piensan: ‚Äú¬°Oh, hay almacenamiento!  Ahora tomaremos alguna solicitud que funcione en 2-3 particiones: en la fecha actual y en la anterior, m√°rquela como result_cache, ¬°y siempre se tomar√° de la memoria! " <br><br>  Pero cuando cambia a Patricia en retrospectiva, todo el cach√© vuela, porque de hecho la unidad de seguimiento de dependencias en result_cache siempre es una tabla, y no s√© si alguna vez habr√° particiones o no. <br><br>  Pensamos y decidimos que ir√≠amos a la producci√≥n de un sistema de recomendaci√≥n con tales cosas: <br><br><ul><li>  <strong>No almacenaremos en cach√© todas nuestras tablas, tomaremos solo las necesarias.</strong> <br></li><li>  <strong>Establezca result_cache para la consulta de larga duraci√≥n.</strong> <br></li></ul><br>  Verificamos todo, realizamos pruebas de rendimiento, <strong>tiempo de procesamiento: 30 s</strong> .  ¬°Todo est√° genial, ve a producci√≥n! <br><br>  Arruinado - se fue a dormir.  Llegamos por la ma√±ana  Vemos una carta: "El reconocimiento lleva al menos 20 minutos, las sesiones se congelan".  ¬øPor qu√© se est√°n congelando?  ¬øC√≥mo se <strong>convirtieron 30 segundos en 20 minutos</strong> ? <br><br>  Comenzaron a entender, mira la base de datos: <br><br><ul><li>  sesiones activas - 400; </li><li>  en promedio l√≠neas en un documento para reconocimiento - 500; </li><li>  columnas m√≠nimas: 5-8; </li><li>  ¬°el n√∫mero de sesiones en la base de datos siempre es igual al n√∫mero de aplicaciones de usuario multiplicado por 3!  Y result_cache no le gusta el acceso frecuente a √©l. </li></ul><br>  Despu√©s de realizar una investigaci√≥n interna, descubrimos que los desarrolladores de Java reconocen en 3 hilos. <br><br>  Est√°bamos molestos: una carga de 5 veces, ca√≠da, degradaci√≥n e incluso con tales par√°metros, tal hundimiento no deber√≠a haber sucedido. <br><br>  Obviamente, necesitas entender. <br><br><h3>  Monitoreo <br></h3><br><img src="https://habrastorage.org/webt/b6/iq/iw/b6iqiwwevjqyua9xr6p8j2aq0bu.jpeg"><br><br>  Para el monitoreo, tenemos dos cosas clave: <br><br><ol><li>  V $ RESULT_CACHE_OBJECTS: una lista de todos los objetos; </li><li>  V $ RESULT_CACHE_STATISTICS - estad√≠sticas agregadas de result_cache en su conjunto. </li></ol><br>  MEMORY_REPORT son variaciones sobre un tema, no las necesitaremos. <br><br>  ¬°Oracle es m√°gico!  Hay una gran documentaci√≥n, pero est√° dise√±ada para aquellos que cambian de otras bases de datos para que lean y piensen que Oracle es muy bueno.  Pero <strong>toda la informaci√≥n sobre result_cache se encuentra solo con soporte</strong> . <br><br><img src="https://habrastorage.org/webt/vm/u1/bt/vmu1bt35lwpsvebw9o-rnxxasgs.jpeg"><br><br>  ¬°Hay un matiz que consiste en el hecho de que tan pronto como recurrimos a estos objetos para resolver el problema, lo exacerbamos enterr√°ndonos finalmente!  Hasta Oracle12.2, antes del parche que se lanz√≥ en octubre del a√±o pasado, estas solicitudes hacen que result_cache sea inaccesible para el estado y la escritura hasta que se cuenten por completo. <br><br><img src="https://habrastorage.org/webt/8b/nd/4y/8bnd4ygeerwxy7n38lqjrqrfwnw.jpeg"><br><br>  Entonces, usando la vista v $ result_cache_objects, descubrimos que hay miles de entradas en la lista de objetos en cach√©, mucho m√°s de lo que esper√°bamos.  Adem√°s, estos fueron objetos de algunas de nuestras consultas en tablas extra√±as: tabletas peque√±as y consultas last_modified_date.  Obviamente, <strong>alguien estableci√≥ ETL en nuestra base</strong> . <br><br>  Antes de insultar a los desarrolladores de ETL, verificamos que la opci√≥n result_cache force estuviera habilitada para estas tablas, y recordamos que la activamos nosotros mismos, ya que algunos de estos datos a menudo eran requeridos por la aplicaci√≥n y el almacenamiento en cach√© era apropiado. <br><br><img src="https://habrastorage.org/webt/u1/wq/28/u1wq28jkvtylav6ndpx7qql6koo.jpeg"><br><br>  Pero result√≥ que <strong>todas estas solicitudes solo toman y lavan nuestro cach√©</strong> .  Afortunadamente, los desarrolladores tuvieron la oportunidad de influir en el ETL en la producci√≥n, por lo que pudimos cambiar result_cache para excluir estas minuciosas solicitudes. <br><br>  ¬øCrees que es m√°s f√°cil?  - No te sientas mejor!  El n√∫mero de objetos almacenados en cach√© disminuy√≥, y luego volvi√≥ a aumentar a 12,000. Continuamos estudiando qu√© m√°s se almacenaba en cach√©, ya que la velocidad no cambi√≥. <br><br><img src="https://habrastorage.org/webt/iy/1o/di/iy1odismaewdpasdhlh_uidjeay.jpeg"><br><br>  Miramos: un mont√≥n de solicitudes, y muy inteligentes, pero todas incomprensibles.  Aunque cualquiera que haya trabajado con Oracle 12 sabe que DS SVC son estad√≠sticas adaptativas.  Es necesario para mejorar el rendimiento, pero cuando hay result_cache, resulta que lo mata porque la competencia est√° sucediendo.  Esto, por supuesto, est√° escrito <strong>solo en soporte</strong> . <br><br>  Sab√≠amos c√≥mo se organiza la carga de trabajo y entendimos que en nuestro caso, las estad√≠sticas adaptativas no mejorar√≠an radicalmente nuestros planes.  Por lo tanto, lo apagamos heroicamente: el resultado, como est√° escrito en el manual secreto, es de 10 minutos por documento.  No est√° mal, pero no lo suficiente. <br><br><h3>  Cierres <br></h3><br>  <strong>La competencia entre result_cache y DS SVC</strong> se debe al hecho de que Oracle tiene pestillos, peque√±os bloqueos livianos. <br><br><img src="https://habrastorage.org/webt/d5/ts/nd/d5tsndbmieve1hguz6yv-qzq2jk.jpeg"><br><br>  Sin entrar en detalles sobre c√≥mo funcionan, intentamos poner un pestillo con nombre varias veces, no funcion√≥, Oracle se levanta y se duerme <br><br>  Cualquiera que est√© en el tema puede decir que en result_cache, se colocan dos pestillos en cada bloque con fetch.  Estos son los detalles.  Hay dos tipos de pestillos en result_cache: <br><br>  1. Bloquee el per√≠odo mientras escribimos datos en result_cache. <br><br><img src="https://habrastorage.org/webt/pv/db/qe/pvdbqeunmn4qjgcybpkxai3thne.jpeg"><br><br>  Es decir, si su solicitud ha estado funcionando durante 8 s, durante el per√≠odo de estos 8 s, otras mismas solicitudes (la palabra clave "same") no podr√°n hacer nada, porque esperan hasta que los datos se escriban en result_cache.  Se registrar√°n otras solicitudes, pero esperar√°n el bloqueo solo en la primera l√≠nea.  Se desconoce cu√°nto tendr√°n que esperar; este es el par√°metro no documentado result_cache_timeout.  Despu√©s de eso, comienzan a ignorar result_cache, por as√≠ decirlo, y trabajan lentamente.  Sin embargo, tan pronto como se libera el bloqueo de la √∫ltima l√≠nea en la puerta, comienzan a funcionar autom√°ticamente con result_cache nuevamente. <br><br>  2. El segundo tipo de bloqueos: para recibir desde result_cache tambi√©n desde la primera l√≠nea hasta la √∫ltima. <br>  Pero como la recuperaci√≥n proviene de la memoria instant√°nea, se eliminan muy r√°pidamente. <br><br><img src="https://habrastorage.org/webt/pl/es/ds/plesds8v7w0qd8vjfrecofbmwno.jpeg"><br><br>  Aseg√∫rese de tener en cuenta que cuando el DBA ve bloqueos en la base de datos, comienza a decir: ‚Äú¬°Cierres!  ¬°Espera, todo se fue!  ¬ªY aqu√≠ comienza el juego m√°s interesante: <strong>convencer a DBA de que el tiempo de espera de los pestillos es en realidad incomparablemente m√°s corto que el tiempo de reintento de consulta</strong> . <br><br><img src="https://habrastorage.org/webt/ii/du/sv/iidusv3bzptakrexkjrco7cubsw.jpeg"><br><br>  Como muestra nuestra experiencia, nuestras medidas, los <strong>pestillos en result_cache ocupan el 10% de las solicitudes mismas</strong> . <br><br><img src="https://habrastorage.org/webt/7-/o8/8a/7-o88agtahp-edtfts_lb2ss6s4.jpeg"><br><br>  Estas son estad√≠sticas agregadas.  El hecho de que todo est√° mal puede entenderse por el hecho de que el cach√© est√° obstruido.  Otra confirmaci√≥n es que se eliminan los resultados adecuados.  Es decir, el <strong>cach√© se sobrescribe</strong> .  Parece que somos inteligentes y siempre consideramos el tama√±o de la memoria: tomamos el tama√±o de la l√≠nea de nuestro resultado en cach√© para nuestra recomendaci√≥n, lo multiplicamos por el n√∫mero de l√≠neas y algo sali√≥ mal. <br><br><img src="https://habrastorage.org/webt/mg/lh/5e/mglh5eorzkulnfqoewvrreqpb_u.jpeg"><br><br>  support   2 ,  ,  <strong>  result_cache   </strong> .         . <br><br>   ,    .   , ,   ,  workload   5 .           ,     ,    . <br><br> <strong>   ?</strong> <br><br>  :     .   ,      . <br><br><img src="https://habrastorage.org/webt/2i/qm/_j/2iqm_jbqws8mw7udadiwhkrngao.jpeg"><br><br>    4 : <br><br><ul><li> RESULT_CACHE_MAX_SIZE; <br></li><li> RESULT_CACHE_MAX_RESULT; <br></li><li> RESULT_CACHE_MODE; <br></li><li> _RESULT_CACHE_MAX_TIMEOUT. <br></li></ul><br><img src="https://habrastorage.org/webt/bt/fr/wp/btfrwpqmjmcs6evdykbcvizgte4.jpeg"><br><br>     ‚Äî  .  ,    100   512,      6 . <br><br>    ,    - . , Invalidation Count = 10000. <br><br>   ,    .     ,   job  ,      . ,   .   job   ,    ,      . <br><br><img src="https://habrastorage.org/webt/2b/m0/dl/2bm0dl2vlmo6bbv16wyksdoora0.jpeg"><br><br>    , invalid     ,    . <strong>         40 </strong> . <br><br>  ,    .     ,     ,     Oracle.  ! <br><br><img src="https://habrastorage.org/webt/wj/dd/jw/wjddjwnlpkmemk8lglmb7rczgb0.jpeg"><br><br> <strong>SHELFLIVE</strong> ‚Äî ,    read-consistent  ,       10 ,   .        . ,     ,    . <br><br>      ‚Äî <strong>SNAPSHOT</strong> .  ,       ,     read-consistent    ‚Äî       . <br><br> <strong></strong> : <br><br><img src="https://habrastorage.org/webt/bj/ts/pd/bjtspdkmsfo2d2xicp_pmxgtqag.jpeg"><br><br><ol><li>  ‚Äî       SYS. </li><li>      . ,    ,  Oracle    ,     ,        .  , Oracle ,   ,   12.2     . ,  external  -    support,    . </li><li>    sql  pl/sql : current_date, current_time  .   ,     current_time,          . </li><li>    . </li><li>          ,    CLOB, BLOB  . </li></ol><br><h3> Result cache inside Oracle <br></h3><br> Result_cache ‚Äî   Oracle Core.        , ,    job  result_cache (,    hint,    )  ,    APEX. <br><br><img src="https://habrastorage.org/webt/6n/u3/wf/6nu3wfqtrqzz3n5r_kyfdfwfv8c.jpeg"><br><br> ,    Dynamic sampling    ,   ,      ,   result_cache. <br><br><img src="https://habrastorage.org/webt/qa/gr/al/qagralka35xxjh68wtrfpprgrii.jpeg"><br><br><h2> Oracle internals for result cache <br></h2><br>         result_cache: <br><br><ol><li>        (storage)   ; <br></li><li>         result_cache; <br></li><li> result_cache   shared pool. <br></li></ol><br><img src="https://habrastorage.org/webt/yx/29/pk/yx29pkuz-o_c4dbgk9dbjwbn0lm.jpeg"><br><br> <strong>:</strong> <br><br><ul><li>     . <br></li><li>           read-consistent. </li><li> Result_cache,   ,  . </li></ul><br> <strong>:</strong> <br><br><ul><li>    . <br></li><li>     ,    . <br></li></ul><br><h2>   ! <br></h2><br>      ,    .    support Oracle, ,  29  2017 .:   Oracle E-Business suite    result_cache,      . <br><br><img src="https://habrastorage.org/webt/zh/h3/eu/zhh3eud6fphqdaiuukx1yoklczu.jpeg"><br><br> ,       ,     .          support        ,    ,      . <br><br><img src="https://habrastorage.org/webt/qp/e8/5i/qpe85iwdofjvbxhgtrrihdjmxb4.jpeg"><br><br>             : <br><br><ol><li>  -    ; <br></li><li> , , , ,  v$result_cache_memory  dbms_result_cache.memory_report,       . <br></li></ol><br> ,     ,      ,   v_result_cache_objects  . <br><br><blockquote>   ,  support note ‚Äî   support ,   . <br></blockquote><br><img src="https://habrastorage.org/webt/me/ut/5o/meut5o7krxdlelwjxgavdxrq-fe.jpeg"><br><br>    ,       ,   :     - .    ,    ,      : <br><br><ol><li>  hint result_cache; </li><li>  hint no result_cache; </li><li>  black_list,  ,   ,   -. </li></ol><br> <strong>    ?</strong> <br><br><ul><li>   ,  - , ,      ; </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhabilite el cach√© durante el per√≠odo de arranque, es decir, se desconecta, vierte y enciende r√°pidamente. </font><font style="vertical-align: inherit;">Es mejor que el sistema se desacelere un poco, pero funciona, luego se cae.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como notamos, el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">principal problema con los cach√©s en el servidor es el costo de la costosa memoria del servidor</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Oracle tiene una tercera soluci√≥n final.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cach√© de resultados del lado del cliente </font></font><br></h3><br><img src="https://habrastorage.org/webt/mk/6s/5m/mk6s5m24srinff6gkhrmxxei7xu.jpeg"><br><br>  El diagrama de su dispositivo se muestra en lo anterior, estos son los componentes principales de la base de datos y el controlador. <br><br>  La primera vez que se accede al lado del cliente, el Cach√© de resultados va a la base de datos, que est√° preconfigurada, recibe el tama√±o del cach√© del cliente de la base de datos e instala este cach√© en el cliente una vez en la primera conexi√≥n.  La consulta en cach√© primero accede a la base de datos y escribe datos en la cach√©.  Los subprocesos restantes solicitan un cach√© de controlador compartido, ahorrando as√≠ memoria y recursos del servidor.  Por cierto, a veces dependiendo de la carga, el controlador env√≠a estad√≠sticas sobre el uso de la memoria cach√© a la base de datos, que luego se puede ver. <br><br>  <strong>Una pregunta interesante es, ¬øc√≥mo ocurre la discapacidad?</strong> <br><br>  Hay dos modos de invalidaci√≥n, que se agudizan con el par√°metro Retardo de invalidaci√≥n.  Esta es la cantidad de Oracle que permite que el cach√© del controlador no sea coherente. <br><br>  El primer modo se utiliza cuando las solicitudes van con frecuencia y no se produce el retraso de invalidaci√≥n.  En este caso, la transmisi√≥n ir√° a la base de datos, actualizar√° los cach√©s y leer√° los datos de ella. <br><br><img src="https://habrastorage.org/webt/ah/wo/u1/ahwou1tplbgyiq4w8lizx0raeto.jpeg"><br><br>  Si falla el retraso de invalidaci√≥n, cualquier solicitud no almacenada en cach√©, que se refiera a la base de datos, adem√°s de los resultados de la consulta, trae una lista de objetos no v√°lidos.  En consecuencia, est√°n marcados como no v√°lidos en la memoria cach√©, y todo funciona como en la imagen del primer escenario. <br><br>  En el segundo caso, si ha pasado m√°s tiempo que el retraso de invalidaci√≥n, entonces el resultado result_cache del cliente mismo va a la base de datos y dice: "¬°Dame una lista de cambios!"  Es decir, √©l mismo mantiene su estado adecuado. <br><br>  <strong>Configurar el cach√© de resultados del lado del cliente es muy simple</strong> .  Hay 2 opciones: <br><br><ol><li>  CLIENT_RESULT_CACHE_LAG - valor de retraso de cach√©; </li><li>  CLIENT_RESULT_CACHE_SIZE - tama√±o (m√≠nimo 32 Kb, m√°ximo - 2 GB). </li></ol><br><img src="https://habrastorage.org/webt/ky/zl/mh/kyzlmhtgmgjkodcgtwkjm6sqoym.jpeg"><br><br>  Desde el punto de vista del desarrollador de la aplicaci√≥n, la cach√© del cliente no es muy diferente de la cach√© del servidor, tambi√©n ingresaron la pista result_cache.  Si lo fuera, entonces simplemente comenzar√° a ser utilizado por el cliente, tanto en .Net como en Java. <br><br><img src="https://habrastorage.org/webt/xo/bv/of/xobvof-_m9gwfhdocpw5dywqshe.jpeg"><br><br>  Habiendo hecho 10 iteraciones de la consulta, obtuve lo siguiente. <br><br><img src="https://habrastorage.org/webt/vq/zs/di/vqzsdifg9jkvb18jnrgy_bu9je4.jpeg"><br><br>  El primer atractivo es la creaci√≥n, luego 9 accesos a cach√©.  La tabla indica que la memoria tambi√©n se asigna en bloques.  Tambi√©n preste atenci√≥n a SELECCIONAR: no es muy intuitivo.  Para ser honesto, antes de comenzar a lidiar con esto, ni siquiera sab√≠a que hab√≠a una representaci√≥n de <code>GV$SESSION_CONNECT_INFO</code> .  Por qu√© Oracle no lo llev√≥ directamente a esta tabla (y esta es una tabla, no una vista), no pod√≠a entenderlo.  Pero por eso creo que esta funcionalidad no es muy popular, aunque, como me parece, es muy √∫til. <br><br>  <strong>Ventajas del almacenamiento en cach√© del cliente:</strong> <br><br><ul><li>  memoria de cliente barata; </li><li>  cualquier controlador disponible: JDBC, .NET, etc. </li><li>  Impacto m√≠nimo en el c√≥digo de la aplicaci√≥n. </li><li>  Reducir la carga en la CPU, E / S y, en general, la base de datos; </li><li>  no es necesario aprender y usar todo tipo de capas de cach√© inteligente y API; </li><li>  Sin pestillos. </li></ul><br>  <strong>Desventajas</strong> <br><br><ul><li>  consistencia en la lectura con retraso - en principio, ahora esta es una tendencia; </li><li>  necesita cliente Oracle OCI; </li><li>  limitaci√≥n de 2 GB por cliente, pero en general 2 GB es mucho; </li><li>  Para m√≠ personalmente, la limitaci√≥n clave es una peque√±a informaci√≥n sobre la producci√≥n. </li></ul><br>  En el soporte, que siempre usamos cuando trabajamos con result_cache, encontr√© solo 5 errores.  Esto sugiere que, muy probablemente, pocas personas lo necesitan. <br><br>  Entonces, reunimos todo lo que se dijo anteriormente. <br><br><h3>  <strong>Cach√© hecho a mano</strong> <br></h3><br>  <strong>Malos escenarios:</strong> <br><br><ul><li>  Cambio instant√°neo: si despu√©s de cambiar los datos, el cach√© deber√≠a volverse irrelevante de inmediato.  Para las memorias cach√© hechas a s√≠ mismas, es dif√≠cil crear la invalidaci√≥n correcta en caso de cambios en los objetos sobre los que est√°n construidas. </li><li>  Si el uso de la l√≥gica almacenada en la base de datos est√° prohibido por las pol√≠ticas de desarrollo. </li></ul><br>  <strong>Buenos escenarios:</strong> <br><br><ul><li>  Hay un fuerte equipo de desarrollo de bases de datos. </li><li>  L√≥gica PL / SQL implementada. </li><li>  Existen limitaciones que impiden el uso de otras t√©cnicas de almacenamiento en cach√©. </li></ul><br><h3>  <strong>Cach√© de resultados del lado del servidor</strong> <br></h3><br>  <strong>Malos escenarios:</strong> <br><br><ul><li>  Muchos resultados diferentes que simplemente lavan todo el cach√©; </li><li>  Las solicitudes tardan m√°s de _RESULT_CACHE_TIMEOUT o este par√°metro est√° configurado incorrectamente. </li><li>  Los resultados de sesiones muy grandes se cargan en la memoria cach√© en subprocesos paralelos. </li></ul><br>  <strong>Buenos escenarios:</strong> <br><br><ul><li>  Cantidad razonable de resultados en cach√©. </li><li>  Conjuntos de datos relativamente peque√±os (200‚Äì300 filas). </li><li>  SQL bastante costoso, de lo contrario todo el tiempo ir√° a pestillos. </li><li>  M√°s o menos tablas est√°ticas. </li><li>  Hay un DBA, que en caso de que algo venga y salve a todos. </li></ul><br><h3>  <strong>Cach√© de resultados del lado del cliente</strong> <br></h3><br>  <strong>Malos escenarios:</strong> <br><br><ul><li>  Cuando surge el problema mismo de la discapacidad instant√°nea. </li><li>  Se requieren controladores delgados. <br></li></ul><br>  <strong>Buenos escenarios:</strong> <br><br><ul><li>  Hay un equipo normal de desarrollo de capa media. </li><li>  Ya se est√° utilizando una gran cantidad de SQL sin utilizar una capa de almacenamiento en cach√© externa que se pueda conectar f√°cilmente. </li><li>  Hay restricciones en las gl√°ndulas. </li></ul><br><br><h2>  Conclusiones <br></h2><br>  Creo que mi historia es sobre el dolor de cach√© de resultados del lado del servidor, por lo que las conclusiones son las siguientes: <br><br><ol><li>  Siempre eval√∫e el tama√±o de la memoria correctamente teniendo en cuenta la cantidad de consultas y no la cantidad de resultados, es decir: bloques, APEX, trabajo, estad√≠sticas adaptativas, etc. </li><li>  No tenga miedo de usar las opciones de descarga autom√°tica de cach√© (instant√°nea + vida √∫til). </li><li>  No sobrecargue el cach√© con solicitudes mientras carga grandes cantidades de datos; deshabilite result_cache antes de esto.  Calienta el cach√©. </li><li>  Aseg√∫rese de que _result_cache_timeout cumpla con sus expectativas. </li><li>  NUNCA use FORCE para toda la base de datos.  Necesita una base de datos en memoria: use una soluci√≥n especializada en memoria. </li><li>  Verifique si la opci√≥n FORCE se usa apropiadamente para tablas individuales para que no funcione como lo hacemos con un ETL de terceros. </li><li>  Decida si las estad√≠sticas adaptativas son tan buenas como las descritas por Oracle (_optimizer_ads_use_result_cache = false). </li></ol><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Highload ++ Siberia el</a> pr√≥ximo lunes, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">calendario est√°</a> listo y publicado en el sitio.  Hay varios informes en el tema de este art√≠culo: <br><br><ul><li>  <strong>Alexander Makarov</strong> (CFT GC) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">demostrar√° un</a> m√©todo para identificar cuellos de botella en el lado del servidor del software utilizando la base de datos Oracle como ejemplo. <br></li><li>  <strong>Ivan Sharov</strong> y <strong>Konstantin Poluektov</strong> le dir√°n qu√© problemas surgen al migrar el producto a nuevas versiones de la base de datos Oracle, y tambi√©n prometen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dar recomendaciones</a> sobre la organizaci√≥n y realizaci√≥n de dicho trabajo. <br></li><li>  <strong>Nikolay Golov</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">le dir√°</a> c√≥mo garantizar la integridad de los datos en una arquitectura de microservicio sin transacciones distribuidas y conectividad estrecha. <br></li></ul><br>  <strong>Nos vemos en Novosibirsk!</strong> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414401/">https://habr.com/ru/post/es414401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414389/index.html">An√°lisis de registros de dispositivos Cisco mediante Splunk Cisco Security Suite</a></li>
<li><a href="../es414393/index.html">Robot operado por voz en 1961</a></li>
<li><a href="../es414395/index.html">M√°s f√°cil de lo que parece. Fractura</a></li>
<li><a href="../es414397/index.html">FCS propone reducir el umbral libre de impuestos a cero</a></li>
<li><a href="../es414399/index.html">El uso de la producci√≥n digital en negocios y educaci√≥n reales.</a></li>
<li><a href="../es414403/index.html">Fujitsu ha creado una nueva tecnolog√≠a de modelado molecular</a></li>
<li><a href="../es414405/index.html">Instalar certificado en el servidor HTTP Apache</a></li>
<li><a href="../es414411/index.html">Wiren Board 6: nuevamente en Habr√© con la nueva versi√≥n del controlador para automatizaci√≥n</a></li>
<li><a href="../es414413/index.html">Sinopsis y video de la historia sobre las redes en la industria del juego con el gamedev del festival</a></li>
<li><a href="../es414415/index.html">Conferencia de Tarantool 21 de junio - no solo sobre Tarantool, sino en general sobre la computaci√≥n en memoria</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>