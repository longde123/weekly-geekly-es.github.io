<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏾 ✒️ 🙍🏼 toString: genial y terrible ♣️ 🤟🏿 🤙🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La función toString en JavaScript es probablemente la más "implícita" discutida tanto entre los desarrolladores de js como entre los observadores exte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>toString: genial y terrible</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414495/"><p><img src="https://habrastorage.org/webt/on/px/4c/onpx4cu-vxqkdask5tvj3so9va4.jpeg" alt="imagen"></p><br><p>  La función <em>toString</em> en <strong>JavaScript es</strong> probablemente la más "implícita" discutida tanto entre los desarrolladores de js como entre los observadores externos.  Ella es la causa de numerosos chistes y memes sobre muchas operaciones aritméticas sospechosas, transformaciones que entran en un estupor <em>[objeto de objeto]</em> .  Se admite, tal vez, solo para sorprender cuando se trabaja con float64. </p><br><p>  Los casos interesantes que tuve que observar, usar o superar, me motivaron a escribir un informe real.  Galoparemos sobre la especificación del lenguaje y usaremos los ejemplos para analizar las características no obvias de <em>toString</em> . </p><br><p> Si espera una guía útil y suficiente, entonces <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ese</a> material es más adecuado para usted.  Si su curiosidad aún prevalece sobre el pragmatismo, entonces, por favor, debajo del gato. </p><a name="habracut"></a><br><h3 id="vse-chto-nuzhno-znat">  Todo lo que necesitas saber </h3><br><p>  La función <em>toString</em> es una propiedad del objeto prototipo Object, en palabras simples, su método.  Se utiliza para la conversión de cadenas de un objeto y debe devolver un valor primitivo de una buena manera.  Los objetos prototipo también tienen sus implementaciones: <em>Función, Matriz, Cadena, Booleano, Número, Símbolo, Fecha, RegExp, Error</em> .  Si implementa su prototipo de objeto (clase), <em>toString</em> será una buena forma de hacerlo. </p><br><p>  <em>JavaScript</em> es un lenguaje con un sistema de tipo débil: lo que significa que nos permite mezclar diferentes tipos, realiza muchas operaciones implícitamente.  En las conversiones, <em>toString</em> se combina con <em>valueOf</em> para reducir el objeto a la primitiva necesaria para la operación.  Por ejemplo, el operador de suma se convierte en concatenación si hay al menos una línea entre los operadores.  Algunas funciones estándar del lenguaje antes de su trabajo conducen a un argumento a la cadena: <em>parseInt, decodeURI, JSON.parse, btoa,</em> etc. </p><br><p>  Se ha dicho y ridiculizado bastante sobre el casting implícito.  Consideraremos implementaciones de <em>toString de</em> objetos prototipo de lenguaje clave. </p><br><h3 id="objectprototypetostring">  Object.prototype.toString </h3><br><p>  Si pasamos a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sección</a> correspondiente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de la</a> especificación, encontramos que la tarea principal del <em>toString</em> predeterminado es conseguir que la llamada <strong>etiqueta se</strong> concatene con la cadena resultante: </p><br><pre><code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"[object "</span></span> + tag + <span class="hljs-string"><span class="hljs-string">"]"</span></span></code> </pre> <br><p>  Para hacer esto: </p><br><ol><li>  Se produce una llamada al símbolo interno <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>toStringTag</em></a> (o la pseudo-propiedad <em>[[Class]]</em> en la edición anterior): tiene muchos objetos prototipo incorporados ( <em>Map, Math, JSON</em> y otros). </li><li>  Si falta una cadena o no, entonces se enumeran varias otras pseudo-propiedades internas y métodos que indican el tipo de objeto: <em>[[Call]]</em> para <em>Function</em> , <em>[[DateValue]]</em> para <em>Date,</em> y así sucesivamente. </li><li>  Bueno, si nada, entonces la <em>etiqueta</em> es <em>"Objeto"</em> . </li></ol><br><p>  Aquellos afectados por la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reflexión</a> notarán de inmediato la posibilidad de obtener el tipo de un objeto con una operación simple (no recomendado por la especificación, pero posible): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getObjT = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.toString.call(obj).match(<span class="hljs-regexp"><span class="hljs-regexp">/\[object\s(\w+)]/</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre> <br><p>  La peculiaridad del valor predeterminado de <em>toString</em> es que funciona con cualquier valor de <em>este tipo</em> .  Si es un primitivo, se lanzará al objeto ( <em>nulo</em> e <em>indefinido</em> se verifican por separado).  No <em>TypeError</em> : </p><br><pre> <code class="javascript hljs">[<span class="hljs-literal"><span class="hljs-literal">Infinity</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, x =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}].map(getObjT); &gt; [<span class="hljs-string"><span class="hljs-string">"Number"</span></span>, <span class="hljs-string"><span class="hljs-string">"Null"</span></span>, <span class="hljs-string"><span class="hljs-string">"Function"</span></span>, <span class="hljs-string"><span class="hljs-string">"Date"</span></span>, <span class="hljs-string"><span class="hljs-string">"GeneratorFunction"</span></span>]</code> </pre> <br><p>  ¿Cómo puede ser útil?  Por ejemplo, al desarrollar herramientas para el análisis dinámico de código.  Al tener un conjunto improvisado de variables utilizadas durante el trabajo de la aplicación, puede recopilar estadísticas útiles y homogéneas en tiempo de ejecución. </p><br><p>  Este enfoque tiene un inconveniente importante: los tipos de usuarios.  No es difícil adivinar que para sus instancias solo obtenemos <em>"Objeto"</em> . </p><br><h3 id="kastomnyy-symboltostringtag-i-functionname">  Symbol.toStringTag personalizado y Function.name </h3><br><p>  OOP en JavaScript se basa en prototipos, y no en clases (como en Java), y no tenemos un método <em>getClass ()</em> listo.  Una definición explícita del carácter <em>toStringTag</em> para un tipo de usuario ayudará a resolver el problema: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span></span>{ get [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Cat'</span></span>; } }</code> </pre> <br><p>  o en estilo prototipo: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} Dog.prototype[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag] = <span class="hljs-string"><span class="hljs-string">'Dog'</span></span>;</code> </pre> <br><p>  Existe una solución alternativa a través de la propiedad de solo lectura <em>Function.name</em> , que aún no forma parte de la especificación, pero es compatible con la mayoría de los navegadores.  Cada instancia del prototipo de objeto / clase tiene un enlace a la función constructora con la que se creó.  Entonces podemos encontrar el nombre del tipo: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span></span>{} (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat).constructor.name &lt; <span class="hljs-string"><span class="hljs-string">'Cat'</span></span></code> </pre> <br><p>  o en estilo prototipo: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog).constructor.name &lt; <span class="hljs-string"><span class="hljs-string">'Dog'</span></span></code> </pre> <br><p>  Por supuesto, esta solución no funciona para objetos creados usando una función anónima ( <em>"anónimo"</em> ) o <em>Object.create (nulo)</em> , o para primitivas sin un objeto contenedor ( <em>nulo, indefinido</em> ). </p><br><p>  Por lo tanto, para la manipulación confiable de tipos de variables, vale la pena combinar técnicas bien conocidas, basadas principalmente en la tarea en cuestión.  En la gran mayoría de los casos, <em>typeof</em> e <em>instanceof</em> son suficientes. </p><br><h3 id="functionprototypetostring">  Function.prototype.toString </h3><br><p>  Estábamos un poco distraídos, pero como resultado llegamos a funciones que tienen su propio <em>toString</em> interesante.  Primero, eche un vistazo al siguiente código: </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'('</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.callee.toString() + <span class="hljs-string"><span class="hljs-string">')()'</span></span>); })()</code> </pre> <br><p>  Muchos probablemente adivinaron que este es un ejemplo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quine</a> .  Si carga una secuencia de comandos con dicho contenido en el cuerpo de la página, se mostrará una copia exacta del código fuente en la consola.  Esto se debe a la llamada <em>aString</em> desde la función <em>argumentos.callee</em> . </p><br><p>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementación</a> utilizada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">del</a> objeto prototipo <em>toString of the</em> <em>Function</em> devuelve una representación de cadena del código fuente de la función, conservando la sintaxis utilizada en su definición: <em>FunctionDeclaration, FunctionExpression, ClassDeclaration, ArrowFunction</em> , etc. </p><br><p>  Por ejemplo, tenemos una función de flecha: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bind = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, ctx</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.apply(ctx, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }</code> </pre> <br><p>  Llamar a <em>bind.toString ()</em> nos devolverá una representación de cadena de <em>ArrowFunction</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"(f, ctx) =&gt; function() { return f.apply(ctx, arguments); }"</span></span></code> </pre> <br><p>  Y llamar a <em>toString</em> desde una función envuelta ya es una representación de cadena de <em>FunctionExpression</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"function() { return f.apply(ctx, arguments); }"</span></span></code> </pre> <br><p>  Este ejemplo de <em>enlace</em> no es accidental, ya que tenemos una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solución preparada</a> con el enlace de contexto <em>Function.prototype.bind</em> , y con respecto a las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funciones enlazadas</a> nativas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> hay una característica de <em>Function.prototype.toString que</em> trabaja con ellas.  Dependiendo de la implementación, se puede obtener una representación tanto de la función ajustada como de la función <em>objetivo</em> .  V8 y SpiderMonkey últimas versiones de Chrome y FF: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getx</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } getx.bind({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }).toString() &lt; <span class="hljs-string"><span class="hljs-string">"function () { [native code] }"</span></span></code> </pre> <br><p>  Por lo tanto, se debe tener precaución con las características decoradas de forma nativa. </p><br><h3 id="praktika-ispolzovaniya-ftostring">  Practica usando f.toString </h3><br><p>  Hay muchas opciones para usar <em>toString en</em> cuestión, pero es urgente solo como una herramienta de metaprogramación o depuración.  Tener una aplicación típica similar en lógica de negocios tarde o temprano conducirá a una depresión rota no admitida. </p><br><p>  Lo más simple que viene a la mente es <strong>determinar la duración de la función</strong> : </p><br><pre> <code class="javascript hljs">f.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).length</code> </pre> <br><p>  La ubicación y el número de caracteres de espacio en blanco del resultado de <em>toString</em> están dados por la especificación para la compra de una implementación específica, por lo tanto, para la limpieza, primero eliminamos el exceso, lo que lleva a una vista general.  Por cierto, en versiones anteriores del motor Gecko, la función tenía un parámetro de <em>sangría</em> especial que ayuda a formatear sangrías. </p><br><p>  La <strong>definición de los nombres de los parámetros de la función</strong> viene inmediatamente a la mente, lo que puede ser útil para la reflexión: </p><br><pre> <code class="javascript hljs">f.toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/^function(?:\s+\w+)?\s*\(([^\)]+)/m</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>].split(<span class="hljs-regexp"><span class="hljs-regexp">/\s*,\s*/</span></span>)</code> </pre> <br><p>  Esta solución de rodilla es adecuada para la sintaxis de <em>FunctionDeclaration</em> y <em>FunctionExpression</em> .  Si necesita uno más detallado y preciso, le recomiendo que busque ejemplos del código fuente de su marco favorito, que probablemente tenga algún tipo de inyección de dependencia bajo el capó, según los nombres de los parámetros declarados. </p><br><p>  Una opción peligrosa e interesante para <strong>anular una función a</strong> través de <em>eval</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prod = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(sum.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\+(?=\s*(?:a|b))/gm</span></span>, <span class="hljs-string"><span class="hljs-string">'*'</span></span>)); sum(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">15</span></span> prod(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">50</span></span></code> </pre> <br><p>  Conociendo la estructura de la función original, creamos una nueva reemplazando el operador de suma usado en su cuerpo con argumentos con multiplicación.  En el caso de código generado por software o la falta de una interfaz de extensión de función, esto puede ser mágicamente útil.  Por ejemplo, si está investigando un modelo matemático, seleccionando una función adecuada, jugando con operadores y coeficientes. </p><br><p>  Un uso más práctico es la <strong>compilación y distribución de plantillas</strong> .  Muchas implementaciones de motor de plantillas compilan el código fuente de una plantilla y proporcionan una función de datos que ya forma el HTML final (u otro).  El siguiente es un ejemplo de la función <a href="">_.template</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloJst = <span class="hljs-string"><span class="hljs-string">"Hello, &lt;%= user %&gt;"</span></span> _.template(helloJst)({ <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-string"><span class="hljs-string">'admin'</span></span> }) &lt; <span class="hljs-string"><span class="hljs-string">"Hello, admin"</span></span></code> </pre> <br><p>  Pero, ¿qué pasa si compilar la plantilla requiere recursos de hardware o si el cliente es muy delgado?  En este caso, podemos compilar la plantilla en el lado del servidor y dar a los clientes no el texto de la plantilla, sino una representación en cadena de la función finalizada.  Además, no necesita cargar la biblioteca de plantillas en el cliente. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloStr = _.template(helloJst).toString() helloStr &lt; <span class="hljs-string"><span class="hljs-string">"function(obj) { obj || (obj = {}); var __t, __p = ''; with (obj) { __p += 'Hello, ' + ((__t = ( user )) == null ? '' : __t); } return __p }"</span></span></code> </pre> <br><p>  Ahora necesitamos ejecutar este código en el cliente antes de usarlo.  Que en la compilación no hubo <em>SyntaxError</em> debido a la sintaxis de <em>FunctionExpression</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloFn = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(helloStr.replace(<span class="hljs-regexp"><span class="hljs-regexp">/^function\(obj\)/</span></span>, <span class="hljs-string"><span class="hljs-string">'obj=&gt;'</span></span>));</code> </pre> <br><p>  más o menos: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloFn = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`const f = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${helloStr}</span></span></span><span class="hljs-string">;f`</span></span>);</code> </pre> <br><p>  O como más te guste.  En cualquier caso: </p><br><pre> <code class="javascript hljs">helloFn({ <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-string"><span class="hljs-string">'admin'</span></span> }) &lt; <span class="hljs-string"><span class="hljs-string">"Hello, admin"</span></span></code> </pre> <br><p>  Puede que esta no sea la mejor práctica para compilar plantillas en el lado del servidor y distribuirlas a los clientes aún más.  Solo un ejemplo usando un montón de <em>Function.prototype.toString</em> y <em>eval</em> . </p><br><p>  Finalmente, la antigua tarea de <strong>definir el nombre de una función</strong> (antes de que aparezca la propiedad <em>Function.name</em> ) a través de <em>toString</em> : </p><br><pre> <code class="javascript hljs">f.toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/function\s+(\w+)(?=\s*\()/m</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  Por supuesto, esto funciona bien con la sintaxis de <em>FunctionDeclaration</em> .  Una solución más inteligente requerirá una astuta expresión regular o coincidencia de patrones. </p><br><p>  Internet está lleno de soluciones interesantes basadas en <em>Function.prototype.toString</em> , solo pregunte.  Comparte tu experiencia en los comentarios: muy interesante. </p><br><h3 id="arrayprototypetostring">  Array.prototype.toString </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La implementación de</a> <em>toString de</em> un prototipo de objeto <em>Array</em> es genérica y se puede llamar para cualquier objeto.  Si el objeto tiene un método de <em>unión</em> , el resultado de <em>toString</em> será su llamada, de lo contrario, <em>Object.prototype.toString</em> . </p><br><p>  <em>La matriz</em> , lógicamente, tiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un método de unión</a> que concatena la representación de cadena de todos sus elementos a través del <em>separador</em> pasado como parámetro (el valor predeterminado es una coma). </p><br><p>  Supongamos que necesitamos escribir una función que serialice una lista de sus argumentos.  Si todos los parámetros son primitivos, en muchos casos podemos prescindir de <em>JSON.stringify</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seria</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>).toString(); }</code> </pre> <br><p>  más o menos: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> seria = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> a.toString();</code> </pre> <br><p>  Solo recuerde que la cadena '10' y el número 10 se serializarán de la misma manera.  En el problema del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">memorizador más corto</a> en una etapa, se utilizó esta solución. </p><br><p>  La combinación nativa de elementos de matriz funciona a través de un ciclo aritmético de 0 a <em>longitud</em> y no filtra los elementos faltantes ( <em>nulos</em> e <em>indefinidos</em> ).  En cambio, la concatenación ocurre con el <em>separador</em> .  Esto lleva a lo siguiente: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>); ar.toString() &lt; <span class="hljs-string"><span class="hljs-string">",,,...,,,"</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1000 times</span></span></code> </pre> <br><p>  Por lo tanto, si por una razón u otra agrega un elemento con un índice grande a la matriz (por ejemplo, esta es una identificación natural generada), en ningún caso no se una y, en consecuencia, no conduzca a una cadena sin una preparación preliminar.  De lo contrario, puede haber consecuencias: <em>longitud de cadena no válida,</em> falta <em>de memoria</em> o simplemente un script colgante.  Use las funciones del objeto <em>Valores</em> y <em>claves</em> del objeto para iterar sobre sus propias propiedades enumeradas del objeto solamente: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> k = []; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">20</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(k).toString() &lt; <span class="hljs-string"><span class="hljs-string">"1,2,3"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(k).toString() &lt; <span class="hljs-string"><span class="hljs-string">"1024,1048576,1073741824"</span></span></code> </pre> <br><p>  Pero es mucho mejor evitar tal manejo de la matriz: lo más probable es que un simple objeto de valor clave le convenga como almacenamiento. </p><br><p>  Por cierto, existe el mismo peligro cuando se serializa a través de <em>JSON.stringify</em> .  Solo que es más grave, ya que los elementos vacíos y no compatibles ya están representados como <em>"nulos"</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(ar); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">]" // </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1000</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">times</span></span></span></span></span></span></code> </pre> <br><p>  Concluyendo la sección, me gustaría recordarle que puede definir su método de <em>unión</em> para el tipo de usuario y llamar a <em>Array.prototype.toString.call</em> como una <em>conversión</em> alternativa a la cadena, pero dudo que tenga algún uso práctico. </p><br><h3 id="numberprototypetostring-i-parseint">  Number.prototype.toString y parseInt </h3><br><p>  Una de mis tareas favoritas para los cuestionarios js es ¿Qué devolverá la próxima llamada de <em>parseInt</em> ? </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  Lo primero que hace <em>parseInt</em> es emitir implícitamente un argumento a una cadena llamando a la función abstracta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>ToString</em></a> , que, según el tipo de argumento, ejecuta la rama de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>conversión</em></a> deseada.  Para el <em>número de</em> tipo, se hace lo siguiente: </p><br><ol><li>  Si el valor es <em>NaN, 0</em> o <em>Infinito</em> , devuelve la cadena correspondiente. </li><li>  De lo contrario, el algoritmo devuelve el registro más conveniente para la persona del número: en forma decimal o exponencial. </li></ol><br><p>  No duplicaré el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algoritmo para</a> determinar la forma preferida aquí, solo notaré lo siguiente: si el número de dígitos en una notación decimal excede <strong>21</strong> , entonces se seleccionará una forma exponencial.  Y esto significa que en nuestro caso <em>parseInt</em> no funciona con "100 ... 000" sino con "1e30".  Por lo tanto, la respuesta no se espera en absoluto 2 ^ 30.  Quién sabe la naturaleza de este número mágico 21: ¡escribe! </p><br><p>  A continuación, <em>parseInt</em> analiza la base del sistema de números de <em>radix</em> utilizado (por defecto 10, tenemos 2) y verifica la compatibilidad de los caracteres de la cadena recibida.  Habiendo encontrado 'e', ​​corta toda la cola, dejando solo "1".  El resultado será un número entero obtenido mediante la conversión del sistema con la base de la raíz a decimal; en nuestro caso, es 1. </p><br><p>  Procedimiento inverso: </p><br><pre> <code class="javascript hljs">(<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>).toString(<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  Aquí es donde se llama a la función <em>toString</em> desde el objeto prototipo <em>Number</em> , que usa el mismo algoritmo para convertir el <em>número</em> en una cadena.  También tiene el parámetro de <em>raíz</em> opcional.  Solo arroja un <em>RangeError</em> para un valor no válido (debe ser un número entero de 2 a 36 inclusive), mientras que <em>parseInt</em> devuelve <em>NaN</em> . </p><br><p>  Vale la pena recordar el límite superior del sistema de números si planea implementar una función hash exótica: este <em>toString</em> puede no funcionar para usted. </p><br><p>  La tarea de distraer por un momento: </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'3113'</span></span>.split(<span class="hljs-string"><span class="hljs-string">''</span></span>).map(<span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>)</code> </pre> <br><p>  ¿Qué volverá y cómo solucionarlo? </p><br><h3 id="obdelennoe-vnimaniem">  Privado de atención </h3><br><p>  Examinamos <em>toString</em> de ninguna manera, incluso todos los objetos prototipos nativos.  En parte, porque personalmente no tuve que meterme en problemas con ellos, y no hay mucho interés en ellos.  Además, no tocamos la función <em>toLocaleString</em> , ya que sería bueno hablar de ello por separado.  Si hice algo en vano sin atención, perdido de vista o mal entendido, ¡asegúrese de escribir! </p><br><h3 id="prizyv-k-bezdeystviyu">  Llamado a la inacción </h3><br><p>  Los ejemplos que he citado no son recetas preparadas, solo alimento para pensar.  Además, me parece inútil y un poco estúpido discutir esto en entrevistas técnicas: para esto, hay temas eternos sobre cierres, uniones, un bucle de eventos, patrones de módulo / fachada / mediador y preguntas "por supuesto" sobre [el marco utilizado]. </p><br><p>  Este artículo resultó ser una mezcolanza, y espero que hayas encontrado algo interesante para ti.  PD El lenguaje JavaScript: ¡increíble! </p><br><h3 id="bonus">  Bono </h3><br><p>  Al preparar este material para su publicación, utilicé Google Translate.  Y por casualidad descubrí un efecto entretenido.  Si selecciona una traducción del ruso al inglés, ingrese "toString" y comience a borrarla usando la tecla Retroceso, luego observaremos: </p><br><p><img src="https://habrastorage.org/webt/op/yl/g3/opylg3burl5dlqv5ojibfeis0c4.gif" alt="bono"></p><br><p>  ¡Qué ironía!  Creo que estoy lejos del primero, pero por si acaso les envié una captura de pantalla con un script de reproducción.  Parece un inofensivo self-XSS, por eso lo comparto. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414495/">https://habr.com/ru/post/es414495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414483/index.html">Escriba Safe SQL en Kotlin</a></li>
<li><a href="../es414485/index.html">GNMT, falla épica o sutilezas de la traducción automática</a></li>
<li><a href="../es414487/index.html">Un representante raro del tipo de fuerza bruta: la historia de un ataque</a></li>
<li><a href="../es414489/index.html">Estados Unidos planea abordar seriamente el tema de los desechos espaciales</a></li>
<li><a href="../es414493/index.html">Cómo escribir un contrato inteligente para ICO en 5 minutos</a></li>
<li><a href="../es414497/index.html">Consulo UI API de la idea al prototipo</a></li>
<li><a href="../es414499/index.html">Informe del Club de Roma 2018, Capítulo 1.1.3: “Un mundo vacío versus una paz plena”</a></li>
<li><a href="../es414501/index.html">Informe del Club de Roma 2018, Capítulo 3.11: “Reformas del sector financiero”</a></li>
<li><a href="../es414503/index.html">Intel NUC Hades Canyon con AMD Vega Graphics: ¿VR o no VR?</a></li>
<li><a href="../es414505/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 2: "Control de ataques de hackers", parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>