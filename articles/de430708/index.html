<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë©üèΩ üîö ü•Ä Tic Tac Toe "Ohne Grenzen" üèÇüèª üè§ ‚ÜïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tic-Tac-Toe ... alle haben sie gespielt, da bin ich mir sicher. Das Spiel ist in seiner Einfachheit attraktiv, besonders wenn Sie die Uhr irgendwo in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tic Tac Toe "Ohne Grenzen"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430708/"> Tic-Tac-Toe ... alle haben sie gespielt, da bin ich mir sicher.  Das Spiel ist in seiner Einfachheit attraktiv, besonders wenn Sie die Uhr irgendwo in der Lektion ziehen, ein Paar, und nichts zur Hand ist au√üer einem Notizbuchblatt und einem einfachen Bleistift.  Ich wei√ü nicht, wer der erste war, der einmal vermutet hat, Kreuze und Kreise auf 9 Feldern zu zeichnen, aber seitdem hat das Spiel √ºberhaupt nicht an Nachfrage verloren, zumal die Leute viele seiner Variationen erfunden haben. <br><br><img src="https://habrastorage.org/webt/pd/gx/-c/pdgx-cibc6880fmwfxt90nxmi-k.jpeg"><br><br>  In diesem Artikel geht es um den Prozess der Entwicklung von KI auf Javascript zum Spielen einer dieser Variationen von Tic-Tac-Toe: Ich habe viel Material, aber ich habe es mit Animationen und Bildern verd√ºnnt.  Auf jeden Fall ist es einen Versuch wert, es zu spielen. <br>  Die Unterschiede zwischen dieser Version des Spiels und dem Original sind wie folgt: <br><br><ol><li>  <b>Das Feld</b> kann beliebig <b>gro√ü sein</b> (wie lange h√§lt das Notebook) </li><li>  Der Gewinner ist derjenige, der <b>5 Teile</b> (wenn man sie so nennen kann) hintereinander legt. </li></ol><br>  Alles ist einfach ... und gleichzeitig kompliziert: Das Ergebnis des Spiels kann nicht wie im klassischen Analogon im Voraus berechnet werden.  Diese "kleine Projektion" hat mir viel Zeit und Nerven genommen.  Hoffe du findest es interessant. <a name="habracut"></a><br><br><h3>  Bevor wir anfangen </h3><br>  Ich war gezwungen, mich im Voraus f√ºr den Umfang des Artikels und an einigen Stellen f√ºr die nicht ganz verst√§ndliche Darstellung des Denkens zu entschuldigen, konnte die Herde jedoch nicht ohne Verlust an Inhalt und Qualit√§t quetschen. <br>  Ich empfehle Ihnen, sich zuerst mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ergebnis</a> vertraut zu machen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> <br><br>  Hotkeys und Befehle: <br><br><ul><li>  <b>D</b> - AI wird einen Schritt f√ºr Sie machen </li><li>  <b>T</b> - siehe Zellgewicht </li><li>  Schreiben Sie <b>SHOW_WEIGHTS = true</b> in die Konsole, um die Gewichte aller analysierten Zellen anzuzeigen. </li></ul><br><h3>  Fangen wir an </h3><br>  Sie m√ºssen mit der Implementierung des Spiels selbst beginnen, d. H.  schreibe eine Bewerbung f√ºr zwei Spieler, bisher ohne Bot.  F√ºr meine Zwecke habe ich mich f√ºr Javascript + JQuery + Bootstrap4 entschieden, obwohl es dort praktisch nicht verwendet wird, aber es ist besser, es zu belassen - sonst schwebt die Tabelle.  Es gibt nichts Besonderes zu erz√§hlen, es gibt viel Material zu js, jquery und bootstrap.  Ich kann nur sagen, dass ich MVC verwendet habe.  Wie auch immer, ich werde nicht den gesamten Code erkl√§ren - es gab bereits viel Material. <br><br>  Das Spielfeld war also fertig.  Sie k√∂nnen Formen in Zellen festlegen.  Aber der Sieg eines der Spieler war in keiner Weise festgelegt. <br><br><h3>  Spielende-Scan </h3><br>  Das Spiel endet, wenn einer der Spieler <b>5 Teile</b> hintereinander legt.  "Es ist einfach!"  Dachte ich.  Und er fing an, absolut alle Zellen des Feldes zu scannen: zuerst alle horizontalen, dann die vertikalen und schlie√ülich die Diagonalen. <br><br>  Das ist ein dummer Weg, aber es hat funktioniert.  Es k√∂nnte jedoch erheblich verbessert werden, was ich auch getan habe: Die meisten Zellen bleiben w√§hrend des Spiels leer - das Spielfeld ist zu gro√ü, um vollst√§ndig gef√ºllt zu werden.  Da es notwendig war, jede Bewegung zu scannen und nur ein Teil in einer Bewegung platziert wird, k√∂nnen Sie sich nur auf dieses Teil (Zelle) konzentrieren: Scannen Sie nur eine horizontale, vertikale und zwei Diagonalen der Zelle, die dieselbe Zelle besitzt. <br><br>  Au√üerdem m√ºssen Sie nicht alle Zelllinien scannen.  Da das Ende des Spiels 5 Teile hintereinander ist, sind die Teile, die 6 Zellen voneinander entfernt sind, f√ºr uns nicht von Interesse.  Es reicht aus, f√ºnf Zellen auf jeder Seite zu scannen.  Unverst√§ndlich?  Siehe die Animation unten. <br><br><img src="https://habrastorage.org/webt/nt/fj/wu/ntfjwuj6nfabfj2qtedcs4g-fp0.gif"><br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen</b> <div class="spoiler_text"><pre><code class="javascript hljs">checkWin( cellX, cellY ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newFig = getFig(cellX,cellY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! newFig ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res; res = res || checkLine( cellX, cellY, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//horizontal res = res || checkLine( cellX, cellY, 0, 1 ); //vertical res = res || checkLine( cellX, cellY, 1, 1 ); //diagonal 45 res = res || checkLine( cellX, cellY, 1, -1 ); //diagonal 135 return res; function getFig( x, y ){ return Model.Field[x] &amp;&amp; Model.Field[x][y] ? Model.Field[x][y] : 'b'; } function checkLine( x, y, dx, dy ){ x = +x; y = +y; var score = 0; while( getFig( x - dx, y - dy ) == newFig ){ x -= dx; y -= dy; } while( getFig( x, y ) == newFig ){ x += dx; y += dy; score++; } if( score &gt;= 5 ) return true; return false; } }</span></span></code> </pre> <br></div></div><br><h3>  Kommen wir zum Bot selbst </h3><br>  Wir haben also bereits eine Seite mit Tic-Tac-Toe geschrieben.  Wir gehen zur Hauptaufgabe √ºber - KI. <br>  Sie k√∂nnen nicht einfach Code nehmen und schreiben, wenn Sie nicht wissen wie: Sie m√ºssen √ºber die Logik des Bots nachdenken. <br><br>  Die Quintessenz besteht darin, das Spielfeld, zumindest einen Teil davon, zu analysieren und den <b>Preis (das Gewicht)</b> jeder Zelle auf dem Spielfeld zu berechnen.  Die Zelle mit dem h√∂chsten Gewicht - das vielversprechendste - der Bot wird dort eine Zahl setzen.  Die Hauptschwierigkeit besteht in der Berechnung des Gewichts einer Zelle. <br><br><h3>  Terminologie </h3><br>  <b>Kreuze und Zehen</b> sind Figuren. <br>  <b>Ein Angriff</b> wird als mehrere identische Figuren bezeichnet, die nebeneinander auf derselben Linie stehen.  In der Tat ist das viel.  Die Anzahl der Teile eines Angriffs ist seine <b>St√§rke</b> .  Ein separates St√ºck ist auch ein Angriff (Kraft 1). <br><br>  Auf benachbarten Angriffszellen (an den Enden) k√∂nnen sich leere Zellen oder feindliche Teile befinden.  Es ist logisch zu denken, dass ein Angriff mit zwei leeren Zellen an den ‚ÄûEnden‚Äú in zwei Richtungen entwickelt werden kann, was ihn vielversprechender macht.  Die Anzahl der leeren Zellen an den "Enden" des Angriffs wird als <b>Potenzial bezeichnet</b> .  Das Potential kann 0, 1 oder 2 sein. <br>  Wir bezeichnen Angriffe wie folgt: <b>[Angriffskraft, Potenzial]</b> .  Zum Beispiel ein <b>Angriff [4: 1]</b> . <br><br><img src="https://habrastorage.org/webt/1_/pk/e3/1_pke3kve1yjbf6cjjzg3hnnzvm.jpeg"><br>  <i>Abbildung 1. Angriff [4: 1]</i> <br><br>  Im Verlauf der Analyse werden alle Zellen ausgewertet, die in einen bestimmten Bereich eintreten.  Jede Zelle berechnet ihr <b>Gewicht</b> .  Sie wird basierend auf den Gewichten aller Angriffe berechnet, die von dieser Zelle betroffen sind. <br><br><h3>  Das Wesentliche der Analyse </h3><br>  Stellen Sie sich vor, auf dem Spielfeld gibt es bereits mehrere Angriffe eines und des zweiten Spielers.  Einer der Spieler macht einen Zug (lass die Kreuze).  Nat√ºrlich zieht er in eine leere Zelle - und damit kann er: <br><br><ol><li>  Entwickle deinen Angriff und vielleicht mehr als einen, um seine Kraft zu erh√∂hen.  Kann einen neuen Angriff starten usw. </li><li>  Verhindern Sie die Entwicklung eines feindlichen Angriffs oder blockieren Sie ihn vollst√§ndig. </li></ol><br>  Das hei√üt, unser Protagonist kann angreifen und verteidigen.  Oder vielleicht auf einmal.  F√ºr ihn sind sowohl der erste als auch der zweite wichtig. <br><br>  Das Wesentliche der Analyse ist wie folgt: <br><br><ol><li>  Der Bot ersetzt die Zahlen in der markierten Zelle: zuerst ein Kreuz, dann eine Null. </li><li>  Dann sucht er nach allen Angriffen, die durch solche Bewegungen erhalten wurden, und fasst ihre Gewichte zusammen. </li><li>  Die erhaltene Menge ist das Gewicht der Zelle. </li><li>  Ein √§hnlicher Algorithmus wird f√ºr alle Zellen des Spielfelds durchgef√ºhrt. </li></ol><br><img src="https://habrastorage.org/webt/ur/rc/qz/urrcqzyrjrnp9oupxjoqc1iu6wg.gif"><br><br>  Tats√§chlich √ºberpr√ºfen wir mit einem solchen Algorithmus, was passieren wird, wenn wir diesen Weg gehen ... und was passieren wird, wenn der Gegner diesen Weg geht.  Wir freuen uns auf einen Schritt und w√§hlen die am besten geeignete Zelle aus - mit dem h√∂chsten Gewicht. <br><br>  Wenn eine Zelle mehr Gewicht als eine andere hat, f√ºhrt dies zur Entstehung gef√§hrlicherer Angriffe oder zur Blockierung starker feindlicher Angriffe.  Alles ist logisch ... es scheint mir. <br>  Wenn Sie zur Seite gehen und in die Konsole SHOW_WEIGHTS = true schreiben, k√∂nnen Sie die Funktionsweise des Algorithmus visuell sp√ºren (Zellengewichte werden angezeigt). <br><br><h3>  Angriffsgewichte </h3><br>  Ich ging mein Gehirn durch und brachte eine solche Entsprechung von Angriffen und Gewichten: <br><br><pre> <code class="javascript hljs">ATTACK_WEIGHT = [[],[],[],[],[],[]]; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">6</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0.25</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">7</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre><br>  Empirisch ausgew√§hlt - vielleicht ist dies nicht die beste Option. <br><br>  Ich habe dem Array eine Angriffskraft von 5 mit unerschwinglich gro√üem Gewicht hinzugef√ºgt.  Dies kann durch die Tatsache erkl√§rt werden, dass der Bot das Spiel analysiert und einen Schritt nach vorne betrachtet (indem er die Figur in der Zelle ersetzt).  Das √úberspringen eines solchen Angriffs ist nichts anderes als eine Niederlage.  Na ja, oder Sieg ... je nachdem wer. <br><br>  Angriffe mit hohem Potenzial werden h√∂her bewertet. <br><br>  Angriff [4: 2] entscheidet in den meisten F√§llen √ºber das Ergebnis des Spiels.  Wenn es dem Spieler gelungen ist, einen solchen Angriff zu erstellen, kann der Gegner ihn nicht mehr blockieren.  Dies ist jedoch kein Sieg.  Der Feind kann das Spiel schneller beenden, selbst wenn wir einen Angriff [4: 2] auf dem Spielfeld haben, sodass sein Gewicht geringer ist als das von Angriffen mit einer St√§rke von 5. Siehe ein Beispiel unten. <br><br><img src="https://habrastorage.org/webt/pk/4u/mm/pk4ummarchcw9j4lpkujlmj_iig.jpeg"><br>  <i>Abbildung 2. Angriff [4: 2]</i> <br><br><h3>  Zerrissene Angriffe </h3><br>  Der Code wird in diesem Absatz nicht dargestellt.  Hier stellen wir das Konzept eines Angriffsteilers vor und erkl√§ren die Essenz von <b>‚Äûzerrissenen Angriffen‚Äú</b> . <br><br>  Stellen Sie sich folgende Situation vor: Wenn Sie eine Zahl ersetzen, um mehrere leere Zellen zu entfernen, jedoch nicht mehr als 5, befindet sich eine weitere. <br><br>  Und es scheint, zwei identische Figuren auf derselben Linie ... visuell sieht es aus wie ein Angriff, aber tats√§chlich nicht.  Kein Befehl, da solche "zerrissenen" Angriffe auch eine potenzielle Bedrohung darstellen. <br><br>  Insbesondere in solchen F√§llen berechnen wir f√ºr jeden Angriff den Divisor.  Anfangs ist sein Wert 1. <br><br><ol><li>  Wir pr√§sentieren den "zerrissenen" Angriff als mehrere gew√∂hnliche </li><li>  Wir z√§hlen die Anzahl der leeren Zellen zwischen dem zentralen Angriff und der Seite </li><li>  F√ºr jede leere Zelle wird der Divisor um 1 erh√∂ht </li><li>  Wir berechnen wie gewohnt das Gewicht des Zentralangriffs, das Gewicht der Seitenangriffe - dividiert durch den Divisor </li></ol><br><img src="https://habrastorage.org/webt/dc/w9/62/dcw9629rd4zdhomn6q2uwi5yxkg.jpeg"><br>  <i>Abb. 3. Analyse des "Zerrissenen Angriffs".</i>  <i>Eine Zelle mit einem gelben Kreuz wird gescannt.</i> <br><br>  Somit werden zerrissene Angriffe auch von der KI ber√ºcksichtigt.  Tats√§chlich handelt es sich um gew√∂hnliche Angriffe, aber je weiter sie von der gescannten Zelle entfernt sind, desto weniger Einfluss haben sie darauf und dementsprechend haben sie weniger Gewicht (dank des Teilers). <br><br><h3>  Angriffssuchalgorithmus </h3><br>  Erstellen Sie zun√§chst <b>eine</b> Angriffsklasse.  Der Angriff wird 3 Attribute haben, √ºber die ich zuvor geschrieben habe: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attack</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( cap = 0, pot = 0, div = 1 ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability = cap; <span class="hljs-comment"><span class="hljs-comment">// this.potential = pot; // this.divider = div; // }</span></span></code> </pre><br>  Und eine <b>Methode</b> , die das Gewicht eines bestimmten Angriffs zur√ºckgibt: <br><br><pre> <code class="javascript hljs">countWeigth(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ATTACK_WEIGHT[ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.potential ] / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.divider } }</code> </pre><br>  Weiter.  Wir werden die Suche nach allen Angriffen f√ºr eine Zelle in folgende Bereiche unterteilen: <br><br><ol><li>  Horizontale Suche </li><li>  Vertikale Suche </li><li>  45-Grad-Diagonalsuche </li><li>  135-Grad-Diagonalsuche </li></ol><br>  All dies sind <b>Linien</b> , und der Algorithmus f√ºr die Suche nach Angriffen auf diese Linien kann verallgemeinert werden: <b>die checkLine-Klasse</b> . <br><br>  Wir m√ºssen jedoch nicht die gesamte Zeile √ºberpr√ºfen.  Die maximale Angriffskraft, die uns interessiert, ist 5. Nat√ºrlich ist es m√∂glich, einen Angriff mit einer Kraft von beispielsweise 6 zu erstellen.  F√ºr eine KI, die die Spielsituation des n√§chsten Zuges analysiert, entspricht dies 6 oder 5. Die Aussicht auf einen dieser Angriffe zeigt das Ende des Spiels im n√§chsten Zug an.  Dementsprechend ist das Gewicht der analysierten Zelle in beiden F√§llen gleich. <br><br>  Klassenattribute: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">checkLine</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">//,        this.subFig = "√ó"; //     .    ¬´0¬ª - . this.Attacks = []; //  this.curAttack = new Attack; // (      ) this.iter = 1; //,     this.checkEdge = false;</span></span></code> </pre><br>  Hier muss angehalten werden, da sich die Frage stellen kann: Warum die 6. Zelle √ºberpr√ºfen, wenn die maximale Angriffskraft 5 betr√§gt? Die Antwort besteht darin, das Potenzial zu ermitteln, das vom Angriffszentrum entfernt ist. <br><br>  Hier ein Beispiel: Ein Angriff mit einer Potenz von 1 im Bild befindet sich am Rand des gescannten Bereichs.  Um das Potenzial dieses Angriffs herauszufinden, m√ºssen Sie "ins Ausland schauen". <br><br><img src="https://habrastorage.org/webt/cg/hb/0r/cghb0ryfnk7kgmaqhw-67emn0qc.jpeg"><br>  <i>Abb.</i>  <i>3. 6. Zellen scannen.</i>  <i>Wenn Sie die 6. Zelle nicht scannen, k√∂nnen Sie das Angriffspotential falsch bestimmen.</i> <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   this.attackplace = 1; }</span></span></code> </pre><br>  M√∂glicherweise ist einfach nicht gen√ºgend Platz vorhanden, um einige Angriffe abzuschlie√üen.  Nachdem wir den Angriffsort gez√§hlt haben, k√∂nnen wir im Voraus verstehen, welcher der Angriffe nicht vielversprechend ist. <br><br><img src="https://habrastorage.org/webt/ww/fy/n4/wwfyn4tolymet3ylnf53hax6gju.jpeg"><br>  <i>Abb.</i>  <i>4. Ort zum Angriff</i> <br><br>  Der Algorithmus ist wie folgt: <br><br>  1) Beginnen wir mit der zentralen Zelle.  Es sollte leer sein (wir werden einen Zug hinein machen, richtig? Aber wir vergessen nicht, dass unsere KI Zahlen in dieser Zelle f√ºr die Analyse des n√§chsten Zuges ersetzen muss. Die Zahl, die wir ersetzen, ist <b>this.subfig</b> - der Standardwert ist ein Kreuz. Da die zentrale Zelle nach dem Ersetzen zun√§chst eine bestimmte Form enth√§lt, geh√∂rt sie zu einem Angriff <b>this.curAttack</b> : <br><br><ul><li>  seine Leistung wird nicht weniger als 1 sein (eine Zahl in der zentralen Zelle) </li><li>  Teiler - 1, weil  es ist ein zentraler Angriff (es geh√∂rt zur gescannten Zelle); </li><li>  Potenzial ist noch nicht bekannt - Standard ist 0; </li></ul><br><br>  Wir haben alle diese Punkte in den Standardkonstruktorwerten angezeigt - siehe den obigen Code. <br><br>  2) Als n√§chstes iteriert das Reduzieren des Iterators √ºber 5 Zellen auf einer Seite des gescannten.  Die Funktion <b>getAttacks (cellX, cellY, subFig, dx, dy)</b> ist daf√ºr verantwortlich, wobei: <br><br>  <b>cellX, cellY</b> - Koordinaten der √ºberpr√ºften Zelle <br>  <b>subFig</b> - die Zahl, die wir in der <b>markierten</b> Zelle ersetzen <br>  <b>dx, dy</b> - √Ñnderungen der x- und y-Koordinaten in Zyklen - so stellen wir die Suchrichtung ein: <br><br><ul><li>  Horizontal (dx = 1, dy = 0) </li><li>  Vertikal (dx = 0, dy = 1) </li><li>  Diagonale 45 (dx = 1, dy = -1) </li><li>  Diagonale 135 (dx = 1, dy = 1) </li></ul><br>  In gewissem Sinne ist dies ein Vektor parallel zur Suchlinie.  Somit kann eine Funktion in 4 Richtungen suchen und wir werden das DRY-Prinzip nicht noch einmal verletzen. <br><br>  Funktionscode: <br><br><pre> <code class="javascript hljs">getAttacks( cellX, cellY, subFig, dx, dy ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.substitudeFigure( subFig ); <span class="hljs-comment"><span class="hljs-comment">//  ‚Äì  ... for( var x = cellX - dx, y = cellY - dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x -= dx, y -= dy ) if( this.checkCell( x, y ) ) break; //: //    (  ) this.turnAround(); //  -    ... for( var x = cellX + dx, y = cellY + dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x += dx, y += dy ) if( this.checkCell( x, y ) ) break; return this.Attacks; }</span></span></code> </pre><br>  Bitte beachten Sie, dass die Schleife stoppt, wenn checkCell () etwas zur√ºckgibt. <br><br>  3) Wir √ºberpr√ºfen die Zahlen dieser Zellen. <br>  Die Funktion <b>checkCell (x, y)</b> ist daf√ºr verantwortlich: <br><br>  Schreiben Sie zuerst die Form in die <b>Feigenvariable</b> : <br>  <b>Model.Field</b> ist unser Spielfeld. <br><br><pre> <code class="javascript hljs">checkCell( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fig = Model.Field[x] &amp;&amp; Model.Field[x][y] !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> ? Model.Field[x][y] : <span class="hljs-string"><span class="hljs-string">'b'</span></span>;</code> </pre><br>  <b>fig</b> kann 'x', 'o', 'b' (Rand), 0 (leere Zelle) sein. <br><br><ul><li>  Wenn eine solche Zahl mit der Figur der zentralen Zelle ( <b>thisFig</b> ) <b>√ºbereinstimmt</b> , setzen wir den Algorithmus fort - das hei√üt, wir scannen den Angriff weiter, alles ist in Ordnung, wir fahren im gleichen Sinne fort.  Ein zus√§tzliches Teil des Angriffs ist ein Plus f√ºr seine Kraft ( <b>this.curAttack.capability</b> ) und seinen Platz ( <b>this.attackplace</b> ). <br><br>  (Siehe Code im n√§chsten Absatz) </li><li>  Wenn dies eine andere Zahl ist, wird der zuvor gescannte Angriff (this.curAttack) von dieser Seite blockiert.  Wir √§ndern nichts an den Angriffsparametern, schreiben es in das Array von Angriffen und fallen aus der Schleife heraus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'‚óã'</span></span> || fig == <span class="hljs-string"><span class="hljs-string">'√ó'</span></span> ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig != fig ){ <span class="hljs-comment"><span class="hljs-comment">//  this.Attacks.push( this.curAttack ); //  return fig; //      } else{ //    this.curAttack.capability++; // +   this.attackplace++; // +   } }</span></span></code> </pre><br></li><li>  Wenn es keine solche Zelle gibt, bedeutet dies, dass sie aus der Feldgrenze herausgefallen sind, was bedeutet, dass der Angriff blockiert ist.  Wir schreiben es in ein Array aller Angriffe und verlassen die Schleife. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'b'</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">// this.Attacks.push( this.curAttack ); return 'b'; }</span></span></code> </pre><br></li><li>  Wenn Sie einen leeren K√§fig fangen, bedeutet dies, dass der aktuelle Angriff beendet ist oder es sich um einen "zerrissenen Angriff" handelt.  Plus das Potenzial und den Ort zum Angriff (weil der Angriff nicht blockiert ist).  Wir kommen jedoch nicht aus der Schleife heraus - vielleicht ist dies ein "zerrissener Angriff" - wir schreiben einfach this.curAttack in das Array aller Angriffe der Zeile this.Attacks [].  Erstellen Sie einen neuen ‚Äûaktuellen‚Äú Angriff und erh√∂hen Sie seinen Teiler um 1 (dies ist ein Seitenangriff). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  if( this.curAttack.capability ){ this.curAttack.potential++; this.Attacks.push( this.curAttack ); this.curAttack = new Attack; this.curAttack.potential++; } this.curAttack.divider++; this.attackplace++; }</span></span></code> </pre><br></li></ul><br><br>  4) Wenn in der 5. Zelle die Zahl mit der zentralen Zelle √ºbereinstimmt, ‚Äûruhte‚Äú der Angriff an der Grenze und um das Angriffspotential zu bestimmen, m√ºssen Sie ‚Äûdie Grenze √ºberpr√ºfen‚Äú ( <b>this.checkEdge = true</b> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter == <span class="hljs-number"><span class="hljs-number">4</span></span> &amp;&amp; fig == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig ) <span class="hljs-comment"><span class="hljs-comment">// 5-  this.checkEdge = true; else if( this.iter == 5 ){ if( this.checkEdge ){ if( fig == this.curFig || fig == 0 ) this.curAttack.potential++; this.Attacks.push( this.curAttack ) } return 0; } this.iter++</span></span></code> </pre><br>  Die <b>checkCell-</b> Funktion ist bereit.  Wir arbeiten jedoch weiterhin an der <b>checkLine-</b> Klasse. <br><br>  5) Nach Abschluss des ersten Zyklus m√ºssen Sie sich "umdrehen".  Wir √ºbersetzen den Iterator in die Mitte und den zentralen Angriff mit dem Index 0, entfernen ihn aus dem Array der Angriffe und legen ihn als aktuellen fest. <br><br><pre> <code class="javascript hljs">turnAround(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.checkEdge = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curAttack = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre><br>  6) Gehen Sie als n√§chstes zur anderen Seite der aktuellen Zelle und erh√∂hen Sie den Iterator. <br>  Absolut die gleiche √úberpr√ºfung der Zahlen.  (Code bereits geschrieben - Funktion <b>getAttacks</b> ) <br><br>  7) Alles, wir haben alle Angriffe, die auf der Linie waren, in einem Array gesammelt. <br>  Das war's mit der <b>checkLine-</b> Klasse <b>...</b> alles ist erledigt. <br><br>  Nun, dann ist alles einfach - erstellen Sie ein <b>checkLine-</b> Objekt f√ºr jede der Linien (2 Diagonalen, horizontal und vertikal) und rufen Sie die Funktion <b>getAttacks auf</b> .  Das hei√üt, f√ºr jede Zeile - ein eigenes <b>checkLine-</b> Objekt und dementsprechend eine eigene Reihe von Angriffen. <br><br>  Lassen <b>Sie die</b> Funktion <b>getAllAttacks ()</b> f√ºr all dies verantwortlich sein - bereits getrennt von den oben beschriebenen Klassen; <br><br><pre> <code class="javascript hljs">getAllAttacks( cellX, cellY ){ <span class="hljs-comment"><span class="hljs-comment">// ,  , //       if( Model.Field[ cellX ][ cellY ] ) return false var cX = []; var cO = []; //   ... cX['0'] = this.getAttacksLine( cellX, cellY, '√ó', 1, 0 ); cX['90'] = this.getAttacksLine( cellX, cellY, '√ó', 0, 1 ); cX['45'] = this.getAttacksLine( cellX, cellY, '√ó', 1, -1 ); cX['135'] = this.getAttacksLine( cellX, cellY, '√ó', 1, 1 ); //  ... cO['0'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, 0 ); cO['90'] = this.getAttacksLine( cellX, cellY, '‚óã', 0, 1 ); cO['45'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, -1 ); cO['135'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, 1 ); return { //     'x': cX, 'o': cO } } getAttacksLine( cellX, cellY, subFig, dx, dy ){ //      var C = new checkLine; C.getAttacks( cellX, cellY, subFig, dx, dy ); return this.filterAttacks( C ) //   }</span></span></code> </pre><br>  Am Ausgang haben wir ein Objekt mit allen Angriffen f√ºr die getestete Zelle <br><br>  M√∂glicherweise haben Sie jedoch eine Filterfunktion bemerkt.  Seine Aufgabe ist es, "vergebliche" Angriffe auszusortieren: <br><br><ul><li>  Mit null Leistung (Sie wissen nie, ob sie in das Array gelangen) </li><li>  Angriffe ohne Platz (Angriffsort &lt;5) </li><li>  Mit Nullpotential. </li></ul><br>  Wenn der Angriff jedoch eine St√§rke von mehr als 5 hat, √ºberspringt der Filter diese.  Der Bot muss solche Angriffe sehen, ihre √úberpr√ºfung f√ºhrt am Ende des Spiels zu Pfosten. <br><br><pre> <code class="javascript hljs">filterAttacks( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( attackLine.attackplace &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) attackLine.Attacks.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &amp;&amp; a.potential || a.capability &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) res.push( a ) }) attackLine.Attacks = res; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res }</code> </pre><br><h3>  Haltepunkte </h3><br>  Ja ... nochmal, sorry!  Wir werden also die Situation im Spiel nennen, wenn ein falscher Zug √ºber das Ergebnis des Spiels entscheidet. <br><br>  Zum Beispiel ist ein Angriff [3: 2] ein Haltepunkt.  Wenn der Gegner es nicht blockiert, indem er eine Figur daneben legt, haben wir im n√§chsten Zug bereits einen Angriff [4: 2] auf das Spielfeld - nun, das Ergebnis des Spiels wird entschieden, was auch immer man sagen mag (in den allermeisten F√§llen). <br><br>  Oder ein Angriff [4: 1].  Ein G√§hnen - und das Spiel kann leicht abgeschlossen werden. <br><br><img src="https://habrastorage.org/webt/bd/vc/d0/bdvcd0jzf2wiiqqm9wupccpgmn4.jpeg"><br>  <i>Abbildung 5. Haltepunkt</i> <br><br>  Alles ist klar und verst√§ndlich, und der oben beschriebene Algorithmus kann bereits Haltepunkte ber√ºcksichtigen und rechtzeitig blockieren.  Der Bot freut sich.  Er wird sehen, dass der Gegner in der n√§chsten Runde zum Beispiel einen Angriff [5: 1] ausf√ºhren kann, dessen Gewicht 200 betr√§gt - was bedeutet, dass der listige Nerdy hierher geht. <br><br>  Stellen Sie sich jedoch eine Situation vor, in der einer der Spieler 2 Haltepunkte auf dem Spielfeld erreicht.  Und das l√§sst dem Gegner nat√ºrlich keine Chance, denn  In einem Zug k√∂nnen wir nur einen Haltepunkt blockieren.  Wie kann man unserer KI beibringen, solche Angriffe abzuwehren? <br><br><img src="https://habrastorage.org/webt/bh/qu/79/bhqu79lupldi6d3pshuan0lxcmg.jpeg"><br>  <i>Abbildung 6. 2 Haltepunkte</i> <br><br>  Alles ist einfach, wenn wir eine Zelle analysieren, wenn wir ein Teil darin ersetzen, z√§hlen wir die Anzahl der Haltepunkte, die wir beim n√§chsten Zug erhalten (der Bot schaut auf den Vorw√§rtsschritt, nicht vergessen).  Durch Z√§hlen von 2 Haltepunkten erh√∂hen wir das Zellgewicht um 100. <br><br>  Und jetzt wird der Bot solche Spielsituationen nicht nur verhindern, sondern auch erstellen k√∂nnen, was ihn jetzt zu einem gewaltigeren Gegner macht. <br><br><h3>  Wie man versteht, dass ein Angriff ein Haltepunkt ist </h3><br>  Beginnen wir mit dem Offensichtlichen: Jeder Angriff mit einer Potenz von 4 ist ein Haltepunkt.  Nur ein verpasster Zug gibt uns die M√∂glichkeit, das Spiel zu beenden, d. H.  5 St√ºcke hintereinander legen. <br><br>  Wenn das Angriffspotential 2 betr√§gt, werden wir 1 Runde mehr ausgeben, um einen solchen Angriff zu blockieren, was bedeutet, dass es einen Haltepunkt mit einer Potenz von 3 gibt. Es gibt jedoch nur einen solchen Haltepunkt - dies ist ein Angriff [3: 2]. <br><br>  Und noch schwieriger - <b>"zerrissene Angriffe"</b> . <br>  Wir werden nur Angriffe mit einer leeren Zelle in der Mitte betrachten - nicht mehr.  Dies liegt daran, dass Sie mindestens zwei Z√ºge ausf√ºhren m√ºssen, um den Angriff mit zwei leeren Zellen in der Mitte abzuschlie√üen - dies ist eindeutig kein Haltepunkt. <br><br>  Wie wir uns erinnern, betrachten wir zerrissene Angriffe als mehrere konventionelle: einen Zentralangriff und Seitenangriffe.  Der zentrale Angriff geh√∂rt zur gescannten Zelle, der Seitenteiler hat mehr als 1 - dies wurde oben beschrieben. <br><br>  Algorithmus zum Finden eines Haltepunkts (einfacher, siehe unten): <br><br><ol><li>  Wir f√ºhren die variable <b>Punktzahl ein</b> </li><li>  Wir nehmen den Zentralangriff, wir betrachten die Macht </li><li>  Wir nehmen eine der Seiten, wenn der Teiler nicht mehr als 2x betr√§gt. </li><li>  <b>Punktzahl</b> - die Summe der St√§rke der Zentral- und Seitenangriffe </li><li>  Wenn das Potenzial der Zentral- und Seitenangriffe 2 betr√§gt, m√ºssen Sie eine weitere Runde verbringen, um einen solchen Angriff zu blockieren.  Daher wird die Punktzahl um 1 erh√∂ht </li><li>  Wenn <b>Punktzahl</b> &gt; = 4 ist, ist dies ein Haltepunkt <br>  In der Tat k√∂nnten Haltepunkte einfach aufgez√§hlt werden, es gibt nicht viele von ihnen, aber ich habe dies nicht sofort verstanden. </li></ol><br><pre> <code class="javascript hljs">isBreakPoint( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attackLine || ! attackLine.length ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> centAtk; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">1</span></span> ) centAtk = a; }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.potential == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> score = centAtk.capability; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">//side attack if( centAtk.potential == 2 &amp;&amp; a.potential == 2 ) score++; if( score + a.capability &gt;= 4 ){ res = true; return; } } }) return res; }</span></span></code> </pre><br><h3>  Ja, wir werden endlich alles zusammenbringen </h3><br>  Die Haupth√∂lle dahinter ist oben beschrieben.  Es ist Zeit, etwas daraus zu formen.  Funktion <b>countWeight (x, y)</b> - nimmt die Koordinaten der Zelle als Eingabe und gibt ihr Gewicht zur√ºck.  Was ist unter ihrer Kapuze? <br><br>  Zuerst erhalten wir eine Reihe aller Angriffe, zu denen die Zelle geh√∂rt.  ( <b>getAllAttacks (x, y)</b> ).  Wir gehen alle Zeilen durch und z√§hlen die Anzahl der Haltepunkte.  Wenn es 2 Haltepunkte gibt, erinnern wir uns, dass eine solche Situation das Ergebnis des Spiels bestimmen und das Zellgewicht um 100 erh√∂hen kann. <br>  Alle Haltepunkte m√ºssen jedoch einem Spieler geh√∂ren, daher musste ich eine Pr√ºfung in zwei Schritten durchf√ºhren: zuerst Kreuze, dann Nullen. <br><br>  Da ich in der Reihe der Angriffsgewichte ( <b>ATTACK_WEIGHTS []</b> ) keine Angriffe mit einer Potenz von 6 oder mehr <b>bereitgestellt habe</b> , musste ich sie durch Angriffe mit einer Potenz von 5 ersetzen. Es macht keinen Unterschied - sie alle f√ºhren zum Ende des Spiels. <br><br>  Nun, wir fassen die Angriffsgewichte zusammen - das ist alles. <br><br>  Ein weiterer kleiner Punkt: Damit der Bot am Ende des Spiels nicht dumm ist, wenn er bereits einen Angriff mit einer Potenz von 4 aufgebaut hat und √ºber den aktuellen Zug nachdenkt, muss das Gewicht der Zelle deutlich erh√∂ht werden, um einen solchen Angriff abzuschlie√üen.  Ohne dies kann sich die KI einfach gegen die ‚Äûgef√§hrlichen‚Äú Angriffe des Gegners verteidigen, obwohl das Spiel gewonnen zu sein scheint.  Der letzte Schritt ist wichtig. <br><br><pre> <code class="javascript hljs">countWeight( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attacks = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getAttacks( x, y ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attacks ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.x, <span class="hljs-string"><span class="hljs-string">'√ó'</span></span> ); sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.o, <span class="hljs-string"><span class="hljs-string">'‚óã'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> atks, curFig </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weight = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> breakPoints = <span class="hljs-number"><span class="hljs-number">0</span></span>; [ <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"45"</span></span>, <span class="hljs-string"><span class="hljs-string">"90"</span></span>, <span class="hljs-string"><span class="hljs-string">"135"</span></span> ].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> p </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isBreakPoint( atks[p] ) ){ debug( <span class="hljs-string"><span class="hljs-string">"Break point"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ++breakPoints == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; debug( <span class="hljs-string"><span class="hljs-string">"Good cell"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } atks[p].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ) a.capability = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability == <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; curFig == Model.whoPlays.char ) weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; weight += a.getWeight(); }); }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weight } }</code> </pre><br>  Wenn wir diese Funktion f√ºr eine bestimmte Zelle aufrufen, erhalten wir ihr Gewicht.  Wir f√ºhren diesen Vorgang f√ºr alle Zellen durch und w√§hlen die besten (mit dem h√∂chsten Gewicht) aus.  Da und los) <br><br>  Den Rest des Codes finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a> .  Es gibt bereits viel Material, und seine Pr√§sentation l√§sst, wie ich nicht versucht habe, zu w√ºnschen √ºbrig.  Aber wenn Sie bis zu diesem Punkt lesen k√∂nnten, lieber Leser, dann bin ich Ihnen dankbar. <br><br><h3>      </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komm runter! </font><font style="vertical-align: inherit;">Ja, du kannst ihn schlagen, aber das zu tun ist f√ºr mich pers√∂nlich ein wenig problematisch. </font><font style="vertical-align: inherit;">Vielleicht bin ich einfach nicht vorsichtig genug. </font><font style="vertical-align: inherit;">Versuche auch deine St√§rke. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich wei√ü, dass es einfacher ist, aber ich wei√ü nicht wie. </font><font style="vertical-align: inherit;">Ich w√ºrde gerne Leuten zuh√∂ren, die andere Implementierungen eines solchen Bots kennen oder anschauen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich wei√ü, was besser sein kann. </font><font style="vertical-align: inherit;">Ja ... Sie k√∂nnen bekannte Algorithmen wie Minimax verwenden, aber daf√ºr ben√∂tigen Sie eine Wissensbasis auf dem Gebiet der Spieltheorie, mit der ich mich leider nicht r√ºhmen kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Zukunft plane ich, die Breakpoint-Analyse einige Schritte weiter hinzuzuf√ºgen, um den Bot zu einem noch ernsthafteren Gegner zu machen. </font><font style="vertical-align: inherit;">Jetzt habe ich jedoch keine klare Vorstellung von der Umsetzung; </font><font style="vertical-align: inherit;">Ich habe gerade die bevorstehende Sitzung und ein unvollst√§ndiges Diplom - was mich traurig macht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank, wenn Sie bis zum Ende lesen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430708/">https://habr.com/ru/post/de430708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430694/index.html">Eine kurze Anleitung zum Erlernen von C ++: Was, wann und worauf soll erstellt werden?</a></li>
<li><a href="../de430700/index.html">Ein einheitliches System zur Aufzeichnung von Online-Filmansichten wird in Russland funktionieren</a></li>
<li><a href="../de430702/index.html">Sehr seltsames Training</a></li>
<li><a href="../de430704/index.html">Wie Technologien f√ºr k√ºnstliche Intelligenz das Wachstum von Aviasales f√∂rdern: Sieben Beispiele</a></li>
<li><a href="../de430706/index.html">Neue Evolutionstheorie</a></li>
<li><a href="../de430710/index.html">Was tun, wenn der Schwarze Freitag morgen ist und Ihre Server nicht bereit sind?</a></li>
<li><a href="../de430712/index.html">NeurIPS: Wie man die beste ML-Konferenz erobert</a></li>
<li><a href="../de430714/index.html">VMware kauft Heptio - was bedeutet das f√ºr Kubernetes?</a></li>
<li><a href="../de430718/index.html">F√ºr welche Objekte lohnt sich die Cloud-Video√ºberwachung?</a></li>
<li><a href="../de430720/index.html">Intel RealSense D435i: kleines Update und kurzer historischer Exkurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>