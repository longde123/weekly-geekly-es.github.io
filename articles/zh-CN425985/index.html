<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏜️ 💏 👣 GO上的自定义代码执行 🔪 🅾️ 🔆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这实际上与智能合约有关。 
 但是，如果您不太了解智能合约是什么，并且通常与加密货币相去甚远，那么什么是数据库中的存储过程，您就可以完全想象。 用户创建代码段，然后在我们的服务器上工作。 用户可以方便地编写和发布它们，并且我们可以安全地执行它们。 

 不幸的是，我们还没有开发安全性，所以现在我将不...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GO上的自定义代码执行</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425985/"><h2> 这实际上与智能合约有关。 </h2><br> 但是，如果您不太了解智能合约是什么，并且通常与加密货币相去甚远，那么什么是数据库中的存储过程，您就可以完全想象。 用户创建代码段，然后在我们的服务器上工作。 用户可以方便地编写和发布它们，并且我们可以安全地执行它们。 <br><a name="habracut"></a><br> 不幸的是，我们还没有开发安全性，所以现在我将不对其进行描述，但是我会给出一些提示。 <br><br> 我们还在Go上编写代码，它的运行时施加了一些非常具体的限制，主要的限制是，我们基本上不能链接到不在旅途中编写的另一个项目，这将在我们每次执行第三方代码时停止运行。 总的来说，我们可以选择使用某种解释器，为此我们发现了一个完全健全的Lua和一个完全健全的WASM，但是我不希望将客户添加到Lua中，但是有了WASM，现在问题多于收益，它处于草拟状态，它每月更新一次，因此我们将等到规范确定下来。 我们将其用作第二个引擎。 <br><br> 由于与自己的良心进行了长时间的战斗，因此决定在GO上编写智能合约。 事实是，如果构建用于执行已编译的GO代码的体系结构，则出于安全性考虑，您将不得不将该执行转移到一个单独的进程中，以确保安全性，并且转移到一个单独的进程上会降低IPC的性能，尽管在将来，当我们了解可执行文件的数量时代码，选择这种解决方案甚至让人感到愉快。 事实是，它具有可伸缩性，尽管它会增加每个呼叫的延迟。 我们可以引发许多远程运行时。 <br><br> 有关所做决定的更多信息，以便使之清楚。 每个智能合约由两部分组成，一部分是类代码，第二部分是对象数据，因此，在相同的代码上，一旦我们发布了代码，就可以创建许多行为基本相同但设置不同的合约，并且状态不同。 如果我们进一步讨论，那么这已经是关于区块链的问题，而不是这个故事的主题。 <br><br><h2> 因此，我们执行GO </h2><br> 我们决定使用插件机制，它不仅准备好而且很好。 他做了以下工作，我们以一种特殊的方式将一个插件编译到共享库中，然后加载它，在其中找到符号并在其中传递执行。 但是要注意的是，GO有一个运行时，这几乎是一兆字节的代码，并且默认情况下，该运行时也将进入该库，并且我们到处都有一个raznipipenny运行时。 但是现在我们决定去争取它，确保将来可以击败它。 <br><br> 构建库时，一切都很简单，您可以使用键-buildmode = plugin进行构建，并获取.so文件，然后将其打开。 <br><br><pre><code class="go hljs">p, err := plugin.Open(path)</code> </pre> <br> 寻找您感兴趣的角色： <br><br><pre> <code class="go hljs">symbol, err := p.Lookup(Method)</code> </pre> <br> 现在，根据变量是函数还是函数，您可以调用它或将其用作变量。 <br><br> 在此机制的底层是一个简单的dlopen（3），我们加载该库，检查它是否是一个插件并对其进行包装，在创建包装器时，所有导出的字符都包装在接口{}中并存储。 如果它是一个函数，则必须将其简化为正确的函数类型，并简单地调用（如果是变量），然后像变量一样工作。 <br><br> 要记住的主要事情是，如果符号是变量，则它在整个过程中都是全局的，您不能盲目地使用它。 <br><br> 如果已在插件中声明了类型，则此类型在单独的包中有意义，以便主进程可以使用它，例如，将参数作为参数传递给插件的功能。 这是可选的，您不能蒸煮并使用反射。 <br><br> 我们的合同是相应“类”的对象，在开始时，该对象的实例存储在我们的导出变量中，因此我们可以创建另一个相同的变量： <br><br><pre> <code class="go hljs">export, err := p.Lookup(<span class="hljs-string"><span class="hljs-string">"EXPORT"</span></span>) obj := reflect.New(reflect.ValueOf(export).Elem().Type()).Interface()</code> </pre> <br> 并且已经在正确类型的此局部变量内，反序列化对象的状态。 还原对象后，我们可以在其上调用方法。 之后，对象被序列化并添加回存储中，我们为合同中的方法加油打气。 <br><br> 如果您对方法感兴趣，但又懒于阅读文档，则： <br><br><pre> <code class="go hljs">method := reflect.ValueOf(obj).MethodByName(Method) res:= method.Call(in)</code> </pre> <br> 在中间，您仍然需要用包含正确参数类型的空接口填充in数组，如果您感兴趣的话，自己看看它是如何完成的，源是开放的，尽管要在<a href="">历史上</a>找到这个位置很困难。 <br><br> 总的来说，一切对我们都有效，您可以使用类之类的代码编写代码，将其放在区块链上，再次在区块链上创建此类合同，然后对其进行方法调用，并将合同的新状态写回到区块链上。 太好了！ 如何使用现有代码创建新合同？ 很简单，我们有构造函数返回一个新创建的对象，即新合同。 到目前为止，一切都通过反射进行，用户必须编写： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> EXPORT ContractType</code> </pre> <br> 这样我们就知道什么符号代表合同，并实际将其用作模板。 <br><br> 我们真的不喜欢它。 而且我们努力。 <br><br><h2> 解析中 </h2><br> 首先，用户不应写任何多余的东西，其次，我们认为合同与合同之间的交互应该简单，并且在不提高区块链的情况下进行测试，区块链既缓慢又困难。 <br><br> 因此，我们决定将合同包装在包装器中，该包装器是在合同和包装器模板的基础上生成的，原则上是一种可以理解的解决方案。 首先，包装器为我们创建了一个导出对象，其次，当用户编写合同时，包装器将替换用于收集合同的库，将基础库与内部的Mokas一起使用，并在发布合同时，将其替换为可与区块链本身一起使用的战斗库。 。 <br><br> 首先，您需要分析代码并了解我们通常所拥有的，找到从BaseContract继承的结构，以便围绕它生成包装。 <br><br> 这非常简单，我们使用[]字节中的代码读取文件，尽管解析器本身可以读取文件，但最好将所有AST元素都引用的文本放在某处，它们引用文件中的字节数，以后我们希望接收就其结构代码而言，我们只是采取类似的方法。 <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pf *ParsedFile)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">codeOfNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n ast.Node)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(pf.code[n.Pos()<span class="hljs-number"><span class="hljs-number">-1</span></span> : n.End()<span class="hljs-number"><span class="hljs-number">-1</span></span>]) }</code> </pre> <br> 实际上，我们解析文件并获取将要从中爬网文件的最高AST节点。 <br><br><pre> <code class="go hljs">fileSet = token.NewFileSet() node, err := parser.ParseFile(fileSet, name, code, parser.ParseComments)</code> </pre> <br> 接下来，我们从顶部节点开始遍历代码，并在单独的结构中收集所有有趣的内容。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, decl := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> node.Decls { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> d := decl.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ast.GenDecl: … <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ast.FuncDecl: … } }</code> </pre> <br>  Decls，它已经被解析成一个数组，一个文件中定义的所有内容的列表，但是它是一个Decl接口的数组，没有描述其中的内容，因此每个元素都需要转换为特定的类型，此处语言的作者脱离了使用接口的想法， go / ast中的接口是一个基类。 <br><br> 我们对GenDecl和FuncDecl类型的节点感兴趣。  GenDecl是变量或类型的定义，您需要检查内部类型的确切含义，然后再次将其强制转换为可以使用的TypeDecl类型。  FuncDecl更简单-它是一个函数，如果已填充Recv字段，则这是相应结构的方法。 我们将所有这些东西收集在一个方便的存储中，因为这样我们就使用文本/模板，并且它没有太多的表达能力。 <br><br> 我们唯一需要单独记住的是从BaseContract继承的数据类型的名称，我们将围绕它进行讨论。 <br><br><h2> 代码生成 </h2><br> 因此，我们知道合同中的所有类型和函数，我们需要能够根据传入的方法名称和参数化序列数组对对象进行方法调用。 但是毕竟，在代码生成时，我们知道了合同的整个设备，因此我们将合同文件旁边的另一个文件放在具有相同包名的文件旁边，然后将所有必需的导入内容推送到该文件中，这些类型已经在主文件中定义了并且是不必要的。 <br><br> 最主要的是函数的包装。 包装器的名称加上某种前缀，现在很容易找到包装器。 <br><br><pre> <code class="go hljs">symbol, err := p.Lookup(<span class="hljs-string"><span class="hljs-string">"INSMETHOD_"</span></span> + Method) wrapper, ok := symbol.(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ph proxyctx.ProxyHelper, object []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, result []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span><span class="hljs-function">)</span></span></code> </pre><br> 每个包装器都有相同的签名，因此，当我们从主程序调用它时，我们不需要额外的反射，唯一的事情是函数包装器与方法包装器不同，它们不接收也不返回对象的状态。 <br><br> 包装纸里面有什么？ <br><br> 我们创建一个与函数的参数相对应的空变量数组，将其放入接口数组类型的变量中，然后将参数反序列化到其中，如果我们是一个方法，我们还需要序列化对象的状态，通常是这样的： <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $method := .Methods }} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">INSMETHOD_</span></span></span></span>{{ $method.Name }}(ph proxyctx.ProxyHelper, object []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, data []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) ([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, error) { self := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>({{ $.ContractType }}) err := ph.Deserialize(object, self) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ $method.ArgumentsZeroList }} err = ph.Deserialize(data, &amp;args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $method.Results }} {{ $method.Results }} := self.{{ $method.Name }}( {{ $method.Arguments }} ) {{ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> }} self.{{ $method.Name }}( {{ $method.Arguments }} ) {{ end }} state := []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{} err = ph.Serialize(self, &amp;state) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $i := $method.ErrorInterfaceInRes }} ret{{ $i }} = ph.MakeErrorSerializable(ret{{ $i }}) {{ end }} ret := []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{} err = ph.Serialize([]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} { {{ $method.Results }} }, &amp;ret) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, ret, err } {{ end }}</code> </pre><br> 细心的读者会对什么是代理助手感兴趣？  -这是我们仍然需要的组合对象，但是现在我们使用它的序列化和反序列化功能。 <br><br> 好吧，任何人都会问：“但是这些是您的论点，它们来自何处？” 这也是一个可以理解的答案，是的，文本/模板没有来自天空的星星，这就是为什么我们在代码中而不是模板中计算这些行的原因。 <br><br>  method.ArgumentsZeroList包含类似 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arg0 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> Var arg1 <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = “” Var arg2 ackwardType = ackwardType{} Args := []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{&amp;arg0, &amp;arg1, &amp;arg2}</code> </pre> <br> 并且参数相应地包含“ arg0，arg1，arg2”。 <br><br> 因此，我们可以使用任何签名调用任何我们想要的东西。 <br><br> 但是我们无法序列化任何答案，事实是序列化器可以通过反射工作，并且不能访问结构的未导出字段，这就是为什么我们有一个特殊的代理帮助器方法，该方法使用错误接口对象并从中创建基础类型的对象。错误，它与通常的错误不同，因为错误文本位于导出的字段中，并且尽管有一些损失，我们也可以对其进行序列化。 <br><br> 但是，如果我们使用代码生成的灭菌器，那么我们甚至都不需要它，因为它是在同一包中编译的，因此我们可以访问未导出的字段。 <br><br><h2> 但是，如果我们想从合同中调用合同呢？ </h2><br> 如果您认为从合同中调用合同很容易，那么您就不会理解问题的严重性。 事实是，另一个合同的有效性必须通过共识确认，并且此调用的事实必须在区块链上签名，通常，仅凭另一个合同进行编译并调用其方法是行不通的，尽管我真的很想这样做。 但是我们是程序员的朋友，所以我们应该给他们机会直接做所有事情，并将所有技巧隐藏在系统的内部。 因此，合同的开发就像是直接调用一样，并且合同之间是透明的相互拉动，但是当我们收集要发布的合同时，我们会滑动一个代理而不是另一个合同，后者只知道其地址并要求有关该合同的签名。 <br><br> 如何组织这一切？  -我们必须将其他合同存储在一个特殊的目录中，我们的生成器将能够识别该目录并为导入的每个合同创建代理。 <br><br> 也就是说，如果我们遇到了： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> “ContractsDir/ContractAddress<span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br> 我们将其写入进口合同清单。 <br><br> 顺便说一句，您不需要知道合同的源代码，只需知道我们已经编译的描述，因此，如果我们在某个地方发布这样的描述，并且所有调用都经过主系统，那么我们就不在乎另一个合同是用该语言编写的，如果可以在其中调用方法，则可以在Go上为其编写存根，该存根看起来像是带有可直接调用的合同的程序包。 拿破仑的计划，让我们开始吧。 <br><br> 原则上，我们已经有了具有以下签名的代理帮助器方法： <br><br><pre> <code class="go hljs">RouteCall(ref Address, method <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) ([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, error)</code> </pre> <br> 可以直接从合同中调用此方法，它调用远程合同，返回需要解析的序列化响应并返回到合同。 <br><br> 但是对于用户来说，一切都必须看起来像： <br><br><pre> <code class="go hljs">ret := contractPackage.GetObject(Address).Method(arg1,arg2, …)</code> </pre> <br> 让我们开始吧，首先，在代理中，您需要列出合同方法签名中使用的所有类型，但是我们记得，对于每个AST节点，我们都可以采用其文本表示形式，现在该机制的时代到了。 <br><br> 接下来，我们需要创建一种合同，原则上，他已经知道他的班级，只需要一个地址即可。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> {{ .ContractType }} <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Reference Address }</code> </pre> <br> 接下来，我们需要以某种方式实现GetObject函数，该函数在区块链上的地址处将返回一个代理实例，该代理实例知道如何使用此合同，并且对于用户而言，它看起来像一个合同实例。 <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref Address)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *{{ .ContractType }})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;{{ .ContractType }}{Reference: ref} }</code> </pre> <br> 有趣的是，用户调试模式下的GetObject方法直接是BaseContract结构方法，但是没有什么可以阻止我们观察SLA来做对我们方便的事情。 现在，我们可以创建一个代理合同，该合同由我们控制。 实际创建方法还有待解决。 <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $method := .MethodsProxies }} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *{{ $.ContractType }})</span></span></span></span> {{ $method.Name }}( {{ $method.Arguments }} ) ( {{ $method.ResultsTypes }} ) { {{ $method.InitArgs }} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> argsSerialized []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> err := proxyctx.Current.Serialize(args, &amp;argsSerialized) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } res, err := proxyctx.Current.RouteCall(r.Reference, <span class="hljs-string"><span class="hljs-string">"{{ $method.Name }}"</span></span>, argsSerialized) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } {{ $method.ResultZeroList }} err = proxyctx.Current.Deserialize(res, &amp;resList) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {{ $method.Results }} } {{ end }}</code> </pre> <br> 由于我们很懒，并且正好存储方法的ast.Node，因此这里的参数列表也是如此，因此计算需要大量模板不知道的类型转换，因此所有操作都需要事先准备。 使用函数，一切都会变得更加复杂，这是另一篇文章的主题。 <br><br> 我们拥有的功能是对象构造函数，并且非常着重于如何在系统中实际创建对象，创建的事实已注册在远程执行器上，将对象转移到另一个执行器上，将其检查并实际存储在其中，并且有许多无效的保存方法这方面的知识称为隐窝。 这个想法基本上很简单，其中只存储地址的包装程序，以及将调用序列化并拉动我们的单例的方法结合起来完成其余的工作。 我们无法使用传输的代理帮助程序，因为用户没有将其传递给我们，因此我们不得不将其设置为单例。 <br><br> 另一个技巧-实际上，我们仍然使用调用上下文，该对象存储有关谁，何时，为什么，为什么调用智能合约的信息，用户根据此信息来决定是否完全执行，如果可能的话然后如何。 <br><br> 以前，我们只是简单地传递了上下文，它是BaseContract类型中的一个不可表达的字段，带有一个setter和getter，并且该setter只允许设置该字段一次，因此上下文是在执行合约之前设置的，用户只能读取它。 <br><br> 但这是问题所在，用户仅读取此上下文，如果他对某种系统功能进行了调用，例如对另一个合约的代理调用，则该代理调用不会收到任何上下文，因为没有人将其传递给他。 然后goroutine本地存储进入现场。 我们决定不编写自己的代码，而是使用github.com/tylerb/gls。 <br><br> 它允许您设置和获取当前goroutine的上下文。 因此，如果在合同内部未创建goroutine，则只需在启动合同之前在gls中设置上下文，现在我们为用户提供的不是方法，而是函数。 <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">core</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicCallContext</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gls.Get(<span class="hljs-string"><span class="hljs-string">"ctx"</span></span>).(*core.LogicCallContext) }</code> </pre> <br> 他很乐意使用它，但是例如，我们在RouteCall（）中使用它，以了解当前哪个合同正在调用某人。 <br><br> 原则上，用户可以创建goroutine，但是如果他这样做，则上下文会丢失，因此我们需要对此进行一些操作，例如，如果用户使用go关键字，那么我们必须将此类调用包装在包装器中，上下文会记住并创建goroutine并在其中恢复上下文，但这是另一篇文章的主题。 <br><br><h2> 一起 </h2><br> 我们基本上喜欢GO语言工具链的工作方式，实际上，它是一堆做着一件事情的不同命令，例如，当您进行构建时，这些命令会一起执行。 我们决定做同样的事情，一个团队将合同文件放在一个临时目录中，第二个团队在其旁边放置一个包装器，然后第三次调用，这会为每个导入的合同创建一个代理，第四个团队将其全部编译，第五个将其发布在区块链上。 并且有一个命令以正确的顺序运行它们。 <br><br>  Hooray，我们现在有了从GO启动GO的工具链和运行时。 仍然存在许多问题，例如，您需要以某种方式卸载未使用的代码，需要以某种方式确定其已挂起并重新启动挂起的进程，但是这些任务很清楚如何解决。 <br><br> 是的，当然，我们编写的代码并不伪装成库，不能直接使用，但是阅读工作代码生成示例总是很棒，有时我会错过它。 因此，可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编译器中</a>查看部分代码生成，但可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">executor中</a>查看它的启动方式。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425985/">https://habr.com/ru/post/zh-CN425985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425973/index.html">我们如何构建S3 DataLine存储。 实验，测试和有关河马的一些知识</a></li>
<li><a href="../zh-CN425975/index.html">将单词和短语转换为字谜</a></li>
<li><a href="../zh-CN425977/index.html">Flexbox：这个柔性盒有多大？</a></li>
<li><a href="../zh-CN425981/index.html">LK的新手职业：跨越式发展</a></li>
<li><a href="../zh-CN425983/index.html">飞行安全</a></li>
<li><a href="../zh-CN425989/index.html">在Graveyard Keeper的幕后：如何实现图形效果</a></li>
<li><a href="../zh-CN425991/index.html">我们如何创建托管</a></li>
<li><a href="../zh-CN425993/index.html">如何弥合技术中的性别差距</a></li>
<li><a href="../zh-CN425995/index.html">可视化FHIR-医学IT标准</a></li>
<li><a href="../zh-CN425997/index.html">麻省理工学院的课程“计算机系统安全”。 第11课：Ur / Web编程语言，第1部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>