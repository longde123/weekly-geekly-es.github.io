<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔤 🎖️ ❌ 反应式编程简介 🦇 🕤 😮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="你好 在本文中，我将在欧洲四处奔跑，也就是说，我将告诉您反应式编程的含义，介绍演员，反应式流程，最后，使用反应式流程，我们将认识到鼠标手势，就像在旧的Opera及其精神继承者Vivaldi中一样。 

 目的是介绍反应式编程的基本概念，并表明并非所有事物看上去乍一看都那么复杂和令人恐惧。 


 来...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>反应式编程简介</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/arcadia/blog/432004/"> 你好 在本文中，我将在欧洲四处奔跑，也就是说，我将告诉您反应式编程的含义，介绍演员，反应式流程，最后，使用反应式流程，我们将认识到鼠标手势，就像在旧的Opera及其精神继承者Vivaldi中一样。 <br><br> 目的是介绍反应式编程的基本概念，并表明并非所有事物看上去乍一看都那么复杂和令人恐惧。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c6/858/157/0c68581574002383d90367c3e6b996c9.jpg" alt="图片"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a></i> <br><a name="habracut"></a><br><h2> 什么是反应式编程？ </h2><br> 为了回答这个问题，我们转到该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">站点</a> 。 它有一幅美丽的图画，显示了反应性应用程序必须满足的四个主要标准。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e5/092/390/6e5092390fa27e7843b59d57da94b8b3.svg" alt="图片"><br><br> 该应用程序应该快速，容错并且扩展性好。 <br> 看起来“我们对所有人都有好有坏”，对吗？ <br><br> 这些词是什么意思： <br><br><ol><li> <b>反应性</b> <br><br> 该应用程序应在半秒钟内为用户提供结果。 这还包括快速失败的原理-也就是说，当出现问题时，最好向用户返回一条错误消息，例如“对不起，有问题。 请稍后重试，以免天气在海边等待。 如果操作很长，我们会向用户显示进度条。 如果时间太长，“您的请求将在2042年3月18日临时得到满足。 我们将通过邮件向您发送通知。” </li><li>  <b>可伸缩性</b>是在负载下提供响应能力的一种方法。 想象一下相对成功的服务的生命周期： <br><ol><li> 启动-请求流很小，服务在具有一个核心的虚拟机上运行。 </li><li> 请求流增加-将内核添加到虚拟机，并在多个线程中处理请求。 </li><li> 更大的负载-我们连接了批处理-对数据库和硬盘驱动器的请求进行了分组。 </li><li> 更大的负载-您需要增加服务器并在集群中提供工作。 <br> 理想情况下，系统本身应根据负载扩大或缩小。 </li></ol></li><li>  <b>容错能力</b> <br><br> 我们接受我们生活在一个不完美的世界中，一切都会发生。 万一我们的系统出现问题，我们必须提供错误处理和恢复方法 </li><li> 最后，我们受邀使用其系统基于<b>消息驱动的</b>消息传递的系统来实现所有这些目标 </li></ol><br> 在继续之前，我想详细介绍事件驱动系统与消息驱动系统的不同之处。 <br><br>  <b>事件驱动：</b> <br><br><ul><li> 事件-系统报告已达到特定状态。 </li><li> 活动的订阅者可能很多。 </li><li> 事件链通常很短，事件处理程序（在物理上和在代码上）都接近源。 </li><li> 事件源及其处理程序通常具有相同的状态（从物理上讲，它们使用同一块RAM进行信息交换）。 </li></ul><br>  <b>与事件驱动相反，在消息驱动系统中：</b> <br><br><ul><li> 每封邮件只有一个收件人。 </li><li> 消息是不可变的：您无法更改接收到的消息中的任何内容，以便发件人知道并可以读取信息。 </li><li> 系统元素响应（或不响应）接收消息，并且可以将消息发送到系统的其他元素。 </li></ul><br> 所有这些为我们提供了 <br><br><h1> 演员模型 </h1><br> 发展的里程碑： <br><br><ul><li> 在1973年的科学论文中首次提到了参与者-卡尔·休伊特（Carl Hewitt），彼得·毕晓普（Peter Bishop）和理查德·史蒂格（Richard Steiger），“人工智能的通用模块化ACTOR形式主义”， </li><li>  1986年-Erlang出现。  Ericson需要一种用于电信设备的语言，该语言将提供容错能力和无错传播。 在本文的上下文中，其主要功能是： <br><br><ul><li> 一切都是一个过程 </li><li> 消息是唯一的通信方式（Erlang是一种功能语言，并且其中的消息不可更改）。 </li></ul></li><li>  .. </li><li>  2004年-Scala语言的第一个版本。 其特点： <ul><li> 由JVM驱动， </li><li> 功能性 </li><li> 对于多线程，已选择参与者模型。 </li></ul><br></li><li>  2009年-演员的实施分配在一个单独的图书馆中-Akka </li><li>  2014年-Akka.net-已移植到.Net。 </li></ul><br><h1> 演员可以做什么？ </h1><br> 角色是相同的对象，但是： <br><br><ul><li> 与普通对象不同，演员无法调用彼此的方法。 </li><li> 参与者<b>只能通过不变的消息</b>来传递信息。 </li><li> 收到消息后，演员可以 <br><ul><li> 创建新的参与者（他们将在层次结构中处于较低的位置）， </li><li> 发送消息给其他演员， </li><li> 在层次结构和您自己中停止下面的参与者。 </li></ul></li></ul><br> 让我们来看一个例子。 <br><br><img src="https://habrastorage.org/webt/ql/wj/cj/qlwjcjyygaw5s7iub_mshc1rbry.jpeg" alt="图片"><br><br> 演员A要向演员B发送消息。他所拥有的只是ActorRef（某个地址）。 演员B可以在任何地方。 <br>  Actor A通过系统（ActorSystem）发送字母B。 系统将字母放入演员B的信箱中，并“唤醒”演员B。演员B从信箱中取出这封信并做某事。 <br><br> 与在另一个对象上调用方法相比，它看起来不必要地复杂，但是如果您假设参与者是受过训练以对某些刺激做出反应的人，那么参与者的模型就非常适合现实世界。 <br><br> 想象一下父亲和儿子： <br><br><img src="https://habrastorage.org/webt/gk/o9/s5/gko9s5syabkkpdkg0_v_aimwwis.jpeg"><br><br> 父亲给儿子SMSku发送“在房间里打扫房间”，并继续做自己的事情。 儿子读了SMSku并开始清洁。 同时，父亲在玩扑克。 儿子完成清洁并发送短信“完成”。 看起来很简单，对吧？ <br><br> 现在假设父亲和儿子不是演员，而是可以互相借鉴的普通物品。 父亲拉着儿子采取“打扫房间”的方法，紧随其后，直到儿子完成打扫并将控制权移交给父亲。 父亲此时不能玩扑克。 在这种情况下，演员模型变得越来越有吸引力。 <br><br> 现在让我们继续 <br><br><h1>  Akka.NET </h1><br> 下面编写的所有内容对于JVM的原始Akka都是正确的，但是对我而言，C＃比Java更紧密，因此我将以Akka.NET为例。 <br><br><h3> 那么Akka有什么好处呢？ </h3><br><ul><li> 通过消息传递的多线程。 您再也不必为共享内存的经典多线程所遭受的各种锁，信号灯，互斥锁和其他魅力所困扰。 </li><li> 系统及其组件之间的透明通信。 无需担心复杂的网络代码-系统本身将找到消息的目的地并保证消息的传递（您可以在此插入有关UDP vs TCP的笑话）。 </li><li> 可以自动按比例放大或缩小的灵活体系结构。 例如，在负载下，系统可以增加其他群集节点并平均分配负载。 </li></ul><br> 但是扩展的主题非常广泛，值得单独发表。 因此，我将仅详细介绍该功能，该功能将在所有项目中有用： <br><br><h2> 错误处理 </h2><br> 角色具有层次结构-可以将其表示为树。 每个演员都有父母，可以有“孩子”。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99e/57e/919/99e57e919cbea8e6761b75537c3f507a.png" alt="图片"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Akka.NET文档</a>版权所有2013-2018 Akka.NET项目</i> <br><br> 您可以为每个演员设置监督策略-如果“孩子”出了问题该怎么办。 例如，“击败”遇到问题的演员，然后创建一个相同类型的新演员并将其委托给他。 <br><br> 例如，我在Akka.net CRUD上创建了一个应用程序，其中在角色上实现了“业务逻辑”层。 该项目的目的是确定参与者是否应在不可扩展的系统中使用-他们会改善生活还是增加痛苦。 <br><br>  Akka的内置错误处理如何帮助您： <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1f/oz/ou/1fozoulh0ufwzuyufofz4n8pvbi.gif"><br></div></div><br><ol><li> 一切都很好，应用程序正常工作， </li><li> 仓库发生了什么事，现在结果只占5分之一 </li><li> 我将监督策略设置为“每秒尝试10次”， </li><li> 该应用程序又可以工作了（尽管速度较慢），而且我有时间弄清楚是怎么回事。 </li></ol><br> 有一种诱惑说：“来吧，我自己写这样的错误处理程序，为什么有些演员必须犯错？” 坦白地说，但前提是失败要点很少。 <br><br> 和一些代码。 这就是IoC容器中的actor系统初始化的样子： <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Container</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { system = ActorSystem.Create(<span class="hljs-string"><span class="hljs-string">"MySystem"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> echo = system.ActorOf&lt;EchoActor&gt;(<span class="hljs-string"><span class="hljs-string">"Echo"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//stop initialization if something is wrong with actor system var alive = echo.Ask&lt;bool&gt;(true, TimeSpan.FromMilliseconds(100)).Result; container = new WindsorContainer(); //search for dependencies //register controllers //register ActorSystem propsResolver = new WindsorDependencyResolver(container, (ActorSystem)system); system.AddDependencyResolver(propsResolver); actorSystemWrapper = new ActorSystemWrapper(system, propsResolver); container.Register(Component.For&lt;IActorRefFactory&gt;().Instance(actorSystemWrapper)); container.Register(Component.For&lt;IDependencyResolver&gt;().Instance(propsResolver)); }</span></span></code> </pre> <br>  EchoActor是向发送方返回值的最简单的actor： <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EchoActor</span></span> : <span class="hljs-title"><span class="hljs-title">ReceiveActor</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EchoActor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Receive&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(flag =&gt; { Sender.Tell(flag); }); } }</code> </pre><br> 要将参与者与“常规”代码连接，请使用Ask命令： <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;ActionResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Index</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ViewBag.Type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Model); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> CrudActorRef.Ask&lt;IEnumerable&lt;Model&gt;&gt;(DataMessage.GetAll&lt;Model&gt;(), maxDelay); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(res); }</code> </pre> <br><h3> 合计 </h3><br> 我可以和演员们窃笑，我可以说： <br><br><ul><li> 如果需要可伸缩性，请查看它们。 </li><li> 对于复杂的业务逻辑，最好不要使用它们，因为 <ul><li> 奇怪的依赖注入。 要使用必要的依赖关系初始化角色，必须首先创建一个Props对象，然后将其提供给ActorSystem以创建所需类型的角色。 要使用IoC容器（例如Castle Windsor或Autofac）创建Props，有现成的包装器-DependencyResolvers。 但是我面对这样一个事实，即IoC容器试图控制依赖项的生存期，不久后系统悄然崩溃。 <br><br>  *也许，不是将依赖项注入到对象中，而是应将此依赖项作为子actor放置。 </li><li> 打字问题。  ActorRef对其所引用的actor类型一无所知。 也就是说，在编译时，不知道参与者是否可以处理这种类型的消息。 </li></ul></li></ul><br><h1> 第2部分：喷射流 </h1><br> 现在，让我们继续讨论一个更流行和有用的主题-射流。 如果您在工作过程中无法与演员见面，那么Rx流肯定会在前端和后端派上用场。 它们几乎以所有现代编程语言实现。 我将提供有关RxJ的示例，因为如今，即使后端程序员有时也必须使用JavaScript进行某些操作。 <br><br><img src="https://habrastorage.org/webt/ru/yn/g9/ruyng9clvfa1gh8bd5ai3lpnc5m.jpeg"><br>  <i>Rx流可用于所有流行的编程语言。</i> <br><br>  <i>由CC BY-NC 4.0许可的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Andre Staltz撰写的</a> “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您缺少的反应式编程简介</a> ”</i> <br><br> 为了解释什么是喷射流，我将从pull和push集合开始。 <br><table><tbody><tr><th></th><th> 单返回值 </th><th> 多个返回值 </th></tr><tr><td> 拉力 <br> 同步的 <br> 互动式 </td><td>  Ť </td><td>  IEnumerable &lt;T&gt; </td></tr><tr><td> 推入 <br> 异步的 <br> 反应性 </td><td> 任务&lt;T&gt; </td><td>  IObservable &lt;T&gt; </td></tr></tbody></table><br> 拉取集合是我们在编程中经常使用的集合。 最引人注目的示例是数组。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br> 它已经有数据，他本人不会更改此数据，但是他可以根据要求提供。 <br><br><pre> <code class="javascript hljs">arr.forEach(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br> 另外，在对数据进行处理之前，您可以进行某种方式的处理。 <br><br><pre> <code class="javascript hljs">arr.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> i+<span class="hljs-number"><span class="hljs-number">1</span></span>).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">I</span></span></span><span class="hljs-function"> =&gt;</span></span> “my number is ”+i).forEach(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br> 现在，让我们假设最初在集合中没有数据，但是它肯定会通知您它们已经出现（推送）。 同时，我们仍然可以对该集合进行必要的转换。 <br><br> 例如： <br><br><pre> <code class="javascript hljs">source.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> i+<span class="hljs-number"><span class="hljs-number">1</span></span>).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">I</span></span></span><span class="hljs-function"> =&gt;</span></span> “my number is ”+i).forEach(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br> 当源中出现诸如1之类的值时，console.log将输出“我的号码为1”。 <br><br> 运作方式： <br><br> 出现一个新实体-主题（或可观察）： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = Rx.Observable.create(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) </span></span>{ observer.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">2</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">3</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(<span class="hljs-number"><span class="hljs-number">4</span></span>); observer.complete(); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); });</code> </pre> <br> 这是一个推送集合，它将发出有关其状态更改的通知。 <br><br> 在这种情况下，数字1、2和3将立即出现在其中，在第二个4中出现，然后集合将“结束”。 这是一种特殊的事件。 <br><br> 第二个实体是观察者。 他可以订阅主题事件，并对接收到的数据进行处理。 例如： <br><br><pre> <code class="javascript hljs">observable.subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x)); observable.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'got value '</span></span> + x), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'something wrong occurred: '</span></span> + err), <span class="hljs-attr"><span class="hljs-attr">complete</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>), }); observable .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'This is '</span></span> + x) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x));</code> </pre> <br> 可以看出，一个主题可以有许多订阅者。 <br><br> 看起来很简单，但尚不清楚为什么有必要这样做。 在使用无功流时，我将给出另外两个需要了解的定义，然后在实践中说明它们如何工作以及在什么情况下发挥其全部潜能。 <br><br><h4> 冷观测 </h4><br><ul><li> 订阅事件时通知事件。 </li><li> 不管订阅时间如何，整个数据流都会再次发送给每个订阅者。 </li><li> 为每个订户复制数据。 </li></ul><br> 这是什么意思：假设公司（主题）决定安排礼物的分发。 每个员工（观察员）上班并收到礼物的副本。 没有人仍然被剥夺。 <br><br><h4> 热观测 </h4><br><ul><li> 他们尝试通知事件，而不考虑订户的存在。 如果在事件发生时没有订阅者，则数据将丢失。 </li></ul><br> 示例：早上，将员工的热饼带到公司。 当它们被带进来时，所有的百灵都会闻到气味，然后把馅饼做成早餐。 但是后来出现的猫头鹰不再有馅饼了。 <br><br><h4> 在什么情况下使用喷射流？ </h4><br> 当有数据流随时间分布时。 例如，用户输入。 或任何服务的日志。 在一个项目中，我看到了一个自制的记录器，该记录器在N秒内收集了事件，然后同时记录了整个文件包。 电池代码占据了该页面。 如果使用Rx流，那么它将更加简单： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6e/b1a/396/b6eb1a3960bd8b422c01b6c0a5dd97f0.png" alt="图片"><br>  <i>“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RxJs参考/可观察的</a> ，根据CC BY 4.0许可的文档</i> 。 <br>  <i>（有很多示例和图片说明了无功流的各种操作的作用）</i> <br><br><pre> <code class="javascript hljs">source.bufferTime(<span class="hljs-number"><span class="hljs-number">2000</span></span>).subsribe(doThings);</code> </pre> <br> 最后，是一个使用示例。 <br><br><h2> 使用Rx流识别鼠标手势 </h2><br> 在旧的Opera或其精神继任者Vivaldi中，有一个使用鼠标手势的浏览器控件。 <br><br><div class="spoiler">  <b class="spoiler_title">Gif-Vivaldi中的鼠标手势</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/xs/ok/eq/xsokeqelkjbtvgrcurbv-wffmog.gif"><br></div></div><br> 也就是说，您需要识别鼠标的上/下，右/左移动及其组合。 它可以在没有Rx流的情况下编写，但是代码将很复杂且难以维护。 <br><br><h4> 这是Rx流的外观： </h4><br> 我将从头开始-我将按原始顺序设置要搜索的数据和格式： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//gestures to look for const gestures = Rx.Observable.from([ { name: "Left", sequence: Rx.Observable.from([{ x: -1, y: 0 }]) }, { name: "Right", sequence: Rx.Observable.from([{ x: 1, y: 0 }]) }, { name: "Up", sequence: Rx.Observable.from([{ x: 0, y: -1 }]) }, { name: "Down", sequence: Rx.Observable.from([{ x: 0, y: 1 }]) }, { name: "Down+Up", sequence: Rx.Observable.from([{ x: 0, y: 1 }, { x: 0, y: -1 }]) }, { name: "Up+Right", sequence: Rx.Observable.from([{ x: 0, y: -1 }, { x: 1, y: 0 }]) } ]);</span></span></code> </pre> <br> 这些是单位向量及其组合。 <br><br> 接下来，您需要将鼠标事件转换为Rx流。 所有Rx库都具有用于将标准事件转换为Observable的内置工具。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mouseMoves = Rx.Observable.fromEvent(canvas, <span class="hljs-string"><span class="hljs-string">'mousemove'</span></span>), mouseDowns = Rx.Observable.fromEvent(canvas, <span class="hljs-string"><span class="hljs-string">'mousedown'</span></span>), mouseUps = Rx.Observable.fromEvent(canvas, <span class="hljs-string"><span class="hljs-string">'mouseup'</span></span>);</code> </pre> <br> 接下来，我将鼠标的坐标按2分组并找到它们的差，得到鼠标的偏移量。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mouseDiffs = mouseMoves .map(getOffset) .pairwise() .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pair</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: pair[<span class="hljs-number"><span class="hljs-number">1</span></span>].x-pair[<span class="hljs-number"><span class="hljs-number">0</span></span>].x, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: pair[<span class="hljs-number"><span class="hljs-number">1</span></span>].y-pair[<span class="hljs-number"><span class="hljs-number">0</span></span>].y } });</code> </pre> <br> 并使用“ mousedown”和“ mouseup”事件对这些运动进行分组。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mouseGestures = mouseDiffs .bufferToggle(mouseDowns, x =&gt; mouseUps) .map(concat);</code> </pre> <br> 连拍功能会切掉太短的运动，并将方向大致对齐的运动分组。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-comment"><span class="hljs-comment">//summarize move in same direction return values.reduce((a, v) =&gt; { if (!a.length) { a.push(v); } else { const last = a[a.length - 1]; const lastAngle = Math.atan2(last.x, last.y); const angle = Math.atan2(vx, vy); const angleDiff = normalizeAngle(angle - lastAngle); const dist = Math.hypot(vx, vy); if (dist &lt; 1) return a;//move is too short – ignore //moving in same direction =&gt; adding vectors if (Math.abs(angleDiff) &lt;= maxAngleDiff) { last.x += vx; last.y += vy; } else { a.push(v); } } return a; }, []); }</span></span></code> </pre> <br> 如果X轴或Y轴上的运动太短，则将其重置为零。 然后从获得的位移坐标中仅保留符号。 因此，获得了我们正在寻找的单位向量。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> normalizedMouseGestures = mouseGestures.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr</span></span></span><span class="hljs-function"> =&gt;</span></span> arr.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dist = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.hypot(vx, vy);<span class="hljs-comment"><span class="hljs-comment">//length of vector vx = Math.abs(vx) &gt; minMove &amp;&amp; Math.abs(vx) * treshold &gt; dist ? vx : 0; vy = Math.abs(vy) &gt; minMove &amp;&amp; Math.abs(vy) * treshold &gt; dist ? vy : 0; return v; }) ).map(arr =&gt; arr .map(v =&gt; { return { x: Math.sign(vx), y: Math.sign(vy) }; }) .filter(v =&gt; Math.hypot(vx, vy) &gt; 0) );</span></span></code> </pre> <br> 结果： <br><br><pre> <code class="javascript hljs">gestures.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">gesture</span></span></span><span class="hljs-function"> =&gt;</span></span> normalizedMouseGestures.mergeMap( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">moves</span></span></span><span class="hljs-function"> =&gt;</span></span> Rx.Observable.from(moves) .sequenceEqual(gesture.sequence, comparer) ).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x).mapTo(gesture.name) ).mergeAll().subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">gestureName</span></span></span><span class="hljs-function"> =&gt;</span></span> actions[gestureName]());</code> </pre> <br> 使用sequenceEqual，您可以将接收到的动作与原始动作进行比较，如果匹配，则执行特定操作。 <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/lp/bx/fe/lpbxfeq_bq-mdfybskn0v7wwen8.gif"><br></div></div><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您可以在这里玩手势</a> <br><br> 请注意，除了手势识别，在HTML画布上还绘制了鼠标的初始移动和标准化移动。 代码的可读性不会因此受到影响。 <br><br> 由此带来的另一个优势是-可以轻松地补充和扩展借助Rx流编写的功能。 <br><br><h2> 总结 </h2><br><ul><li> 带有Rx流的库可用于几乎所有编程语言。 </li><li> 当事件流随时间扩展时（例如，用户输入），应使用Rx流。 </li><li> 使用Rx流编写的功能可以轻松补充和扩展。 </li><li> 我没有发现任何重大缺陷。 </li></ul><br><div class="spoiler">  <b class="spoiler_title">有用的链接</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.introtorx.com</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">getakka.net/articles/intro/what-is-akka.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">reactx.io/rxjs/class/es6/Observable.js~Observable.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">reactx.io/languages.html</a> </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN432004/">https://habr.com/ru/post/zh-CN432004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431992/index.html">生物识别：我们与他们之间的情况如何</a></li>
<li><a href="../zh-CN431994/index.html">讨论托管在GitHub上的项目的免费PVS-Studio许可证</a></li>
<li><a href="../zh-CN431996/index.html">Smart Engines Science Corporate（或我们如何驾车前往ICMV 2018）</a></li>
<li><a href="../zh-CN431998/index.html">认识Yandex.Phone-现在正式</a></li>
<li><a href="../zh-CN432002/index.html">Microsoft正在开发基于Chromium的浏览器，默认情况下将代替Edge发行</a></li>
<li><a href="../zh-CN432006/index.html">我如何进入女性健康这一主题的故事</a></li>
<li><a href="../zh-CN432008/index.html">追逐网络标准</a></li>
<li><a href="../zh-CN432012/index.html">如何测试智能合约</a></li>
<li><a href="../zh-CN432014/index.html">适用于初学者的Kali Linux</a></li>
<li><a href="../zh-CN432016/index.html">音乐和绘画如何教我如何编程</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>