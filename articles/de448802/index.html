<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë©üèª üë®üèø‚Äçü§ù‚Äçüë®üèæ üèª Mit Portalen denken: Portale in Unreal Engine 4 erstellen üö† üç≥ üç∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich Ihnen erkl√§ren, wie Sie Portale in Unreal Engine 4 erstellen. Ich habe keine Quellen gefunden, die ein solches System deta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mit Portalen denken: Portale in Unreal Engine 4 erstellen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448802/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif" alt="Bild"></div><br>  In diesem Artikel werde ich Ihnen erkl√§ren, wie Sie Portale in Unreal Engine 4 erstellen. Ich habe keine Quellen gefunden, die ein solches System detailliert beschreiben (√úberwachung durch Portale und Weitergabe durch diese), daher habe ich beschlossen, meine eigenen zu schreiben. <br><br><h2>  Was ist ein Portal? </h2><br>  Beginnen wir mit Beispielen und Erkl√§rungen, was ein Portal ist.  Der einfachste Weg, die Portale als einen Weg von einem Raum zum anderen zu beschreiben.  In einigen beliebten Spielen wird dieses Konzept f√ºr visuelle Effekte und sogar f√ºr die Spielmechanik verwendet: <br><br><div class="spoiler">  <b class="spoiler_title">Beispiele f√ºr Spielportale (GIF)</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/611/020/f86/611020f86b634e1946a79f86ee8c4024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/7b9/813/77d7b9813811fc5b1748d8d29c7599ad.gif"></div><br>  <i>Vorkammer (2013) und Portal (2007)</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/671/ad1/527671ad1b23838f56c324d350bf2e1e.gif"></div><br>  <i>Beute, 2006</i> </div></div><br>  Das ber√ºhmteste der drei Spiele ist wahrscheinlich Portal, aber ich pers√∂nlich habe Prey immer bewundert und sie wollte sie kopieren.  Einmal habe ich versucht, meine eigene Version in Unreal Engine 4 zu implementieren, aber es gelang mir nicht wirklich, da der Engine die Funktionalit√§t fehlte.  Trotzdem gelang es mir, diese Experimente durchzuf√ºhren: <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Ihr Browser unterst√ºtzt kein HTML5-Video. <source src="http://froyok.fr/vine_archive/videos/1318354931002269696.mp4" type="video/mp4"></video></div></div></div><br>  Erst in neuen Versionen von Unreal Engine gelang es mir jedoch, den gew√ºnschten Effekt zu erzielen: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5lga4ppJiuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Portale - wie funktionieren sie? </h2><br>  Bevor wir mit den Einzelheiten fortfahren, schauen wir uns das allgemeine Bild der Funktionsweise von Portalen an. <br><br>  Tats√§chlich ist ein Portal ein Fenster, das nicht nach drau√üen geht, sondern an einen anderen Ort. Das hei√üt, wir legen lokal einen bestimmten Ansichtspunkt relativ zum Objekt fest und replizieren diesen Ansichtspunkt an einer anderen Stelle.  Mit diesem Prinzip k√∂nnen wir zwei R√§ume verbinden, auch wenn sie sehr weit voneinander entfernt sind.  Das Fenster √§hnelt einer Maske, mit der wir herausfinden k√∂nnen, wo und wann ein anderer Bereich anstelle des urspr√ºnglichen angezeigt werden soll.  Da der Ausgangspunkt der Sichtweise an anderer Stelle wiederholt wird, entsteht die Illusion von Kontinuit√§t. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/d56/84b/6b3d5684bf30d66c8b60d551049f7a9b.png"></div><br>  In diesem Bild befindet sich das Aufnahmeger√§t (SceneCapture in UE4) vor dem Raum, der dem Raum aus der Sicht des Spielers entspricht.  Alles, was nach der Linie sichtbar ist, wird durch das ersetzt, was die Aufnahme sehen kann.  Da sich das Erfassungsger√§t zwischen der T√ºr und anderen Objekten befinden kann, ist es wichtig, die sogenannte ‚ÄûClipping-Ebene‚Äú zu verwenden.  Im Fall des Portals m√∂chten wir, dass die enge Schnittebene die vor dem Portal sichtbaren Objekte maskiert. <br><br>  Zusammenfassend.  Wir brauchen: <br><br><ul><li>  Standort des Spielers </li><li>  Portal-Einstiegspunkt </li><li>  Portalausgangspunkt </li><li>  Clipping-Ger√§t mit Clipping-Ebene </li></ul><br>  Wie implementiere ich das in Unreal Engine? <br><br>  Ich habe mein System auf der Grundlage von zwei Hauptklassen erstellt, die von <b>PlayerController</b> und <b>Character verwaltet werden</b> .  Die <b>Portal-</b> Klasse ist ein echter Portal-Einstiegspunkt, dessen Ansichts- / Austrittspunkt der Zielakteur ist.  Es gibt auch einen <b>Portal-Manager</b> , der vom PlayerController generiert und von Character aktualisiert wird, um jedes Portal auf der Ebene zu verwalten und zu aktualisieren sowie das SceneCapture-Objekt (das allen Portalen gemeinsam ist) zu bearbeiten. <br><br><blockquote>  Beachten Sie, dass das Lernprogramm erwartet, dass Sie √ºber Code auf die Klassen Character und PlayerController zugreifen k√∂nnen.  In meinem Fall hei√üen sie ExedreCharacter und ExedrePlayerController. </blockquote><br><h2>  Erstellen einer Portal Actor Class </h2><br>  Beginnen wir mit dem Akteur des Portals, mit dem die ‚ÄûFenster‚Äú festgelegt werden, durch die wir die Ebene betrachten.  Die Aufgabe des Schauspielers besteht darin, Informationen √ºber den Spieler bereitzustellen, um verschiedene Positionen und Z√ºge zu berechnen.  Er wird auch erkennen, ob der Spieler das Portal √ºberquert, und seine Teleportation. <br><br>  Bevor ich mit einer ausf√ºhrlichen Diskussion des Schauspielers beginne, m√∂chte ich einige Konzepte erl√§utern, die ich zur Verwaltung des Portalsystems erstellt habe: <br><br><ul><li>  Zur bequemen Ablehnung von Berechnungen hat das Portal einen Aktiv-Inaktiv-Status.  Dieser Status wird vom Portal Manager aktualisiert. </li><li>  Das Portal hat Vorder- und R√ºckseite, die durch seine Position und Richtung (Vorw√§rtsvektor) bestimmt werden. </li><li>  Um herauszufinden, ob der Spieler das Portal √ºberquert, speichert er die vorherige Position des Spielers und vergleicht sie mit der aktuellen.  Wenn sich der Spieler im vorherigen Takt vor dem Portal und im aktuellen - hinter ihm - befand, glauben wir, dass der Spieler es √ºberquert hat.  Das umgekehrte Verhalten wird ignoriert. </li><li>  Das Portal verf√ºgt √ºber eine begrenzte Lautst√§rke, um keine Berechnungen und √úberpr√ºfungen durchzuf√ºhren, bis sich der Player in dieser Lautst√§rke befindet.  Beispiel: Ignorieren Sie die Kreuzung, wenn der Player das Portal nicht ber√ºhrt. </li><li>  Der Standort des Spielers wird aus dem Standort der Kamera berechnet, um ein korrektes Verhalten sicherzustellen, wenn der Blickwinkel das Portal √ºberquert, nicht jedoch den K√∂rper des Spielers. </li><li>  Das Portal erh√§lt ein Renderziel, das in jeder Kennzahl einen anderen Blickwinkel anzeigt, falls die Textur beim n√§chsten Mal falsch ist und ersetzt werden muss. </li><li>  Das Portal speichert einen Link zu einem anderen Akteur namens Target, um zu wissen, wo der andere Bereich kontaktiert werden soll. </li></ul><br>  Mit diesen Regeln habe ich eine neue ExedrePortal-Klasse erstellt, die von AActor als Ausgangspunkt geerbt wurde.  Hier ist der Titel: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortal.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API AExedrePortal : public AActor { GENERATED_UCLASS_BODY() protected: virtual void BeginPlay() override; public: virtual void Tick(float DeltaTime) override; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Status of the Portal (being visualized by the player or not) UFUNCTION(BlueprintPure, Category="Exedre|Portal") bool IsActive(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetActive( bool NewActive ); //Render target to use to display the portal UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void ClearRTT(); UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void SetRTT( UTexture* RenderTexture ); UFUNCTION(BlueprintNativeEvent, Category="Exedre|Portal") void ForceTick(); //Target of where the portal is looking UFUNCTION(BlueprintPure, Category="Exedre|Portal") AActor* GetTarget(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetTarget( AActor* NewTarget ); //Helpers UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void TeleportActor( AActor* ActorToTeleport ); protected: UPROPERTY(BlueprintReadOnly) USceneComponent* PortalRootComponent; private: bool bIsActive; AActor* Target; //Used for Tracking movement of a point FVector LastPosition; bool LastInFront; };</span></span></span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, gibt es die meisten der hier beschriebenen Verhaltensweisen.  Nun wollen wir sehen, wie sie im K√∂rper verarbeitet werden (.cpp). <br><br><hr><br>  Der Designer hier bereitet die Stammkomponenten vor.  Ich habe beschlossen, zwei Stammkomponenten zu erstellen, da der Portal-Akteur sowohl grafische Effekte als auch Kollisionen / Erkennung kombiniert.  Daher brauchte ich eine einfache Methode, um festzustellen, wo sich die Fenster- / Portalebene befindet, ohne dass Bluetooth-Funktionen oder andere Tricks erforderlich sind.  PortalRootComponent ist die Basis f√ºr alle Berechnungen im Zusammenhang mit dem Portal. <br><br>  Das Portalstammverzeichnis ist auf dynamisch eingestellt, falls die Blueprint-Klasse es animiert (verwendet beispielsweise eine Open / Close-Animation). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Sets default values AExedrePortal::AExedrePortal(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = true; bIsActive = false; RootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("RootComponent")); RootComponent-&gt;Mobility = EComponentMobility::Static; PortalRootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("PortalRootComponent")); PortalRootComponent-&gt;SetupAttachment( GetRootComponent() ); PortalRootComponent-&gt;SetRelativeLocation( FVector(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;SetRelativeRotation( FRotator(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;Mobility = EComponentMobility::Movable; }</span></span></code> </pre> <br><hr><br>  Es gibt nur Get- und Set-Funktionen und nichts weiter.  Wir werden den Aktivit√§tsstatus von einem anderen Ort aus verwalten. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsActive() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bIsActive; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetActive( <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> NewActive ) { bIsActive = NewActive; }</code> </pre> <br><hr><br>  Blueprint-Ereignisse, ich mache nichts in der C ++ - Klasse. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ClearRTT_Implementation() { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetRTT_Implementation( UTexture* RenderTexture ) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ForceTick_Implementation() { }</code> </pre> <br><hr><br>  Die Funktionen Get und Set f√ºr den Zielakteur.  Auch in diesem Teil gibt es nichts Komplizierteres. <br><br><pre> <code class="cpp hljs">AActor* AExedrePortal::GetTarget() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Target; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetTarget( AActor* NewTarget ) { Target = NewTarget; }</code> </pre> <br><hr><br>  Mit dieser Funktion k√∂nnen wir leicht √ºberpr√ºfen, ob sich ein Punkt vor einer Ebene befindet, und in unserem Fall handelt es sich um ein Portal.  Die Funktion verwendet die FPlane-Struktur der UE4-Engine, um Berechnungen durchzuf√ºhren. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-comment"><span class="hljs-comment">//If &lt; 0 means we are behind the Plane //See : http://api.unrealengine.com/INT/API/Runtime/Core/Math/FPlane/PlaneDot/index.html return ( PortalDot &gt;= 0 ); }</span></span></code> </pre> <br><hr><br>  Diese Funktion pr√ºft, ob der Punkt die Portalebene √ºberschritten hat.  Hier verwenden wir die alte Position, um herauszufinden, wie sich der Punkt verh√§lt.  Diese Funktion ist √ºblich, damit sie mit jedem Schauspieler funktioniert, aber in meinem Fall wird sie nur mit dem Player verwendet. <br><br>  Die Funktion erstellt eine Richtung / ein Segment zwischen dem vorherigen und dem aktuellen Standort und pr√ºft dann, ob sie die Ebene schneiden.  Wenn ja, pr√ºfen wir, ob es sich in die richtige Richtung kreuzt (von vorne nach hinten?). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FVector IntersectionPoint; FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCrossing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsInFront = PortalDot &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsIntersect = FMath::SegmentPlaneIntersection( LastPosition, Point, PortalPlane, IntersectionPoint ); <span class="hljs-comment"><span class="hljs-comment">//Did we intersect the portal since last Location ? //If yes, check the direction : crossing forward means we were in front and now at the back //If we crossed backward, ignore it (similar to Prey 2006) if( IsIntersect &amp;&amp; !IsInFront &amp;&amp; LastInFront ) { IsCrossing = true; } //Store values for Next check LastInFront = IsInFront; LastPosition = Point; return IsCrossing; }</span></span></code> </pre> <br><h2>  Schauspieler teleportieren </h2><br>  Der letzte Teil des Portal-Akteurs, den wir uns ansehen werden, ist die <b>TeleportActor ()</b> -Funktion. <br><br>  Wenn Sie einen Schauspieler von Punkt A nach Punkt B teleportieren, m√ºssen Sie seine Bewegung und Position nachbilden.  Wenn zum Beispiel ein Spieler das Portal betritt, scheint es ihm in Kombination mit geeigneten visuellen Effekten, dass er durch eine gew√∂hnliche T√ºr gegangen ist. <br><br>  Der Schnittpunkt des Portals f√ºhlt sich an, als w√ºrde man sich in einer geraden Linie bewegen, aber in Wirklichkeit passiert etwas v√∂llig anderes.  Beim Verlassen des Portals befindet sich der Spieler m√∂glicherweise in einem ganz anderen Kontext.  Betrachten Sie ein Beispiel aus Portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/185/809/d4f/185809d4fd81675cdd6f1cc871eaf193.gif"></div><br>  Wie Sie sehen k√∂nnen, dreht sich die Kamera beim √úberqueren des Portals relativ zu ihrem Vorw√§rtsvektor (dreht sich).  Dies liegt daran, dass Start- und Endpunkt parallel zu verschiedenen Ebenen liegen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/072/97f/b30/07297fb30171a80c1cc0d831701feb74.jpg"></div><br>  Damit dies funktioniert, m√ºssen wir die Bewegung des Spielers in den relativen Bereich des Portals umwandeln, um sie in den Zielbereich umzuwandeln.  Durch diese Implementierung k√∂nnen wir sicher sein, dass der Spieler nach dem Betreten des Portals und dem Verlassen der anderen Seite korrekt in Bezug auf den Platz ausgerichtet ist.  Dies gilt nicht nur f√ºr die Position und Rotation des Schauspielers, sondern auch f√ºr seine <b>Geschwindigkeit</b> . <br><br><blockquote>  Wenn wir einen Schauspieler ohne √Ñnderungen teleportieren und ihn in eine lokale Rotation umwandeln, kann sich der Schauspieler auf den Kopf stellen.  Dies kann f√ºr Objekte geeignet sein, gilt jedoch nicht f√ºr die Charaktere oder den Spieler selbst.  Sie m√ºssen die Position des Schauspielers √§ndern, wie oben im Beispiel von Portal gezeigt. </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::TeleportActor( AActor* ActorToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ActorToTeleport == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//------------------------------- //Retrieve and save Player Velocity //(from the Movement Component) //------------------------------- FVector SavedVelocity = FVector::ZeroVector; AExedreCharacter* EC = nullptr; if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { EC = Cast&lt;AExedreCharacter&gt;( ActorToTeleport ); SavedVelocity = EC-&gt;GetCharMovementComponent()-&gt;GetCurrentVelocity(); } //------------------------------- //Compute and apply new location //------------------------------- FHitResult HitResult; FVector NewLocation = UTool::ConvertLocationToActorSpace( ActorToTeleport-&gt;GetActorLocation(), this, Target ); ActorToTeleport-&gt;SetActorLocation( NewLocation, false, &amp;HitResult, ETeleportType::TeleportPhysics ); //------------------------------- //Compute and apply new rotation //------------------------------- FRotator NewRotation = UTool::ConvertRotationToActorSpace( ActorToTeleport-&gt;GetActorRotation(), this, Target ); //Apply new rotation ActorToTeleport-&gt;SetActorRotation( NewRotation ); //------------------------------- //If we are teleporting a character we need to //update its controller as well and reapply its velocity //------------------------------- if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { //Update Controller AExedrePlayerController* EPC = EC-&gt;GetPlayerController(); if( EPC != nullptr ) { NewRotation = UTool::ConvertRotationToActorSpace( EPC-&gt;GetControlRotation(), this, Target ); EPC-&gt;SetControlRotation( NewRotation ); } //Reapply Velocity (Need to reorient direction into local space of Portal) { FVector Dots; Dots.X = FVector::DotProduct( SavedVelocity, GetActorForwardVector() ); Dots.Y = FVector::DotProduct( SavedVelocity, GetActorRightVector() ); Dots.Z = FVector::DotProduct( SavedVelocity, GetActorUpVector() ); FVector NewVelocity = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); EC-&gt;GetCharMovementComponent()-&gt;Velocity = NewVelocity; } } //Cleanup Teleport LastPosition = NewLocation; }</span></span></code> </pre> <br><hr><br>  Wie Sie wahrscheinlich bemerkt haben, rufe ich externe Funktionen auf, um Rotation / Position aufzurufen.  Sie werden von der UTool-Benutzerklasse aufgerufen, die statische Funktionen definiert, die von √ºberall aufgerufen werden k√∂nnen (einschlie√ülich Blaupausen).  Ihr Code wird unten gezeigt. Sie k√∂nnen sie so implementieren, wie es Ihnen am besten erscheint (es ist wahrscheinlich einfacher, sie einfach in die Portal-Actor-Klasse einzuf√ºgen). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FVector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertLocationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Location, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FVector::ZeroVector; } FVector Direction = Location - Reference-&gt;GetActorLocation(); FVector TargetLocation = Target-&gt;GetActorLocation(); FVector Dots; Dots.X = FVector::DotProduct( Direction, Reference-&gt;GetActorForwardVector() ); Dots.Y = FVector::DotProduct( Direction, Reference-&gt;GetActorRightVector() ); Dots.Z = FVector::DotProduct( Direction, Reference-&gt;GetActorUpVector() ); FVector NewDirection = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TargetLocation + NewDirection; }</code> </pre> <br>  Die Transformation wird hier durchgef√ºhrt, indem das Skalarprodukt von Vektoren berechnet wird, um verschiedene Winkel zu bestimmen.  Der Richtungsvektor ist nicht normalisiert, dh wir k√∂nnen das Punktergebnis erneut mit Zielvektoren multiplizieren, um die Position im lokalen Raum des Zielakteurs in genau derselben Entfernung zu erhalten. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FRotator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertRotationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FRotator Rotation, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FRotator::ZeroRotator; } FTransform SourceTransform = Reference-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat QuatRotation = FQuat( Rotation ); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * QuatRotation; FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewWorldQuat.Rotator(); }</code> </pre> <br>  Die Transformation zu drehen war etwas schwieriger umzusetzen.  Am Ende stellte sich heraus, dass die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Quaternionen</a> die beste L√∂sung war, da dies viel genauer ist als die Arbeit mit normalen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Euler-Winkeln</a> und nur wenige Codezeilen erfordert.  Rotationen durch Quaternionen werden mithilfe der Multiplikation ausgef√ºhrt. In unserem Fall wird Inverse () auf die Rotation angewendet, die konvertiert werden soll, und in den lokalen Raum verschoben.  Als n√§chstes m√ºssen wir es nur noch einmal mit der Zielrunde multiplizieren, um die letzte Runde zu erhalten. <br><br><h2>  Erstellen eines Portalnetzes </h2><br>  Um aus der Sicht eines Spielers sch√∂n auszusehen, verwendet mein Portalsystem ein bestimmtes Netz.  Das Netz ist in zwei verschiedene Ebenen unterteilt: <br><br><ul><li>  <b>Ebene 1</b> : Die Hauptebene, auf der das Renderziel des Portals angezeigt wird.  Dieses Flugzeug hat ein eher ungew√∂hnliches Verhalten, da es die Aufgabe hat, sich ein wenig vom Spieler abzuheben, wenn er sich n√§hert, um ein Abschneiden durch die Kamera zu vermeiden.  Da sich die R√§nder des Flugzeugs nicht bewegen, sondern nur die mittleren Spitzen, kann der Spieler das Rendern des Portals ohne visuelle Artefakte √ºberlagern.  Die Kanten an den Kanten haben in der oberen H√§lfte eine eigene UV-Strahlung, w√§hrend die Innenkanten in der unteren H√§lfte eine eigene UV-Strahlung haben, wodurch es einfach ist, sie im Shader zu maskieren. </li><li>  <b>Ebene 2</b> : Diese Ebene wird nur zum Erweitern des Standardbegrenzungsrahmens des Netzes verwendet.  Die Normalen der Scheitelpunkte sind nach unten gerichtet, sodass das Netz selbst auf nicht planarem Boden standardm√§√üig nicht sichtbar ist (da das Rendering-Material nicht zweiseitig ist). </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72e/125/f6f/72e125f6fd315caa2777f65dc0eaf39a.gif"></div><br>  Warum ein solches Netz verwenden? <br><br>  Ich entschied, dass sich "Flugzeug 1" ausdehnen w√ºrde, wenn sich der Spieler n√§herte.  Dadurch kann der Spieler das Portal √ºberlappen und es passieren, ohne es zu beschneiden (zu schneiden).  Dies kann beispielsweise passieren, wenn die Kamera die Ebene des Portals noch nicht √ºberquert hat, die F√º√üe des Spielers sie jedoch bereits ber√ºhrt haben.  Auf diese Weise k√∂nnen Sie den Player nicht abschneiden und das Netz andererseits duplizieren. <br><br>  Die Aufgabe ‚ÄûEbene 2‚Äú besteht darin, den Standardbegrenzungsrahmen des Netzes zu erweitern.  Da ‚ÄûEbene 1‚Äú flach ist, hat der Begrenzungsrahmen auf einer Achse eine Dicke von 0, und wenn sich die Kamera dahinter befindet, wird er vom Motor abgeschnitten (dh nicht gerendert).  Ebene 1 hat eine Gr√∂√üe von 128 √ó 128, sodass sie mit der Engine einfach skaliert werden kann.  Ebene 2 ist etwas gr√∂√üer und befindet sich unter dem Boden (unter 0). <br><br>  Nachdem wir das Netz erstellt haben, exportieren wir es einfach aus einem 3D-Editor eines Drittanbieters und importieren es in Unreal.  Es wird im n√§chsten Schritt verwendet. <br><br><h2>  Portalmaterial erstellen </h2><br>  Um die andere Seite des Portals anzuzeigen, m√ºssen wir unser eigenes Material erstellen.  Erstellen Sie neues Material im Inhaltsbrowser (ich habe es <b>MAT_PortalBase genannt</b> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b0/402/a9c/7b0402a9cd6c6d62438e06fa3a7cd1f4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dea/96c/a1b/dea96ca1b613a92acc7ca35e0bbe44b1.png"></div><br>  √ñffnen Sie es nun und erstellen Sie das folgende Diagramm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfe/4fa/c17/cfe4fac175e5e399c9e615a6afd0b800.jpg"></div><br>  So funktioniert das Material: <br><br><ul><li>  <b>FadeColor</b> ist die Farbe, die durch das Portal sichtbar ist, wenn es sehr weit entfernt ist.  Dies ist erforderlich, da nicht immer alle Portale gerendert werden. Daher wird das Rendern verdeckt, wenn der Player / die Kamera weit entfernt ist. </li><li>  Um herauszufinden, wie weit der Player vom Portal entfernt ist, bestimme ich den <b>Abstand</b> zwischen Kameraposition und Schauspielerposition.  Dann dividiere ich den Abstand durch den Maximalwert, mit dem ich einen Vergleich durchf√ºhren m√∂chte.  Wenn zum Beispiel das von mir festgelegte Maximum 2000 ist und die Entfernung zum Spieler 1000 betr√§gt, erhalten wir 0,5.  Wenn der Spieler weiter ist, erhalte ich einen Wert gr√∂√üer als 1, daher verwende ich ges√§ttigte Knoten, um ihn zu begrenzen.  Als n√§chstes kommt der Smoothstep-Knoten, mit dem die Entfernung als Farbverlauf skaliert und die Portalschattierung genauer gesteuert wird.  Wenn der Player beispielsweise in der N√§he ist, verschwindet der Schatten vollst√§ndig. </li><li>  Ich verwende die Entfernungsberechnung als Alpha-Kanalwert f√ºr den <b>Lerp-</b> Knoten, um die Schattierungsfarbe und die <b>Textur</b> zu mischen, die das <b>Portalziel</b> rendern. </li><li>  Schlie√ülich isoliere ich die Y-Komponente der UV-Koordinaten, um eine Maske zu erstellen, mit der Sie wissen, welche Scheitelpunkte des Netzes verschoben werden.  Ich multipliziere diese Maske mit der Absto√üungsmenge, die ich brauche.  Ich verwende einen negativen Wert, damit sich die Normalen der Scheitelpunkte, wenn sie mit den Scheitelpunkten multipliziert werden, in die entgegengesetzte Richtung bewegen. </li></ul><br>  Nachdem wir dies alles getan haben, haben wir gebrauchsfertiges Material erstellt. <br><br><h2>  Erstellen eines Portal Actor in Blueprint </h2><br>  Lassen Sie uns eine neue Blueprint-Klasse einrichten, die vom Portal-Akteur erbt.  Klicken Sie mit der rechten Maustaste auf den Inhaltsbrowser und w√§hlen Sie die Blueprint-Klasse aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/28b/5a2/ead28b5a23369c2c86a076ec8bb1dda0.png"></div><br>  Geben Sie nun "Portal" in das Suchfeld ein, um die Portalklasse auszuw√§hlen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/da4/555/bd7da4555cff2dc953ab3b0b0f4d1057.png"></div><br>  √ñffnen Sie Bluetooth, falls es noch nicht ge√∂ffnet ist.  In der Liste der Komponenten sehen Sie die folgende Hierarchie: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/34c/308/73c34c308a70f644759dc9057b0facd2.png"></div><br>  Wie erwartet gibt es eine Root-Komponente und ein Portal-Root.  F√ºgen wir PortalRootComponent eine statische Netzkomponente hinzu und laden das im vorherigen Schritt erstellte Netz hinein: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/ef3/11d/fa4ef311d11c803afc565060a9902c24.jpg"></div><br><hr><br>  Wir f√ºgen auch die Kollisionsbox hinzu, mit der bestimmt wird, ob sich der Player innerhalb des Portal-Volumes befindet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b0/28f/df6/0b028fdf696598f6b3eca9af3049caa1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2a/85d/747/c2a85d747c8b76900cae32e9f9cc1a59.png"></div><br>  Das Feld Kollision befindet sich unter der Szenenkomponente, die dem Hauptstamm zugeordnet ist, und nicht unter dem Portalstamm.  Ich habe auch ein Symbol (Werbetafel) und eine Pfeilkomponente hinzugef√ºgt, um das Portal auf den Ebenen besser sichtbar zu machen.  Dies ist nat√ºrlich nicht erforderlich. <br><br>  Lassen Sie uns nun das Material in Blaupause einrichten. <br><br>  Zun√§chst ben√∂tigen wir zwei Variablen - eine vom Typ <b>Actor</b> und der Name <b>PortalTarget</b> , die zweite vom Typ <b>Dynamic Material Instance</b> und hei√üt <b>MaterialInstance</b> .  PortalTarget ist ein Verweis auf die Position, auf die das Portalfenster schaut (daher ist die Variable h√§ufig mit einem Symbol f√ºr offenes Auge), damit wir sie √§ndern k√∂nnen, wenn der Akteur auf der Ebene platziert wird.  MaterialInstance speichert einen Link zu dynamischem Material, damit wir in Zukunft das Renderziel des Portals im laufenden Betrieb zuweisen k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/0b9/772/4740b9772dfc7ce30cda63300f1682a5.png"></div><br>  Wir m√ºssen auch unsere eigenen Ereignisknoten hinzuf√ºgen.  √ñffnen Sie am besten das Kontextmen√º im <b>Ereignisdiagramm</b> und suchen Sie die Namen der Ereignisse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/719/d22/bc2719d224381581c9bdb8ea5ce7c365.png"></div><br>  Und hier, um das folgende Diagramm zu erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f4/400/24f/0f440024f5c322c6640609bb8d20bcad.jpg"></div><br><ul><li>  <b>Spiel</b> starten: Hier rufen wir die √ºbergeordnete Funktion SetTarget () des Portals auf, um ihm einen Link zum Schauspieler zuzuweisen, der sp√§ter f√ºr SceneCapture verwendet wird.  Anschlie√üend erstellen wir ein neues dynamisches Material und weisen ihm den Wert der MaterialInstance-Variablen zu.  Mit diesem neuen Material k√∂nnen wir es der statischen Netzkomponente zuweisen.  Ich habe dem Material auch eine Dummy-Textur gegeben, aber dies ist optional. </li><li>  <b>RTT</b> l√∂schen: Mit dieser Funktion wird die dem Portalmaterial zugewiesene Renderziel-Textur gel√∂scht.  Es wird vom Portal-Manager gestartet. </li><li>  <b>RTT</b> festlegen: Mit dieser Funktion wird das Renderzielmaterial des Portals festgelegt.  Es wird vom Portal-Manager gestartet. </li></ul><br>  Bisher sind wir mit Bluetooth fertig, aber wir werden sp√§ter darauf zur√ºckkommen, um Tick-Funktionen zu implementieren. <br><br><h2>  Portal Manager </h2><br>  Jetzt haben wir alle grundlegenden Elemente, die zum Erstellen einer neuen Klasse erforderlich sind, die von AActor geerbt wurde, n√§mlich Portal Manager.  M√∂glicherweise ben√∂tigen Sie die Portal Manager-Klasse nicht in Ihrem Projekt, aber in meinem Fall vereinfacht dies die Arbeit mit einigen Aspekten erheblich.  Hier ist eine Liste der vom Portal-Manager ausgef√ºhrten Aufgaben: <br><br><ul><li>  Der Portal-Manager ist ein <b>vom Player-Controller erstellter</b> und damit verbundener Akteur, um den Status und die Entwicklung des Spielers innerhalb der Spielebene zu verfolgen. </li><li>  Renderzielportal erstellen und zerst√∂ren.  Die Idee ist, dynamisch eine Render-Zieltextur zu erstellen, die der Bildschirmaufl√∂sung des Players entspricht.  Wenn Sie die Aufl√∂sung w√§hrend des Spiels √§ndern, konvertiert der Manager sie automatisch in die gew√ºnschte Gr√∂√üe. </li><li>  Der Portal-Manager <b>findet und aktualisiert</b> die Portal-Darstellerebene, um ihnen ein Renderziel zu geben.  Diese Aufgabe wird so ausgef√ºhrt, dass die Kompatibilit√§t mit Level-Streaming gew√§hrleistet ist.  Wenn ein neuer Schauspieler erscheint, sollte er eine Textur bekommen.  Wenn sich das Renderziel √§ndert, kann der Manager au√üerdem automatisch ein neues Ziel zuweisen.  Dies erleichtert die Verwaltung des Systems, anstatt dass jeder Portal-Akteur den Manager manuell kontaktiert. </li><li>  Die <b>SceneCapture-</b> Komponente <b>ist</b> an den Portal-Manager angeh√§ngt, um nicht f√ºr jedes Portal eine Kopie zu erstellen.  Dar√ºber hinaus k√∂nnen Sie es jedes Mal wiederverwenden, wenn wir zu einem bestimmten Portal-Akteur auf der Ebene wechseln. </li><li>  Wenn das Portal beschlie√üt, <b>den</b> Player zu <b>teleportieren</b> , sendet es eine Anfrage an Portal Manager.  Dies ist erforderlich, um sowohl das Quell- als auch das Zielportal (falls vorhanden) zu aktualisieren, sodass der √úbergang ohne Verbindungen erfolgt. </li><li>  <b>Der</b> Portal-Manager wird am Ende der Funktion " <b>Character tick ()"</b> aktualisiert, sodass alles korrekt aktualisiert wird, einschlie√ülich der Kamera des Players.  Dies stellt sicher, dass alles auf dem Bildschirm synchronisiert ist, und vermeidet eine Verz√∂gerung von einem Frame w√§hrend des Renderns durch die Engine. </li></ul><br>  Werfen wir einen Blick auf den Portal Manager-Header: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortalManager.generated.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Forward declaration class AExedrePlayerController; class AExedrePortal; class UExedreScriptedTexture; UCLASS() class EXEDRE_API AExedrePortalManager : public AActor { GENERATED_UCLASS_BODY() public: AExedrePortalManager(); //Called by a Portal actor when wanting to teleport something UFUNCTION(BlueprintCallable, Category="Portal") void RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ); //Save a reference to the PlayerControler void SetControllerOwner( AExedrePlayerController* NewOwner ); //Various setup that happens during spawn void Init(); //Manual Tick void Update( float DeltaTime ); //Find all the portals in world and update them //returns the most valid/usable one for the Player AExedrePortal* UpdatePortalsInWorld(); //Update SceneCapture void UpdateCapture( AExedrePortal* Portal ); //Accessor for Debug purpose UTexture* GetPortalTexture(); //Accessor for Debug purpose FTransform GetCameraTransform(); private: //Function to create the Portal render target void GeneratePortalTexture(); UPROPERTY() USceneCaptureComponent2D* SceneCapture; //Custom class, can be replaced by a "UCanvasRenderTarget2D" instead //See : https://api.unrealengine.com/INT/API/Runtime/Engine/Engine/UCanvasRenderTarget2D/index.html UPROPERTY() UExedreScriptedTexture* PortalTexture; UPROPERTY() AExedrePlayerController* ControllerOwner; int32 PreviousScreenSizeX; int32 PreviousScreenSizeY; float UpdateDelay; };</span></span></span></span></code> </pre> <br><hr><br>  Bevor ich auf Details eingehe, werde ich zeigen, wie ein Akteur aus der Player Controller-Klasse erstellt wird, die von der BeginPlay () -Funktion aufgerufen wird: <br><br><pre> <code class="cpp hljs"> FActorSpawnParameters SpawnParams; PortalManager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PortalManager = GetWorld()-&gt;SpawnActor&lt;AExedrePortalManager&gt;( AExedrePortalManager::StaticClass(), FVector::ZeroVector, FRotator::ZeroRotator, SpawnParams); PortalManager-&gt;AttachToActor( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, FAttachmentTransformRules::SnapToTargetIncludingScale); PortalManager-&gt;SetControllerOwner( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); PortalManager-&gt;Init();</code> </pre> <br>  Also erstellen wir einen Akteur, h√§ngen ihn an den Controller des Players an (diesen), speichern den Link und rufen die Funktion Init () auf. <br><br>  Es ist auch wichtig zu beachten, dass wir den Akteur manuell aus der Zeichenklasse aktualisieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedreCharacter::TickActor( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime, <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELevelTick TickType, FActorTickFunction&amp; ThisTickFunction ) { Super::TickActor( DeltaTime, TickType, ThisTickFunction ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) ); EPC-&gt;PortalManager-&gt;Update( DeltaTime ); } }</code> </pre> <br>  Und hier ist der Konstruktor von Portal Manager.  Beachten Sie, dass Tick wieder deaktiviert ist, da wir Portal Manager manuell √ºber den Player aktualisieren. <br><br><pre> <code class="cpp hljs">AExedrePortalManager::AExedrePortalManager(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; PortalTexture = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; UpdateDelay = <span class="hljs-number"><span class="hljs-number">1.1f</span></span>; PreviousScreenSizeX = <span class="hljs-number"><span class="hljs-number">0</span></span>; PreviousScreenSizeY = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><hr><br>  Hier sind die Funktionen von get / set Portal Manager (danach werden wir zu interessanteren Dingen √ºbergehen): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::SetControllerOwner( AExedrePlayerController* NewOwner ) { ControllerOwner = NewOwner; } FTransform AExedrePortalManager::GetCameraTransform() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( SceneCapture != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SceneCapture-&gt;GetComponentTransform(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FTransform(); } } UTexture* AExedrePortalManager::GetPortalTexture() { <span class="hljs-comment"><span class="hljs-comment">//Portal Texture is a custom component class that embed a UCanvasRenderTraget2D //The GetTexture() simply returns the RenderTarget contained in that class. //IsValidLowLevel() is used here as a way to ensure the Texture has not been destroyed or garbage collected. if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { return PortalTexture-&gt;GetTexture(); } else { return nullptr; } }</span></span></code> </pre> <br><hr><br>  Das erste, mit dem Sie beginnen, ist nat√ºrlich die Funktion <b>Init ()</b> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hauptziel dieser Funktion besteht darin, die SceneCapture-Komponente (dh das oben erw√§hnte Aufnahmeger√§t) zu erstellen und korrekt zu konfigurieren. </font><font style="vertical-align: inherit;">Es beginnt mit der Erstellung eines neuen Objekts und seiner Registrierung als Bestandteil dieses Akteurs. </font><font style="vertical-align: inherit;">Anschlie√üend werden die Eigenschaften f√ºr diese Erfassung festgelegt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu erw√§hnende Eigenschaften:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bCaptureEveryFrame = false</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Wir m√∂chten nicht, dass die Erfassung </font><b><font style="vertical-align: inherit;">aktiviert wird,</font></b><font style="vertical-align: inherit;"> wenn wir sie nicht ben√∂tigen. </font><font style="vertical-align: inherit;">Wir werden es manuell verwalten.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bEnableClipPlane = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Eine ziemlich wichtige Eigenschaft zum korrekten Rendern der Portalaufnahme.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bUseCustomProjectionMatrix = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dies erm√∂glicht es uns, die Capture-Projektion basierend auf dem Standpunkt des Players durch unsere eigene zu ersetzen.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CaptureSource = ESceneCaptureSource :: SCS_SceneColorSceneDepth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dieser Modus ist etwas teuer, aber erforderlich, um eine ausreichende Menge an Informationen zu rendern.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die √ºbrigen Eigenschaften beziehen sich haupts√§chlich auf die Nachbearbeitungsparameter. </font><font style="vertical-align: inherit;">Sie sind eine bequeme M√∂glichkeit, die Qualit√§t zu kontrollieren und damit die Leistung zu erfassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der letzte Teil ruft die Funktion auf, mit der das Renderziel erstellt wird (siehe unten).</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Init() { <span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------ //Create Camera //------------------------------------------------ SceneCapture = NewObject&lt;USceneCaptureComponent2D&gt;(this, USceneCaptureComponent2D::StaticClass(), *FString("PortalSceneCapture")); SceneCapture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); SceneCapture-&gt;RegisterComponent(); SceneCapture-&gt;bCaptureEveryFrame = false; SceneCapture-&gt;bCaptureOnMovement = false; SceneCapture-&gt;LODDistanceFactor = 3; //Force bigger LODs for faster computations SceneCapture-&gt;TextureTarget = nullptr; SceneCapture-&gt;bEnableClipPlane = true; SceneCapture-&gt;bUseCustomProjectionMatrix = true; SceneCapture-&gt;CaptureSource = ESceneCaptureSource::SCS_SceneColorSceneDepth; //Setup Post-Process of SceneCapture (optimization : disable Motion Blur, etc) FPostProcessSettings CaptureSettings; CaptureSettings.bOverride_AmbientOcclusionQuality = true; CaptureSettings.bOverride_MotionBlurAmount = true; CaptureSettings.bOverride_SceneFringeIntensity = true; CaptureSettings.bOverride_GrainIntensity = true; CaptureSettings.bOverride_ScreenSpaceReflectionQuality = true; CaptureSettings.AmbientOcclusionQuality = 0.0f; //0=lowest quality..100=maximum quality CaptureSettings.MotionBlurAmount = 0.0f; //0 = disabled CaptureSettings.SceneFringeIntensity = 0.0f; //0 = disabled CaptureSettings.GrainIntensity = 0.0f; //0 = disabled CaptureSettings.ScreenSpaceReflectionQuality = 0.0f; //0 = disabled CaptureSettings.bOverride_ScreenPercentage = true; CaptureSettings.ScreenPercentage = 100.0f; SceneCapture-&gt;PostProcessSettings = CaptureSettings; //------------------------------------------------ //Create RTT Buffer //------------------------------------------------ GeneratePortalTexture(); }</span></span></code> </pre> <br><hr><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeneratePortalTexture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Funktion, die bei Bedarf aufgerufen wird, wenn Sie eine neue Renderziel-Textur f√ºr Portale erstellen m√ºssen. </font><font style="vertical-align: inherit;">Dies geschieht in der Initialisierungsfunktion, kann aber auch w√§hrend des Portal Manager-Upgrades aufgerufen werden. </font><font style="vertical-align: inherit;">Aus diesem Grund verf√ºgt diese Funktion √ºber eine interne √úberpr√ºfung zum √Ñndern der Aufl√∂sung des Ansichtsfensters. </font><font style="vertical-align: inherit;">Ist dies nicht der Fall, wird das Update nicht durchgef√ºhrt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In meinem Fall habe ich eine Wrapper-Klasse f√ºr UCanvasRenderTarget2D erstellt. Ich habe es ExedreScriptedTexture genannt, es ist eine Komponente, die an einen Schauspieler angeh√§ngt werden kann. Ich habe diese Klasse erstellt, um Renderziele bequem mit Akteuren zu verwalten, die Renderaufgaben haben. Er f√ºhrt die ordnungsgem√§√üe Initialisierung des Renderziels durch und ist mit meinem eigenen UI-System kompatibel. Im Kontext von Portalen ist eine regul√§re RenderTarget2D-Textur jedoch mehr als ausreichend. Daher k√∂nnen Sie es einfach verwenden.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::GeneratePortalTexture() { int32 CurrentSizeX = <span class="hljs-number"><span class="hljs-number">1920</span></span>; int32 CurrentSizeY = <span class="hljs-number"><span class="hljs-number">1080</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;GetViewportSize(CurrentSizeX, CurrentSizeY); } CurrentSizeX = FMath::Clamp( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(CurrentSizeX / <span class="hljs-number"><span class="hljs-number">1.7</span></span>), <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1920</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1920 / 1.5 = 1280 CurrentSizeY = FMath::Clamp( int(CurrentSizeY / 1.7), 128, 1080); if( CurrentSizeX == PreviousScreenSizeX &amp;&amp; CurrentSizeY == PreviousScreenSizeY ) { return; } PreviousScreenSizeX = CurrentSizeX; PreviousScreenSizeY = CurrentSizeY; //Cleanup existing RTT if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { PortalTexture-&gt;DestroyComponent(); GEngine-&gt;ForceGarbageCollection(); } //Create new RTT PortalTexture = nullptr; PortalTexture = NewObject&lt;UExedreScriptedTexture&gt;(this, UExedreScriptedTexture::StaticClass(), *FString("PortalRenderTarget")); PortalTexture-&gt;SizeX = CurrentSizeX; PortalTexture-&gt;SizeY = CurrentSizeY; //Custom properties of the UExedreScriptedTexture class PortalTexture-&gt;Gamma = 1.0f; PortalTexture-&gt;WrapModeX = 1; //Clamp PortalTexture-&gt;WrapModeY = 1; //Clamp PortalTexture-&gt;bDrawWidgets = false; PortalTexture-&gt;bGenerateMipMaps = false; PortalTexture-&gt;SetClearOnUpdate( false ); //Will be cleared by SceneCapture instead PortalTexture-&gt;Format = ERenderTargetFormat::RGBA16; //Needs 16b to get &gt;1 for Emissive PortalTexture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); PortalTexture-&gt;RegisterComponent(); PortalTexture-&gt;SetOwner( this ); PortalTexture-&gt;Init(); PortalTexture-&gt;SetFilterMode( TextureFilter::TF_Bilinear ); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie oben erw√§hnt, habe ich meine eigene Klasse erstellt, daher m√ºssen die hier festgelegten Eigenschaften an das √ºbliche Renderziel angepasst werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist wichtig zu verstehen, wo die Aufnahme angezeigt wird. </font><font style="vertical-align: inherit;">Da das Renderziel im Spiel angezeigt wird, bedeutet dies, dass dies vor der gesamten Nachbearbeitung geschieht. Daher m√ºssen wir die Szene mit gen√ºgend Informationen rendern (um Werte √ºber 1 zu speichern, um Bloom zu erstellen). </font><font style="vertical-align: inherit;">Aus diesem Grund habe ich das RGBA16-Format gew√§hlt (beachten Sie, dass es eine eigene Aufz√§hlung hat, Sie m√ºssen stattdessen ETextureRenderTargetFormat verwenden). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Informationen finden Sie in den folgenden Quellen:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UTextureRenderTarget2D</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETextureRenderTargetFormat</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USceneCaptureComponent2D</font></font></a> </li></ul><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiter werden wir Update-Funktionen betrachten. </font><font style="vertical-align: inherit;">Die Grundfunktion ist recht einfach und komplexer. </font><font style="vertical-align: inherit;">Vor dem Aufrufen der Funktion GeneratePortalTexture () tritt eine Verz√∂gerung auf, um zu vermeiden, dass das Renderziel beim √Ñndern der Gr√∂√üe des Ansichtsfensters neu erstellt wird (z. B. im Editor). </font><font style="vertical-align: inherit;">W√§hrend der Ver√∂ffentlichung des Spiels kann diese Verz√∂gerung beseitigt werden.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Update( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime ) { <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Generate Portal texture ? //----------------------------------- UpdateDelay += DeltaTime; if( UpdateDelay &gt; 1.0f ) { UpdateDelay = 0.0f; GeneratePortalTexture(); } //----------------------------------- //Find portals in the level and update them //----------------------------------- AExedrePortal* Portal = UpdatePortalsInWorld(); if( Portal != nullptr ) { UpdateCapture( Portal ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir rufen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf, um alle in der aktuellen Welt vorhandenen Portale (einschlie√ülich aller geladenen Ebenen) zu finden und zu aktualisieren. </font><font style="vertical-align: inherit;">Die Funktion bestimmt auch, welche "aktiv" ist, d.h. </font><font style="vertical-align: inherit;">f√ºr den Spieler sichtbar. </font><font style="vertical-align: inherit;">Wenn wir ein aktives Portal finden, rufen wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture () auf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das die SceneCapture-Komponente steuert.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So funktioniert das Welt-Update in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ol><li>   <b></b>   (    ) </li><li>   <b>iterator</b> ,         </li><li>     ,   ,    <b>ClearRTT()</b> ,    .    <b> </b> (,   ). </li><li>  ,     <b></b>  ,    ,     ,     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die √úberpr√ºfung, die die Richtigkeit des Portals feststellt, ist einfach: Wir geben dem Portal, das dem Spieler am n√§chsten liegt, Priorit√§t, da er aus seiner Sicht h√∂chstwahrscheinlich am sichtbarsten ist. </font><font style="vertical-align: inherit;">Um Verwandte, aber zum Beispiel Portale, die sich hinter dem Player befinden, fallen zu lassen, sind komplexere √úberpr√ºfungen erforderlich, aber ich wollte mich in meinem Tutorial nicht darauf konzentrieren, da dies ziemlich schwierig werden kann.</font></font><br><br><pre> <code class="cpp hljs">AExedrePortal* AExedrePortalManager::UpdatePortalsInWorld() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update Portal actors in the world (and active one if nearby) //----------------------------------- AExedrePortal* ActivePortal = nullptr; FVector PlayerLocation = Character-&gt;GetActorLocation(); FVector CameraLocation = Character-&gt;GetCameraComponent()-&gt;GetComponentLocation(); float Distance = 4096.0f; for( TActorIterator&lt;AExedrePortal&gt;ActorItr( GetWorld() ); ActorItr; ++ActorItr ) { AExedrePortal* Portal = *ActorItr; FVector PortalLocation = Portal-&gt;GetActorLocation(); FVector PortalNormal = -1 * Portal-&gt;GetActorForwardVector(); //Reset Portal Portal-&gt;ClearRTT(); Portal-&gt;SetActive( false ); //Find the closest Portal when the player is Standing in front of float NewDistance = FMath::Abs( FVector::Dist( PlayerLocation, PortalLocation ) ); if( NewDistance &lt; Distance ) { Distance = NewDistance; ActivePortal = Portal; } } return ActivePortal; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist Zeit, die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture () -</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion in Betracht zu </font><b><font style="vertical-align: inherit;">ziehen</font></b><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist eine Upgrade-Funktion, die die andere Seite des Portals erfasst. </font><font style="vertical-align: inherit;">Aus den Kommentaren sollte alles klar sein, aber hier ist eine kurze Beschreibung:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erhalten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu Character und Player Controller.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir pr√ºfen, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ob alles korrekt ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Portal, SceneCapture-Komponente, Player).</font></font></li><li>   <b>Camera</b>    <b>Target</b>  . </li><li> <b></b>    ,     SceneCapture. </li><li>      SceneCapture     Target. </li><li> ,  SceneCapure  ,  ,   <b></b> . </li><li> <b> Render Target</b>  SceneCapture,  . </li><li>  <b> </b>  PlayerController. </li><li> ,    <b>Capture</b>  SceneCapture     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie wir sehen k√∂nnen, ist beim Teleportieren eines Spielers die korrekte Umwandlung der Position und Drehung des Portals in den lokalen Zielraum ein Schl√ºsselelement des nat√ºrlichen und fehlerfreien Verhaltens von SceneCapture. </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Definition von ConvertLocationToActorSpace () finden Sie unter ‚ÄûTeleportieren eines Akteurs‚Äú. </font></font></blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::UpdateCapture( AExedrePortal* Portal ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update SceneCapture (discard if there is no active portal) //----------------------------------- if(SceneCapture != nullptr &amp;&amp; PortalTexture != nullptr &amp;&amp; Portal != nullptr &amp;&amp; Character != nullptr ) { UCameraComponent* PlayerCamera = Character-&gt;GetCameraComponent(); AActor* Target = Portal-&gt;GetTarget(); //Place the SceneCapture to the Target if( Target != nullptr ) { //------------------------------- //Compute new location in the space of the target actor //(which may not be aligned to world) //------------------------------- FVector NewLocation = UTool::ConvertLocationToActorSpace( PlayerCamera-&gt;GetComponentLocation(), Portal, Target ); SceneCapture-&gt;SetWorldLocation( NewLocation ); //------------------------------- //Compute new Rotation in the space of the //Target location //------------------------------- FTransform CameraTransform = PlayerCamera-&gt;GetComponentTransform(); FTransform SourceTransform = Portal-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * CameraTransform.GetRotation(); FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; //Update SceneCapture rotation SceneCapture-&gt;SetWorldRotation( NewWorldQuat ); //------------------------------- //Clip Plane : to ignore objects between the //SceneCapture and the Target of the portal //------------------------------- SceneCapture-&gt;ClipPlaneNormal = Target-&gt;GetActorForwardVector(); SceneCapture-&gt;ClipPlaneBase = Target-&gt;GetActorLocation() + (SceneCapture-&gt;ClipPlaneNormal * -1.5f); //Offset to avoid visible pixel border } //Switch on the valid Portal Portal-&gt;SetActive( true ); //Assign the Render Target Portal-&gt;SetRTT( PortalTexture-&gt;GetTexture() ); SceneCapture-&gt;TextureTarget = PortalTexture-&gt;GetTexture(); //Get the Projection Matrix SceneCapture-&gt;CustomProjectionMatrix = ControllerOwner-&gt;GetCameraProjectionMatrix(); //Say Cheeeeese ! SceneCapture-&gt;CaptureScene(); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font><font style="vertical-align: inherit;">Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetCameraProjectionMatrix () ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der PlayerController-Klasse standardm√§√üig nicht vorhanden. Ich habe sie selbst hinzugef√ºgt. </font><font style="vertical-align: inherit;">Es wird unten gezeigt:</font></font><br><br><pre> <code class="cpp hljs">FMatrix AExedrePlayerController::GetCameraProjectionMatrix() { FMatrix ProjectionMatrix; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( GetLocalPlayer() != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { FSceneViewProjectionData PlayerProjectionData; GetLocalPlayer()-&gt;GetProjectionData( GetLocalPlayer()-&gt;ViewportClient-&gt;Viewport, EStereoscopicPass::eSSP_FULL, PlayerProjectionData ); ProjectionMatrix = PlayerProjectionData.ProjectionMatrix; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProjectionMatrix; }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich m√ºssen wir den Aufruf der Teleport-Funktion implementieren. </font><font style="vertical-align: inherit;">Der Grund f√ºr die teilweise Verarbeitung der Teleportation √ºber den Portal-Manager besteht darin, dass die Aktualisierung der erforderlichen Portale gew√§hrleistet werden muss, da nur der Manager Informationen zu allen Portalen in der Szene hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir zwei verbundene Portale haben, m√ºssen wir beim Wechsel von einem zum anderen beide in einem Tick aktualisieren. </font><font style="vertical-align: inherit;">Andernfalls teleportiert sich der Spieler und befindet sich auf der anderen Seite des Portals, aber das Zielportal ist erst beim n√§chsten Frame / Takt aktiv. </font><font style="vertical-align: inherit;">Dadurch entstehen visuelle L√ºcken mit dem versetzten Material des ebenen Netzes, das wir oben gesehen haben.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { Portal-&gt;TeleportActor( TargetToTeleport ); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Force update //----------------------------------- AExedrePortal* FuturePortal = UpdatePortalsInWorld(); if( FuturePortal != nullptr ) { FuturePortal-&gt;ForceTick(); //Force update before the player render its view since he just teleported UpdateCapture( FuturePortal ); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nun, das ist es, wir sind endlich fertig mit Portal Manager! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beenden Sie die Blaupause </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Abschluss des Portal-Managers m√ºssen wir nur den Portal-Akteur selbst fertigstellen. Danach funktioniert das System. </font><font style="vertical-align: inherit;">Das einzige, was hier fehlt, sind die Tick-Funktionen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/455/bd3/f0f/455bd3f0f3b7c9f4f3fb36d5d1ae85d0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So funktioniert es: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir aktualisieren das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so, dass es nicht in einem aktiven Zustand bleibt.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Portal derzeit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inaktiv ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wird der Rest der Ma√ünahme verworfen.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir bekommen die Zeichenklasse die f√ºr </font><font style="vertical-align: inherit;">den Zugriff auf die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kamera die Lage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Teil pr√ºft, ob sich die Kamera im Kollisionsfeld des Portals befindet. </font><font style="vertical-align: inherit;">Wenn ja, versetzen wir das Portalnetz mit seinem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der zweite Teil besteht darin, die Position innerhalb der Kollisionsbox erneut zu √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Wenn es ausgef√ºhrt wird, rufen wir eine Funktion auf, die pr√ºft, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ob wir das Portal √ºberqueren</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li>        ,   Portal manager,    <b> Teleport</b> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Screenshot meines Diagramms sehen Sie zwei interessante Punkte: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Point Inside Box</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get Portal Manager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ich habe diese beiden Funktionen noch nicht erkl√§rt. Dies sind statische Funktionen, die ich in meiner eigenen Klasse definiert habe, damit Sie sie von √ºberall aus aufrufen k√∂nnen. Dies ist eine Art Helferklasse. Der Code dieser Funktionen wird unten angezeigt. Sie k√∂nnen selbst entscheiden, wo sie eingef√ºgt werden sollen. Wenn Sie sie nicht au√üerhalb des Portalsystems ben√∂tigen, k√∂nnen Sie sie direkt in die Portal-Akteurklasse einf√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst wollte ich das Kollisionssystem verwenden, um den Portal-Akteur in der Kollisionsbox zu finden, aber es schien mir nicht zuverl√§ssig genug zu sein. Au√üerdem scheint mir diese Methode schneller anzuwenden zu sein und hat einen Vorteil: Sie ber√ºcksichtigt die Rotation des Schauspielers.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPointInsideBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Point, UBoxComponent* Box )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Box != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//From : //https://stackoverflow.com/questions/52673935/check-if-3d-point-inside-a-box/52674010 FVector Center = Box-&gt;GetComponentLocation(); FVector Half = Box-&gt;GetScaledBoxExtent(); FVector DirectionX = Box-&gt;GetForwardVector(); FVector DirectionY = Box-&gt;GetRightVector(); FVector DirectionZ = Box-&gt;GetUpVector(); FVector Direction = Point - Center; bool IsInside = FMath::Abs( FVector::DotProduct( Direction, DirectionX ) ) &lt;= Half.X &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionY ) ) &lt;= Half.Y &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionZ ) ) &lt;= Half.Z; return IsInside; } else { return false; } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AExedrePortalManager* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPortalManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AActor* Context )</span></span></span><span class="hljs-function"> </span></span>{ AExedrePortalManager* Manager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Retrieve the World from the Context actor if( Context != nullptr &amp;&amp; Context-&gt;GetWorld() != nullptr ) { //Find PlayerController AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( Context-&gt;GetWorld()-&gt;GetFirstPlayerController() ); //Retrieve the Portal Manager if( EPC != nullptr &amp;&amp; EPC-&gt;GetPortalManager() != nullptr ) { Manager = EPC-&gt;GetPortalManager(); } } return Manager; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der letzte Teil des Blueprint-Darstellers ist </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ForceTick</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Denken Sie daran, dass Force Tick aufgerufen wird, wenn ein Spieler ein Portal √ºberquert und sich neben einem anderen Portal befindet, f√ºr das Portal Manager ein Update erzwingt. </font><font style="vertical-align: inherit;">Da wir gerade teleportiert haben, ist es nicht erforderlich, denselben Code zu verwenden, und Sie k√∂nnen die vereinfachte Version verwenden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/562/22e/cf356222e9d9c81dc38c57d021e51a90.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Prozess beginnt ungef√§hr zur gleichen Zeit wie die Tick-Funktion, aber wir f√ºhren nur den ersten Teil der Sequenz aus, der das Material aktualisiert. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sind wir fertig? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir das Portalsystem in dieser Form implementieren, werden wir h√∂chstwahrscheinlich auf das folgende Problem sto√üen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/f2f/9f7/4c1f2f9f71e8ce213764d42dad1d20c3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist hier los? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem GIF ist die Framerate des Spiels auf 6 FPS begrenzt, um das Problem deutlicher darzustellen. In einem Frame verschwindet der Cube, weil das </font><font style="vertical-align: inherit;">Unreal Engine- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clipping-System</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ihn als unsichtbar betrachtet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies liegt daran, dass die Ermittlung im aktuellen Frame durchgef√ºhrt und dann im n√§chsten verwendet wird. Dies erzeugt eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verz√∂gerung von einem Frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies kann normalerweise behoben werden, indem der Begrenzungsrahmen des Objekts so erweitert wird, dass es registriert wird, bevor es sichtbar wird. Dies wird hier jedoch nicht funktionieren, da wir uns beim √úberqueren des Portals von einem Ort zu einem v√∂llig anderen teleportieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Deaktivieren des Clipping-Systems ist ebenfalls nicht m√∂glich, insbesondere weil dies bei Ebenen mit vielen Objekten die Leistung beeintr√§chtigt. Au√üerdem habe ich viele Teams der Unreal-Engine ausprobiert, aber keine positiven Ergebnisse erzielt: In allen F√§llen blieb eine Verz√∂gerung von einem Frame bestehen. Gl√ºcklicherweise konnte ich nach einer detaillierten Untersuchung des Quellcodes von Unreal Engine eine L√∂sung finden (der Weg war lang - es dauerte mehr als eine Woche)! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei der SceneCapture-Komponente k√∂nnen Sie der Kamera des Players mitteilen, dass wir einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprungschnitt vorgenommen haben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Die Kameraposition ist zwischen zwei Bildern gesprungen, was bedeutet, dass wir uns nicht auf die Informationen des vorherigen Bildes verlassen k√∂nnen. </font><font style="vertical-align: inherit;">Dieses Verhalten kann bei Verwendung von Matinee oder Sequencer beobachtet werden, z. B. beim Wechseln der Kamera: Bewegungsunsch√§rfe oder Gl√§ttung k√∂nnen nicht auf Informationen aus dem vorherigen Frame beruhen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu m√ºssen wir zwei Aspekte ber√ºcksichtigen:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LocalPlayer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Diese Klasse verarbeitet verschiedene Informationen (z. B. das Ansichtsfenster des Players) und ist dem PlayerController zugeordnet. </font><font style="vertical-align: inherit;">Hier k√∂nnen wir den Renderprozess der Kamera des Players beeinflussen.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerController</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Wenn sich ein Spieler teleportiert, beginnt diese Klasse dank des Zugriffs auf LocalPlayer zu splei√üen.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der gro√üe Vorteil dieser L√∂sung besteht darin, dass der Eingriff in den Rendering-Prozess der Engine bei zuk√ºnftigen Updates von Unreal Engine minimal und einfach zu warten ist. </font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit der Erstellung einer neuen Klasse, die von LocalPlayer geerbt wurde. </font><font style="vertical-align: inherit;">Im Folgenden finden Sie eine √úberschrift, in der zwei Hauptkomponenten aufgef√ºhrt sind: Neudefinition der Berechnungen des Szenenansichtsfensters und eine neue Funktion zum Aufrufen des Kameraklebens.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Engine/LocalPlayer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API UExedreLocalPlayer : public ULocalPlayer { GENERATED_BODY() UExedreLocalPlayer(); public: FSceneView* CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) override; void PerformCameraCut(); private: bool bCameraCut; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So wird alles implementiert: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Exedre.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.h"</span></span></span><span class="hljs-meta"> UExedreLocalPlayer::UExedreLocalPlayer() { bCameraCut = false; } FSceneView* UExedreLocalPlayer::CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ULocalPlayer::CalcSceneView() use a ViewInitOptions to create // a FSceneView which contains a "bCameraCut" variable // See : H:\GitHub\UnrealEngine\Engine\Source\Runtime\Renderer\Private\SceneCaptureRendering.cpp // as well for bCameraCutThisFrame in USceneCaptureComponent2D FSceneView* View = Super::CalcSceneView(ViewFamily, OutViewLocation, OutViewRotation, Viewport, ViewDrawer, StereoPass ); if( bCameraCut ) { View-&gt;bCameraCut = true; bCameraCut = false; } return View; } void UExedreLocalPlayer::PerformCameraCut() { bCameraCut = true; }</span></span></span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PerformCameraCut ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> startet Camera Cut nur mit einem booleschen Wert. </font><font style="vertical-align: inherit;">Wenn die Engine die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView () aufruft</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , f√ºhren wir zuerst die urspr√ºngliche Funktion aus. </font><font style="vertical-align: inherit;">Dann pr√ºfen wir, ob wir kleben m√ºssen. </font><font style="vertical-align: inherit;">In diesem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fall</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definieren wir die boolesche Variable "Camera Cut" innerhalb der </font><b><font style="vertical-align: inherit;">FSceneView-</font></b><font style="vertical-align: inherit;"> Struktur neu </font><font style="vertical-align: inherit;">, die vom Engine-Rendering-Prozess verwendet wird, und setzen dann die boolesche Variable zur√ºck (verwenden Sie sie).</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf der Player Controller-Seite sind die √Ñnderungen minimal. </font><font style="vertical-align: inherit;">Sie m√ºssen dem Header eine Variable hinzuf√ºgen, um einen Link zur nativen LocalPlayer-Klasse zu speichern:</font></font><br><br><pre> <code class="cpp hljs"> UPROPERTY() UExedreLocalPlayer* LocalPlayer;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BeginPlay ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"> LocalPlayer = Cast&lt;UExedreLocalPlayer&gt;( GetLocalPlayer() );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich habe auch eine Funktion hinzugef√ºgt, um Cut schnell zu starten: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePlayerController::PerformCameraCut() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( LocalPlayer != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { LocalPlayer-&gt;PerformCameraCut(); } }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich </font><font style="vertical-align: inherit;">k√∂nnen wir </font><font style="vertical-align: inherit;">in der Portal Manager-Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RequestTeleportByPortal ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> w√§hrend der Camera Cut-Teleportation </font><b><font style="vertical-align: inherit;">Folgendes</font></b><font style="vertical-align: inherit;"> ausf√ºhren:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;PerformCameraCut(); } [...]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und das ist alles! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camera Cut muss aufgerufen werden, bevor SceneCapture aktualisiert wird. Deshalb befindet es sich am Anfang der Funktion.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Endergebnis </font></font></h2><br> <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir gelernt, in Portalen zu denken. </font></font></a></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das System gut funktioniert, sollten wir in der Lage sein, folgende Dinge zu erstellen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie Probleme haben, √ºberpr√ºfen Sie Folgendes: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellen Sie sicher, dass Portal Manager ordnungsgem√§√ü erstellt und initialisiert wurde. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Renderziel wird korrekt erstellt (Sie k√∂nnen das im Inhaltsbrowser erstellte Ziel zum Starten verwenden). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Portale sind korrekt aktiviert und deaktiviert. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bei Portalen ist der Zieldarsteller im Editor richtig eingestellt. </font></font></li></ul><br><h2>  Fragen und Antworten </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die beliebtesten Fragen, die mir zu diesem Tutorial gestellt wurden: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es m√∂glich, dies auf Blunts und nicht √ºber C ++ zu implementieren? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Gro√üteil des Codes kann mit Ausnahme von zwei Aspekten in Blunts implementiert werden:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zum </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abrufen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Projektionsmatrix verwendete </font><b><font style="vertical-align: inherit;">LocalPlayer-</font></b><font style="vertical-align: inherit;"> Funktion </font><b><font style="vertical-align: inherit;">GetProjectionData ()</font></b><font style="vertical-align: inherit;"> ist in Blaupausen nicht verf√ºgbar.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die LocalPlayer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Funktion </font><font style="vertical-align: inherit;">, die f√ºr die L√∂sung des Clipping-Systemproblems von entscheidender Bedeutung ist, ist in Blaupausen nicht verf√ºgbar.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher m√ºssen Sie entweder eine C ++ - Implementierung verwenden, um auf diese beiden Funktionen zuzugreifen, oder den Quellcode der Engine √§ndern, um sie √ºber Blaupausen zug√§nglich zu machen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann ich dieses System in VR verwenden? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ja, zum gr√∂√üten Teil. </font><font style="vertical-align: inherit;">Einige Teile m√ºssen jedoch angepasst werden, zum Beispiel:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen zwei Renderziele verwenden (eines f√ºr jedes Auge) und diese im Portalmaterial maskieren, um sie nebeneinander im Bildschirmbereich anzuzeigen. </font><font style="vertical-align: inherit;">Jedes Renderziel sollte halb so breit sein wie die Aufl√∂sung des VR-Ger√§ts.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie m√ºssen zwei SceneCapture verwenden, um das Ziel mit dem richtigen Abstand (dem Abstand zwischen den Augen) zu rendern und stereoskopische Effekte zu erzielen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hauptproblem wird die Leistung sein, da die andere Seite des Portals zweimal gerendert werden muss. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann ein anderes Objekt das Portal √ºberqueren? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mein Code enth√§lt keine. </font><font style="vertical-align: inherit;">Es ist jedoch nicht so schwierig, es allgemeiner zu gestalten. </font><font style="vertical-align: inherit;">Dazu muss das Portal weitere Informationen zu allen Objekten in der N√§he verfolgen, um zu √ºberpr√ºfen, ob sie diese √ºberqueren. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterst√ºtzt das System die Rekursion (Portal innerhalb des Portals)? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Tutorial ist nicht. </font><font style="vertical-align: inherit;">F√ºr die Rekursion ben√∂tigen Sie zus√§tzliches Renderziel und SceneCapture. </font><font style="vertical-align: inherit;">Au√üerdem muss festgelegt werden, welches RenderTarget zuerst gerendert werden soll, und so weiter. </font><font style="vertical-align: inherit;">Das ist ziemlich schwierig und ich wollte das nicht, weil dies f√ºr mein Projekt nicht notwendig ist. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann ich das Portal in der N√§he der Wand √ºberqueren?</font></font></b> <br><br>  Leider gibt es keine.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich sehe jedoch zwei M√∂glichkeiten, dies (theoretisch) umzusetzen: </font></font><br><br><ul><li>   ,      .  ,       . </li><li>   ,    ,    .       .   ,   ,       .         .    , , ,    ,  level streaming     . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448802/">https://habr.com/ru/post/de448802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448790/index.html">SpaceVIL - plattform√ºbergreifendes GUI-Framework f√ºr die Entwicklung auf .Net Core, .Net Standard und JVM</a></li>
<li><a href="../de448794/index.html">Python-Test mit Pytest. Plugins KAPITEL 5</a></li>
<li><a href="../de448796/index.html">Python-Test mit Pytest. Konfiguration, KAPITEL 6</a></li>
<li><a href="../de448798/index.html">Python-Test mit Pytest. Verwenden von pytest mit anderen Tools, KAPITEL 7</a></li>
<li><a href="../de448800/index.html">Konfigurieren Sie Visual Studio in Ihrer Organisation mit .vsconfig</a></li>
<li><a href="../de448804/index.html">Vorbereitungen f√ºr die geh√§rtete Laufzeit und den Notar von macOS</a></li>
<li><a href="../de448806/index.html">Erstellen eines Erweiterungssystems in der Qt-Bibliothek</a></li>
<li><a href="../de448810/index.html">Wie habe ich einen Hacker gefangen?</a></li>
<li><a href="../de448812/index.html">Mondmission ‚ÄûBereshit‚Äú - Suche nach der ersten Mondbibliothek nach Beginn des Unfalls ihres Tr√§gers</a></li>
<li><a href="../de448814/index.html">Bosque Language - Microsofts neue Programmiersprache</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>