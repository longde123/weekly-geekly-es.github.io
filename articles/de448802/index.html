<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👩🏻 👨🏿‍🤝‍👨🏾 🏻 Mit Portalen denken: Portale in Unreal Engine 4 erstellen 🚠 🍳 🍸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich Ihnen erklären, wie Sie Portale in Unreal Engine 4 erstellen. Ich habe keine Quellen gefunden, die ein solches System deta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mit Portalen denken: Portale in Unreal Engine 4 erstellen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448802/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif" alt="Bild"></div><br>  In diesem Artikel werde ich Ihnen erklären, wie Sie Portale in Unreal Engine 4 erstellen. Ich habe keine Quellen gefunden, die ein solches System detailliert beschreiben (Überwachung durch Portale und Weitergabe durch diese), daher habe ich beschlossen, meine eigenen zu schreiben. <br><br><h2>  Was ist ein Portal? </h2><br>  Beginnen wir mit Beispielen und Erklärungen, was ein Portal ist.  Der einfachste Weg, die Portale als einen Weg von einem Raum zum anderen zu beschreiben.  In einigen beliebten Spielen wird dieses Konzept für visuelle Effekte und sogar für die Spielmechanik verwendet: <br><br><div class="spoiler">  <b class="spoiler_title">Beispiele für Spielportale (GIF)</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/611/020/f86/611020f86b634e1946a79f86ee8c4024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/7b9/813/77d7b9813811fc5b1748d8d29c7599ad.gif"></div><br>  <i>Vorkammer (2013) und Portal (2007)</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/671/ad1/527671ad1b23838f56c324d350bf2e1e.gif"></div><br>  <i>Beute, 2006</i> </div></div><br>  Das berühmteste der drei Spiele ist wahrscheinlich Portal, aber ich persönlich habe Prey immer bewundert und sie wollte sie kopieren.  Einmal habe ich versucht, meine eigene Version in Unreal Engine 4 zu implementieren, aber es gelang mir nicht wirklich, da der Engine die Funktionalität fehlte.  Trotzdem gelang es mir, diese Experimente durchzuführen: <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Ihr Browser unterstützt kein HTML5-Video. <source src="http://froyok.fr/vine_archive/videos/1318354931002269696.mp4" type="video/mp4"></video></div></div></div><br>  Erst in neuen Versionen von Unreal Engine gelang es mir jedoch, den gewünschten Effekt zu erzielen: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5lga4ppJiuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Portale - wie funktionieren sie? </h2><br>  Bevor wir mit den Einzelheiten fortfahren, schauen wir uns das allgemeine Bild der Funktionsweise von Portalen an. <br><br>  Tatsächlich ist ein Portal ein Fenster, das nicht nach draußen geht, sondern an einen anderen Ort. Das heißt, wir legen lokal einen bestimmten Ansichtspunkt relativ zum Objekt fest und replizieren diesen Ansichtspunkt an einer anderen Stelle.  Mit diesem Prinzip können wir zwei Räume verbinden, auch wenn sie sehr weit voneinander entfernt sind.  Das Fenster ähnelt einer Maske, mit der wir herausfinden können, wo und wann ein anderer Bereich anstelle des ursprünglichen angezeigt werden soll.  Da der Ausgangspunkt der Sichtweise an anderer Stelle wiederholt wird, entsteht die Illusion von Kontinuität. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/d56/84b/6b3d5684bf30d66c8b60d551049f7a9b.png"></div><br>  In diesem Bild befindet sich das Aufnahmegerät (SceneCapture in UE4) vor dem Raum, der dem Raum aus der Sicht des Spielers entspricht.  Alles, was nach der Linie sichtbar ist, wird durch das ersetzt, was die Aufnahme sehen kann.  Da sich das Erfassungsgerät zwischen der Tür und anderen Objekten befinden kann, ist es wichtig, die sogenannte „Clipping-Ebene“ zu verwenden.  Im Fall des Portals möchten wir, dass die enge Schnittebene die vor dem Portal sichtbaren Objekte maskiert. <br><br>  Zusammenfassend.  Wir brauchen: <br><br><ul><li>  Standort des Spielers </li><li>  Portal-Einstiegspunkt </li><li>  Portalausgangspunkt </li><li>  Clipping-Gerät mit Clipping-Ebene </li></ul><br>  Wie implementiere ich das in Unreal Engine? <br><br>  Ich habe mein System auf der Grundlage von zwei Hauptklassen erstellt, die von <b>PlayerController</b> und <b>Character verwaltet werden</b> .  Die <b>Portal-</b> Klasse ist ein echter Portal-Einstiegspunkt, dessen Ansichts- / Austrittspunkt der Zielakteur ist.  Es gibt auch einen <b>Portal-Manager</b> , der vom PlayerController generiert und von Character aktualisiert wird, um jedes Portal auf der Ebene zu verwalten und zu aktualisieren sowie das SceneCapture-Objekt (das allen Portalen gemeinsam ist) zu bearbeiten. <br><br><blockquote>  Beachten Sie, dass das Lernprogramm erwartet, dass Sie über Code auf die Klassen Character und PlayerController zugreifen können.  In meinem Fall heißen sie ExedreCharacter und ExedrePlayerController. </blockquote><br><h2>  Erstellen einer Portal Actor Class </h2><br>  Beginnen wir mit dem Akteur des Portals, mit dem die „Fenster“ festgelegt werden, durch die wir die Ebene betrachten.  Die Aufgabe des Schauspielers besteht darin, Informationen über den Spieler bereitzustellen, um verschiedene Positionen und Züge zu berechnen.  Er wird auch erkennen, ob der Spieler das Portal überquert, und seine Teleportation. <br><br>  Bevor ich mit einer ausführlichen Diskussion des Schauspielers beginne, möchte ich einige Konzepte erläutern, die ich zur Verwaltung des Portalsystems erstellt habe: <br><br><ul><li>  Zur bequemen Ablehnung von Berechnungen hat das Portal einen Aktiv-Inaktiv-Status.  Dieser Status wird vom Portal Manager aktualisiert. </li><li>  Das Portal hat Vorder- und Rückseite, die durch seine Position und Richtung (Vorwärtsvektor) bestimmt werden. </li><li>  Um herauszufinden, ob der Spieler das Portal überquert, speichert er die vorherige Position des Spielers und vergleicht sie mit der aktuellen.  Wenn sich der Spieler im vorherigen Takt vor dem Portal und im aktuellen - hinter ihm - befand, glauben wir, dass der Spieler es überquert hat.  Das umgekehrte Verhalten wird ignoriert. </li><li>  Das Portal verfügt über eine begrenzte Lautstärke, um keine Berechnungen und Überprüfungen durchzuführen, bis sich der Player in dieser Lautstärke befindet.  Beispiel: Ignorieren Sie die Kreuzung, wenn der Player das Portal nicht berührt. </li><li>  Der Standort des Spielers wird aus dem Standort der Kamera berechnet, um ein korrektes Verhalten sicherzustellen, wenn der Blickwinkel das Portal überquert, nicht jedoch den Körper des Spielers. </li><li>  Das Portal erhält ein Renderziel, das in jeder Kennzahl einen anderen Blickwinkel anzeigt, falls die Textur beim nächsten Mal falsch ist und ersetzt werden muss. </li><li>  Das Portal speichert einen Link zu einem anderen Akteur namens Target, um zu wissen, wo der andere Bereich kontaktiert werden soll. </li></ul><br>  Mit diesen Regeln habe ich eine neue ExedrePortal-Klasse erstellt, die von AActor als Ausgangspunkt geerbt wurde.  Hier ist der Titel: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortal.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API AExedrePortal : public AActor { GENERATED_UCLASS_BODY() protected: virtual void BeginPlay() override; public: virtual void Tick(float DeltaTime) override; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Status of the Portal (being visualized by the player or not) UFUNCTION(BlueprintPure, Category="Exedre|Portal") bool IsActive(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetActive( bool NewActive ); //Render target to use to display the portal UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void ClearRTT(); UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void SetRTT( UTexture* RenderTexture ); UFUNCTION(BlueprintNativeEvent, Category="Exedre|Portal") void ForceTick(); //Target of where the portal is looking UFUNCTION(BlueprintPure, Category="Exedre|Portal") AActor* GetTarget(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetTarget( AActor* NewTarget ); //Helpers UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void TeleportActor( AActor* ActorToTeleport ); protected: UPROPERTY(BlueprintReadOnly) USceneComponent* PortalRootComponent; private: bool bIsActive; AActor* Target; //Used for Tracking movement of a point FVector LastPosition; bool LastInFront; };</span></span></span></span></code> </pre> <br>  Wie Sie sehen können, gibt es die meisten der hier beschriebenen Verhaltensweisen.  Nun wollen wir sehen, wie sie im Körper verarbeitet werden (.cpp). <br><br><hr><br>  Der Designer hier bereitet die Stammkomponenten vor.  Ich habe beschlossen, zwei Stammkomponenten zu erstellen, da der Portal-Akteur sowohl grafische Effekte als auch Kollisionen / Erkennung kombiniert.  Daher brauchte ich eine einfache Methode, um festzustellen, wo sich die Fenster- / Portalebene befindet, ohne dass Bluetooth-Funktionen oder andere Tricks erforderlich sind.  PortalRootComponent ist die Basis für alle Berechnungen im Zusammenhang mit dem Portal. <br><br>  Das Portalstammverzeichnis ist auf dynamisch eingestellt, falls die Blueprint-Klasse es animiert (verwendet beispielsweise eine Open / Close-Animation). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Sets default values AExedrePortal::AExedrePortal(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = true; bIsActive = false; RootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("RootComponent")); RootComponent-&gt;Mobility = EComponentMobility::Static; PortalRootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("PortalRootComponent")); PortalRootComponent-&gt;SetupAttachment( GetRootComponent() ); PortalRootComponent-&gt;SetRelativeLocation( FVector(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;SetRelativeRotation( FRotator(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;Mobility = EComponentMobility::Movable; }</span></span></code> </pre> <br><hr><br>  Es gibt nur Get- und Set-Funktionen und nichts weiter.  Wir werden den Aktivitätsstatus von einem anderen Ort aus verwalten. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsActive() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bIsActive; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetActive( <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> NewActive ) { bIsActive = NewActive; }</code> </pre> <br><hr><br>  Blueprint-Ereignisse, ich mache nichts in der C ++ - Klasse. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ClearRTT_Implementation() { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetRTT_Implementation( UTexture* RenderTexture ) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ForceTick_Implementation() { }</code> </pre> <br><hr><br>  Die Funktionen Get und Set für den Zielakteur.  Auch in diesem Teil gibt es nichts Komplizierteres. <br><br><pre> <code class="cpp hljs">AActor* AExedrePortal::GetTarget() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Target; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetTarget( AActor* NewTarget ) { Target = NewTarget; }</code> </pre> <br><hr><br>  Mit dieser Funktion können wir leicht überprüfen, ob sich ein Punkt vor einer Ebene befindet, und in unserem Fall handelt es sich um ein Portal.  Die Funktion verwendet die FPlane-Struktur der UE4-Engine, um Berechnungen durchzuführen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-comment"><span class="hljs-comment">//If &lt; 0 means we are behind the Plane //See : http://api.unrealengine.com/INT/API/Runtime/Core/Math/FPlane/PlaneDot/index.html return ( PortalDot &gt;= 0 ); }</span></span></code> </pre> <br><hr><br>  Diese Funktion prüft, ob der Punkt die Portalebene überschritten hat.  Hier verwenden wir die alte Position, um herauszufinden, wie sich der Punkt verhält.  Diese Funktion ist üblich, damit sie mit jedem Schauspieler funktioniert, aber in meinem Fall wird sie nur mit dem Player verwendet. <br><br>  Die Funktion erstellt eine Richtung / ein Segment zwischen dem vorherigen und dem aktuellen Standort und prüft dann, ob sie die Ebene schneiden.  Wenn ja, prüfen wir, ob es sich in die richtige Richtung kreuzt (von vorne nach hinten?). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FVector IntersectionPoint; FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCrossing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsInFront = PortalDot &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsIntersect = FMath::SegmentPlaneIntersection( LastPosition, Point, PortalPlane, IntersectionPoint ); <span class="hljs-comment"><span class="hljs-comment">//Did we intersect the portal since last Location ? //If yes, check the direction : crossing forward means we were in front and now at the back //If we crossed backward, ignore it (similar to Prey 2006) if( IsIntersect &amp;&amp; !IsInFront &amp;&amp; LastInFront ) { IsCrossing = true; } //Store values for Next check LastInFront = IsInFront; LastPosition = Point; return IsCrossing; }</span></span></code> </pre> <br><h2>  Schauspieler teleportieren </h2><br>  Der letzte Teil des Portal-Akteurs, den wir uns ansehen werden, ist die <b>TeleportActor ()</b> -Funktion. <br><br>  Wenn Sie einen Schauspieler von Punkt A nach Punkt B teleportieren, müssen Sie seine Bewegung und Position nachbilden.  Wenn zum Beispiel ein Spieler das Portal betritt, scheint es ihm in Kombination mit geeigneten visuellen Effekten, dass er durch eine gewöhnliche Tür gegangen ist. <br><br>  Der Schnittpunkt des Portals fühlt sich an, als würde man sich in einer geraden Linie bewegen, aber in Wirklichkeit passiert etwas völlig anderes.  Beim Verlassen des Portals befindet sich der Spieler möglicherweise in einem ganz anderen Kontext.  Betrachten Sie ein Beispiel aus Portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/185/809/d4f/185809d4fd81675cdd6f1cc871eaf193.gif"></div><br>  Wie Sie sehen können, dreht sich die Kamera beim Überqueren des Portals relativ zu ihrem Vorwärtsvektor (dreht sich).  Dies liegt daran, dass Start- und Endpunkt parallel zu verschiedenen Ebenen liegen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/072/97f/b30/07297fb30171a80c1cc0d831701feb74.jpg"></div><br>  Damit dies funktioniert, müssen wir die Bewegung des Spielers in den relativen Bereich des Portals umwandeln, um sie in den Zielbereich umzuwandeln.  Durch diese Implementierung können wir sicher sein, dass der Spieler nach dem Betreten des Portals und dem Verlassen der anderen Seite korrekt in Bezug auf den Platz ausgerichtet ist.  Dies gilt nicht nur für die Position und Rotation des Schauspielers, sondern auch für seine <b>Geschwindigkeit</b> . <br><br><blockquote>  Wenn wir einen Schauspieler ohne Änderungen teleportieren und ihn in eine lokale Rotation umwandeln, kann sich der Schauspieler auf den Kopf stellen.  Dies kann für Objekte geeignet sein, gilt jedoch nicht für die Charaktere oder den Spieler selbst.  Sie müssen die Position des Schauspielers ändern, wie oben im Beispiel von Portal gezeigt. </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::TeleportActor( AActor* ActorToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ActorToTeleport == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//------------------------------- //Retrieve and save Player Velocity //(from the Movement Component) //------------------------------- FVector SavedVelocity = FVector::ZeroVector; AExedreCharacter* EC = nullptr; if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { EC = Cast&lt;AExedreCharacter&gt;( ActorToTeleport ); SavedVelocity = EC-&gt;GetCharMovementComponent()-&gt;GetCurrentVelocity(); } //------------------------------- //Compute and apply new location //------------------------------- FHitResult HitResult; FVector NewLocation = UTool::ConvertLocationToActorSpace( ActorToTeleport-&gt;GetActorLocation(), this, Target ); ActorToTeleport-&gt;SetActorLocation( NewLocation, false, &amp;HitResult, ETeleportType::TeleportPhysics ); //------------------------------- //Compute and apply new rotation //------------------------------- FRotator NewRotation = UTool::ConvertRotationToActorSpace( ActorToTeleport-&gt;GetActorRotation(), this, Target ); //Apply new rotation ActorToTeleport-&gt;SetActorRotation( NewRotation ); //------------------------------- //If we are teleporting a character we need to //update its controller as well and reapply its velocity //------------------------------- if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { //Update Controller AExedrePlayerController* EPC = EC-&gt;GetPlayerController(); if( EPC != nullptr ) { NewRotation = UTool::ConvertRotationToActorSpace( EPC-&gt;GetControlRotation(), this, Target ); EPC-&gt;SetControlRotation( NewRotation ); } //Reapply Velocity (Need to reorient direction into local space of Portal) { FVector Dots; Dots.X = FVector::DotProduct( SavedVelocity, GetActorForwardVector() ); Dots.Y = FVector::DotProduct( SavedVelocity, GetActorRightVector() ); Dots.Z = FVector::DotProduct( SavedVelocity, GetActorUpVector() ); FVector NewVelocity = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); EC-&gt;GetCharMovementComponent()-&gt;Velocity = NewVelocity; } } //Cleanup Teleport LastPosition = NewLocation; }</span></span></code> </pre> <br><hr><br>  Wie Sie wahrscheinlich bemerkt haben, rufe ich externe Funktionen auf, um Rotation / Position aufzurufen.  Sie werden von der UTool-Benutzerklasse aufgerufen, die statische Funktionen definiert, die von überall aufgerufen werden können (einschließlich Blaupausen).  Ihr Code wird unten gezeigt. Sie können sie so implementieren, wie es Ihnen am besten erscheint (es ist wahrscheinlich einfacher, sie einfach in die Portal-Actor-Klasse einzufügen). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FVector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertLocationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Location, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FVector::ZeroVector; } FVector Direction = Location - Reference-&gt;GetActorLocation(); FVector TargetLocation = Target-&gt;GetActorLocation(); FVector Dots; Dots.X = FVector::DotProduct( Direction, Reference-&gt;GetActorForwardVector() ); Dots.Y = FVector::DotProduct( Direction, Reference-&gt;GetActorRightVector() ); Dots.Z = FVector::DotProduct( Direction, Reference-&gt;GetActorUpVector() ); FVector NewDirection = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TargetLocation + NewDirection; }</code> </pre> <br>  Die Transformation wird hier durchgeführt, indem das Skalarprodukt von Vektoren berechnet wird, um verschiedene Winkel zu bestimmen.  Der Richtungsvektor ist nicht normalisiert, dh wir können das Punktergebnis erneut mit Zielvektoren multiplizieren, um die Position im lokalen Raum des Zielakteurs in genau derselben Entfernung zu erhalten. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FRotator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertRotationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FRotator Rotation, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FRotator::ZeroRotator; } FTransform SourceTransform = Reference-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat QuatRotation = FQuat( Rotation ); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * QuatRotation; FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewWorldQuat.Rotator(); }</code> </pre> <br>  Die Transformation zu drehen war etwas schwieriger umzusetzen.  Am Ende stellte sich heraus, dass die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Quaternionen</a> die beste Lösung war, da dies viel genauer ist als die Arbeit mit normalen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Euler-Winkeln</a> und nur wenige Codezeilen erfordert.  Rotationen durch Quaternionen werden mithilfe der Multiplikation ausgeführt. In unserem Fall wird Inverse () auf die Rotation angewendet, die konvertiert werden soll, und in den lokalen Raum verschoben.  Als nächstes müssen wir es nur noch einmal mit der Zielrunde multiplizieren, um die letzte Runde zu erhalten. <br><br><h2>  Erstellen eines Portalnetzes </h2><br>  Um aus der Sicht eines Spielers schön auszusehen, verwendet mein Portalsystem ein bestimmtes Netz.  Das Netz ist in zwei verschiedene Ebenen unterteilt: <br><br><ul><li>  <b>Ebene 1</b> : Die Hauptebene, auf der das Renderziel des Portals angezeigt wird.  Dieses Flugzeug hat ein eher ungewöhnliches Verhalten, da es die Aufgabe hat, sich ein wenig vom Spieler abzuheben, wenn er sich nähert, um ein Abschneiden durch die Kamera zu vermeiden.  Da sich die Ränder des Flugzeugs nicht bewegen, sondern nur die mittleren Spitzen, kann der Spieler das Rendern des Portals ohne visuelle Artefakte überlagern.  Die Kanten an den Kanten haben in der oberen Hälfte eine eigene UV-Strahlung, während die Innenkanten in der unteren Hälfte eine eigene UV-Strahlung haben, wodurch es einfach ist, sie im Shader zu maskieren. </li><li>  <b>Ebene 2</b> : Diese Ebene wird nur zum Erweitern des Standardbegrenzungsrahmens des Netzes verwendet.  Die Normalen der Scheitelpunkte sind nach unten gerichtet, sodass das Netz selbst auf nicht planarem Boden standardmäßig nicht sichtbar ist (da das Rendering-Material nicht zweiseitig ist). </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72e/125/f6f/72e125f6fd315caa2777f65dc0eaf39a.gif"></div><br>  Warum ein solches Netz verwenden? <br><br>  Ich entschied, dass sich "Flugzeug 1" ausdehnen würde, wenn sich der Spieler näherte.  Dadurch kann der Spieler das Portal überlappen und es passieren, ohne es zu beschneiden (zu schneiden).  Dies kann beispielsweise passieren, wenn die Kamera die Ebene des Portals noch nicht überquert hat, die Füße des Spielers sie jedoch bereits berührt haben.  Auf diese Weise können Sie den Player nicht abschneiden und das Netz andererseits duplizieren. <br><br>  Die Aufgabe „Ebene 2“ besteht darin, den Standardbegrenzungsrahmen des Netzes zu erweitern.  Da „Ebene 1“ flach ist, hat der Begrenzungsrahmen auf einer Achse eine Dicke von 0, und wenn sich die Kamera dahinter befindet, wird er vom Motor abgeschnitten (dh nicht gerendert).  Ebene 1 hat eine Größe von 128 × 128, sodass sie mit der Engine einfach skaliert werden kann.  Ebene 2 ist etwas größer und befindet sich unter dem Boden (unter 0). <br><br>  Nachdem wir das Netz erstellt haben, exportieren wir es einfach aus einem 3D-Editor eines Drittanbieters und importieren es in Unreal.  Es wird im nächsten Schritt verwendet. <br><br><h2>  Portalmaterial erstellen </h2><br>  Um die andere Seite des Portals anzuzeigen, müssen wir unser eigenes Material erstellen.  Erstellen Sie neues Material im Inhaltsbrowser (ich habe es <b>MAT_PortalBase genannt</b> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b0/402/a9c/7b0402a9cd6c6d62438e06fa3a7cd1f4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dea/96c/a1b/dea96ca1b613a92acc7ca35e0bbe44b1.png"></div><br>  Öffnen Sie es nun und erstellen Sie das folgende Diagramm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfe/4fa/c17/cfe4fac175e5e399c9e615a6afd0b800.jpg"></div><br>  So funktioniert das Material: <br><br><ul><li>  <b>FadeColor</b> ist die Farbe, die durch das Portal sichtbar ist, wenn es sehr weit entfernt ist.  Dies ist erforderlich, da nicht immer alle Portale gerendert werden. Daher wird das Rendern verdeckt, wenn der Player / die Kamera weit entfernt ist. </li><li>  Um herauszufinden, wie weit der Player vom Portal entfernt ist, bestimme ich den <b>Abstand</b> zwischen Kameraposition und Schauspielerposition.  Dann dividiere ich den Abstand durch den Maximalwert, mit dem ich einen Vergleich durchführen möchte.  Wenn zum Beispiel das von mir festgelegte Maximum 2000 ist und die Entfernung zum Spieler 1000 beträgt, erhalten wir 0,5.  Wenn der Spieler weiter ist, erhalte ich einen Wert größer als 1, daher verwende ich gesättigte Knoten, um ihn zu begrenzen.  Als nächstes kommt der Smoothstep-Knoten, mit dem die Entfernung als Farbverlauf skaliert und die Portalschattierung genauer gesteuert wird.  Wenn der Player beispielsweise in der Nähe ist, verschwindet der Schatten vollständig. </li><li>  Ich verwende die Entfernungsberechnung als Alpha-Kanalwert für den <b>Lerp-</b> Knoten, um die Schattierungsfarbe und die <b>Textur</b> zu mischen, die das <b>Portalziel</b> rendern. </li><li>  Schließlich isoliere ich die Y-Komponente der UV-Koordinaten, um eine Maske zu erstellen, mit der Sie wissen, welche Scheitelpunkte des Netzes verschoben werden.  Ich multipliziere diese Maske mit der Abstoßungsmenge, die ich brauche.  Ich verwende einen negativen Wert, damit sich die Normalen der Scheitelpunkte, wenn sie mit den Scheitelpunkten multipliziert werden, in die entgegengesetzte Richtung bewegen. </li></ul><br>  Nachdem wir dies alles getan haben, haben wir gebrauchsfertiges Material erstellt. <br><br><h2>  Erstellen eines Portal Actor in Blueprint </h2><br>  Lassen Sie uns eine neue Blueprint-Klasse einrichten, die vom Portal-Akteur erbt.  Klicken Sie mit der rechten Maustaste auf den Inhaltsbrowser und wählen Sie die Blueprint-Klasse aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/28b/5a2/ead28b5a23369c2c86a076ec8bb1dda0.png"></div><br>  Geben Sie nun "Portal" in das Suchfeld ein, um die Portalklasse auszuwählen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/da4/555/bd7da4555cff2dc953ab3b0b0f4d1057.png"></div><br>  Öffnen Sie Bluetooth, falls es noch nicht geöffnet ist.  In der Liste der Komponenten sehen Sie die folgende Hierarchie: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/34c/308/73c34c308a70f644759dc9057b0facd2.png"></div><br>  Wie erwartet gibt es eine Root-Komponente und ein Portal-Root.  Fügen wir PortalRootComponent eine statische Netzkomponente hinzu und laden das im vorherigen Schritt erstellte Netz hinein: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/ef3/11d/fa4ef311d11c803afc565060a9902c24.jpg"></div><br><hr><br>  Wir fügen auch die Kollisionsbox hinzu, mit der bestimmt wird, ob sich der Player innerhalb des Portal-Volumes befindet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b0/28f/df6/0b028fdf696598f6b3eca9af3049caa1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2a/85d/747/c2a85d747c8b76900cae32e9f9cc1a59.png"></div><br>  Das Feld Kollision befindet sich unter der Szenenkomponente, die dem Hauptstamm zugeordnet ist, und nicht unter dem Portalstamm.  Ich habe auch ein Symbol (Werbetafel) und eine Pfeilkomponente hinzugefügt, um das Portal auf den Ebenen besser sichtbar zu machen.  Dies ist natürlich nicht erforderlich. <br><br>  Lassen Sie uns nun das Material in Blaupause einrichten. <br><br>  Zunächst benötigen wir zwei Variablen - eine vom Typ <b>Actor</b> und der Name <b>PortalTarget</b> , die zweite vom Typ <b>Dynamic Material Instance</b> und heißt <b>MaterialInstance</b> .  PortalTarget ist ein Verweis auf die Position, auf die das Portalfenster schaut (daher ist die Variable häufig mit einem Symbol für offenes Auge), damit wir sie ändern können, wenn der Akteur auf der Ebene platziert wird.  MaterialInstance speichert einen Link zu dynamischem Material, damit wir in Zukunft das Renderziel des Portals im laufenden Betrieb zuweisen können. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/0b9/772/4740b9772dfc7ce30cda63300f1682a5.png"></div><br>  Wir müssen auch unsere eigenen Ereignisknoten hinzufügen.  Öffnen Sie am besten das Kontextmenü im <b>Ereignisdiagramm</b> und suchen Sie die Namen der Ereignisse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/719/d22/bc2719d224381581c9bdb8ea5ce7c365.png"></div><br>  Und hier, um das folgende Diagramm zu erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f4/400/24f/0f440024f5c322c6640609bb8d20bcad.jpg"></div><br><ul><li>  <b>Spiel</b> starten: Hier rufen wir die übergeordnete Funktion SetTarget () des Portals auf, um ihm einen Link zum Schauspieler zuzuweisen, der später für SceneCapture verwendet wird.  Anschließend erstellen wir ein neues dynamisches Material und weisen ihm den Wert der MaterialInstance-Variablen zu.  Mit diesem neuen Material können wir es der statischen Netzkomponente zuweisen.  Ich habe dem Material auch eine Dummy-Textur gegeben, aber dies ist optional. </li><li>  <b>RTT</b> löschen: Mit dieser Funktion wird die dem Portalmaterial zugewiesene Renderziel-Textur gelöscht.  Es wird vom Portal-Manager gestartet. </li><li>  <b>RTT</b> festlegen: Mit dieser Funktion wird das Renderzielmaterial des Portals festgelegt.  Es wird vom Portal-Manager gestartet. </li></ul><br>  Bisher sind wir mit Bluetooth fertig, aber wir werden später darauf zurückkommen, um Tick-Funktionen zu implementieren. <br><br><h2>  Portal Manager </h2><br>  Jetzt haben wir alle grundlegenden Elemente, die zum Erstellen einer neuen Klasse erforderlich sind, die von AActor geerbt wurde, nämlich Portal Manager.  Möglicherweise benötigen Sie die Portal Manager-Klasse nicht in Ihrem Projekt, aber in meinem Fall vereinfacht dies die Arbeit mit einigen Aspekten erheblich.  Hier ist eine Liste der vom Portal-Manager ausgeführten Aufgaben: <br><br><ul><li>  Der Portal-Manager ist ein <b>vom Player-Controller erstellter</b> und damit verbundener Akteur, um den Status und die Entwicklung des Spielers innerhalb der Spielebene zu verfolgen. </li><li>  Renderzielportal erstellen und zerstören.  Die Idee ist, dynamisch eine Render-Zieltextur zu erstellen, die der Bildschirmauflösung des Players entspricht.  Wenn Sie die Auflösung während des Spiels ändern, konvertiert der Manager sie automatisch in die gewünschte Größe. </li><li>  Der Portal-Manager <b>findet und aktualisiert</b> die Portal-Darstellerebene, um ihnen ein Renderziel zu geben.  Diese Aufgabe wird so ausgeführt, dass die Kompatibilität mit Level-Streaming gewährleistet ist.  Wenn ein neuer Schauspieler erscheint, sollte er eine Textur bekommen.  Wenn sich das Renderziel ändert, kann der Manager außerdem automatisch ein neues Ziel zuweisen.  Dies erleichtert die Verwaltung des Systems, anstatt dass jeder Portal-Akteur den Manager manuell kontaktiert. </li><li>  Die <b>SceneCapture-</b> Komponente <b>ist</b> an den Portal-Manager angehängt, um nicht für jedes Portal eine Kopie zu erstellen.  Darüber hinaus können Sie es jedes Mal wiederverwenden, wenn wir zu einem bestimmten Portal-Akteur auf der Ebene wechseln. </li><li>  Wenn das Portal beschließt, <b>den</b> Player zu <b>teleportieren</b> , sendet es eine Anfrage an Portal Manager.  Dies ist erforderlich, um sowohl das Quell- als auch das Zielportal (falls vorhanden) zu aktualisieren, sodass der Übergang ohne Verbindungen erfolgt. </li><li>  <b>Der</b> Portal-Manager wird am Ende der Funktion " <b>Character tick ()"</b> aktualisiert, sodass alles korrekt aktualisiert wird, einschließlich der Kamera des Players.  Dies stellt sicher, dass alles auf dem Bildschirm synchronisiert ist, und vermeidet eine Verzögerung von einem Frame während des Renderns durch die Engine. </li></ul><br>  Werfen wir einen Blick auf den Portal Manager-Header: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortalManager.generated.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Forward declaration class AExedrePlayerController; class AExedrePortal; class UExedreScriptedTexture; UCLASS() class EXEDRE_API AExedrePortalManager : public AActor { GENERATED_UCLASS_BODY() public: AExedrePortalManager(); //Called by a Portal actor when wanting to teleport something UFUNCTION(BlueprintCallable, Category="Portal") void RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ); //Save a reference to the PlayerControler void SetControllerOwner( AExedrePlayerController* NewOwner ); //Various setup that happens during spawn void Init(); //Manual Tick void Update( float DeltaTime ); //Find all the portals in world and update them //returns the most valid/usable one for the Player AExedrePortal* UpdatePortalsInWorld(); //Update SceneCapture void UpdateCapture( AExedrePortal* Portal ); //Accessor for Debug purpose UTexture* GetPortalTexture(); //Accessor for Debug purpose FTransform GetCameraTransform(); private: //Function to create the Portal render target void GeneratePortalTexture(); UPROPERTY() USceneCaptureComponent2D* SceneCapture; //Custom class, can be replaced by a "UCanvasRenderTarget2D" instead //See : https://api.unrealengine.com/INT/API/Runtime/Engine/Engine/UCanvasRenderTarget2D/index.html UPROPERTY() UExedreScriptedTexture* PortalTexture; UPROPERTY() AExedrePlayerController* ControllerOwner; int32 PreviousScreenSizeX; int32 PreviousScreenSizeY; float UpdateDelay; };</span></span></span></span></code> </pre> <br><hr><br>  Bevor ich auf Details eingehe, werde ich zeigen, wie ein Akteur aus der Player Controller-Klasse erstellt wird, die von der BeginPlay () -Funktion aufgerufen wird: <br><br><pre> <code class="cpp hljs"> FActorSpawnParameters SpawnParams; PortalManager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PortalManager = GetWorld()-&gt;SpawnActor&lt;AExedrePortalManager&gt;( AExedrePortalManager::StaticClass(), FVector::ZeroVector, FRotator::ZeroRotator, SpawnParams); PortalManager-&gt;AttachToActor( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, FAttachmentTransformRules::SnapToTargetIncludingScale); PortalManager-&gt;SetControllerOwner( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); PortalManager-&gt;Init();</code> </pre> <br>  Also erstellen wir einen Akteur, hängen ihn an den Controller des Players an (diesen), speichern den Link und rufen die Funktion Init () auf. <br><br>  Es ist auch wichtig zu beachten, dass wir den Akteur manuell aus der Zeichenklasse aktualisieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedreCharacter::TickActor( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime, <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELevelTick TickType, FActorTickFunction&amp; ThisTickFunction ) { Super::TickActor( DeltaTime, TickType, ThisTickFunction ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) ); EPC-&gt;PortalManager-&gt;Update( DeltaTime ); } }</code> </pre> <br>  Und hier ist der Konstruktor von Portal Manager.  Beachten Sie, dass Tick wieder deaktiviert ist, da wir Portal Manager manuell über den Player aktualisieren. <br><br><pre> <code class="cpp hljs">AExedrePortalManager::AExedrePortalManager(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; PortalTexture = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; UpdateDelay = <span class="hljs-number"><span class="hljs-number">1.1f</span></span>; PreviousScreenSizeX = <span class="hljs-number"><span class="hljs-number">0</span></span>; PreviousScreenSizeY = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><hr><br>  Hier sind die Funktionen von get / set Portal Manager (danach werden wir zu interessanteren Dingen übergehen): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::SetControllerOwner( AExedrePlayerController* NewOwner ) { ControllerOwner = NewOwner; } FTransform AExedrePortalManager::GetCameraTransform() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( SceneCapture != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SceneCapture-&gt;GetComponentTransform(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FTransform(); } } UTexture* AExedrePortalManager::GetPortalTexture() { <span class="hljs-comment"><span class="hljs-comment">//Portal Texture is a custom component class that embed a UCanvasRenderTraget2D //The GetTexture() simply returns the RenderTarget contained in that class. //IsValidLowLevel() is used here as a way to ensure the Texture has not been destroyed or garbage collected. if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { return PortalTexture-&gt;GetTexture(); } else { return nullptr; } }</span></span></code> </pre> <br><hr><br>  Das erste, mit dem Sie beginnen, ist natürlich die Funktion <b>Init ()</b> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hauptziel dieser Funktion besteht darin, die SceneCapture-Komponente (dh das oben erwähnte Aufnahmegerät) zu erstellen und korrekt zu konfigurieren. </font><font style="vertical-align: inherit;">Es beginnt mit der Erstellung eines neuen Objekts und seiner Registrierung als Bestandteil dieses Akteurs. </font><font style="vertical-align: inherit;">Anschließend werden die Eigenschaften für diese Erfassung festgelegt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu erwähnende Eigenschaften:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bCaptureEveryFrame = false</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Wir möchten nicht, dass die Erfassung </font><b><font style="vertical-align: inherit;">aktiviert wird,</font></b><font style="vertical-align: inherit;"> wenn wir sie nicht benötigen. </font><font style="vertical-align: inherit;">Wir werden es manuell verwalten.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bEnableClipPlane = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Eine ziemlich wichtige Eigenschaft zum korrekten Rendern der Portalaufnahme.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bUseCustomProjectionMatrix = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dies ermöglicht es uns, die Capture-Projektion basierend auf dem Standpunkt des Players durch unsere eigene zu ersetzen.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CaptureSource = ESceneCaptureSource :: SCS_SceneColorSceneDepth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dieser Modus ist etwas teuer, aber erforderlich, um eine ausreichende Menge an Informationen zu rendern.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die übrigen Eigenschaften beziehen sich hauptsächlich auf die Nachbearbeitungsparameter. </font><font style="vertical-align: inherit;">Sie sind eine bequeme Möglichkeit, die Qualität zu kontrollieren und damit die Leistung zu erfassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der letzte Teil ruft die Funktion auf, mit der das Renderziel erstellt wird (siehe unten).</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Init() { <span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------ //Create Camera //------------------------------------------------ SceneCapture = NewObject&lt;USceneCaptureComponent2D&gt;(this, USceneCaptureComponent2D::StaticClass(), *FString("PortalSceneCapture")); SceneCapture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); SceneCapture-&gt;RegisterComponent(); SceneCapture-&gt;bCaptureEveryFrame = false; SceneCapture-&gt;bCaptureOnMovement = false; SceneCapture-&gt;LODDistanceFactor = 3; //Force bigger LODs for faster computations SceneCapture-&gt;TextureTarget = nullptr; SceneCapture-&gt;bEnableClipPlane = true; SceneCapture-&gt;bUseCustomProjectionMatrix = true; SceneCapture-&gt;CaptureSource = ESceneCaptureSource::SCS_SceneColorSceneDepth; //Setup Post-Process of SceneCapture (optimization : disable Motion Blur, etc) FPostProcessSettings CaptureSettings; CaptureSettings.bOverride_AmbientOcclusionQuality = true; CaptureSettings.bOverride_MotionBlurAmount = true; CaptureSettings.bOverride_SceneFringeIntensity = true; CaptureSettings.bOverride_GrainIntensity = true; CaptureSettings.bOverride_ScreenSpaceReflectionQuality = true; CaptureSettings.AmbientOcclusionQuality = 0.0f; //0=lowest quality..100=maximum quality CaptureSettings.MotionBlurAmount = 0.0f; //0 = disabled CaptureSettings.SceneFringeIntensity = 0.0f; //0 = disabled CaptureSettings.GrainIntensity = 0.0f; //0 = disabled CaptureSettings.ScreenSpaceReflectionQuality = 0.0f; //0 = disabled CaptureSettings.bOverride_ScreenPercentage = true; CaptureSettings.ScreenPercentage = 100.0f; SceneCapture-&gt;PostProcessSettings = CaptureSettings; //------------------------------------------------ //Create RTT Buffer //------------------------------------------------ GeneratePortalTexture(); }</span></span></code> </pre> <br><hr><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeneratePortalTexture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Funktion, die bei Bedarf aufgerufen wird, wenn Sie eine neue Renderziel-Textur für Portale erstellen müssen. </font><font style="vertical-align: inherit;">Dies geschieht in der Initialisierungsfunktion, kann aber auch während des Portal Manager-Upgrades aufgerufen werden. </font><font style="vertical-align: inherit;">Aus diesem Grund verfügt diese Funktion über eine interne Überprüfung zum Ändern der Auflösung des Ansichtsfensters. </font><font style="vertical-align: inherit;">Ist dies nicht der Fall, wird das Update nicht durchgeführt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In meinem Fall habe ich eine Wrapper-Klasse für UCanvasRenderTarget2D erstellt. Ich habe es ExedreScriptedTexture genannt, es ist eine Komponente, die an einen Schauspieler angehängt werden kann. Ich habe diese Klasse erstellt, um Renderziele bequem mit Akteuren zu verwalten, die Renderaufgaben haben. Er führt die ordnungsgemäße Initialisierung des Renderziels durch und ist mit meinem eigenen UI-System kompatibel. Im Kontext von Portalen ist eine reguläre RenderTarget2D-Textur jedoch mehr als ausreichend. Daher können Sie es einfach verwenden.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::GeneratePortalTexture() { int32 CurrentSizeX = <span class="hljs-number"><span class="hljs-number">1920</span></span>; int32 CurrentSizeY = <span class="hljs-number"><span class="hljs-number">1080</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;GetViewportSize(CurrentSizeX, CurrentSizeY); } CurrentSizeX = FMath::Clamp( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(CurrentSizeX / <span class="hljs-number"><span class="hljs-number">1.7</span></span>), <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1920</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1920 / 1.5 = 1280 CurrentSizeY = FMath::Clamp( int(CurrentSizeY / 1.7), 128, 1080); if( CurrentSizeX == PreviousScreenSizeX &amp;&amp; CurrentSizeY == PreviousScreenSizeY ) { return; } PreviousScreenSizeX = CurrentSizeX; PreviousScreenSizeY = CurrentSizeY; //Cleanup existing RTT if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { PortalTexture-&gt;DestroyComponent(); GEngine-&gt;ForceGarbageCollection(); } //Create new RTT PortalTexture = nullptr; PortalTexture = NewObject&lt;UExedreScriptedTexture&gt;(this, UExedreScriptedTexture::StaticClass(), *FString("PortalRenderTarget")); PortalTexture-&gt;SizeX = CurrentSizeX; PortalTexture-&gt;SizeY = CurrentSizeY; //Custom properties of the UExedreScriptedTexture class PortalTexture-&gt;Gamma = 1.0f; PortalTexture-&gt;WrapModeX = 1; //Clamp PortalTexture-&gt;WrapModeY = 1; //Clamp PortalTexture-&gt;bDrawWidgets = false; PortalTexture-&gt;bGenerateMipMaps = false; PortalTexture-&gt;SetClearOnUpdate( false ); //Will be cleared by SceneCapture instead PortalTexture-&gt;Format = ERenderTargetFormat::RGBA16; //Needs 16b to get &gt;1 for Emissive PortalTexture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); PortalTexture-&gt;RegisterComponent(); PortalTexture-&gt;SetOwner( this ); PortalTexture-&gt;Init(); PortalTexture-&gt;SetFilterMode( TextureFilter::TF_Bilinear ); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie oben erwähnt, habe ich meine eigene Klasse erstellt, daher müssen die hier festgelegten Eigenschaften an das übliche Renderziel angepasst werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist wichtig zu verstehen, wo die Aufnahme angezeigt wird. </font><font style="vertical-align: inherit;">Da das Renderziel im Spiel angezeigt wird, bedeutet dies, dass dies vor der gesamten Nachbearbeitung geschieht. Daher müssen wir die Szene mit genügend Informationen rendern (um Werte über 1 zu speichern, um Bloom zu erstellen). </font><font style="vertical-align: inherit;">Aus diesem Grund habe ich das RGBA16-Format gewählt (beachten Sie, dass es eine eigene Aufzählung hat, Sie müssen stattdessen ETextureRenderTargetFormat verwenden). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Informationen finden Sie in den folgenden Quellen:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UTextureRenderTarget2D</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETextureRenderTargetFormat</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USceneCaptureComponent2D</font></font></a> </li></ul><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiter werden wir Update-Funktionen betrachten. </font><font style="vertical-align: inherit;">Die Grundfunktion ist recht einfach und komplexer. </font><font style="vertical-align: inherit;">Vor dem Aufrufen der Funktion GeneratePortalTexture () tritt eine Verzögerung auf, um zu vermeiden, dass das Renderziel beim Ändern der Größe des Ansichtsfensters neu erstellt wird (z. B. im Editor). </font><font style="vertical-align: inherit;">Während der Veröffentlichung des Spiels kann diese Verzögerung beseitigt werden.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Update( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime ) { <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Generate Portal texture ? //----------------------------------- UpdateDelay += DeltaTime; if( UpdateDelay &gt; 1.0f ) { UpdateDelay = 0.0f; GeneratePortalTexture(); } //----------------------------------- //Find portals in the level and update them //----------------------------------- AExedrePortal* Portal = UpdatePortalsInWorld(); if( Portal != nullptr ) { UpdateCapture( Portal ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir rufen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf, um alle in der aktuellen Welt vorhandenen Portale (einschließlich aller geladenen Ebenen) zu finden und zu aktualisieren. </font><font style="vertical-align: inherit;">Die Funktion bestimmt auch, welche "aktiv" ist, d.h. </font><font style="vertical-align: inherit;">für den Spieler sichtbar. </font><font style="vertical-align: inherit;">Wenn wir ein aktives Portal finden, rufen wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture () auf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das die SceneCapture-Komponente steuert.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So funktioniert das Welt-Update in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ol><li>   <b></b>   (    ) </li><li>   <b>iterator</b> ,         </li><li>     ,   ,    <b>ClearRTT()</b> ,    .    <b> </b> (,   ). </li><li>  ,     <b></b>  ,    ,     ,     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Überprüfung, die die Richtigkeit des Portals feststellt, ist einfach: Wir geben dem Portal, das dem Spieler am nächsten liegt, Priorität, da er aus seiner Sicht höchstwahrscheinlich am sichtbarsten ist. </font><font style="vertical-align: inherit;">Um Verwandte, aber zum Beispiel Portale, die sich hinter dem Player befinden, fallen zu lassen, sind komplexere Überprüfungen erforderlich, aber ich wollte mich in meinem Tutorial nicht darauf konzentrieren, da dies ziemlich schwierig werden kann.</font></font><br><br><pre> <code class="cpp hljs">AExedrePortal* AExedrePortalManager::UpdatePortalsInWorld() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update Portal actors in the world (and active one if nearby) //----------------------------------- AExedrePortal* ActivePortal = nullptr; FVector PlayerLocation = Character-&gt;GetActorLocation(); FVector CameraLocation = Character-&gt;GetCameraComponent()-&gt;GetComponentLocation(); float Distance = 4096.0f; for( TActorIterator&lt;AExedrePortal&gt;ActorItr( GetWorld() ); ActorItr; ++ActorItr ) { AExedrePortal* Portal = *ActorItr; FVector PortalLocation = Portal-&gt;GetActorLocation(); FVector PortalNormal = -1 * Portal-&gt;GetActorForwardVector(); //Reset Portal Portal-&gt;ClearRTT(); Portal-&gt;SetActive( false ); //Find the closest Portal when the player is Standing in front of float NewDistance = FMath::Abs( FVector::Dist( PlayerLocation, PortalLocation ) ); if( NewDistance &lt; Distance ) { Distance = NewDistance; ActivePortal = Portal; } } return ActivePortal; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist Zeit, die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture () -</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion in Betracht zu </font><b><font style="vertical-align: inherit;">ziehen</font></b><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist eine Upgrade-Funktion, die die andere Seite des Portals erfasst. </font><font style="vertical-align: inherit;">Aus den Kommentaren sollte alles klar sein, aber hier ist eine kurze Beschreibung:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erhalten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu Character und Player Controller.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir prüfen, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ob alles korrekt ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Portal, SceneCapture-Komponente, Player).</font></font></li><li>   <b>Camera</b>    <b>Target</b>  . </li><li> <b></b>    ,     SceneCapture. </li><li>      SceneCapture     Target. </li><li> ,  SceneCapure  ,  ,   <b></b> . </li><li> <b> Render Target</b>  SceneCapture,  . </li><li>  <b> </b>  PlayerController. </li><li> ,    <b>Capture</b>  SceneCapture     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie wir sehen können, ist beim Teleportieren eines Spielers die korrekte Umwandlung der Position und Drehung des Portals in den lokalen Zielraum ein Schlüsselelement des natürlichen und fehlerfreien Verhaltens von SceneCapture. </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Definition von ConvertLocationToActorSpace () finden Sie unter „Teleportieren eines Akteurs“. </font></font></blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::UpdateCapture( AExedrePortal* Portal ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update SceneCapture (discard if there is no active portal) //----------------------------------- if(SceneCapture != nullptr &amp;&amp; PortalTexture != nullptr &amp;&amp; Portal != nullptr &amp;&amp; Character != nullptr ) { UCameraComponent* PlayerCamera = Character-&gt;GetCameraComponent(); AActor* Target = Portal-&gt;GetTarget(); //Place the SceneCapture to the Target if( Target != nullptr ) { //------------------------------- //Compute new location in the space of the target actor //(which may not be aligned to world) //------------------------------- FVector NewLocation = UTool::ConvertLocationToActorSpace( PlayerCamera-&gt;GetComponentLocation(), Portal, Target ); SceneCapture-&gt;SetWorldLocation( NewLocation ); //------------------------------- //Compute new Rotation in the space of the //Target location //------------------------------- FTransform CameraTransform = PlayerCamera-&gt;GetComponentTransform(); FTransform SourceTransform = Portal-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * CameraTransform.GetRotation(); FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; //Update SceneCapture rotation SceneCapture-&gt;SetWorldRotation( NewWorldQuat ); //------------------------------- //Clip Plane : to ignore objects between the //SceneCapture and the Target of the portal //------------------------------- SceneCapture-&gt;ClipPlaneNormal = Target-&gt;GetActorForwardVector(); SceneCapture-&gt;ClipPlaneBase = Target-&gt;GetActorLocation() + (SceneCapture-&gt;ClipPlaneNormal * -1.5f); //Offset to avoid visible pixel border } //Switch on the valid Portal Portal-&gt;SetActive( true ); //Assign the Render Target Portal-&gt;SetRTT( PortalTexture-&gt;GetTexture() ); SceneCapture-&gt;TextureTarget = PortalTexture-&gt;GetTexture(); //Get the Projection Matrix SceneCapture-&gt;CustomProjectionMatrix = ControllerOwner-&gt;GetCameraProjectionMatrix(); //Say Cheeeeese ! SceneCapture-&gt;CaptureScene(); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font><font style="vertical-align: inherit;">Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetCameraProjectionMatrix () ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der PlayerController-Klasse standardmäßig nicht vorhanden. Ich habe sie selbst hinzugefügt. </font><font style="vertical-align: inherit;">Es wird unten gezeigt:</font></font><br><br><pre> <code class="cpp hljs">FMatrix AExedrePlayerController::GetCameraProjectionMatrix() { FMatrix ProjectionMatrix; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( GetLocalPlayer() != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { FSceneViewProjectionData PlayerProjectionData; GetLocalPlayer()-&gt;GetProjectionData( GetLocalPlayer()-&gt;ViewportClient-&gt;Viewport, EStereoscopicPass::eSSP_FULL, PlayerProjectionData ); ProjectionMatrix = PlayerProjectionData.ProjectionMatrix; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProjectionMatrix; }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließlich müssen wir den Aufruf der Teleport-Funktion implementieren. </font><font style="vertical-align: inherit;">Der Grund für die teilweise Verarbeitung der Teleportation über den Portal-Manager besteht darin, dass die Aktualisierung der erforderlichen Portale gewährleistet werden muss, da nur der Manager Informationen zu allen Portalen in der Szene hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir zwei verbundene Portale haben, müssen wir beim Wechsel von einem zum anderen beide in einem Tick aktualisieren. </font><font style="vertical-align: inherit;">Andernfalls teleportiert sich der Spieler und befindet sich auf der anderen Seite des Portals, aber das Zielportal ist erst beim nächsten Frame / Takt aktiv. </font><font style="vertical-align: inherit;">Dadurch entstehen visuelle Lücken mit dem versetzten Material des ebenen Netzes, das wir oben gesehen haben.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { Portal-&gt;TeleportActor( TargetToTeleport ); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Force update //----------------------------------- AExedrePortal* FuturePortal = UpdatePortalsInWorld(); if( FuturePortal != nullptr ) { FuturePortal-&gt;ForceTick(); //Force update before the player render its view since he just teleported UpdateCapture( FuturePortal ); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nun, das ist es, wir sind endlich fertig mit Portal Manager! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beenden Sie die Blaupause </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Abschluss des Portal-Managers müssen wir nur den Portal-Akteur selbst fertigstellen. Danach funktioniert das System. </font><font style="vertical-align: inherit;">Das einzige, was hier fehlt, sind die Tick-Funktionen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/455/bd3/f0f/455bd3f0f3b7c9f4f3fb36d5d1ae85d0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So funktioniert es: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir aktualisieren das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so, dass es nicht in einem aktiven Zustand bleibt.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Portal derzeit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inaktiv ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wird der Rest der Maßnahme verworfen.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir bekommen die Zeichenklasse die für </font><font style="vertical-align: inherit;">den Zugriff auf die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kamera die Lage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Teil prüft, ob sich die Kamera im Kollisionsfeld des Portals befindet. </font><font style="vertical-align: inherit;">Wenn ja, versetzen wir das Portalnetz mit seinem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der zweite Teil besteht darin, die Position innerhalb der Kollisionsbox erneut zu überprüfen. </font><font style="vertical-align: inherit;">Wenn es ausgeführt wird, rufen wir eine Funktion auf, die prüft, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ob wir das Portal überqueren</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li>        ,   Portal manager,    <b> Teleport</b> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Screenshot meines Diagramms sehen Sie zwei interessante Punkte: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Point Inside Box</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get Portal Manager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ich habe diese beiden Funktionen noch nicht erklärt. Dies sind statische Funktionen, die ich in meiner eigenen Klasse definiert habe, damit Sie sie von überall aus aufrufen können. Dies ist eine Art Helferklasse. Der Code dieser Funktionen wird unten angezeigt. Sie können selbst entscheiden, wo sie eingefügt werden sollen. Wenn Sie sie nicht außerhalb des Portalsystems benötigen, können Sie sie direkt in die Portal-Akteurklasse einfügen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst wollte ich das Kollisionssystem verwenden, um den Portal-Akteur in der Kollisionsbox zu finden, aber es schien mir nicht zuverlässig genug zu sein. Außerdem scheint mir diese Methode schneller anzuwenden zu sein und hat einen Vorteil: Sie berücksichtigt die Rotation des Schauspielers.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPointInsideBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Point, UBoxComponent* Box )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Box != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//From : //https://stackoverflow.com/questions/52673935/check-if-3d-point-inside-a-box/52674010 FVector Center = Box-&gt;GetComponentLocation(); FVector Half = Box-&gt;GetScaledBoxExtent(); FVector DirectionX = Box-&gt;GetForwardVector(); FVector DirectionY = Box-&gt;GetRightVector(); FVector DirectionZ = Box-&gt;GetUpVector(); FVector Direction = Point - Center; bool IsInside = FMath::Abs( FVector::DotProduct( Direction, DirectionX ) ) &lt;= Half.X &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionY ) ) &lt;= Half.Y &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionZ ) ) &lt;= Half.Z; return IsInside; } else { return false; } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AExedrePortalManager* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPortalManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AActor* Context )</span></span></span><span class="hljs-function"> </span></span>{ AExedrePortalManager* Manager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Retrieve the World from the Context actor if( Context != nullptr &amp;&amp; Context-&gt;GetWorld() != nullptr ) { //Find PlayerController AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( Context-&gt;GetWorld()-&gt;GetFirstPlayerController() ); //Retrieve the Portal Manager if( EPC != nullptr &amp;&amp; EPC-&gt;GetPortalManager() != nullptr ) { Manager = EPC-&gt;GetPortalManager(); } } return Manager; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der letzte Teil des Blueprint-Darstellers ist </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ForceTick</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Denken Sie daran, dass Force Tick aufgerufen wird, wenn ein Spieler ein Portal überquert und sich neben einem anderen Portal befindet, für das Portal Manager ein Update erzwingt. </font><font style="vertical-align: inherit;">Da wir gerade teleportiert haben, ist es nicht erforderlich, denselben Code zu verwenden, und Sie können die vereinfachte Version verwenden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/562/22e/cf356222e9d9c81dc38c57d021e51a90.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Prozess beginnt ungefähr zur gleichen Zeit wie die Tick-Funktion, aber wir führen nur den ersten Teil der Sequenz aus, der das Material aktualisiert. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sind wir fertig? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir das Portalsystem in dieser Form implementieren, werden wir höchstwahrscheinlich auf das folgende Problem stoßen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/f2f/9f7/4c1f2f9f71e8ce213764d42dad1d20c3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist hier los? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem GIF ist die Framerate des Spiels auf 6 FPS begrenzt, um das Problem deutlicher darzustellen. In einem Frame verschwindet der Cube, weil das </font><font style="vertical-align: inherit;">Unreal Engine- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clipping-System</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ihn als unsichtbar betrachtet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies liegt daran, dass die Ermittlung im aktuellen Frame durchgeführt und dann im nächsten verwendet wird. Dies erzeugt eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verzögerung von einem Frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies kann normalerweise behoben werden, indem der Begrenzungsrahmen des Objekts so erweitert wird, dass es registriert wird, bevor es sichtbar wird. Dies wird hier jedoch nicht funktionieren, da wir uns beim Überqueren des Portals von einem Ort zu einem völlig anderen teleportieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Deaktivieren des Clipping-Systems ist ebenfalls nicht möglich, insbesondere weil dies bei Ebenen mit vielen Objekten die Leistung beeinträchtigt. Außerdem habe ich viele Teams der Unreal-Engine ausprobiert, aber keine positiven Ergebnisse erzielt: In allen Fällen blieb eine Verzögerung von einem Frame bestehen. Glücklicherweise konnte ich nach einer detaillierten Untersuchung des Quellcodes von Unreal Engine eine Lösung finden (der Weg war lang - es dauerte mehr als eine Woche)! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei der SceneCapture-Komponente können Sie der Kamera des Players mitteilen, dass wir einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprungschnitt vorgenommen haben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Die Kameraposition ist zwischen zwei Bildern gesprungen, was bedeutet, dass wir uns nicht auf die Informationen des vorherigen Bildes verlassen können. </font><font style="vertical-align: inherit;">Dieses Verhalten kann bei Verwendung von Matinee oder Sequencer beobachtet werden, z. B. beim Wechseln der Kamera: Bewegungsunschärfe oder Glättung können nicht auf Informationen aus dem vorherigen Frame beruhen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu müssen wir zwei Aspekte berücksichtigen:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LocalPlayer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Diese Klasse verarbeitet verschiedene Informationen (z. B. das Ansichtsfenster des Players) und ist dem PlayerController zugeordnet. </font><font style="vertical-align: inherit;">Hier können wir den Renderprozess der Kamera des Players beeinflussen.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerController</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Wenn sich ein Spieler teleportiert, beginnt diese Klasse dank des Zugriffs auf LocalPlayer zu spleißen.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der große Vorteil dieser Lösung besteht darin, dass der Eingriff in den Rendering-Prozess der Engine bei zukünftigen Updates von Unreal Engine minimal und einfach zu warten ist. </font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit der Erstellung einer neuen Klasse, die von LocalPlayer geerbt wurde. </font><font style="vertical-align: inherit;">Im Folgenden finden Sie eine Überschrift, in der zwei Hauptkomponenten aufgeführt sind: Neudefinition der Berechnungen des Szenenansichtsfensters und eine neue Funktion zum Aufrufen des Kameraklebens.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Engine/LocalPlayer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API UExedreLocalPlayer : public ULocalPlayer { GENERATED_BODY() UExedreLocalPlayer(); public: FSceneView* CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) override; void PerformCameraCut(); private: bool bCameraCut; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So wird alles implementiert: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Exedre.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.h"</span></span></span><span class="hljs-meta"> UExedreLocalPlayer::UExedreLocalPlayer() { bCameraCut = false; } FSceneView* UExedreLocalPlayer::CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ULocalPlayer::CalcSceneView() use a ViewInitOptions to create // a FSceneView which contains a "bCameraCut" variable // See : H:\GitHub\UnrealEngine\Engine\Source\Runtime\Renderer\Private\SceneCaptureRendering.cpp // as well for bCameraCutThisFrame in USceneCaptureComponent2D FSceneView* View = Super::CalcSceneView(ViewFamily, OutViewLocation, OutViewRotation, Viewport, ViewDrawer, StereoPass ); if( bCameraCut ) { View-&gt;bCameraCut = true; bCameraCut = false; } return View; } void UExedreLocalPlayer::PerformCameraCut() { bCameraCut = true; }</span></span></span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PerformCameraCut ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> startet Camera Cut nur mit einem booleschen Wert. </font><font style="vertical-align: inherit;">Wenn die Engine die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView () aufruft</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , führen wir zuerst die ursprüngliche Funktion aus. </font><font style="vertical-align: inherit;">Dann prüfen wir, ob wir kleben müssen. </font><font style="vertical-align: inherit;">In diesem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fall</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definieren wir die boolesche Variable "Camera Cut" innerhalb der </font><b><font style="vertical-align: inherit;">FSceneView-</font></b><font style="vertical-align: inherit;"> Struktur neu </font><font style="vertical-align: inherit;">, die vom Engine-Rendering-Prozess verwendet wird, und setzen dann die boolesche Variable zurück (verwenden Sie sie).</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf der Player Controller-Seite sind die Änderungen minimal. </font><font style="vertical-align: inherit;">Sie müssen dem Header eine Variable hinzufügen, um einen Link zur nativen LocalPlayer-Klasse zu speichern:</font></font><br><br><pre> <code class="cpp hljs"> UPROPERTY() UExedreLocalPlayer* LocalPlayer;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BeginPlay ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"> LocalPlayer = Cast&lt;UExedreLocalPlayer&gt;( GetLocalPlayer() );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich habe auch eine Funktion hinzugefügt, um Cut schnell zu starten: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePlayerController::PerformCameraCut() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( LocalPlayer != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { LocalPlayer-&gt;PerformCameraCut(); } }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließlich </font><font style="vertical-align: inherit;">können wir </font><font style="vertical-align: inherit;">in der Portal Manager-Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RequestTeleportByPortal ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> während der Camera Cut-Teleportation </font><b><font style="vertical-align: inherit;">Folgendes</font></b><font style="vertical-align: inherit;"> ausführen:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;PerformCameraCut(); } [...]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und das ist alles! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camera Cut muss aufgerufen werden, bevor SceneCapture aktualisiert wird. Deshalb befindet es sich am Anfang der Funktion.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Endergebnis </font></font></h2><br> <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir gelernt, in Portalen zu denken. </font></font></a></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das System gut funktioniert, sollten wir in der Lage sein, folgende Dinge zu erstellen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie Probleme haben, überprüfen Sie Folgendes: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellen Sie sicher, dass Portal Manager ordnungsgemäß erstellt und initialisiert wurde. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Renderziel wird korrekt erstellt (Sie können das im Inhaltsbrowser erstellte Ziel zum Starten verwenden). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Portale sind korrekt aktiviert und deaktiviert. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bei Portalen ist der Zieldarsteller im Editor richtig eingestellt. </font></font></li></ul><br><h2>  Fragen und Antworten </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die beliebtesten Fragen, die mir zu diesem Tutorial gestellt wurden: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es möglich, dies auf Blunts und nicht über C ++ zu implementieren? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Großteil des Codes kann mit Ausnahme von zwei Aspekten in Blunts implementiert werden:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zum </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abrufen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Projektionsmatrix verwendete </font><b><font style="vertical-align: inherit;">LocalPlayer-</font></b><font style="vertical-align: inherit;"> Funktion </font><b><font style="vertical-align: inherit;">GetProjectionData ()</font></b><font style="vertical-align: inherit;"> ist in Blaupausen nicht verfügbar.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die LocalPlayer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Funktion </font><font style="vertical-align: inherit;">, die für die Lösung des Clipping-Systemproblems von entscheidender Bedeutung ist, ist in Blaupausen nicht verfügbar.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher müssen Sie entweder eine C ++ - Implementierung verwenden, um auf diese beiden Funktionen zuzugreifen, oder den Quellcode der Engine ändern, um sie über Blaupausen zugänglich zu machen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann ich dieses System in VR verwenden? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ja, zum größten Teil. </font><font style="vertical-align: inherit;">Einige Teile müssen jedoch angepasst werden, zum Beispiel:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie müssen zwei Renderziele verwenden (eines für jedes Auge) und diese im Portalmaterial maskieren, um sie nebeneinander im Bildschirmbereich anzuzeigen. </font><font style="vertical-align: inherit;">Jedes Renderziel sollte halb so breit sein wie die Auflösung des VR-Geräts.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie müssen zwei SceneCapture verwenden, um das Ziel mit dem richtigen Abstand (dem Abstand zwischen den Augen) zu rendern und stereoskopische Effekte zu erzielen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hauptproblem wird die Leistung sein, da die andere Seite des Portals zweimal gerendert werden muss. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann ein anderes Objekt das Portal überqueren? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mein Code enthält keine. </font><font style="vertical-align: inherit;">Es ist jedoch nicht so schwierig, es allgemeiner zu gestalten. </font><font style="vertical-align: inherit;">Dazu muss das Portal weitere Informationen zu allen Objekten in der Nähe verfolgen, um zu überprüfen, ob sie diese überqueren. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterstützt das System die Rekursion (Portal innerhalb des Portals)? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Tutorial ist nicht. </font><font style="vertical-align: inherit;">Für die Rekursion benötigen Sie zusätzliches Renderziel und SceneCapture. </font><font style="vertical-align: inherit;">Außerdem muss festgelegt werden, welches RenderTarget zuerst gerendert werden soll, und so weiter. </font><font style="vertical-align: inherit;">Das ist ziemlich schwierig und ich wollte das nicht, weil dies für mein Projekt nicht notwendig ist. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann ich das Portal in der Nähe der Wand überqueren?</font></font></b> <br><br>  Leider gibt es keine.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich sehe jedoch zwei Möglichkeiten, dies (theoretisch) umzusetzen: </font></font><br><br><ul><li>   ,      .  ,       . </li><li>   ,    ,    .       .   ,   ,       .         .    , , ,    ,  level streaming     . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448802/">https://habr.com/ru/post/de448802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448790/index.html">SpaceVIL - plattformübergreifendes GUI-Framework für die Entwicklung auf .Net Core, .Net Standard und JVM</a></li>
<li><a href="../de448794/index.html">Python-Test mit Pytest. Plugins KAPITEL 5</a></li>
<li><a href="../de448796/index.html">Python-Test mit Pytest. Konfiguration, KAPITEL 6</a></li>
<li><a href="../de448798/index.html">Python-Test mit Pytest. Verwenden von pytest mit anderen Tools, KAPITEL 7</a></li>
<li><a href="../de448800/index.html">Konfigurieren Sie Visual Studio in Ihrer Organisation mit .vsconfig</a></li>
<li><a href="../de448804/index.html">Vorbereitungen für die gehärtete Laufzeit und den Notar von macOS</a></li>
<li><a href="../de448806/index.html">Erstellen eines Erweiterungssystems in der Qt-Bibliothek</a></li>
<li><a href="../de448810/index.html">Wie habe ich einen Hacker gefangen?</a></li>
<li><a href="../de448812/index.html">Mondmission „Bereshit“ - Suche nach der ersten Mondbibliothek nach Beginn des Unfalls ihres Trägers</a></li>
<li><a href="../de448814/index.html">Bosque Language - Microsofts neue Programmiersprache</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>