<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏼 👈 🌂 Wir implementieren AutoMapper mithilfe von Roslyn und Codegenerierung 🦉 ⌨️ 🤤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem früheren Artikel habe ich eine Möglichkeit beschrieben, die Codegenerierung mit Roslyn zu organisieren. Die damalige Aufgabe bestand darin, e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir implementieren AutoMapper mithilfe von Roslyn und Codegenerierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459771/"><p>  In einem früheren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel habe</a> ich eine Möglichkeit beschrieben, die Codegenerierung mit Roslyn zu organisieren.  Die damalige Aufgabe bestand darin, einen gemeinsamen Ansatz zu demonstrieren.  Jetzt möchte ich etwas realisieren, das eine echte Anwendung haben wird. </p><br><p> Und wer interessiert sich dafür, wie Sie eine Bibliothek wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AutoMapper erstellen können,</a> bitte unter cat. </p><a name="habracut"></a><br><h1 id="vvedenie">  Einführung </h1><br><p> Zunächst denke ich, dass es sich lohnt zu beschreiben, wie mein Ahead of Time Mapper (AOTMapper) funktionieren wird.  Der Einstiegspunkt unseres Mappers wird die generische Erweiterungsmethode <code>MapTo&lt;&gt;</code> .  Der Analysator sucht danach und bietet an, die <code>MapToUser</code> Erweiterungsmethode zu implementieren, wobei <code>User</code> der Typ ist, der an <code>MapTo&lt;&gt;</code> . </p><br><p>  Nehmen Sie als Beispiel die folgenden Klassen: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">AOTMapper.Benchmark.Data</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UserEntity</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserEntity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserEntity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Guid id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lastName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Id = id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.FirstName = firstName; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.LastName = lastName; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Guid Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LastName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LastName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre> <br><p>  Der generierte <code>MapToUser</code> sieht folgendermaßen aus: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AOTMapper.Benchmark.Data.<span class="hljs-function"><span class="hljs-function">User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapToUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AOTMapper.Benchmark.Data.UserEntity input</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AOTMapper.Benchmark.Data.User(); output.FirstName = input.FirstName; output.LastName = input.LastName; output.Name = ; <span class="hljs-comment"><span class="hljs-comment">// missing property return output; }</span></span></code> </pre> <br><p>  Wie Sie in diesem Beispiel sehen können, werden alle Eigenschaften mit denselben Namen und Typen automatisch zugewiesen.  Im Gegenzug hängen diejenigen, für die keine Übereinstimmungen gefunden wurden, weiterhin hängen und verursachen einen Kompilierungsfehler, und der Entwickler muss sie irgendwie behandeln. </p><br><p>  Zum Beispiel so: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AOTMapper.Benchmark.Data.<span class="hljs-function"><span class="hljs-function">User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapToUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AOTMapper.Benchmark.Data.UserEntity input</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AOTMapper.Benchmark.Data.User(); output.FirstName = input.FirstName; output.LastName = input.LastName; output.Name = <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{input.FirstName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{input.LastName}</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; }</code> </pre> <br><p>  Während der <code>MapToUser</code> Generierung wird der <code>MapTo&lt;User&gt;</code> <code>MapToUser</code> durch <code>MapToUser</code> . </p><br><p>  Wie es in Bewegung funktioniert, sehen Sie hier: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BCznYk2n3II" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  AOTMapper kann auch über Nuget installiert werden: </p><br><pre> <code class="plaintext hljs">Install-Package AOTMapper</code> </pre> <br><p>  Den vollständigen Projektcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><h1 id="realizaciya">  Implementierung </h1><br><p>  Ich habe lange darüber nachgedacht, wie dies anders gemacht werden kann, und bin am Ende zu dem Schluss gekommen, dass dies nicht so schlimm ist, da dies einige der Unannehmlichkeiten löst, die mich bei der Verwendung von <code>AutoMapper</code> gequält haben. </p><br><p>  Erstens erhalten wir verschiedene Erweiterungsmethoden für verschiedene Typen, wodurch wir für einige abstrakte <code>User</code> sehr einfach mit IntelliSense herausfinden können, welche Karten bereits implementiert sind, ohne nach derselben Datei suchen zu müssen, in der unsere Karten registriert sind.  Schauen Sie sich einfach an, welche Erweiterungsmethoden Sie bereits haben. </p><br><p>  Zweitens handelt es sich zur Laufzeit nur um eine Erweiterungsmethode, sodass wir keinen Aufwand für den Aufruf unseres Mappers verursachen.  Ich verstehe, dass <code>AutoMapper</code> Entwickler viel Aufwand in die Optimierung des Anrufs <code>AutoMapper</code> , aber es gibt immer noch einige zusätzliche Kosten.  Mein kleiner Benchmark zeigte, dass er durchschnittlich 140-150 ns pro Anruf beträgt, ohne Initialisierungszeit.  Der Benchmark selbst kann im Repository angezeigt werden, und die Messergebnisse sind niedriger. </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Gen 0 </th><th>  Gen 1 </th><th>  Gen 2 </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  AutoMapperToUserEntity </td><td>  151,84 ns </td><td>  1,9952 ns </td><td>  1,8663 ns </td><td>  0,0253 </td><td>  - - </td><td>  - - </td><td>  80 B. </td></tr><tr><td>  AOTMapperToUserEntity </td><td>  10,41 ns </td><td>  0,2009 ns </td><td>  0,1879 ns </td><td>  0,0152 </td><td>  - - </td><td>  - - </td><td>  48 B. </td></tr><tr><td>  AutoMapperToUser </td><td>  197,51 ns </td><td>  2,9225 ns </td><td>  2,5907 ns </td><td>  0,0787 </td><td>  - - </td><td>  - - </td><td>  248 B. </td></tr><tr><td>  AOTMapperToUser </td><td>  46,46 ns </td><td>  0,3530 ns </td><td>  0,3129 ns </td><td>  0,0686 </td><td>  - - </td><td>  - - </td><td>  216 B. </td></tr></tbody></table></div><br><p>  Zu den Vorteilen dieses Mappers gehört außerdem die Tatsache, dass die Initialisierung beim Start der Anwendung im Allgemeinen keine Zeit erfordert, was in großen Anwendungen hilfreich sein kann. </p><br><p>  Der Analysator selbst hat die folgende Form (ohne Bindungscode): </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OperationAnalysisContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syntax = context.Operation.Syntax; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (syntax <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> InvocationExpressionSyntax invocationSytax &amp;&amp; invocationSytax.Expression <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MemberAccessExpressionSyntax memberAccessSyntax &amp;&amp; syntax.DescendantNodes().OfType&lt;GenericNameSyntax&gt;().FirstOrDefault() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> GenericNameSyntax genericNameSyntax &amp;&amp; genericNameSyntax.Identifier.ValueText == <span class="hljs-string"><span class="hljs-string">"MapTo"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semanticModel = context.Compilation.GetSemanticModel(syntax.SyntaxTree); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methodInformation = semanticModel.GetSymbolInfo(genericNameSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodInformation.Symbol.ContainingAssembly.Name != CoreAssemblyName) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fromTypeInfo = semanticModel.GetTypeInfo(memberAccessSyntax.Expression); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fromTypeName = fromTypeInfo.Type.ToDisplayString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeSyntax = genericNameSyntax.TypeArgumentList.Arguments.First(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toTypeInfo = semanticModel.GetTypeInfo(typeSyntax); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toTypeName = toTypeInfo.Type.ToDisplayString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> properties = ImmutableDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;.Empty .Add(<span class="hljs-string"><span class="hljs-string">"fromType"</span></span>, fromTypeName) .Add(<span class="hljs-string"><span class="hljs-string">"toType"</span></span>, toTypeName); context.ReportDiagnostic(Diagnostic.Create(AOTMapperIsNotReadyDescriptor, genericNameSyntax.GetLocation(), properties)); } }</code> </pre> <br><p>  Er prüft <code>MapTo&lt;&gt;</code> , ob es sich um die von uns benötigte Methode handelt, extrahiert den Typ aus der Entität, für die <code>MapTo&lt;&gt;</code> aufgerufen wird, aus dem ersten Parameter der verallgemeinerten Methode und generiert eine Diagnosemeldung. </p><br><p>  Es wird wiederum im <code>AOTMapperCodeFixProvider</code> .  Hier erhalten wir Informationen zu den Typen, über die wir die Codegenerierung ausführen werden.  Dann ersetzen wir den Aufruf von <code>MapTo&lt;&gt;</code> durch eine bestimmte Implementierung.  Dann rufen wir <code>AOTMapperGenerator</code> der eine Datei mit der Erweiterungsmethode generiert. </p><br><p>  Im Code sieht es so aus: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Document&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Diagnostic diagnostic, CodeFixContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fromTypeName = diagnostic.Properties[<span class="hljs-string"><span class="hljs-string">"fromType"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toTypeName = diagnostic.Properties[<span class="hljs-string"><span class="hljs-string">"toType"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> document = context.Document; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semanticModel = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> document.GetSemanticModelAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> diagnostic.Location.SourceTree.GetRootAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> call = root.FindNode(diagnostic.Location.SourceSpan); root = root.ReplaceNode(call, SyntaxFactory.IdentifierName(<span class="hljs-string"><span class="hljs-string">$"MapTo</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{toTypeName.Split(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'.'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">).Last()}</span></span></span><span class="hljs-string">"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pairs = ImmutableDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;.Empty .Add(fromTypeName, toTypeName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> generator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AOTMapperGenerator(document.Project, semanticModel.Compilation); generator.GenerateMappers(pairs, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">"AOTMapper"</span></span>, <span class="hljs-string"><span class="hljs-string">"Mappers"</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newProject = generator.Project; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> documentInNewProject = newProject.GetDocument(document.Id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> documentInNewProject.WithSyntaxRoot(root); }</code> </pre> <br><p>  <code>AOTMapperGenerator</code> selbst ändert das eingehende Projekt, indem Dateien mit Zuordnungen zwischen den Typen erstellt werden. <br>  Dies geschieht wie folgt: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMappers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ImmutableDictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; values, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] outputNamespace</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> values) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fromSymbol = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Compilation.GetTypeByMetadataName(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Key); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toSymbol = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Compilation.GetTypeByMetadataName(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Value); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fromSymbolName = fromSymbol.ToDisplayString().Replace(<span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toSymbolName = toSymbol.ToDisplayString().Replace(<span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileName = <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{fromSymbolName}</span></span></span><span class="hljs-string">_To_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{toSymbolName}</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GenerateMapper(fromSymbol, toSymbol, fileName); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Project = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Project .AddDocument(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{fileName}</span></span></span><span class="hljs-string">.cs"</span></span>, source) .WithFolders(outputNamespace) .Project; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">INamedTypeSymbol fromSymbol, INamedTypeSymbol toSymbol, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fromProperties = fromSymbol.GetAllMembers() .OfType&lt;IPropertySymbol&gt;() .Where(o =&gt; (o.DeclaredAccessibility &amp; Accessibility.Public) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) .ToDictionary(o =&gt; o.Name, o =&gt; o.Type); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toProperties = toSymbol.GetAllMembers() .OfType&lt;IPropertySymbol&gt;() .Where(o =&gt; (o.DeclaredAccessibility &amp; Accessibility.Public) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) .ToDictionary(o =&gt; o.Name, o =&gt; o.Type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">$@" public static class </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{fileName}</span></span></span><span class="hljs-string">Extentions {{ public static </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{toSymbol.ToDisplayString()}</span></span></span><span class="hljs-string"> MapTo</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{toSymbol.ToDisplayString().Split(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'.'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">).Last()}</span></span></span><span class="hljs-string">(this </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{fromSymbol.ToDisplayString()}</span></span></span><span class="hljs-string"> input) {{ var output = new </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{toSymbol.ToDisplayString()}</span></span></span><span class="hljs-string">(); </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{ toProperties .Where(o =&gt; fromProperties.TryGetValue(o.Key, </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> type) &amp;&amp; type == o.Value) .Select(o =&gt; </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">$" output.</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{o.Key}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"> = input.</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{o.Key}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">;"</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> ) .JoinWithNewLine() }</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{ toProperties .Where(o =&gt; !fromProperties.TryGetValue(o.Key, </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> type) || type != o.Value) .Select(o =&gt; </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">$" output.</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{o.Key}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"> = ; // missing property"</span></span></span></span><span class="hljs-string"><span class="hljs-subst">) .JoinWithNewLine() }</span></span></span><span class="hljs-string"> return output; }} }} "</span></span>; }</code> </pre> <br><h1 id="vyvody">  Schlussfolgerungen </h1><br><p>  Insgesamt haben wir einen Mapper, der zum Zeitpunkt des Schreibens des Codes funktioniert, und dann bleibt nichts von seiner Laufzeit übrig.  Die Pläne sehen eine Möglichkeit vor, Konfigurationsfunktionen hinzuzufügen.  Konfigurieren Sie beispielsweise die Vorlagen für die Namen der generierten Methoden und geben Sie das Verzeichnis an, in dem gespeichert werden soll.  Fügen Sie auch die Möglichkeit hinzu, Änderungen an Typen zu verfolgen.  Ich habe eine Idee, wie dies organisiert werden kann, aber ich vermute, dass dies im Hinblick auf den Ressourcenverbrauch spürbar ist, und bisher wurde beschlossen, dies zu verzögern. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459771/">https://habr.com/ru/post/de459771/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459761/index.html">Wie man ein Elektrofahrrad pflegt</a></li>
<li><a href="../de459763/index.html">Wie viele TPS befinden sich in Ihrer Blockchain?</a></li>
<li><a href="../de459765/index.html">Künstliche Intelligenz Goldeneye 007</a></li>
<li><a href="../de459767/index.html">Tesla erhöht die Produktion von Elektrofahrzeugen dramatisch</a></li>
<li><a href="../de459769/index.html">Virtuell, industriell, zu Hause</a></li>
<li><a href="../de459773/index.html">Erstellen, Bereitstellen und Testen von Waves RIDE dApp</a></li>
<li><a href="../de459775/index.html">Was ich über maschinelles Lernen gelernt habe, nachdem ich in 12 Startups gearbeitet habe</a></li>
<li><a href="../de459785/index.html">Deep Learning: Überblick</a></li>
<li><a href="../de459787/index.html">C ++, ob der Typ definiert ist: vorläufige Deklaration der notwendigen Objekte</a></li>
<li><a href="../de459789/index.html">Aktualisieren von Unity Android-Projekten auf Kompatibilität mit der ARM64-Architektur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>