<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍶 🖖🏽 🔳 LoJax：恶意活动中使用的第一个已知UEFI Rootkit 🚧 🚶 👊🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sednit Cyber​​group，也称为ART28，Strontium和Fancy Bear，至少从2004年开始运营。 人们认为，该组织背后是一系列共振网络攻击的背后。 一些IB公司和美国司法部已致电Sednit，负责在2016年美国大选之前入侵民主党全国委员会。 该组织因入侵全球电视网络T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>LoJax：恶意活动中使用的第一个已知UEFI Rootkit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/eset/blog/425251/">  Sednit Cyber​​group，也称为ART28，Strontium和Fancy Bear，至少从2004年开始运营。 人们认为，该组织背后是一系列共振网络攻击的背后。 一些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IB公司</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">美国司法部已</a>致电Sednit，负责在2016年美国大选之前入侵民主党全国委员会。 该组织因<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">入侵</a>全球电视网络TV5Monde，来自世界反兴奋剂机构（WADA） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>电子邮件<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">泄漏</a>以及其他事件而受到赞誉。  Sednit有许多目标和各种各样的工具，其中一些我们已经在前面进行了介绍，但是在本工作中，我们将首次详细描述UEFI rootkit的使用。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ai/yf/nq/aiyfnqxa7dzic4myqh6eircpapo.jpeg"></div><br><a name="habracut"></a><h2> 简短评论 </h2><br> 我们发现至少自2017年初以来，Sednit一直在使用该程序旧用户代理的木马版本来保护设备免受Absolute Software-LoJack开发人员的盗窃。 该工具由于使用UEFI / BIOS模块作为确保持久性的机制而吸引了信息安全专业人员的注意。 我们称该程序为木马版本<b>LoJax</b> 。 <br><br> 受感染的系统中存在著名的Sednit工具以及LoJax示例，并且木马代理使用的某些命令服务器以前是Sedn​​it基础结构的一部分，这使我们能够高度自信地将UEFI rootkit与该组相关联。 <br><br> 与LoJax代理一起，发现了用于读取UEFI系统固件的工具，在一种情况下，该工具可以转储，修补和重写部分系统SPI闪存。 该工具的最终目标是将恶意UEFI模块安装到其闪存SPI保护易受攻击或配置不当的系统中。 <br><br>  UEFI模块负责在系统中实现LoJax代理；这是Sedn​​it组中第一个UEFI标识的rootkit。 由于它在系统固件中，因此可以在重新安装Windows和更换硬盘驱动器后幸免。 <br><br> 至少有一种情况是该rootkit成功安装在系统SPI闪存中。 根据我们的信息，这是在野外发现的第一个UEFI rootkit。 <br><br><h2> 引言 </h2><br>  Sednit使用许多恶意软件家族。 我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告中</a>提供了常用分组工具的详细说明。 <br><br> 我们已经跟踪Sednit的活动已有好几年了，并且已经发布了有关该小组工作的许多报告，从零日漏洞的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">描述</a>到自定义程序（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Zebrocy）</a> 。 本报告中描述的组件构成一个单独的组。 <br><br> 信息安全公司先前在报告中已经描述了UEFI Rootkit。 例如，众所周知，在hack7团队中有关数据泄漏的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示中介绍</a>了rkloader，并从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vault7</a>文档中下载了macOS EFI / UEFI下载中的植入程序<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DerStarke</a> 。 我们知道这些工具的存在，但是，rootkit尚未发布UEFI危害报告。 <br><br> 现在，我们不仅证明了带有恶意LoJax UEFI模块的野外固件的使用，而且还发现了最有可能用于安装它的全部工具。 有趣的是，Sednit使用DownDelph引导程序包，该程序包在2013年和2014年用于维护Downdelph，这是第一阶段的Sednit后门程序之一。 这个想法是相似的，但是在新版本的UEFI中，不再可以使用Bootkit。 因此，这两个组件的行为差异很大。 <br><br> 这项工作分为三个部分。 首先，我们将分析LoJack / Computrace安全性的早期研究以及恶意使用该程序的可能性。 第二部分致力于研究过程，最终将我们引向了UEFI Rootkit。 最后，在第三部分中，我们详细描述了各种LoJax组件，以及它们在重新安装Windows和更换硬盘驱动器之后如何在系统中提供持久性。 <br><br><h4> 归因 </h4><br> 尽管过去许多供应商已经就Sednit集团发表过声明，但ESET决不决定其地缘政治归属。 自2016年<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">研究报告</a>发表以来，我们的立场没有改变。 基于科学方法确定网络攻击的来源是一项复杂的任务，超出了ESET专家的能力范围。 我们所谓的“ Sednit组”只是一套软件和相关的网络基础架构，我们无法与任何特定组织进行权威地关联。 <br><br><h4> 目标 </h4><br> 在研究过程中，我们发现了少量不同的LoJax图像。 根据我们的遥测数据和对在野外发现的其他Sednit程序的研究，我们相信，与其他工具相比，很少使用此特定模块。 目标主要是位于中欧和东欧的巴尔干地区的国家组织。 <br><br><h2> 早期Computertrace / LoJack研究 </h2><br>  LoJack-由Absolute Software Corporation开发的保护计算机免遭盗窃和丢失的软件。 该代理的早期版本称为Computrace。 顾名思义，在激活服务后，计算机可以访问其命令服务器-如果丢失或失窃，将通知所有者设备的位置。 <br><br> 以下部分描述了以前的LoJack体系结构。 网络犯罪分子仅对该软件的旧版本进行了木马分析，因此我们将重点关注它。 此外，Absolute Software于2018年5月发布了一份<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">声明，</a>指出以下所述漏洞不会影响其代理最新版本的运行。 <br><br>  Computrace程序吸引了信息安全专业人员的注意，因为它使用了一种不寻常的方法来确保持久性。 它的目的是防止盗窃，因此，重要的是它必须能够重新安装操作系统并更换硬盘驱动器-所有这些均在UEFI / BIOS模块中实现，这些模块在这些操作后仍可继续存在。 该解决方案已预先安装在不同制造商的笔记本电脑的相当一部分固件中，用户只需要激活此功能即可。 可以在BIOS中完成激活，如下图所示。 <br><br><img src="https://habrastorage.org/webt/rf/vx/i_/rfvxi_hexr1f29e0hqddhak97ag.png"><br>  <i>图1.在BIOS中激活Computrace</i> <br><br> 第一批LoJack / Computrace实施报告于2009年发布。 公开了产品的全局体系结构，UEFI / BIOS模块将用户代理刷新到磁盘以及代理与由Absolute Software控制的Web服务器通信的方式。 从下图可以理解该图。 <br><br><img src="https://habrastorage.org/webt/mh/5a/u2/mh5au2bhmrriy8sn8dtsd1g1avw.png"><br>  <i>图2. LoJack持久性机制（大约2008年）</i> <br><br> 以下是上面列出的步骤的说明： <br><br>  1.如果激活，则UEFI / BIOS模块在引导时执行。 他正在尝试查找FAT / FAT32 / NTFS分区。 然后，他使用NTFS驱动程序创建<code>autochk.exe</code>文件的备份，并用负责安装用户代理组件的<code>autochk.exe</code>程序覆盖其内容。  <code>autochk.exe</code>文件是Windows可执行文件，在系统启动的早期阶段启动，以检查硬盘是否损坏。 <br><br>  2.修改后的<code>autochk.exe</code>启动时，其主要目标是实现<code>rpcnetp.exe</code>微型代理并将其添加为服务，以便每次重新启动时启动。 该组件的最后一步是还原<code>autochk.exe</code>的原始版本。 <br><br>  3. Mini-agent <code>rpcnetp.exe</code>一个小的可执行文件，其目的是确保主代理的运行。 如果主代理不起作用，则<code>rpcnetp.exe</code>尝试连接到Absolute Software C＆C命令服务器以下载并执行它。 首先，迷你代理将对其自身进行复制，然后对PE标头进行更改以转换为DLL。 然后将该库加载到内存中，调用<code>svchost.exe</code>进程，并在其中注入DLL。 接下来，启动<code>iexplore.exe</code> Internet Explorer进程，并将DLL注入其中。 后面的过程将用于通过Internet进行通信。 将Computrace微型代理注入第三方进程通常是在恶意软件中发现的，很少与合法软件相关联。 <br><br>  4.现在，功能齐全的代理正在系统上运行，并且可以使用Computrace函数进行跟踪和恢复。 <br><br> 迷你代理与C＆C服务器之间涉及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>此过程和网络协议的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明</a>已于2014年发布。 由于缺少身份验证机制，如果攻击者控制了微型代理与之通信的服务器，则他们可以强制其下载任意代码。 有几种机制可以使攻击者直接联系迷你代理。 对我们来说最重要的是使用通过迷你代理获取C＆C服务器地址的方法。 实际上，此信息存储在可执行文件本身的配置文件中。 <br><br><img src="https://habrastorage.org/webt/qc/ww/es/qcwwesoicwoyw1aghae1smpgnao.png"><br>  <i>图3.右侧的加密的LoJack部分解密配置文件</i> <br><br> 该图显示了LoJack微型代理程序配置文件。 使用的“加密”方法是对单字节密钥的简单XOR。 对于所有已研究的迷你代理，0xB5密钥均相同。 从图中可以看出，在文件中指定了C＆C域。 前面的四个字节包含C＆C服务器的IP地址。 在没有对配置文件的内容进行验证的情况下，具有<code>%WINDIR%</code>写权限的攻击者可以更改其内容，以便迷你代理将与其命令服务器进行通信，而不是与之通信。 了解网络协议后，您可以下载迷你代理并执行任意代码。 这些风险早已为人所知，但直到最近，该机制才在实践中使用。 <br><br><h4>  LoJack变成LoJax </h4><br>  2018年5月， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在</a> Arbor Network <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客上</a>介绍了LoJack微型代理rpcnetp.exe的Trobor示例。 他们的硬编码网络设置已更改，以便恶意样本与攻击者的C＆C服务器而不是合法的Absolute Software服务器建立了连接。 特洛伊木马样本中发现的某些域是较早满足的-它们在2017年底被用作Sednitloader组第一阶段的后门SedUploader的C＆C服务器域。 下图显示了LoJax迷你代理之一中修改后的配置的示例。 <br><br><img src="https://habrastorage.org/webt/om/ts/md/omtsmdgqzbkn-fbqrpjd59abp7a.png"><br>  <i>图4.左侧是合法的配置文件，右侧是经过修改的文件</i> <br><br> 合法代理和特洛伊木马代理之间的差异非常小，上面几乎都给出了。 我们能够找到的LoJax迷你代理样本是同一Computrace迷你代理样本<code>rpcnetp.exe</code> 。 它们都有相同的编译时间戳，并且与原始字节只有几十个字节不同。 除了更改配置文件外，计时器变量还存在差异，这些差异决定了C＆C服务器连接之间的间隔。 <br><br> 在发布之时，我们发现了各种LoJax微型代理，这些代理用于攻击中欧和东欧的巴尔干各组织，但是我们对如何安装它们没有任何想法。 一个明显的解释是使用著名的Sednit后门之一进行安装。 不要忘记，LoJack作为一种完善的工具已被许多防病毒供应商列入白名单。 因此，即使在该活动中仅使用了微型代理，该微型代理在重新安装Windows后仍无法生存，它仍然具有优势-不太可能被检测为恶意软件。 但是，如果折衷方案甚至更深，并且攻击者试图复制LoJack以获取系统固件，该怎么办？ <br><br><h2> 寻找较低级别的组件 </h2><br> 我们记录了针对中欧和东欧巴尔干地区多个组织的LoJax攻击。 在所有这些中，我们设法找到了Sednit恶意软件的痕迹，包括： <br><br><ul><li>  SedUploader，第一阶段后门 </li><li>  XAgent，Sednit的旗舰后门 </li><li>  Xtunnel，一种网络代理工具，可以在Internet上的C＆C服务器与本地网络上的目标计算机之间传输任何网络流量 </li></ul><br> 我们在大多数成为LoJax目标的系统中以及只有LoJax的几个系统中发现了Sednit工具的痕迹。 可以假定在某些情况下，LoJax被用作单独的工具，可能作为恢复Sednit运营商对网络访问的附加后门。 <br><br>  XAgent后门通常会将其他模块放入受损的系统中，因此立即想到LoJax样本是以相同的方式交付的，没有任何其他机制。 可以假设Sednit仅从LoJack解决方案中借用了一个迷你代理。 但是，在分析开始后不久，我们发现了一些证据，表明灵感的来源更为广泛。 <br><br><h4>  RWEverything（RwDrv）驱动程序和info_efi.exe </h4><br> 最初的证据归功于网络犯罪分子的定制工具，该工具在执行时将有关下层系统设置的信息卸载到了文本文件中。 该工具与一些LoJax示例一起被发现。 下图以逻辑名称<code>info_efi.exe</code>显示了此工具的<code>info_efi.exe</code>文件的<code>info_efi.exe</code> 。 <br><br><img src="https://habrastorage.org/webt/8j/9x/kc/8j9xkcnbmste_xynugnkenaar6g.png"><br>  <i>图5. info_efi .exe生成的文件日志的节选</i> <br><br> 要读取此类信息，该工具包括一个名为<code>RwDrv.sys</code>的驱动程序。 内核驱动程序随附<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RWEverything</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RWEverything</a>是网络上免费的实用程序，可用于读取几乎所有较低级别设置的信息，包括PCI Express接口，内存，PCI Option ROM等。 内核驱动程序是合法软件，并使用有效证书签名。 <br><br><img src="https://habrastorage.org/webt/2u/o-/mb/2uo-mbk6so15sdz9iusnxzl15qq.png"><br>  <i>图6. RwDrv.sys代码签名证书</i> <br><br>  RWEverything带有图形用户界面，使您可以访问所有这些信息。 <br><br><img src="https://habrastorage.org/webt/if/yp/dp/ifypdpu-hnounvupxelxhcp5el4.png"><br>  <i>图7. RWEverything界面截图</i> <br><br>  <code>info_efi</code>工具的发现是UEFI LoJax模块可能存在的第一个迹象。 尝试更新系统固件时，拥有有关其供应商，版本等的信息非常重要。 考虑到允许用户进程访问和修改存储UEFI模块的SPI闪存内容的漏洞，获取系统固件数据是成功进行攻击的第一步。 <br><br> 使我们能够找到Sednit组的第一个UEFI rootkit的最终线索是两个工具-转储SPI闪存和对其进行写入。 <br><br><h4> 转储SPI闪存 </h4><br> 难题的第一步是名为<code>ReWriter_read.exe</code>的文件。 它包含使用RWEverything驱动程序<code>RwDrv.sys</code>转储系统SPI闪存所需的所有代码。 为了使设备驱动程序执行必要的操作，转储工具必须发送正确的I / O控制代码（IOCTL）。 尽管<code>RwDrv.sys</code>支持许多不同的IOCTL代码，但本节和下一节中介绍的转储工具和<code>RwDrv.sys</code>器工具仅使用其中的四个。 <br><br>  RwDrv.sys：支持的IOCTL代码： <br><br>  <i>0x22280c-</i>写入分配给I / O的内存区域 <br>  <i>0x222808-</i>读取分配给输入输出的内存区域 <br>  <i>0x222840-</i>从指定的PCI配置寄存器读取dword <br>  <i>0x222834-</i>将字节写入指定的PCI配置寄存器 <br><br>  <code>ReWriter_read</code>首先使用内置的<code>RwDrv.sys</code>内核<code>RwDrv.sys</code>创建服务，并写入UEFI / BIOS配置信息，BIOS管理寄存器（BIOS_CNTL）中包含的三个字段的相应值：BIOS锁定启用（BLE），BIOS写启用（BIOSWE）和SMM BIOS写保护禁用（SMM_BWP）。 尽管<code>ReWrite_read</code>不使用这些值，但在以下各节中，我们将说明为什么这些字段对此工具感兴趣。 <br><br> 该工具的下一个任务是获取SPI中BIOS存储区的基地址及其大小。 此信息作为BIOS Flash主要区域包含在主SPI接口的寄存器中。 所有寄存器都显示在根复合寄存器块（RCRB）的内存中，其基地址可以通过读取所需的PCI配置寄存器来获取。  <code>ReWriter_read</code>通过使用RwDrv IOCTL 0x22840并读取正确的缩进（在本例中为0xF0）来获取此地址。 知道BIOS区域的基地址及其大小后，转储工具将读取SPI闪存的相应内容并将其写入磁盘上的文件中。 下图说明了读取SPI闪存的过程。 缩写的定义在下面的术语表中给出。 <br><br><img src="https://habrastorage.org/webt/mw/wm/tb/mwwmtbzbrwmm18l1w7-2iugvpxc.png"><br>  <i>图8. SPI闪存的读取顺序</i> <br><br> 除了仅执行一次的前两个步骤外，还需要一个周期地重复这些操作，直到读取完SPI闪存中的所有数据为止。 这个过程<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>也有很好的描述。 然后<code>ReWriter_read</code>验证合并图像的大小。 它解析图像内存描述符以获得一系列BIOS，千兆位以太网（GbE）和管理引擎（ME）区域。 通过添加这三个区域的尺寸，转储工具可以计算闪存SPI的全部内容。 如果该大小与通过读取Flash Primary BIOS注册表区域获得的大小匹配，则该映像被认为是正确的。 <br><br><h4>  UEFI固件补丁 </h4><br> 难题的第二部分是一个名为<code>ReWriter_binary.exe</code>的文件。 该文件包含Sednit固件的证据。 该文件包含用于应用已下载的UEFI映像的补丁并将木马版本写回SPI闪存的代码。 在本节中，我们描述此二进制文件的结构。 <br><br> 在通过上述工具卸载闪存的内容并进行验证之后，恶意的UEFI模块将添加到映像中。 为此，必须分析UEFI图像以突出显示必要的信息。 <br><br>  UEFI映像中存储的数据通过文件系统（FFS）分解为卷。 顾名思义，这是用于存储固件映像的特殊文件系统。 卷包含带有GUID的文件。 每个文件通常包含许多部分，其中一个部分包含实际的可执行文件PE / COFF，这是一个UEFI映像。 以下是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UEFITool</a>的屏幕截图， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UEFITool</a>是一个用于处理UEFI固件映像的开源项目，以使电路更简单。 <br><br><img src="https://habrastorage.org/webt/s6/th/mp/s6thmpgjnornwankifoul8d9zlk.png"><br>  <i>图9.加载到UEFITool中的UEFI固件映像示例</i> <br><br>  ReWriter_binary分析在闪存的BIOS SPI区域中找到的所有固件卷，并查找特定文件： <br><br><ul><li>  IP4Dxe（8f92960f-2880-4659-b857-915a8901bdc8） </li><li>  NtfsDxe（768bedfd-7b4b-4c9f-b2ff-6377e3387243） </li><li>  SmiFlash（bc327dbd-b982-4f55-9f79-056ad7e987c5） </li><li>  Dxe核心 </li></ul><br><img src="https://habrastorage.org/webt/zt/ou/kc/ztoukch8w0mdyv-whzpkaibpc9u.png"><br>  <i>图10.在固件卷中使用Hex-Rays反编译器的结果</i> <br><br>  Ip4Dxe和NtfsDxe是DXE驱动程序。 在UEFI固件中，DXE驱动程序是为硬件抽象或用于组织服务以供其他DXE驱动程序或UEFI应用程序使用而创建的PE / COFF映像。 在启动过程的早期，DXE Foundation会通过DXE Manager（DXE内核）检测并下载此类驱动程序。 完成此阶段后，所有服务（例如OS加载程序）都可用于处理UEFI应用程序。 通常，DXE驱动程序存储在同一卷中。 但是，DXE调度程序可能是独立的。 <br><br>  <code>ReWriter_binary</code>仅搜索Ip4Dxe以确定给定的卷是否包含DXE驱动程序。 如我们稍后所述，该卷将成为安装恶意DXE驱动程序的候选对象。 他还搜索DXE内核，并将其所在的卷添加为另一个记录Rootkit的位置的候选对象。 存储每个这些卷中的可用空闲空间，以后可用来检查是否添加了恶意驱动程序。 <br><br>  NtfsDxe-AMI NTFS DXE驱动程序。 如果固件卷中存在该文件，则将其位置保存起来，以后再用于从该卷中删除该文件。 在UEFI rootkit部分中，我们将了解为什么它会删除此文件。 <br><br> 至于SmiFlash图像，与之相关的信息已存储，但在Malvari中的任何地方均未使用。 有趣的是，图像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">很脆弱</a> 。 因此，我们相信Sednit运营商可以努力利用这些漏洞。 这可能使他们甚至可以将正确配置的系统写入SPI闪存。 正如我们稍后将要说明的那样，该工具只能以当前形式写入配置错误或相当旧的系统的BIOS区域（在2008年左右推出的芯片组早于Platform Controller Hub的主板上）。 <br><br> 分配必要的元数据后， <code>ReWriter_binary</code>修补UEFI映像的转储并添加恶意DXE驱动程序。 首先，它创建文件头（EFI_FFS_FILE_HEADER）。 然后，他根据Ip4Dxe和DXE内核的位置以及这些卷上的可用空间来选择目标卷。  <code>ReWriter_binary</code>嵌入了一个压缩段，该段包含一个PE图像和一个用户界面段，该段定义了人类可读的文件名：SecDxe。 压缩的部分将添加到文件头中，并在卷的末尾的可用空间中写入。 下图显示了结构-在UEFITool中的显示。 <br><br><img src="https://habrastorage.org/webt/g6/9-/-a/g69--aub7xrb5b1iinzwrtpxyo8.png"><br>  <i>图11. UEFITool中的SecDxe文件视图</i> <br><br> 最后，如果映像中存在NtfsDxe驱动程序，则将其删除。 固件文件系统按顺序存储文件及其内容，因此过程非常简单： <br><br><ul><li> 缩进卷尾的可用空间 </li><li> 在NtfsDxe映像顶部写入0xFF字节 </li><li> 复制固件卷的下一部分，从缩进NtfsDxe所在的位置开始 </li><li> 文件系统的其余部分填充有0xFF字节，即可用空间 </li></ul><br><h4> 将修补的固件写回到SPI闪存 </h4><br> 成功更改固件映像后，下一步是将其写回到SPI闪存中。 在进入此过程之前，我们需要确定一些在这种情况下很重要的BIOS写保护。 其他现有机制（例如范围写保护BIOS）仍然保持超然状态，因为ReWriter_binary不会对其进行检查。 <br><br> 该平台使用多种安全机制来阻止未经授权的写入BIOS区域的尝试。 我必须说，默认情况下未启用这些机制。 固件负责正确配置。 这些配置在BIOS控制寄存器（BIOS_CNTL）中提供。 它包含BIOS写使能（BIOSWE）位，必须将其写入“ 1”才能写入SPI闪存的BIOS区域。 由于平台不应该允许任何尝试写入BIOS区域的操作，因此BIOS_CNTL中还有一点可以保护BIOSWE-这是BIOS锁定启用（BLE）。 设置后，该机制应阻止BIOSWE位并使该值等于“ 0”。 但是，该解决方案存在漏洞。 当请求将BIOSWE位更改为“ 1”时，将BIOSWE位更改为“ 1”，只有在平台使用系统管理中断（SMI）中断任务后，此SMI的代码才会将BIOSWE位更改为“ 0”。 <br><br> 此版本的解决方案存在许多问题。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，将SMI处理器留给固件开发人员使用。因此，如果此代码未在固件中实现，则BLE位将无用，因为BIOSWE位将不会被设置回“ 0”。其次，在这种情况下，</font><font style="vertical-align: inherit;">即使SMI处理程序正确实现</font><font style="vertical-align: inherit;">，我们也具有“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">竞争条件漏洞</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”，该</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">漏洞</font></a><font style="vertical-align: inherit;">使我们能够完全规避此机制。要利用此漏洞，攻击者需要运行一个线程，该线程将BIOSWE连续设置为“ 1”，而另一个线程必须将数据写入SPI闪存。根据</font><font style="vertical-align: inherit;">Kallenberg和Wojtchuk </font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，此攻击适用于多核处理器，并且也可以成功地在启用了超线程技术的单核处理器上使用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为解决此问题，已通过BIOS_CNTL配置了新的保护机制。它是从英特尔平台控制器中枢（PCH）引入到芯片组家族中的。如果设置了配置位，则仅当所有内核都处于系统管理模式（SMM）且BIOSWE设置为“ 1”时，SMM BIOS写保护禁用（SMM_BWP）才允许写入BIOS区域。这样可以有效地保护系统免受上述“竞争条件漏洞”的影响。但是，与BLE一样，必须从固件端激活SMM_BWP。因此，其中错误配置了这些机制的固件会使系统处于向BIOS区域授予未经授权的写权限的风险。</font></font><br><br> <code>ReWriter_binary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">读取BIOS控制寄存器的内容以选择正确的路径。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他首先检查是否设置了BIOSWE。如果是这样，它将进入记录阶段。如果BIOSWE被禁用，它将检查BLE位的值。如果未安装，它将更改BIOSWE位的值并开始记录修补的固件。如果BLE位置1，它将检查禁用状态SMM_BWP并应用上述“竞争条件漏洞”。如果将SMM_BWP位置1，则操作将失败。下图说明了该过程。</font></font><br><br><img src="https://habrastorage.org/webt/db/3t/n5/db3tn5tpff0bgjciq9ciiy3a6p4.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图12.记录过程中的决策树</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设使用特定的分析文件</font></font><code>ReWriter_binary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来部署UEFI Rootkit，我们可以得出结论：固件错误地配置了BIOS写保护，或者受害机器的芯片组比Platform Controller Hub早。</font></font><br><br> <code>ReWriter_binary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我无法在经过良好调整的现代系统上替换UEFI固件。但是，在搜索易受攻击的SmiFlash UEFI映像时，解析UEFI固件卷表明，攻击者还可以使用更高级的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIOS绕过写保护</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以与读取过程非常相似的方式，写入SPI闪存：</font></font><br><br><img src="https://habrastorage.org/webt/ct/wi/v3/ctwiv38relsl9rpveltd8imrpjy.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图13.写入SPI闪存的顺序</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了仅执行一次的前两个步骤之外，这些操作将循环重复进行，直到将所有信息写入SPI闪存。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记录过程完成后，SPI闪存的内容将再次卸载到文件中</font></font><code>image.bin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。进行相同的完整性检查</font></font><code>ReWriter_read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在新的合并图像上运行。</font><font style="vertical-align: inherit;">然后，将从SPI闪存读取的图像与内存中的修补图像进行比较。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果任何字节不同，则将其地址写入日志。</font><font style="vertical-align: inherit;">是否存在差异不会影响恶意软件的进程。</font><font style="vertical-align: inherit;">仅记录此信息，以便操作员了解正在发生的事情。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在最后阶段，将注册表项设置为：</font></font><br><br> <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\BootExecute = “autocheck autochk *”</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，停止并删除RwDrv服务。</font><font style="vertical-align: inherit;">将这一行的值分配给Windows注册表项非常重要，因为UEFI rootkit会精确搜索此行以更改它并在Windows启动期间执行其组件。</font><font style="vertical-align: inherit;">当我们描述UEFI rootkit及其组件时，我们将更详细地讨论这一点。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LoJax技术分析 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于转储，修补和写入SPI闪存的工具是针对特定固件映像而定制的，不能在任何系统上使用。在这种情况下，可以分配完整的UEFI模块。收到此模块后，我们要做的第一件事是研究遥测数据，以了解是否曾经见过。在这种情况下，我们必须依靠可以扫描系统固件的新UEFI扫描程序。我们发现Sednit组的UEFI模块在系统中至少安装了一次，这意味着该rootkit实际上是在野外使用的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尚未确定如何将恶意工具传递到受感染的系统。最可能的是，其他程序也用于此目的，例如XAgent。转储和记录工具位于同一系统中，但时间不同-可能是操作员分多个阶段工作。首先，他们在目标计算机上卸载了固件，确保用于对程序进行调整的工具正常运行，然后重新加载并实际修补了固件。我们发现该工具仅用于转储和记录的一个版本，但是可能存在其他版本的其他固件，它们可能会发现漏洞。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下图概述了在操作系统启动之前UEFI rootkit的操作。</font><font style="vertical-align: inherit;">首先，由DXE管理器加载SecDxe DXE驱动程序。</font><font style="vertical-align: inherit;">这样，就配置了事件组的通知功能</font></font><code>EFI_EVENT_GROUP_READY_TO_BOOT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当固件准备好选择引导设备并启动引导加载程序时，将调用通知功能。</font><font style="vertical-align: inherit;">她执行三个操作：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 加载内置的NTFS DXE驱动程序，以提供对NTFS分区的访问和写入功能 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将两个文件写入NTFS Windows分区：rpcnetp.exe和autoche.exe </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将注册表项'HKEY_LOCAL_MACHINE \ SYSTEM \ CurrentControlSet \ Control \ Session Manager \ BootExecute'更改为：'autocheck autochk *'; </font><font style="vertical-align: inherit;">之后：“ autocheck autoche *”。</font></font></li></ul><br><img src="https://habrastorage.org/webt/at/qy/ec/atqyecti3adwerrfljy0ccirxgy.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图14.感染了UEFI rootkit的系统的引导过程</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SecDxe：恶意DXE驱动程序 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本节中，我们将揭示在受感染系统中发生的事件的顺序。我们从对Rootkit的描述开始，然后遵循事件链，直到最终组件在操作系统级别部署。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sednit的UEFI rootkit是带有GUID的DXE驱动程序</font></font><code>682894B5-6B70-4EBA-9E90-A607E5676297</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它没有签名，因此无法在启用了安全启动保护的系统上运行。部署到其中一个固件卷后，DXE Foundation会在每次系统启动时下载它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SecDxe是一个小型DXE驱动程序，基本上可以完成两件事。它设置了GUID专用协议。</font></font><code>832d9b4d-d8d5-425f-bd52-5c5afb2c85dc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从未使用过。然后，它创建一个与通知功能关联的事件。通知功能配置为按组呼叫信号</font></font><code>EFI_EVENT_GROUP_READY_TO_BOOT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。当准备选择要引导的设备时，来自引导管理器的信号就是这组事件的信号。</font></font><br><br><img src="https://habrastorage.org/webt/sj/ff/6o/sjff6ohskqe2ewtsv8xnyis3oss.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图15. Hex-Rays反编译器经过事件创建过程的结果</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通知功能利用了UEFI Sednit Rootkit的恶意行为。她将组件写入NTFS Windows文件系统。通常，UEFI固件仅与EFI系统分区一起使用，因此通常不包括NTFS驱动程序。仅FAT文件系统受支持作为下载分区。因此，UEFI固件不一定与NTFS驱动程序一起提供。因此，SecDxe具有自己的内置NTFS驱动程序。该驱动程序首先启动并连接到磁盘设备。即，它将安装</font></font><code>EFI_SIMPLE_FILE_SYSTEM_PROTOCOL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在具有NTFS分区的磁盘设备上，从而包括对其的文件访问。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在一切准备就绪，可以将文件写入Windows分区了，SecDxe重置</font></font><code>rpcnetp.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font></font><code>autoche.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后将其</font></font><code>rpcnetp.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装</font></font><code>%WINDIR%\SysWOW64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在64位版本的Windows或</font></font><code>%WINDIR%\System32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在32位版本上。</font><font style="vertical-align: inherit;">将A </font></font><code>autoche.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置为</font></font><code>%WINDIR%\SysWOW64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">下图显示了负责将这些文件写入磁盘的过程。</font></font><br><br><img src="https://habrastorage.org/webt/si/jo/pn/sijopnar5xrablwh02xdrv5e37a.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图16. Hex-Rays反编译器经过将文件写入磁盘的过程的结果，</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后SecDxe打开了</font></font><code>%WINDIR%\System32\config\SYSTEM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有一组注册表项备份的文件</font></font><code>HKLM\SYSTEM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他解析文件，直到找到</font></font><code>'autocheck autochk *'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并替换</font></font><code>'k'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>'autochk'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font></font><code>'e'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">结果，它</font></font><code>'HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\ BootExecute'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变为</font></font><code>'autocheck autoche *'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">下次Windows启动时，将启动autoche.exe </font></font><code>autochk.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 黑客团队NTFS驱动程序 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如前所述，NTFS驱动程序内置在SecDxe模块中。有充分的证据表明Sednit运营商没有编写自己的驱动程序，而是从Hacking Team编译了已发布的NTFS DXE驱动程序的副本。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他们的NTFS驱动程序使用ntfs-3g项目作为内核。这只是一个包装，使其可以用作UEFI DXE驱动程序。 Hacking Team驱动程序程序集INF文件本身列出了ntfs-3g项目文件名。 SecDxe NTFS驱动程序代码行也列出了许多这些文件名：</font><font style="vertical-align: inherit;">有趣的是，该项目的路径与在Hacking Team EFI开发项目vector-edk中找到的路径相同。 vector-edk中有一个子项目</font></font><br><br> <code>- c:\edk2\NtfsPkg\NtfsDxe\ntfs\inode.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\volume.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\bootsect.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\unistr.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\attrib.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\mft.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\index.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\cache.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\misc.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\dir.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\runlist.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\logfile.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\uefi_io.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\ntfsinternal.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\mst.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\lcnalloc.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\compress.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\bitmap.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\collate.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\security.c</code> <br> <br><font style="vertical-align: inherit;"></font><code>NtfsPkg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有绝对相同的目录布局。 ntfs-3g项目源文件位于相同的地址路径。尽管路径本身并不显着，但我们认为这不仅仅是巧合。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将泄漏到网络的源代码与我们在Hex-Rays反编译器的输出中获得的代码进行比较，很明显，这是同一项目。下图显示了</font></font><code>NtfsDriverBindingStart</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从中获取</font><font style="vertical-align: inherit;">功能的比较示例</font></font><code>vector-edk/NtfsPkg/NtfsDxe/Ntfs.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。删除了原始HT代码中的注释，以便更好地理解。函数调用的逻辑和顺序相同。两个项目甚至都使用一个变量（LockedByMe）来保存锁定状态。</font></font><br><br><img src="https://habrastorage.org/webt/qn/-k/ut/qn-kutvxgtnyuqkcvvo8zwfglya.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图17. Hex-Rays NTFS反编译器Sednit驱动程序（左）和NTFS HT驱动程序（右）的输出结果比较</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面的代码显示了来自黑客团队的开发人员，该团队不在开源ntfs-3g中。如本节所述</font></font><code>ReWriter_binary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在解析固件文件系统期间，可执行文件将尝试删除AMI NTFS驱动程序。我们想弄清楚为什么要删除而不是使用它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们分析了驱动程序，发现它只能执行读取操作。由于无法写入文件系统，因此开发人员无法将其用于自己的目的。由于固件中已经存在另一个NTFS驱动程序，因此Sednit操作人员也可能遇到困难，因此他们决定简单地删除它。除了实现读写功能外，Hacking Team驱动程序不遵守文件权限。例如，它可以覆盖一个只读文件而不会引起任何错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">至此，我们已经描述了UEFI Rootkit执行的各种系统折衷操作。</font><font style="vertical-align: inherit;">我们还讨论了Sednit操作员为何使用Hacking Team的vector-edk源代码来开发其NTFS驱动程序以将文件写入Windows上的NTFS分区的原因。</font><font style="vertical-align: inherit;">在本文的后面，我们将对SecDxe交付的组件进行分析。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">autoche.exe与 </font><font style="vertical-align: inherit;">autochk.exe</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恶意</font></font><code>autoche.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于确保迷你代理的持久性</font></font><code>rpcnetp.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。从下图可以看到，它使用对Windows API的本机调用来创建服务。</font></font><br><br><img src="https://habrastorage.org/webt/wc/dk/fv/wcdkfvfmcoog14t1orjmryouwd4.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图18.恶意autoche .exe配置rpcnetp.exe的持久性</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该注意的是，该服务名称与合法Computrace代理所使用的名称相同。创建服务后，它将还原以前的注册表项值</font></font><code>BootExecute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/yz/wc/lj/yzwclj1loxeconb728wvsxqvyse.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图19.恶意的autoche.exe恢复了BootExecute注册表项的原始值</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于该过程在Windows启动期间发生，因此用户不太可能会注意到密钥值的更改。</font></font><code>BootExecute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">应该注意的是，在autoche .exe中，与Computrace中的autochk.exe模块有一些相似之处，例如，所应用的API调用和服务注册，但是其余的却完全不同。</font><font style="vertical-align: inherit;">Computrace模块更大，它可以还原原始的可执行文件，</font></font><code>autochk.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不用更改注册表项。</font><font style="vertical-align: inherit;">他还负责将迷你代理部署到磁盘，而LoJax使用UEFI rootkit来完成。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rpcnetp.exe </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虽然</font></font><code>rpcnetp.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以通过UEFI Rootkit来实现</font><font style="vertical-align: inherit;">迷你代理</font><font style="vertical-align: inherit;">，但是在大多数情况下，当我们找到木马版本的LoJack时，迷你代理可能没有使用此组件。他们很可能出于机会考虑而出发，只有在有机会的时候，并且在他们最感兴趣的组织中，才安装UEFI rootkit。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在调查过程中，我们发现了LoJax迷你代理的各种版本。危害指标列表显示了它们的哈希值和相应的域/ IP地址。正如我们已经说过的，发现的所有示例都是同一旧Computrace代理（于2008年编译）的木马版本。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们从未见过LoJax代理下载和安装其他模块，但是我们知道这种功能存在。</font><font style="vertical-align: inherit;">由于LoJax的最佳品质是隐身性和持久性，因此它绝对可以用于提供对关键资源的访问。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 攻击防范与恢复 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了防止攻击，需要一个由许多活动组件组成的复杂生态系统。</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以阻止此类攻击的第一个安全机制是安全启动。启用安全启动后，必须正确签名根据固件要求下载的固件的每个组件，从而确保其完整性。</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们建议</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您启用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全启动</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">功能</font></a><font style="vertical-align: inherit;">，这是防止UEFI固件受到攻击的基本保护。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与软件一样，UEFI固件必须始终及时更新。请访问主板制造商的网站，以确保您具有最新的可用版本。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您还应确保所有系统都配备了带有Platform Controller Hub的现代芯片组（从Intel Series 5芯片组开始及以后）。这将确保安全机制与平台中存在的“竞赛条件漏洞”（如我们所</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指出的）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对抗</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">固件安全性的另一部分掌握在UEFI / BIOS供应商手中。平台提供的安全机制必须由系统固件正确配置，才能真正确保其受到保护。因此，在构建固件时应首先了解安全措施。幸运的是，越来越多的安全研究人员开始关注固件的安全性，吸引了供应商的注意。值得一提的是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CHIPSEC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是一个开放式源代码框架，可以执行低级安全性评估以确定平台是否正确配置。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消除通过UEFI固件破坏的后果是一项艰巨的任务。没有清除此类威胁的简便方法，也没有可以解决所有问题的特殊安全产品。在这里描述的情况下，要删除rootkit，必须重新刷新SPI闪存。这是一项艰巨的任务；它不适合普通用户。如果重写了闪存的整个SPI区域，则更新UEFI固件可以删除rootkit。如果无法进行UEFI闪烁，则唯一的解决方案是更换受感染系统的主板。</font></font><br><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UEFI Rootkit是网络犯罪分子最危险和功能最强大的工具之一，因为它具有很高的持久性和免疫力，可以重新安装操作系统和更换硬盘驱动器，并且具有极高的检测和删除难度。尽管系统的UEFI映像很难更改，但是很少有解决方案允许您扫描UEFI模块并在其中识别出恶意模块。此外，清理UEFI固件意味着要对其进行刷新，这不是普通用户无法执行的普通操作。这些好处说明了为什么拥有无限资源的网络集团将继续攻击UEFI系统。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对此工作有任何疑问，请联系threatintel@eset.com </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们要感谢那些致力于opensecuritytraining.info项目的人们。课程设置</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我们分析与SPI闪存芯片的交互时</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">，BIOS＆SMM简介</font></a><font style="vertical-align: inherit;">确实对我们有所帮助。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 词汇表 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关</font><font style="vertical-align: inherit;">缩写的详细说明，</font><font style="vertical-align: inherit;">请参阅</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英特尔</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规格</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-BIOS_CNTL：BIOS控制寄存器</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-BIOSWE：BIOS启用写入-BLE：BIOS </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锁定启用</font><font style="vertical-align: inherit;">-FADDR：闪存</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地址</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-FDATAX：从FDATA0到FDATAN的</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">闪存数据-FDBC：闪存数据字节计数</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-FGO：闪存循环执行</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-HSFC：硬件排序闪存控制</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-HSFS：硬件排序闪存状态-IOCTL：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入/输出控制</font><font style="vertical-align: inherit;">-PCH </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：平台控制器中枢</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-RCBA：根复杂基地址寄存器</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-RCRB：根复杂寄存器块-SCIP：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正在进行SPI周期</font><font style="vertical-align: inherit;">-SMI </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：系统管理中断</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-SMM：系统管理模式</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-SMM_BWP：SMM BIOS写保护禁用-SPI：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">串行外围接口</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 折衷指标 </font></font></h2><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ReWriter_read.exe </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检测ESET </font></font><br> <code>Win32/SPIFlash.A</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHA-1</font></font><br> <code>ea728abe26bac161e110970051e1561fd51db93b</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ReWriter_binary.exe </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检测ESET </font></font><br> <code>Win32/SPIFlash.A</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHA-1</font></font><br> <code>cc217342373967d1916cb20eca5ccb29caaf7c1b</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Secdexe </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检测ESET </font></font><br> <code>EFI/LoJax.A</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHA-1</font></font><br> <code>f2be778971ad9df2082a266bd04ab657bd287413</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> info_efi.exe </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检测ESET </font></font><br> <code>Win32/Agent.ZXZ</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHA-1</font></font><br> <code>4b9e71615b37aea1eaeb5b1cfa0eee048118ff72</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 自动安装程序 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检测ESET </font></font><br> <code>Win32/LoJax.A</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHA-1</font></font><br> <code>700d7e763f59e706b4f05c69911319690f85432e</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EXE迷你代理 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检测ESET </font><font style="vertical-align: inherit;">SHA-1</font></font><br> <code>Win32/Agent.ZQE <br> Win32/Agent.ZTU</code> <br><font style="vertical-align: inherit;"></font><br> <code>1771e435ba25f9cdfa77168899490d87681f2029 <br> ddaa06a4021baf980a08caea899f2904609410b9 <br> 10d571d66d3ab7b9ddf6a850cb9b8e38b07623c0 <br> 2529f6eda28d54490119d2123d22da56783c704f <br> e923ac79046ffa06f67d3f4c567e84a82dd7ff1b <br> 8e138eecea8e9937a83bffe100d842d6381b6bb1 <br> ef860dca7d7c928b68c4218007fb9069c6e654e9 <br> e8f07caafb23eff83020406c21645d8ed0005ca6 <br> 09d2e2c26247a4a908952fee36b56b360561984f <br> f90ccf57e75923812c2c1da9f56166b36d1482be</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 命令服务器域名 </font></font></h4><br> <code>secao[.]org <br> ikmtrust[.]com <br> sysanalyticweb[.]com <br> lxwo[.]org <br> jflynci[.]com <br> remotepx[.]net <br> rdsnets[.]com <br> rpcnetconnect[.]com <br> webstp[.]com <br> elaxo[.]org</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 命令服务器IP地址 </font></font></h4><br> <code>185.77.129[.]106 <br> 185.144.82[.]239 <br> 93.113.131[.]103 <br> 185.86.149[.]54 <br> 185.86.151[.]104 <br> 103.41.177[.]43 <br> 185.86.148[.]184 <br> 185.94.191[.]65 <br> 86.106.131[.]54</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DLL迷你代理 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESET </font></font><br> <code>Win32/Agent.ZQE</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHA-1 </font><font style="vertical-align: inherit;">检测</font></font><br> <code>397d97e278110a48bd2cb11bb5632b99a9100dbd</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令服务器域名命令服务器</font></font><br> <code>elaxo.org</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP地址</font></font><br> <code>86.106.131[.]54</code> </div> </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425251/">https://habr.com/ru/post/zh-CN425251/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425241/index.html">20年后的开发人员：瓦西里·列别杰夫（Vasily Lebedev）的ICRE，教育，他的书和编程</a></li>
<li><a href="../zh-CN425243/index.html">约翰·威利斯手册</a></li>
<li><a href="../zh-CN425245/index.html">RamblerFront和＃6的公告</a></li>
<li><a href="../zh-CN425247/index.html">测试中的众包</a></li>
<li><a href="../zh-CN425249/index.html">如何与ITMO大学的LLP相识：“低级编程”课程</a></li>
<li><a href="../zh-CN425253/index.html">我们正在用Python做一个机器学习项目。 第一部分</a></li>
<li><a href="../zh-CN425255/index.html">Broo无损压缩算法和增量编码，与Xdelta3进行比较。 家庭项目开发</a></li>
<li><a href="../zh-CN425259/index.html">使用git和Makefile备份您的网站</a></li>
<li><a href="../zh-CN425261/index.html">EV证书已失效</a></li>
<li><a href="../zh-CN425263/index.html">iFEST音乐节将在下诺夫哥罗德举行</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>