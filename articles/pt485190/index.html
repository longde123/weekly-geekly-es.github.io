<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍⚕️ ♎️ 👨🏾‍🤝‍👨🏽 Andrew Eun "Paixão pelo aprendizado de máquina". Tradução dos capítulos 47-58 🕯️ 🚅 ◽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este é o segundo artigo com uma tradução de capítulos individuais do livro de Andrew Un, Passion for Machine Learning. Você pode ler a tradução dos ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Andrew Eun "Paixão pelo aprendizado de máquina". Tradução dos capítulos 47-58</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485190/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/4t/87/qr/4t87qrmbsuxfltahjbm9iunonx4.png"></div><br><br>  Este é o segundo artigo com uma tradução de capítulos individuais do livro de Andrew Un, Passion for Machine Learning.  Você pode ler a tradução dos capítulos anteriores <a href="https://habr.com/ru/post/485070/">aqui</a> . <br><br>  Este artigo se concentrará no aprendizado profundo de ponta a ponta, assim como o autor do livro compartilhará algumas maneiras de analisar os erros do algoritmo de aprendizado. <br><a name="habracut"></a><br><h1>  Aprendizagem profunda de ponta a ponta </h1><br><hr><h3>  <font color="#548dd4">Capítulo 47. O crescimento da aprendizagem de ponta a ponta</font> </h3><hr><br>  Suponha que você deseje criar um sistema para verificar as análises de produtos na Internet, que informará automaticamente se o autor da revisão gostou ou não deste produto.  Por exemplo, você espera reconhecer a seguinte análise como muito positiva: <br><br><ul><li>  "Este é um ótimo esfregão!" </li></ul><br>  e o seguinte é extremamente negativo: <br><br><ul><li>  “Esta esfregona é de má qualidade, desculpe pela compra” </li></ul><br>  O problema de reconhecer opiniões positivas e negativas é chamado de "classificação de humor".  Para criar esse sistema, você pode criar um "pipeline" de dois componentes: <br><br><ol><li>  <b>Analisador</b> : <b>Um</b> sistema que anota texto com informações, identificando as palavras mais importantes.  <sup>1</sup> Por exemplo, você pode usar o analisador para indicar todos os adjetivos e substantivos.  Portanto, você receberá o seguinte texto anotado: <br><br><ul><li>  Este é um ótimo esfregão! </li></ul><br><blockquote>  <sup>1</sup> De fato, o analisador anota o texto muito mais rico do que o descrito, mas essa descrição simplificada será suficiente para explicar o aprendizado profundo de ponta a ponta. </blockquote><br></li><li>  <b>Classificador de sentimentos</b> : um algoritmo de aprendizado que recebe entrada de texto anotado e prevê seu humor geral.  As anotações do analisador podem ser de grande ajuda para esse algoritmo: dando mais peso aos adjetivos, seu algoritmo pode ser rapidamente lembrado ao processar palavras importantes como "excelente" e ignorar palavras menos importantes como "isso". </li></ol><br>  Podemos visualizar esse pipeline de dois componentes da seguinte maneira: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zt/3f/wy/zt3fwy4_ibclomuquousi_mxe4m.png"></div><br><br>  Recentemente, houve uma tendência a substituir os pipelines por um único algoritmo de aprendizado.  Um algoritmo de aprendizado de ponta a ponta para essa tarefa simplesmente pegaria o texto original e bruto "This is a great mop!" Como entrada e tentaria reconhecer diretamente seu humor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5l/eo/qv/5leoqvedvmnp8dr7fab15gz3n_e.png"></div><br><br>  Redes neurais são comumente usadas em sistemas de aprendizado de ponta a ponta.  O termo "passagem" refere-se ao fato de solicitarmos ao algoritmo de aprendizado que vá diretamente da entrada para o resultado desejado.  Ou seja, o algoritmo de aprendizado conecta diretamente o "final de entrada" do sistema ao "final de saída". <br><br>  Nas tarefas em que há muitos dados, os sistemas ponta a ponta têm sido extremamente bem-sucedidos.  Mas eles nem sempre são uma boa escolha.  Os próximos capítulos darão mais exemplos de sistemas transversais, além de dicas sobre quando e quando não usá-los. <br><br><hr><h3>  <font color="#548dd4">Capítulo 48. Exemplos adicionais de aprendizado transversal</font> </h3><hr><br>  Imagine que você deseja criar um sistema de reconhecimento de fala.  Você pode construir um sistema de três componentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/ja/3g/txja3gpoqs8svx3z_roiwe6800g.png"></div><br><br>  Os componentes funcionam da seguinte maneira: <br><br><ol><li>  Funções computacionais: recupere recursos projetados manualmente, como MFCC ( <a href="https://en.wikipedia.org/wiki/Mel-frequency_cepstrum">coeficientes de cepstro de frequência de mel</a> ), que tentam capturar o conteúdo de uma declaração enquanto ignoram propriedades menos importantes, como o passo na dinâmica. </li><li>  Reconhecimento de fonemas: alguns linguistas acreditam que existem unidades básicas de som chamadas "fonemas".  Por exemplo, o som inicial "k" em "keep" é o mesmo fonema que o som "c" em "cake".  Este sistema tenta reconhecer fonemas individuais em gravações de áudio. </li><li>  End Recognizer: pega uma sequência de fonemas reconhecidos e tenta vinculá-los a um registro de saída. </li></ol><br>  Em contraste com esse "pipeline", o sistema de ponta a ponta pode receber uma gravação de áudio na entrada e tentará transferi-la diretamente para a gravação de saída: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/eh/kp/xpehkpiky2bfr3fhrxsfvveefpc.png"></div><br><br>  Até agora, descrevemos apenas "transportadores" completamente lineares de aprendizado de máquina: a saída é transmitida sequencialmente de um estágio para outro.  Mas os transportadores podem ser mais complexos.  Por exemplo, aqui está uma arquitetura simples para um veículo não tripulado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  Este transportador inclui três componentes: um detecta outros carros usando a imagem da câmera, o segundo detecta pedestres e, finalmente, o último componente calcula o caminho do nosso carro para evitar colisões com outros carros e pedestres. <br><br>  Nem todos os componentes deste pipeline serão treinados.  Por exemplo, a literatura sobre "planejar o movimento de robôs" descreve muitos algoritmos para o cálculo final do percurso de um carro.  Muitos desses algoritmos não requerem treinamento. <br><br>  Pelo contrário, a abordagem de ponta a ponta pode tentar receber leituras do sensor e girar diretamente o volante na direção certa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iy/5x/rw/iy5xrwykphbakzznhiqd0la0mzw.png"></div><br><br>  Embora o treinamento de ponta a ponta tenha levado a muitos sucessos, essa nem sempre é a melhor abordagem.  Por exemplo, o reconhecimento de fala de ponta a ponta funciona bem.  Mas sou cético em relação ao treinamento transversal de direção autônoma para sistemas não tripulados.  Os próximos capítulos explicam o porquê. <br><br><hr><h3>  <font color="#548dd4">Capítulo 49. Treinamento transversal: prós e contras</font> </h3><hr><br>  Considere o exemplo anterior do pipeline de reconhecimento de fala: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/ja/3g/txja3gpoqs8svx3z_roiwe6800g.png"></div><br><br>  Muitas de suas partes são projetadas "manualmente": <br><br><ul><li>  MFCC é um conjunto de recursos de áudio especialmente projetados.  E, embora eles forneçam um resumo razoável de todo o áudio recebido na entrada, eles também simplificam o sinal recebido ao descartar algumas informações. </li><li>  Os fonemas são uma invenção dos linguistas.  Eles são uma representação imperfeita dos sons da fala.  Como os fonemas são uma aproximação aproximada da realidade, um algoritmo que usa fonemas para representar a fala limitará a eficácia de todo o sistema de reconhecimento de fala. </li></ul><br><ul><li>  Os sinais da MFCC são robustos para certas propriedades da fala que não afetam o conteúdo, como a afinação do orador.  Assim, eles ajudam a simplificar a tarefa do algoritmo de aprendizado. </li><li>  Na medida em que os fonemas são uma representação razoável da fala, eles também podem ajudar o algoritmo de aprendizado a entender os componentes básicos do som e, portanto, aumentar sua eficácia. </li></ul><br>  Ter mais componentes projetados à mão na maioria das vezes permite que um sistema de reconhecimento de fala aprenda com menos dados.  O conhecimento obtido “manualmente” usando MFCC e fonemas “complementa” o conhecimento que nosso algoritmo obtém dos dados.  Quando temos poucos dados, esse conhecimento é útil. <br><br>  Agora considere o sistema de ponta a ponta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/eh/kp/xpehkpiky2bfr3fhrxsfvveefpc.png"></div><br><br>  Este sistema não possui conhecimento suficiente obtido "manualmente".  Portanto, quando o conjunto de treinamento é pequeno, esse sistema pode funcionar pior do que um transportador projetado manualmente. <br><br>  No entanto, quando o conjunto de treinamento é grande, não há restrições devido ao uso de MFCC ou fonemas.  Se o algoritmo de aprendizado é uma rede neural suficientemente grande e se é treinado em um conjunto de treinamento suficientemente grande, ele tem um grande potencial e talvez até se aproxime da taxa de erro ideal. <br><br>  Os sistemas de ponta a ponta tendem a ser bem-sucedidos quando há muitos dados marcados para ambas as extremidades - o "final de entrada" e o "final de saída".  Neste exemplo, precisamos de um grande conjunto desses pares (áudio e transcrição).  Quando dados desse tipo não estiverem disponíveis para você, aborde o aprendizado com muito cuidado. <br><br>  Se você estiver trabalhando em uma tarefa de aprendizado de máquina na qual o conjunto de treinamento é muito pequeno, a maioria das informações disponíveis para o seu algoritmo será obtida graças à sua compreensão humana, ou seja,  de componentes projetados manualmente. <br><br>  Se você preferir não usar um sistema de ponta a ponta, precisará decidir quais etapas serão no seu pipeline e como elas devem se encaixar.  No próximo capítulo, ofereceremos algumas idéias para projetar esses sistemas. <br><br><hr><h3>  <font color="#548dd4">Capítulo 50. Seleção de Componentes de Pipeline: Disponibilidade de Dados</font> </h3><hr><br>  Quando você constrói um transportador que não é um sistema de ponta a ponta, quais componentes desse transportador serão uma boa escolha?  Como você projeta o transportador afetará bastante o desempenho geral do sistema.  Um fator importante é a capacidade de coletar dados com facilidade para treinar cada componente. <br><br>  Por exemplo, considere esta arquitetura de direção autônoma: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  Você pode usar algoritmos de aprendizado de máquina para detectar carros e pedestres.  Além disso, não é difícil para eles coletar dados: existem muitos conjuntos prontos de dados de visão por computador com um grande número de carros e pedestres marcados.  Você também pode usar o crowdsourcing (como o Amazon Mechanical Turk) para obter conjuntos de dados ainda maiores.  Portanto, será relativamente fácil coletar dados de treinamento para criar um detector de carro e um detector de pedestres. <br><br>  Pelo contrário, considere um sistema limpo de ponta a ponta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iy/5x/rw/iy5xrwykphbakzznhiqd0la0mzw.png"></div><br><br>  Para treinar esse sistema, precisamos de um grande conjunto de elementos já mapeados (imagem = volante girando na direção certa).  Essa é uma tarefa muito demorada e cara.  Para coletar esses dados, é necessário que as pessoas dirijam carros e registrem dados sobre cada volta do volante.  Você precisará de toda uma frota de carros especialmente equipados e um grande número de horas de trabalho para cobrir a maior variedade possível de situações.  Isso torna o sistema de ponta a ponta muito difícil de aprender.  É muito mais fácil tirar um grande conjunto de imagens rotuladas de carros e pedestres. <br><br>  Em um sentido mais geral, se houver muitos dados disponíveis para o treinamento de módulos transportadores "intermediários" (como um detector de carro ou um detector de pedestres), será necessário pensar em usar um transportador composto por vários componentes.  Esse método pode funcionar melhor, porque  Você pode usar todos os dados disponíveis para treinar módulos intermediários. <br><br>  Até que haja mais dados para modelos de ponta a ponta, acredito que a abordagem tradicional é muito mais promissora para direção autônoma: sua arquitetura combina melhor com a disponibilidade atual de dados. <br><br><hr><h3>  <font color="#548dd4">Capítulo 51. Escolhendo Componentes do Transportador: Simplicidade da Tarefa</font> </h3><hr><br>  Além da disponibilidade de dados, você também deve considerar o segundo fator ao escolher componentes de pipeline: quão simples são as tarefas que os componentes individuais resolvem?  Você deve tentar selecionar os componentes do transportador para que sejam fáceis de construir ou aprender.  Mas o que significa um componente ser fácil de aprender? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fc/bg/fy/fcbgfyb4ggr4u6m79xy01h6gtqa.png"></div><br><br>  Considere as seguintes tarefas de aprendizado de máquina, listadas em ordem crescente de complexidade: <br><br><ol><li>  A definição é superexposta à imagem apresentada (como no exemplo acima). </li><li>  Determinar se uma imagem é tirada em ambientes internos ou externos. </li><li>  Determinando se há um gato na imagem. </li><li>  Determinando se há um gato na imagem com pêlo preto e branco. </li><li>  Determinação da existência de um gato siamês na imagem (qualquer raça específica de gatos). </li></ol><br>  Para cada um desses problemas de classificação binária, é necessário obter uma imagem na entrada e na saída 0 ou 1. Mas as tarefas listadas anteriormente na lista parecem ser mais fáceis de aprender nas redes neurais.  Você pode treinar o algoritmo para tarefas mais simples com menos exemplos de treinamento. <br><br>  No estágio atual do aprendizado de máquina, não há uma boa definição formal do que torna uma tarefa fácil ou difícil.  <sup>2</sup> Com o crescimento da aprendizagem profunda e das redes neurais multicamadas, às vezes chamamos o problema de fácil, se ele pode ser resolvido com menos etapas de cálculo (por exemplo, usando redes neurais com um pequeno número de camadas), e chamamos a tarefa de difícil se exigir mais etapas. computação (que corresponde a uma rede neural profunda).  Mas esta é uma definição informal. <br><blockquote>  <sup>2</sup> Na teoria algorítmica da informação, existe o conceito de complexidade de Kolmogorov, que afirma que a complexidade da função que está sendo estudada é a duração do menor programa de computador que pode produzir essa função.  Este conceito teórico encontrou várias aplicações práticas em IA. </blockquote><br>  Se você tiver a oportunidade de dividir uma tarefa complexa em subtarefas mais simples, codificando com precisão cada subtarefa, você fornecerá ao algoritmo um conhecimento mais importante que pode ajudá-lo a resolver com mais eficiência todo o problema. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cm/cm/so/cmcmsoncvrly_eqnmdswoqxyqcc.png"></div><br><br>  Imagine que você está projetando um detector de gato siamês.  Aqui está uma arquitetura de ponta a ponta limpa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/ex/em/3gexemhnlou8qon3qwpprhtcidm.png"></div><br><br>  Pelo contrário, você pode usar um transportador de dois componentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br>  Na primeira etapa (detector de gato), todos os gatos da imagem serão reconhecidos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9q/a4/wu/9qa4wugiqcvqysomntw52alpy8q.png"></div><br><br>  Em seguida, na segunda etapa, as imagens colhidas de cada um dos gatos detectados, uma de cada vez, são transferidas para o classificador da raça.  E finalmente, se algum dos gatos detectados for um gato siamês, obtemos "1" na saída. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ns/oj/ii/nsojiirbbbuni7qkmrokqmuksfm.png"></div><br><br>  Comparado ao ensino de um classificador puramente de passagem que usa apenas tags 0/1, cada um dos dois componentes no pipeline (detector de gatos e classificador de raças) parece mais fácil de aprender e requer significativamente menos dados.  <sup>3</sup> <br><blockquote>  <sup>3</sup> Se você estiver familiarizado com os algoritmos de detecção de objetos que são realmente utilizados na prática, entenderá que eles são treinados não apenas com os rótulos de imagem 0/1.  Em vez disso, eles são treinados usando a estrutura restritiva fornecida como parte dos dados de treinamento.  A discussão deles está além do escopo deste capítulo. </blockquote><br>  E o último exemplo, lembremos novamente o pipeline da tarefa de direção autônoma: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  Usando esse transportador, você informa ao algoritmo que existem três etapas principais na condução de um carro: <br><br><ul><li>  Reconheça outros carros. </li><li>  Reconheça pedestres. </li><li>  Planeje a direção de mais movimentos. </li></ul><br>  Cada uma dessas etapas é uma tarefa mais simples e pode ser treinada com menos dados do que com uma abordagem puramente transversal. <br><br>  Como resultado, ao decidir quais devem ser os componentes do pipeline, tente criar um pipeline em que cada componente seja uma função relativamente "simples" que só possa ser treinada em uma pequena quantidade de dados. <br><br><hr><h3>  <font color="#548dd4">Capítulo 52. Aprendendo com informações imersivas</font> </h3><hr><br>  O algoritmo de classificação de imagem pega uma imagem de entrada X e produz um número inteiro, que é um rótulo para a categoria do objeto.  Em vez disso, o algoritmo pode emitir uma frase inteira descrevendo a imagem? <br><br>  Por exemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/12/z6/-v/12z6-votwnq7mu2j9rwukqce52k.png"></div><br><br>  Y = "Um ônibus amarelo está dirigindo pela estrada em meio a árvores e grama verde." <br><br>  A aplicação tradicional do ensino com um professor envolve a presença de uma função treinada h: X → Y, onde a saída (y) é geralmente representada por um número inteiro ou natural.  Por exemplo: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Desafio </th><th>  X </th><th>  Y </th></tr><tr><td>  <b>Antispam</b> </td><td>  E-mail </td><td>  Spam / Não Spam (0/1) </td></tr><tr><td>  <b>Reconhecimento de imagem</b> </td><td>  Imagem </td><td>  Rótulo inteiro </td></tr><tr><td>  <b>Previsão de Preços Imobiliários</b> </td><td>  Características da casa </td><td>  Preço em dólares </td></tr><tr><td>  <b>Recomendação do produto</b> </td><td>  Especificações do produto e do cliente </td><td>  Probabilidade de compra </td></tr></tbody></table></div><br><br>  Uma das coisas mais empolgantes sobre a aprendizagem profunda transversal é que ela nos permite aprender diretamente Y, o que é muito mais complicado que os números.  No exemplo da tarefa de descrição da imagem mencionada acima, você pode aplicar alguma imagem (x) à entrada da rede neural e obter uma descrição imediata (y) na saída. <br><br>  Aqui estão alguns exemplos: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Desafio </th><th>  X </th><th>  Y </th><th>  Citação do trabalho </th></tr><tr><td>  <b>Descrição das Imagens</b> </td><td>  Imagem </td><td>  Text </td><td>  Mao e outros, 2014 </td></tr><tr><td>  <b>Tradução automática</b> </td><td>  Texto em inglês </td><td>  Texto em francês </td><td>  Suskever e outros, 2014 </td></tr><tr><td>  <b>Respostas às perguntas</b> </td><td>  Par (texto + pergunta) </td><td>  Resposta à pergunta </td><td>  Bordes e outros, 2015 </td></tr><tr><td>  <b>Reconhecimento de fala</b> </td><td>  Áudio </td><td>  Transcrição </td><td>  Hannun e outros, 2015 </td></tr><tr><td>  <b>Conversão de texto em fala</b> </td><td>  Tags de texto </td><td>  Áudio </td><td>  Van der Oord et al., 2016 </td></tr></tbody></table></div><br><br>  Essa é uma tendência crescente no aprendizado profundo: quando você tem os pares rotulados (entrada e saída) corretos, às vezes pode escolher um treinamento de ponta a ponta, mesmo se a saída for uma frase, imagem, áudio ou qualquer outra saída que contenha muito mais informações, do que apenas números de etiqueta única. <br><br><h1>  Análise de erro parcial </h1><hr><h3>  <font color="#548dd4">Capítulo 53. Análise de erros em partes</font> </h3><hr><br>  Suponha que seu sistema seja construído usando um sofisticado pipeline de aprendizado de máquina e você gostaria de melhorar a eficiência do sistema.  Qual parte do transportador você deve melhorar?  Atribuindo erros a partes específicas do pipeline, você pode decidir como priorizar seu trabalho. <br><br>  Vamos usar nosso exemplo de classificador de gatos siameses: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br>  A primeira parte, um detector de gatos, detecta gatos e os corta para fora de toda a imagem.  A segunda parte, o classificador de raças de gatos, decide se esse gato é um gato siamês.  Você pode passar anos trabalhando para melhorar qualquer um desses dois componentes do transportador.  Como você decide em qual componente focar? <br><br>  Executando a análise de erros em partes, você pode tentar atribuir cada erro do algoritmo a uma das duas partes do pipeline (e às vezes as duas ao mesmo tempo).  Por exemplo, o algoritmo classifica incorretamente essa imagem como não contendo um gato siamês (y = 0), embora o rótulo correto seja y = 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hj/ju/2g/hjju2gw3fble1fcgc8fblrenkms.png"></div><br><br>  Vamos verificar manualmente o que o algoritmo faz em cada uma das duas etapas.  Suponha que um detector de gato siamês detectou um gato da seguinte maneira: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oe/0l/rx/oe0lrx5ysvmznqkmbl83m_k_46g.png"></div><br><br>  Isso significa que o classificador da raça de gato receberá esta imagem: <br><br><img src="https://habrastorage.org/webt/ft/wm/vs/ftwmvsdrnvpp2f9vrds36flldzo.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O classificador da raça classifica corretamente esta imagem como não contendo um gato siamês. Portanto, o classificador de raças de gatos é inocente: ele recebeu um punhado de pedras na entrada e deu uma nota bastante razoável y = 0. De fato, uma pessoa que classifica a imagem cortada acima também prediz y = 0. Portanto, você pode atribuir claramente esse erro a detector de gato. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por outro lado, se um detector de gato exibir a seguinte caixa delimitadora:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oz/qu/no/ozqunon7ny51kw1ukglsfl3hjj8.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">então você concluiria que o detector de gatos fez seu trabalho corretamente e o erro ocorreu devido ao classificador da raça. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que você tenha passado por 100 imagens classificadas incorretamente de uma amostra de validação e encontrado 90 erros relacionados a um detector de gatos e apenas 10 erros relacionados a um classificador de raça de gato. Você pode concluir com segurança que deveria se concentrar mais em melhorar o seu detector de gatos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além disso, você também encontrou com sucesso 90 exemplos em que o detector de gato trouxe a caixa delimitadora errada. Você pode usar esses 90 exemplos para uma </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">análise </font><font style="vertical-align: inherit;">mais profunda </font><font style="vertical-align: inherit;">dos erros do detector de gatos e ver como melhorá-los.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossa descrição de como atribuir o erro a uma parte do pipeline até agora tem sido informal: você analisa a saída de cada parte e vê se consegue decidir qual cometeu o erro. </font><font style="vertical-align: inherit;">Este método informal pode ser suficiente. </font><font style="vertical-align: inherit;">Mas no próximo capítulo, você também verá uma maneira mais formal de atribuir erros.</font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capítulo 54. Atribuição de erro a uma parte específica</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos continuar com o nosso exemplo: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suponha que o detector de gato tenha produzido esta caixa delimitadora: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bc/_d/8k/bc_d8kmcijt314qterhumctdyyq.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, o classificador da raça recebeu essa imagem cortada, após a qual emitiu incorretamente y = 0, ou seja, </font><font style="vertical-align: inherit;">que não há gato na foto.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/71/mu/ld/71muldvuqnfx0cd_a6bpo41xzvc.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O detector de gatos fez um mau trabalho. </font><font style="vertical-align: inherit;">Enquanto uma pessoa treinada, sem dúvida, será capaz de reconhecer o gato siamês nesta imagem cortada. </font><font style="vertical-align: inherit;">Portanto, atribuímos esse erro a um detector de gatos, a um classificador de raças ou a ambos? </font><font style="vertical-align: inherit;">Claro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o número de casos controversos for pequeno, podemos tomar qualquer decisão e obter um resultado semelhante. </font><font style="vertical-align: inherit;">Mas aqui está um teste mais formal, que permite atribuir com mais precisão o erro a exatamente uma parte:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Substitua a saída do detector de gato por um quadro marcado manualmente. </font></font><br><img src="https://habrastorage.org/webt/np/8f/zy/np8fzyx2lfbh1cdbd-o7iiykpvq.png"></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passe a imagem cortada correspondente pelo classificador da raça. </font><font style="vertical-align: inherit;">Se o classificador de raça ainda não classificar a imagem corretamente, atribua o erro ao classificador de raça. </font><font style="vertical-align: inherit;">Caso contrário, atribua o erro ao detector de gato.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em outras palavras, conduza um experimento no qual você envia dados ideais para a entrada do classificador de rochas. </font><font style="vertical-align: inherit;">Nesse caso, são possíveis 2 opções:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mesmo com um quadro ideal, o classificador de raças erroneamente y = 0. Nesse caso, o classificador é sem dúvida o culpado. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tendo recebido um quadro ideal, o classificador da raça corretamente y = 1. Isso mostra que, se apenas o detector de gatos produzisse uma caixa delimitadora mais perfeita, a conclusão geral do sistema estaria correta. </font><font style="vertical-align: inherit;">Assim, atribuímos o erro ao detector de gato.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de executar essa análise de imagens classificadas incorretamente a partir da amostra de validação, agora você pode atribuir inequivocamente cada erro a um componente. </font><font style="vertical-align: inherit;">Isso permite estimar a proporção de erros associados a cada componente do pipeline e, portanto, decidir em que focar sua atenção.</font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capítulo 55. O caso principal de atribuição de erros</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui estão as etapas gerais para atribuir erros. </font><font style="vertical-align: inherit;">Suponha que o pipeline tenha três estágios A, B e C, onde A é alimentado diretamente para B e B é alimentado diretamente para C.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ok/tz/0i/oktz0iqvw81g6gbnxdwvehsmo50.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para cada erro que o sistema comete na amostra de validação: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tente substituir manualmente a saída do estágio A pela saída "ideal" (ou seja, caixa delimitadora "ideal" para o gato)) e continue com o restante do transportador B, C por essa saída. </font><font style="vertical-align: inherit;">Se o algoritmo agora produzir o resultado correto, isso indica que apenas o estágio A deve melhorar sua própria saída para que todo o algoritmo funcione corretamente. </font><font style="vertical-align: inherit;">Portanto, você pode atribuir esse erro ao componente A. Caso contrário, vá para a etapa 2.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tente substituir manualmente a saída do estágio B pela saída "perfeita". </font><font style="vertical-align: inherit;">Se o algoritmo inteiro começar a funcionar corretamente, atribua o erro ao componente B. Caso contrário, vá para a etapa 3.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atribua o erro ao componente C. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Veja um exemplo mais complexo: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seu drone usa este transportador. </font><font style="vertical-align: inherit;">Como, usando a análise de erro fragmentada, para determinar em qual componente focar? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode marcar os componentes da seguinte maneira:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A. Reconhecer carros. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> B. Reconhecer pedestres. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C. Planeje o caminho. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seguindo o procedimento descrito acima, suponha que você teste seu carro em um campo de treinamento fechado e encontre um caso em que o carro escolha uma manobra em uma direção mais nítida do que um motorista experiente faria. </font><font style="vertical-align: inherit;">No mundo da direção não tripulada, esse evento é geralmente chamado de script. </font><font style="vertical-align: inherit;">Nesse caso:</font></font><br><br><ol><li>      A ( )  «»  (..     ).     B  C   ,    C ( )  «»   A.        ,    ,     A   ,     .        A.     2. </li><li>      B ( )  «» .      ,      B.     3. </li><li>    C. </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os componentes do pipeline de aprendizado de máquina devem ser organizados de acordo com um gráfico acíclico direcionado (DAG), o que significa que você deve poder calculá-los em alguma ordem fixa da esquerda para a direita, e os componentes posteriores devem depender apenas das saídas dos componentes anteriores. </font><font style="vertical-align: inherit;">Desde que a </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disposição dos componentes na ordem A → B → C corresponda à ordem do DAG, a análise de erro continuará corretamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode obter resultados ligeiramente diferentes se você trocar A e B:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A. Reconhecer peões (anteriormente reconhecimento de automóveis) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> B. Reconhecer carros (anteriormente reconhecimento de pedestres) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C. Planeje o caminho do seu carro </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mas o resultado dessa análise ainda permanecerá verdadeiro e dará uma boa orientação sobre o que você deve focar sua atenção. </font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capítulo 56. Análise de erros em partes e comparação com eficiência no nível humano</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A condução de uma análise de erro em um algoritmo de aprendizado é semelhante ao uso da ciência de dados para analisar erros do sistema ML, a fim de ter uma idéia do que fazer em seguida. </font><font style="vertical-align: inherit;">Na maioria dos casos, uma análise de erro fragmentada nos dirá qual componente vale a pena tentar melhorar acima de tudo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digamos que você tenha algum conjunto de dados sobre clientes que compram itens em um site. Um cientista de dados pode analisar dados de várias maneiras diferentes. Ele pode tirar muitas conclusões diferentes sobre se o site deve aumentar os preços, o valor dos clientes adquiridos por meio de várias campanhas de marketing e assim por diante. Não existe uma maneira “certa” única de analisar um conjunto de dados; existem muitas idéias úteis possíveis que podem surgir. Da mesma forma, não existe uma maneira "certa" de analisar erros. Nesses capítulos, você aprendeu alguns dos padrões de design mais comuns para obter informações úteis sobre o seu sistema ML, mas também pode experimentar livremente outros métodos de análise de erros.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De volta ao aplicativo de veículo não tripulado, no qual o algoritmo de detecção de carro exibe a localização (e possivelmente a velocidade) dos carros próximos, o algoritmo de detecção de pedestres exibe a localização dos pedestres mais próximos e essas duas saídas são finalmente usadas para planejar o caminho do carro. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para depurar esse pipeline e não seguir estritamente o procedimento que você viu no capítulo anterior, você pode fazer as seguintes perguntas: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A que distância está o algoritmo de reconhecimento de carro da eficiência humana na solução de um problema semelhante? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qual a distância do algoritmo de reconhecimento de pedestres do desempenho humano na solução de um problema semelhante? </font></font></li><li>         ?      ,       ,          (      ).  ,    « »    ,        ? </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você achar que um dos componentes do sistema está longe da eficiência humana, terá uma boa oportunidade de se concentrar em melhorar a eficácia desse componente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muitos processos de análise de erro funcionam melhor quando tentamos automatizar algo que uma pessoa pode fazer; portanto, comparamos os resultados com os de uma pessoa. A maioria dos exemplos anteriores tinha essa suposição implícita. Se você estiver construindo um sistema de ML no qual a saída final ou alguns dos componentes intermediários fazem coisas que nem uma pessoa consegue fazer bem, alguns desses procedimentos não se aplicam.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Essa é outra vantagem de trabalhar em problemas que as pessoas podem resolver - você possui ferramentas mais poderosas para analisar erros e, portanto, pode priorizar com mais eficiência o trabalho de sua equipe. </font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capítulo 57. Detecção de Erros no Pipeline ML</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E se cada componente individual do seu transportador ML mostrar eficiência no nível humano ou um pouco mais baixo, mas o transportador geral não corresponder ao nível humano? </font><font style="vertical-align: inherit;">Normalmente, isso significa que o transportador tem falhas e precisa ser redesenhado. </font><font style="vertical-align: inherit;">A análise de erros também pode ajudá-lo a descobrir se seu pipeline precisa ser redesenhado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No capítulo anterior, colocamos a pergunta: cada um dos três componentes mostra eficiência no nível humano? </font><font style="vertical-align: inherit;">Suponha que a resposta para todas as três perguntas seja afirmativa. </font><font style="vertical-align: inherit;">Então:</font></font><br><br><ol><li> ,  ,   ()           . </li><li> ,  ,   ()           . </li><li> ,   ,     ,    ,      ,                (     ). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, seu veículo não tripulado lida com a condução significativamente pior do que uma pessoa. Ou seja, as pessoas que têm acesso às imagens da câmera podem planejar o caminho do carro muito melhor. Que conclusão você pode tirar? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A única conclusão possível é que seu pipeline de ML não foi projetado corretamente. Nesse caso, o componente que planeja o caminho do carro funciona, além de permitir dados recebidos que não contêm informações suficientes. Você deve se perguntar que outras informações que não estão na saída dos dois componentes anteriores são necessárias para um excelente planejamento do percurso do carro. Em outras palavras, que outras informações são usadas por um motorista experiente?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que você entenda que um motorista humano também precisa ver as marcações na estrada. Isso sugere que você deve fazer engenharia reversa do pipeline da seguinte maneira: </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/qa/wy/msqawygb_nyn4twj9cnbbiqlad0.png"></div><br><blockquote> <sup>4</sup>       ,     ,         .       «Task simplicity»,    51,            ,          .     «  »    —               ,        /  . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por fim, se você acha que seu pipeline como um todo não será capaz de alcançar a eficiência humana, mesmo que cada componente individual tenha eficiência no nível humano (lembre-se de que você está comparando com uma pessoa que tem a mesma entrada que o componente) , esse transportador tem desvantagens e deve ser reprojetado. </font></font><br><br><h1>  Conclusão </h1><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capítulo 58. Crie uma super equipe, compartilhe esse conhecimento com os camaradas</font></font></font> </h3><hr><br>  Parabéns por completar este livro! <br>  No capítulo 2, falamos sobre como este livro pode ajudá-lo a se tornar um super-herói em sua equipe. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/8d/ta/ms8dta_asiaioa6tttb3dsl4syo.png"></div><br><br>  A única coisa que pode ser melhor do que ser um super-herói é fazer parte de uma equipe de super-heróis.  Espero que você compartilhe cópias deste livro com seus amigos e colegas de equipe e ajude a criar outros super-heróis! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485190/">https://habr.com/ru/post/pt485190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485178/index.html">Metodologia para reconstrução de edifícios perdidos a partir de fotografias</a></li>
<li><a href="../pt485180/index.html">Precisamos de um lago de dados? O que fazer com o data warehouse?</a></li>
<li><a href="../pt485182/index.html">Sennheiser em 2020 - fones de ouvido sem fio atualizados para o aniversário</a></li>
<li><a href="../pt485184/index.html">Resultados da votação com guias</a></li>
<li><a href="../pt485186/index.html">Startup de trilhões de dólares ou como nasceram as empresas Valley de maior sucesso</a></li>
<li><a href="../pt485194/index.html">Árvore de segmentos: rápido e fácil</a></li>
<li><a href="../pt485196/index.html">AvitoTech On Tour: Vá e participe de reuniões em Kazan</a></li>
<li><a href="../pt485198/index.html">Outra maneira de medir o desempenho dos métodos de aplicativo .NET</a></li>
<li><a href="../pt485200/index.html">Confusão no início: post-mortem na velocidade de lançamento de um aplicativo iOS</a></li>
<li><a href="../pt485202/index.html">Sistema de Supressão</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>