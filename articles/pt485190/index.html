<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚öïÔ∏è ‚ôéÔ∏è üë®üèæ‚Äçü§ù‚Äçüë®üèΩ Andrew Eun "Paix√£o pelo aprendizado de m√°quina". Tradu√ß√£o dos cap√≠tulos 47-58 üïØÔ∏è üöÖ ‚óΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este √© o segundo artigo com uma tradu√ß√£o de cap√≠tulos individuais do livro de Andrew Un, Passion for Machine Learning. Voc√™ pode ler a tradu√ß√£o dos ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Andrew Eun "Paix√£o pelo aprendizado de m√°quina". Tradu√ß√£o dos cap√≠tulos 47-58</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485190/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/4t/87/qr/4t87qrmbsuxfltahjbm9iunonx4.png"></div><br><br>  Este √© o segundo artigo com uma tradu√ß√£o de cap√≠tulos individuais do livro de Andrew Un, Passion for Machine Learning.  Voc√™ pode ler a tradu√ß√£o dos cap√≠tulos anteriores <a href="https://habr.com/ru/post/485070/">aqui</a> . <br><br>  Este artigo se concentrar√° no aprendizado profundo de ponta a ponta, assim como o autor do livro compartilhar√° algumas maneiras de analisar os erros do algoritmo de aprendizado. <br><a name="habracut"></a><br><h1>  Aprendizagem profunda de ponta a ponta </h1><br><hr><h3>  <font color="#548dd4">Cap√≠tulo 47. O crescimento da aprendizagem de ponta a ponta</font> </h3><hr><br>  Suponha que voc√™ deseje criar um sistema para verificar as an√°lises de produtos na Internet, que informar√° automaticamente se o autor da revis√£o gostou ou n√£o deste produto.  Por exemplo, voc√™ espera reconhecer a seguinte an√°lise como muito positiva: <br><br><ul><li>  "Este √© um √≥timo esfreg√£o!" </li></ul><br>  e o seguinte √© extremamente negativo: <br><br><ul><li>  ‚ÄúEsta esfregona √© de m√° qualidade, desculpe pela compra‚Äù </li></ul><br>  O problema de reconhecer opini√µes positivas e negativas √© chamado de "classifica√ß√£o de humor".  Para criar esse sistema, voc√™ pode criar um "pipeline" de dois componentes: <br><br><ol><li>  <b>Analisador</b> : <b>Um</b> sistema que anota texto com informa√ß√µes, identificando as palavras mais importantes.  <sup>1</sup> Por exemplo, voc√™ pode usar o analisador para indicar todos os adjetivos e substantivos.  Portanto, voc√™ receber√° o seguinte texto anotado: <br><br><ul><li>  Este √© um √≥timo esfreg√£o! </li></ul><br><blockquote>  <sup>1</sup> De fato, o analisador anota o texto muito mais rico do que o descrito, mas essa descri√ß√£o simplificada ser√° suficiente para explicar o aprendizado profundo de ponta a ponta. </blockquote><br></li><li>  <b>Classificador de sentimentos</b> : um algoritmo de aprendizado que recebe entrada de texto anotado e prev√™ seu humor geral.  As anota√ß√µes do analisador podem ser de grande ajuda para esse algoritmo: dando mais peso aos adjetivos, seu algoritmo pode ser rapidamente lembrado ao processar palavras importantes como "excelente" e ignorar palavras menos importantes como "isso". </li></ol><br>  Podemos visualizar esse pipeline de dois componentes da seguinte maneira: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zt/3f/wy/zt3fwy4_ibclomuquousi_mxe4m.png"></div><br><br>  Recentemente, houve uma tend√™ncia a substituir os pipelines por um √∫nico algoritmo de aprendizado.  Um algoritmo de aprendizado de ponta a ponta para essa tarefa simplesmente pegaria o texto original e bruto "This is a great mop!" Como entrada e tentaria reconhecer diretamente seu humor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5l/eo/qv/5leoqvedvmnp8dr7fab15gz3n_e.png"></div><br><br>  Redes neurais s√£o comumente usadas em sistemas de aprendizado de ponta a ponta.  O termo "passagem" refere-se ao fato de solicitarmos ao algoritmo de aprendizado que v√° diretamente da entrada para o resultado desejado.  Ou seja, o algoritmo de aprendizado conecta diretamente o "final de entrada" do sistema ao "final de sa√≠da". <br><br>  Nas tarefas em que h√° muitos dados, os sistemas ponta a ponta t√™m sido extremamente bem-sucedidos.  Mas eles nem sempre s√£o uma boa escolha.  Os pr√≥ximos cap√≠tulos dar√£o mais exemplos de sistemas transversais, al√©m de dicas sobre quando e quando n√£o us√°-los. <br><br><hr><h3>  <font color="#548dd4">Cap√≠tulo 48. Exemplos adicionais de aprendizado transversal</font> </h3><hr><br>  Imagine que voc√™ deseja criar um sistema de reconhecimento de fala.  Voc√™ pode construir um sistema de tr√™s componentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/ja/3g/txja3gpoqs8svx3z_roiwe6800g.png"></div><br><br>  Os componentes funcionam da seguinte maneira: <br><br><ol><li>  Fun√ß√µes computacionais: recupere recursos projetados manualmente, como MFCC ( <a href="https://en.wikipedia.org/wiki/Mel-frequency_cepstrum">coeficientes de cepstro de frequ√™ncia de mel</a> ), que tentam capturar o conte√∫do de uma declara√ß√£o enquanto ignoram propriedades menos importantes, como o passo na din√¢mica. </li><li>  Reconhecimento de fonemas: alguns linguistas acreditam que existem unidades b√°sicas de som chamadas "fonemas".  Por exemplo, o som inicial "k" em "keep" √© o mesmo fonema que o som "c" em "cake".  Este sistema tenta reconhecer fonemas individuais em grava√ß√µes de √°udio. </li><li>  End Recognizer: pega uma sequ√™ncia de fonemas reconhecidos e tenta vincul√°-los a um registro de sa√≠da. </li></ol><br>  Em contraste com esse "pipeline", o sistema de ponta a ponta pode receber uma grava√ß√£o de √°udio na entrada e tentar√° transferi-la diretamente para a grava√ß√£o de sa√≠da: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/eh/kp/xpehkpiky2bfr3fhrxsfvveefpc.png"></div><br><br>  At√© agora, descrevemos apenas "transportadores" completamente lineares de aprendizado de m√°quina: a sa√≠da √© transmitida sequencialmente de um est√°gio para outro.  Mas os transportadores podem ser mais complexos.  Por exemplo, aqui est√° uma arquitetura simples para um ve√≠culo n√£o tripulado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  Este transportador inclui tr√™s componentes: um detecta outros carros usando a imagem da c√¢mera, o segundo detecta pedestres e, finalmente, o √∫ltimo componente calcula o caminho do nosso carro para evitar colis√µes com outros carros e pedestres. <br><br>  Nem todos os componentes deste pipeline ser√£o treinados.  Por exemplo, a literatura sobre "planejar o movimento de rob√¥s" descreve muitos algoritmos para o c√°lculo final do percurso de um carro.  Muitos desses algoritmos n√£o requerem treinamento. <br><br>  Pelo contr√°rio, a abordagem de ponta a ponta pode tentar receber leituras do sensor e girar diretamente o volante na dire√ß√£o certa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iy/5x/rw/iy5xrwykphbakzznhiqd0la0mzw.png"></div><br><br>  Embora o treinamento de ponta a ponta tenha levado a muitos sucessos, essa nem sempre √© a melhor abordagem.  Por exemplo, o reconhecimento de fala de ponta a ponta funciona bem.  Mas sou c√©tico em rela√ß√£o ao treinamento transversal de dire√ß√£o aut√¥noma para sistemas n√£o tripulados.  Os pr√≥ximos cap√≠tulos explicam o porqu√™. <br><br><hr><h3>  <font color="#548dd4">Cap√≠tulo 49. Treinamento transversal: pr√≥s e contras</font> </h3><hr><br>  Considere o exemplo anterior do pipeline de reconhecimento de fala: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/ja/3g/txja3gpoqs8svx3z_roiwe6800g.png"></div><br><br>  Muitas de suas partes s√£o projetadas "manualmente": <br><br><ul><li>  MFCC √© um conjunto de recursos de √°udio especialmente projetados.  E, embora eles forne√ßam um resumo razo√°vel de todo o √°udio recebido na entrada, eles tamb√©m simplificam o sinal recebido ao descartar algumas informa√ß√µes. </li><li>  Os fonemas s√£o uma inven√ß√£o dos linguistas.  Eles s√£o uma representa√ß√£o imperfeita dos sons da fala.  Como os fonemas s√£o uma aproxima√ß√£o aproximada da realidade, um algoritmo que usa fonemas para representar a fala limitar√° a efic√°cia de todo o sistema de reconhecimento de fala. </li></ul><br><ul><li>  Os sinais da MFCC s√£o robustos para certas propriedades da fala que n√£o afetam o conte√∫do, como a afina√ß√£o do orador.  Assim, eles ajudam a simplificar a tarefa do algoritmo de aprendizado. </li><li>  Na medida em que os fonemas s√£o uma representa√ß√£o razo√°vel da fala, eles tamb√©m podem ajudar o algoritmo de aprendizado a entender os componentes b√°sicos do som e, portanto, aumentar sua efic√°cia. </li></ul><br>  Ter mais componentes projetados √† m√£o na maioria das vezes permite que um sistema de reconhecimento de fala aprenda com menos dados.  O conhecimento obtido ‚Äúmanualmente‚Äù usando MFCC e fonemas ‚Äúcomplementa‚Äù o conhecimento que nosso algoritmo obt√©m dos dados.  Quando temos poucos dados, esse conhecimento √© √∫til. <br><br>  Agora considere o sistema de ponta a ponta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/eh/kp/xpehkpiky2bfr3fhrxsfvveefpc.png"></div><br><br>  Este sistema n√£o possui conhecimento suficiente obtido "manualmente".  Portanto, quando o conjunto de treinamento √© pequeno, esse sistema pode funcionar pior do que um transportador projetado manualmente. <br><br>  No entanto, quando o conjunto de treinamento √© grande, n√£o h√° restri√ß√µes devido ao uso de MFCC ou fonemas.  Se o algoritmo de aprendizado √© uma rede neural suficientemente grande e se √© treinado em um conjunto de treinamento suficientemente grande, ele tem um grande potencial e talvez at√© se aproxime da taxa de erro ideal. <br><br>  Os sistemas de ponta a ponta tendem a ser bem-sucedidos quando h√° muitos dados marcados para ambas as extremidades - o "final de entrada" e o "final de sa√≠da".  Neste exemplo, precisamos de um grande conjunto desses pares (√°udio e transcri√ß√£o).  Quando dados desse tipo n√£o estiverem dispon√≠veis para voc√™, aborde o aprendizado com muito cuidado. <br><br>  Se voc√™ estiver trabalhando em uma tarefa de aprendizado de m√°quina na qual o conjunto de treinamento √© muito pequeno, a maioria das informa√ß√µes dispon√≠veis para o seu algoritmo ser√° obtida gra√ßas √† sua compreens√£o humana, ou seja,  de componentes projetados manualmente. <br><br>  Se voc√™ preferir n√£o usar um sistema de ponta a ponta, precisar√° decidir quais etapas ser√£o no seu pipeline e como elas devem se encaixar.  No pr√≥ximo cap√≠tulo, ofereceremos algumas id√©ias para projetar esses sistemas. <br><br><hr><h3>  <font color="#548dd4">Cap√≠tulo 50. Sele√ß√£o de Componentes de Pipeline: Disponibilidade de Dados</font> </h3><hr><br>  Quando voc√™ constr√≥i um transportador que n√£o √© um sistema de ponta a ponta, quais componentes desse transportador ser√£o uma boa escolha?  Como voc√™ projeta o transportador afetar√° bastante o desempenho geral do sistema.  Um fator importante √© a capacidade de coletar dados com facilidade para treinar cada componente. <br><br>  Por exemplo, considere esta arquitetura de dire√ß√£o aut√¥noma: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  Voc√™ pode usar algoritmos de aprendizado de m√°quina para detectar carros e pedestres.  Al√©m disso, n√£o √© dif√≠cil para eles coletar dados: existem muitos conjuntos prontos de dados de vis√£o por computador com um grande n√∫mero de carros e pedestres marcados.  Voc√™ tamb√©m pode usar o crowdsourcing (como o Amazon Mechanical Turk) para obter conjuntos de dados ainda maiores.  Portanto, ser√° relativamente f√°cil coletar dados de treinamento para criar um detector de carro e um detector de pedestres. <br><br>  Pelo contr√°rio, considere um sistema limpo de ponta a ponta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iy/5x/rw/iy5xrwykphbakzznhiqd0la0mzw.png"></div><br><br>  Para treinar esse sistema, precisamos de um grande conjunto de elementos j√° mapeados (imagem = volante girando na dire√ß√£o certa).  Essa √© uma tarefa muito demorada e cara.  Para coletar esses dados, √© necess√°rio que as pessoas dirijam carros e registrem dados sobre cada volta do volante.  Voc√™ precisar√° de toda uma frota de carros especialmente equipados e um grande n√∫mero de horas de trabalho para cobrir a maior variedade poss√≠vel de situa√ß√µes.  Isso torna o sistema de ponta a ponta muito dif√≠cil de aprender.  √â muito mais f√°cil tirar um grande conjunto de imagens rotuladas de carros e pedestres. <br><br>  Em um sentido mais geral, se houver muitos dados dispon√≠veis para o treinamento de m√≥dulos transportadores "intermedi√°rios" (como um detector de carro ou um detector de pedestres), ser√° necess√°rio pensar em usar um transportador composto por v√°rios componentes.  Esse m√©todo pode funcionar melhor, porque  Voc√™ pode usar todos os dados dispon√≠veis para treinar m√≥dulos intermedi√°rios. <br><br>  At√© que haja mais dados para modelos de ponta a ponta, acredito que a abordagem tradicional √© muito mais promissora para dire√ß√£o aut√¥noma: sua arquitetura combina melhor com a disponibilidade atual de dados. <br><br><hr><h3>  <font color="#548dd4">Cap√≠tulo 51. Escolhendo Componentes do Transportador: Simplicidade da Tarefa</font> </h3><hr><br>  Al√©m da disponibilidade de dados, voc√™ tamb√©m deve considerar o segundo fator ao escolher componentes de pipeline: qu√£o simples s√£o as tarefas que os componentes individuais resolvem?  Voc√™ deve tentar selecionar os componentes do transportador para que sejam f√°ceis de construir ou aprender.  Mas o que significa um componente ser f√°cil de aprender? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fc/bg/fy/fcbgfyb4ggr4u6m79xy01h6gtqa.png"></div><br><br>  Considere as seguintes tarefas de aprendizado de m√°quina, listadas em ordem crescente de complexidade: <br><br><ol><li>  A defini√ß√£o √© superexposta √† imagem apresentada (como no exemplo acima). </li><li>  Determinar se uma imagem √© tirada em ambientes internos ou externos. </li><li>  Determinando se h√° um gato na imagem. </li><li>  Determinando se h√° um gato na imagem com p√™lo preto e branco. </li><li>  Determina√ß√£o da exist√™ncia de um gato siam√™s na imagem (qualquer ra√ßa espec√≠fica de gatos). </li></ol><br>  Para cada um desses problemas de classifica√ß√£o bin√°ria, √© necess√°rio obter uma imagem na entrada e na sa√≠da 0 ou 1. Mas as tarefas listadas anteriormente na lista parecem ser mais f√°ceis de aprender nas redes neurais.  Voc√™ pode treinar o algoritmo para tarefas mais simples com menos exemplos de treinamento. <br><br>  No est√°gio atual do aprendizado de m√°quina, n√£o h√° uma boa defini√ß√£o formal do que torna uma tarefa f√°cil ou dif√≠cil.  <sup>2</sup> Com o crescimento da aprendizagem profunda e das redes neurais multicamadas, √†s vezes chamamos o problema de f√°cil, se ele pode ser resolvido com menos etapas de c√°lculo (por exemplo, usando redes neurais com um pequeno n√∫mero de camadas), e chamamos a tarefa de dif√≠cil se exigir mais etapas. computa√ß√£o (que corresponde a uma rede neural profunda).  Mas esta √© uma defini√ß√£o informal. <br><blockquote>  <sup>2</sup> Na teoria algor√≠tmica da informa√ß√£o, existe o conceito de complexidade de Kolmogorov, que afirma que a complexidade da fun√ß√£o que est√° sendo estudada √© a dura√ß√£o do menor programa de computador que pode produzir essa fun√ß√£o.  Este conceito te√≥rico encontrou v√°rias aplica√ß√µes pr√°ticas em IA. </blockquote><br>  Se voc√™ tiver a oportunidade de dividir uma tarefa complexa em subtarefas mais simples, codificando com precis√£o cada subtarefa, voc√™ fornecer√° ao algoritmo um conhecimento mais importante que pode ajud√°-lo a resolver com mais efici√™ncia todo o problema. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cm/cm/so/cmcmsoncvrly_eqnmdswoqxyqcc.png"></div><br><br>  Imagine que voc√™ est√° projetando um detector de gato siam√™s.  Aqui est√° uma arquitetura de ponta a ponta limpa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/ex/em/3gexemhnlou8qon3qwpprhtcidm.png"></div><br><br>  Pelo contr√°rio, voc√™ pode usar um transportador de dois componentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br>  Na primeira etapa (detector de gato), todos os gatos da imagem ser√£o reconhecidos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9q/a4/wu/9qa4wugiqcvqysomntw52alpy8q.png"></div><br><br>  Em seguida, na segunda etapa, as imagens colhidas de cada um dos gatos detectados, uma de cada vez, s√£o transferidas para o classificador da ra√ßa.  E finalmente, se algum dos gatos detectados for um gato siam√™s, obtemos "1" na sa√≠da. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ns/oj/ii/nsojiirbbbuni7qkmrokqmuksfm.png"></div><br><br>  Comparado ao ensino de um classificador puramente de passagem que usa apenas tags 0/1, cada um dos dois componentes no pipeline (detector de gatos e classificador de ra√ßas) parece mais f√°cil de aprender e requer significativamente menos dados.  <sup>3</sup> <br><blockquote>  <sup>3</sup> Se voc√™ estiver familiarizado com os algoritmos de detec√ß√£o de objetos que s√£o realmente utilizados na pr√°tica, entender√° que eles s√£o treinados n√£o apenas com os r√≥tulos de imagem 0/1.  Em vez disso, eles s√£o treinados usando a estrutura restritiva fornecida como parte dos dados de treinamento.  A discuss√£o deles est√° al√©m do escopo deste cap√≠tulo. </blockquote><br>  E o √∫ltimo exemplo, lembremos novamente o pipeline da tarefa de dire√ß√£o aut√¥noma: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  Usando esse transportador, voc√™ informa ao algoritmo que existem tr√™s etapas principais na condu√ß√£o de um carro: <br><br><ul><li>  Reconhe√ßa outros carros. </li><li>  Reconhe√ßa pedestres. </li><li>  Planeje a dire√ß√£o de mais movimentos. </li></ul><br>  Cada uma dessas etapas √© uma tarefa mais simples e pode ser treinada com menos dados do que com uma abordagem puramente transversal. <br><br>  Como resultado, ao decidir quais devem ser os componentes do pipeline, tente criar um pipeline em que cada componente seja uma fun√ß√£o relativamente "simples" que s√≥ possa ser treinada em uma pequena quantidade de dados. <br><br><hr><h3>  <font color="#548dd4">Cap√≠tulo 52. Aprendendo com informa√ß√µes imersivas</font> </h3><hr><br>  O algoritmo de classifica√ß√£o de imagem pega uma imagem de entrada X e produz um n√∫mero inteiro, que √© um r√≥tulo para a categoria do objeto.  Em vez disso, o algoritmo pode emitir uma frase inteira descrevendo a imagem? <br><br>  Por exemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/12/z6/-v/12z6-votwnq7mu2j9rwukqce52k.png"></div><br><br>  Y = "Um √¥nibus amarelo est√° dirigindo pela estrada em meio a √°rvores e grama verde." <br><br>  A aplica√ß√£o tradicional do ensino com um professor envolve a presen√ßa de uma fun√ß√£o treinada h: X ‚Üí Y, onde a sa√≠da (y) √© geralmente representada por um n√∫mero inteiro ou natural.  Por exemplo: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Desafio </th><th>  X </th><th>  Y </th></tr><tr><td>  <b>Antispam</b> </td><td>  E-mail </td><td>  Spam / N√£o Spam (0/1) </td></tr><tr><td>  <b>Reconhecimento de imagem</b> </td><td>  Imagem </td><td>  R√≥tulo inteiro </td></tr><tr><td>  <b>Previs√£o de Pre√ßos Imobili√°rios</b> </td><td>  Caracter√≠sticas da casa </td><td>  Pre√ßo em d√≥lares </td></tr><tr><td>  <b>Recomenda√ß√£o do produto</b> </td><td>  Especifica√ß√µes do produto e do cliente </td><td>  Probabilidade de compra </td></tr></tbody></table></div><br><br>  Uma das coisas mais empolgantes sobre a aprendizagem profunda transversal √© que ela nos permite aprender diretamente Y, o que √© muito mais complicado que os n√∫meros.  No exemplo da tarefa de descri√ß√£o da imagem mencionada acima, voc√™ pode aplicar alguma imagem (x) √† entrada da rede neural e obter uma descri√ß√£o imediata (y) na sa√≠da. <br><br>  Aqui est√£o alguns exemplos: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Desafio </th><th>  X </th><th>  Y </th><th>  Cita√ß√£o do trabalho </th></tr><tr><td>  <b>Descri√ß√£o das Imagens</b> </td><td>  Imagem </td><td>  Text </td><td>  Mao e outros, 2014 </td></tr><tr><td>  <b>Tradu√ß√£o autom√°tica</b> </td><td>  Texto em ingl√™s </td><td>  Texto em franc√™s </td><td>  Suskever e outros, 2014 </td></tr><tr><td>  <b>Respostas √†s perguntas</b> </td><td>  Par (texto + pergunta) </td><td>  Resposta √† pergunta </td><td>  Bordes e outros, 2015 </td></tr><tr><td>  <b>Reconhecimento de fala</b> </td><td>  √Åudio </td><td>  Transcri√ß√£o </td><td>  Hannun e outros, 2015 </td></tr><tr><td>  <b>Convers√£o de texto em fala</b> </td><td>  Tags de texto </td><td>  √Åudio </td><td>  Van der Oord et al., 2016 </td></tr></tbody></table></div><br><br>  Essa √© uma tend√™ncia crescente no aprendizado profundo: quando voc√™ tem os pares rotulados (entrada e sa√≠da) corretos, √†s vezes pode escolher um treinamento de ponta a ponta, mesmo se a sa√≠da for uma frase, imagem, √°udio ou qualquer outra sa√≠da que contenha muito mais informa√ß√µes, do que apenas n√∫meros de etiqueta √∫nica. <br><br><h1>  An√°lise de erro parcial </h1><hr><h3>  <font color="#548dd4">Cap√≠tulo 53. An√°lise de erros em partes</font> </h3><hr><br>  Suponha que seu sistema seja constru√≠do usando um sofisticado pipeline de aprendizado de m√°quina e voc√™ gostaria de melhorar a efici√™ncia do sistema.  Qual parte do transportador voc√™ deve melhorar?  Atribuindo erros a partes espec√≠ficas do pipeline, voc√™ pode decidir como priorizar seu trabalho. <br><br>  Vamos usar nosso exemplo de classificador de gatos siameses: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br>  A primeira parte, um detector de gatos, detecta gatos e os corta para fora de toda a imagem.  A segunda parte, o classificador de ra√ßas de gatos, decide se esse gato √© um gato siam√™s.  Voc√™ pode passar anos trabalhando para melhorar qualquer um desses dois componentes do transportador.  Como voc√™ decide em qual componente focar? <br><br>  Executando a an√°lise de erros em partes, voc√™ pode tentar atribuir cada erro do algoritmo a uma das duas partes do pipeline (e √†s vezes as duas ao mesmo tempo).  Por exemplo, o algoritmo classifica incorretamente essa imagem como n√£o contendo um gato siam√™s (y = 0), embora o r√≥tulo correto seja y = 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hj/ju/2g/hjju2gw3fble1fcgc8fblrenkms.png"></div><br><br>  Vamos verificar manualmente o que o algoritmo faz em cada uma das duas etapas.  Suponha que um detector de gato siam√™s detectou um gato da seguinte maneira: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oe/0l/rx/oe0lrx5ysvmznqkmbl83m_k_46g.png"></div><br><br>  Isso significa que o classificador da ra√ßa de gato receber√° esta imagem: <br><br><img src="https://habrastorage.org/webt/ft/wm/vs/ftwmvsdrnvpp2f9vrds36flldzo.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O classificador da ra√ßa classifica corretamente esta imagem como n√£o contendo um gato siam√™s. Portanto, o classificador de ra√ßas de gatos √© inocente: ele recebeu um punhado de pedras na entrada e deu uma nota bastante razo√°vel y = 0. De fato, uma pessoa que classifica a imagem cortada acima tamb√©m prediz y = 0. Portanto, voc√™ pode atribuir claramente esse erro a detector de gato. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por outro lado, se um detector de gato exibir a seguinte caixa delimitadora:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oz/qu/no/ozqunon7ny51kw1ukglsfl3hjj8.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ent√£o voc√™ concluiria que o detector de gatos fez seu trabalho corretamente e o erro ocorreu devido ao classificador da ra√ßa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que voc√™ tenha passado por 100 imagens classificadas incorretamente de uma amostra de valida√ß√£o e encontrado 90 erros relacionados a um detector de gatos e apenas 10 erros relacionados a um classificador de ra√ßa de gato. Voc√™ pode concluir com seguran√ßa que deveria se concentrar mais em melhorar o seu detector de gatos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, voc√™ tamb√©m encontrou com sucesso 90 exemplos em que o detector de gato trouxe a caixa delimitadora errada. Voc√™ pode usar esses 90 exemplos para uma </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an√°lise </font><font style="vertical-align: inherit;">mais profunda </font><font style="vertical-align: inherit;">dos erros do detector de gatos e ver como melhor√°-los.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossa descri√ß√£o de como atribuir o erro a uma parte do pipeline at√© agora tem sido informal: voc√™ analisa a sa√≠da de cada parte e v√™ se consegue decidir qual cometeu o erro. </font><font style="vertical-align: inherit;">Este m√©todo informal pode ser suficiente. </font><font style="vertical-align: inherit;">Mas no pr√≥ximo cap√≠tulo, voc√™ tamb√©m ver√° uma maneira mais formal de atribuir erros.</font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cap√≠tulo 54. Atribui√ß√£o de erro a uma parte espec√≠fica</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos continuar com o nosso exemplo: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suponha que o detector de gato tenha produzido esta caixa delimitadora: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bc/_d/8k/bc_d8kmcijt314qterhumctdyyq.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, o classificador da ra√ßa recebeu essa imagem cortada, ap√≥s a qual emitiu incorretamente y = 0, ou seja, </font><font style="vertical-align: inherit;">que n√£o h√° gato na foto.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/71/mu/ld/71muldvuqnfx0cd_a6bpo41xzvc.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O detector de gatos fez um mau trabalho. </font><font style="vertical-align: inherit;">Enquanto uma pessoa treinada, sem d√∫vida, ser√° capaz de reconhecer o gato siam√™s nesta imagem cortada. </font><font style="vertical-align: inherit;">Portanto, atribu√≠mos esse erro a um detector de gatos, a um classificador de ra√ßas ou a ambos? </font><font style="vertical-align: inherit;">Claro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o n√∫mero de casos controversos for pequeno, podemos tomar qualquer decis√£o e obter um resultado semelhante. </font><font style="vertical-align: inherit;">Mas aqui est√° um teste mais formal, que permite atribuir com mais precis√£o o erro a exatamente uma parte:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Substitua a sa√≠da do detector de gato por um quadro marcado manualmente. </font></font><br><img src="https://habrastorage.org/webt/np/8f/zy/np8fzyx2lfbh1cdbd-o7iiykpvq.png"></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passe a imagem cortada correspondente pelo classificador da ra√ßa. </font><font style="vertical-align: inherit;">Se o classificador de ra√ßa ainda n√£o classificar a imagem corretamente, atribua o erro ao classificador de ra√ßa. </font><font style="vertical-align: inherit;">Caso contr√°rio, atribua o erro ao detector de gato.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em outras palavras, conduza um experimento no qual voc√™ envia dados ideais para a entrada do classificador de rochas. </font><font style="vertical-align: inherit;">Nesse caso, s√£o poss√≠veis 2 op√ß√µes:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mesmo com um quadro ideal, o classificador de ra√ßas erroneamente y = 0. Nesse caso, o classificador √© sem d√∫vida o culpado. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tendo recebido um quadro ideal, o classificador da ra√ßa corretamente y = 1. Isso mostra que, se apenas o detector de gatos produzisse uma caixa delimitadora mais perfeita, a conclus√£o geral do sistema estaria correta. </font><font style="vertical-align: inherit;">Assim, atribu√≠mos o erro ao detector de gato.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de executar essa an√°lise de imagens classificadas incorretamente a partir da amostra de valida√ß√£o, agora voc√™ pode atribuir inequivocamente cada erro a um componente. </font><font style="vertical-align: inherit;">Isso permite estimar a propor√ß√£o de erros associados a cada componente do pipeline e, portanto, decidir em que focar sua aten√ß√£o.</font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cap√≠tulo 55. O caso principal de atribui√ß√£o de erros</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√£o as etapas gerais para atribuir erros. </font><font style="vertical-align: inherit;">Suponha que o pipeline tenha tr√™s est√°gios A, B e C, onde A √© alimentado diretamente para B e B √© alimentado diretamente para C.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ok/tz/0i/oktz0iqvw81g6gbnxdwvehsmo50.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para cada erro que o sistema comete na amostra de valida√ß√£o: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tente substituir manualmente a sa√≠da do est√°gio A pela sa√≠da "ideal" (ou seja, caixa delimitadora "ideal" para o gato)) e continue com o restante do transportador B, C por essa sa√≠da. </font><font style="vertical-align: inherit;">Se o algoritmo agora produzir o resultado correto, isso indica que apenas o est√°gio A deve melhorar sua pr√≥pria sa√≠da para que todo o algoritmo funcione corretamente. </font><font style="vertical-align: inherit;">Portanto, voc√™ pode atribuir esse erro ao componente A. Caso contr√°rio, v√° para a etapa 2.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tente substituir manualmente a sa√≠da do est√°gio B pela sa√≠da "perfeita". </font><font style="vertical-align: inherit;">Se o algoritmo inteiro come√ßar a funcionar corretamente, atribua o erro ao componente B. Caso contr√°rio, v√° para a etapa 3.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atribua o erro ao componente C. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Veja um exemplo mais complexo: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seu drone usa este transportador. </font><font style="vertical-align: inherit;">Como, usando a an√°lise de erro fragmentada, para determinar em qual componente focar? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode marcar os componentes da seguinte maneira:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A. Reconhecer carros. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> B. Reconhecer pedestres. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C. Planeje o caminho. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seguindo o procedimento descrito acima, suponha que voc√™ teste seu carro em um campo de treinamento fechado e encontre um caso em que o carro escolha uma manobra em uma dire√ß√£o mais n√≠tida do que um motorista experiente faria. </font><font style="vertical-align: inherit;">No mundo da dire√ß√£o n√£o tripulada, esse evento √© geralmente chamado de script. </font><font style="vertical-align: inherit;">Nesse caso:</font></font><br><br><ol><li>      A ( )  ¬´¬ª  (..     ).     B  C   ,    C ( )  ¬´¬ª   A.        ,    ,     A   ,     .        A.     2. </li><li>      B ( )  ¬´¬ª .      ,      B.     3. </li><li>    C. </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os componentes do pipeline de aprendizado de m√°quina devem ser organizados de acordo com um gr√°fico ac√≠clico direcionado (DAG), o que significa que voc√™ deve poder calcul√°-los em alguma ordem fixa da esquerda para a direita, e os componentes posteriores devem depender apenas das sa√≠das dos componentes anteriores. </font><font style="vertical-align: inherit;">Desde que a </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disposi√ß√£o dos componentes na ordem A ‚Üí B ‚Üí C corresponda √† ordem do DAG, a an√°lise de erro continuar√° corretamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode obter resultados ligeiramente diferentes se voc√™ trocar A e B:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A. Reconhecer pe√µes (anteriormente reconhecimento de autom√≥veis) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> B. Reconhecer carros (anteriormente reconhecimento de pedestres) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C. Planeje o caminho do seu carro </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mas o resultado dessa an√°lise ainda permanecer√° verdadeiro e dar√° uma boa orienta√ß√£o sobre o que voc√™ deve focar sua aten√ß√£o. </font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cap√≠tulo 56. An√°lise de erros em partes e compara√ß√£o com efici√™ncia no n√≠vel humano</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A condu√ß√£o de uma an√°lise de erro em um algoritmo de aprendizado √© semelhante ao uso da ci√™ncia de dados para analisar erros do sistema ML, a fim de ter uma id√©ia do que fazer em seguida. </font><font style="vertical-align: inherit;">Na maioria dos casos, uma an√°lise de erro fragmentada nos dir√° qual componente vale a pena tentar melhorar acima de tudo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digamos que voc√™ tenha algum conjunto de dados sobre clientes que compram itens em um site. Um cientista de dados pode analisar dados de v√°rias maneiras diferentes. Ele pode tirar muitas conclus√µes diferentes sobre se o site deve aumentar os pre√ßos, o valor dos clientes adquiridos por meio de v√°rias campanhas de marketing e assim por diante. N√£o existe uma maneira ‚Äúcerta‚Äù √∫nica de analisar um conjunto de dados; existem muitas id√©ias √∫teis poss√≠veis que podem surgir. Da mesma forma, n√£o existe uma maneira "certa" de analisar erros. Nesses cap√≠tulos, voc√™ aprendeu alguns dos padr√µes de design mais comuns para obter informa√ß√µes √∫teis sobre o seu sistema ML, mas tamb√©m pode experimentar livremente outros m√©todos de an√°lise de erros.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De volta ao aplicativo de ve√≠culo n√£o tripulado, no qual o algoritmo de detec√ß√£o de carro exibe a localiza√ß√£o (e possivelmente a velocidade) dos carros pr√≥ximos, o algoritmo de detec√ß√£o de pedestres exibe a localiza√ß√£o dos pedestres mais pr√≥ximos e essas duas sa√≠das s√£o finalmente usadas para planejar o caminho do carro. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para depurar esse pipeline e n√£o seguir estritamente o procedimento que voc√™ viu no cap√≠tulo anterior, voc√™ pode fazer as seguintes perguntas: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A que dist√¢ncia est√° o algoritmo de reconhecimento de carro da efici√™ncia humana na solu√ß√£o de um problema semelhante? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qual a dist√¢ncia do algoritmo de reconhecimento de pedestres do desempenho humano na solu√ß√£o de um problema semelhante? </font></font></li><li>         ?      ,       ,          (      ).  ,    ¬´ ¬ª    ,        ? </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ achar que um dos componentes do sistema est√° longe da efici√™ncia humana, ter√° uma boa oportunidade de se concentrar em melhorar a efic√°cia desse componente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muitos processos de an√°lise de erro funcionam melhor quando tentamos automatizar algo que uma pessoa pode fazer; portanto, comparamos os resultados com os de uma pessoa. A maioria dos exemplos anteriores tinha essa suposi√ß√£o impl√≠cita. Se voc√™ estiver construindo um sistema de ML no qual a sa√≠da final ou alguns dos componentes intermedi√°rios fazem coisas que nem uma pessoa consegue fazer bem, alguns desses procedimentos n√£o se aplicam.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Essa √© outra vantagem de trabalhar em problemas que as pessoas podem resolver - voc√™ possui ferramentas mais poderosas para analisar erros e, portanto, pode priorizar com mais efici√™ncia o trabalho de sua equipe. </font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cap√≠tulo 57. Detec√ß√£o de Erros no Pipeline ML</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E se cada componente individual do seu transportador ML mostrar efici√™ncia no n√≠vel humano ou um pouco mais baixo, mas o transportador geral n√£o corresponder ao n√≠vel humano? </font><font style="vertical-align: inherit;">Normalmente, isso significa que o transportador tem falhas e precisa ser redesenhado. </font><font style="vertical-align: inherit;">A an√°lise de erros tamb√©m pode ajud√°-lo a descobrir se seu pipeline precisa ser redesenhado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No cap√≠tulo anterior, colocamos a pergunta: cada um dos tr√™s componentes mostra efici√™ncia no n√≠vel humano? </font><font style="vertical-align: inherit;">Suponha que a resposta para todas as tr√™s perguntas seja afirmativa. </font><font style="vertical-align: inherit;">Ent√£o:</font></font><br><br><ol><li> ,  ,   ()           . </li><li> ,  ,   ()           . </li><li> ,   ,     ,    ,      ,                (     ). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, seu ve√≠culo n√£o tripulado lida com a condu√ß√£o significativamente pior do que uma pessoa. Ou seja, as pessoas que t√™m acesso √†s imagens da c√¢mera podem planejar o caminho do carro muito melhor. Que conclus√£o voc√™ pode tirar? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √∫nica conclus√£o poss√≠vel √© que seu pipeline de ML n√£o foi projetado corretamente. Nesse caso, o componente que planeja o caminho do carro funciona, al√©m de permitir dados recebidos que n√£o cont√™m informa√ß√µes suficientes. Voc√™ deve se perguntar que outras informa√ß√µes que n√£o est√£o na sa√≠da dos dois componentes anteriores s√£o necess√°rias para um excelente planejamento do percurso do carro. Em outras palavras, que outras informa√ß√µes s√£o usadas por um motorista experiente?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que voc√™ entenda que um motorista humano tamb√©m precisa ver as marca√ß√µes na estrada. Isso sugere que voc√™ deve fazer engenharia reversa do pipeline da seguinte maneira: </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/qa/wy/msqawygb_nyn4twj9cnbbiqlad0.png"></div><br><blockquote> <sup>4</sup>       ,     ,         .       ¬´Task simplicity¬ª,    51,            ,          .     ¬´  ¬ª    ‚Äî               ,        /  . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por fim, se voc√™ acha que seu pipeline como um todo n√£o ser√° capaz de alcan√ßar a efici√™ncia humana, mesmo que cada componente individual tenha efici√™ncia no n√≠vel humano (lembre-se de que voc√™ est√° comparando com uma pessoa que tem a mesma entrada que o componente) , esse transportador tem desvantagens e deve ser reprojetado. </font></font><br><br><h1>  Conclus√£o </h1><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cap√≠tulo 58. Crie uma super equipe, compartilhe esse conhecimento com os camaradas</font></font></font> </h3><hr><br>  Parab√©ns por completar este livro! <br>  No cap√≠tulo 2, falamos sobre como este livro pode ajud√°-lo a se tornar um super-her√≥i em sua equipe. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/8d/ta/ms8dta_asiaioa6tttb3dsl4syo.png"></div><br><br>  A √∫nica coisa que pode ser melhor do que ser um super-her√≥i √© fazer parte de uma equipe de super-her√≥is.  Espero que voc√™ compartilhe c√≥pias deste livro com seus amigos e colegas de equipe e ajude a criar outros super-her√≥is! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485190/">https://habr.com/ru/post/pt485190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485178/index.html">Metodologia para reconstru√ß√£o de edif√≠cios perdidos a partir de fotografias</a></li>
<li><a href="../pt485180/index.html">Precisamos de um lago de dados? O que fazer com o data warehouse?</a></li>
<li><a href="../pt485182/index.html">Sennheiser em 2020 - fones de ouvido sem fio atualizados para o anivers√°rio</a></li>
<li><a href="../pt485184/index.html">Resultados da vota√ß√£o com guias</a></li>
<li><a href="../pt485186/index.html">Startup de trilh√µes de d√≥lares ou como nasceram as empresas Valley de maior sucesso</a></li>
<li><a href="../pt485194/index.html">√Årvore de segmentos: r√°pido e f√°cil</a></li>
<li><a href="../pt485196/index.html">AvitoTech On Tour: V√° e participe de reuni√µes em Kazan</a></li>
<li><a href="../pt485198/index.html">Outra maneira de medir o desempenho dos m√©todos de aplicativo .NET</a></li>
<li><a href="../pt485200/index.html">Confus√£o no in√≠cio: post-mortem na velocidade de lan√ßamento de um aplicativo iOS</a></li>
<li><a href="../pt485202/index.html">Sistema de Supress√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>