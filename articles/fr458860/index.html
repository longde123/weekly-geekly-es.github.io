<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèø üïäÔ∏è üíä R√©glage des param√®tres du noyau Linux pour optimiser PostgreSQL üë©üèº‚Äçü§ù‚Äçüë®üèø üëé üíê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les performances optimales de PostgreSQL d√©pendent de param√®tres de syst√®me d'exploitation correctement d√©finis. Des param√®tres de noyau de syst√®me d'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>R√©glage des param√®tres du noyau Linux pour optimiser PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458860/"><img width="30%" align="left" src="https://habrastorage.org/webt/dy/qf/mh/dyqfmhq5wntmbisfsdahfiwc_-y.jpeg">  Les performances optimales de PostgreSQL d√©pendent de param√®tres de syst√®me d'exploitation correctement d√©finis.  Des param√®tres de noyau de syst√®me d'exploitation mal r√©gl√©s peuvent d√©grader les performances du serveur de base de donn√©es.  Par cons√©quent, il est imp√©ratif que ces param√®tres soient configur√©s en fonction du serveur de base de donn√©es et de sa charge de travail.  Dans cet article, nous discuterons de certains param√®tres importants du noyau Linux qui peuvent affecter les performances du serveur de base de donn√©es et comment les r√©gler. <br><br><h2>  SHMMAX / SHMALL </h2><br>  <b>SHMMAX</b> est un param√®tre de noyau utilis√© pour d√©terminer la taille maximale d'un segment de m√©moire partag√©e unique qu'un processus Linux peut allouer.  Avant la version 9.2, PostgreSQL utilisait System V (SysV), qui n√©cessite une configuration SHMMAX.  Apr√®s 9.2, PostgreSQL est pass√© √† la m√©moire partag√©e POSIX.  Alors maintenant, moins d'octets de m√©moire partag√©e System V sont n√©cessaires. <br><br>  Avant la version 9.3, SHMMAX √©tait le param√®tre de noyau le plus important.  La valeur SHMMAX est sp√©cifi√©e en octets. <br><a name="habracut"></a><br>  De m√™me, <b>SHMALL</b> est un autre param√®tre du noyau utilis√© pour d√©terminer <br>  pages de m√©moire partag√©e √† l'√©chelle du syst√®me.  Utilisez la commande <i>ipcs</i> pour afficher les valeurs SHMMAX, SHMALL ou SHMMIN actuelles. <br><br>  <sup><b>D√©tails SHM * - Linux</b></sup> <br><br><pre><code class="bash hljs">$ ipcs -lm ------ Shared Memory Limits -------- max number of segments = 4096 max seg size (kbytes) = 1073741824 max total shared memory (kbytes) = 17179869184 min seg size (bytes) = 1</code> </pre> <br>  <sup><b>D√©tails SHM * - MacOS X</b></sup> <br><br><pre> <code class="bash hljs">$ ipcs -M IPC status from as of Thu Aug 16 22:20:35 PKT 2018 shminfo: shmmax: 16777216 (max shared memory segment size) shmmin: 1 (min shared memory segment size) shmmni: 32 (max number of shared memory identifiers) shmseg: 8 (max shared memory segments per process) shmall: 1024 (max amount of shared memory <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pages)</code> </pre><br>  PostgreSQL utilise <b>IPC System V</b> pour allouer la m√©moire partag√©e.  Ce param√®tre est l'un des param√®tres de noyau les plus importants.  Chaque fois que vous recevez les messages d'erreur suivants, cela signifie que vous disposez d'une ancienne version de PostgreSQL et que votre valeur SHMMAX est tr√®s faible.  Il est pr√©vu que les utilisateurs ajusteront et augmenteront la valeur en fonction de la m√©moire partag√©e qu'ils vont utiliser. <br><br><h3>  Erreurs de mauvaise configuration possibles </h3><br>  Si SHMMAX n'est pas configur√© correctement, vous pouvez recevoir une erreur lorsque vous essayez d'initialiser un cluster PostgreSQL √† l'aide de la commande <i>initdb</i> . <br><br>  <sup><b>√©chec initdb</b></sup> <br> <code>DETAIL: Failed system call was shmget(key=1, size=2072576, 03600). <br> <br> HINT: This error usually means that PostgreSQL's request for a shared memory segment exceeded your kernel's SHMMAX parameter. <br> You can either reduce the request size or reconfigure the kernel with larger SHMMAX. To reduce the request size (currently 2072576 bytes), <br> reduce PostgreSQL's shared memory usage, perhaps by reducing shared_buffers or max_connections. <br> <br> If the request size is already small, it's possible that it is less than your kernel's SHMMIN parameter, <br> in which case raising the request size or reconfiguring SHMMIN is called for. <br> <br> The PostgreSQL documentation contains more information about shared memory configuration. child process exited with exit code 1</code> <br> <br>  De m√™me, vous pouvez recevoir une erreur lors du d√©marrage du serveur PostgreSQL √† l'aide de la commande <i>pg_ctl</i> . <br><br>  <sup><b>√©chec de pg_ctl</b></sup> <br> <code>DETAIL: Failed system call was shmget(key=5432001, size=14385152, 03600). <br> <br> HINT: This error usually means that PostgreSQL's request for a shared memory segment exceeded your kernel's SHMMAX parameter. <br> <br> You can either reduce the request size or reconfigure the kernel with larger SHMMAX.; To reduce the request size (currently 14385152 bytes), reduce PostgreSQL's shared memory usage, perhaps by reducing shared_buffers or max_connections. <br> <br> If the request size is already small, it's possible that it is less than your kernel's SHMMIN parameter, <br> in which case raising the request size or reconfiguring SHMMIN is called for. <br> <br> The PostgreSQL documentation contains more information about shared memory configuration.</code> <br> <br><h3>  Comprendre les diff√©rences dans les d√©finitions </h3><br>  La d√©finition des param√®tres SHMMAX / SHMALL est l√©g√®rement diff√©rente sous Linux et MacOS X: <br><br><ul><li>  Linux: kernel.shmmax, kernel.shmall </li><li>  MacOS X: kern.sysv.shmmax, kern.sysv.shmall </li></ul><br>  La commande <i>sysctl</i> peut √™tre utilis√©e pour modifier temporairement une valeur.  Pour d√©finir des valeurs constantes, ajoutez une entr√©e dans <i>/etc/sysctl.conf</i> .  Les d√©tails sont donn√©s ci-dessous. <br><br>  <sup><b>Modifier les param√®tres du noyau sur MacOS X</b></sup> <br><br><pre> <code class="plaintext hljs"># Get the value of SHMMAX sudo sysctl kern.sysv.shmmax kern.sysv.shmmax: 4096 # Get the value of SHMALL sudo sysctl kern.sysv.shmall kern.sysv.shmall: 4096 # Set the value of SHMMAX sudo sysctl -w kern.sysv.shmmax=16777216 kern.sysv.shmmax: 4096 -&gt; 16777216 # Set the value of SHMALL sudo sysctl -w kern.sysv.shmall=16777216 kern.sysv.shmall: 4096 -&gt; 16777216</code> </pre> <br>  <sup><b>Modification des param√®tres du noyau Linux</b></sup> <br><br><pre> <code class="plaintext hljs"># Get the value of SHMMAX sudo sysctl kernel.shmmax kernel.shmmax: 4096 # Get the value of SHMALL sudo sysctl kernel.shmall kernel.shmall: 4096 # Set the value of SHMMAX sudo sysctl -w kernel.shmmax=16777216 kernel.shmmax: 4096 -&gt; 16777216 # Set the value of SHMALL sudo sysctl -w kernel.shmall=16777216 kernel.shmall: 4096 -&gt; 16777216</code> </pre> <br>  <sub><b>N'oubliez pas</b> : pour rendre les modifications permanentes, ajoutez ces valeurs √† <font color="blue">/etc/sysctl.conf</font></sub> <br><br><h2>  Grandes pages (grandes pages) </h2><br>  Linux utilise par d√©faut des pages 4K, BSD utilise des <i>Super Pages</i> et Windows utilise de <i>grandes pages</i> .  Une page est un morceau de RAM allou√© √† un processus.  Un processus peut avoir plusieurs pages, selon les besoins en m√©moire.  Plus un processus a besoin de m√©moire, plus il a √©t√© allou√© de pages.  Le syst√®me d'exploitation prend en charge une table d'allocation de pages pour les processus.  Plus la taille de la page est petite, plus le tableau est grand, plus il faut de temps pour trouver une page dans ce tableau de pages.  Par cons√©quent, les grandes pages vous permettent d'utiliser une grande quantit√© de m√©moire avec une surcharge r√©duite;  moins de pages vues, moins d'erreurs de page, des op√©rations de lecture / √©criture plus rapides gr√¢ce √† de grands tampons.  Le r√©sultat est une am√©lioration des performances. <br><br>  PostgreSQL ne prend en charge que les grandes pages sous Linux.  Par d√©faut, Linux utilise 4 Ko de pages de m√©moire, donc si vous avez trop d'op√©rations de m√©moire, vous devez installer des pages plus grandes.  Il y a un gain de performances lors de l'utilisation de grandes pages de 2 Mo et jusqu'√† 1 Go.  Une grande taille de page peut √™tre d√©finie au d√©marrage.  Vous pouvez facilement v√©rifier les param√®tres de la grande page et leur utilisation sur votre ordinateur Linux en utilisant la commande <i>cat / proc / meminfo |</i>  <i>grep -i √©norme</i> . <br><br>  <sup><b>Obtention d'informations sur les grandes pages (Linux uniquement)</b></sup> <br><br><pre> <code class="bash hljs">Note: This is only <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Linux, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> other OS this operation is ignored$ cat /proc/meminfo | grep -i huge AnonHugePages:        0 kB ShmemHugePages:       0 kB HugePages_Total:      0 HugePages_Free:       0 HugePages_Rsvd:       0 HugePages_Surp:       0 Hugepagesize:      2048 kB</code> </pre> <br>  Dans cet exemple, bien que la taille de la grande page soit d√©finie sur 2048 (2 Mo), le nombre total de grandes pages est de 0. Cela signifie que les grandes pages sont d√©sactiv√©es. <br><br><h3>  Script pour d√©terminer le nombre de grandes pages </h3><br>  Ce script simple renvoie le nombre requis de grandes pages.  Ex√©cutez le script sur votre serveur Linux pendant l'ex√©cution de PostgreSQL.  V√©rifiez que le r√©pertoire de donn√©es PostgreSQL est d√©fini pour la variable d'environnement <i>$ PGDATA</i> . <br><br>  <sup><b>Obtenir le nombre de grandes pages requises</b></sup> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash pid=`head -1 $PGDATA/postmaster.pid` echo "Pid:           $pid" peak=`grep ^VmPeak /proc/$pid/status | awk '{ print $2 }'` echo "VmPeak:          $peak kB" hps=`grep ^Hugepagesize /proc/meminfo | awk '{ print $2 }'` echo "Hugepagesize:  $hps kB" hp=$((peak/hps)) echo Set Huge Pages:    $hp</span></span></code> </pre> <br>  La sortie du script est la suivante: <br><br>  <sup><b>Sortie de script</b></sup> <br><br><pre> <code class="bash hljs">Pid:           12737 VmPeak:        180932 kB Hugepagesize:  2048 kB Set Huge Pages: 88</code> </pre> <br>  La valeur recommand√©e pour les grandes pages est 88, vous devez donc la d√©finir sur 88. <br><br>  <sup><b>Installer de grandes pages</b></sup> <br><br><pre> <code class="bash hljs">sysctl -w vm.nr_hugepages=88</code> </pre> <br>  V√©rifiez les grandes pages maintenant, vous verrez que les grandes pages ne sont pas utilis√©es (HugePages_Free = HugePages_Total). <br><br>  <sup><b>Informations sur les grandes pages √† nouveau (Linux uniquement)</b></sup> <br><br><pre> <code class="bash hljs">$ cat /proc/meminfo | grep -i huge AnonHugePages:        0 kB ShmemHugePages:       0 kB HugePages_Total:     88 HugePages_Free:      88 HugePages_Rsvd:       0 HugePages_Surp:       0 Hugepagesize:      2048 kB</code> </pre> <br>  Maintenant, d√©finissez √©norme_pages ¬´on¬ª sur $ PGDATA / postgresql.conf et red√©marrez le serveur. <br><br>  <sup><b>Et encore une fois, des informations sur les grandes pages (Linux uniquement)</b></sup> <br><br><pre> <code class="bash hljs">$ cat /proc/meminfo | grep -i huge AnonHugePages:        0 kB ShmemHugePages:       0 kB HugePages_Total:     88 HugePages_Free:      81 HugePages_Rsvd:       64 HugePages_Surp:       0 Hugepagesize:      2048 kB</code> </pre> <br>  Vous pouvez maintenant voir que tr√®s peu de grandes pages sont utilis√©es.  Essayons maintenant d'ajouter des donn√©es √† la base de donn√©es. <br><br>  <sup><b>Quelques op√©rations de base de donn√©es pour le recyclage de grandes pages</b></sup> <br><br><pre> <code class="sql hljs">postgres=<span class="hljs-comment"><span class="hljs-comment"># CREATE TABLE foo(a INTEGER); CREATE TABLE postgres=# INSERT INTO foo VALUES(generate_Series(1,10000000)); INSERT 0 10000000</span></span></code> </pre> <br>  Voyons voir si nous utilisons des pages plus grandes maintenant qu'auparavant. <br><br>  <sup><b>Encore une fois des informations sur de grandes pages (Linux uniquement)</b></sup> <br><br><pre> <code class="bash hljs">$ cat /proc/meminfo | grep -i huge AnonHugePages:        0 kB ShmemHugePages:       0 kB HugePages_Total:     88 HugePages_Free:      18 HugePages_Rsvd:       1 HugePages_Surp:       0 Hugepagesize:      2048 kB</code> </pre> <br>  Vous pouvez maintenant voir que la plupart des grandes pages sont en cours d'utilisation. <br><br>  <sub>Remarque: la valeur approximative des HugePages utilis√©es ici est tr√®s faible, ce qui n'est pas une valeur normale pour une machine dans un environnement alimentaire.</sub>  <sub>Veuillez √©valuer le nombre de pages requis pour votre syst√®me et les d√©finir en fonction de la charge et des ressources.</sub> <br><br><h3>  vm.swappiness </h3><br>  <b>vm.swappiness</b> est un autre param√®tre du noyau qui peut affecter les performances de la base de donn√©es.  Ce param√®tre est utilis√© pour contr√¥ler le comportement d'√©change (√©change de pages vers et depuis la m√©moire) sous Linux.  La valeur va de 0 √† 100. Elle d√©termine la quantit√© de m√©moire qui sera d√©charg√©e ou d√©charg√©e.  Z√©ro signifie d√©sactiver l'√©change et 100 signifie √©change agressif. <br><br>  Vous pouvez obtenir de bonnes performances en d√©finissant des valeurs inf√©rieures. <br><br>  Si vous d√©finissez la valeur sur 0 dans les noyaux plus r√©cents, OOM Killer (processus de nettoyage de la m√©moire Linux) peut tuer le processus.  Ainsi, vous pouvez d√©finir la valeur sur 1 en toute s√©curit√© si vous souhaitez minimiser l'√©change.  La valeur par d√©faut sous Linux est 60. Une valeur plus √©lev√©e fait que la MMU (unit√© de gestion de la m√©moire) utilise plus d'espace de pagination que la RAM, tandis qu'une valeur plus basse enregistre plus de donn√©es / code en m√©moire. <br><br>  Une valeur inf√©rieure est un bon pari sur l'am√©lioration des performances dans PostgreSQL. <br><br><h3>  vm.overcommit_memory / vm.overcommit_ratio </h3><br>  Les applications re√ßoivent de la m√©moire et la lib√®rent lorsqu'elle n'est plus n√©cessaire.  Mais dans certains cas, l'application obtient trop de m√©moire et ne la lib√®re pas.  Cela peut provoquer un tueur OOM.  Voici les valeurs possibles pour le param√®tre <b>vm.overcommit_memory</b> avec une description pour chacune: <br><br><ol><li>  Surcharge heuristique (par d√©faut);  heuristique bas√©e sur le noyau </li><li>  Autorisez quand m√™me le surengagement </li><li>  N'en faites pas trop, ne d√©passez pas le ratio de surengagement. </li></ol><br>  <i>Lien: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.kernel.org/doc/Documentation/vm/overcommit-accounting</a></i> <br><br>  <b>vm.overcommit_ratio</b> - pourcentage de RAM disponible pour la surcharge.  Une valeur de 50% dans un syst√®me avec 2 Go de RAM peut allouer jusqu'√† 3 Go de RAM. <br><br>  Une valeur de 2 pour vm.overcommit_memory offre de meilleures performances pour PostgreSQL.  Cette valeur maximise l'utilisation de la RAM par le processus serveur sans risque significatif d'√™tre tu√© par le processus de tueur OOM.  L'application pourra red√©marrer, mais uniquement dans les limites des d√©penses excessives, ce qui r√©duit le risque que le tueur OOM ne tue le processus.  Par cons√©quent, une valeur de 2 donne de meilleures performances que la valeur par d√©faut de 0. Cependant, la fiabilit√© peut √™tre am√©lior√©e en garantissant que la m√©moire en dehors de la plage acceptable n'est pas surcharg√©e.  Cela √©limine le risque que le processus soit tu√© par le tueur OOM. <br><br>  Sur les syst√®mes sans pagination, un probl√®me peut se produire avec vm.overcommit_memory √©gal √† 2. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.postgresql.org/docs/current/static/kernel-resources.html#LINUX-MEMORY-OVERCOMMIT</a> <br><br><h3>  vm.dirty_background_ratio / vm.dirty_background_bytes </h3><br>  <b>vm.dirty_background_ratio</b> est le pourcentage de m√©moire remplie de pages sales qui doivent √™tre √©crites sur le disque.  R√©initialisez sur le disque en arri√®re-plan.  La valeur de ce param√®tre est comprise entre 0 et 100;  cependant, une valeur inf√©rieure √† 5 peut √™tre inefficace et certains noyaux ne la prennent pas en charge.  10 est la valeur par d√©faut sur la plupart des syst√®mes Linux.  Vous pouvez am√©liorer les performances pour les op√©rations d'enregistrement intensives √† un taux inf√©rieur, ce qui signifie que Linux videra les pages sales en arri√®re-plan. <br><br>  Vous devez d√©finir la valeur de <b>vm.dirty_background_bytes en</b> fonction de la vitesse de votre disque. <br><br>  Il n'y a pas de ¬´bonnes¬ª valeurs pour ces deux param√®tres, car les deux d√©pendent du mat√©riel.  Cependant, la d√©finition de vm.dirty_background_ratio sur 5 et vm.dirty_background_bytes √† 25% de la vitesse du disque augmentera les performances √† ~ 25% dans la plupart des cas. <br><br><h3>  vm.dirty_ratio / dirty_bytes </h3><br>  C'est la m√™me chose que <b>vm.dirty_background_ratio / dirty_background_bytes</b> , sauf que la r√©initialisation est effectu√©e dans une session de travail, bloquant l'application.  Par cons√©quent, vm.dirty_ratio doit √™tre sup√©rieur √† <b>vm.dirty_background_ratio</b> .  Cela garantit que les processus d'arri√®re-plan d√©marreront plus t√¥t afin d'√©viter autant que possible de bloquer l'application.  Vous pouvez ajuster la diff√©rence entre ces deux ratios en fonction de la charge d'E / S du disque. <br><br><h2>  R√©sum√© </h2><br>  Vous pouvez configurer d'autres param√®tres pour augmenter la productivit√©, mais les am√©liorations seront minimes et vous n'obtiendrez pas beaucoup d'avantages.  Nous devons nous rappeler que tous les param√®tres ne s'appliquent pas √† tous les types d'applications.  Certaines applications fonctionnent mieux lorsque nous configurons certains param√®tres, d'autres non.  Vous devez trouver le bon √©quilibre entre les configurations de ces param√®tres pour la charge de travail attendue et le type d'application, et lors de la configuration, vous devez prendre en compte le comportement du syst√®me d'exploitation.  La configuration des param√®tres du noyau n'est pas aussi simple que le r√©glage des param√®tres de la base de donn√©es: il est plus difficile de donner vos recommandations ici. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458860/">https://habr.com/ru/post/fr458860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458846/index.html">Comment d√©velopper un autre jeu de plateforme en utilisant Unity. Un autre tutoriel</a></li>
<li><a href="../fr458848/index.html">Version Rust 1.36.0: futur trait, stabilisation de l'allocation et MaybeUninit <T></a></li>
<li><a href="../fr458850/index.html">Apprenez l'anglais √† moindre co√ªt et efficacement. 2e partie</a></li>
<li><a href="../fr458854/index.html">MotionLayout: les animations sont meilleures, moins de code</a></li>
<li><a href="../fr458856/index.html">Piles AAA bon march√© et ch√®res</a></li>
<li><a href="../fr458864/index.html">Concours de d√©veloppeurs de robots pour TamTam</a></li>
<li><a href="../fr458866/index.html">Fonctionnement de l'√©quilibreur d'√©quipe dans World of Tanks Blitz</a></li>
<li><a href="../fr458868/index.html">Bruit dans les m√©gadonn√©es. Analyse d'entropie</a></li>
<li><a href="../fr458870/index.html">Probl√®mes informatiques les plus courants auxquels nous sommes confront√©s tous les jours</a></li>
<li><a href="../fr458874/index.html">Liste de contr√¥le ASO: optimisation du texte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>