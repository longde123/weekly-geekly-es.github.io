<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏼 ⛏️ 📭 Dois-je apprendre le C pour comprendre le fonctionnement d'un ordinateur? 👩🏼‍🤝‍👨🏽 🎳 💫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai souvent entendu des gens suggérer d'étudier C. pour comprendre les performances de l'ordinateur. Est-ce une bonne idée? Êtes-vous sûr Je vais imm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dois-je apprendre le C pour comprendre le fonctionnement d'un ordinateur?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426993/">  J'ai souvent entendu des gens suggérer d'étudier C. pour comprendre les performances de l'ordinateur. Est-ce une bonne idée?  Êtes-vous sûr  Je vais immédiatement décrire les conclusions de l'article, juste pour une clarté absolue: <br><br><ul><li>  C n'est pas comment l'ordinateur fonctionne. </li><li>  Je ne pense pas que la plupart des gens parlent littéralement, donc peu importe. </li><li>  Comprendre le contexte signifie que l'apprentissage du C pour cette raison peut toujours avoir du sens, selon vos objectifs. </li></ul><br>  J'ai l'intention d'écrire deux autres articles avec une explication plus détaillée des conclusions, mais c'est déjà suffisant.  Ajoutez des liens ici lorsque les articles seront publiés. <br><a name="habracut"></a><br>  J'ai souvent entendu des gens dire ceci: <br><br><blockquote> En étudiant C, vous pouvez comprendre le fonctionnement des ordinateurs. </blockquote><br>  Je ne pense pas que l'idée soit initialement erronée, mais elle a quelques réserves.  Si vous les gardez à l'esprit, cela pourrait très bien être une stratégie viable pour apprendre des choses nouvelles et importantes.  Cependant, je vois rarement des gens discuter de ces réserves en détail, alors j'écris cet article pour fournir, à mon avis, un contexte très nécessaire ... Si vous songez à apprendre le C pour comprendre le fonctionnement de votre ordinateur, cet article est pour vous.  J'espère qu'elle vous aidera à le découvrir. <br><br><blockquote>  Avant de vraiment commencer, je voudrais dire encore une chose: si vous voulez apprendre le C, alors étudiez!  L'apprentissage est super.  L'apprentissage du C est devenu très important pour ma compréhension de l'informatique et ma carrière.  Apprendre ce langage et sa place dans l'histoire d'un langage de programmation fera de vous un meilleur programmeur.  Vous n'avez besoin d'aucune excuse.  Apprenez des choses juste pour le plaisir d'apprendre.  Cet article est destiné à être un guide pour comprendre la vérité, il ne traite pas de l'opportunité d'étudier C. </blockquote><br>  Tout d'abord, à qui cette idée est généralement recommandée.  Si vous essayez de «savoir comment fonctionnent les ordinateurs», il va sans dire que vous ne comprenez pas cela pour le moment.  Quels programmeurs ne comprennent pas comment fonctionnent les ordinateurs?  J'ai essentiellement vu que ce sentiment venait de personnes qui programment principalement dans des langages de «scriptage» typés dynamiquement comme Ruby, Python ou JavaScript.  Ils sont censés «ne pas savoir comment fonctionnent les ordinateurs» car ces langages fonctionnent à l'intérieur d'une machine virtuelle, où seule la sémantique de la machine virtuelle importe.  Au final, l'idée même d'une machine virtuelle est de fournir la portabilité.  Le but n'est pas de dépendre de l'équipement sur lequel la VM fonctionne. <br><br>  Il n'y a qu'un seul problème: C fonctionne <i>également à l'</i> intérieur d'une machine virtuelle. <br><br><h3>  Machine abstraite C </h3><br>  D'après la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spécification C99</a> , section 5.1.2.3, «Exécution du programme»: <br><br><blockquote>  Les descriptions sémantiques de la présente Norme internationale décrivent le comportement d'une machine abstraite dans laquelle les problèmes d'optimisation ne sont pas pertinents. </blockquote><br>  À mon avis, c'est la chose la plus importante à comprendre lors de l'apprentissage de C. Le langage ne «décrit pas le fonctionnement d'un ordinateur», mais décrit le fonctionnement d'une «machine C abstraite».  Tout le reste important découle de ce concept. <br><br><blockquote> Encore une remarque: ici j'ai choisi C99, qui n'est pas la dernière norme C. Pourquoi?  Eh bien, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MSVC a ... une prise en charge intéressante du langage C</a> , et je suis un utilisateur Windows ces jours-ci.  Oui, vous pouvez exécuter <code>clang</code> et <code>gcc</code> sous Windows.  Il n'y a pas de grande différence entre C89, C99 et C11 quant à ce dont nous parlons.  À un moment donné, vous devez choisir.  La version que j'ai mentionnée ici comprend quelques modifications par rapport aux spécifications d'origine. </blockquote><br>  Vous avez peut-être entendu une autre phrase dans votre discours en C: «C est assembleur portable».  Si vous pensez à cette phrase, vous comprendrez que si cela est vrai, alors C ne peut pas correspondre au fonctionnement d'un ordinateur: il existe de nombreux ordinateurs différents avec des architectures différentes.  Si C est comme un assembleur qui s'exécute sur différents ordinateurs avec différentes architectures, il ne peut pas fonctionner simultanément exactement comme chacun de ces ordinateurs.  Il <i>doit</i> cacher les détails, sinon il ne sera pas portable! <br><br>  Néanmoins, je pense que ce fait n'a pas d'importance, car les gens se réfèrent à peine littéralement à "C est la façon dont l'ordinateur fonctionne."  Avant de revenir à cela, parlons de la machine C abstraite, et pourquoi beaucoup ne semblent pas comprendre cet aspect de C. <br><br><h3>  Digression: pourquoi les gens se trompent-ils? </h3><br>  Je ne peux que parler de mon expérience, bien que ce ne soit pas unique. <br><br>  J'ai appris GW-BASIC, puis C, puis C ++, puis Java.  J'ai entendu parler de Java avant de commencer à l'écrire vers 1999, quatre ans après son apparition.  Le marketing à cette époque contrastait activement Java et C ++, il se concentrait sur la JVM en tant que plate-forme, et sur le fait que le modèle de machine le distingue du C ++, et donc C. Sun Microsystems n'existe plus, mais le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">miroir</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communiqué de presse</a> nous rappelle: <br><br><blockquote>  Les applications Java sont indépendantes de la plate-forme;  il vous suffit de porter la machine virtuelle Java sur chaque plate-forme.  Il agit comme un interprète entre l'ordinateur de l'utilisateur et l'application Java.  Une application écrite dans l'environnement Java peut fonctionner n'importe où, éliminant le besoin de porter des applications sur plusieurs plates-formes. </blockquote><br>  La devise principale était «Écrivez une fois, exécutez partout».  Ces deux phrases sont devenues comment j'ai (et beaucoup d'autres) compris Java et comment il diffère de C ++.  Java a un interprète, une machine virtuelle Java.  Il n'y a pas de machine virtuelle en C ++. <br><br>  Avec un marketing aussi puissant, la «machine virtuelle» dans l'esprit de nombreuses personnes est devenue synonyme de «grand moteur d'exécution et / ou interprète».  Les langues sans cette fonctionnalité étaient trop liées à un ordinateur spécifique et nécessitaient un portage car elles n'étaient pas vraiment indépendantes de la plate-forme.  La principale raison pour laquelle Java existait était un changement dans cette faille C ++. <br><br><blockquote>  «Environnement d'exécution», «machine virtuelle» et «machine abstraite» sont des mots différents pour le même concept fondamental.  Mais depuis lors, ils ont reçu des connotations différentes en raison d'une légère variation dans la mise en œuvre de ces idées. </blockquote><br>  Je crois personnellement que ce marketing de 1995 est la raison pour laquelle les programmeurs comprennent encore mal la nature de C. <br><br>  Cette déclaration est-elle donc fausse?  Pourquoi Sun Microsystems dépenserait-il des millions et des millions de dollars pour promouvoir des mensonges?  Si C est également basé sur une machine abstraite qui offre une portabilité multiplateforme, pourquoi avons-nous besoin de Java?  Je pense que c'est la clé pour comprendre ce que les gens veulent vraiment dire quand ils disent "C est comment l'ordinateur fonctionne". <br><br><h3>  Que veulent vraiment dire les gens? </h3><br>  Bien que C fonctionne dans le contexte d'une machine virtuelle, il est toujours très différent des langages de type Java.  Le soleil n'a pas menti.  Pour comprendre, vous devez connaître l'histoire de C. <br><br>  En 1969, Bell Labs a écrit un système d'exploitation informatique en langage assembleur.  En 1970, il a été surnommé UNIX.  Au fil du temps, les Bell Labs ont acheté de plus en plus de nouveaux ordinateurs, dont le PDP-11. <br><br>  Quand est venu le temps de porter Unix sur PDP-11, ils ont décidé d'utiliser un langage de niveau supérieur, ce qui était une idée assez radicale à l'époque.  Imaginez qu'aujourd'hui je vous dise: "Je vais écrire un OS en Java" - vous allez probablement rire, bien que l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">idée soit réalisable</a> .  La situation (à ma connaissance, je ne vivais pas à l'époque) était à peu près la même.  Nous avons considéré un langage appelé B, mais il ne supportait pas certaines des fonctions du PDP-11, et donc ils ont créé un successeur en l'appelant "C" car c'était la prochaine lettre de l'alphabet. <br><br><blockquote>  Il n'y avait pas de langue "A";  B a réussi BCPL (Basic Combined Programming Language). </blockquote><br>  En 1972, le premier compilateur C a été écrit sur PDP-11 et en même temps réécrit UNIX en C. Initialement, ils ne pensaient pas à la portabilité, mais C a gagné en renommée, donc les compilateurs C ont porté sur d'autres systèmes. <br><br>  En 1978, la première édition du livre "Programming Language C" a été publiée.  Affectueusement appelé «K&amp;R», selon les noms de ses auteurs, le livre ne ressemblait pas du tout à la spécification, mais en même temps, décrivait le langage de manière suffisamment détaillée, à la suite de quoi d'autres ont également essayé d'écrire des compilateurs C. Plus tard, cette «version» sera appelée «K&amp;R C». <br><br>  À mesure que UNIX et C se répandaient, ils étaient tous deux portés sur de nombreux ordinateurs.  Dans les années 70 et 80, leur base matérielle ne cessait de croître.  De la même manière que C a été créé car B ne prend pas en charge toutes les fonctions de PDP-11, de nombreux compilateurs utilisent des extensions de langage.  Comme il n'y avait que K&amp;R et non une spécification, cela était considéré comme acceptable tant que les extensions étaient assez proches.  En 1983, l'absence de toute normalisation posait des problèmes. L'ANSI a donc constitué une équipe pour préparer les spécifications.  En 1989, la norme C89 est sortie, parfois appelée "ANSI C". <br><br>  La spécification C a tenté d'unifier ces diverses implémentations sur divers matériels.  Ainsi, la machine C abstraite est une sorte de spécification la plus petite possible qui permettrait au même code de fonctionner de la même sur toutes les plateformes.  Les implémentations C ont été compilées, pas interprétées, donc il n'y avait pas d'interprète, donc il n'y avait pas de «VM» au sens de 1995.  Cependant, les programmes C sont écrits sur cet ordinateur abstrait inexistant, puis le code est converti en assembleur spécifique à l'ordinateur particulier sur lequel le programme s'exécute.  Vous ne pouviez pas vous fier à certains détails spécifiques pour écrire du code C. portable. Cela rend l'écriture du C portable très difficile car vous avez peut-être fait une hypothèse spécifique à la plate-forme lors de l'écriture de la version initiale de votre code. <br><br>  Ceci est mieux illustré par un exemple.  Un des principaux types de données en C est <code>char</code> , du mot "caractère".  Cependant, la machine C abstraite ne détermine pas combien de bits doivent être en caractères.  Eh bien, détermine, mais pas par nombre;  il détermine la taille de <code>CHAR_BIT</code> , qui est une constante.  Section 5.2.4.2.1 de la spécification: <br><br><blockquote>  Les valeurs indiquées ci-dessous doivent être remplacées par des expressions constantes appropriées ou utilisées dans les directives de prétraitement <code>#if</code> . ... Les valeurs dans des implémentations spécifiques doivent être égales ou supérieures en magnitude (valeur absolue) à celles données ici avec le même signe. <br><br> <code>CHAR_BIT: 8</code> </blockquote> <br>  En d'autres termes, vous savez que <code>char</code> est au moins 8 bits, mais les implémentations peuvent être plus grandes.  Afin de coder correctement une «machine C abstraite», <code>CHAR_BIT</code> doit être utilisé au lieu de <code>8</code> comme taille lors du traitement de <code>char</code> .  Mais ce n'est pas une sorte de fonction d'interprète, comme nous pensons aux machines virtuelles;  c'est une propriété de la façon dont le compilateur traduit le code source en code machine. <br><br><blockquote>  Oui, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il existe des systèmes</a> où <code>CHAR_BIT</code> pas <code>8</code> . </blockquote><br>  Ainsi, cette "machine abstraite", bien que techniquement la même idée que la machine virtuelle Java, est plus probablement une construction de compilation pour gérer les compilateurs lors de la création de code assembleur, plutôt qu'une sorte de vérification ou de propriété d'exécution.  Le type équivalent en Java est un <code>byte</code> , qui est toujours 8 bits, et l'implémentation JVM est chargée de ce qu'il faut faire sur les plates-formes avec plus d'octets.  (Je ne sais pas si la JVM fonctionne sur l'une de ces plates-formes, mais c'est ainsi que cela devrait fonctionner.)  La machine C abstraite a été créée comme une enveloppe minimale pour divers "matériels", et non comme une sorte de plate-forme en tissu solide, écrite dans un logiciel pour votre code. <br><br>  Donc, bien que Sun se soit trompé techniquement, dans la pratique, ils signifient un peu ce qu'ils disent littéralement, et ce qu'ils <i>veulent dire</i> est vrai.  Même chose avec la phrase «Apprenez C pour comprendre le fonctionnement des ordinateurs». <br><br><h3>  Apprenez à mieux comprendre le fonctionnement des ordinateurs </h3><br>  Que <i>veulent vraiment</i> dire les gens?  Dans le contexte de «un rubiste doit-il apprendre le C pour comprendre le fonctionnement des ordinateurs» - c'est un conseil pour descendre «au niveau du fer».  C'est-à-dire non seulement pour comprendre comment votre propre programme fonctionne à l'intérieur de la machine virtuelle, mais aussi comment la combinaison du programme et de la VM fonctionne dans le contexte de la machine elle-même. <br><br>  L'apprentissage C vous <i>fournira</i> plus de ces détails car la machine abstraite est beaucoup plus proche du matériel ainsi que des abstractions des systèmes d'exploitation.  Le langage C est très différent des langages de haut niveau, donc l'apprendre peut en apprendre beaucoup. <br><br>  Mais il est important de se rappeler que C est essentiellement une <i>abstraction</i> matérielle et que les abstractions sont imparfaites.  Faites attention à ce que fait C ou à son fonctionnement avec la machine elle-même.  Si vous allez trop loin, vous rencontrerez sûrement ces différences, ce qui peut causer des problèmes.  La plupart des ressources de formation pour C, en particulier aujourd'hui, lorsque l'équipement devient plus homogène, favoriseront l'idée que <i>c'est ainsi</i> que <i>fonctionne</i> un ordinateur.  Par conséquent, il peut être difficile pour un élève de comprendre ce qui se passe sous le capot et quelle est l'abstraction fournie par C. <br><br>  Dans cette discussion, nous n'avons même pas abordé d'autres questions.  Par exemple, en raison de l'énorme popularité de C, le matériel est devenu plus uniforme car il tend à évoluer vers la sémantique de la machine abstraite C. Si votre architecture est trop différente de la sémantique C, les programmes C peuvent s'exécuter beaucoup plus lentement que les autres. et la vitesse du matériel est souvent mesurée par des tests en C. Cet article est déjà assez long ... <br><br>  Pour cette raison, je pense qu'une version plus précise de cette déclaration serait «En apprenant le C, vous <i>en</i> apprendrez <i>plus</i> sur le fonctionnement des ordinateurs».  Je pense vraiment qu'une connaissance approximative de C est utile à de nombreux programmeurs, même s'ils n'écrivent pas eux-mêmes C. L'introduction de C vous donnera également une idée de l'histoire de notre industrie. <br><br>  Il existe d'autres façons d'explorer ce sujet;  C <i>n'est intrinsèquement</i> pas conçu pour en savoir plus sur un ordinateur, mais c'est une bonne option. <br><br>  Il y a tellement à apprendre en programmation.  Je vous souhaite beaucoup de succès dans ce voyage. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426993/">https://habr.com/ru/post/fr426993/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426981/index.html">10 astuces pour un tableau de bord avancé dans Splunk. Partie 1</a></li>
<li><a href="../fr426983/index.html">Nouveau dans SObjectizer-5.5.23: réalisation des souhaits ou boîte de Pandore?</a></li>
<li><a href="../fr426985/index.html">kubebox et autres coques de console pour Kubernetes</a></li>
<li><a href="../fr426987/index.html">Apprenez OpenGL. Leçon 6.3 - Éclairage basé sur l'image. Irradiation diffuse</a></li>
<li><a href="../fr426991/index.html">Startup Digest: 10 événements IT à venir à Moscou</a></li>
<li><a href="../fr426995/index.html">Le recyclage nuit aux produits et aux employés</a></li>
<li><a href="../fr426997/index.html">Comment créer des formes personnalisées à l'aide de MaterialShapeDrawable</a></li>
<li><a href="../fr426999/index.html">Suivre les tendances ou évoluer vers RxJava et LiveData</a></li>
<li><a href="../fr427003/index.html">Cartes hexagonales dans Unity: brouillard de guerre, recherche cartographique, génération procédurale</a></li>
<li><a href="../fr427005/index.html">Développeurs d'IA - le métier de millionnaire?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>