<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåü üë† ‚ùÑÔ∏è Die Vereinigung von Arduino und dem klassischen Prozessor üíç üë¶üèº ‚úãüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Retrocomputer sind in unterschiedlichem Ma√üe pingelig. Einige geben sich mit der Emulation zufrieden. Andere bevorzugen FPGAs, denn dann stellt sich h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Vereinigung von Arduino und dem klassischen Prozessor</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446048/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/8r/yr/ol8ryrltwjene6e2frje_pacnti.jpeg"></div><br>  Retrocomputer sind in unterschiedlichem Ma√üe pingelig.  Einige geben sich mit der Emulation zufrieden.  Andere bevorzugen FPGAs, denn dann stellt sich heraus, dass es sich nicht um Emulation, sondern um Erholung handelt.  Zum Schluss den dritten Prozessor bedienen. <br><br>  Aber der Prozessor braucht so viel, um zu arbeiten!  Wieder das Dilemma: Nehmen Sie echte Chips der gleichen Jahre oder legen Sie alles in das FPGA und lassen Sie den Prozessor drau√üen?  Warum ist FPGA jedoch notwendig?  Es lebe die Vereinigung von Arduino und klassischem Prozessor! <a name="habracut"></a><br><br>  Geben Sie Ihrem Arduino ein ‚Äûzweites Gehirn‚Äú und machen Sie es schlauer. <br><br>  Ein echter 8-Bit-Mikroprozessor f√ºhrt Programme aus, w√§hrend ein Arduino ROM, RAM und einfache Peripherieger√§te emuliert. <br><br>  Entwerfen Sie virtuelle Peripherieger√§te in der Arduino IDE und f√ºhren Sie den Assembler-Code auf dem Mikroprozessor aus.  Keine Notwendigkeit, komplexe Schaltungen und Flash-Parallel-ROMs zusammenzubauen. <br><br>  Unterst√ºtzte Mikroprozessoren: 6502, 6809 und Z80 (818581), andere sind unterwegs. <br><br>  Eine Abschirmung mit einem Mikroprozessor beeintr√§chtigt nicht die Verbindung anderer Abschirmungen: mit LCDs, Speicherkarten usw. <br><br>  Zus√§tzlich zur Selbstassemblierungssprache k√∂nnen Sie versuchen, klassischen Code auf dem Mikroprozessor auszuf√ºhren. <br><br>  Der Mikroprozessor arbeitet zwar mit einer sehr niedrigen Frequenz - etwa 95 kHz, sein genauer Wert h√§ngt von der Optimierung des peripheren Emulationscodes ab. <br><br>  Die Verteilung des Adressraums wird programmgesteuert in einer Skizze festgelegt.  Dem Mikroprozessor k√∂nnen 4 bis 6 kB 8 kB RAM zugewiesen werden, die auf dem Arduino Mega verf√ºgbar sind.  Der ROM kann mehr als 200 kB der verf√ºgbaren 256 zuweisen. <br><br>  Die serielle Arduino Mega-Schnittstelle kann UART emulieren. <br><br>  Schaltungen, Platinenzeichnungen, Gerber-Dateien finden Sie hier unter CC-BY-SA 4.0.  Gleichzeitig muss die Datei README.md angeh√§ngt werden, da sie die folgende Warnung enth√§lt: <br><blockquote>  Schlie√üen Sie die Abschirmung erst an, wenn die periphere Emulationsskizze hochgeladen wurde!  Andernfalls ist ein Kurzschluss der Ausgangsleitungen des Mikroprozessors m√∂glich. </blockquote>  Ja, und in der Skizze selbst muss aus demselben Grund etwas sorgf√§ltig √ºberarbeitet werden. <br><br>  Das Schema des Ger√§ts auf 6502: <br><br><img src="https://habrastorage.org/webt/e0/n8/6k/e0n86kpozlcttklifjihnl51quo.png"><br><br>  Das Schema des Ger√§ts auf 6809: <br><br><img src="https://habrastorage.org/webt/qf/yi/kx/qfyikx1tktdjuad0hocivlpsolw.png"><br><br>  Schema des Ger√§ts auf dem Z80: <br><br><img src="https://habrastorage.org/webt/ct/uh/qs/ctuhqskjmmp1rvxrhs8abcoqvne.png"><br><br>  Sie k√∂nnen bereits ausf√ºhren: <br><br>  Auf einem Ger√§t mit 6502 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apple I, Woz Monitor + ROM mit BASIC</a> <br><br>  Auf einem Ger√§t mit 6809 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Analogon eines selbstgebauten Computers Simon6809 desselben Entwicklers, eines Trainingsmonitors mit Assembler und Disassembler</a> <br><br>  Auf einem Ger√§t mit Z80 - bisher nur ein Echotest <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der seriellen Schnittstelle</a> , mit dem Sie die Leistung des virtuellen 8251 (KR580VV51A) √ºberpr√ºfen k√∂nnen. <br><br>  Firmware zur Emulation von Peripherieger√§ten - unter der MIT-Lizenz. <br><br>  Kurzbeschreibungen des Handlungsprinzips: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zum 6502 Ger√§t</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zum Ger√§t auf 6809</a> <br><br>  Zum Ger√§t am Z80 - in Vorbereitung. <br><br>  Der Entwickler versucht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> Ger√§te zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verkaufen</a> , jedoch nur in den USA.  Es gibt keinen besonderen Grund zum Kauf, da das Schema sehr einfach ist, k√∂nnen Sie es in einer Stunde auf einem St√ºck des Steckbretts wiederholen. <br><br>  Es ist geplant, √§hnliche Boards auf RCA1802, 68008, 8085 (211821 ,85), 8088 (181088) zu entwickeln.  √úber K1801BM1 wird nichts gesagt, aber Sie k√∂nnen dem Autor eine solche Idee vorlegen. <br><br>  Dateien: <br><br>  Zum Ger√§t auf 6502: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Montageanleitung</a> , <a href="">Siebdruck</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diagramm</a> <br><br>  Zum Ger√§t auf 6809: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Montageanleitung</a> , <a href="">Siebdruck</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diagramm</a> <br><br>  Zum Ger√§t am Z80: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Montageanleitung</a> , <a href="">Siebdruck</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diagramm</a> <br><br>  Betrachten Sie das Zusammenspiel von Arduino und 6502-Ger√§t. Das Arduino √§ndert regelm√§√üig den Pegel am Eingang des Mikroprozessors, der f√ºr die Versorgung von Taktimpulsen ausgelegt ist, von Null auf Eins und umgekehrt.  Bei jedem Zyklus pr√ºft es, was auf den Steuerleitungen und dem Adressbus geschieht, und liest je nach Situation Informationen vom Datenbus oder sendet sie dorthin.  Arduino kann auch IRQ- und NMI-Leitungen steuern, was zu Unterbrechungen f√ºhrt.  Die Abbildung zeigt die Datentypen und die √úbertragungsrichtungen: <br><br><img src="https://habrastorage.org/webt/tr/in/je/trinjeibi9cwwrngfq628lm4yns.png"><br><br>  Die Entsprechung der Arduino-Ports und der Mikroprozessorausg√§nge ist in der Skizze konfiguriert: <br><br><pre><code class="plaintext hljs">/* Digital Pin Assignments */ #define DATA_OUT PORTL #define DATA_IN PINL #define ADDR_H PINC #define ADDR_L PINA #define ADDR ((unsigned int) (ADDR_H &lt;&lt; 8 | ADDR_L)) #define uP_RESET_N 38 #define uP_RW_N 40 #define uP_RDY 39 #define uP_SO_N 41 #define uP_IRQ_N 50 #define uP_NMI_N 51 #define uP_E 52 #define uP_GPIO 53</code> </pre> <br>  Wir werden jede Ma√ünahme in folgende Ereignisse unterteilen: <br><br>  CLK √§ndert den Status von eins auf null (Abnahme) <br>  CLK befindet sich in einem Zustand von Null <br>  CLK √§ndert den Zustand von eins auf null (Anstieg) <br>  CLK befindet sich im Einheitszustand <br>  CLK √§ndert erneut den Status von eins auf null ... <br><br>  Was passiert in Momenten des Staats√ºbergangs? <br><br>  6502 empf√§ngt Taktimpulse am Eingang CLK0, puffert sie und sendet sie an zwei Ausg√§nge: CLK1 und CLK2.  Obwohl alle Ereignisse im Mikroprozessor an CLK1 gebunden sind, nehmen wir an, dass die Verz√∂gerung gering ist, und sie sind an CLK0 gebunden - die Linie, entlang der der Mikroprozessor Taktimpulse von Arduino empf√§ngt.  Und nenne das Signal nur CLK. <br><br><img src="https://habrastorage.org/webt/9i/kq/hc/9ikqhcytwd4sjg6rwjnvmohgkvi.png"><br><br>  1. CLK √§ndert den Status von eins auf null. <br><br>  2. Der Mikroprozessor gibt eine neue Adresse an den Adressbus und ein Schaltsignal zwischen Lesen und Schreiben an den R / W-Ausgang aus.  Aber er ist noch nicht bereit f√ºr den Datenaustausch. <br><br>  3. CLK geht in den Einheitszustand √ºber, und dies bedeutet, dass der Datenaustausch begonnen hat.  Wenn dies eine Leseoperation ist, √ºbertr√§gt der Mikroprozessor die Datenbusausg√§nge in den Eingangszustand und empf√§ngt Daten, und wenn die Schreiboperation, √ºbertr√§gt er sie in den Ausgangszustand und sendet Daten.  Und das R / W-Signal schaltet das externe Ger√§t in den Schreib- oder Lesemodus, das Gegenteil des entsprechenden Zustands des Mikroprozessors. <br><br>  4. CLK geht auf Null.  Jetzt geben weder der Mikroprozessor noch die Eingabe- / Ausgabeger√§te etwas an den Datenbus aus.  Der Mikroprozessor kann die Datenbusleitung und den R / W-Pin in einen neuen Zustand versetzen. <br><br>  Eine einfache Erkl√§rung, die f√ºr das Kind verst√§ndlich ist.  Wer nie an diese "Intrigen hinter den Kulissen" denkt, der programmiert nur Mikrocontroller.  Auch im Assembler. <br><br>  Wenn Sie Ihr Peripherieger√§t anschlie√üen m√ºssen, muss es Zeit haben, die Daten vorzubereiten, bevor das Ger√§t (Vorbereitungszeit) in der CLK-Zeile angezeigt wird. Wenn das Ger√§t dort ist, √§ndern Sie es nicht.  Wenn das Peripherieger√§t keine Zeit hat, die Daten vorzubereiten, w√§hrend CLK Null ist, oder sie √§ndert, wenn das Ger√§t vorhanden ist, werden Sie sich lange fragen, warum Ihr Code nicht funktioniert.  Da die Taktfrequenz des Mikroprozessors zehn- bis f√ºnfzehnmal niedriger als die Nennfrequenz ist, ist es einfach, diese Anforderung zu erf√ºllen.  Aber es ist notwendig. <br><br>  Wir m√ºssen also Arduino ‚Äûbeibringen‚Äú, Taktimpulse zu erzeugen, kontinuierlich zu √ºberpr√ºfen, was auf dem Adressbus und der R / W-Leitung geschieht, und entsprechend mit dem Datenbus interagieren.  Zu diesem Zweck verwendet die Skizze den Timer1-Timer-Interrupt, der Impulse mit einer Frequenz von 95 kHz erzeugt.  Arduino arbeitet viel schneller als der Mikroprozessor und kann daher zwischen seinen Uhren alles lesen und vorbereiten.  Es ist wichtig sicherzustellen, dass diese Bedingung nach dem √Ñndern der Skizze weiterhin erf√ºllt ist. <br><br>  Hier ist ein Auszug aus der Skizze, der zeigt, wie der CLK von null auf eins geht und was als n√§chstes passiert: <br><br><pre> <code class="plaintext hljs">//////////////////////////////////////////////////////////////////// // Processor Control Loop //////////////////////////////////////////////////////////////////// // This is where the action is. // it reads processor control signals and acts accordingly. // ISR(TIMER1_COMPA_vect) { // Drive CLK high CLK_E_HIGH; // Let's capture the ADDR bus uP_ADDR = ADDR; if (STATE_RW_N) ////////////////////////////////////////////////////////////////// // HIGH = READ transaction { // uP wants to read so Arduino to drive databus to uP: DATA_DIR = DIR_OUT; // Check what device uP_ADDR corresponds to: // ROM? if ( (ROM_START &lt;= uP_ADDR) &amp;&amp; (uP_ADDR &lt;= ROM_END) ) DATA_OUT = pgm_read_byte_near(rom_bin + (uP_ADDR - ROM_START)); else if ( (BASIC_START &lt;= uP_ADDR) &amp;&amp; (uP_ADDR &lt;= BASIC_END) ) DATA_OUT = pgm_read_byte_near(basic_bin + (uP_ADDR - BASIC_START)); else // RAM? if ( (uP_ADDR &lt;= RAM_END) &amp;&amp; (RAM_START &lt;= uP_ADDR) ) DATA_OUT = RAM[uP_ADDR - RAM_START]; else // 6821? if ( KBD &lt;=uP_ADDR &amp;&amp; uP_ADDR &lt;= DSPCR ) { // KBD? if (uP_ADDR == KBD) { ... // handle KBD register } else // KBDCR? if (uP_ADDR == KBDCR) { ... // handle KBDCR register } else // DSP? if (uP_ADDR == DSP) { ... // handle DSP register } else // DSPCR? if (uP_ADDR == DSPCR) { ... // handle DSPCR register } } } else ////////////////////////////////////////////////////////////////// // R/W = LOW = WRITE { // RAM? if ( (uP_ADDR &lt;= RAM_END) &amp;&amp; (RAM_START &lt;= uP_ADDR) ) RAM[uP_ADDR - RAM_START] = DATA_IN; else // 6821? if ( KBD &lt;=uP_ADDR &amp;&amp; uP_ADDR &lt;= DSPCR ) { // KBD? if (uP_ADDR == KBD) { ... // handle KBD register } else // KBDCR? if (uP_ADDR == KBDCR) { ... // handle KBDCR register } else // DSP? if (uP_ADDR == DSP) { ... // handle DSP register } else // DSPCR? if (uP_ADDR == DSPCR) { ... // handle DSPCR register } } } //////////////////////////////////////////////////////////////// // We are done with this cycle. // one full cycle complete clock_cycle_count ++; // start next cycle CLK_E_LOW; // If Arduino was driving the bus, no need anymore. // natural delay for DATA Hold time after CLK goes low (t_HR) DATA_DIR = DIR_IN; }</code> </pre> <br>  Die Zuweisung des Adressraums kann auf beliebige Weise erfolgen. In einer unver√§nderten Skizze ist dies dieselbe wie in Apple 1 mit 256 Byte ROM, 8 Kilobyte ROM f√ºr BASIC, 4 Kilobyte RAM und 6821 Eingabe- / Ausgabeger√§t. <br><br><pre> <code class="plaintext hljs">// MEMORY LAYOUT // 4K MEMORY #define RAM_START 0x0000 #define RAM_END 0x0FFF byte RAM[RAM_END-RAM_START+1]; // ROMs (Monitor + Basic) #define ROM_START 0xFF00 #define ROM_END 0xFFFF #define BASIC_START 0xE000 #define BASIC_END 0xEFFF //////////////////////////////////////////////////////////////////// // Woz Monitor Code //////////////////////////////////////////////////////////////////// // PROGMEM const unsigned char rom_bin[] = { 0xd8, 0x58, 0xa0, 0x7f, 0x8c, 0x12, 0xd0, 0xa9, 0xa7, 0x8d, 0x11, 0xd0, ... 0x00, 0xff, 0x00, 0x00 }; // BASIC ROM starts at E000 PROGMEM const unsigned char basic_bin[] = { 0x4C, 0xB0, 0xE2, 0xAD, 0x11, 0xD0, 0x10, 0xFB, ... 0xE0, 0x80, 0xD0, 0x01, 0x88, 0x4C, 0x0C, 0xE0 };</code> </pre> <br>  RAM wird durch Byte-RAM-Array [RAM_END-RAM_START + 1] emuliert.  Es werden zwei PROGMEM-Schl√ºsselw√∂rter ben√∂tigt, damit der Inhalt emulierter ROMs im Flash-Speicher des Mikrocontrollers gespeichert wird. <br><br>  6821 ist so emuliert, dass die virtuelle Tastatur und Anzeige √ºber das ‚ÄûTerminal‚Äú funktionieren.  Woz Monitor und BASIC arbeiten, was der Autor suchte. <br><br>  Um ein Peripherieger√§t zu emulieren, m√ºssen Sie dessen Datenblatt sorgf√§ltig lesen und herausfinden, √ºber welche Register es verf√ºgt und wof√ºr sie bestimmt sind.  Der Komfort der Emulation liegt in der Flexibilit√§t, mit der Sie Software-Analoga der Peripherie erstellen k√∂nnen. <br><br>  E / A-Ger√§te befinden sich im Adressraum des Mikroprozessors und werden wie Speicherzellen aufgerufen.  Um die "Eisen" -Peripherieger√§te wie ein LCD-Display, eine Speicherkarte und eine Tonausgabe zu verwenden, m√ºssen Sie einen Platz im Adressraum zuweisen. <br><br>  Referenzen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.6502.org</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.callapple.org/soft/ap1/emul.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Skilldrick.github.io/easy6502</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">searle.hostei.com/grant/6502/Simple6502.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wilsonminesco.com/6502primer</a> <br>  SB-Assembler: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.sbprojects.net/sbasm</a> <br><br>  Gehen Sie zu 6809, es enth√§lt: <br><br>  Zwei 8-Bit-Batterien A und B, die zu einer 6-Bit-Batterie kombiniert werden k√∂nnen <br>  Zwei 16-Bit-Stapelindizes <br>  Adressierung relativ zum Anweisungsz√§hler <br>  Addiere oder subtrahiere automatisch 1 oder 2 <br>  Multiplikation von zwei achtstelligen vorzeichenlosen Zahlen <br>  16-Bit-Arithmetik <br>  √úbertragung und Austausch von Daten zwischen allen Registern <br>  Schreiben und Lesen aller Register und einer beliebigen Kombination davon <br><br>  Der Mikroprozessor 6809E (extern) ben√∂tigt eine externe Uhr, w√§hrend der 6809 eine interne hat.  F√ºr Hitachi hei√üen sie 6309E bzw. 6309 und unterscheiden sich von den √ºblichen darin, dass sie innerhalb der Operation in 32-Bit-Form arbeiten. Es ist jedoch m√∂glich, mit der klassischen Version in den Kompatibilit√§tsmodus zu wechseln. <br><br>  Eigentlich begann das gesamte RetroShield-Projekt, weil der Autor seinen selbstgebauten Computer Simon6809 aktualisieren und das Ergebnis Simon6809 Turbo nennen wollte.  Es stellte sich jedoch heraus, dass Standard-Logik-Chips f√ºr alles, was er dort implementieren wollte, viel erfordern w√ºrden.  Daher formulierte der Autor die Idee von RetroShield zum ersten Mal speziell in Bezug auf 6809 und dachte erst dann: ‚ÄûWas ist, wenn dasselbe mit anderen Prozessoren dasselbe tut?‚Äú. <br><br>  Das Ger√§t verwendet nat√ºrlich den 6809E, f√ºr den eine externe Uhr erforderlich ist, damit es seine Arbeit von au√üen synchronisieren kann.  Die E- und Q-Leitungen f√ºr beide Prozessoren haben den gleichen Namen, nur 6809 haben Ausg√§nge und 6809E haben Eing√§nge. <br><br>  Arduino interagiert mit 6809 auf die gleiche Weise wie mit 6502, verf√ºgt jedoch √ºber zwei Takteing√§nge: E und Q und drei Interrupt-Eing√§nge: IRQ, FIRQ und NMI. <br><br><img src="https://habrastorage.org/webt/0i/uk/dn/0iukdn25vkrhbsvd8spjlhr-s3q.png"><br><br>  Dieses Mal ist die Entsprechung zwischen den Arduino-Ports und den Mikroprozessor-Pins wie folgt konfiguriert: <br><br><pre> <code class="plaintext hljs">/* Digital Pin Assignments */ #define DATA_OUT PORTL #define DATA_IN PINL #define ADDR_H PINC #define ADDR_L PINA #define ADDR ((unsigned int) (ADDR_H &lt;&lt; 8 | ADDR_L)) #define uP_RESET_N 38 #define uP_E 52 #define uP_Q 53 #define uP_RW_N 40 #define uP_FIRQ_N 41 #define uP_IRQ_N 50 #define uP_NMI_N 51 #define uP_GPIO 39</code> </pre> <br>  Wie aus den Diagrammen ersichtlich ist, ist das Signal Q relativ zu E um ein Viertel der Periode verschoben: <br><br>  Wir werden Q kaum beachten, da alle Ereignisse an E gebunden sind. Und alles passiert so: <br><br><img src="https://habrastorage.org/webt/ao/hj/qv/aohjqvkk89mbouy7_njtjqbz3ku.png"><br><br><ol><li>  E schaltet auf Null.  Der Prozessor legt eine neue Adresse auf dem Adressbus fest und √§ndert den Status der R / W-Leitung. </li><li>  E schaltet auf eins, der Prozessor wird f√ºr den Datenaustausch bereit. </li><li>  Es spielt keine Rolle, was mit dem Datenbus passiert, solange E eins ist. Hauptsache, die erforderlichen Daten sind dort vorhanden, wenn E auf Null zur√ºckkehrt. </li><li>  Beim Lesen von Daten muss das E / A-Ger√§t die erforderlichen Daten an den Datenbus liefern, bevor die Leitung E von eins nach null geht (die minimale Verz√∂gerung wird durch die Zahl 17 im Kreis angezeigt). </li><li>  Bei der Aufzeichnung muss das E / A-Ger√§t die Daten in einem Register in der Form fixieren, in der sie sich zum Zeitpunkt E von eins auf null befanden.  Der Prozessor wird diese Daten noch fr√ºher auf dem Bus bereitstellen - zum Zeitpunkt des √úbergangs von Q zu eins (die Nummer 20 im Kreis). </li><li>  Nach dem √úbergang von E zu Null wiederholt sich alles. </li></ol><br>  Alles, was oben √ºber 6502 √ºber die Notwendigkeit eines Peripherieger√§ts (einschlie√ülich eines virtuellen) gesagt wurde, um alle Signale rechtzeitig zu entwickeln, betrifft 6809. <br><br>  Erzeugung der Signale E und Q, wie im Fall von 6502, mit dem einzigen Unterschied, dass es zwei Signale gibt, und sie m√ºssen gem√§√ü den Graphen geschaltet werden.  Und genau so f√ºhrt eine bei Unterbrechung aufgerufene Unterroutine die Dateneingabe oder -ausgabe zu den erforderlichen Zeitpunkten durch. <br><br>  Der Adressraum in der unver√§nderten Skizze wird auf dieselbe Weise verteilt wie auf dem selbstgebauten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simon6809-</a> Computer: <br><br><pre> <code class="plaintext hljs">// MEMORY #define RAM_START 0x0000 #define RAM_END 0x0FFF #define ROM_START 0xE000 #define ROM_END 0xFFFF byte RAM[RAM_END-RAM_START+1]; //////////////////////////////////////////////////////////////////// // Monitor Code //////////////////////////////////////////////////////////////////// // static const unsigned char PROGMEM const unsigned char simon09_bin[] = { 0x1a, 0xff, 0x4f, 0x1f, 0x8b, 0x0f, 0x36, 0x7f, 0x01, 0xa5, 0x10, 0xce, ... 0x00, 0x09, 0x00, 0x0c, 0x00, 0x0f, 0xe0, 0x00 };</code> </pre> <br>  RAM und ROM werden auf die gleiche Weise wie in der 6502-Variante in Arrays gespeichert, mit dem einzigen Unterschied, dass es nur ein Array mit ROM-Daten gibt. <br><br>  E / A-Ger√§ten werden auch Teile des Adressraums zugewiesen, und sie k√∂nnen entweder virtuell oder real sein.  Da Simon6809 eine moderne Maschine ist, die auf einer Vintage-Elementbasis basiert, tauscht sie Daten √ºber FTDI von dem PC aus, auf dem das ‚ÄûTerminal‚Äú ausgef√ºhrt wird.  Hier wird es emuliert. <br><br>  Referenzen: <br><br>  Viele Informationen zu 6809 auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arto-Seite</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia-Artikel √ºber 6809</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SWTPc 6809-Systeme</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia-Artikel zum FLEX-Betriebssystem</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446048/">https://habr.com/ru/post/de446048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446036/index.html">Oracle Application Express. Anwendungen und Seiten</a></li>
<li><a href="../de446038/index.html">Eine kurze Anleitung zum Erstellen von Orakeln, Autog√∂ttern und Fehlern zweiter Ordnung</a></li>
<li><a href="../de446040/index.html">Full Stack Confession: Beruf, Religion, Tr√§ume</a></li>
<li><a href="../de446042/index.html">DJI Mavic 2 Pro nach sechs Monaten Gebrauch</a></li>
<li><a href="../de446046/index.html">Die Expansion des Universums ist der gr√∂√üte Irrtum in der Geschichte der Wissenschaft</a></li>
<li><a href="../de446050/index.html">Flattern. Schl√ºssel! Wof√ºr sind sie?</a></li>
<li><a href="../de446052/index.html">Erstellen Sie die Stimme und den Ton Ihres Produkts</a></li>
<li><a href="../de446054/index.html">Backup bereit: Urlaubsmythen zerst√∂ren</a></li>
<li><a href="../de446056/index.html">Eine einfache M√∂glichkeit, mit Ihrer Website zu sprechen</a></li>
<li><a href="../de446058/index.html">So erstellen Sie SDN - Acht Open Source-Tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>