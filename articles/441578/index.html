<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌 👩‍🌾 👼🏼 Tutorial de React Parte 19: Métodos del ciclo de vida de los componentes 🤚 👩🏿‍🔧 👩🏿‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la parte de hoy de la traducción del tutorial React, se le presentará una descripción general de los métodos del ciclo de vida de los componentes. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tutorial de React Parte 19: Métodos del ciclo de vida de los componentes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441578/">  En la parte de hoy de la traducción del tutorial React, se le presentará una descripción general de los métodos del ciclo de vida de los componentes. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/kv/3m/yg/kv3mygzwigixivdzbagb80fvlvi.png" alt="imagen"></a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1: descripción general del curso, razones de la popularidad de React, ReactDOM y JSX</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2: componentes funcionales</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3: archivos de componentes, estructura del proyecto</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4: componentes principales y secundarios</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 5: inicio del trabajo en una aplicación TODO, los fundamentos del estilo</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 6: sobre algunas características del curso, JSX y JavaScript</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 7: estilos en línea</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 8: trabajo continuo en la aplicación TODO, familiaridad con las propiedades de los componentes</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 9: propiedades del componente</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 10: Taller sobre trabajo con propiedades de componentes y estilo</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 11: generación de marcado dinámico y método de matrices de mapas</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 12: taller, tercera etapa de trabajo en una aplicación TODO</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 13: componentes basados ​​en clases</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 14: taller sobre componentes basados ​​en la clase, estado de los componentes.</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 15: talleres de componentes de salud</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 16: la cuarta etapa de trabajo en una aplicación TODO, manejo de eventos</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 17: quinta etapa de trabajo en una aplicación TODO, modificando el estado de los componentes</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 18: la sexta etapa de trabajo en una aplicación TODO</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 19: métodos del ciclo de vida de los componentes.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 20: la primera lección de representación condicional</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 21: segunda lección y taller sobre representación condicional</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 22: la séptima etapa de trabajo en una aplicación TODO, descargando datos de fuentes externas</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 23: primera lección sobre trabajar con formularios</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 24: Segunda lección de formularios</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 25: Taller sobre trabajo con formularios</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 26: arquitectura de la aplicación, patrón de contenedor / componente</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 27: proyecto del curso</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Lección 34. Métodos del ciclo de vida de los componentes, parte 1</font> </h2><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Original</a> <br><br>  Una de las características del desarrollo de aplicaciones React es el hecho de que escribimos un código JavaScript bastante simple que impulsa los mecanismos internos de React y, por lo tanto, nos brinda grandes oportunidades para desarrollar interfaces de aplicaciones y trabajar con datos.  Al mismo tiempo, los componentes que utilizamos durante su ciclo de vida pasan por ciertas etapas.  A menudo, lo que le sucede a un componente en una aplicación se compara con la vida de una persona.  Las personas nacen, viven, en su vida ocurren algunos eventos importantes, después de los cuales mueren.  Los componentes de React en esto son similares a las personas, ya que también son "nacidos", "vivos" y "muertos".  Cuando trabajamos con componentes, podemos responder a lo que les sucede, gracias a los métodos de su ciclo de vida que se invocan en momentos especiales de su "vida". <br><br>  Recientemente, el equipo de desarrollo de React ha desactualizado los métodos de ciclo de vida de tres componentes.  Sin embargo, consideraremos estos métodos, ya que todavía se pueden usar, y dado que se pueden encontrar en el código existente.  Además, se agregaron dos nuevos métodos de ciclo de vida de componentes a React, que discutiremos en la próxima lección. <br><br>  Consideraremos solo los métodos más importantes que sean más relevantes para aquellos que acaban de comenzar a estudiar React.  Cuando continúe dominando esta biblioteca, podrá experimentar con otros métodos. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aquí hay</a> un buen material sobre los métodos del ciclo de vida de los componentes de React que eran relevantes antes de React 16.3.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aquí</a> , en una publicación del blog oficial de desarrolladores de React, puede conocer los cambios que se han producido en React 16.3. <br><br>  Ahora, comencemos la discusión sobre los métodos del ciclo de vida de los componentes React que encontrará con más frecuencia. <br><br>  Usaremos, como siempre, el proyecto de demostración aquí.  En este caso, comenzamos con un proyecto estándar creado usando create-react-app, en el archivo <code>App.js</code> que contiene el siguiente código: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>()       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}   }     render() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (           <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">               Code goes here           </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>       )   } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> App</code> </pre> <br>  Para comenzar, echemos un vistazo al método que ya ha utilizado con componentes basados ​​en clases.  Este es el método <code>render()</code> . <br><br>  A menudo, no se le menciona cuando habla sobre los métodos del ciclo de vida del componente.  Creo que este método, cuando se compara un componente con una persona, se puede comparar con vestirse antes de salir.  El objetivo de este método es determinar qué se mostrará en la pantalla, es decir, cómo se verá el componente.  El método <code>render()</code> se puede llamar varias veces durante la vida útil de un componente.  Entonces, cuando React determina que algo relacionado con un componente ha cambiado, como un estado o propiedades, es decir, algo que puede afectar la apariencia de un componente, React puede llamar a este método.  Esto se puede comparar, si continuamos la analogía con las personas, para que una persona pueda decidir cambiarse de ropa.  Por ejemplo, para, después de un día de trabajo, prepararse para algún tipo de evento de vacaciones. <br><br>  Ahora echemos un vistazo a otro método del ciclo de vida del <code>componentDidMount()</code> : <code>componentDidMount()</code> .  Este método se declara, al igual que cualquier otro método de componente basado en clases, en el cuerpo de una clase de componente: <br><br><pre> <code class="javascript hljs">componentDidMount() { }</code> </pre> <br>  Este método se llama en el momento del ciclo de vida del componente, que se puede comparar con el "nacimiento" de este componente.  Este método se activa una vez que el componente está montado (insertado) en el árbol DOM.  En este caso, por ejemplo, si después de cambiar algunos datos que afectan la apariencia del componente, se volverá a representar, no se llamará al método <code>componentDidMount()</code> .  Esto sucede debido al hecho de que al realizar tales operaciones, el componente no se elimina del árbol DOM y luego se vuelve a incluir en el árbol. <br><br>  El método <code>componentDidMount()</code> se usa generalmente para realizar llamadas a ciertas API en casos en los que el desarrollador necesita datos de fuentes externas.  Supongamos que el componente que estamos considerando aquí en realidad se llama <code>TodoList</code> y es un componente que forma una lista de tareas en una aplicación Todo.  El método <code>componentDidMount()</code> de dicho componente puede cargar materiales de la base de datos del servidor que son necesarios para la visualización correcta de la lista de tareas almacenada en el servidor.  Como resultado, una vez completada la instalación del componente, nosotros, en el método <code>componentDidMount()</code> , podemos cargar los datos necesarios para que el componente se muestre correctamente en la página.  También hablaremos sobre la carga de datos que necesitan los componentes, pero por ahora puede recordar que este es el caso de uso más común para <code>componentDidMount()</code> . <br><br>  El siguiente método de ciclo de vida del componente que discutimos se llama <code>componentWillReceiveProps()</code> .  Este método se puede comparar con lo que sucede cuando alguien recibe un regalo de alguien.  Entonces, un componente puede recibir propiedades de un componente padre.  Cada vez que un componente toma propiedades, se llama a este método.  Al mismo tiempo, este método se llama cada vez que el componente primario pasa las propiedades al componente secundario, y no solo cuando esto ocurre por primera vez.  Por ejemplo, si el componente primario decide cambiar las propiedades pasadas al componente secundario, entonces, en el método <code>componentWillReceiveProps()</code> , podemos, por ejemplo, verificar si las nuevas propiedades difieren de las que ya se pasaron al componente.  El hecho es que si las nuevas propiedades no difieren de las antiguas, esto significa que su recibo no cambia nada, lo que significa que, después de descubrirlo, no podemos hacer nada más.  Si las nuevas propiedades son diferentes de las antiguas, podemos realizar ciertas acciones.  Normalmente, este método se declara en el cuerpo de la clase de componente de la siguiente manera: <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps) { }</code> </pre> <br>  Aquí generalmente se usa, como el nombre del parámetro, <code>nextProps</code> , pero puede nombrar este parámetro como desee.  Para comparar algunas propiedades específicas que ya se han transferido al componente con lo que ya se le pasó anteriormente, y decidir sobre otras acciones, puede utilizar esta construcción: <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextProps.whatever !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.whatever) {       <span class="hljs-comment"><span class="hljs-comment">//   -    } }</span></span></code> </pre> <br>  Por lo general, este método se usa de esa manera. <br><br>  Sin embargo, como ya se mencionó, después del lanzamiento de React 16.3, algunos métodos del ciclo de vida del componente quedaron en desuso, y <code>componentWillReceiveProps()</code> es uno de esos métodos. <br><br>  Hasta la Reacción 17, estos métodos heredados todavía se pueden usar, aunque es mejor no hacerlo.  Si no puede prescindir del método en cuestión, debe llamarlo <code>UNSAFE_componentWillReceiveProps()</code> .  Después de React 17, el nombre del método <code>componentWillReceiveProps()</code> no significará nada especial. <br><br>  Es útil conocer este método para poder comprender el código desactualizado, pero no se utilizará en el desarrollo de las aplicaciones modernas de React. <br><br>  Otro método interesante del ciclo de vida del componente se llama <code>shouldComponentUpdate()</code> .  Él, si continuamos comparando el componente con una persona, recuerda el momento en que una persona está pensando si necesita cambiarse de ropa o no.  En condiciones normales, si React no está muy seguro de volver a representar un componente, lo hará por si acaso.  No importa si esto es necesario, de acuerdo con la lógica de la aplicación, o no. <br><br>  Esto hace que React vuelva a representar los componentes, incluso cuando nada relacionado con el componente cambia.  Esto puede ralentizar la aplicación, porque según este principio, React procesa todos los componentes que componen la aplicación.  El método <code>shouldComponentUpdate()</code> permite al desarrollador optimizar la aplicación.  Aquí puede implementar alguna lógica que ayude a descubrir la necesidad de actualizar el componente.  Este método generalmente se declara así: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) {   <span class="hljs-comment"><span class="hljs-comment">//  true        //  false    }</span></span></code> </pre> <br>  Además, a partir de este método, si el componente necesita una nueva representación, teniendo en cuenta las nuevas propiedades y el estado, debe devolver <code>true</code> .  De lo contrario, debe devolverse <code>false</code> .  En realidad, devolver <code>false</code> de este método lleva al hecho de que el componente no se actualiza y la aplicación se ejecuta más rápido, pero al hacerlo, debe asegurarse de que el componente realmente no necesita volver a procesarse.  Si el componente necesita ser actualizado, y este método devuelve <code>false</code> , esto conducirá a errores que serán difíciles de manejar. <br><br>  Otro método de ciclo de vida del componente del que hablaremos se llama <code>componentWillUnmount()</code> .  Este método marca el final de la "vida" del componente: el momento en que se elimina del árbol DOM y desaparece de la pantalla. <br><br>  Este método se utiliza principalmente para liberar recursos ocupados por un componente y poner las cosas en orden antes de eliminarlo.  Por ejemplo, si en el método <code>componentDidMount()</code> se configuró algo así como un detector de eventos, debido a que, cuando el usuario desplaza la página, se ejecuta algún código, es en <code>componentWillUnmount()</code> puede eliminar dicho detector de eventos.  De hecho, este método tiene muchas aplicaciones que tienen como objetivo eliminar de la aplicación todo lo que resulta innecesario después de que el componente desaparece. <br><br>  Aquí está el código completo de nuestro componente de <code>App</code> , en el que se agregan métodos de ciclo de vida: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>()       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}   }     componentDidMount() {       <span class="hljs-comment"><span class="hljs-comment">//  ,        }     componentWillReceiveProps(nextProps) {       if (nextProps.whatever !== this.props.whatever) {           //   -        }   }     shouldComponentUpdate(nextProps, nextState) {       //  true            //  false      }     componentWillUnmount() {       //            // ( -   )   }     render() {       return (           &lt;div&gt;               Code goes here           &lt;/div&gt;       )   } } export default App</span></span></code> </pre> <br>  Esto concluye esta lección, aunque debe tenerse en cuenta que los métodos del ciclo de vida de los componentes React no se limitan a los que revisamos hoy. <br><br><h2>  <font color="#3AC1EF">Lección 35. Métodos del ciclo de vida de los componentes, parte 2</font> </h2><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Original</a> <br><br>  Como ya se mencionó en la lección anterior, cuando salió React 16.3, se informó que los métodos de ciclo de vida de los tres componentes estaban desactualizados.  Estos métodos son <code>componentWillMount()</code> , <code>componentWillReceiveProps()</code> y <code>componentWillUpdate()</code> .  También se informaron dos nuevos métodos.  Este es el <code>getDerivedStateFromProps()</code> estático <code>getDerivedStateFromProps()</code> y el método <code>getSnapshotBeforeUpdate()</code> .  No se puede decir que estos métodos jugarán un papel importante en futuras clases de este curso, pero a pesar de esto, los conoceremos aquí. <br><br>  Experimentaremos en el mismo proyecto que utilizamos la última vez. <br><br>  <code>getDerivedStateFromProps()</code> es como se ve la declaración del método <code>getDerivedStateFromProps()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> getDerivedStateFromProps(props, state) { }</code> </pre> <br>  Tenga en cuenta la <code>static</code> antes del nombre del método.  Él, sobre la base de las propiedades aceptadas por él, debe devolver un estado actualizado.  Se utiliza en aquellos casos en que un determinado componente debe aceptar las propiedades entrantes que recibe del componente principal y configurar su estado en función de estas propiedades.  Los detalles sobre este método se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  Este material, publicado en el blog React, dice que el uso de este método está lejos de estar justificado en todas aquellas situaciones en las que parece ser útil.  Su uso incorrecto puede conducir a varios errores, a una caída en el rendimiento de la aplicación, así que úselo con precaución.  No debe intentar resolver problemas con su ayuda, para cuya solución no está destinada.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aquí está la</a> documentación para este método. <br><br>  Ahora hablemos sobre el método <code>getSnapshotBeforeUpdate()</code> .  Así es como se ve su declaración en el cuerpo de la clase: <br><br><pre> <code class="javascript hljs">getSnapshotBeforeUpdate() { }</code> </pre> <br>  Se puede considerar como un método de ciclo de vida, que le permite crear algo así como una copia de seguridad de lo que hay en el componente antes de actualizarlo.  Se asemeja a una instantánea del estado de una aplicación.  Cabe señalar que los desarrolladores de React dicen que el alcance de este método es limitado.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aquí está la</a> documentación para ello. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Hoy hablamos sobre los métodos del ciclo de vida de los componentes.  Cuando avance en el desarrollo de aplicaciones React, sin duda serán útiles.  En las siguientes clases de este curso, nos encontraremos con estos métodos, en particular, con <code>componentDidMount()</code> .  La próxima vez hablaremos sobre renderizado condicional. <br><br>  <b>Estimados lectores!</b>  Si está desarrollando profesionalmente aplicaciones React, cuéntenos cómo utiliza los métodos de ciclo de vida de los componentes. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441578/">https://habr.com/ru/post/441578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441568/index.html">Gestión de memoria Python</a></li>
<li><a href="../441570/index.html">El resumen de materiales frescos del mundo del front-end para la última semana No. 353 (del 17 al 24 de febrero de 2019)</a></li>
<li><a href="../441572/index.html">Frontend Weekly Digest (18-24 de febrero de 2019)</a></li>
<li><a href="../441574/index.html">Learning Docker Parte 6: Trabajar con datos</a></li>
<li><a href="../441576/index.html">Redes de Kubernetes: Pods</a></li>
<li><a href="../441580/index.html">Tutorial React Parte 20: primera lección de renderizado condicional</a></li>
<li><a href="../441582/index.html">Optimización del sistema de control LQR</a></li>
<li><a href="../441584/index.html">PHP Digest No. 150 (del 11 al 25 de febrero de 2019)</a></li>
<li><a href="../441586/index.html">Cómo recomendar música que casi nadie escuchó. Informe Yandex</a></li>
<li><a href="../441590/index.html">La evolución de la interacción del clúster. Cómo implementamos ActiveMQ y Hazelcast</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>