<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍍 ⚜️ ♒️ Cómo se representa el marco de Rise of the Tomb Raider 😍 🔗 🤬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rise of the Tomb Raider (2015) es la secuela del excelente reinicio de Tomb Raider (2013). Personalmente, encuentro ambas partes interesantes porque s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo se representa el marco de Rise of the Tomb Raider</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436500/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1k/5p/s6/1k5ps6qnv2soku_ymxsemz7wnxa.gif"></div><br>  Rise of the Tomb Raider (2015) es la secuela del excelente reinicio de Tomb Raider (2013).  Personalmente, encuentro ambas partes interesantes porque se alejaron de la serie original estancada y volvieron a contar la historia de Lara.  En este juego, como en la precuela, el lugar central está ocupado por la trama, proporciona una mecánica fascinante de elaboración, caza y escalada / investigación. <br><br>  Tomb Raider usó Crystal Engine, desarrollado por Crystal Dynamics, también usado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Deus Ex: Human Revolution</a> .  La secuela utilizó un nuevo motor llamado Foundation, desarrollado previamente para Lara Croft y el Templo de Osiris (2014).  Su representación generalmente se puede describir como un motor de mosaico con un pase de iluminación preliminar, y luego descubriremos lo que esto significa.  El motor le permite elegir entre los renderizadores DX11 y DX12;  Elegí este último, por las razones que discutimos a continuación.  Para capturar el marco, se utilizó <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Renderdoc</a> 1.2 en la Geforce 980 Ti, el juego incluye todas las funciones y decoraciones. <br><br><h2>  Marco analizado </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/254/df9/0bb/254df90bbbfd5498710f37624e12d1f4.jpg"></div><br>  Para evitar spoilers, diré que en este marco los malos están persiguiendo a Lara, porque ella está buscando un artefacto que están buscando.  Este conflicto de intereses no puede resolverse sin armas.  Lara se coló en la base enemiga por la noche.  Elegí un marco con iluminación atmosférica y de contraste, en el que el motor puede mostrarse. <a name="habracut"></a><br><br><h4>  Profundidad de avance </h4><br>  Aquí, se realiza la optimización habitual para muchos juegos: un pequeño paso preliminar de la profundidad (aproximadamente 100 llamadas de sorteo).  El juego representa los objetos más grandes (y no los que ocupan más espacio en la pantalla) para aprovechar las características del procesador de video Early-Z.  Lea más sobre esto en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un artículo de Intel</a> .  En resumen, las GPU pueden evitar ejecutar un sombreador de píxeles si pueden determinar que se superpone con el píxel anterior.  Este es un pasaje de bastante bajo costo, que llena previamente el búfer Z con valores de profundidad. <br><br>  En este punto, descubrí una técnica interesante de nivel de detalle (LOD) llamada "fizzle" o "tablero de ajedrez".  Esta es una forma común de mostrar u ocultar gradualmente objetos a distancia, para que luego puedan reemplazarse con una malla de menor calidad u ocultarlos por completo.  Mira este camión.  Parece que está renderizando dos veces, pero de hecho está renderizando con un LOD alto y un LOD bajo en la misma posición.  Cada uno de los niveles representa aquellos píxeles que el otro no renderizó.  El primer LOD tiene 182,226 vértices, y el segundo LOD tiene 47,250. A gran distancia son indistinguibles, pero uno de ellos es tres veces menos costoso.  En este marco, LOD 0 casi desaparece y LOD 1 se renderiza casi por completo.  Después de la desaparición completa de LOD 0, solo se representará LOD 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/d8d/24e/c31d8d24e58229c27fb4edf6f635974d.png"></div><br>  <i>LOD 0</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bf/3b4/5bb/7bf3b45bbe13521b4bae010f72a702a7.png"></div><br>  <i>LOD 1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jy/7r/it/jy7rit_bwqm4n0lwpzzlydyx5rs.gif"></div><br>  La textura pseudoaleatoria y el coeficiente de probabilidad nos permite descartar píxeles que no han pasado el valor umbral.  Esta textura se usa en ROTR.  Uno puede preguntarse por qué no se usa la mezcla alfa.  La mezcla alfa tiene muchos inconvenientes en comparación con el desvanecimiento por fizzle. <br><br><ol><li>  <strong>Conveniencia para el pasaje preliminar de las profundidades:</strong> gracias a la representación de un objeto opaco con agujeros hechos en él, podemos renderizar en el pasaje preliminar y usar temprano-z.  Los objetos con mezcla alfa en una etapa tan temprana no se procesarán en el búfer de profundidad debido a problemas de clasificación. </li><li>  <strong>La necesidad de sombreadores adicionales</strong> : si se usa un renderizador diferido, el sombreador de los objetos opacos no contiene ninguna iluminación.  Si necesita reemplazar un objeto opaco por uno transparente, entonces necesita una opción separada en la que haya iluminación.  Además de aumentar la cantidad de memoria necesaria y la complejidad debido a al menos un sombreador adicional para todos los objetos opacos, deben ser precisos para evitar que los objetos avancen.  Esto es complicado por muchas razones, pero todo se reduce al hecho de que el renderizado ahora se realiza en una ruta de código diferente. </li><li>  <strong>Redibujos más grandes</strong> : la combinación alfa puede crear redibujos grandes, y con un cierto nivel de complejidad de los objetos, puede ser necesaria una gran fracción del ancho de banda para sombrear el LOD. </li><li>  <strong>Conflictos Z</strong> : los <strong>conflictos</strong> z son un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">efecto de parpadeo</a> cuando dos polígonos se representan a una profundidad muy cercana entre sí.  En este caso, la inexactitud de los cálculos de coma flotante obliga a que se procesen a su vez.  Si renderizamos dos LOD consecutivos, ocultando gradualmente uno y mostrando el segundo, entonces pueden causar un conflicto z, porque están muy cerca el uno del otro.  Siempre hay formas de evitar esto, por ejemplo, prefiriendo un polígono a otro, pero este sistema es complejo. </li><li>  <strong>Efectos de Z-Buffer</strong> : Muchos efectos como SSAO usan solo el buffer de profundidad.  Si renderizamos objetos transparentes al final de la tubería cuando la oclusión ambiental ya se completó, no podríamos tenerlo en cuenta. </li></ol><br>  La desventaja de esta técnica es que se ve peor que la mezcla alfa, pero un buen patrón de ruido, desenfoque después de la efervescencia o anti-aliasing temporal puede ocultarlo casi por completo.  En este sentido, ROTR no hace nada particularmente inusual. <br><br><h4>  Pase normal </h4><br>  Crystal Dynamics utiliza un patrón de iluminación bastante inusual en sus juegos, que cubriremos en el pasillo de iluminación.  Por ahora, basta con decir que el motor no tiene un pase G-buffer;  al menos en la medida en que es familiar en otros juegos.  En este pasaje, los objetos transmiten solo información sobre la profundidad y las normales a la salida.  Las normales se registran en el destino de representación del formato RGBA16_SNORM en el espacio mundial.  Es curioso que este motor utilice el esquema Z-up, no el Y-up (el eje Z se dirige hacia arriba, no el eje Y), que se usa con mayor frecuencia en otros motores / paquetes de modelado.  El canal alfa contiene brillo, que luego se desempaqueta como <code>exp2(glossiness * 12 + 1.0)</code> .  El valor de brillo también puede ser negativo, porque el signo se usa como una bandera que indica si la superficie es metálica.  Esto se puede notar por sí solo, porque todos los colores oscuros en el canal alfa están relacionados con objetos metálicos. <br><br><table><tbody><tr><td>  <strong><font color="#ff0000">R</font></strong> </td><td>  <strong><font color="#00ff00">G</font></strong> </td><td>  <strong><font color="0000ff">B</font></strong> </td><td></td></tr><tr><td>  <strong>Normal.x</strong> </td><td>  <strong>Normal.y</strong> </td><td>  <strong>Normal.z</strong> </td><td>  <b>Brillo + Metalidad</b> </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e8/209/484/1e8209484fe730d178c4afffef4c8f93.jpg"></div><br>  <i>Normal</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/dd3/b2d/8fbdd3b2d2ddbce3111a4c017e7daef3.jpg"></div><br>  <i>Brillo / metalidad</i> <br><br>  <strong>Ventajas de la partida</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/b15/52b/aa1b1552b0f81c2122d094441e531f3f.jpg"></div><br>  ¿Recuerda que en la sección "Profundidad preliminar", hablamos sobre el ahorro de costos de píxeles?  Volveré un poco para ilustrarlo.  Toma la siguiente imagen.  Esto representa la parte detallada de la montaña en el búfer normal.  Renderdoc resaltó amablemente los píxeles que pasaron la prueba de profundidad con verde, y los que no la pasaron con rojo (no se mostrarán).  El número total de píxeles que se representarían sin este pase preliminar es aproximadamente igual a 104518 (calculado en Photoshop).  El número total de píxeles que realmente se representan es 23858 (calculado por Renderdoc).  ¡Ahorre alrededor del 77%!  Como vemos, con un uso inteligente, este pase preliminar puede dar una gran ganancia, y solo requiere alrededor de cien llamadas de extracción. <br><br>  <strong>Grabar comandos multiproceso</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/919/5d0/623/9195d06236fd6247cea6e6065f05e9e8.png"></div><br>  Vale la pena señalar un aspecto interesante, por lo que elegí el renderizador DX12: grabar comandos de subprocesos múltiples.  En API anteriores, como DX11, la representación generalmente se realiza en un solo hilo.  El controlador de gráficos recibió comandos de representación del juego y transmitió constantemente solicitudes de GPU, pero el juego no sabía cuándo ocurriría esto.  Esto conduce a la ineficiencia, porque el controlador debe de alguna manera adivinar lo que la aplicación está tratando de hacer, y no escala a múltiples hilos.  Las API más nuevas, como DX12, transfieren el control a un desarrollador que puede decidir cómo escribir comandos y cuándo enviarlos.  Aunque Renderdoc no puede mostrar cómo se realiza la grabación, verá que hay siete pases de color marcados como Color Pass N, y cada uno de ellos está envuelto en un par de ExecuteCommandList: Reset / Close.  Marca el comienzo y el final de la lista de comandos.  La lista representa aproximadamente 100-200 llamadas de sorteo.  Esto no significa que fueron grabados usando varias transmisiones, pero lo insinúa. <br><br>  <strong>Huellas en la nieve</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca6/d21/2e8/ca6d212e89b61f52738dfbd01363e366.jpg"></div><br>  Si miras a Lara, puedes ver que cuando se mueve frente a la captura de pantalla, deja huellas en la nieve.  En cada cuadro, se ejecuta un sombreador de cálculo, que registra las deformaciones en ciertas áreas y las aplica en función del tipo y la altura de la superficie.  Aquí, solo se aplica el mapa normal a la nieve (es decir, la geometría no cambia), pero en algunas áreas donde la nieve es más gruesa, la deformación se lleva a cabo.  También puedes ver cómo la nieve "cae" en su lugar y llena las huellas dejadas por Lara.  Esta técnica se describe con mucho más detalle en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GPU Pro 7</a> .  La textura de urdimbre de nieve es un tipo de mapa de elevación que rastrea los movimientos de Lara y se pega alrededor de los bordes para que el sombreador de muestreo pueda aprovechar este plegado. <br><br><h4>  Atlas de sombras </h4><br>  Al crear mapeo de sombras, se utiliza un enfoque bastante común: empacar tantas tarjetas de sombras como sea posible en una textura de sombra común.  Tal atlas de sombras es en realidad una gran textura de 16 bits con un tamaño de 16384 × 8196.  Esto le permite reutilizar y escalar de manera muy flexible los mapas de sombras en el atlas.  En el marco que estamos analizando, se registran 8 mapas de sombras en el atlas.  Cuatro de ellos se relacionan con la fuente principal de iluminación direccional (la luna, porque sucede en la noche), porque usan mapas de sombras en cascada, una técnica bastante estándar de sombras de larga distancia para iluminación direccional, que ya expliqué un poco <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">antes</a> .  Más interesante aún, varias fuentes de proyección y foco también se incluyen en la captura de este marco.  El hecho de que se graben 8 mapas de sombras en este marco no significa que solo haya 8 fuentes de iluminación de sombras proyectadas en él.  El juego puede almacenar en caché los cálculos de sombras, es decir, la iluminación que no ha cambiado ni la posición de la fuente ni la geometría del alcance no debe actualizar su mapa de sombras. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/8d9/169/f008d9169bd3490c26f923bcc4ea8e85.jpg"></div><br>  Parece que la representación de mapas de sombras también se beneficia al escribir comandos de subprocesos múltiples en la lista, y en este caso, se escribieron hasta 19 listas de comandos para representar mapas de sombras. <br><br>  <strong>Sombras de la iluminación direccional.</strong> <br><br>  Las sombras de la iluminación direccional se calculan antes del paso de la iluminación y luego se muestrean.  No sé qué pasaría si hubiera varias fuentes de iluminación direccional en la escena. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/209/845/cef209845628db5e68588f07880542eb.jpg"></div><br><h4>  Oclusión ambiental </h4><br>  Para la oclusión ambiental, ROTR le permite usar HBAO o una variante de HBAO + (esta técnica fue publicada originalmente por NVIDIA).  Hay varias variaciones de este algoritmo, por lo que consideraré el que encontré en ROTR.  Primero, el búfer de profundidad se divide en 16 texturas, cada una de las cuales contiene 1/16 de todos los valores de profundidad.  La separación se realiza de tal manera que cada textura contiene un valor de un bloque 4 × 4 de la textura original que se muestra en la figura a continuación.  La primera textura contiene todos los valores marcados en rojo (1), la segunda contiene los valores marcados en azul (2), y así sucesivamente.  Si desea saber más sobre esta técnica, aquí hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un artículo de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Louis Bavoil</a> , quien también fue uno de los autores del artículo sobre HBAO. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c9/2dc/60f/1c92dc60fe369caed766efe18dd2739d.png"></div><br>  El siguiente paso calcula la oclusión ambiental para cada textura, lo que nos da 16 texturas AO.  Se genera una oclusión ambiental de la siguiente manera: el tampón de profundidad se muestrea varias veces, recreando la posición y acumulando el resultado del cálculo para cada una de las muestras.  Cada textura de oclusión ambiental se calcula utilizando diferentes coordenadas de muestreo, es decir, en un bloque de 4x4 píxeles, cada píxel cuenta su propia parte de la historia.  Esto se hace por razones de rendimiento.  Cada píxel ya muestrea el búfer de profundidad 32 veces, y el efecto completo requerirá 16 × 32 = 512 muestras, lo que es un fracaso incluso para las GPU más potentes.  Luego se recombinan en una textura de pantalla completa, que resulta ser bastante ruidosa, por lo que para suavizar los resultados justo después de eso, se realiza un pase de desenfoque de pantalla completa.  Vimos una solución muy similar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Shadow of Mordor</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25f/e57/dd8/25fe57dd8001f561e9a971b36b57085e.png" alt="imagen"></div><br>  <i>Piezas HBAO</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/113/e1b/7d0/113e1b7d065a25b8f4dfb8dce29c808c.png" alt="imagen"></div><br>  <i>HBAO completo con ruido</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/063/bfe/cd1/063bfecd15cdf8d62a0b6221fddfe4ee.png" alt="imagen"></div><br>  <i>Desenfoque horizontal completo HBAO</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/af9/8e2/51daf98e295b549a57089b4d17df1975.png" alt="imagen"></div><br>  <i>Listo HBAO</i> <br><br><h4>  Pre-pase de iluminación en mosaico </h4><br>  Light Prepass es una técnica bastante inusual.  La mayoría de los equipos de desarrollo usan una combinación de cálculo de iluminación diferida + directa (con variaciones, por ejemplo, con mosaico, agrupación) o completamente directa para algunos efectos del espacio de la pantalla.  La técnica de pre-iluminación es tan inusual que merece una explicación.  Si el concepto de iluminación tradicional retrasada es separar las propiedades de los materiales de la iluminación, entonces la idea de separar la iluminación de las propiedades de los materiales es la piedra angular del paso preliminar de la iluminación.  Aunque esta redacción parece un poco tonta, la diferencia con la iluminación diferida tradicional es que almacenamos todas las propiedades del material (como albedo, color especular, rugosidad, metalidad, microoclusión, emisivo) en un enorme G-buffer, y lo usamos más tarde como datos de entrada para pases de iluminación posteriores.  La iluminación diferida tradicional puede presentar una gran carga en el rendimiento;  cuanto más complejos son los materiales, más información y operaciones se necesitan en el G-buffer.  Sin embargo, en el pase de iluminación preliminar, primero acumulamos toda la iluminación por separado, utilizando la cantidad mínima de datos, y luego los aplicamos en pases posteriores a los materiales.  En este caso, la iluminación es suficiente solo para condiciones normales, aspereza y metalidad.  Los sombreadores (aquí se usan dos pases) generan datos en tres formatos de renderizado RGBA16F.  Uno contiene iluminación difusa, el segundo contiene iluminación especular y el tercero contiene iluminación ambiental.  En este punto, todos los datos sombra se tienen en cuenta.  Es curioso que en el primer paso (iluminación difusa + espejo) para un pase de pantalla completa, se use un cuadrángulo de dos triángulos, y en otros efectos, se usa un triángulo de pantalla completa (por qué esto es importante, puede averiguarlo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> ).  Desde este punto de vista, todo el marco no es integral. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41d/6ba/a3b/41d6baa3b45cc3e0df1423eaf015d416.jpg" alt="imagen"></div><br>  <i>Iluminación difusa</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cd/0c5/137/9cd0c513782787daa220b7627b11b28e.jpg" alt="imagen"></div><br>  <i>Iluminación del espejo</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33d/ed9/cbc/33ded9cbc62470319b7729b542b7e830.jpg" alt="imagen"></div><br>  <i>Iluminación ambiental</i> <br><br>  <strong>Optimización de azulejos</strong> <br><br>  La iluminación de azulejos es una técnica de optimización diseñada para representar una gran cantidad de fuentes de luz.  ROTR divide la pantalla en mosaicos de 16 × 16, y luego guarda información sobre qué fuentes se cruzan con cada mosaico, es decir, los cálculos de iluminación se realizarán solo para aquellas fuentes relacionadas con los mosaicos.  Al comienzo del marco, se inicia una secuencia de sombreadores computacionales, que determinan qué fuentes se relacionan con los mosaicos.  En la etapa de iluminación, cada píxel determina en qué mosaico se encuentra y recorre cada fuente de luz en el mosaico, realizando todos los cálculos de iluminación.  Si las fuentes están vinculadas a los mosaicos de manera eficiente, puede ahorrar una gran cantidad de cómputo y la mayor parte del ancho de banda, así como aumentar la productividad. <br><br>  <strong>Zoom de profundidad</strong> <br><br>  El muestreo ascendente basado en profundidad es una técnica interesante útil en este y pases posteriores.  A veces, los algoritmos computacionalmente caros no se pueden representar a resolución completa, por lo que se representan a una resolución más baja y luego se amplían.  En nuestro caso, la iluminación ambiental se calcula en la mitad de la resolución, es decir, después de los cálculos, la iluminación debe recrearse correctamente.  En la forma más simple, se toman 4 píxeles de baja resolución y se interpolan para obtener algo parecido a la imagen original.  Esto funciona para transiciones suaves, pero no se ve bien en las discontinuidades, porque allí mezclamos valores no relacionados que pueden ser adyacentes en el espacio de la pantalla, pero distantes entre sí en el espacio mundial.  En soluciones a este problema, generalmente se toman varias muestras de búfer de profundidad y se comparan con la muestra de profundidad que queremos recrear.  Si la muestra está demasiado lejos, entonces no la tenemos en cuenta al reconstruir.  Tal esquema funciona bien, pero significa que el sombreador de recreación requiere mucho ancho de banda. <br><br>  ROTR hace un movimiento complicado con el descarte temprano de la plantilla.  Después de pasar las normales, el búfer de profundidad está completamente lleno, por lo que el motor realiza un pase de pantalla completa, marcando todos los píxeles interrumpidos en el búfer de plantilla.  Cuando llega el momento de recrear el búfer de iluminación ambiental, el motor usa dos sombreadores: uno es muy simple para áreas sin espacios de profundidad, el otro es más complejo para píxeles con espacios.  La plantilla temprana descarta píxeles si no pertenecen a la región correspondiente, es decir, solo hay costos en las regiones necesarias.  Las siguientes imágenes son mucho más claras: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/747/912/729/747912729abfecffd281c72e8ca4e258.jpg" alt="imagen"></div><br>  <i>Iluminación ambiental de media resolución</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0d/e46/b7e/f0de46b7e19ace552377d1a39d86ed22.png" alt="imagen"></div><br>  <i>Escalando las profundidades del interior</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d64/354/63b/d6435463b209e7361831b279abcf1ae1.jpg" alt="imagen"></div><br>  <i>Iluminación ambiental de resolución completa, sin costillas</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/e12/702/db5e1270220121c5ca9c2a9277d519ed.png" alt="imagen"></div><br>  <i>Escalando las profundidades de las costillas</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/971/5cf/3ea9715cf0c57785d926b0711808b256.jpg" alt="imagen"></div><br>  <i>Listo iluminación ambiental</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a5/5d2/128/4a55d2128ab191fb120ca3c1c4310c95.jpg" alt="imagen"></div><br>  <i>Vista de media resolución</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd4/eaa/a07/cd4eaaa0719a527bcdd1add09f00597b.jpg" alt="imagen"></div><br>  <i>Una vista de primer plano de la imagen recreada</i> <br><br>  Después del paso preliminar de la iluminación, la geometría se transfiere al transportador, solo que esta vez cada objeto muestra texturas de iluminación, textura de oclusión ambiental y otras propiedades de materiales que no escribimos en el G-buffer desde el principio.  Esto es bueno, porque el ancho de banda se guarda en gran medida aquí debido al hecho de que no es necesario leer un montón de texturas para escribirlas en un gran G-buffer, y luego leerlas / decodificarlas nuevamente.  El inconveniente obvio de este enfoque es que toda la geometría necesita retransmitirse, y la textura del paso preliminar de la iluminación en sí misma representa una gran carga en el rendimiento.  Me preguntaba por qué no usar un formato más ligero, por ejemplo R11G11B10F, para las texturas preliminares del pase de iluminación, pero hay información adicional en el canal alfa, por lo que esto sería imposible.  Sea como fuere, esta es una solución técnica interesante.  En este punto, toda la geometría opaca ya está renderizada y encendida.  Tenga en cuenta que incluye objetos emisores de luz, como el cielo y la pantalla del portátil. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2eb/3cb/0a3/2eb3cb0a3f58c521079fc2bbd1b3fd67.jpg"></div><br><h4>  Reflexiones </h4><br>  Esta escena no es un buen ejemplo para demostrar reflexiones, así que elegí otra.  El sombreador de reflejos es una combinación bastante complicada de ciclos que se puede reducir a dos partes: uno muestra mapas cúbicos y el otro realiza SSR (Reflexión del espacio de la pantalla - cálculo de reflexiones en el espacio de la pantalla);  todo esto se hace en una pasada y al final se mezcla teniendo en cuenta el coeficiente que determina si el SSR detectó reflexión (probablemente el coeficiente no es binario, sino que es un valor en el intervalo [0, 1]).  SSR funciona de manera estándar para muchos juegos: rastrea repetidamente el búfer de profundidad, tratando de encontrar la mejor intersección entre el rayo reflejado por la superficie sombreada y otra superficie en cualquier lugar de la pantalla.  SSR funciona con la cadena mip de la escala previamente reducida del búfer HDR actual, y no con todo el búfer. <br><br>  También existen factores de corrección como el brillo de la reflexión, así como la peculiar textura de Fresnel, que se calculó antes de este pasaje, en función de las condiciones normales y la rugosidad.  No estoy completamente seguro, pero después de estudiar el código de ensamblaje, me parece que ROTR solo puede calcular SSR para superficies lisas.  El motor no tiene una cadena de mip borrosa después de la etapa SSR, que existe en otros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motores</a> , y ni siquiera hay nada como rastrear el búfer de profundidad utilizando rayos, que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">varía según la rugosidad</a> .  En general, las superficies más rugosas reciben reflejos de los mapas cúbicos, o no los reciben en absoluto.  Sin embargo, donde SSR funciona, su calidad es muy alta y estable, teniendo en cuenta el hecho de que no se acumula con el tiempo y no se realiza el desenfoque espacial.  Los datos alfa también admiten SSR (en algunos templos se pueden ver reflejos muy hermosos en el agua) y esta es una buena adición que no se ve con frecuencia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/b6f/093/5afb6f0937fe9b172b8e38d3f0459b9b.jpg" alt="imagen"></div><br>  <i>Reflexiones para</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecc/66d/c6c/ecc66dc6ca98108593b9a5ec4695dc63.jpg" alt="imagen"></div><br>  <i>Tampón de reflexión</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec9/6ff/e57/ec96ffe5730e775b678a47ae23906b73.jpg" alt="imagen"></div><br>  <i>Reflexiones después</i> <br><br><h4>  Niebla encendida </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/578/565/d2a/578565d2af38eac19d8aff86b82cf710.jpg"></div><br>  En nuestra escena, la niebla está mal representada porque oscurece el fondo y, por lo tanto, es creada por partículas, por lo que nuevamente utilizamos el ejemplo con reflejos.  La niebla es relativamente simple, pero bastante efectiva.  Hay dos modos: global, el color general de la niebla y el color de la dispersión interna obtenida del mapa cúbico.  Quizás el mapa cúbico fue tomado nuevamente de los mapas de reflexión cúbicos, o tal vez creado de nuevo.  En ambos modos, la rarefacción de la niebla se toma de la textura global de rarefacción, en la que las curvas de rarefacción se empaquetan para varios efectos.  En tal esquema, es notable que proporcione una niebla iluminada de muy bajo costo, es decir  dispersando los cambios internos en el espacio, creando la ilusión de la interacción de la niebla con la iluminación distante.  Este enfoque también se puede utilizar para la dispersión atmosférica hacia el interior cerca del cielo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e33/e0e/c3a/e33e0ec3aee95a3cd5a669b332946083.jpg" alt="imagen"></div><br>  <i>Niebla a</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acb/5ed/c78/acb5edc78ab74eb97b9350c1e7aba261.jpg" alt="imagen"></div><br>  <i>Niebla después</i> <br><br><h4>  Iluminación volumétrica </h4><br>  En las primeras etapas del marco, se realizan varias operaciones para prepararse para la iluminación volumétrica.  Se copian dos memorias intermedias de la CPU a la GPU: índices de fuente de luz y datos de fuente de luz.  Ambos son leídos por un sombreador computacional que genera una textura 3D de 40x23x16 de la vista de la cámara que contiene el número de fuentes de luz que cruzan esta área.  La textura es 40 × 23 porque cada mosaico ocupa 32 × 32 píxeles (1280/32 = 40, 720/32 = 22.5), y 16 es el número de píxeles en profundidad.  La textura no incluye todas las fuentes de luz, sino solo aquellas que están marcadas como voluminosas (hay tres en nuestra escena).  Como veremos a continuación, hay otros efectos volumétricos falsos creados por texturas planas.  La textura mostrada tiene una resolución más alta: 160x90x64.  Después de determinar el número de fuentes de luz por mosaico y su índice, tres sombreadores computacionales se ejecutan secuencialmente, realizando las siguientes operaciones: <br><br><ol><li>  El primer paso determina la cantidad de luz que ingresa a la celda dentro del volumen en forma de una pirámide de visibilidad.  Cada célula acumula la influencia de todas las fuentes de luz, como si tuvieran partículas suspendidas que reaccionan a la luz y devuelven parte de ella a la cámara. </li><li>  La segunda pasada difumina la iluminación con un radio pequeño.  Esto probablemente sea necesario para evitar parpadeos al mover la cámara, porque la resolución es muy baja. </li><li>  El tercer paso omite la textura del volumen de adelante hacia atrás, agregando gradualmente la influencia de cada fuente y dando la textura final.  De hecho, simula la cantidad total de iluminación entrante a lo largo del haz a una distancia dada.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que cada celda contiene una parte de la luz reflejada por las partículas hacia la cámara, en cada una de ellas recibiremos una contribución conjunta de todas las celdas previamente pasadas. </font><font style="vertical-align: inherit;">Este pasaje también se difumina.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando todo esto se completa, obtenemos una textura 3D que informa cuánta luz recibe una posición en particular en relación con la cámara. </font><font style="vertical-align: inherit;">Todo lo que queda por hacer en el pasaje de pantalla completa es determinar esta posición, encontrar el vóxel correspondiente de la textura y agregarlo al búfer HDR. </font><font style="vertical-align: inherit;">El sombreador de iluminación en sí es muy simple y contiene solo unas 16 instrucciones.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/939/e8a/b58939e8ae5abf2320c519abc51f6e8a.jpg" alt="imagen"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iluminación volumétrica</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ab/006/e9d/1ab006e9d0b62e0ea0470751185ffe41.jpg" alt="imagen"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iluminación volumétrica después</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Renderizado de cabello </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la función PureHair no está habilitada, las capas estándar de cabello se representan una encima de la otra. </font><font style="vertical-align: inherit;">Esta solución todavía se ve genial, pero me gustaría centrarme en la última tecnología. </font><font style="vertical-align: inherit;">Si la función está habilitada, el marco comienza con una simulación del cabello de Lara con una secuencia de sombreadores computacionales. </font><font style="vertical-align: inherit;">La primera parte de Tomb Raider utilizó una tecnología llamada TressFX, y en la secuela Crystal Dynamics implementó una tecnología mejorada. </font><font style="vertical-align: inherit;">Después de los cálculos iniciales, obtenemos hasta 7 buffers. </font><font style="vertical-align: inherit;">Todos ellos se usan para controlar el cabello de Lara. </font><font style="vertical-align: inherit;">El proceso es el siguiente:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inicie un sombreador computacional para calcular valores de movimiento basados ​​en posiciones anteriores y actuales (para desenfoque de movimiento) </font></font></li><li>          1×1        () </li><li>   122       (Triangle Strip) (   —  ).     ,         .    7 ,      .     ,      ,  .      « ». </li><li>  /   quad    ,     ,     .  ,          ,    . </li><li>       4,      (    « ») </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si está interesado en aprender más sobre esto, entonces AMD tiene muchos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recursos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presentaciones</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , porque es una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biblioteca pública</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> creada por la compañía </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Estaba confundido por la etapa anterior a la etapa 1, en la que se realiza la misma llamada de sorteo que en la etapa 3, se dice que representa solo valores de profundidad, pero de hecho el contenido no se representa, y esto es interesante; </font><font style="vertical-align: inherit;">quizás Renderdoc no me está diciendo nada. </font><font style="vertical-align: inherit;">Sospecho que puede haber intentado ejecutar una solicitud de representación condicional, pero no veo ninguna llamada de predicción.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21f/127/76f/21f12776f41f0893c37a677deca12529.jpg" alt="imagen"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cabello recogido</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/832/f49/ecd/832f49ecd96406db87ee99f3b1089de0.jpg" alt="imagen"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Píxeles visibles del cabello</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/33e/030/28933e0309107cfcb3120564d55fd412.jpg" alt="imagen"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cabello sombreado</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Representación en mosaico de datos alfa y partículas </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los objetos transparentes vuelven a utilizar la clasificación de las fuentes de luz en mosaico calculadas para el paso de iluminación preliminar de las fichas. Cada objeto transparente calcula su propia iluminación en una pasada, es decir, el número de instrucciones y ciclos se vuelve bastante aterrador (por eso se utilizó la pasada preliminar de iluminación para objetos opacos). ¡Los objetos transparentes incluso pueden realizar reflejos en el espacio de la pantalla si están encendidos! Cada objeto se procesa en orden de atrás hacia adelante directamente en el búfer HDR, incluyendo vidrio, llama, agua de rutina, etc. El pasaje alfa también muestra los bordes resaltados cuando Lara se enfoca en algún objeto (por ejemplo, una botella con una mezcla combustible en una caja a la izquierda).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/445/4a8/311/4454a83115f4118ab092fc1ff3bcaaf1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, las partículas se convierten en un búfer de media resolución para suavizar la enorme carga en el ancho de banda creado por su repintado, especialmente cuando se utilizan muchas partículas grandes que cubren la pantalla para crear niebla, niebla, llamas, etc. Por lo tanto, el tampón HDR y el tampón de profundidad disminuyen a la mitad en cada lado, después de lo cual comienza el procesamiento de partículas. Las partículas crean una gran cantidad de redibujado, algunos píxeles se sombrean unas 40 veces. El mapa de calor muestra lo que quiero decir. Dado que las partículas se renderizaron en la mitad de la resolución, se usa el mismo truco de zoom inteligente que en la iluminación ambiental (los espacios se marcan en la plantilla, el primer paso se convierte en píxeles internos, el segundo recrea los bordes). Puede notar que las partículas se convierten en otros efectos alfa, como la llama,brillo, etc. Esto es necesario para que el alfa se pueda clasificar correctamente en relación con, por ejemplo, el humo. También puede notar que aquí aparecen rayos de luz "volumétricos", provenientes de focos de seguridad. Se agregan aquí y no se crean en la etapa de iluminación volumétrica. Esta es una forma económica pero realista de crearlos a largas distancias.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e78/0f1/c77/e780f1c77d8c9031e10b1ddc6faf6b20.jpg" alt="imagen"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/409/09c/1db40909cea712bec3b9f1d4eab109d7.jpg" alt="imagen"></div><br> <i> -</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/8f2/80a/2c18f280ab65f272470ff711def4b89e.jpg" alt="imagen"></div><br> <i>   1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/098/e29/66c/098e2966cf5d8bdc62a7d76bfdc2344e.jpg" alt="imagen"></div><br> <i>   2</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/c73/f5a/e0bc73f5ab35af88840eebe45f175074.jpg" alt="imagen"></div><br> <i>   3</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb0/6ef/e9e/eb06efe9eb6fe1db3e749e6b1a6c1c9c.jpg" alt="imagen"><br> <i>   </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56e/263/ba6/56e263ba63ae60ee5af108c172711410.jpg" alt="imagen"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8f/564/288/e8f564288ae2310272be7ac9899409d9.jpg" alt="imagen"></div><br> <i> -</i> <br><br><h4>     </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ROTR realiza la velocidad de obturación y la corrección de tono en una sola pasada. Sin embargo, aunque generalmente creemos que la corrección gamma ocurre con la corrección de tono, este no es el caso aquí. Hay muchas formas de implementar la exposición, como hemos visto con </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">otros </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juegos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El cálculo de la luminancia en ROTR es muy interesante y casi no requiere datos intermedios o pases, por lo que explicaremos este proceso con más detalle. Toda la pantalla se divide en 64 × 64 mosaicos, después de lo cual el cálculo de grupos (20, 12, 1) de 256 secuencias en cada uno comienza a llenar toda la pantalla. Cada hilo esencialmente realiza la siguiente tarea (el pseudocódigo se presenta a continuación):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; ++i) { uint2 iCoord = CalculateCoord(threadID, i, j); <span class="hljs-comment"><span class="hljs-comment">// Obtain coordinate float3 hdrValue = Load(hdrTexture, iCoord.xyz); // Read HDR float maxHDRValue = max3(hdrValue); // Find max component float minHDRValue = min3(hdrValue); // Find min component float clampedAverage = max(0.0, (maxHDRValue + minHDRValue) / 2.0); float logAverage = log(clampedAverage); // Natural logarithm sumLogAverage += logAverage; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada grupo calcula la suma logarítmica de los 64 píxeles (256 hilos, cada uno de los cuales procesa 16 valores). En lugar de almacenar el valor promedio, guarda la suma y el número de píxeles realmente procesados ​​(no todos los grupos procesan exactamente 64 × 64 píxeles, porque, por ejemplo, pueden ir más allá de los bordes de la pantalla). Shader usa sabiamente el almacenamiento local de hilos para dividir la suma; cada flujo primero funciona con 16 valores horizontales, y luego los flujos separados resumen todos estos valores verticalmente, y finalmente el flujo de control de este grupo (flujo 0) agrega el resultado y los guarda en el búfer. Este búfer contiene 240 elementos, esencialmente dándonos el brillo promedio de muchas áreas de la pantalla. El siguiente comando inicia 64 hilos que recorren todos estos valores y los agregan,para obtener el brillo final de la pantalla. También regresa del logaritmo a unidades lineales.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No tengo mucha experiencia con técnicas de exposición, pero al leer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta publicación de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Krzysztof Narkovic se aclararon algunas cosas. Es necesario guardar en una matriz de 64 elementos para calcular el promedio móvil, en el que puede ver los valores calculados anteriores y suavizar la curva para evitar cambios muy bruscos en el brillo, creando cambios bruscos en la velocidad de obturación. Este es un sombreador muy complejo y todavía no he descubierto todos sus detalles, pero el resultado final es el valor de la velocidad de obturación correspondiente al cuadro actual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Después de encontrar las velocidades de obturación adecuadas, una pasada realiza la velocidad de obturación final más la corrección tonal. ROTR parece usar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapeo fotográfico de tonos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que explica el uso de medios logarítmicos en lugar de los medios habituales. </font><font style="vertical-align: inherit;">La fórmula de corrección tonal en el sombreador (después de la exposición) se puede ampliar de la siguiente manera:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bz/yv/-k/bzyv-kjhv-hs6lj3mh4yfrh427w.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/id/zn/1d/idzn1d3rn-3qs7vrokrn94d9z1m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una breve explicación se puede encontrar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">No pude entender por qué es necesaria una división adicional por Lm, porque cancela la influencia de la multiplicación. </font><font style="vertical-align: inherit;">En cualquier caso, whitePoint es 1.0, por lo que el proceso no hace mucho en este marco, la imagen solo cambia la velocidad de obturación. </font><font style="vertical-align: inherit;">¡Ni siquiera hay un límite para los valores del intervalo LDR! </font><font style="vertical-align: inherit;">Ocurre durante la gradación de color, cuando el cubo de color limita indirectamente valores superiores a 1.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1a/92f/2e8/e1a92f2e852892aa137c170a56718f8e.jpg" alt="imagen"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exposición a</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/c4f/905/788c4f905eecffaa8d5dbd12d1c8972d.jpg" alt="imagen"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exposición después</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Destello de lente </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los destellos de las lentes se representan de manera interesante. Un pequeño pase preliminar calcula una textura 1xN (donde N es el número total de elementos de deslumbramiento que se renderizarán como destellos de lente, en nuestro caso hay 28). Esta textura contiene el valor alfa de la partícula y alguna otra información no utilizada, pero en lugar de calcularlo a partir de una solicitud de visibilidad o algo similar, el motor lo calcula analizando el búfer de profundidad alrededor de la partícula en el círculo. Para hacer esto, la información sobre los vértices se almacena en un búfer disponible para el sombreador de píxeles.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/604/e96/8a0604e96d5a4fe4ebf691719f03d75f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego, cada elemento se representa como simples planos alineados con el plano emitidos por las fuentes de luz. </font><font style="vertical-align: inherit;">Si el valor alfa es menor que 0.01, el valor NaN se asigna a la posición para que esta partícula no se rasterice. </font><font style="vertical-align: inherit;">Son un poco como el efecto de floración y agregan brillo, pero este efecto en sí mismo se crea más tarde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/526/da9/a18/526da9a184f303dc8e3bfd82cd16034a.jpg" alt="imagen"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lente estalla</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/465/440/335/4654403353e5b94dc7bae2a68b95ed88.jpg" alt="imagen"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elementos de destello de lente</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c1/f10/c43/5c1f10c4396cbd6a8502a28b5a53fe0f.jpg" alt="imagen"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Destellos de lente después</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloom </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom utiliza un enfoque estándar: reduciendo la resolución del búfer HDR, se aíslan los píxeles brillantes y luego su escala se incrementa secuencialmente con desenfoque para expandir su área de influencia. El resultado se amplía a la resolución de la pantalla y la composición se superpone encima. Hay un par de puntos interesantes que vale la pena explorar. Todo el proceso se realiza utilizando 7 sombreadores computacionales: 2 para disminución de muestras, 1 para desenfoque simple, 4 para acercamiento.</font></font><br><br><ol><li>                  target   (mip 1).        .  ,   mip-    ,           0.02. </li><li>     mip      mip 2, 3, 4  5. </li><li>       mip 5.        ,    .       ,             . </li><li>   —   .  3          ,   mip N    mip N + 1,       ,     .     bloom      ,     . </li><li>     mip 1      HDR-,      bloom. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0c/478/bc7/b0c478bc7ccc0c4774cea8b2aaa4ec8b.jpg" alt="imagen"></div><br> <i>Bloom </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f77/b74/99b/f77b7499b451e0f232b06d183ccc04f4.jpg"></div><br> <i>MIP 1   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c65/ae2/875/c65ae2875487b8a9b441a9ce0b137430.jpg"></div><br> <i>MIP 2   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55b/9a4/757/55b9a4757f48867201dc76df90ea0dd1.jpg"></div><br> <i>MIP 3   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba5/17d/a6f/ba517da6f179cca1067a08115579c155.jpg"></div><br> <i>MIP 4   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33f/91f/44d/33f91f44dcc1f9a395375fce8535ac2d.jpg" alt="imagen"></div><br> <i>MIP 5   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecb/561/33d/ecb56133d1965bcc93024c5cded95ec7.jpg"></div><br> <i> MIP 5  Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/0ed/474/2350ed47490101cda12baffbd61fc8f0.jpg"></div><br> <i>MIP 4   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff0/cfb/4df/ff0cfb4dfeea995b8666d4b8aec057a1.jpg"></div><br> <i>MIP 3   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/980/7ca/a31/9807caa31251495050af2e2fd32b5e90.jpg" alt="imagen"></div><br> <i>MIP 2   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/857/4be/854/8574be854f2526857ef9b6854d6f7235.jpg"></div><br> <i>MIP 1   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9be/aa8/8a1/9beaa88a1bf00876801bb103ef85dd16.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom after El</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aspecto curioso es que las texturas de escala reducida cambian la relación de aspecto. </font><font style="vertical-align: inherit;">En aras de la visualización, los corregí, y solo puedo adivinar las razones de esto; </font><font style="vertical-align: inherit;">quizás esto se hace para que los tamaños de textura sean múltiplos de 16. Otro punto interesante: dado que estos sombreadores generalmente tienen un ancho de banda muy limitado, los valores almacenados en la memoria compartida del grupo se convierten de float32 a float16. </font><font style="vertical-align: inherit;">Esto permite que el sombreador intercambie operaciones matemáticas para duplicar la memoria libre y el ancho de banda. </font><font style="vertical-align: inherit;">Para que esto se convierta en un problema, el rango de valores debería ser bastante grande.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fxaa </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ROTR admite una amplia gama de diferentes técnicas de suavizado, como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FXAA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Fast Approximate AA) y SSAA (Super Sampling AA). </font><font style="vertical-align: inherit;">Es de destacar que la opción de habilitar AA temporal está ausente, porque para la mayoría de los juegos AAA modernos se está convirtiendo en estándar. </font><font style="vertical-align: inherit;">Sea como fuere, FXAA hace frente a su tarea notablemente, SSAA también funciona bien, esta es una opción bastante "pesada" si el juego carece de rendimiento.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Desenfoque de movimiento </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece que Motion Blur utiliza un enfoque muy similar a la solución en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadows of Mordor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Después de renderizar la iluminación volumétrica, un pase de representación separado genera los vectores de movimiento desde los objetos animados hasta el buffer de movimiento. Luego, este búfer se combina con el movimiento causado por la cámara, y el búfer de movimiento final se convierte en entrada al paso de desenfoque, que realiza el desenfoque en la dirección indicada por los vectores de movimiento del espacio de la pantalla. Para estimar el radio de desenfoque en unas pocas pasadas, se calcula la textura de los vectores de movimiento en una escala reducida para que cada píxel tenga una idea aproximada de qué tipo de movimiento se encuentra cerca. El desenfoque se realiza en varias pasadas a media resolución y, como vimos, más tarde su escala con la ayuda de la plantilla aumenta en dos pasadas. Se realizan varios pases por dos razones: primero,para reducir la cantidad de lecturas de textura necesarias para crear desenfoque con un radio potencialmente muy grande y, en segundo lugar, porque se realizan diferentes tipos de desenfoque. Depende de si el personaje animado estaba en los píxeles actuales.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/91d/df6/3f491ddf60c6a1a6b9caeaec316eab4f.jpg" alt="imagen"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desenfoque de movimiento para</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e5/eb5/d42/2e5eb5d42d4e0c36c4c96e764538f8c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Velocidad de desenfoque de movimiento</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edf/3ed/2e7/edf3ed2e7144ec27ba21b3b16e606c7f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pase de desenfoque de movimiento 1</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c5/c65/931/7c5c6593183900a85a3d0372fce9eb03.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 2</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a3/bc5/bcc/8a3bc5bcc85c92d698fc081e49c0f318.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 3</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/5e1/a7e/04f5e1a7e722d9818c8a23ef5759c172.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 4</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/98f/579/f9d98f579e02acec8e3ef99e90bdd0c0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 5</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/3ca/b5c/99e3cab5cbf5d25b2eea0d3311eae7cf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 6</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/042/af0/5bd/042af05bd488751c53bd97c73cb037fc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desenfoque de movimiento, acercamiento y alejamiento</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e10/26d/c47/e1026dc47d9035e8713422ad8210e6a7.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desenfoque de movimiento, bordes de zoom</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Características y detalles adicionales </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hay algunas cosas más que vale la pena mencionar sin muchos detalles. </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Congelación de la cámara: en climas fríos agrega copos de nieve y escarcha a la cámara </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cámara sucia: agrega suciedad a la cámara. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corrección de color: al final del cuadro, se realiza una pequeña corrección de color, utilizando un cubo de color bastante estándar para realizar la corrección de color, como se describió anteriormente, y también agrega ruido para hacer que algunas escenas sean más severas </font></font></li></ol><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La interfaz de usuario se implementa de forma un poco inusual: representa todos los elementos en el espacio lineal. </font><font style="vertical-align: inherit;">Por lo general, en el momento de la representación, la interfaz de usuario ya había realizado la corrección de tono y la corrección gamma. </font><font style="vertical-align: inherit;">Sin embargo, ROTR usa espacio lineal hasta el final del cuadro. </font><font style="vertical-align: inherit;">Esto tiene sentido, porque el juego utiliza una reminiscencia de la interfaz de usuario 3D; </font><font style="vertical-align: inherit;">sin embargo, antes de grabar imágenes sRGB en el búfer HDR, deben convertirse al espacio lineal para que la operación más reciente (corrección gamma) no distorsione los colores.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para resumir </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que hayas disfrutado leyendo este análisis de la misma manera que lo hice. </font><font style="vertical-align: inherit;">Personalmente, definitivamente aprendí mucho de eso. </font><font style="vertical-align: inherit;">Felicitaciones a los talentosos desarrolladores de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crystal Dynamics</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por el fantástico trabajo realizado para crear este motor. </font><font style="vertical-align: inherit;">También quiero agradecer a Baldur Karlsson por su fantástico trabajo en Renderdoc. </font><font style="vertical-align: inherit;">Su trabajo hizo que la depuración de gráficos en una PC fuera un proceso mucho más conveniente. </font><font style="vertical-align: inherit;">Creo que lo único que fue un poco complicado en este análisis fue el seguimiento de los lanzamientos de sombreadores, porque al momento de escribir esta función no está disponible para DX12. </font><font style="vertical-align: inherit;">Espero que con el tiempo aparezca y todos estemos muy contentos.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436500/">https://habr.com/ru/post/es436500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436490/index.html">Motorola planea introducir la encarnación Razr v3</a></li>
<li><a href="../es436492/index.html">Estamos buscando oradores en el décimo DIY Mitap 17 de febrero de 2019</a></li>
<li><a href="../es436494/index.html">Reemplazar un disco manteniendo la numeración adecuada en CEPH</a></li>
<li><a href="../es436496/index.html">PVS-Studio para Java</a></li>
<li><a href="../es436498/index.html">Software AG: no solo ARIS</a></li>
<li><a href="../es436502/index.html">Pampers de suscripción o cómo vender más a los mismos clientes</a></li>
<li><a href="../es436504/index.html">Sistema en paquete, o ¿Qué hay debajo de la cubierta del paquete de chips?</a></li>
<li><a href="../es436506/index.html">Cómo crear un AI-racista sin mucho esfuerzo</a></li>
<li><a href="../es436508/index.html">$ 10 millones en inversiones y elogios de Wozniak: crear una computadora educativa para niños</a></li>
<li><a href="../es436510/index.html">Datos centrales en detalle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>