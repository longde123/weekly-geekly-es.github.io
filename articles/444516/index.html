<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôé ‚úçÔ∏è üõÄüèæ Wolfenstein 3D: trazado de rayos con WebGL1 üì≤ üë©‚Äçüë¶‚Äçüë¶ üë®üèø‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despu√©s de la aparici√≥n de las tarjetas gr√°ficas Nvidia RTX el verano pasado, el trazado de rayos ha recuperado su antigua popularidad. En los √∫ltimos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wolfenstein 3D: trazado de rayos con WebGL1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444516/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/885/df3/33c/885df333c0da45fcbb909c01c5da9648.png" alt="imagen"></div><br>  Despu√©s de la aparici√≥n de las tarjetas gr√°ficas Nvidia RTX el verano pasado, el trazado de rayos ha recuperado su antigua popularidad.  En los √∫ltimos meses, mi feed de Twitter se ha llenado con un sinf√≠n de comparaciones gr√°ficas con RTX habilitado y deshabilitado. <br><br>  Despu√©s de admirar tantas im√°genes hermosas, quer√≠a intentar combinar el cl√°sico renderizador de avance con un rastreador de rayos por mi cuenta. <br><br>  Al sufrir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un s√≠ndrome de rechazo de los desarrollos de otras personas</a> , como resultado, cre√© mi propio motor de renderizado h√≠brido basado en WebGL1.  Puede jugar con la representaci√≥n de nivel de demostraci√≥n de Wolfenstein 3D con las esferas (que utilic√© debido al trazado de rayos) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><a name="habracut"></a><br><h3>  Prototipo </h3><br>  Comenc√© este proyecto creando un prototipo, tratando de recrear <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la iluminaci√≥n global con el trazado de rayos de Metro Exodus</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/61a/447/26261a447cd19758715a3cbde356eeb7.png"></div><br>  <i>El primer prototipo que muestra una iluminaci√≥n global difusa (Diffuse GI)</i> <br><br>  El prototipo se basa en un renderizador hacia adelante, que representa toda la geometr√≠a de la escena.  El sombreador utilizado para rasterizar la geometr√≠a no solo calcula la iluminaci√≥n directa, sino que tambi√©n emite rayos aleatorios desde la superficie de la geometr√≠a renderizada para acumular usando el reflector indirecto de la luz que surge de superficies no brillantes (GI difuso). <br><br>  En la imagen de arriba puede ver c√≥mo todas las esferas se iluminan correctamente solo con luz indirecta (los rayos de luz se reflejan desde la pared detr√°s de la c√°mara).  La fuente de luz en s√≠ est√° cubierta por una pared marr√≥n en el lado izquierdo de la imagen. <br><br><h3>  Wolfenstein 3D </h3><br>  El prototipo usa una escena muy simple.  Tiene solo una fuente de luz y solo se representan unas pocas esferas y cubos.  Gracias a esto, el c√≥digo de trazado de rayos en el sombreador es muy simple.  El ciclo de verificaci√≥n de la fuerza bruta en la intersecci√≥n en el que se prueba la viga para la intersecci√≥n con todos los cubos y esferas en la escena a√∫n es lo suficientemente r√°pido como para que el programa lo ejecute en tiempo real. <br><br>  Despu√©s de crear este prototipo, quer√≠a hacer algo m√°s complejo agregando m√°s geometr√≠a y muchas fuentes de luz a la escena. <br><br>  El problema con un entorno m√°s complejo es que todav√≠a necesito poder rastrear rayos en la escena en tiempo real.  Por lo general, se usar√≠a una estructura de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jerarqu√≠a de volumen delimitador</a> (BVH) para acelerar el proceso de trazado de rayos, pero mi decisi√≥n de crear este proyecto en WebGL1 no lo permiti√≥: es imposible cargar datos de 16 bits en una textura en WebGL1 y las operaciones binarias no se pueden usar en un sombreador.  Esto complica el c√°lculo preliminar y la aplicaci√≥n de BVH en sombreadores WebGL1. <br><br>  Es por eso que decid√≠ usar el nivel de demostraci√≥n 3D de Wolfenstein para esto.  En 2013, cre√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sombreador fragmentado de WebGL</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Shadertoy</a> que no solo representa niveles similares a Wolfenstein, sino que tambi√©n crea de manera procesal todas las texturas necesarias.  Por mi experiencia trabajando en este sombreador, sab√≠a que el dise√±o de nivel basado en la cuadr√≠cula de Wolfenstein tambi√©n se puede usar como una estructura de aceleraci√≥n r√°pida y f√°cil, y que el trazado de rayos en esta estructura ser√° muy r√°pido. <br><br>  A continuaci√≥n se muestra una captura de pantalla de la demostraci√≥n, y en modo de pantalla completa puedes jugarla aqu√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://reindernijhoff.net/wolfrt</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eu/gl/fp/euglfpjgl9503fy-_hjdwmr5hdi.png"></div><br><h3>  Breve descripci√≥n </h3><br>  La demostraci√≥n utiliza un motor de renderizado h√≠brido.  Para representar todos los pol√≠gonos en el marco, utiliza la rasterizaci√≥n tradicional y luego combina el resultado con sombras, GI difuso y reflejos creados por el trazado de rayos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f7/fd8/bb9/8f7fd8bb9324905edf5200fedb28bb7a.png"></div><br>  <i>Sombras</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/5b5/6ba/5245b56ba3a1feb02a9401857d625514.png"></div><br>  <i>Gi difusa</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/885/df3/33c/885df333c0da45fcbb909c01c5da9648.png"></div><br>  <i>Reflexiones</i> <br><br><h3>  Representaci√≥n proactiva </h3><br>  Las tarjetas Wolfenstein se pueden codificar completamente en una cuadr√≠cula bidimensional de 64 √ó 64.  El mapa utilizado en la demostraci√≥n se basa en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer nivel del episodio 1 de</a> Wolfenstein 3D. <br><br>  Al inicio, se crea toda la geometr√≠a necesaria para pasar el renderizado proactivo.  Se genera una malla de muros a partir de los datos del mapa.  Tambi√©n crea planos de piso y techo, mallas separadas para luces, puertas y esferas al azar. <br><br>  Todas las texturas utilizadas para paredes y puertas se empaquetan en un atlas de textura √∫nica, por lo que todas las paredes se pueden dibujar en una llamada de sorteo. <br><br><h4>  Sombras e iluminaci√≥n </h4><br>  La iluminaci√≥n directa se calcula en el sombreador utilizado para el pase de renderizado directo.  Cada fragmento puede ser iluminado (m√°ximo) por cuatro fuentes diferentes.  Para saber qu√© fuentes pueden influir en el fragmento en el sombreador, cuando se inicia la demostraci√≥n, la textura de b√∫squeda se calcula previamente.  Esta textura de b√∫squeda tiene un tama√±o de 64 por 128 y codifica las posiciones de las 4 fuentes de luz m√°s cercanas para cada posici√≥n en la cuadr√≠cula del mapa. <br><br><pre><code class="cpp hljs">varying vec3 vWorldPos; varying vec3 vNormal; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ vec3 ro = vWorldPos; vec3 normal = normalize(vNormal); vec3 light = vec3(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;LIGHTS_ENCODED_IN_MAP; i++) { light += sampleLight(i, ro, normal); }</code> </pre> <br>  Para obtener sombras suaves para cada fragmento y fuente de luz, se muestrea una posici√≥n aleatoria en la fuente de luz.  Usando el c√≥digo de trazado de rayos en el sombreador (consulte la secci√≥n Trazado de rayos a continuaci√≥n), se emite un rayo de sombra a un punto de muestreo para determinar la visibilidad de la fuente de luz. <br><br>  Despu√©s de agregar reflexiones (auxiliares) (consulte la secci√≥n Reflexi√≥n a continuaci√≥n), se agrega GI difuso al color calculado del fragmento realizando una b√∫squeda en el Objetivo de renderizado de GI difuso (ver a continuaci√≥n). <br><br><h3>  Trazado de rayos </h3><br>  Aunque en el prototipo el c√≥digo de trazado de rayos para GI difuso se combin√≥ con un sombreador preventivo, en la demostraci√≥n decid√≠ separarlos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58b/8fd/3ab/58b8fd3abd38a86da42e1454df7109de.png"></div><br>  Los separ√© haciendo un segundo renderizado de toda la geometr√≠a en un objetivo de renderizado separado (Diffuse GI Render Target) usando otro sombreador que solo emite rayos aleatorios para recolectar GI difuso (ver la secci√≥n "GI difuso" a continuaci√≥n).  La iluminaci√≥n recopilada en este objetivo de renderizado se agrega a la iluminaci√≥n directa calculada en el pasaje de renderizado directo. <br><br>  Al separar el paso proactivo y el GI difuso, podemos emitir menos de un haz GI difuso por p√≠xel de pantalla.  Esto se puede hacer reduciendo la escala de b√∫fer (moviendo el control deslizante en las opciones en la esquina superior derecha de la pantalla). <br><br>  Por ejemplo, si la escala de b√∫fer es 0,5, solo se emitir√° un rayo por cada cuatro p√≠xeles de pantalla.  Esto proporciona un gran aumento en la productividad.  Usando la misma interfaz de usuario en la esquina superior derecha de la pantalla, tambi√©n puede cambiar el n√∫mero de muestras por p√≠xel en el objetivo de representaci√≥n (SPP) y el n√∫mero de reflejos del haz. <br><br><h4>  Emitir un rayo </h4><br>  Para poder emitir rayos en la escena, toda la geometr√≠a de nivel debe tener un formato que pueda utilizar el trazador de rayos en el sombreador.  La capa Wolfenstein codific√≥ una cuadr√≠cula de 64 √ó 64, por lo que es bastante f√°cil codificar todos los datos en una sola textura de 64 √ó 64: <br><br><ul><li>  En el canal rojo del color de la textura, todos los objetos ubicados en la celda correspondiente <em>x, y de</em> la cuadr√≠cula del mapa est√°n codificados.  Si el valor del canal rojo es cero, entonces no hay objetos en la celda, de lo contrario, est√° ocupado por una pared (valores del 1 al 64), una puerta, una fuente de luz o una esfera que debe verificarse para la intersecci√≥n. </li><li>  Si una esfera ocupa una celda de cuadr√≠cula de nivel, entonces se utilizan canales verde, azul y alfa para codificar el radio <em>y las</em> coordenadas relativas <em>x</em> e <em>y</em> de la esfera dentro de la celda de cuadr√≠cula. </li></ul><br>  Se emite un rayo en una escena atravesando una textura usando el siguiente c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worldHit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n vec3 ro,in vec3 rd,in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t_min, in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t_max, inout vec3 recPos, inout vec3 recNormal, inout vec3 recColor)</span></span></span><span class="hljs-function"> </span></span>{ vec3 pos = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(ro); vec3 ri = <span class="hljs-number"><span class="hljs-number">1.0</span></span>/rd; vec3 rs = sign(rd); vec3 dis = (pos-ro + <span class="hljs-number"><span class="hljs-number">0.5</span></span> + rs*<span class="hljs-number"><span class="hljs-number">0.5</span></span>) * ri; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;MAXSTEPS; i++ ) { vec3 mm = step(dis.xyz, dis.zyx); dis += mm * rs * ri; pos += mm * rs; vec4 mapType = texture2D(_MapTexture, pos.xz * (<span class="hljs-number"><span class="hljs-number">1.</span></span> / <span class="hljs-number"><span class="hljs-number">64.</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWall(mapType)) { ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Se puede encontrar un c√≥digo de trazado de rayos de malla similar en este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sombreador Wolfenstein</a> en Shadertoy. <br><br>  Despu√©s de calcular el punto de intersecci√≥n con la pared o la puerta (usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la prueba de intersecci√≥n con un paralelogramo</a> ), buscar en el mismo atlas de textura que se us√≥ para pasar la representaci√≥n proactiva nos da puntos de intersecci√≥n de albedo.  Las esferas tienen un color que se determina seg√∫n el procedimiento en funci√≥n de sus coordenadas <em>x, y</em> en la cuadr√≠cula y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la funci√≥n de gradiente de color</a> . <br><br>  Las puertas son un poco m√°s complicadas porque se mueven.  Para que la representaci√≥n de la escena en la CPU (utilizada para renderizar mallas en el pase de renderizado hacia adelante) sea la misma que la representaci√≥n de la escena en la GPU (utilizada para el trazado de rayos), todas las puertas se mueven de forma autom√°tica y determinista, en funci√≥n de la distancia desde la c√°mara hasta la puerta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d7/ded/058/3d7ded058d2f62fcf298c9b68b568a69.png"></div><br><br><h4>  Gi difusa </h4><br>  La iluminaci√≥n global dispersa (GI difusa) se calcula emitiendo rayos en el sombreador, que se utiliza para dibujar toda la geometr√≠a en el objetivo de renderizado GI difuso.  La direcci√≥n de estos rayos depende de la normalidad a la superficie, determinada mediante el muestreo del hemisferio ponderado por coseno. <br><br>  Teniendo la direcci√≥n del haz <em>rd</em> y el punto de partida <em>ro</em> , la iluminaci√≥n reflejada se puede calcular utilizando el siguiente ciclo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBounceCol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(in vec3 ro, in vec3 rd, in vec3 col)</span></span></span><span class="hljs-function"> </span></span>{ vec3 emitted = vec3(<span class="hljs-number"><span class="hljs-number">0</span></span>); vec3 recPos, recNormal, recColor; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;MAX_RECURSION; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worldHit(ro, rd, <span class="hljs-number"><span class="hljs-number">0.001</span></span>, <span class="hljs-number"><span class="hljs-number">20.</span></span>, recPos, recNormal, recColor)) { <span class="hljs-comment"><span class="hljs-comment">// if (isLightHit) { // direct light sampling code // return vec3(0); // } col *= recColor; for (int i=0; i&lt;2; i++) { emitted += col * sampleLight(i, recPos, recNormal); } } else { return emitted; } rd = cosWeightedRandomHemisphereDirection(recNormal); ro = recPos; } return emitted; }</span></span></code> </pre> <br>  Para reducir el ruido, se agrega muestreo de luz directa al bucle.  Esto es similar a la t√©cnica utilizada en mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otro</a> sombreador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cornell Box</a> en Shadertoy. <br><br><h4>  Reflexion </h4><br>  Gracias a la capacidad de trazar la escena con rayos en el sombreador, es muy f√°cil agregar reflejos.  En mi demostraci√≥n, los reflejos se agregan llamando al mismo m√©todo <em>getBounceCol</em> que se muestra arriba usando el haz reflejado de la c√°mara: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> REFLECTION col = mix(col, getReflectionCol(ro, reflect(normalize(vWorldPos - _CamPos), normal), albedo), .15); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Las reflexiones se agregan en el paso de representaci√≥n hacia adelante, por lo tanto, un rayo de reflexi√≥n siempre emitir√° un haz de reflexi√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a88/e84/d6a/a88e84d6a2d0209234d6edaf02fcc441.png"></div><br><h3>  Anti-aliasing temporal </h3><br>  Dado que ambas sombras suaves en la representaci√≥n proactiva pasan y la aproximaci√≥n GI difusa usan aproximadamente una muestra por p√≠xel, el resultado final es extremadamente ruidoso.  Para reducir la cantidad de ruido, se us√≥ el anti-aliasing temporal (TAA) basado en el TAA de Playdead: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Anti-Aliasing de Reproyecci√≥n Temporal en el INTERIOR</a> . <br><br><h4>  Re-proyecci√≥n </h4><br>  La idea detr√°s de TAA es bastante simple: TAA calcula un subp√≠xel por fotograma y luego promedia sus valores con el p√≠xel correspondiente del fotograma anterior. <br><br>  Para saber d√≥nde estaba el p√≠xel actual en el cuadro anterior, la posici√≥n del fragmento se vuelve a proyectar usando la matriz de proyecci√≥n de vista de modelo del cuadro anterior. <br><br><h4>  Colocar muestras y limitar vecindarios </h4><br>  En algunos casos, una muestra guardada del pasado no es v√°lida, por ejemplo, cuando la c√°mara se movi√≥ de tal manera que la geometr√≠a cerr√≥ un fragmento del cuadro actual en el cuadro anterior.  Para descartar tales muestras no v√°lidas, se utiliza una restricci√≥n de vecindad.  Eleg√≠ el tipo m√°s simple de restricci√≥n: <br><br><pre> <code class="cpp hljs">vec3 history = texture2D(_History, uvOld ).rgb; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = <span class="hljs-number"><span class="hljs-number">-1.</span></span>; x &lt;= <span class="hljs-number"><span class="hljs-number">1.</span></span>; x+=<span class="hljs-number"><span class="hljs-number">1.</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = <span class="hljs-number"><span class="hljs-number">-1.</span></span>; y &lt;= <span class="hljs-number"><span class="hljs-number">1.</span></span>; y+=<span class="hljs-number"><span class="hljs-number">1.</span></span>) { vec3 n = texture2D(_New, vUV + vec2(x,y) / _Resolution).rgb; mx = max(n, mx); mn = min(n, mn); } } vec3 history_clamped = clamp(history, mn, mx);</code> </pre> <br>  Tambi√©n intent√© usar el m√©todo de restricci√≥n basado en el paralelogramo delimitador, pero no vi mucha diferencia con mi soluci√≥n.  Esto probablemente sucedi√≥ porque en la escena de la demostraci√≥n hay muchos colores oscuros id√©nticos y casi ning√∫n objeto en movimiento. <br><br><h4>  Vibraciones de la c√°mara </h4><br>  Para obtener anti-aliasing, la c√°mara en cada cuadro oscila debido al uso de desplazamiento de subp√≠xel (pseudo) aleatorio.  Esto se implementa cambiando la matriz de proyecci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._projectionMatrix[<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>] += (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getHaltonSequence(frame % <span class="hljs-number"><span class="hljs-number">51</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) - <span class="hljs-number"><span class="hljs-number">.5</span></span>) / renderWidth; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._projectionMatrix[<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] += (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getHaltonSequence(frame % <span class="hljs-number"><span class="hljs-number">41</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) - <span class="hljs-number"><span class="hljs-number">.5</span></span>) / renderHeight;</code> </pre> <br><h3>  El ruido </h3><br>  El ruido es la base de los algoritmos utilizados para calcular el IG difuso y las sombras suaves.  El uso de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">buen ruido</a> afecta en gran medida la calidad de la imagen, mientras que el mal ruido crea artefactos o ralentiza la convergencia de la imagen. <br><br>  Me temo que el ruido blanco utilizado en esta demostraci√≥n no es muy bueno. <br><br>  Usar buen ruido es probablemente el aspecto m√°s importante para mejorar la calidad de imagen en esta demostraci√≥n.  Por ejemplo, puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ruido azul</a> . <br><br>  Realic√© experimentos con ruido basados ‚Äã‚Äãen la proporci√≥n √°urea, pero no tuvieron √©xito.  Hasta ahora, se utiliza el infame <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hash sin Seno de</a> Dave Hoskins: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 p3 = fract(vec3(g_seed += <span class="hljs-number"><span class="hljs-number">0.1</span></span>) * HASHSCALE3); p3 += dot(p3, p3.yzx + <span class="hljs-number"><span class="hljs-number">19.19</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract((p3.xx+p3.yz)*p3.zy); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a81/338/42a/a8133842a43266dad1b4e9ee50c59228.png"></div><br><h3>  Reducci√≥n de ruido </h3><br>  Incluso con TAA habilitado, la demostraci√≥n todav√≠a muestra mucho ruido.  Es especialmente dif√≠cil renderizar el techo, ya que est√° iluminado solo por iluminaci√≥n indirecta.  No simplifica la situaci√≥n de que el techo es una gran superficie plana, llena de un color s√≥lido: si tuviera textura o detalles geom√©tricos, entonces el ruido ser√≠a menos notable. <br><br>  No quer√≠a pasar mucho tiempo en esta parte de la demostraci√≥n, as√≠ que trat√© de aplicar solo un filtro de reducci√≥n de ruido: Median3x3 de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Morgan McGuire y Kyle Witson</a> .  Desafortunadamente, este filtro no funciona muy bien con gr√°ficos de "pixel art" para texturas de pared: elimina todos los detalles en la distancia y redondea las esquinas de los p√≠xeles de las paredes cercanas. <br><br>  En otro experimento, apliqu√© el mismo filtro al Diffuse GI Render Target.  Aunque redujo levemente el ruido, al mismo tiempo, casi sin cambiar los detalles de las texturas de la pared, decid√≠ que esta mejora no val√≠a los milisegundos adicionales gastados. <br><br><h3>  Demo </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Puedes jugar la demo aqu√≠</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444516/">https://habr.com/ru/post/444516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444502/index.html">¬øLa criptograf√≠a cu√°ntica es realmente confiable?</a></li>
<li><a href="../444504/index.html">Usando el directorio del paquete local en Python ahora</a></li>
<li><a href="../444508/index.html">C√≥mo creamos PHP 7 el doble de r√°pido que PHP 5. Parte 1: optimizaci√≥n de estructuras de datos</a></li>
<li><a href="../444512/index.html">Crear una aplicaci√≥n gr√°fica para resolver el problema del curso del caballo.</a></li>
<li><a href="../444514/index.html">Seminario web "Seguridad del aprendizaje autom√°tico: problemas naturales de la inteligencia artificial"</a></li>
<li><a href="../444518/index.html">Hacia una teor√≠a fundamental de la conciencia.</a></li>
<li><a href="../444520/index.html">2. Check Point Getting Started R80.20. Arquitectura de soluciones</a></li>
<li><a href="../444522/index.html">Apocalipsis es cancelado</a></li>
<li><a href="../444524/index.html">Lambdas: de C ++ 11 a C ++ 20. Parte 1</a></li>
<li><a href="../444526/index.html">Pila DOTS: C ++ y C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>