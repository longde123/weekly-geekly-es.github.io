<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏴󠁧󠁢󠁥󠁮󠁧󠁿 👨🏼 🦓 مكتبة مولد جامع التعليمات البرمجية للميكروكونترولر AVR. الجزء 5 🚈 🤐 💌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="← الجزء 4. برمجة الأجهزة الطرفية والتعامل مع المقاطعات 
 مكتبة مولد المجمع كود ل AVR Microcontrollers 
 الجزء 5. تصميم تطبيقات متعددة الخيوط 


 في ال...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>مكتبة مولد جامع التعليمات البرمجية للميكروكونترولر AVR. الجزء 5</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464651/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">← الجزء 4. برمجة الأجهزة الطرفية والتعامل مع المقاطعات</a> </p><br><h2 id="biblioteka-generatora-assemblernogo-koda-dlya-mikrokontrollerov-avr" style=";text-align:right;direction:rtl">  مكتبة مولد المجمع كود ل AVR Microcontrollers </h2><br><h3 id="chast-5-proektirovanie-mnogopotochnyh-prilozheniy" style=";text-align:right;direction:rtl">  الجزء 5. تصميم تطبيقات متعددة الخيوط </h3><br><p style=";text-align:right;direction:rtl">  في الأجزاء السابقة من المقال ، قمنا بالتفصيل حول أساسيات البرمجة باستخدام المكتبة.  في الجزء السابق ، تعرفنا على تنفيذ المقاطعات والقيود التي قد تنشأ عند العمل معهم.  في هذا الجزء من المنشور ، سنناقش أحد الخيارات الممكنة لبرمجة العمليات الموازية باستخدام فئة <em>Parallel</em> .  يتيح استخدام هذه الفئة تبسيط عملية إنشاء التطبيقات التي يجب أن تتم فيها معالجة البيانات في عدة تدفقات برنامج مستقلة. </p><a name="habracut"></a><br><p style=";text-align:right;direction:rtl">  جميع أنظمة تعدد المهام للأنظمة أحادية النواة متشابهة مع بعضها البعض.  يتم تطبيق تعدد العمليات من خلال عمل المرسل ، الذي يخصص فترة زمنية لكل خيط ، وعندما ينتهي ، فإنه يتحكم ويمنح التحكم في الخيط التالي.  يكمن الاختلاف بين التطبيقات المختلفة في التفاصيل فقط ، لذلك سنتناول بمزيد من التفصيل بشكل رئيسي الميزات المحددة لهذا التطبيق. </p><br><p style=";text-align:right;direction:rtl">  وحدة تنفيذ العملية في الخيط هي المهمة.  يمكن أن يوجد عدد غير محدود من المهام في النظام ، ولكن في أي وقت معين لا يمكن تنشيط سوى عدد معين منها ، مقيدًا بعدد مهام سير العمل في المرسل.  في هذا التطبيق ، يتم تحديد عدد مهام سير العمل في مُنشئ المدير ولا يمكن تغييره لاحقًا.  في هذه العملية ، يمكن لمؤشرات الترابط القيام بالمهام أو البقاء مجانًا.  بخلاف الحلول الأخرى ، لا يقوم <em>Parallel</em> Manager بتبديل المهام.  لمهمة إعادة التحكم إلى المرسل ، يجب إدخال الأوامر المناسبة في الكود.  وبالتالي ، فإن مسؤولية مدة الفاصل الزمني في المهمة تقع على عاتق المبرمج ، الذي يتعين عليه إدراج أوامر المقاطعة في أماكن معينة في الكود إذا كانت المهمة تستغرق وقتًا طويلاً ، وكذلك تحديد سلوك سلسلة الرسائل عند الانتهاء من المهمة.  تتمثل ميزة هذا الأسلوب في أن المبرمج يتحكم في نقاط التبديل بين المهام ، مما يسمح لك بتحسين رمز الحفظ / الاستعادة بشكل كبير عند التبديل بين المهام ، وكذلك التخلص من معظم المشكلات المتعلقة بالوصول الآمن إلى البيانات. </p><br><p style=";text-align:right;direction:rtl">  للتحكم في تنفيذ المهام قيد التشغيل ، يتم استخدام فئة <em>إشارة</em> خاصة.  الإشارة متغيرة قليلاً ، يتم استخدام الإعداد الخاص بها كإشارة تمكين لبدء مهمة في دفق.  يمكن تعيين قيم الإشارة إما يدويًا أو بواسطة حدث مرتبط بهذه الإشارة. </p><br><p style=";text-align:right;direction:rtl">  تتم إعادة تعيين الإشارة عندما يتم تنشيط المهمة بواسطة المرسل أو يمكن تنفيذها برمجيًا. </p><br><p style=";text-align:right;direction:rtl">  يمكن أن تكون المهام في النظام في الحالات التالية: </p><br><p style=";text-align:right;direction:rtl">  <strong>غير نشط</strong> - الحالة الأولية لجميع المهام.  المهمة لا تشغل التحكم في التدفق ولا يتم نقل التنفيذ.  العودة إلى هذه الحالة للمهام تفعيلها يحدث عند الانتهاء من الأمر. </p><br><p style=";text-align:right;direction:rtl">  <strong>تم التنشيط</strong> - الحالة التي تقع فيها المهمة بعد التنشيط.  تربط عملية التنشيط مهمة بخيط التنفيذ وإشارة التنشيط.  يقوم المدير باستقصاء مؤشرات الترابط وبدء المهمة في حالة تنشيط إشارة المهمة. </p><br><p style=";text-align:right;direction:rtl">  <strong>محظور</strong> - عند تنشيط المهمة ، قد يتم بالفعل تعيين إشارة إليها كإشارة ، والتي يتم استخدامها بالفعل للتحكم في سلسلة رسائل أخرى.  في هذه الحالة ، لتجنب الغموض في سلوك البرنامج ، تنتقل المهمة التي تم تنشيطها إلى الحالة المقفلة.  في هذه الحالة ، تشغل المهمة مؤشر الترابط ، لكن لا يمكنها تلقي التحكم ، حتى إذا تم تنشيط الإشارة الخاصة بها.  عند الانتهاء من المهام أو عند تغيير إشارة التنشيط ، يقوم المرسل بفحص حالة المهام في سلاسل الرسائل وتغييرها.  إذا كانت مؤشرات الترابط قد حظرت المهام التي تتطابق الإشارة مع الإشارة التي تم إصدارها ، فسيتم تنشيط أول إشارة تم العثور عليها.  إذا لزم الأمر ، يمكن للمبرمج قفل المهام وفتحها بشكل مستقل ، استنادًا إلى المنطق المطلوب للبرنامج. </p><br><p style=";text-align:right;direction:rtl">  <strong>الانتظار</strong> - الحالة التي تكون فيها المهمة بعد تنفيذ أمر <em>التأخير</em> .  في هذه الحالة ، لا تتلقى المهمة التحكم حتى يتم انقضاء الفاصل الزمني المطلوب.  في الفئة <em>Parallel</em> ، تُستخدم المقاطعات 16 بتنسيق WDT للتحكم في التأخير ، مما يسمح بعدم شغل أجهزة ضبط الوقت لاحتياجات النظام.  في حالة احتياجك إلى مزيد من الاستقرار أو الدقة على فترات زمنية صغيرة ، بدلاً من " <em>تأخير" ،</em> يمكنك استخدام التنشيط بواسطة إشارات المؤقت.  يجب ألا يغيب عن البال أن دقة التأخير ستظل منخفضة وستتقلب في نطاق <em>"وقت استجابة المرسل" - "أقصى فترة زمنية للوقت في وقت استجابة النظام + المرسل"</em> .  بالنسبة للمهام ذات نطاقات زمنية محددة ، يجب عليك استخدام الوضع المختلط ، حيث يعمل المؤقت ، الذي لا يُستخدم في فئة <em>Parallel</em> ، بشكل مستقل عن تدفق المهام ويعالج الفواصل الزمنية في وضع المقاطعة الخالص. </p><br><p style=";text-align:right;direction:rtl">  كل مهمة تنفذ في موضوع هي عملية معزولة.  يستلزم ذلك تحديد نوعين من البيانات: البيانات المحلية لتيار ما ، والتي يجب أن تكون مرئية وتغييرها فقط في إطار هذا التدفق ، والبيانات العالمية للتبادل بين التدفقات والوصول إلى الموارد المشتركة.  في إطار هذا التطبيق ، يتم إنشاء البيانات العالمية بواسطة أوامر تم اعتبارها مسبقًا على مستوى الجهاز.  لإنشاء متغيرات مهمة محلية ، يجب إنشاؤها باستخدام طرق من فئة المهمة.  يكون سلوك متغير المهمة المحلي كما يلي: عند مقاطعة مهمة قبل نقل التحكم إلى المرسل ، يتم تخزين جميع متغيرات السجل المحلي في ذاكرة الدفق.  عند إرجاع التحكم ، تتم استعادة متغيرات السجل المحلي قبل تنفيذ الأمر التالي. <br>  فئة مع واجهة <em>IHeap</em> المرتبطة خاصية <em>Heap</em> للفئة <em>Parallel</em> مسؤولة عن تخزين البيانات المحلية من الدفق.  إن أبسط تطبيق لهذه الفئة هو <em>StaticHeap</em> ، الذي ينفذ التخصيص الثابت لنفس كتل الذاكرة لكل خيط.  في حالة وجود <em>فرق</em> كبير بين المهام وفقًا لمتطلبات كمية البيانات المحلية ، يمكنك استخدام <em>DynamicHeap</em> ، والذي يسمح لك بتحديد حجم الذاكرة المحلية بشكل فردي لكل مهمة.  من الواضح أن النفقات العامة للعمل مع ذاكرة الدفق في هذه الحالة ستكون أعلى بكثير. </p><br><p style=";text-align:right;direction:rtl">  الآن ، دعونا نلقي نظرة فاحصة على بناء جملة الفصل باستخدام دفقين كمثال ، حيث يقوم كل منهما بتبديل إخراج منفذ منفصل بشكل مستقل. </p><br><pre style=";text-align:right;direction:rtl"><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328 { FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>, CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; m.PortB.Direction(<span class="hljs-number"><span class="hljs-number">0x07</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit1 = m.PortB[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit2 = m.PortB[<span class="hljs-number"><span class="hljs-number">2</span></span>]; m.PortB.Activate(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">2</span></span>); tasks.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(tasks, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit1.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">32</span></span>); tsk.TaskContinue(loop); },<span class="hljs-string"><span class="hljs-string">"Task1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit2.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">48</span></span>); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"Task2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ca = tasks.ContinuousActivate(tasks.AlwaysOn, t1); tasks.ActivateNext(ca, tasks.AlwaysOn, t2); ca.Dispose(); m.EnableInterrupt(); tasks.Loop();</code> </pre> <br><p style=";text-align:right;direction:rtl">  الخطوط العليا للبرنامج مألوفة لك بالفعل.  في نفوسهم ، نحدد نوع وحدة التحكم ونخصص البتات الأولى والثانية للمنفذ B كمخرج.  بعد ذلك ، يتم تهيئة متغير من فئة <em>Parallel</em> ، حيث نحدد في المعلمة الثانية الحد الأقصى لعدد سلاسل عمليات التنفيذ.  في السطر التالي ، نخصص الذاكرة لاستيعاب التدفقات المتغيرة المحلية.  لدينا مهام متساوية ، لذلك نستخدم <em>StaticHeap</em> .  الكتلة التالية من التعليمات البرمجية هي تعريف المهمة.  في ذلك ، نحدد مهمتين متطابقة تقريبا.  الفرق الوحيد هو منفذ التحكم ومقدار التأخير.  للعمل مع كائنات المهمة المحلية ، يتم تمرير مؤشر إلى <em>tsk</em> المهمة المحلية إلى <em>كتلة رمز</em> المهمة.  نص المهمة في حد ذاته بسيط للغاية: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يتم إنشاء تسمية محلية لتنظيم دورة التبديل لانهائية </li><li style=";text-align:right;direction:rtl">  يتم عكس حالة المنفذ </li><li style=";text-align:right;direction:rtl">  يتم إرجاع التحكم إلى المرسل ، والمهمة تنتقل إلى حالة الانتظار لعدد محدد من المللي ثانية </li><li style=";text-align:right;direction:rtl">  يتم تعيين مؤشر الإرجاع على كتلة بداية الكتلة ويتم إرجاع التحكم إلى المرسل. <br>  من الواضح ، في مثال ملموس ، يمكن استبدال الأمر الأخير بأمر عادي للانتقال إلى بداية الكتلة وإعطاءها في المثال فقط لغرض إظهارها.  إذا رغبت في ذلك ، يمكن توسيع المثال بسهولة للتحكم في عدد كبير من الاستنتاجات ، عن طريق نسخ المهام وزيادة عدد مؤشرات الترابط. </li></ul><br><p style=";text-align:right;direction:rtl">  قائمة كاملة من أوامر إحباط المهمة لنقل التحكم إلى المرسل هي كما يلي <br>  <strong>AWAIT (إشارة)</strong> - يحفظ الدفق جميع المتغيرات في ذاكرة الدفق وينقل التحكم إلى المرسل.  في المرة التالية التي يتم فيها تنشيط الدفق ، تتم استعادة المتغيرات ويستمر التنفيذ ، بدءًا من التعليمة التالية بعد <em>AWAIT</em> .  تم تصميم الأمر لتقسيم المهمة إلى فترات زمنية ولتنفيذ آلة الحالة وفقًا لمخطط <em>الإشارة → المعالجة 1 → الإشارة → المعالجة 2</em> ، إلخ. </p><br><p style=";text-align:right;direction:rtl">  قد يكون للأمر AWAIT إشارة كمعلمة اختيارية.  إذا كانت المعلمة فارغة ، يتم حفظ إشارة التنشيط.  إذا تم تحديده في المعلمة ، فسيتم إجراء جميع استدعاءات المهام اللاحقة عند تنشيط الإشارة المحددة ، وفقد الاتصال مع الإشارة السابقة. </p><br><p style=";text-align:right;direction:rtl">  <strong>TaskContinue (تسمية ، إشارة)</strong> - الأمر ينهي الدفق ويعطي السيطرة على المرسل دون حفظ المتغيرات.  في المرة التالية التي يتم فيها تنشيط الدفق ، يتم نقل التحكم إلى ملصق <em>التسمية</em> .  تسمح لك معلمة <em>الإشارة</em> الاختيارية بتجاوز إشارة تنشيط الدفق للمكالمة التالية.  إذا لم يتم تحديد ذلك ، فإن الإشارة تظل كما هي.  يمكن استخدام أمر بدون تحديد إشارة لتنظيم دورات داخل مهمة واحدة ، حيث يتم تنفيذ كل دورة في فترة زمنية منفصلة.  يمكن استخدامه أيضًا لتعيين مهمة جديدة لمؤشر الترابط الحالي بعد إكمال المهمة السابقة.  الاستفادة من هذا النهج مقارنة مع دورة <em>تحرير سلسلة من المواضيع → تسليط الضوء على تيار</em> هو برنامج أكثر كفاءة.  يؤدي استخدام <em>TaskContinue إلى</em> إلغاء الحاجة إلى قيام المدير بالبحث عن مؤشر ترابط مجاني في التجمع ويضمن وجود أخطاء عند محاولة تخصيص <em>سلاسل الرسائل</em> في حالة عدم وجود <em>سلاسل رسائل</em> مجانية. </p><br><p style=";text-align:right;direction:rtl">  <strong>TaskEnd ()</strong> - مسح الدفق بعد اكتمال المهمة.  تنتهي المهمة ، ويتم تحرير مؤشر الترابط ، ويمكن استخدامه لتعيين مهمة جديدة باستخدام الأمر <em>تنشيط</em> . </p><br><p style=";text-align:right;direction:rtl">  <strong>Delay (ms)</strong> - الدفق ، كما في حالة استخدام <em>AWAIT</em> ، يحفظ جميع المتغيرات في ذاكرة الدفق وينقل التحكم إلى المرسل.  في هذه الحالة ، يتم تسجيل قيمة التأخير بالمللي ثانية في رأس الدفق.  في حلقة المرسل ، في حالة وجود قيمة غير صفرية في حقل التأخير ، لا يتم تنشيط التدفق.  يتم تغيير القيم في حقل التأخير لجميع التدفقات عن طريق مقاطعة مؤقت WDT كل 16 مللي ثانية.  عند الوصول إلى قيمة الصفر ، تتم إزالة حظر التنفيذ وتعيين إشارة تنشيط الدفق.  يتم تخزين فقط قيمة البايت الواحد للتأخير في الرأس ، مما يعطي نطاقًا ضيقًا نسبيًا من التأخيرات المحتملة ، وبالتالي ، فإن تطبيق <em>Delay ()</em> ينشئ حلقة داخلية باستخدام متغيرات الدفق المحلي. <br>  يتم تنفيذ تنشيط الأوامر في المثال باستخدام أوامر <em>ContinuousActivate</em> و <em>ActivateNext</em> .  هذا هو نوع خاص من تنشيط المهمة الأولية عند بدء التشغيل.  في مرحلة التنشيط الأولية ، نحن نضمن عدم وجود خيط مشغول واحد ، وبالتالي فإن عملية التنشيط لا تتطلب إجراء بحث أولي عن خيط مجاني لمهمة وتتيح لك تنشيط المهام بالتسلسل.  <em>يقوم ContinuousActivate</em> بتنشيط المهمة في مؤشر ترابط الصفر وإرجاع مؤشر إلى رأس مؤشر الترابط التالي ، وتستخدم الدالة <em>ActivateNext</em> هذا المؤشر لتنشيط المهام التالية في مؤشرات الترابط التسلسلية. </p><br><p style=";text-align:right;direction:rtl">  كإشارة تنشيط ، يستخدم المثال إشارة <em>AlwaysOn</em> .  هذه هي واحدة من إشارات النظام.  الغرض منه هو أن المهمة ستنفذ دائمًا ، لأن هذه هي الإشارة الوحيدة التي يتم تنشيطها دائمًا ولا تتم إعادة ضبطها عن طريق الاستخدام. </p><br><p style=";text-align:right;direction:rtl">  المثال ينتهي باستدعاء <em>حلقة</em> .  تبدأ هذه الوظيفة دورة المرسل ، لذلك يجب أن يكون هذا الأمر هو الأخير في الكود. </p><br><p style=";text-align:right;direction:rtl">  النظر في مثال آخر حيث استخدام المكتبة يمكن أن تبسط بشكل كبير هيكل التعليمات البرمجية.  فليكن جهاز تحكم مشروط يسجل إشارة تناظرية ويرسلها في شكل رمز HEX إلى الجهاز. </p><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cData = m.DREG(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outDigit = m.ARRAY(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chex = Const.String(<span class="hljs-string"><span class="hljs-string">"0123456789ABCDEF"</span></span>); m.ADC.Clock = eADCPrescaler.S64; m.ADC.ADCReserved = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; m.ADC.Source = eASource.ADC0; m.Usart.Baudrate = <span class="hljs-number"><span class="hljs-number">9600</span></span>; m.Usart.FrameFormat = eUartFrame.U8N1; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> os = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">4</span></span>); os.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(os, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ADS = os.AddSignal(m.ADC.Handler, () =&gt; m.ADC.Data(cData)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trm = os.AddSignal(m.Usart.TXC_Handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> starts = os.AddLocker(); os.PrepareSignals(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t0 = os.CreateTask((tsk) =&gt; { m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r, l) =&gt; { m.ADC.ConvertAsync(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">500</span></span>); }); }, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mref = m.ROMPTR(); mref.Load(chex); m.TempL.Load(cData.High); m.TempL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">0</span></span>]); mref.Load(chex); m.TempL.Load(cData.High); m.TempL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">1</span></span>]); mref.Load(chex); m.TempL.Load(cData.Low); m.TempL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">2</span></span>]); mref.Load(chex); m.TempL.Load(cData.Low); m.TempL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">3</span></span>]); starts.Set(); tsk.TaskContinue(loop); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); trm.Clear(); m.TempL.Load(<span class="hljs-string"><span class="hljs-string">'0'</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(trm); m.TempL.Load(<span class="hljs-string"><span class="hljs-string">'x'</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">0</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">1</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">2</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">3</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.Load(<span class="hljs-number"><span class="hljs-number">13</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.Load(<span class="hljs-number"><span class="hljs-number">10</span></span>); m.Usart.Transmit(m.TempL); tsk.TaskContinue(loop, starts); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = os.ContinuousActivate(os.AlwaysOn, t0); os.ActivateNext(p, ADS, t1); os.ActivateNext(p, starts, t2); m.ADC.Activate(); m.Usart.Activate(); m.EnableInterrupt(); os.Loop();</code> </pre> <br><p style=";text-align:right;direction:rtl">  هذا لا يعني أننا رأينا الكثير من الأشياء الجديدة هنا ، ولكن يمكنك رؤية شيء مثير للاهتمام في هذا الرمز. </p><br><p style=";text-align:right;direction:rtl">  في هذا المثال ، يتم ذكر ADC (محول تمثيلي إلى رقمي) أولاً.  تم تصميم هذا الجهاز المحيطي لتحويل جهد إشارة الدخل إلى رمز رقمي.  يتم تشغيل دورة التحويل بواسطة وظيفة <em>ConvertAsync</em> ، والتي تبدأ العملية فقط دون انتظار النتيجة.  عند اكتمال التحويل ، ينشئ ADC مقاطعة ينشط إشارة <em>adcSig</em> .  انتبه لتعريف إشارة <em>adcSig</em> .  بالإضافة إلى مؤشر المقاطعة ، فإنه يحتوي أيضًا على كتلة رمز لتخزين القيم من سجل بيانات ADC.  يجب وضع كل الرموز التي يُفضل تنفيذها فور حدوث المقاطعة (على سبيل المثال ، قراءة البيانات من سجلات الجهاز) في هذا المكان. <br>  تتمثل مهمة <em>التحويل</em> في تحويل رمز جهد ثنائي إلى تمثيل سداسي عشري مكون من أربعة أحرف للمحطة الشرطية الخاصة بنا.  يمكن أن نلاحظ هنا استخدام الوظائف لوصف الأجزاء المكررة لتقليل حجم الكود المصدري واستخدام سلسلة ثابتة لتحويل البيانات. </p><br><p style=";text-align:right;direction:rtl">  تعد مشكلة <em>الإرسال</em> مثيرة للاهتمام من وجهة نظر تنفيذ الإخراج المنسق لسلسلة يتم فيها دمج إخراج البيانات الثابتة والديناميكية.  لا يمكن اعتبار الآلية نفسها مثالية ؛ بل هي دليل على إمكانيات إدارة المعالجات.  هنا يمكنك أيضًا الانتباه إلى إعادة تعريف إشارة التنشيط أثناء التنفيذ ، مما يؤدي إلى تغيير إشارة التنشيط من <em>التحويل</em> إلى <em>TxS</em> والعكس. </p><br><p style=";text-align:right;direction:rtl">  من أجل فهم أفضل ، نصف خوارزمية البرنامج بالكلمات. </p><br><p style=";text-align:right;direction:rtl">  في الحالة الأولية ، أطلقنا ثلاث مهام.  اثنتان منها لديهما إشارات غير نشطة ، حيث <em>يتم</em> تنشيط إشارة مهمة <em>التحويل (adcSig)</em> في نهاية دورة القراءة للإشارة التناظرية ، ويتم <em>تنشيط ConvS</em> لمهمة <em>الإرسال</em> بواسطة رمز لم يتم تنفيذه بعد.  نتيجة لذلك ، ستكون المهمة الأولى التي يتم إطلاقها بعد الإطلاق هي القياس.  يبدأ رمز هذه المهمة في دورة تحويل ADC ، وبعدها تنتقل مهمة 500 مللي ثانية إلى دورة الانتظار.  في نهاية دورة التحويل ، يتم <em>تنشيط</em> علامة <em>adcSig</em> ، والتي تقوم بتشغيل مهمة <em>التحويل</em> .  في هذه المهمة ، يتم تنفيذ دورة لتحويل البيانات المستلمة إلى سلسلة.  قبل إنهاء المهمة ، نقوم بتنشيط علامة <em>ConvS</em> ، مع توضيح أن لدينا بيانات جديدة لإرسالها إلى الجهاز.  يقوم أمر الخروج بإعادة ضبط نقطة الإرجاع إلى بداية المهمة ويمنح السيطرة على المرسل.  تسمح <em>مجموعة</em> علم <em>ConvS</em> بنقل التحكم إلى مهمة <em>النقل</em> .  بعد إرسال البايت الأول من التسلسل ، تتغير إشارة التنشيط في المهمة إلى <em>TxS</em> .  نتيجة لذلك ، بعد اكتمال نقل البايت ، سيتم استدعاء مهمة النقل مرة أخرى ، مما سيؤدي إلى نقل البايت التالي.  بعد إرسال البايت الأخير من التسلسل ، تُرجع المهمة <em>إشارة</em> تنشيط <em>ConvS</em> وتعيد <em>ضبط</em> نقطة الإرجاع إلى بداية المهمة.  اكتمال الدورة.  ستبدأ الدورة التالية عندما تكمل مهمة القياس فترة الانتظار وتنشط دورة القياس التالية. </p><br><p style=";text-align:right;direction:rtl">  في جميع أنظمة تعدد المهام تقريبًا ، هناك مفهوم قوائم الانتظار للتفاعل بين مؤشرات الترابط.  لقد توصلنا بالفعل إلى أنه نظرًا لأن التبديل بين المهام في هذا النظام هو عملية يتم التحكم فيها بالكامل ، فإن استخدام المتغيرات العالمية لتبادل البيانات بين المهام أمر ممكن تمامًا.  ومع ذلك ، هناك عدد من المهام حيث يكون هناك ما يبرر استخدام قوائم الانتظار.  لذلك ، لن نترك هذا الموضوع جانبا ونرى كيف يتم تنفيذه في المكتبة. </p><br><p style=";text-align:right;direction:rtl">  لتطبيق قائمة انتظار في برنامج ، من الأفضل استخدام فئة <em>RingBuff</em> .  يقوم الفصل ، كما يوحي الاسم ، بتنفيذ مخزن مؤقت للرنين باستخدام أوامر الكتابة والجلب.  يتم تنفيذ قراءة وكتابة البيانات بواسطة أوامر <em>القراءة</em> <em>والكتابة</em> .  أوامر القراءة والكتابة ليس لها أي معلمات.  يستخدم المخزن المؤقت متغير التسجيل المحدد في المُنشئ كمصدر / مستقبل للبيانات.  يتم الوصول إلى هذا المتغير من خلال فئة المعلمة <em>IOReg</em> .  يتم تحديد حالة المخزن المؤقت بواسطة <em>علامتي Ovf</em> و <em>Empty</em> ، مما يساعد على تحديد حالة الفائض أثناء الكتابة والفيضان أثناء القراءة.  بالإضافة إلى ذلك ، يتمتع الفصل بالقدرة على تحديد الكود الذي يتم تشغيله على أحداث تجاوز السعة / تجاوز السعة.  <em>RingBuff</em> لا يوجد لديه التبعيات على فئة <em>Parallel</em> ويمكن استخدامها بشكل منفصل.  القيد عند العمل مع الفصل هو السعة المسموح بها ، والتي يجب أن تكون مضاعفة لقدرة اثنين (8.16.32 ، إلخ) لأسباب تحسين الكود. </p><br><p style=";text-align:right;direction:rtl">  ويرد أدناه مثال على العمل مع الفصل. </p><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> io = m.REG(); <span class="hljs-comment"><span class="hljs-comment">//     16     io. var bf = new RingBuff(m, 16, io) { //    OnOverflow = () =&gt; { AVRASM.Comment("   "); }, OnEmpty = () =&gt; { AVRASM.Comment("   "); } }; var cntr = m.REG(); cntr.Load(16); //       m.LOOP(cntr, (r, l) =&gt; { cntr--; m.IFNOTEMPTY(l); },(r)=&gt; { //         //m.IF(bf.Ovf,()=&gt;{AVRASM.Comment("”)}; bf.IOReg.Load(cntr); //      bf.Write(); //    }); //     m.LOOP(cntr, (r, l) =&gt; { m.GO(l); }, (r) =&gt; { //         //m.IF(bf.Ovf,()=&gt;{AVRASM.Comment(" ”)}; bf.Read(); //       IOReg //    });</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  يختتم هذا الجزء نظرة عامة على ميزات المكتبة.  لسوء الحظ ، بقي عدد من الجوانب المتعلقة بقدرات المكتبة ، والتي لم يتم ذكرها حتى.  في المستقبل ، في حالة الاهتمام بالمشروع ، يتم تخطيط المقالات المخصصة لحل مشاكل محددة باستخدام المكتبة ووصفًا أكثر تفصيلًا للمشكلات المعقدة التي تتطلب منشورًا منفصلاً. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar464651/">https://habr.com/ru/post/ar464651/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar464641/index.html">كيفية إعداد PVS-Studio في Travis CI باستخدام مثال محاكي وحدة ألعاب PSP</a></li>
<li><a href="../ar464643/index.html">ليس مسحًا واحدًا أو كيفية إنشاء عملية إدارة الثغرات الأمنية في 9 خطوات</a></li>
<li><a href="../ar464645/index.html">كيفية تكوين PVS-Studio في Travis CI باستخدام محاكي وحدة ألعاب PSP كمثال</a></li>
<li><a href="../ar464647/index.html">جريدة هاري بوتر</a></li>
<li><a href="../ar464649/index.html">نظام تعاون المستندات لـ Zimbra Open-Source Edition</a></li>
<li><a href="../ar464655/index.html">كيف تغيرت الرواتب وشعبية لغات البرمجة على مدار العامين الماضيين</a></li>
<li><a href="../ar464657/index.html">عكس الهندسة الكهربائية كورنيش AM82TV</a></li>
<li><a href="../ar464659/index.html">أمان التطبيق أو كيفية تضمين الأمان في تطوير مخصص. تجربة شخصية في AGIMA</a></li>
<li><a href="../ar464661/index.html">لمن يعهد إلى تصميم إعادة المعدات التقنية ومرافق إعادة الإعمار</a></li>
<li><a href="../ar464665/index.html">التقسيم في SQL Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>