<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍍 🤮 💅🏼 LLVM IR dan Go 💯 🐦 👩🏼‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, kita akan melihat bagaimana membangun program Go, seperti kompiler atau penganalisa statis, yang berinteraksi dengan kerangka kerja ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>LLVM IR dan Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459704/">  Pada artikel ini, kita akan melihat bagaimana membangun program Go, seperti kompiler atau penganalisa statis, yang berinteraksi dengan kerangka kerja LLVM menggunakan bahasa assembly IR LLVM. <br><br>  <b>TL; DR</b> kami menulis perpustakaan untuk berinteraksi dengan LLVM IR di Go murni, lihat tautan ke kode dan contoh proyek. <br><a name="habracut"></a><br><h3>  Contoh sederhana tentang LLVM IR </h3><br>  (Bagi Anda yang akrab dengan LLVM IR dapat melompat ke bagian berikutnya). <br><br>  LLVM IR adalah representasi menengah tingkat rendah yang digunakan oleh kerangka kompilasi LLVM.  Anda dapat menganggap LLVM IR sebagai assembler independen platform dengan jumlah register lokal yang tak terbatas. <br><br>  Saat mendesain kompiler, ada keuntungan besar dalam mengkompilasi bahasa sumber ke dalam representasi perantara (IR, representasi perantara) alih-alih mengompilasinya menjadi arsitektur target (mis. X86). <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  Gagasan menggunakan bahasa perantara dalam kompiler tersebar luas.  GCC menggunakan GIMPLE, Roslyn menggunakan CIL, LLVM menggunakan LLVM IR. <br></div></div><br>  Karena banyak teknik optimasi yang umum (misalnya, menghapus kode yang tidak digunakan, mendistribusikan konstanta), lintasan optimasi ini dapat dilakukan secara langsung di tingkat IR dan digunakan oleh semua platform target. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  Dengan menggunakan bahasa perantara (IR) sehingga mengurangi jumlah kombinasi yang diperlukan untuk bahasa sumber n dan arsitektur target m (backends) dari n * m ke n + m. <br></div></div><br>  Dengan demikian, kompiler sering terdiri dari tiga bagian: frontend, middleland dan backend, masing-masing melakukan tugasnya sendiri, menerima input dan / atau memberikan output IR. <br><br><ul><li>  Frontend: mengkompilasi bahasa sumber di IR </li><li>  Middleland: mengoptimalkan IR </li><li>  Backend: mengkompilasi IR ke dalam kode mesin </li></ul><br><img src="https://habrastorage.org/webt/i_/pc/q6/i_pcq6eyhimm7drjixdnwrkog60.png"><br><br><h4>  Program sampel assembler LLVM IR </h4><br>  Untuk mendapatkan gambaran seperti apa assembler LLVM IR, pertimbangkan program berikut. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">2</span></span>*b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); }</code> </pre> <br>  Kami menggunakan Dentang dan mengkompilasi kode C di atas ke assembler LLVM IR. <br><br><div class="spoiler">  <b class="spoiler_title">Dentang</b> <div class="spoiler_text">  dentang -S -emit-llvm -o foo.ll foo.c. <br></div></div><br><pre> <code class="cpp hljs">define i32 @f(i32 %a, i32 %b) { ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">0</span></span> %<span class="hljs-number"><span class="hljs-number">1</span></span> = mul i32 <span class="hljs-number"><span class="hljs-number">2</span></span>, %b %<span class="hljs-number"><span class="hljs-number">2</span></span> = add i32 %a, %<span class="hljs-number"><span class="hljs-number">1</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">2</span></span> } define i32 @main() { ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">0</span></span> %<span class="hljs-number"><span class="hljs-number">1</span></span> = call i32 @f(i32 <span class="hljs-number"><span class="hljs-number">10</span></span>, i32 <span class="hljs-number"><span class="hljs-number">20</span></span>) ret i32 %<span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Melihat kode assembler LLVM IR di atas, kita dapat melihat beberapa fitur IR LLVM yang patut diperhatikan, yaitu: <br><br>  LLVM IR diketik secara statis (mis. Integer 32-bit berpotongan dengan tipe i32). <br><br>  Variabel lokal memiliki cakupan dalam fungsi (mis.,% 1 pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">main</a> berbeda dari% 1 pada @f). <br><br>  Tanpa nama (register sementara) menerima pengidentifikasi lokal (misalnya,% 1,% 2), dalam urutan menaik, di masing-masing fungsi.  Setiap fungsi dapat menggunakan jumlah register yang tidak terbatas (tidak terbatas pada 32 register tujuan umum).  Pengidentifikasi global (mis. @F) dan pengidentifikasi lokal (mis.% A,% 1) dibedakan dengan awalan (masing-masing @ dan%). <br><br>  Sebagian besar perintah melakukan apa yang Anda harapkan, jadi mul melakukan perkalian, menambahkan penambahan, dll <br><br>  Komentar dimulai dengan, seperti biasa dalam bahasa majelis. <br><br><h4>  LLMV IR Assembler Structure </h4><br>  Isi file perakitan IR LLVM adalah modul.  Modul ini berisi deklarasi tingkat tinggi, seperti variabel dan fungsi global. <br><br>  Deklarasi fungsi tidak mengandung blok dasar, definisi fungsi berisi satu atau lebih blok dasar (mis., Badan fungsi). <br><br>  Contoh yang lebih terperinci dari modul IR LLVM diberikan di bawah ini.  termasuk definisi variabel global @foo dan definisi fungsi @f yang berisi tiga blok dasar (% entri,% blok_1 dan% blok_2). <br><br><pre> <code class="cpp hljs">;  ,  <span class="hljs-number"><span class="hljs-number">32</span></span>-  <span class="hljs-number"><span class="hljs-number">21</span></span> @foo = global i32 <span class="hljs-number"><span class="hljs-number">21</span></span> ; f  <span class="hljs-number"><span class="hljs-number">42</span></span>,   cond ,  <span class="hljs-number"><span class="hljs-number">0</span></span>    define i32 @f(i1 %cond) { ;       ,     ;      entry: ;     br    block_1,  %cond ; ,   block_2   . br i1 %cond, label %block_1, label %block_2 ;     ,    ,     block_1: %tmp = load i32, i32* @foo %result = mul i32 %tmp, <span class="hljs-number"><span class="hljs-number">2</span></span> ret i32 %result ;     ,     ,     block_2: ret i32 <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><h4>  Unit dasar </h4><br>  Unit dasar adalah urutan perintah yang bukan perintah transisi (perintah terminasi).  Gagasan kunci dari unit dasar adalah bahwa jika satu perintah dari unit dasar dijalankan, maka semua perintah lain dari unit dasar dijalankan.  Ini menyederhanakan analisis aliran eksekusi. <br><br><h4>  Tim </h4><br>  Perintah yang bukan perintah lompat biasanya melakukan perhitungan atau akses memori (misalnya, tambahkan, muat), tetapi tidak mengubah aliran kontrol program. <br><br><h4>  Tim pemutusan hubungan kerja </h4><br>  Perintah terminasi terletak di akhir setiap unit dasar, dan menentukan di mana transisi akan dilakukan pada akhir unit dasar.  Sebagai contoh, perintah ret terminating mengembalikan aliran kontrol dari fungsi pemanggilan, dan br melakukan transisi, kondisional atau tanpa syarat. <br><br><h4>  Formulir SSA </h4><br>  Satu properti yang sangat penting dari LLVM IR adalah bahwa ia ditulis dalam bentuk SSA (Static Single Assignment), yang pada dasarnya berarti bahwa setiap register hanya ditugaskan satu kali.  Properti ini menyederhanakan analisis statis aliran data. <br><br>  Untuk memproses variabel yang ditetapkan lebih dari satu kali dalam kode sumber asli, perintah phi digunakan dalam LLVM IR.  Perintah phi pada dasarnya mengembalikan nilai tunggal dari satu set nilai input, tergantung pada jalur eksekusi mana perintah ini tercapai.  Dengan demikian, setiap nilai input dikaitkan dengan blok input sebelumnya. <br><br>  Sebagai contoh, pertimbangkan fungsi IR LLVM berikut: <br><br><pre> <code class="cpp hljs">define i32 @f(i32 %a) { ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> i32 %a, label %<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [ i32 <span class="hljs-number"><span class="hljs-number">42</span></span>, label %case1 ] case1: %x<span class="hljs-number"><span class="hljs-number">.1</span></span> = mul i32 %a, <span class="hljs-number"><span class="hljs-number">2</span></span> br label %ret <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: %x<span class="hljs-number"><span class="hljs-number">.2</span></span> = mul i32 %a, <span class="hljs-number"><span class="hljs-number">3</span></span> br label %ret ret: %x<span class="hljs-number"><span class="hljs-number">.0</span></span> = phi i32 [ %x<span class="hljs-number"><span class="hljs-number">.2</span></span>, %<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> ], [ %x<span class="hljs-number"><span class="hljs-number">.1</span></span>, %case1 ] ret i32 %x<span class="hljs-number"><span class="hljs-number">.0</span></span> }</code> </pre> <br>  Perintah phi (juga kadang-kadang disebut simpul phi) dalam contoh di atas mensimulasikan berbagai penugasan menggunakan set nilai input yang mungkin, satu untuk setiap jalur yang mungkin dalam utas eksekusi, yang mengarah ke penugasan variabel.  Misalnya, salah satu jalur terkait dalam aliran data adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/ng/zd/h3/ngzdh3seqkmiww9rsn9as7czeg4.png"><br><br>  Secara umum, ketika mengembangkan kompiler yang mengubah kode sumber ke LLVM IR, semua variabel kode sumber lokal dapat dikonversi ke bentuk SSA, dengan pengecualian variabel yang alamatnya diambil. <br><br>  Untuk menyederhanakan implementasi frontend LLVM, direkomendasikan untuk memodelkan variabel lokal dalam bahasa sumber sebagai variabel yang dialokasikan dalam memori (menggunakan alokasi), mensimulasikan tugas ke variabel lokal sebagai menulis ke memori, dan menggunakan variabel lokal sebagai dibaca dari memori.  Alasannya adalah bahwa itu bisa menjadi tugas nontrivial untuk secara langsung menerjemahkan bahasa sumber ke LLVM IR dalam bentuk SSA.  Selama akses memori mengikuti pola-pola tertentu, kita dapat mengandalkan pass optimasi mem2reg sebagai bagian dari LLVM untuk mengubah variabel lokal yang dialokasikan dalam memori menjadi register dalam bentuk SSA (menggunakan node phi jika diperlukan). <br><br><h3>  Perpustakaan LLVM IR on Go murni </h3><br>  Ada dua perpustakaan utama untuk bekerja dengan LLVM IR in Go: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://godoc.org/llvm.org/llvm/bindings/go/llvm</a> : binding LLVM resmi untuk bahasa Go. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/llir/llvm</a> : Pustaka Go yang bersih untuk berinteraksi dengan LLVM IR. <br><br>  Ikatan LLVM resmi untuk bahasa Go menggunakan Cgo untuk menyediakan akses ke API yang kaya dan kuat dari kerangka kerja penyusun LLVM, sementara proyek llir / llvm sepenuhnya ditulis dalam Go dan menggunakan LLVM IR untuk berinteraksi dengan kerangka kerja LLVM. <br><br>  Artikel ini berfokus pada llir / llvm, tetapi dapat digeneralisasi untuk bekerja dengan perpustakaan lain. <br><br><h4>  Mengapa menulis perpustakaan baru? </h4><br>  Motivasi utama untuk mengembangkan perpustakaan Go yang bersih untuk berinteraksi dengan LLVM IR adalah membuat kompiler penulisan dan alat analisis statis, yang didasarkan pada kerangka kompilasi LLVM IR, tugas yang lebih menyenangkan.  Itu juga dipengaruhi oleh fakta bahwa waktu kompilasi suatu proyek berdasarkan ikatan LLVM resmi dengan Go dapat menjadi signifikan (terima kasih kepada @aykevl, penulis TinyGo, sekarang dimungkinkan untuk mempercepat kompilasi karena tautan dinamis, berbeda dengan versi standar LLVM 4). <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  Proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/aykevl/go-llvm</a> menyediakan binder Go untuk LLVM yang diinstal pada sistem. <br></div></div><br>  Motivasi besar lainnya adalah mencoba mengembangkan API Go dari awal.  Perbedaan utama antara API yang mengikat LLVM untuk Go dan llir / llvm adalah bagaimana nilai-nilai LLVM dimodelkan.  Dalam pengikat LLVM untuk Go, nilai-nilai LLVM dimodelkan sebagai tipe struktural beton, yang, pada dasarnya, berisi semua metode yang mungkin untuk semua kemungkinan nilai LLVM.  Pengalaman pribadi saya menggunakan API ini menunjukkan bahwa sulit untuk mengetahui bagian metode yang diizinkan untuk memanggil nilai tertentu.  Misalnya, untuk mendapatkan opcode instruksi, Anda memanggil metode InstructionOpcode, yang intuitif.  Namun, jika Anda memanggil metode Opcode, yang dirancang untuk mendapatkan opcode dari ekspresi konstan, Anda akan mendapatkan kesalahan runtime: “cast () argumen tipe tidak kompatibel!”  (Konversi argumen ke tipe yang tidak kompatibel). <br><br>  Perpustakaan llir / llvm dirancang untuk memeriksa jenis pada waktu kompilasi dan memastikan bahwa mereka digunakan dengan benar dengan sistem tipe Go.  Nilai LLVM di llir / llvm dimodelkan sebagai tipe antarmuka.  Pendekatan ini hanya menyediakan sekumpulan metode minimal, dibagikan oleh semua nilai, dan jika Anda ingin mengakses metode atau bidang tertentu, gunakan pengalihan tipe (seperti yang ditunjukkan dalam contoh di bawah). <br><br><h4>  Contoh penggunaan </h4><br>  Sekarang mari kita lihat beberapa contoh kegunaan khusus.  mari kita memiliki perpustakaan, tetapi apa yang harus kita lakukan dengan LLVM IR? <br><br>  Pertama, kita mungkin ingin mem-parsing LLVM IR yang dihasilkan oleh alat lain, seperti Dentang dan pengoptimal LLVM opt (lihat contoh input di bawah). <br><br>  Kedua, kami mungkin ingin memproses LLVM IR dan melakukan analisis kami sendiri tentang itu, atau membuat melewati optimasi kami sendiri, atau menerapkan juru bahasa, atau kompiler JIT (lihat contoh analisis di bawah). <br><br>  Ketiga, kami mungkin ingin menghasilkan LLVM IR, yang akan menjadi input untuk instrumen lain.  Pendekatan ini dapat dipilih jika kita mengembangkan antarmuka untuk bahasa pemrograman baru (lihat contoh kode keluaran di bawah). <br><br>  Contoh Kode Masukan - LLVM IR Parsing <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       LLVM IR,    //     package main import ( "fmt" "github.com/llir/llvm/asm" ) func main() { //    LLVM IR. m, err := asm.ParseFile("foo.ll") if err != nil { panic(err) } // ,    LLVM IR. // Print LLVM IR module. fmt.Println(m) }</span></span></code> </pre> <br>  Contoh Analisis - Memproses LLVM IR <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      LLVM IR     //  Graphviz DOT package main import ( "bytes" "fmt" "io/ioutil" "github.com/llir/llvm/asm" "github.com/llir/llvm/ir" ) func main() { //    LLVM IR. m, err := asm.ParseFile("foo.ll") if err != nil { panic(err) } //    . callgraph := genCallgraph(m) //      Graphviz DOT. if err := ioutil.WriteFile("callgraph.dot", callgraph, 0644); err != nil { panic(err) } } // genCallgraph      Graphviz DOT    LLVM IR func genCallgraph(m *ir.Module) []byte { buf := &amp;bytes.Buffer{} buf.WriteString("digraph {\n") //      for _, f := range m.Funcs { //   caller := f.Ident() fmt.Fprintf(buf, "\t%q\n", caller) //       for _, block := range f.Blocks { //   ,       . for _, inst := range block.Insts { //  .   call. switch inst := inst.(type) { case *ir.InstCall: callee := inst.Callee.Ident() //        . fmt.Fprintf(buf, "\t%q -&gt; %q\n", caller, callee) } } //     switch term := block.Term.(type) { case *ir.TermRet: //  - _ = term } } } buf.WriteString("}") return buf.Bytes() }</span></span></code> </pre> <br>  Contoh Kode Keluaran - LLVM IR Generation <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     LLVM IR,    C, //    . // // int abs(int x); // // int seed = 0; // // // ref: https://en.wikipedia.org/wiki/Linear_congruential_generator // // a = 0x15A4E35 // // c = 1 // int rand(void) { // seed = seed*0x15A4E35 + 1; // return abs(seed); // } package main import ( "fmt" "github.com/llir/llvm/ir" "github.com/llir/llvm/ir/constant" "github.com/llir/llvm/ir/types" ) func main() { //      i32 := types.I32 zero := constant.NewInt(i32, 0) a := constant.NewInt(i32, 0x15A4E35) //  PRNG. c := constant.NewInt(i32, 1) //  PRNG. //    LLVM IR. m := ir.NewModule() //         . // // int abs(int x); abs := m.NewFunc("abs", i32, ir.NewParam("x", i32)) //         . // // int seed = 0; seed := m.NewGlobalDef("seed", zero) //        . // // int rand(void) { ... } rand := m.NewFunc("rand", i32) //           `rand`. entry := rand.NewBlock("") //         . tmp1 := entry.NewLoad(seed) tmp2 := entry.NewMul(tmp1, a) tmp3 := entry.NewAdd(tmp2, c) entry.NewStore(tmp3, seed) tmp4 := entry.NewCall(abs, tmp3) entry.NewRet(tmp4) //   LLVM IR  . fmt.Println(m) }</span></span></code> </pre> <br><h3>  Kesimpulan </h3><br>  Pengembangan dan implementasi llir / llvm dilakukan dan dipimpin oleh komunitas kontributor yang tidak hanya menulis kode, tetapi juga memimpin diskusi, memasangkan sesi pemrograman, men-debug, membuat profil, dan menunjukkan rasa ingin tahu dalam proses pembelajaran. <br><br>  Salah satu bagian yang paling sulit dari proyek llir / llvm adalah pembangunan tata bahasa EBNF untuk LLVM IR, mencakup seluruh bahasa IR LLVM hingga versi LLVM 7.0.  Kesulitan di sini bukanlah dalam proses itu sendiri, tetapi pada kenyataan bahwa tidak ada tata bahasa yang diterbitkan secara resmi yang mencakup seluruh bahasa.  Beberapa komunitas open source telah mencoba mendefinisikan tata bahasa formal untuk assembler LLVM, tetapi mereka mencakup, sejauh yang kami tahu, hanya himpunan bagian dari bahasa. <br><br>  Grammar LLVM IR membuka jalan bagi proyek yang menarik.  Misalnya, generasi assembler IR LLVM yang valid secara sintaksis dapat digunakan untuk berbagai alat dan pustaka menggunakan LLVM IR, pendekatan yang sama digunakan di GoSmith.  Ini dapat digunakan untuk validasi silang dari proyek LLVM yang dilaksanakan dalam bahasa lain, serta memeriksa kerentanan dan bug implementasi. <br><br>  Masa depan luar biasa, selamat retas! <br><br><h3>  Referensi </h3><br>  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab yang</a> ditulis dengan sangat baik tentang LLVM, ditulis oleh Chris Lattner, penulis proyek LLVM awal, dalam buku "Arsitektur Aplikasi Sumber Terbuka". <br><br>  2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasikan bahasa dengan tutorial LLVM</a> - sering juga disebut Panduan Bahasa Kaleidoskop - menjelaskan secara rinci bagaimana mengimplementasikan bahasa pemrograman sederhana yang dikompilasi dalam LLVM IR.  Artikel ini menjelaskan semua tahapan utama penulisan frontend, termasuk penganalisis leksikal, pengurai, dan pembuatan kode. <br><br>  3. Bagi mereka yang tertarik untuk menulis kompiler dari bahasa input ke LLVM IR, buku " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemetaan Konstruksi Tingkat Tinggi ke LLVM IR</a> " direkomendasikan. <br><br>  Satu set slide yang baik adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LLVM, dalam Great Detail</a> , yang menjelaskan konsep-konsep penting dari LLVM IR, memberikan pengantar untuk LLVM C ++ API, dan menjelaskan beberapa bagian optimasi LLVM yang sangat berguna. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Binding Go resmi untuk LLVM</a> cocok untuk banyak proyek, mereka mewakili LLVM C API, kuat dan stabil. <br><br>  Tambahan yang baik untuk posting adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar LLVM in Go.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459704/">https://habr.com/ru/post/id459704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459688/index.html">Urbanisme di Tiongkok: Kurang Hipsters, Lebih Banyak Sains dan IT</a></li>
<li><a href="../id459692/index.html">Bagaimana kami menemukan modifikasi material yang bertentangan dengan prinsip kimia yang berlaku</a></li>
<li><a href="../id459694/index.html">Museum DataArt. Buka paket dan luncurkan Radio 86RK</a></li>
<li><a href="../id459696/index.html">Pemulihan Foto Berbasis AI</a></li>
<li><a href="../id459698/index.html">Bagaimana cara memaksa Oracle BI 12c untuk membuat variabel sesi sebanyak yang dibutuhkan programmer?</a></li>
<li><a href="../id459706/index.html">5 alasan mengapa Anda harus melupakan Redux dalam Bereaksi aplikasi</a></li>
<li><a href="../id459708/index.html">Desain Antarmuka Game. Brent Fox Tentang apa buku itu?</a></li>
<li><a href="../id459710/index.html">Selamat dari tabrakan langsung dan mengapa amnesia bukan seperti yang Anda pikirkan</a></li>
<li><a href="../id459712/index.html">Peretas Mommy di Pekerjaan Resmi: Apa yang Dilakukan Pentester</a></li>
<li><a href="../id459714/index.html">Mesin virtual pada ESP8266 untuk menjalankan game</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>