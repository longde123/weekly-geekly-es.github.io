<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸœ ğŸšœ âœ³ï¸ Apache Kafka et RabbitMQ: sÃ©mantique et garantie de livraison des messages ğŸ‘ğŸ¿ ğŸ¤¹ğŸ¾ ğŸ‘¨ğŸ¼â€ğŸ”§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons prÃ©parÃ© la traduction de la partie suivante de l'article en sÃ©rie, qui compare les fonctionnalitÃ©s d'Apache Kafka et de RabbitMQ. Cette pub...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Kafka et RabbitMQ: sÃ©mantique et garantie de livraison des messages</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/437446/"><img src="https://habrastorage.org/webt/9w/ar/yb/9warybopprmxno4cvxzuvswgexu.jpeg"><br><br>  Nous avons prÃ©parÃ© la traduction de la partie suivante de l'article en sÃ©rie, qui compare les fonctionnalitÃ©s d'Apache Kafka et de RabbitMQ.  Cette publication traite de la sÃ©mantique et des garanties de livraison des messages.  Veuillez noter que l'auteur a pris en compte Kafka jusqu'Ã  la version 0.10 incluse, et qu'il est apparu une seule fois dans la version 0.11.  NÃ©anmoins, l'article reste pertinent et regorge de points utiles d'un point de vue pratique. <br>  Parties prÃ©cÃ©dentes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premiÃ¨re</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxiÃ¨me</a> . <br><a name="habracut"></a><br>  RabbitMQ et Kafka offrent des garanties de livraison de messages fiables.  Les deux plates-formes offrent des garanties selon les principes de la Â«livraison unique au maximumÂ» et de la Â«livraison unique au moinsÂ», mais avec le principe de la Â«livraison strictement ponctuelleÂ», les garanties de Kafka s'appliquent selon un scÃ©nario trÃ¨s limitÃ©. <br><br>  Voyons d'abord ce que ces garanties signifient: <br><br><ul><li>  Livraison au plus une fois.  Cela signifie que le message ne peut pas Ãªtre remis plus d'une fois.  Cependant, le message peut Ãªtre perdu. </li><li>  Livraison au moins une fois.  Cela signifie que le message ne sera jamais perdu.  Dans ce cas, le message peut Ãªtre remis plusieurs fois. </li><li>  Livraison une seule fois.  Le Saint Graal des systÃ¨mes de messagerie.  Tous les messages sont remis strictement une fois. </li></ul><br>  Le mot Â«livraisonÂ» ici n'est probablement pas un terme exact.  Il serait plus exact de dire Â«traitementÂ».  Dans tous les cas, ce qui nous intÃ©resse maintenant, c'est de savoir si le consommateur peut traiter les messages et selon quel principe cela se produit: Â«pas plus d'unÂ», Â«au moins unÂ» ou Â«strictement une foisÂ».  Mais le mot Â«traitementÂ» complique la perception, et l'expression Â«remise selon le principeÂ« strictement une fois Â»Â» dans ce cas ne sera pas une dÃ©finition prÃ©cise, car il peut Ãªtre nÃ©cessaire de livrer le message deux fois afin de le traiter correctement une fois.  Si le destinataire s'est dÃ©connectÃ© pendant le traitement, le message doit Ãªtre envoyÃ© Ã  nouveau au nouveau destinataire. <br><br>  Le deuxiÃ¨me.  En discutant de la question du traitement des messages, nous arrivons au sujet des Ã©checs partiels, ce qui est un casse-tÃªte pour les dÃ©veloppeurs.  Le processus de traitement du message comporte plusieurs Ã©tapes.  Il consiste en des sessions de communication entre l'application et le systÃ¨me de messagerie au dÃ©but et Ã  la fin et l'application elle-mÃªme travaillant avec les donnÃ©es au milieu.  Les scÃ©narios de dÃ©faillance partielle d'une application doivent Ãªtre gÃ©rÃ©s par l'application elle-mÃªme.  Si les opÃ©rations effectuÃ©es sont entiÃ¨rement transactionnelles et que les rÃ©sultats sont formulÃ©s sur le principe du Â«tout ou rienÂ», des dÃ©faillances partielles dans la logique d'application peuvent Ãªtre Ã©vitÃ©es.  Mais souvent, de nombreuses Ã©tapes incluent l'interaction avec d'autres systÃ¨mes, oÃ¹ la transactionnalitÃ© est impossible.  Si nous incluons dans l'interaction les relations entre les systÃ¨mes de messagerie, les applications, le cache et la base de donnÃ©es, pouvons-nous garantir le traitement Â«une seule foisÂ»?  La rÃ©ponse est non. <br><br>  La stratÃ©gie Â«strictement uniqueÂ» se limite Ã  un scÃ©nario dans lequel le seul destinataire des messages traitÃ©s est la plateforme de messagerie elle-mÃªme, et cette plateforme elle-mÃªme fournit des transactions complÃ¨tes.  Dans ce scÃ©nario limitÃ©, vous pouvez traiter des messages, les Ã©crire, envoyer des signaux indiquant qu'ils ont Ã©tÃ© traitÃ©s dans le cadre d'une transaction effectuÃ©e sur le principe du Â«tout ou rienÂ».  Il est fourni par la bibliothÃ¨que Kafka Streams. <br><br>  Mais si le traitement des messages est toujours idempotent, vous pouvez Ã©viter d'avoir Ã  mettre en Å“uvre la stratÃ©gie Â«strictement une foisÂ» via les transactions.  Si le traitement final des messages est idempotent, vous pouvez vous inquiÃ©ter d'accepter les doublons.  Mais toutes les actions ne peuvent pas Ãªtre mises en Å“uvre de maniÃ¨re identique. <br><br>  <b>Alerte de bout en bout</b> <br><br>  Ce qui n'est reprÃ©sentÃ© sur aucun appareil de tous les systÃ¨mes de messagerie avec lesquels j'ai travaillÃ©, c'est la confirmation de bout en bout.  Ã‰tant donnÃ© qu'un message peut Ãªtre mis en file d'attente dans RabbitMQ, la notification de bout en bout n'a pas de sens.  Sur Kafka, de mÃªme, plusieurs groupes diffÃ©rents de destinataires peuvent lire simultanÃ©ment des informations Ã  partir d'un sujet.  D'aprÃ¨s mon expÃ©rience, les alertes de bout en bout sont ce que les personnes novices en matiÃ¨re de messagerie demandent souvent.  Dans de tels cas, il est prÃ©fÃ©rable d'expliquer immÃ©diatement que cela n'est pas possible. <br><br>  <b>ChaÃ®ne de responsabilitÃ©</b> <br><br>  Dans l'ensemble, les sources de messages ne peuvent pas savoir que leurs messages sont remis aux destinataires.  Ils peuvent seulement savoir que le systÃ¨me de messagerie a reÃ§u leurs messages et a pris la responsabilitÃ© d'assurer leur stockage et leur livraison en toute sÃ©curitÃ©.  Il existe une chaÃ®ne de responsabilitÃ© qui commence par la source, passe par le systÃ¨me de messagerie et se termine chez le destinataire.  Chacun doit remplir correctement ses fonctions et transmettre clairement le message au suivant.  Cela signifie que vous, en tant que dÃ©veloppeur, devez correctement concevoir vos applications afin d'Ã©viter la perte ou l'utilisation abusive des messages pendant qu'ils sont sous votre contrÃ´le. <br><br>  <b>ProcÃ©dure de transfert des messages</b> <br><br>  Cet article est principalement consacrÃ© Ã  la faÃ§on dont chaque plate-forme fournit des stratÃ©gies d'envoi Â«au moins uneÂ» et Â«pas plus d'uneÂ».  Mais il y a toujours un ordre de messagerie.  Dans les parties prÃ©cÃ©dentes de cette sÃ©rie, j'ai Ã©crit sur l'ordre dans lequel les messages sont envoyÃ©s et l'ordre dans lequel ils sont traitÃ©s, et je vous conseille de vous rÃ©fÃ©rer Ã  ces parties. <br><br>  En bref, RabbitMQ et Kafka offrent une garantie premier entrÃ©, premier sorti (FIFO).  RabbitMQ conserve cet ordre au niveau de la file d'attente et Kafka au niveau de la segmentation.  Les implications de telles dÃ©cisions de conception ont Ã©tÃ© discutÃ©es dans les articles prÃ©cÃ©dents. <br><br>  <b>Garanties de livraison dans RabbitMQ</b> <br><br>  Les garanties de livraison sont fournies: <br><br><ul><li>  fiabilitÃ© des messages - ils ne disparaissent pas lorsqu'ils sont stockÃ©s sur RabbitMQ; </li><li>  notifications de messages - RabbitMQ Ã©change des signaux avec les expÃ©diteurs et les destinataires. </li></ul><br><h4>  Ã‰lÃ©ments de fiabilitÃ© </h4><br>  <b>Mise en miroir de la file d'attente</b> <br><br>  Les files d'attente peuvent Ãªtre mises en miroir (rÃ©pliquÃ©es) sur de nombreux nÅ“uds (serveurs).  Chaque file d'attente a une file d'attente principale Ã  l'un des nÅ“uds.  Par exemple, il y a trois nÅ“uds, 10 files d'attente et deux rÃ©pliques par file d'attente.  10 files d'attente de contrÃ´le et 20 rÃ©pliques seront rÃ©parties sur trois nÅ“uds.  La rÃ©partition des files d'attente de contrÃ´le par nÅ“uds peut Ãªtre configurÃ©e.  En cas de gel d'un nÅ“ud: <br><br><ul><li>  au lieu de chaque file d'attente principale sur le nÅ“ud bloquÃ©, une rÃ©plique de cette file d'attente est fournie sur un autre nÅ“ud; </li><li>  de nouvelles rÃ©pliques sont crÃ©Ã©es sur d'autres nÅ“uds pour remplacer les rÃ©pliques perdues sur le nÅ“ud sortant, prenant ainsi en charge le facteur de rÃ©plication. </li></ul><br>  La question de la tolÃ©rance aux pannes sera discutÃ©e dans la prochaine partie de l'article. <br><br>  <b>Files d'attente approuvÃ©es</b> <br><br>  Il existe deux types de files d'attente sur RabbitMQ: fiable et non fiable.  Les files d'attente fiables sont Ã©crites sur le disque et enregistrÃ©es en cas de redÃ©marrage du nÅ“ud.  Lorsque le nÅ“ud dÃ©marre, ils sont remplacÃ©s. <br><br>  <b>Messages persistants</b> <br><br>  Si la file d'attente est fiable, cela ne signifie pas que ses messages sont enregistrÃ©s au redÃ©marrage du nÅ“ud.  Seuls les messages marquÃ©s comme persistants par l'expÃ©diteur seront rÃ©cupÃ©rÃ©s. <br><br>  Lorsque vous travaillez sur RabbitMQ, plus le message est fiable, plus les performances possibles sont faibles.  S'il existe un flux d'Ã©vÃ©nements en temps rÃ©el et qu'il n'est pas essentiel d'en perdre plusieurs ou un petit intervalle de temps du flux, il est prÃ©fÃ©rable de ne pas utiliser la rÃ©plication de file d'attente et de transmettre tous les messages comme instables.  Mais s'il n'est pas souhaitable de perdre des messages en raison d'un dysfonctionnement d'un nÅ“ud, il est prÃ©fÃ©rable d'utiliser des files d'attente fiables avec rÃ©plication et messages stables. <br><br><h4>  Notifications de message </h4><br>  <b>Messagerie</b> <br><br>  Les messages peuvent Ãªtre perdus ou dupliquÃ©s pendant la transmission.  Cela dÃ©pend du comportement de l'expÃ©diteur. <br><br>  <i>"TirÃ© et oubliÃ©"</i> <br><br>  La source peut dÃ©cider de ne pas demander de confirmation au destinataire (notification de rÃ©ception d'un message Ã  l'expÃ©diteur) et simplement envoyer le message automatiquement.  Les messages ne seront pas dupliquÃ©s, mais peuvent Ãªtre perdus (ce qui satisfait la stratÃ©gie Â«au maximum pour une livraison uniqueÂ»). <br><br>  <i>Confirmations Ã  l'expÃ©diteur</i> <br><br>  Lorsque l'expÃ©diteur ouvre un canal pour le courtier de files d'attente, il peut utiliser le mÃªme canal pour envoyer des confirmations.  Maintenant, en rÃ©ponse au message reÃ§u, le courtier de files d'attente doit fournir l'une des deux choses suivantes: <br><br><ul><li>  basic.ack.  Confirmation positive.  Le message est reÃ§u, la responsabilitÃ© en incombe dÃ©sormais Ã  RabbitMQ; </li><li>  basic.nack.  Confirmation nÃ©gative.  Quelque chose s'est produit et le message n'a pas Ã©tÃ© traitÃ©.  La responsabilitÃ© en demeure Ã  la source.  Si vous le souhaitez, il peut envoyer un message une deuxiÃ¨me fois. </li></ul><br>  En plus des notifications de livraison positives et nÃ©gatives, un message de retour de base est fourni.  Parfois, l'expÃ©diteur doit savoir non seulement que le message est arrivÃ© dans RabbitMQ, mais Ã©galement qu'il est vraiment tombÃ© dans une ou plusieurs files d'attente.  Il peut arriver que la source envoie un message au systÃ¨me d'Ã©change de rubriques, dans lequel le message n'est acheminÃ© vers aucune des files d'attente de remise.  Dans cette situation, le courtier rejette simplement le message.  Dans certains scÃ©narios, cela est normal, dans d'autres, la source doit savoir si le message a Ã©tÃ© rejetÃ© et poursuivre en consÃ©quence.  Vous pouvez dÃ©finir l'indicateur Â«ObligatoireÂ» pour les messages individuels, et si le message n'a Ã©tÃ© dÃ©fini dans aucune file d'attente de remise, basic.return sera renvoyÃ© Ã  l'expÃ©diteur. <br><br>  La source peut attendre la confirmation aprÃ¨s l'envoi de chaque message, mais cela rÃ©duira considÃ©rablement ses performances.  Au lieu de cela, les sources peuvent envoyer un flux constant de messages, fixant une limite au nombre de messages non acquittÃ©s.  Lorsque la limite de messages intermÃ©diaires est atteinte, l'envoi est suspendu jusqu'Ã  ce que toutes les confirmations soient reÃ§ues. <br><br>  Maintenant qu'il existe de nombreux messages en transit de l'expÃ©diteur vers RabbitMQ, les confirmations sont regroupÃ©es Ã  l'aide de l'indicateur multiple pour amÃ©liorer les performances.  Tous les messages envoyÃ©s sur le canal se voient attribuer une valeur entiÃ¨re Ã  augmentation monotone, le Â«numÃ©ro de sÃ©quenceÂ».  La notification d'un message comprend le numÃ©ro de sÃ©quence du message correspondant.  Et si en mÃªme temps la valeur est multiple = true, l'expÃ©diteur doit suivre les numÃ©ros de sÃ©quence de ses messages afin de savoir quels messages ont Ã©tÃ© livrÃ©s avec succÃ¨s et lesquels ne l'ont pas Ã©tÃ©.  J'ai Ã©crit un article dÃ©taillÃ© sur ce sujet. <br><br>  GrÃ¢ce aux confirmations, nous Ã©vitons la perte de messages des maniÃ¨res suivantes: <br><br><ul><li>  renvoyer des messages en cas de notification nÃ©gative; </li><li>  stockage continu des messages quelque part en cas de notification nÃ©gative ou de retour de base. </li></ul><br>  <i>Les transactions</i> <br><br>  Les transactions sont rarement utilisÃ©es dans RabbitMQ pour les raisons suivantes: <br><br><ul><li>  Garanties faibles.  Si les messages sont acheminÃ©s vers plusieurs files d'attente ou ont une icÃ´ne obligatoire, la continuitÃ© des transactions ne sera pas prise en charge; </li><li>  Faible productivitÃ©. </li></ul><br>  HonnÃªtement, je ne les ai jamais utilisÃ©s, ils ne donnent aucune garantie supplÃ©mentaire, Ã  l'exception des confirmations Ã  l'expÃ©diteur, et ne font qu'accroÃ®tre l'incertitude quant Ã  la faÃ§on d'interprÃ©ter l'accusÃ© de rÃ©ception des messages rÃ©sultant de l'achÃ¨vement des transactions. <br><br>  <i>Erreurs de communication / canal</i> <br><br>  Outre les notifications de rÃ©ception de messages, l'expÃ©diteur doit tenir compte des dÃ©faillances des outils de communication et des courtiers.  Ces deux facteurs entraÃ®nent la perte du canal de communication.  Avec la perte de canaux, la possibilitÃ© de recevoir toute notification de rÃ©ception de messages non encore reÃ§ue disparaÃ®t.  Ici, l'expÃ©diteur doit choisir entre le risque de perte de message et le risque de duplication. <br><br>  L'Ã©chec du courtier peut se produire lorsque le message Ã©tait dans la mÃ©moire tampon du systÃ¨me d'exploitation ou prÃ©traitÃ©, puis le message sera perdu.  Ou, peut-Ãªtre que le message Ã©tait en file d'attente, mais le courtier de messages est mort avant d'envoyer une confirmation.  Dans ce cas, le message sera remis avec succÃ¨s. <br><br>  De mÃªme, la dÃ©faillance des moyens de communication affecte la situation.  Une dÃ©faillance s'est-elle produite lors de la transmission du message?  Ou aprÃ¨s la mise en file d'attente du message, mais avant de recevoir une notification positive? <br><br>  L'expÃ©diteur ne peut pas dÃ©terminer cela, il doit donc choisir l'une des options suivantes: <br><br><ul><li>  Ne transmettez pas le message, crÃ©ant un risque de perte; </li><li>  renvoyez le message et crÃ©ez un risque de duplication. </li></ul><br>  Si de nombreux messages d'expÃ©diteur sont en transit, le problÃ¨me devient plus compliquÃ©.  La seule chose que l'expÃ©diteur peut faire est de donner un indice aux destinataires en ajoutant un en-tÃªte spÃ©cial au message, indiquant que le message est envoyÃ© une deuxiÃ¨me fois.  Les destinataires peuvent dÃ©cider de vÃ©rifier la prÃ©sence de ces en-tÃªtes dans les messages et, s'ils sont trouvÃ©s, de vÃ©rifier en outre la prÃ©sence de doublons dans les messages reÃ§us (si une telle vÃ©rification n'a pas Ã©tÃ© effectuÃ©e auparavant). <br><br><h4>  Destinataires </h4><br>  Les destinataires disposent de deux options pour recevoir des notifications: <br><br><ul><li>  pas de mode de notification; </li><li>  mode de notification manuelle. </li></ul><br>  <i>Pas de mode de notification</i> <br><br>  Il s'agit d'un mode de notifications automatiques.  Et il est dangereux.  Tout d'abord, car lorsqu'un message pÃ©nÃ¨tre dans votre application, il est supprimÃ© de la file d'attente.  Cela peut entraÃ®ner une perte de message si: <br><br><ul><li>  la connexion a Ã©tÃ© interrompue avant la rÃ©ception du message; </li><li>  le message est toujours dans le tampon interne et l'application a Ã©tÃ© dÃ©sactivÃ©e; </li><li>  Ã©chec du traitement des messages. </li></ul><br>  De plus, nous perdons des mÃ©canismes de contre-pression pour contrÃ´ler la qualitÃ© de la livraison des messages.  En dÃ©finissant le mode d'envoi des notifications manuellement, vous pouvez dÃ©finir une prÃ©lecture (ou dÃ©finir le niveau de services fournis, QoS) pour limiter le nombre unique de messages dont le systÃ¨me n'a pas encore confirmÃ© la rÃ©ception.  Sans cela, RabbitMQ envoie des messages aussi rapidement que la connexion le permet, et cela peut Ãªtre plus rapide que le rÃ©cepteur ne peut les traiter.  Par consÃ©quent, les tampons sont pleins et des erreurs de mÃ©moire se produisent. <br><br>  <i>Mode de notification manuelle</i> <br><br>  Le destinataire doit envoyer manuellement une notification de rÃ©ception de chaque message.  Il peut dÃ©finir une prÃ©lecture au cas oÃ¹ le nombre de messages serait supÃ©rieur Ã  un et traiter plusieurs messages en mÃªme temps.  Il peut dÃ©cider d'envoyer une notification pour chaque message, ou il peut appliquer l'indicateur multiple et envoyer plusieurs notifications Ã  la fois.  Le regroupement des notifications amÃ©liore les performances. <br><br>  Lorsque le destinataire ouvre le canal, les messages qui le traversent contiennent le paramÃ¨tre Delivery Tag, dont la valeur est un nombre entier croissant de faÃ§on monotone.  Il est inclus dans chaque notification de rÃ©ception et est utilisÃ© comme identifiant de message. <br><br>  Les notifications peuvent Ãªtre les suivantes: <br><br><ul><li>  basic.ack.  AprÃ¨s cela, RabbitMQ supprime le message de la file d'attente.  Le drapeau multiple peut Ãªtre appliquÃ© ici. </li><li>  basic.nack.  Le destinataire doit dÃ©finir un indicateur pour indiquer Ã  RabbitMQ s'il doit remettre le message en file d'attente.  Lors de la rÃ©initialisation, le message revient au dÃ©but de la file d'attente.  De lÃ , il est Ã  nouveau envoyÃ© au destinataire (mÃªme au mÃªme destinataire).  La notification basic.nack prend en charge l'indicateur multiple. </li><li>  basic.reject.  Identique Ã  basic.nack, mais ne prend pas en charge l'indicateur multiple. </li></ul><br>  Ainsi, sÃ©mantiquement basic.ack et basic.nack avec requeue = false sont identiques.  Les deux opÃ©rateurs signifient la suppression d'un message de la file d'attente. <br><br>  La question suivante est de savoir quand envoyer des notifications de rÃ©ception.  Si le message a Ã©tÃ© traitÃ© rapidement, vous souhaiterez peut-Ãªtre envoyer une notification immÃ©diatement aprÃ¨s avoir terminÃ© cette opÃ©ration (rÃ©ussie ou non).  Mais si le message Ã©tait dans la file d'attente RabbitMQ et que le traitement prend plusieurs minutes?  L'envoi d'une notification aprÃ¨s cela sera problÃ©matique, car si le canal se ferme, tous les messages auxquels il n'y a pas eu de notification seront renvoyÃ©s dans la file d'attente et l'envoi sera effectuÃ© une deuxiÃ¨me fois. <br><br>  <b>Erreur de connexion / message Broker</b> <br><br>  Si la connexion a Ã©tÃ© dÃ©connectÃ©e ou qu'une erreur s'est produite dans le courtier, aprÃ¨s quoi le canal cesse de fonctionner, tous les messages dont la rÃ©ception n'a pas Ã©tÃ© confirmÃ©e sont Ã  nouveau mis en file d'attente et transfÃ©rÃ©s.  C'est bon car cela empÃªche la perte de donnÃ©es, mais mauvais car cela provoque une duplication excessive. <br><br>  Plus le destinataire a longtemps des messages dont il n'a pas confirmÃ© la rÃ©ception, plus le risque de transmission est Ã©levÃ©.  Lorsqu'un message est renvoyÃ©, RabbitMQ pour l'indicateur de transfert est dÃ©fini sur true.  Pour cette raison, le destinataire a au moins une indication que le message a peut-Ãªtre dÃ©jÃ  Ã©tÃ© traitÃ©. <br><br>  <b>Idempotence</b> <br><br>  Si l'idempotence est requise et garantit qu'aucun message n'est perdu, une vÃ©rification en double ou d'autres schÃ©mas idempotents doivent Ãªtre intÃ©grÃ©s.  Si la vÃ©rification des messages en double est trop coÃ»teuse, vous pouvez appliquer une stratÃ©gie dans laquelle l'expÃ©diteur ajoute toujours un en-tÃªte spÃ©cial aux messages renvoyÃ©s et le destinataire vÃ©rifie la prÃ©sence d'un tel en-tÃªte et d'un indicateur de renvoi dans les messages reÃ§us. <br><br><h4>  Conclusion </h4><br>  RabbitMQ offre des garanties de messagerie fiables et Ã  long terme, mais il existe de nombreuses situations oÃ¹ elles ne seront d'aucune aide. <br><br>  Voici une liste de points Ã  retenir: <br><br><ul><li>  Vous devez utiliser la mise en miroir des files d'attente, des files d'attente fiables, des messages persistants, des accusÃ©s de rÃ©ception pour l'expÃ©diteur, un indicateur de confirmation et une notification forcÃ©e du destinataire si des garanties fiables sont requises dans la stratÃ©gie de Â«remise au moins ponctuelleÂ». </li><li>  Si l'envoi est effectuÃ© dans le cadre de la stratÃ©gie de Â«livraison au moins uniqueÂ», vous devrez peut-Ãªtre ajouter un mÃ©canisme de dÃ©duplication ou d'idempotence lors de la duplication des donnÃ©es envoyÃ©es. </li><li>  Si le problÃ¨me de la perte de messages n'est pas aussi important que celui de la vitesse de livraison et de l'Ã©volutivitÃ© Ã©levÃ©e, alors pensez Ã  des systÃ¨mes sans redondance, sans messages persistants et sans accusÃ© de rÃ©ception du cÃ´tÃ© source.  NÃ©anmoins, je prÃ©fÃ©rerais laisser les notifications forcÃ©es du destinataire afin de contrÃ´ler le flux des messages reÃ§us en modifiant les restrictions de prÃ©lecture.  Dans ce cas, vous devrez envoyer des notifications par lots et utiliser l'indicateur Â«multipleÂ». </li></ul><br>  <b>Garanties de livraison Ã  Kafka</b> <br><br>  Les garanties de livraison sont fournies: <br><br><ul><li>  durabilitÃ© des messages - les messages stockÃ©s dans un segment ne sont pas perdus; </li><li>  Notifications de messages - Ã©change de signaux entre Kafka (et Ã©ventuellement le rÃ©fÃ©rentiel Apache Zookeeper) d'une part et la source / le rÃ©cepteur d'autre part. </li></ul><br>  <b>Deux mots sur le packaging des messages</b> <br><br>  L'une des diffÃ©rences entre RabbitMQ et Kafka est l'utilisation de packages pour la messagerie. <br><br>  RabbitMQ fournit quelque chose de similaire Ã  l'emballage grÃ¢ce Ã : <br><br><ul><li>  Suspendez l'envoi de tous les messages X jusqu'Ã  ce que toutes les notifications soient reÃ§ues.  RabbitMQ regroupe gÃ©nÃ©ralement les notifications en utilisant l'indicateur Â«multipleÂ». </li><li>    Â«prefetchÂ»      Â«multipleÂ». </li></ul><br>       .                  â€œmultipleâ€.     TCP. <br><br> Kafka     .    ,           .     RabbitMQ,      ,    ,      .         ,         . <br><br> Kafka        ,      ,     .      ,          .     RabbitMQ   API    ,                  . RabbitMQ         . <br><br> <b>,  </b> <br><br> <i> </i> <br><br>      Kafka   -    ,       ,      .       .   ,   ,  , ,        ,      . <br><br> Kafka     (In Sync Replicas, ISR).          .        ,   ,     (   10 ).    ,      .    -  ,       ..               .        . <br><br> <i>      </i> <br><br>  ,  Kafka  ,  ,    , Kafka               . <br><br> <i>     </i> <br><br>    ,     Kafka,      ,    : <br><br><ul><li>  ,  . Acks=0. </li><li>     . Acks=1 </li><li>           . Acks=All </li></ul><br>          ,    RabbitMQ.         ,      ,        (   ,    ).   ,          . <br><br>   Kafka       .        : <br><br><ul><li>  enable.idempotence   â€œtrueâ€, </li><li>  max.in.flight.requests.per.connection   5  , </li><li>  retries   1  , </li><li>  acks   â€œallâ€. </li></ul><br> ,          acks=0/1   ,     . <br><br> <i>  </i> <br><br>        ,           ,   .       ZooKeeper    Kafka. <br><br>        (),       ,       : <br><br><ul><li> .          .                 .          .         ,      . </li><li> ,    .      â€œ   â€.    ,      ;     ,    . ,  10         ,    4 ,   ,      ,     ; </li><li>  ,    .      â€œ   â€.  ,      ,      ,           . ,  10         ,       ,  4    ; </li><li> .    ,     . </li></ul><br>  â€œ  â€  Kafka Streams,    Java.   Java      .    â€œ  â€,      ,    ,           . ,         ,      â€œ  â€  .           ,       ,   ()      . <br><br> ,  Kafka Streams,          ,       ,      â€œ  â€.       Kafka:             .    ,    .    ,    ,   ,        (   ),   . <br><br> <b>    </b> <br><br>      Kafka     â€œ--â€.         .   ,   ,  . <br><br>        â€œ â€,    ,      (,  , ).      â€œ â€,    ,      .       . <br><br>   :    â€œ  â€      ?    .        ,     ,    .     .     (Last Stable Offset, LSO) â€”      ;     â€œ  â€      . <br><br>  <b>Conclusions</b> <br><br>         .   ,    ,      .   ,     Kafka      ,                . <br><br><h4>  Pour rÃ©sumer </h4><br><ul><li>      â€œ   â€  â€œ   â€. </li><li>     . </li><li>      ,              . Kafka    ,      . </li><li>       ,   ,        . </li><li>        . </li><li> Kafka   ,      â€œ--â€.          . </li><li>  Kafka,       -         ,        (   ).  RabbitMQ    . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kafka peut augmenter les avantages de la mise en paquets en raison de ses capacitÃ©s de distribution de paquets, et RabbitMQ n'a pas de mise en paquets en raison d'un modÃ¨le de rÃ©ception passif qui n'empÃªche pas les conflits de destinataires. </font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437446/">https://habr.com/ru/post/fr437446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437436/index.html">ExÃ©cution de la visionneuse d'images Ã  partir de Windows XP sur Windows moderne</a></li>
<li><a href="../fr437438/index.html">Audiotechnologie: comment les morceaux de plastique sont dÃ©placÃ©s par ultrasons et pourquoi est-il nÃ©cessaire</a></li>
<li><a href="../fr437440/index.html">Bonne journÃ©e Ã©tudiante, programmeur</a></li>
<li><a href="../fr437442/index.html">RÃ©ponses du support technique 3CX: configurer le routeur pour le serveur PBX VoIP</a></li>
<li><a href="../fr437444/index.html">Un seau de goudron dans un baril de miel, ou un choc culturel potentiel pour les propriÃ©taires de tracteurs</a></li>
<li><a href="../fr437448/index.html">28 janvier en Russie, le systÃ¨me de paiements rapides sans commission (par numÃ©ro de tÃ©lÃ©phone)</a></li>
<li><a href="../fr437450/index.html">Comment j'ai rencontrÃ© OpenCV ou Ã  la recherche de ColorChecker</a></li>
<li><a href="../fr437454/index.html">Test de l'arithmomÃ¨tre Felix M</a></li>
<li><a href="../fr437456/index.html">Plus jeune: Examen des tÃ©lÃ©phones IP Snom D315 et D305</a></li>
<li><a href="../fr437458/index.html">Inscription obligatoire par IMEI offre de faire payÃ©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>