<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏻 ☝🏿 👨‍👧‍👦 Top Entwicklungsfehler bei der Arbeit mit PostgreSQL 🧑🏿‍🤝‍🧑🏿 🤾🏿 👩🏽‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="HighLoad ++ gibt es schon lange und wir sprechen über die regelmäßige Arbeit mit PostgreSQL. Aber Entwickler haben immer noch die gleichen Probleme vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top Entwicklungsfehler bei der Arbeit mit PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/455248/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++</a> gibt es schon lange und wir sprechen über die regelmäßige Arbeit mit PostgreSQL.  Aber Entwickler haben immer noch die gleichen Probleme von Monat zu Monat, von Jahr zu Jahr.  Wenn in kleinen Unternehmen ohne DBA im Bundesstaat Fehler bei der Arbeit mit Datenbanken auftreten, ist dies nicht überraschend.  Große Unternehmen benötigen auch Datenbanken, und selbst bei debuggten Prozessen treten immer noch Fehler auf und die Datenbanken fallen.  Es spielt keine Rolle, wie groß das Unternehmen ist - es treten immer noch Fehler auf, Datenbanken stürzen regelmäßig ab, stürzen ab. <br><br><img src="https://habrastorage.org/webt/k7/dz/pb/k7dzpbs_rg2wat7ac4awvar2h-e.png"><br><br>  Natürlich wird Ihnen das nie passieren, aber das Überprüfen der Checkliste ist nicht schwierig, und es kann sehr anständig sein, zukünftige Nerven zu retten.  Unter der Katze werden die wichtigsten typischen Fehler aufgelistet, die Entwickler bei der Arbeit mit PostgreSQL machen, herausfinden, warum wir dies nicht tun müssen, und herausfinden, wie. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HjLnY0aPQZo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Über den Sprecher: Alexey Lesovsky</b> begann als Linux-Systemadministrator.  Von Aufgaben der Virtualisierungs- und Überwachungssysteme kam PostgreSQL nach und nach.  Jetzt PostgreSQL DBA in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Data Egret</a> , einem Beratungsunternehmen, das mit vielen verschiedenen Projekten arbeitet und viele Beispiele für wiederkehrende Probleme sieht.  Dies ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> zur Präsentation des Berichts auf HighLoad ++ 2018. <br><a name="habracut"></a><br><h2>  Woher kommen die Probleme? </h2><br>  Zum Aufwärmen ein paar Geschichten darüber, wie Fehler auftreten. <br><br><h3>  Verlauf 1. Funktionen </h3><br>  Eines der Probleme ist, welche Funktionen das Unternehmen bei der Arbeit mit PostgreSQL verwendet.  Alles beginnt einfach: PostgreSQL, Datasets, einfache Abfragen mit JOIN.  Wir nehmen die Daten, machen SELECT - alles ist einfach. <br><br>  Dann beginnen wir, die zusätzlichen Funktionen von PostgreSQL zu nutzen, neue Funktionen und Erweiterungen hinzuzufügen.  Die Funktion wird immer größer.  Wir verbinden Streaming-Replikation, Sharding.  Verschiedene Dienstprogramme und Bodykits erscheinen in der Umgebung - pgbouncer, pgpool, patroni.  Ungefähr so. <br><br><img src="https://habrastorage.org/webt/_i/kr/an/_ikran7pf4ni9e4hyxiwptuhwy4.png"><br><br><blockquote>  Jedes Schlüsselwort ist ein Grund für das Auftreten eines Fehlers. </blockquote><br><h3>  Verlauf 2. Datenspeicherung </h3><br>  Die Art und Weise, wie wir Daten speichern, ist auch eine Fehlerquelle. <br><br>  Als das Projekt zum ersten Mal erschien, waren einige Daten und Tabellen darin enthalten.  Einfache Abfragen reichen aus, um Daten zu empfangen und aufzuzeichnen.  Aber dann gibt es immer mehr Tabellen.  Daten werden an verschiedenen Stellen ausgewählt, JOINs werden angezeigt.  Abfragen sind kompliziert und umfassen CTE-Konstrukte, SUBQUERY, IN-Listen und LATERAL.  Einen Fehler zu machen und eine Kurvenabfrage zu schreiben wird viel einfacher. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff9/37e/620/ff937e6202947bba4393531475868c74.png"><br><br>  Und dies ist nur die Spitze des Eisbergs - irgendwo an der Seite können sich weitere 400 Tabellen, Partitionen befinden, aus denen gelegentlich auch Daten gelesen werden. <br><br><h3>  Geschichte 3. Lebenszyklus </h3><br>  Die Geschichte, wie das Produkt verfolgt wird.  Daten müssen immer irgendwo gespeichert werden, daher gibt es immer eine Datenbank.  Wie entwickelt sich eine Datenbank, wenn sich ein Produkt entwickelt? <br><br>  Einerseits gibt es <b>Entwickler</b> , die mit Programmiersprachen beschäftigt sind.  Sie schreiben ihre Anwendungen und entwickeln Fähigkeiten im Bereich der Softwareentwicklung, ohne auf Dienstleistungen zu achten.  Oft interessieren sie sich nicht für die Funktionsweise von Kafka oder PostgreSQL - sie entwickeln neue Funktionen in ihrer Anwendung und kümmern sich nicht um den Rest. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/056/1c3/00a/0561c300abe5623898768ad7d334a334.png"><br><br>  <b>Admins</b> dagegen.  Sie rufen neue Amazon-Instanzen auf Bare-Metal auf und sind mit der Automatisierung beschäftigt: Sie richten eine Bereitstellung ein, damit das Layout gut funktioniert, und konfigurieren, dass die Dienste gut miteinander interagieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/961/3f5/8fb/9613f58fb950f69b235d5b80cc29e1b4.png"><br><br>  Es gibt eine Situation, in der keine Zeit oder kein Wunsch nach einer dünnen Abstimmung der Komponenten und der Datenbank besteht.  Die Datenbanken arbeiten mit Standardkonfigurationen und vergessen sie dann vollständig - "es funktioniert, berühren Sie es nicht". <br><br>  Infolgedessen sind Rechen an verschiedenen Stellen verstreut, die ab und zu in die Stirn der Entwickler fliegen.  In diesem Artikel werden wir versuchen, alle diese Rechen in einem Schuppen zu sammeln, damit Sie über sie Bescheid wissen und bei der Arbeit mit PostgreSQL nicht darauf treten. <br><br><h2>  Planung und Überwachung </h2><br>  Stellen Sie sich zunächst vor, wir haben ein neues Projekt - es ist immer eine aktive Entwicklung, das Testen von Hypothesen und die Implementierung neuer Funktionen.  In dem Moment, in dem die Anwendung gerade erschienen ist und sich entwickelt, hat sie wenig Verkehr, Benutzer und Kunden, und alle generieren kleine Datenmengen.  Die Datenbank verfügt über einfache Abfragen, die schnell verarbeitet werden.  Sie müssen keine großen Datenmengen ziehen, es gibt keine Probleme. <br><br>  Aber es gibt mehr Benutzer, der Datenverkehr kommt: Neue Daten werden angezeigt, Datenbanken wachsen und alte Abfragen funktionieren nicht mehr.  Es ist notwendig, Indizes zu vervollständigen, Abfragen neu zu schreiben und zu optimieren.  Es gibt Leistungsprobleme.  All dies führt zu Warnungen um 4 Uhr morgens, Stress für Administratoren und Unzufriedenheit des Managements. <br><br><h3>  Was ist los? </h3><br><blockquote>  Nach meiner Erfahrung gibt es meistens nicht genügend Festplatten. </blockquote><br>  <b>Das erste Beispiel</b> .  Wir öffnen den Zeitplan für die Überwachung der Festplattenauslastung und stellen fest, dass der <b>freie Speicherplatz auf der Festplatte knapp wird</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/65b/245/c83/65b245c834e20a94ed7e698b08cfabaf.png"><br><br>  Wir schauen uns an, wie viel Speicherplatz und was verbraucht wird - es stellt sich heraus, dass es ein pg_xlog-Verzeichnis gibt: <br><br><pre><code class="plaintext hljs">$ du -csh -t 100M /pgdb/9.6/main/* 15G /pgdb/9.6/main/base 58G /pgdb/9.6/main/pg_xlog 72G </code> </pre> <br>  Datenbankadministratoren wissen normalerweise, was dieses Verzeichnis ist, und sie berühren es nicht - es existiert und existiert.  Aber der Entwickler, besonders wenn er sich die Inszenierung ansieht, kratzt sich am Kopf und denkt: <br><br>  <i>- Eine Art von Protokollen ... Löschen wir pg_xlog!</i> <br><br>  <b>Löscht das Verzeichnis, die Datenbank funktioniert nicht mehr</b> .  Sofort müssen Sie googeln, wie die Datenbank nach dem Löschen der Transaktionsprotokolle ausgelöst wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b8/1af/30c/2b81af30c865d529e6f7ff3fd66339ce.png"><br><br>  <b>Zweites Beispiel</b> .  Wieder öffnen wir die Überwachung und stellen fest, dass nicht genügend Platz vorhanden ist.  Diesmal ist der Ort von einer Art Basis besetzt. <br><br><pre> <code class="plaintext hljs">$ du -csh -t 100M /pgdb/9.6/main/* 70G /pgdb/9.6/main/base 2G /pgdb/9.6/main/pg_xlog 72G </code> </pre> <br>  Wir suchen, welche Datenbank am meisten Speicherplatz beansprucht, welche Tabellen und Indizes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/ffc/4e9/d88ffc4e98ca1fd4648ac7aea1c8d019.png"><br><br>  Es stellt sich heraus, dass dies eine Tabelle mit historischen Protokollen ist.  Wir brauchten nie historische Protokolle.  Sie sind nur für den Fall geschrieben, und wenn es nicht das Problem mit dem Ort gäbe, würde niemand sie bis zum zweiten Mal ansehen: <br><br>  <i>- Lass uns alles aufräumen, was mm ... älter als Oktober ist!</i> <br><br>  Machen Sie eine Update-Anfrage, führen Sie sie aus, es wird funktionieren und einige der Zeilen löschen. <br><br><pre> <code class="plaintext hljs">=# DELETE FROM history_log -# WHERE created_at &lt; «2018-10-01»; DELETE 165517399 Time: 585478.451 ms</code> </pre> <br>  Die Abfrage wird 10 Minuten lang ausgeführt, die Tabelle belegt jedoch immer noch den gleichen Speicherplatz. <br><br>  PostgreSQL entfernt Zeilen aus der Tabelle - alles ist korrekt, aber es gibt den Ort nicht an das Betriebssystem zurück.  Dieses Verhalten von PostgreSQL ist den meisten Entwicklern unbekannt und kann sehr überraschend sein. <br><br>  <b>Das dritte Beispiel</b> .  Zum Beispiel hat ORM eine interessante Anfrage gestellt.  Normalerweise beschuldigt jeder ORM, "schlechte" Abfragen zu machen, die einige Tabellen vorlesen. <br><br>  Angenommen, es gibt mehrere JOIN-Operationen, die Tabellen in mehreren Threads parallel lesen.  PostgreSQL kann Datenoperationen parallelisieren und Tabellen in mehreren Threads lesen.  Da wir jedoch mehrere Anwendungsserver haben, liest diese Abfrage alle Tabellen mehrere tausend Mal pro Sekunde.  Es stellt sich heraus, dass der Datenbankserver überlastet ist, die Festplatten nicht zurechtkommen und dies alles zu einem <b>502 Bad Gateway-</b> Fehler im Backend führt - die Datenbank ist nicht verfügbar. <br><br>  Das ist aber noch nicht alles.  Sie können andere Funktionen von PostgerSQL aufrufen. <br><br><ul><li>  <b>Bremsen von DBMS-Hintergrundprozessen</b> - PostgreSQL verfügt über alle Arten von Checkpoints, Vakuums und Replikationen. <br></li><li>  <b>Virtualisierungsaufwand</b> .  Wenn die Datenbank auf einer virtuellen Maschine ausgeführt wird, befinden sich auf demselben Eisenstück auch virtuelle Maschinen an der Seite, die Konflikte um Ressourcen verursachen können. <br></li><li>  <b>Der Speicher stammt vom chinesischen Hersteller NoName</b> , dessen Leistung vom Mond im Steinbock oder der Position des Saturn abhängt, und es gibt keine Möglichkeit herauszufinden, warum dies so funktioniert.  Die Basis leidet. <br></li><li>  <b>Die Standardkonfiguration</b> .  Dies ist mein Lieblingsthema: Der Kunde sagt, dass seine Datenbank langsamer wird - Sie sehen, und er hat eine Standardkonfiguration.  Tatsache ist, dass die Standard-PostgreSQL-Konfiguration für die <b>Ausführung auf der schwächsten Teekanne ausgelegt ist</b> .  Die Basis wird gestartet, es funktioniert, aber wenn es bereits auf Hardware mittlerer Ebene funktioniert, reicht diese Konfiguration nicht aus, sie muss optimiert werden. <br></li></ul><br><blockquote>  In den meisten Fällen fehlt PostgreSQL entweder der Speicherplatz oder die Festplattenleistung.  Glücklicherweise ist mit Prozessoren, Speicher und einem Netzwerk in der Regel mehr oder weniger alles in Ordnung. </blockquote><br>  Wie man ist  Brauchen Sie Überwachung und Planung!  Es scheint offensichtlich, aber aus irgendeinem Grund plant in den meisten Fällen niemand eine Basis, und die Überwachung deckt nicht alles ab, was während des Betriebs von PostgreSQL überwacht werden muss.  Es gibt eine Reihe klarer Regeln, mit denen alles gut und nicht "zufällig" funktioniert. <br><br><h3>  Planung </h3><br>  <b>Hosten Sie die Datenbank ohne zu zögern auf einer SSD</b> .  SSDs sind seit langem zuverlässig, stabil und produktiv.  Enterprise-SSD-Modelle gibt es schon seit Jahren. <br><br>  <b>Planen Sie immer ein Datenschema</b> .  Schreiben Sie nicht in die Datenbank, dass Sie Zweifel daran haben, was benötigt wird - garantiert nicht benötigt.  Ein einfaches Beispiel ist eine leicht modifizierte Tabelle eines unserer Kunden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/56f/9ec/9e156f9ec534a11c5e80180c1c72a987.png"><br><br>  Dies ist eine Protokolltabelle, in der sich eine Datenspalte vom Typ json befindet.  Relativ gesehen können Sie alles in diese Spalte schreiben.  Aus dem letzten Datensatz dieser Tabelle ist ersichtlich, dass die Protokolle 8 MB belegen.  PostgreSQL hat kein Problem damit, Datensätze dieser Länge zu speichern.  PostgreSQL hat einen sehr guten Speicher, der auf solchen Datensätzen kaut. <br><br>  Das Problem ist jedoch, dass Anwendungsserver beim Lesen von Daten aus dieser Tabelle leicht die gesamte Netzwerkbandbreite verstopfen und andere Anforderungen darunter leiden.  Dies ist das Problem bei der Planung eines Datenschemas. <br><br>  <b>Verwenden Sie die Partitionierung für jeden Hinweis auf eine Story, die länger als zwei Jahre gespeichert werden muss</b> .  Die Partitionierung scheint manchmal kompliziert zu sein - Sie müssen sich mit Triggern beschäftigen, mit Funktionen, die Partitionen erstellen.  In neuen Versionen von PostgreSQL ist die Situation besser und jetzt ist das Einrichten der Partitionierung viel einfacher - sobald dies erledigt ist und funktioniert. <br><br>  In dem betrachteten Beispiel zum Löschen von Daten in 10 Minuten kann <code>DELETE</code> durch <code>DROP TABLE</code> - ein solcher Vorgang dauert unter ähnlichen Umständen nur wenige Millisekunden. <br><br>  Wenn die Daten nach Partitionen sortiert sind, wird die Partition buchstäblich in wenigen Millisekunden gelöscht und das Betriebssystem übernimmt sofort.  Die Verwaltung historischer Daten ist einfacher, einfacher und sicherer. <br><br><h3>  Überwachung </h3><br>  Überwachung ist ein separates großes Thema, aber aus Sicht der Datenbank gibt es Empfehlungen, die in einen Abschnitt des Artikels passen. <br><br>  Standardmäßig bieten viele Überwachungssysteme die Überwachung von Prozessoren, Speicher, Netzwerk und Speicherplatz. In der Regel <b>werden jedoch keine Festplattengeräte entsorgt</b> .  Informationen darüber, wie stark die Festplatten ausgelastet sind, welche Bandbreite derzeit auf den Festplatten vorhanden ist und welcher Latenzwert immer zur Überwachung hinzugefügt werden sollte.  Auf diese Weise können Sie schnell beurteilen, wie Laufwerke geladen sind. <br><br>  Es gibt viele PostgreSQL-Überwachungsoptionen für jeden Geschmack.  Hier sind einige Punkte, die vorhanden sein müssen. <br><br><ul><li>  <b>Verbundene Clients</b> .  Es ist notwendig zu überwachen, mit welchen Status sie arbeiten, schnell die "schädlichen" Kunden zu finden, die der Datenbank schaden, und sie auszuschalten. </li><li>  <b>Fehler</b>  Es ist notwendig, Fehler zu überwachen, um zu verfolgen, wie gut die Datenbank funktioniert: Keine Fehler - großartig, Fehler sind aufgetreten - ein Grund, sich die Protokolle anzusehen und zu verstehen, was falsch läuft. </li><li>  <b>Anfragen (Aussagen)</b> .  Wir überwachen die quantitativen und qualitativen Merkmale von Anfragen, um grob zu beurteilen, ob wir langsame, lange oder ressourcenintensive Anfragen haben. </li></ul><br>  Weitere Informationen finden Sie im Bericht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Grundlagen</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PostgreSQL-Überwachung“</a> mit HighLoad ++ Siberia und auf der Seite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Überwachung“</a> im PostgreSQL-Wiki. <br><br>  Wenn wir alles geplant und uns mit der Überwachung „bedeckt“ haben, können wir immer noch auf einige Probleme stoßen. <br><br><h3>  Skalieren </h3><br>  Normalerweise sieht der Entwickler die Datenbankzeile in der Konfiguration.  Er ist nicht besonders daran interessiert, wie es intern angeordnet ist - wie Checkpoint, Replikation, Scheduler funktionieren.  Der Entwickler hat bereits etwas zu tun - in todo gibt es viele interessante Dinge, die er ausprobieren möchte. <br><br><blockquote>  "Gib mir die Adresse der Basis, dann ich selbst."  © Anonymer Entwickler. </blockquote><br>  Die Unwissenheit über das Thema führt zu interessanten Konsequenzen, wenn der Entwickler beginnt, Abfragen zu schreiben, die in dieser Datenbank funktionieren.  Fantasien beim Schreiben von Abfragen führen manchmal zu atemberaubenden Effekten. <br><br>  Es gibt zwei Arten von Transaktionen.  <b>OLTP-Transaktionen</b> sind schnell, kurz und leicht und dauern Bruchteile einer Millisekunde.  Sie arbeiten sehr schnell und es gibt viele von ihnen.  <b>OLAP - analytische Abfragen</b> - langsam, lang, schwer, große Tabellenfelder lesen und Statistiken lesen. <br><br>  <b>In den</b> letzten 2-3 Jahren klingt die Abkürzung <b>HTAP</b> häufig - Hybrid Transaction / Analytical Processing oder <b>Hybrid Transactional-Analytical Processing</b> .  Wenn Sie keine Zeit haben, über Skalierung und Vielfalt von OLAP- und OLTP-Anforderungen nachzudenken, können Sie sagen: „Wir haben HTAP!“  Die Erfahrung und der Schmerz von Fehlern zeigen jedoch, dass verschiedene Arten von Anforderungen getrennt voneinander leben müssen, da lange OLAP-Anforderungen leichte OLTP-Anforderungen blockieren. <br><br>  Wir kommen also zu der Frage, wie PostgreSQL skaliert werden kann, um die Last zu verteilen, und alle waren zufrieden. <br><br>  <b>Streaming-Replikation</b> .  Die einfachste Option ist das <b>Streaming der Replikation</b> .  Wenn die Anwendung mit der Datenbank arbeitet, verbinden wir mehrere Replikate mit dieser Datenbank und verteilen die Last.  Die Aufnahme geht immer noch zur Master-Basis und das Lesen zu Replikaten.  Mit dieser Methode können Sie sehr weit skalieren. <br><br>  Außerdem können Sie mehr Replikate mit einzelnen Replikaten verbinden und eine <b>kaskadierte Replikation erhalten</b> .  Separate Benutzergruppen oder Anwendungen, die beispielsweise Analysen lesen, können in ein separates Replikat verschoben werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f4/5b3/2d7/7f45b32d7eeb8dfcd7e19cfb38210134.png"><br><br>  <b>Logische Veröffentlichungen, Abonnements</b> - Der Mechanismus logischer Veröffentlichungen und Abonnements impliziert das Vorhandensein mehrerer unabhängiger PostgreSQL-Server mit separaten Datenbanken und Tabellensätzen.  Diese Tabellensätze können mit benachbarten Datenbanken verbunden werden. Sie sind für Anwendungen sichtbar, die sie normal verwenden können.  Das heißt, alle Änderungen, die in der Quelle auftreten, werden auf die Zielbasis repliziert und sind dort sichtbar.  Funktioniert hervorragend mit PostgreSQL 10. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13a/4aa/068/13a4aa06893b4ae9f1a1b7523c407b06.png"><br><br>  <b>Fremdtabellen, deklarative Partitionierung - deklarative Partitionierung und externe Tabellen</b> .  Sie können mehrere PostgreSQL-Dateien verwenden und dort mehrere Tabellensätze erstellen, in denen die gewünschten Datenbereiche gespeichert werden.  Dies können Daten für ein bestimmtes Jahr oder Daten sein, die über einen beliebigen Bereich gesammelt wurden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/109/929/cb9/109929cb936d0c040651ad30c130258b.png"><br><br>  Mithilfe des Mechanismus externer Tabellen können Sie alle diese Datenbanken in Form einer partitionierten Tabelle in einem separaten PostgreSQL kombinieren.  Eine Anwendung arbeitet möglicherweise bereits mit dieser partitionierten Tabelle, liest jedoch tatsächlich Daten von Remote-Partitionen.  Wenn Datenmengen mehr als die Fähigkeiten eines einzelnen Servers sind, ist dies ein Sharding. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/446/d13/a39/446d13a394143b988ec04f60e645ea21.png"><br><br>  All dies kann zu verteilten Konfigurationen kombiniert werden, um verschiedene PostgreSQL-Replikationstopologien zu erstellen. Wie dies alles funktioniert und wie es verwaltet wird, ist das Thema eines separaten Berichts. <br><br><h3>  Wo soll ich anfangen? </h3><br>  Die einfachste Option ist die <b>Replikation</b> .  Der erste Schritt besteht darin, das Lesen und Schreiben zu verteilen.  Schreiben Sie also an den Master und lesen Sie aus Replikaten.  Also skalieren wir die Last und führen das Lesen vom Assistenten aus.  Vergessen Sie außerdem nicht die Analysten.  Analytische Abfragen funktionieren lange. Sie benötigen ein separates Replikat mit separaten Einstellungen, damit lange analytische Abfragen den Rest nicht beeinträchtigen können. <br><br>  Der nächste Schritt ist das <b>Balancieren</b> .  Wir haben immer noch die gleiche Zeile in der Konfiguration, mit der der Entwickler arbeitet.  Er braucht einen Ort, an dem er schreiben und lesen kann.  Hier gibt es mehrere Möglichkeiten. <br><br>  Ideal ist die Implementierung des Ausgleichs <b>auf Anwendungsebene</b> , wenn die Anwendung selbst weiß, woher die Daten gelesen werden sollen, und weiß, wie ein Replikat ausgewählt wird.  Angenommen, ein Kontostand wird immer auf dem neuesten Stand benötigt und muss vom Master gelesen werden, und das Produktbild oder die Informationen dazu können mit einiger Verzögerung gelesen und von einem Replikat erstellt werden. <br><br><ul><li>  <b>DNS Round Robin</b> ist meiner Meinung nach keine sehr praktische Implementierung, da es manchmal lange funktioniert und nicht die erforderliche Zeit für den Wechsel der Assistentenrollen zwischen Servern im Falle eines Failovers bietet. </li><li>  Eine interessantere Option ist die Verwendung von <b>Keepalived und HAProxy</b> .  Virtuelle Adressen für den Master und eine Reihe von Replikaten werden zwischen HAProxy-Servern geworfen, und HAProxy gleicht bereits den Datenverkehr aus. </li><li>  <b>Patroni, DCS</b> in Verbindung mit so etwas wie ZooKeeper, etcd, Consul - meiner Meinung nach die interessanteste Option.  Das heißt, die Serviceerkennung ist für die Informationen verantwortlich, wer jetzt der Master und wer das Replikat ist.  Patroni verwaltet einen Cluster von PostgreSQLs und führt das Umschalten durch. Wenn sich die Topologie geändert hat, werden diese Informationen in der Diensterkennung angezeigt, und Anwendungen können die aktuelle Topologie schnell ermitteln. </li></ul><br>  Und es gibt Nuancen bei der Replikation, von denen die häufigste die <b>Replikationsverzögerung ist</b> .  Sie können es wie GitLab tun, und wenn sich die Verzögerung ansammelt, lassen Sie einfach die Basis fallen.  Aber wir haben eine umfassende Überwachung - wir schauen uns das an und sehen lange Transaktionen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/619/9a0/fae/6199a0fae7ed88fb1646e232cc1f2953.png"><br><br><h3>  Anwendungen und DBMS-Transaktionen </h3><br>  Im Allgemeinen führen langsame und inaktive Transaktionen zu: <br><br><ul><li>  <b>Produktivitätsabfall</b> - nicht zu einem scharfen Krampf, sondern zu einem glatten; <br></li><li>  <b>Sperren und Deadlocks</b> , da lange Transaktionen Sperren für Zeilen enthalten und verhindern, dass andere Transaktionen funktionieren. <br></li><li>  <b>50 * HTTP-Fehler im Backend</b> , Schnittstellenfehler oder anderswo. <br></li></ul><br><br>  Schauen wir uns eine kleine Theorie darüber an, wie diese Probleme auftreten und warum der Mechanismus langer und inaktiver Transaktionen schädlich ist. <br><br>  PostgreSQL hat MVCC - relativ gesehen eine Datenbank-Engine.  Kunden können damit wettbewerbsfähig mit Daten arbeiten, ohne sich gegenseitig zu stören: Leser stören Leser nicht, und Schriftsteller stören Schriftsteller nicht.  Natürlich gibt es einige Ausnahmen, aber in diesem Fall sind sie nicht wichtig. <br><br>  Es stellt sich heraus, dass es in der Datenbank für eine Zeile mehrere Versionen für verschiedene Transaktionen geben kann.  Clients stellen eine Verbindung her, die Datenbank gibt ihnen Snapshots von Daten, und innerhalb dieser Snapshots können verschiedene Versionen derselben Zeile vorhanden sein.  Dementsprechend werden im Lebenszyklus der Datenbank Transaktionen verschoben, ersetzt und es werden Versionen von Zeilen angezeigt, die niemand benötigt. <br><br>  Es besteht also ein <b>Bedarf an einem Müllsammler - automatischem Vakuum</b> .  Es bestehen lange Transaktionen, die verhindern, dass durch automatisches Vakuum unnötige Zeilenversionen entfernt werden.  Diese Junk-Daten wandern von Speicher zu Datenträger, von Datenträger zu Speicher.  Um diesen Müll zu speichern, werden CPU- und Speicherressourcen verschwendet. <br><br><blockquote>  Je länger die Transaktion dauert, desto mehr Junk und geringere Leistung. </blockquote><br>  Unter dem Gesichtspunkt von „Wer ist schuld?“ Ist die App für das Auftreten langer Transaktionen verantwortlich.  Wenn die Datenbank für sich allein existiert, werden lange Nichtstun-Transaktionen von nirgendwoher ausgeführt.  In der Praxis gibt es die folgenden Optionen für das Auftreten von Transaktionen im Leerlauf. <br><br>  <b>"Gehen wir zu einer externen Quelle</b> . <b>"</b>  Die Anwendung öffnet eine Transaktion, führt etwas in der Datenbank aus und entscheidet sich dann für eine externe Quelle, z. B. Memcached oder Redis, in der Hoffnung, dass sie dann zur Datenbank zurückkehrt, weiterarbeitet und die Transaktion schließt.  Wenn jedoch ein Fehler in der externen Quelle auftritt, stürzt die Anwendung ab und die Transaktion bleibt geschlossen, bis jemand sie bemerkt und beendet. <br><br>  <b>Keine Fehlerbehandlung</b> .  Andererseits kann es zu Problemen bei der Fehlerbehandlung kommen.  Als die Anwendung erneut eine Transaktion öffnete, ein Problem in der Datenbank löste, zur Codeausführung zurückkehrte, einige Funktionen und Berechnungen ausführte, um die Arbeit in der Transaktion fortzusetzen und sie zu schließen.  Wenn bei diesen Berechnungen der Anwendungsvorgang mit einem Fehler unterbrochen wurde, kehrte der Code zum Beginn des Zyklus zurück und die Transaktion blieb erneut geschlossen. <br><br>  <b>Der menschliche Faktor</b> .  Zum Beispiel arbeitet ein Administrator, Entwickler, Analyst in einem pgAdmin oder in DBeaver - hat eine Transaktion geöffnet und tut etwas darin.  Dann wurde die Person abgelenkt, er wechselte zu einer anderen Aufgabe, dann zur dritten, vergaß die Transaktion, ging für das Wochenende und die Transaktion hängt weiter.  Die Basisleistung leidet. <br><br>  Mal sehen, was in diesen Fällen zu tun ist. <br><br><ul><li>  Wir haben Überwachung, dementsprechend benötigen wir <b>Warnungen bei der Überwachung</b> .  Jede Transaktion, die länger als eine Stunde dauert und nichts tut, ist eine Gelegenheit, um zu sehen, woher sie stammt, und um zu verstehen, was falsch ist. </li><li>  Der nächste Schritt besteht darin <b>, solche Transaktionen über die Aufgabe in der Krone</b> (pg_terminate_backend (pid)) oder in der PostgreSQL-Konfiguration zu konfigurieren.  Schwellenwerte von 10 bis 30 Minuten sind erforderlich. Danach werden die Transaktionen automatisch abgeschlossen. </li><li>  <b>Anwendungs-Refactoring</b> .  Natürlich müssen Sie herausfinden, woher die inaktiven Transaktionen kommen, warum sie auftreten, und solche Orte beseitigen. </li></ul><br><blockquote>  Vermeiden Sie um jeden Preis lange Transaktionen, da diese die Datenbankleistung stark beeinträchtigen. </blockquote><br>  Alles wird noch interessanter, wenn anstehende Aufgaben angezeigt werden. Beispielsweise müssen Sie die Einheiten sorgfältig berechnen.  Und wir kommen zum Thema Fahrradbau. <br><br><h3>  Fahrradbau </h3><br>  Wund Thema.  Unternehmen auf der Anwendungsseite müssen die Hintergrundverarbeitung von Ereignissen durchführen.  Zum Beispiel, um Aggregate zu berechnen: Minimum, Maximum, Durchschnittswert, Benachrichtigungen an Benutzer senden, Kunden in Rechnung stellen, nach der Registrierung ein Benutzerkonto einrichten oder sich bei benachbarten Diensten registrieren - verzögerte Verarbeitung. <br><br>  Das Wesentliche solcher Aufgaben ist das gleiche - sie werden auf später verschoben.  In der Datenbank werden Tabellen angezeigt, die nur die Warteschlangen ausführen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef4/bfa/f20/ef4bfaf20634c6d43941c9c8325a09ff.png"><br><br>  Hier ist die Kennung der Aufgabe, der Zeitpunkt, zu dem die Aufgabe erstellt wurde, die Aktualisierung, der Handler, der sie ausgeführt hat, die Anzahl der zu erledigenden Versuche.  Wenn Sie eine Tabelle haben, die dieser auch nur annähernd ähnelt, haben Sie <b>selbst geschriebene Warteschlangen</b> . <br><br>  All dies funktioniert einwandfrei, bis lange Transaktionen angezeigt werden.  Danach nehmen <b>Tabellen, die mit Warteschlangen arbeiten, an Größe zu</b> .  Es werden ständig neue Jobs hinzugefügt, alte gelöscht, Aktualisierungen vorgenommen - eine Tabelle mit intensiver Aufzeichnung wird erhalten.  Es sollte regelmäßig von veralteten Versionen von Zeichenfolgen gereinigt werden, damit die Leistung nicht beeinträchtigt wird. <br><br>  <b>Die Verarbeitungszeit nimmt zu</b> - eine lange Transaktion blockiert veraltete Versionen von Zeilen oder verhindert, dass Vakuum sie bereinigt.  Wenn die Tabelle größer wird, erhöht sich auch die Verarbeitungszeit, da Sie viele Seiten mit Müll lesen müssen.  Die Zeit nimmt zu und die <b>Warteschlange funktioniert irgendwann überhaupt nicht mehr</b> . <br><br>  Unten sehen Sie ein Beispiel für die Spitze eines unserer Kunden, der eine Warteschlange hatte.  Alle Anfragen beziehen sich nur auf die Warteschlange. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/344/203/7ac/3442037ac837daec02ee89a83bd53dd7.png"><br><br>  Achten Sie auf die Ausführungszeit dieser Anforderungen - alle bis auf eine arbeiten länger als zwanzig Sekunden. <br><br>  Um diese Probleme zu lösen, wurde <b>Skytools PgQ</b> , ein Warteschlangenmanager für PostgreSQL, vor langer Zeit erfunden.  Erfinden Sie Ihr Fahrrad nicht neu - nehmen Sie PgQ, richten Sie es einmal ein und vergessen Sie die Linien. <br><br>  Es stimmt, er hat auch Funktionen.  Skytools PgQ hat <b>wenig Dokumentation</b> .  Nach dem Lesen der offiziellen Seite hat man das Gefühl, nichts verstanden zu haben.  Das Gefühl wächst, wenn Sie versuchen, etwas zu tun.  Alles funktioniert, aber <b>wie es funktioniert, ist nicht klar</b> .  Eine Art Jedi-Magie.  Viele Informationen finden Sie jedoch in <b>Mailinglisten</b> .  Dies ist kein sehr praktisches Format, aber es gibt viele interessante Dinge, und Sie müssen diese Blätter lesen. <br><br>  Trotz der Nachteile arbeitet Skytools PgQ nach dem Prinzip "Einrichten und Vergessen".   ,    ,     ,    .   PgQ ,        .  PgQ ,      . <br><br><blockquote>    ,   -     —  ,   .     . </blockquote><br>              PgQ. ,    PostgreSQL, ,  ,   PgQ  .    ,   . <br><br><h3>  </h3><br>        ,          .   ,    , ,     - ,   , ,      . ,       ,       ,   alter. <br><br>     <b>auto-failover</b> —       PostgreSQL  - ,       ,        .      ,    auto-failover. <br><br> <b>Split-brain</b> .    PostgreSQL     ,     ,  —  .   ,   .   PostgreSQL     fencing,     Kubernets    .     -    ,         .   Split-brain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/327/239/97e/32723997e13e8427e4cddc59ea7c964f.png"><br><br>           .  GitHub   Split-brain,       . <br><br> <b>Cascade failover</b> . ,     .  ,         . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea9/864/d63/ea9864d63b7cebd46ff8b185ddb5d639.png"><br><br>        ,       .    ,       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81d/243/fc1/81d243fc1500011f0f3c24576f81786a.png"><br><br>         —   failover. <br><br>      auto-failover,    . <br><br> <b>Bash </b> —  ,      .   ,     ,   .   - ,   ,   .     . <br><br> <b>Ansible playbooks</b> — bash-  .    ,   ,    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Patroni</b></a> —   ,    ,      auto-failover,   ,       service discovery. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>PAF</b></a> — <b>  Pacemaker</b> .     auto-failover  PostgreSQL,        Pacemaker. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Stolon</b></a>     .  Kubernetes, . Stolon  Patroni,        . <br><br><h3>    </h3><br>    Docker  Kubernetes .    ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b99/aba/8c4/b99aba8c4f9c959cd96840bfcd3359b2.png"><br><br>        ,       . <i> «      Kubernetes...»</i>    . <br><br> <b> —   stateful</b> ,   - .  Wo?      .   Open Source: CEPH, GlusterFS, LinStor DRBD.    ,       , ,     . <br><br>       — <b>    </b> . ,      Kubernetes,     CEPH.         —    .           ,       . <br><br><ul><li> <b>  </b> ,           . </li><li> <b>     latency</b> .  latency        —    . </li><li> <b>   </b> . Kubernetes ,    - . ,    shared storage  Kubernetes,       .  -         . </li></ul><br>     ,    Kubernetes  Docker    staging  dev-     .    ,   , Kubernetes      . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b04/8dd/fd0/b048ddfd0b6212ef2d1eb49eda02386b.png"><br><br>    ,     <b>local volumes —  </b>     , <b>streaming replication —   </b> ,       <b>PostgreSQL-</b> ,       — ,   .       : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zalando</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Crunchy</a> . <br><br>    ,     .    issues  pull requests.   ,     ,     . <br><br><h2>  </h2><br> <b>         SSD</b> —          ,    . <br><br> <b>     </b> .   JSON  8  —  ,   . <br><br> <b> </b> ,        .  PostgreSQL,   . <br><br> <b>  — Postgres is ready</b> .          . PostgreSQL   ,        .    : <b>streaming replication; publications, subscriptions; foreign Tables; declarative partitioning</b> . <br><br> <b>    </b> .      ,    . <br><br>    -,      ,   — <b>   </b> .    .    ,  Skytools PgQ! <br><br> <b>     Kubernetes,  local volumes, streaming replication  PostgreSQL </b> .     - ,   ,      . <br><br><blockquote>               .     ,   24  25   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad++ Siberia</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  ,    ,           .   38    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> —     ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455248/">https://habr.com/ru/post/de455248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455236/index.html">Comodo widerruft Zertifikate ohne Grund</a></li>
<li><a href="../de455240/index.html">Verwenden der abgelehnten Fehlerrate zur Verbesserung der Fehlerberichterstattung</a></li>
<li><a href="../de455242/index.html">Weniger Ohren oder wie man den Sound im Spiel nicht von Anfang an verdirbt</a></li>
<li><a href="../de455244/index.html">Comic "Löten ist einfach" in der aktualisierten Version (2019)</a></li>
<li><a href="../de455246/index.html">Die Registrierung für den Customer Experience Day in St. Petersburg ist am 20. Juni geöffnet</a></li>
<li><a href="../de455250/index.html">Derjenige, der Herzog Nukem wiederbelebt hat: Interview mit Randy Pitchford, Magier von Gearbox</a></li>
<li><a href="../de455252/index.html">.NET: Tools zum Arbeiten mit Multithreading und Asynchronität - Teil 1</a></li>
<li><a href="../de455256/index.html">Habr Weekly # 4 / Computex, wie können wir Apple Beta, Durov hungert, BadComedian Katze, warum hat das neuronale Netzwerk nach Pornodarstellern gesucht</a></li>
<li><a href="../de455258/index.html">Die Abstimmung für die Berichte der Backend-Sektion zum Jubiläum von DevConfX begann am 21. und 22. Juni in Moskau</a></li>
<li><a href="../de455260/index.html">Merkle Tree: rostig und schnell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>