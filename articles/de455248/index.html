<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçü§ù‚Äçüë®üèª ‚òùüèø üë®‚Äçüëß‚Äçüë¶ Top Entwicklungsfehler bei der Arbeit mit PostgreSQL üßëüèø‚Äçü§ù‚Äçüßëüèø ü§æüèø üë©üèΩ‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="HighLoad ++ gibt es schon lange und wir sprechen √ºber die regelm√§√üige Arbeit mit PostgreSQL. Aber Entwickler haben immer noch die gleichen Probleme vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top Entwicklungsfehler bei der Arbeit mit PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/455248/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++</a> gibt es schon lange und wir sprechen √ºber die regelm√§√üige Arbeit mit PostgreSQL.  Aber Entwickler haben immer noch die gleichen Probleme von Monat zu Monat, von Jahr zu Jahr.  Wenn in kleinen Unternehmen ohne DBA im Bundesstaat Fehler bei der Arbeit mit Datenbanken auftreten, ist dies nicht √ºberraschend.  Gro√üe Unternehmen ben√∂tigen auch Datenbanken, und selbst bei debuggten Prozessen treten immer noch Fehler auf und die Datenbanken fallen.  Es spielt keine Rolle, wie gro√ü das Unternehmen ist - es treten immer noch Fehler auf, Datenbanken st√ºrzen regelm√§√üig ab, st√ºrzen ab. <br><br><img src="https://habrastorage.org/webt/k7/dz/pb/k7dzpbs_rg2wat7ac4awvar2h-e.png"><br><br>  Nat√ºrlich wird Ihnen das nie passieren, aber das √úberpr√ºfen der Checkliste ist nicht schwierig, und es kann sehr anst√§ndig sein, zuk√ºnftige Nerven zu retten.  Unter der Katze werden die wichtigsten typischen Fehler aufgelistet, die Entwickler bei der Arbeit mit PostgreSQL machen, herausfinden, warum wir dies nicht tun m√ºssen, und herausfinden, wie. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HjLnY0aPQZo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>√úber den Sprecher: Alexey Lesovsky</b> begann als Linux-Systemadministrator.  Von Aufgaben der Virtualisierungs- und √úberwachungssysteme kam PostgreSQL nach und nach.  Jetzt PostgreSQL DBA in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Data Egret</a> , einem Beratungsunternehmen, das mit vielen verschiedenen Projekten arbeitet und viele Beispiele f√ºr wiederkehrende Probleme sieht.  Dies ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> zur Pr√§sentation des Berichts auf HighLoad ++ 2018. <br><a name="habracut"></a><br><h2>  Woher kommen die Probleme? </h2><br>  Zum Aufw√§rmen ein paar Geschichten dar√ºber, wie Fehler auftreten. <br><br><h3>  Verlauf 1. Funktionen </h3><br>  Eines der Probleme ist, welche Funktionen das Unternehmen bei der Arbeit mit PostgreSQL verwendet.  Alles beginnt einfach: PostgreSQL, Datasets, einfache Abfragen mit JOIN.  Wir nehmen die Daten, machen SELECT - alles ist einfach. <br><br>  Dann beginnen wir, die zus√§tzlichen Funktionen von PostgreSQL zu nutzen, neue Funktionen und Erweiterungen hinzuzuf√ºgen.  Die Funktion wird immer gr√∂√üer.  Wir verbinden Streaming-Replikation, Sharding.  Verschiedene Dienstprogramme und Bodykits erscheinen in der Umgebung - pgbouncer, pgpool, patroni.  Ungef√§hr so. <br><br><img src="https://habrastorage.org/webt/_i/kr/an/_ikran7pf4ni9e4hyxiwptuhwy4.png"><br><br><blockquote>  Jedes Schl√ºsselwort ist ein Grund f√ºr das Auftreten eines Fehlers. </blockquote><br><h3>  Verlauf 2. Datenspeicherung </h3><br>  Die Art und Weise, wie wir Daten speichern, ist auch eine Fehlerquelle. <br><br>  Als das Projekt zum ersten Mal erschien, waren einige Daten und Tabellen darin enthalten.  Einfache Abfragen reichen aus, um Daten zu empfangen und aufzuzeichnen.  Aber dann gibt es immer mehr Tabellen.  Daten werden an verschiedenen Stellen ausgew√§hlt, JOINs werden angezeigt.  Abfragen sind kompliziert und umfassen CTE-Konstrukte, SUBQUERY, IN-Listen und LATERAL.  Einen Fehler zu machen und eine Kurvenabfrage zu schreiben wird viel einfacher. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff9/37e/620/ff937e6202947bba4393531475868c74.png"><br><br>  Und dies ist nur die Spitze des Eisbergs - irgendwo an der Seite k√∂nnen sich weitere 400 Tabellen, Partitionen befinden, aus denen gelegentlich auch Daten gelesen werden. <br><br><h3>  Geschichte 3. Lebenszyklus </h3><br>  Die Geschichte, wie das Produkt verfolgt wird.  Daten m√ºssen immer irgendwo gespeichert werden, daher gibt es immer eine Datenbank.  Wie entwickelt sich eine Datenbank, wenn sich ein Produkt entwickelt? <br><br>  Einerseits gibt es <b>Entwickler</b> , die mit Programmiersprachen besch√§ftigt sind.  Sie schreiben ihre Anwendungen und entwickeln F√§higkeiten im Bereich der Softwareentwicklung, ohne auf Dienstleistungen zu achten.  Oft interessieren sie sich nicht f√ºr die Funktionsweise von Kafka oder PostgreSQL - sie entwickeln neue Funktionen in ihrer Anwendung und k√ºmmern sich nicht um den Rest. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/056/1c3/00a/0561c300abe5623898768ad7d334a334.png"><br><br>  <b>Admins</b> dagegen.  Sie rufen neue Amazon-Instanzen auf Bare-Metal auf und sind mit der Automatisierung besch√§ftigt: Sie richten eine Bereitstellung ein, damit das Layout gut funktioniert, und konfigurieren, dass die Dienste gut miteinander interagieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/961/3f5/8fb/9613f58fb950f69b235d5b80cc29e1b4.png"><br><br>  Es gibt eine Situation, in der keine Zeit oder kein Wunsch nach einer d√ºnnen Abstimmung der Komponenten und der Datenbank besteht.  Die Datenbanken arbeiten mit Standardkonfigurationen und vergessen sie dann vollst√§ndig - "es funktioniert, ber√ºhren Sie es nicht". <br><br>  Infolgedessen sind Rechen an verschiedenen Stellen verstreut, die ab und zu in die Stirn der Entwickler fliegen.  In diesem Artikel werden wir versuchen, alle diese Rechen in einem Schuppen zu sammeln, damit Sie √ºber sie Bescheid wissen und bei der Arbeit mit PostgreSQL nicht darauf treten. <br><br><h2>  Planung und √úberwachung </h2><br>  Stellen Sie sich zun√§chst vor, wir haben ein neues Projekt - es ist immer eine aktive Entwicklung, das Testen von Hypothesen und die Implementierung neuer Funktionen.  In dem Moment, in dem die Anwendung gerade erschienen ist und sich entwickelt, hat sie wenig Verkehr, Benutzer und Kunden, und alle generieren kleine Datenmengen.  Die Datenbank verf√ºgt √ºber einfache Abfragen, die schnell verarbeitet werden.  Sie m√ºssen keine gro√üen Datenmengen ziehen, es gibt keine Probleme. <br><br>  Aber es gibt mehr Benutzer, der Datenverkehr kommt: Neue Daten werden angezeigt, Datenbanken wachsen und alte Abfragen funktionieren nicht mehr.  Es ist notwendig, Indizes zu vervollst√§ndigen, Abfragen neu zu schreiben und zu optimieren.  Es gibt Leistungsprobleme.  All dies f√ºhrt zu Warnungen um 4 Uhr morgens, Stress f√ºr Administratoren und Unzufriedenheit des Managements. <br><br><h3>  Was ist los? </h3><br><blockquote>  Nach meiner Erfahrung gibt es meistens nicht gen√ºgend Festplatten. </blockquote><br>  <b>Das erste Beispiel</b> .  Wir √∂ffnen den Zeitplan f√ºr die √úberwachung der Festplattenauslastung und stellen fest, dass der <b>freie Speicherplatz auf der Festplatte knapp wird</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/65b/245/c83/65b245c834e20a94ed7e698b08cfabaf.png"><br><br>  Wir schauen uns an, wie viel Speicherplatz und was verbraucht wird - es stellt sich heraus, dass es ein pg_xlog-Verzeichnis gibt: <br><br><pre><code class="plaintext hljs">$ du -csh -t 100M /pgdb/9.6/main/* 15G /pgdb/9.6/main/base 58G /pgdb/9.6/main/pg_xlog 72G </code> </pre> <br>  Datenbankadministratoren wissen normalerweise, was dieses Verzeichnis ist, und sie ber√ºhren es nicht - es existiert und existiert.  Aber der Entwickler, besonders wenn er sich die Inszenierung ansieht, kratzt sich am Kopf und denkt: <br><br>  <i>- Eine Art von Protokollen ... L√∂schen wir pg_xlog!</i> <br><br>  <b>L√∂scht das Verzeichnis, die Datenbank funktioniert nicht mehr</b> .  Sofort m√ºssen Sie googeln, wie die Datenbank nach dem L√∂schen der Transaktionsprotokolle ausgel√∂st wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b8/1af/30c/2b81af30c865d529e6f7ff3fd66339ce.png"><br><br>  <b>Zweites Beispiel</b> .  Wieder √∂ffnen wir die √úberwachung und stellen fest, dass nicht gen√ºgend Platz vorhanden ist.  Diesmal ist der Ort von einer Art Basis besetzt. <br><br><pre> <code class="plaintext hljs">$ du -csh -t 100M /pgdb/9.6/main/* 70G /pgdb/9.6/main/base 2G /pgdb/9.6/main/pg_xlog 72G </code> </pre> <br>  Wir suchen, welche Datenbank am meisten Speicherplatz beansprucht, welche Tabellen und Indizes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/ffc/4e9/d88ffc4e98ca1fd4648ac7aea1c8d019.png"><br><br>  Es stellt sich heraus, dass dies eine Tabelle mit historischen Protokollen ist.  Wir brauchten nie historische Protokolle.  Sie sind nur f√ºr den Fall geschrieben, und wenn es nicht das Problem mit dem Ort g√§be, w√ºrde niemand sie bis zum zweiten Mal ansehen: <br><br>  <i>- Lass uns alles aufr√§umen, was mm ... √§lter als Oktober ist!</i> <br><br>  Machen Sie eine Update-Anfrage, f√ºhren Sie sie aus, es wird funktionieren und einige der Zeilen l√∂schen. <br><br><pre> <code class="plaintext hljs">=# DELETE FROM history_log -# WHERE created_at &lt; ¬´2018-10-01¬ª; DELETE 165517399 Time: 585478.451 ms</code> </pre> <br>  Die Abfrage wird 10 Minuten lang ausgef√ºhrt, die Tabelle belegt jedoch immer noch den gleichen Speicherplatz. <br><br>  PostgreSQL entfernt Zeilen aus der Tabelle - alles ist korrekt, aber es gibt den Ort nicht an das Betriebssystem zur√ºck.  Dieses Verhalten von PostgreSQL ist den meisten Entwicklern unbekannt und kann sehr √ºberraschend sein. <br><br>  <b>Das dritte Beispiel</b> .  Zum Beispiel hat ORM eine interessante Anfrage gestellt.  Normalerweise beschuldigt jeder ORM, "schlechte" Abfragen zu machen, die einige Tabellen vorlesen. <br><br>  Angenommen, es gibt mehrere JOIN-Operationen, die Tabellen in mehreren Threads parallel lesen.  PostgreSQL kann Datenoperationen parallelisieren und Tabellen in mehreren Threads lesen.  Da wir jedoch mehrere Anwendungsserver haben, liest diese Abfrage alle Tabellen mehrere tausend Mal pro Sekunde.  Es stellt sich heraus, dass der Datenbankserver √ºberlastet ist, die Festplatten nicht zurechtkommen und dies alles zu einem <b>502 Bad Gateway-</b> Fehler im Backend f√ºhrt - die Datenbank ist nicht verf√ºgbar. <br><br>  Das ist aber noch nicht alles.  Sie k√∂nnen andere Funktionen von PostgerSQL aufrufen. <br><br><ul><li>  <b>Bremsen von DBMS-Hintergrundprozessen</b> - PostgreSQL verf√ºgt √ºber alle Arten von Checkpoints, Vakuums und Replikationen. <br></li><li>  <b>Virtualisierungsaufwand</b> .  Wenn die Datenbank auf einer virtuellen Maschine ausgef√ºhrt wird, befinden sich auf demselben Eisenst√ºck auch virtuelle Maschinen an der Seite, die Konflikte um Ressourcen verursachen k√∂nnen. <br></li><li>  <b>Der Speicher stammt vom chinesischen Hersteller NoName</b> , dessen Leistung vom Mond im Steinbock oder der Position des Saturn abh√§ngt, und es gibt keine M√∂glichkeit herauszufinden, warum dies so funktioniert.  Die Basis leidet. <br></li><li>  <b>Die Standardkonfiguration</b> .  Dies ist mein Lieblingsthema: Der Kunde sagt, dass seine Datenbank langsamer wird - Sie sehen, und er hat eine Standardkonfiguration.  Tatsache ist, dass die Standard-PostgreSQL-Konfiguration f√ºr die <b>Ausf√ºhrung auf der schw√§chsten Teekanne ausgelegt ist</b> .  Die Basis wird gestartet, es funktioniert, aber wenn es bereits auf Hardware mittlerer Ebene funktioniert, reicht diese Konfiguration nicht aus, sie muss optimiert werden. <br></li></ul><br><blockquote>  In den meisten F√§llen fehlt PostgreSQL entweder der Speicherplatz oder die Festplattenleistung.  Gl√ºcklicherweise ist mit Prozessoren, Speicher und einem Netzwerk in der Regel mehr oder weniger alles in Ordnung. </blockquote><br>  Wie man ist  Brauchen Sie √úberwachung und Planung!  Es scheint offensichtlich, aber aus irgendeinem Grund plant in den meisten F√§llen niemand eine Basis, und die √úberwachung deckt nicht alles ab, was w√§hrend des Betriebs von PostgreSQL √ºberwacht werden muss.  Es gibt eine Reihe klarer Regeln, mit denen alles gut und nicht "zuf√§llig" funktioniert. <br><br><h3>  Planung </h3><br>  <b>Hosten Sie die Datenbank ohne zu z√∂gern auf einer SSD</b> .  SSDs sind seit langem zuverl√§ssig, stabil und produktiv.  Enterprise-SSD-Modelle gibt es schon seit Jahren. <br><br>  <b>Planen Sie immer ein Datenschema</b> .  Schreiben Sie nicht in die Datenbank, dass Sie Zweifel daran haben, was ben√∂tigt wird - garantiert nicht ben√∂tigt.  Ein einfaches Beispiel ist eine leicht modifizierte Tabelle eines unserer Kunden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/56f/9ec/9e156f9ec534a11c5e80180c1c72a987.png"><br><br>  Dies ist eine Protokolltabelle, in der sich eine Datenspalte vom Typ json befindet.  Relativ gesehen k√∂nnen Sie alles in diese Spalte schreiben.  Aus dem letzten Datensatz dieser Tabelle ist ersichtlich, dass die Protokolle 8 MB belegen.  PostgreSQL hat kein Problem damit, Datens√§tze dieser L√§nge zu speichern.  PostgreSQL hat einen sehr guten Speicher, der auf solchen Datens√§tzen kaut. <br><br>  Das Problem ist jedoch, dass Anwendungsserver beim Lesen von Daten aus dieser Tabelle leicht die gesamte Netzwerkbandbreite verstopfen und andere Anforderungen darunter leiden.  Dies ist das Problem bei der Planung eines Datenschemas. <br><br>  <b>Verwenden Sie die Partitionierung f√ºr jeden Hinweis auf eine Story, die l√§nger als zwei Jahre gespeichert werden muss</b> .  Die Partitionierung scheint manchmal kompliziert zu sein - Sie m√ºssen sich mit Triggern besch√§ftigen, mit Funktionen, die Partitionen erstellen.  In neuen Versionen von PostgreSQL ist die Situation besser und jetzt ist das Einrichten der Partitionierung viel einfacher - sobald dies erledigt ist und funktioniert. <br><br>  In dem betrachteten Beispiel zum L√∂schen von Daten in 10 Minuten kann <code>DELETE</code> durch <code>DROP TABLE</code> - ein solcher Vorgang dauert unter √§hnlichen Umst√§nden nur wenige Millisekunden. <br><br>  Wenn die Daten nach Partitionen sortiert sind, wird die Partition buchst√§blich in wenigen Millisekunden gel√∂scht und das Betriebssystem √ºbernimmt sofort.  Die Verwaltung historischer Daten ist einfacher, einfacher und sicherer. <br><br><h3>  √úberwachung </h3><br>  √úberwachung ist ein separates gro√ües Thema, aber aus Sicht der Datenbank gibt es Empfehlungen, die in einen Abschnitt des Artikels passen. <br><br>  Standardm√§√üig bieten viele √úberwachungssysteme die √úberwachung von Prozessoren, Speicher, Netzwerk und Speicherplatz. In der Regel <b>werden jedoch keine Festplattenger√§te entsorgt</b> .  Informationen dar√ºber, wie stark die Festplatten ausgelastet sind, welche Bandbreite derzeit auf den Festplatten vorhanden ist und welcher Latenzwert immer zur √úberwachung hinzugef√ºgt werden sollte.  Auf diese Weise k√∂nnen Sie schnell beurteilen, wie Laufwerke geladen sind. <br><br>  Es gibt viele PostgreSQL-√úberwachungsoptionen f√ºr jeden Geschmack.  Hier sind einige Punkte, die vorhanden sein m√ºssen. <br><br><ul><li>  <b>Verbundene Clients</b> .  Es ist notwendig zu √ºberwachen, mit welchen Status sie arbeiten, schnell die "sch√§dlichen" Kunden zu finden, die der Datenbank schaden, und sie auszuschalten. </li><li>  <b>Fehler</b>  Es ist notwendig, Fehler zu √ºberwachen, um zu verfolgen, wie gut die Datenbank funktioniert: Keine Fehler - gro√üartig, Fehler sind aufgetreten - ein Grund, sich die Protokolle anzusehen und zu verstehen, was falsch l√§uft. </li><li>  <b>Anfragen (Aussagen)</b> .  Wir √ºberwachen die quantitativen und qualitativen Merkmale von Anfragen, um grob zu beurteilen, ob wir langsame, lange oder ressourcenintensive Anfragen haben. </li></ul><br>  Weitere Informationen finden Sie im Bericht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûGrundlagen</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PostgreSQL-√úberwachung‚Äú</a> mit HighLoad ++ Siberia und auf der Seite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Äû√úberwachung‚Äú</a> im PostgreSQL-Wiki. <br><br>  Wenn wir alles geplant und uns mit der √úberwachung ‚Äûbedeckt‚Äú haben, k√∂nnen wir immer noch auf einige Probleme sto√üen. <br><br><h3>  Skalieren </h3><br>  Normalerweise sieht der Entwickler die Datenbankzeile in der Konfiguration.  Er ist nicht besonders daran interessiert, wie es intern angeordnet ist - wie Checkpoint, Replikation, Scheduler funktionieren.  Der Entwickler hat bereits etwas zu tun - in todo gibt es viele interessante Dinge, die er ausprobieren m√∂chte. <br><br><blockquote>  "Gib mir die Adresse der Basis, dann ich selbst."  ¬© Anonymer Entwickler. </blockquote><br>  Die Unwissenheit √ºber das Thema f√ºhrt zu interessanten Konsequenzen, wenn der Entwickler beginnt, Abfragen zu schreiben, die in dieser Datenbank funktionieren.  Fantasien beim Schreiben von Abfragen f√ºhren manchmal zu atemberaubenden Effekten. <br><br>  Es gibt zwei Arten von Transaktionen.  <b>OLTP-Transaktionen</b> sind schnell, kurz und leicht und dauern Bruchteile einer Millisekunde.  Sie arbeiten sehr schnell und es gibt viele von ihnen.  <b>OLAP - analytische Abfragen</b> - langsam, lang, schwer, gro√üe Tabellenfelder lesen und Statistiken lesen. <br><br>  <b>In den</b> letzten 2-3 Jahren klingt die Abk√ºrzung <b>HTAP</b> h√§ufig - Hybrid Transaction / Analytical Processing oder <b>Hybrid Transactional-Analytical Processing</b> .  Wenn Sie keine Zeit haben, √ºber Skalierung und Vielfalt von OLAP- und OLTP-Anforderungen nachzudenken, k√∂nnen Sie sagen: ‚ÄûWir haben HTAP!‚Äú  Die Erfahrung und der Schmerz von Fehlern zeigen jedoch, dass verschiedene Arten von Anforderungen getrennt voneinander leben m√ºssen, da lange OLAP-Anforderungen leichte OLTP-Anforderungen blockieren. <br><br>  Wir kommen also zu der Frage, wie PostgreSQL skaliert werden kann, um die Last zu verteilen, und alle waren zufrieden. <br><br>  <b>Streaming-Replikation</b> .  Die einfachste Option ist das <b>Streaming der Replikation</b> .  Wenn die Anwendung mit der Datenbank arbeitet, verbinden wir mehrere Replikate mit dieser Datenbank und verteilen die Last.  Die Aufnahme geht immer noch zur Master-Basis und das Lesen zu Replikaten.  Mit dieser Methode k√∂nnen Sie sehr weit skalieren. <br><br>  Au√üerdem k√∂nnen Sie mehr Replikate mit einzelnen Replikaten verbinden und eine <b>kaskadierte Replikation erhalten</b> .  Separate Benutzergruppen oder Anwendungen, die beispielsweise Analysen lesen, k√∂nnen in ein separates Replikat verschoben werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f4/5b3/2d7/7f45b32d7eeb8dfcd7e19cfb38210134.png"><br><br>  <b>Logische Ver√∂ffentlichungen, Abonnements</b> - Der Mechanismus logischer Ver√∂ffentlichungen und Abonnements impliziert das Vorhandensein mehrerer unabh√§ngiger PostgreSQL-Server mit separaten Datenbanken und Tabellens√§tzen.  Diese Tabellens√§tze k√∂nnen mit benachbarten Datenbanken verbunden werden. Sie sind f√ºr Anwendungen sichtbar, die sie normal verwenden k√∂nnen.  Das hei√üt, alle √Ñnderungen, die in der Quelle auftreten, werden auf die Zielbasis repliziert und sind dort sichtbar.  Funktioniert hervorragend mit PostgreSQL 10. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13a/4aa/068/13a4aa06893b4ae9f1a1b7523c407b06.png"><br><br>  <b>Fremdtabellen, deklarative Partitionierung - deklarative Partitionierung und externe Tabellen</b> .  Sie k√∂nnen mehrere PostgreSQL-Dateien verwenden und dort mehrere Tabellens√§tze erstellen, in denen die gew√ºnschten Datenbereiche gespeichert werden.  Dies k√∂nnen Daten f√ºr ein bestimmtes Jahr oder Daten sein, die √ºber einen beliebigen Bereich gesammelt wurden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/109/929/cb9/109929cb936d0c040651ad30c130258b.png"><br><br>  Mithilfe des Mechanismus externer Tabellen k√∂nnen Sie alle diese Datenbanken in Form einer partitionierten Tabelle in einem separaten PostgreSQL kombinieren.  Eine Anwendung arbeitet m√∂glicherweise bereits mit dieser partitionierten Tabelle, liest jedoch tats√§chlich Daten von Remote-Partitionen.  Wenn Datenmengen mehr als die F√§higkeiten eines einzelnen Servers sind, ist dies ein Sharding. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/446/d13/a39/446d13a394143b988ec04f60e645ea21.png"><br><br>  All dies kann zu verteilten Konfigurationen kombiniert werden, um verschiedene PostgreSQL-Replikationstopologien zu erstellen. Wie dies alles funktioniert und wie es verwaltet wird, ist das Thema eines separaten Berichts. <br><br><h3>  Wo soll ich anfangen? </h3><br>  Die einfachste Option ist die <b>Replikation</b> .  Der erste Schritt besteht darin, das Lesen und Schreiben zu verteilen.  Schreiben Sie also an den Master und lesen Sie aus Replikaten.  Also skalieren wir die Last und f√ºhren das Lesen vom Assistenten aus.  Vergessen Sie au√üerdem nicht die Analysten.  Analytische Abfragen funktionieren lange. Sie ben√∂tigen ein separates Replikat mit separaten Einstellungen, damit lange analytische Abfragen den Rest nicht beeintr√§chtigen k√∂nnen. <br><br>  Der n√§chste Schritt ist das <b>Balancieren</b> .  Wir haben immer noch die gleiche Zeile in der Konfiguration, mit der der Entwickler arbeitet.  Er braucht einen Ort, an dem er schreiben und lesen kann.  Hier gibt es mehrere M√∂glichkeiten. <br><br>  Ideal ist die Implementierung des Ausgleichs <b>auf Anwendungsebene</b> , wenn die Anwendung selbst wei√ü, woher die Daten gelesen werden sollen, und wei√ü, wie ein Replikat ausgew√§hlt wird.  Angenommen, ein Kontostand wird immer auf dem neuesten Stand ben√∂tigt und muss vom Master gelesen werden, und das Produktbild oder die Informationen dazu k√∂nnen mit einiger Verz√∂gerung gelesen und von einem Replikat erstellt werden. <br><br><ul><li>  <b>DNS Round Robin</b> ist meiner Meinung nach keine sehr praktische Implementierung, da es manchmal lange funktioniert und nicht die erforderliche Zeit f√ºr den Wechsel der Assistentenrollen zwischen Servern im Falle eines Failovers bietet. </li><li>  Eine interessantere Option ist die Verwendung von <b>Keepalived und HAProxy</b> .  Virtuelle Adressen f√ºr den Master und eine Reihe von Replikaten werden zwischen HAProxy-Servern geworfen, und HAProxy gleicht bereits den Datenverkehr aus. </li><li>  <b>Patroni, DCS</b> in Verbindung mit so etwas wie ZooKeeper, etcd, Consul - meiner Meinung nach die interessanteste Option.  Das hei√üt, die Serviceerkennung ist f√ºr die Informationen verantwortlich, wer jetzt der Master und wer das Replikat ist.  Patroni verwaltet einen Cluster von PostgreSQLs und f√ºhrt das Umschalten durch. Wenn sich die Topologie ge√§ndert hat, werden diese Informationen in der Diensterkennung angezeigt, und Anwendungen k√∂nnen die aktuelle Topologie schnell ermitteln. </li></ul><br>  Und es gibt Nuancen bei der Replikation, von denen die h√§ufigste die <b>Replikationsverz√∂gerung ist</b> .  Sie k√∂nnen es wie GitLab tun, und wenn sich die Verz√∂gerung ansammelt, lassen Sie einfach die Basis fallen.  Aber wir haben eine umfassende √úberwachung - wir schauen uns das an und sehen lange Transaktionen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/619/9a0/fae/6199a0fae7ed88fb1646e232cc1f2953.png"><br><br><h3>  Anwendungen und DBMS-Transaktionen </h3><br>  Im Allgemeinen f√ºhren langsame und inaktive Transaktionen zu: <br><br><ul><li>  <b>Produktivit√§tsabfall</b> - nicht zu einem scharfen Krampf, sondern zu einem glatten; <br></li><li>  <b>Sperren und Deadlocks</b> , da lange Transaktionen Sperren f√ºr Zeilen enthalten und verhindern, dass andere Transaktionen funktionieren. <br></li><li>  <b>50 * HTTP-Fehler im Backend</b> , Schnittstellenfehler oder anderswo. <br></li></ul><br><br>  Schauen wir uns eine kleine Theorie dar√ºber an, wie diese Probleme auftreten und warum der Mechanismus langer und inaktiver Transaktionen sch√§dlich ist. <br><br>  PostgreSQL hat MVCC - relativ gesehen eine Datenbank-Engine.  Kunden k√∂nnen damit wettbewerbsf√§hig mit Daten arbeiten, ohne sich gegenseitig zu st√∂ren: Leser st√∂ren Leser nicht, und Schriftsteller st√∂ren Schriftsteller nicht.  Nat√ºrlich gibt es einige Ausnahmen, aber in diesem Fall sind sie nicht wichtig. <br><br>  Es stellt sich heraus, dass es in der Datenbank f√ºr eine Zeile mehrere Versionen f√ºr verschiedene Transaktionen geben kann.  Clients stellen eine Verbindung her, die Datenbank gibt ihnen Snapshots von Daten, und innerhalb dieser Snapshots k√∂nnen verschiedene Versionen derselben Zeile vorhanden sein.  Dementsprechend werden im Lebenszyklus der Datenbank Transaktionen verschoben, ersetzt und es werden Versionen von Zeilen angezeigt, die niemand ben√∂tigt. <br><br>  Es besteht also ein <b>Bedarf an einem M√ºllsammler - automatischem Vakuum</b> .  Es bestehen lange Transaktionen, die verhindern, dass durch automatisches Vakuum unn√∂tige Zeilenversionen entfernt werden.  Diese Junk-Daten wandern von Speicher zu Datentr√§ger, von Datentr√§ger zu Speicher.  Um diesen M√ºll zu speichern, werden CPU- und Speicherressourcen verschwendet. <br><br><blockquote>  Je l√§nger die Transaktion dauert, desto mehr Junk und geringere Leistung. </blockquote><br>  Unter dem Gesichtspunkt von ‚ÄûWer ist schuld?‚Äú Ist die App f√ºr das Auftreten langer Transaktionen verantwortlich.  Wenn die Datenbank f√ºr sich allein existiert, werden lange Nichtstun-Transaktionen von nirgendwoher ausgef√ºhrt.  In der Praxis gibt es die folgenden Optionen f√ºr das Auftreten von Transaktionen im Leerlauf. <br><br>  <b>"Gehen wir zu einer externen Quelle</b> . <b>"</b>  Die Anwendung √∂ffnet eine Transaktion, f√ºhrt etwas in der Datenbank aus und entscheidet sich dann f√ºr eine externe Quelle, z. B. Memcached oder Redis, in der Hoffnung, dass sie dann zur Datenbank zur√ºckkehrt, weiterarbeitet und die Transaktion schlie√üt.  Wenn jedoch ein Fehler in der externen Quelle auftritt, st√ºrzt die Anwendung ab und die Transaktion bleibt geschlossen, bis jemand sie bemerkt und beendet. <br><br>  <b>Keine Fehlerbehandlung</b> .  Andererseits kann es zu Problemen bei der Fehlerbehandlung kommen.  Als die Anwendung erneut eine Transaktion √∂ffnete, ein Problem in der Datenbank l√∂ste, zur Codeausf√ºhrung zur√ºckkehrte, einige Funktionen und Berechnungen ausf√ºhrte, um die Arbeit in der Transaktion fortzusetzen und sie zu schlie√üen.  Wenn bei diesen Berechnungen der Anwendungsvorgang mit einem Fehler unterbrochen wurde, kehrte der Code zum Beginn des Zyklus zur√ºck und die Transaktion blieb erneut geschlossen. <br><br>  <b>Der menschliche Faktor</b> .  Zum Beispiel arbeitet ein Administrator, Entwickler, Analyst in einem pgAdmin oder in DBeaver - hat eine Transaktion ge√∂ffnet und tut etwas darin.  Dann wurde die Person abgelenkt, er wechselte zu einer anderen Aufgabe, dann zur dritten, verga√ü die Transaktion, ging f√ºr das Wochenende und die Transaktion h√§ngt weiter.  Die Basisleistung leidet. <br><br>  Mal sehen, was in diesen F√§llen zu tun ist. <br><br><ul><li>  Wir haben √úberwachung, dementsprechend ben√∂tigen wir <b>Warnungen bei der √úberwachung</b> .  Jede Transaktion, die l√§nger als eine Stunde dauert und nichts tut, ist eine Gelegenheit, um zu sehen, woher sie stammt, und um zu verstehen, was falsch ist. </li><li>  Der n√§chste Schritt besteht darin <b>, solche Transaktionen √ºber die Aufgabe in der Krone</b> (pg_terminate_backend (pid)) oder in der PostgreSQL-Konfiguration zu konfigurieren.  Schwellenwerte von 10 bis 30 Minuten sind erforderlich. Danach werden die Transaktionen automatisch abgeschlossen. </li><li>  <b>Anwendungs-Refactoring</b> .  Nat√ºrlich m√ºssen Sie herausfinden, woher die inaktiven Transaktionen kommen, warum sie auftreten, und solche Orte beseitigen. </li></ul><br><blockquote>  Vermeiden Sie um jeden Preis lange Transaktionen, da diese die Datenbankleistung stark beeintr√§chtigen. </blockquote><br>  Alles wird noch interessanter, wenn anstehende Aufgaben angezeigt werden. Beispielsweise m√ºssen Sie die Einheiten sorgf√§ltig berechnen.  Und wir kommen zum Thema Fahrradbau. <br><br><h3>  Fahrradbau </h3><br>  Wund Thema.  Unternehmen auf der Anwendungsseite m√ºssen die Hintergrundverarbeitung von Ereignissen durchf√ºhren.  Zum Beispiel, um Aggregate zu berechnen: Minimum, Maximum, Durchschnittswert, Benachrichtigungen an Benutzer senden, Kunden in Rechnung stellen, nach der Registrierung ein Benutzerkonto einrichten oder sich bei benachbarten Diensten registrieren - verz√∂gerte Verarbeitung. <br><br>  Das Wesentliche solcher Aufgaben ist das gleiche - sie werden auf sp√§ter verschoben.  In der Datenbank werden Tabellen angezeigt, die nur die Warteschlangen ausf√ºhren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef4/bfa/f20/ef4bfaf20634c6d43941c9c8325a09ff.png"><br><br>  Hier ist die Kennung der Aufgabe, der Zeitpunkt, zu dem die Aufgabe erstellt wurde, die Aktualisierung, der Handler, der sie ausgef√ºhrt hat, die Anzahl der zu erledigenden Versuche.  Wenn Sie eine Tabelle haben, die dieser auch nur ann√§hernd √§hnelt, haben Sie <b>selbst geschriebene Warteschlangen</b> . <br><br>  All dies funktioniert einwandfrei, bis lange Transaktionen angezeigt werden.  Danach nehmen <b>Tabellen, die mit Warteschlangen arbeiten, an Gr√∂√üe zu</b> .  Es werden st√§ndig neue Jobs hinzugef√ºgt, alte gel√∂scht, Aktualisierungen vorgenommen - eine Tabelle mit intensiver Aufzeichnung wird erhalten.  Es sollte regelm√§√üig von veralteten Versionen von Zeichenfolgen gereinigt werden, damit die Leistung nicht beeintr√§chtigt wird. <br><br>  <b>Die Verarbeitungszeit nimmt zu</b> - eine lange Transaktion blockiert veraltete Versionen von Zeilen oder verhindert, dass Vakuum sie bereinigt.  Wenn die Tabelle gr√∂√üer wird, erh√∂ht sich auch die Verarbeitungszeit, da Sie viele Seiten mit M√ºll lesen m√ºssen.  Die Zeit nimmt zu und die <b>Warteschlange funktioniert irgendwann √ºberhaupt nicht mehr</b> . <br><br>  Unten sehen Sie ein Beispiel f√ºr die Spitze eines unserer Kunden, der eine Warteschlange hatte.  Alle Anfragen beziehen sich nur auf die Warteschlange. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/344/203/7ac/3442037ac837daec02ee89a83bd53dd7.png"><br><br>  Achten Sie auf die Ausf√ºhrungszeit dieser Anforderungen - alle bis auf eine arbeiten l√§nger als zwanzig Sekunden. <br><br>  Um diese Probleme zu l√∂sen, wurde <b>Skytools PgQ</b> , ein Warteschlangenmanager f√ºr PostgreSQL, vor langer Zeit erfunden.  Erfinden Sie Ihr Fahrrad nicht neu - nehmen Sie PgQ, richten Sie es einmal ein und vergessen Sie die Linien. <br><br>  Es stimmt, er hat auch Funktionen.  Skytools PgQ hat <b>wenig Dokumentation</b> .  Nach dem Lesen der offiziellen Seite hat man das Gef√ºhl, nichts verstanden zu haben.  Das Gef√ºhl w√§chst, wenn Sie versuchen, etwas zu tun.  Alles funktioniert, aber <b>wie es funktioniert, ist nicht klar</b> .  Eine Art Jedi-Magie.  Viele Informationen finden Sie jedoch in <b>Mailinglisten</b> .  Dies ist kein sehr praktisches Format, aber es gibt viele interessante Dinge, und Sie m√ºssen diese Bl√§tter lesen. <br><br>  Trotz der Nachteile arbeitet Skytools PgQ nach dem Prinzip "Einrichten und Vergessen".   ,    ,     ,    .   PgQ ,        .  PgQ ,      . <br><br><blockquote>    ,   -     ‚Äî  ,   .     . </blockquote><br>              PgQ. ,    PostgreSQL, ,  ,   PgQ  .    ,   . <br><br><h3>  </h3><br>        ,          .   ,    , ,     - ,   , ,      . ,       ,       ,   alter. <br><br>     <b>auto-failover</b> ‚Äî       PostgreSQL  - ,       ,        .      ,    auto-failover. <br><br> <b>Split-brain</b> .    PostgreSQL     ,     ,  ‚Äî  .   ,   .   PostgreSQL     fencing,     Kubernets    .     -    ,         .   Split-brain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/327/239/97e/32723997e13e8427e4cddc59ea7c964f.png"><br><br>           .  GitHub   Split-brain,       . <br><br> <b>Cascade failover</b> . ,     .  ,         . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea9/864/d63/ea9864d63b7cebd46ff8b185ddb5d639.png"><br><br>        ,       .    ,       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81d/243/fc1/81d243fc1500011f0f3c24576f81786a.png"><br><br>         ‚Äî   failover. <br><br>      auto-failover,    . <br><br> <b>Bash </b> ‚Äî  ,      .   ,     ,   .   - ,   ,   .     . <br><br> <b>Ansible playbooks</b> ‚Äî bash-  .    ,   ,    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Patroni</b></a> ‚Äî   ,    ,      auto-failover,   ,       service discovery. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>PAF</b></a> ‚Äî <b>  Pacemaker</b> .     auto-failover  PostgreSQL,        Pacemaker. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Stolon</b></a>     .  Kubernetes, . Stolon  Patroni,        . <br><br><h3>    </h3><br>    Docker  Kubernetes .    ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b99/aba/8c4/b99aba8c4f9c959cd96840bfcd3359b2.png"><br><br>        ,       . <i> ¬´      Kubernetes...¬ª</i>    . <br><br> <b> ‚Äî   stateful</b> ,   - .  Wo?      .   Open Source: CEPH, GlusterFS, LinStor DRBD.    ,       , ,     . <br><br>       ‚Äî <b>    </b> . ,      Kubernetes,     CEPH.         ‚Äî    .           ,       . <br><br><ul><li> <b>  </b> ,           . </li><li> <b>     latency</b> .  latency        ‚Äî    . </li><li> <b>   </b> . Kubernetes ,    - . ,    shared storage  Kubernetes,       .  -         . </li></ul><br>     ,    Kubernetes  Docker    staging  dev-     .    ,   , Kubernetes      . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b04/8dd/fd0/b048ddfd0b6212ef2d1eb49eda02386b.png"><br><br>    ,     <b>local volumes ‚Äî  </b>     , <b>streaming replication ‚Äî   </b> ,       <b>PostgreSQL-</b> ,       ‚Äî ,   .       : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zalando</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Crunchy</a> . <br><br>    ,     .    issues  pull requests.   ,     ,     . <br><br><h2>  </h2><br> <b>         SSD</b> ‚Äî          ,    . <br><br> <b>     </b> .   JSON  8  ‚Äî  ,   . <br><br> <b> </b> ,        .  PostgreSQL,   . <br><br> <b>  ‚Äî Postgres is ready</b> .          . PostgreSQL   ,        .    : <b>streaming replication; publications, subscriptions; foreign Tables; declarative partitioning</b> . <br><br> <b>    </b> .      ,    . <br><br>    -,      ,   ‚Äî <b>   </b> .    .    ,  Skytools PgQ! <br><br> <b>     Kubernetes,  local volumes, streaming replication  PostgreSQL </b> .     - ,   ,      . <br><br><blockquote>               .     ,   24  25   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad++ Siberia</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  ,    ,           .   38    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ‚Äî     ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455248/">https://habr.com/ru/post/de455248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455236/index.html">Comodo widerruft Zertifikate ohne Grund</a></li>
<li><a href="../de455240/index.html">Verwenden der abgelehnten Fehlerrate zur Verbesserung der Fehlerberichterstattung</a></li>
<li><a href="../de455242/index.html">Weniger Ohren oder wie man den Sound im Spiel nicht von Anfang an verdirbt</a></li>
<li><a href="../de455244/index.html">Comic "L√∂ten ist einfach" in der aktualisierten Version (2019)</a></li>
<li><a href="../de455246/index.html">Die Registrierung f√ºr den Customer Experience Day in St. Petersburg ist am 20. Juni ge√∂ffnet</a></li>
<li><a href="../de455250/index.html">Derjenige, der Herzog Nukem wiederbelebt hat: Interview mit Randy Pitchford, Magier von Gearbox</a></li>
<li><a href="../de455252/index.html">.NET: Tools zum Arbeiten mit Multithreading und Asynchronit√§t - Teil 1</a></li>
<li><a href="../de455256/index.html">Habr Weekly # 4 / Computex, wie k√∂nnen wir Apple Beta, Durov hungert, BadComedian Katze, warum hat das neuronale Netzwerk nach Pornodarstellern gesucht</a></li>
<li><a href="../de455258/index.html">Die Abstimmung f√ºr die Berichte der Backend-Sektion zum Jubil√§um von DevConfX begann am 21. und 22. Juni in Moskau</a></li>
<li><a href="../de455260/index.html">Merkle Tree: rostig und schnell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>