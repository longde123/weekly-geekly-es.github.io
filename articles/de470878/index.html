<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåì üêé üë©üèª‚Äçüè´ Erstellen Sie mit Babel benutzerdefinierte JavaScript-Syntaxkonstrukte. Teil 2 üë∑ üòå üéª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute ver√∂ffentlichen wir den zweiten Teil einer √úbersetzung der JavaScript-Syntaxerweiterung mit Babel. 

  

 ‚Üí Schwindelerregender erster Teil 

 W...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie mit Babel benutzerdefinierte JavaScript-Syntaxkonstrukte. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/470878/">  Heute ver√∂ffentlichen wir den zweiten Teil einer √úbersetzung der JavaScript-Syntaxerweiterung mit Babel. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/i-/ll/wz/i-llwz7io9q0spj7eijn8hokkqe.jpeg"></a> <br><br>  ‚Üí Schwindelerregender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erster Teil</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Wie das Parsen funktioniert</font> </h2><br>  Der Parser empf√§ngt eine Liste von Token vom Code-Tokenisierungssystem und erstellt einen AST, indem er die Token einzeln untersucht.  Um eine Entscheidung √ºber die Verwendung von Token zu treffen und zu verstehen, welches Token als n√§chstes erwartet werden kann, verweist der Parser auf die Angabe der Grammatik der Sprache. <br><br>  Die Grammatikspezifikation sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre><code class="javascript hljs">... ExponentiationExpression -&gt; UnaryExpression                             UpdateExpression ** ExponentiationExpression MultiplicativeExpression -&gt; ExponentiationExpression                             MultiplicativeExpression (<span class="hljs-string"><span class="hljs-string">"*"</span></span> or <span class="hljs-string"><span class="hljs-string">"/"</span></span> or <span class="hljs-string"><span class="hljs-string">"%"</span></span>) ExponentiationExpression AdditiveExpression    -&gt; MultiplicativeExpression                             AdditiveExpression + MultiplicativeExpression                             AdditiveExpression - MultiplicativeExpression ...</code> </pre> <br>  Es beschreibt die Priorit√§t der Ausf√ºhrung von Ausdr√ºcken oder Anweisungen.  Ein <code>AdditiveExpression</code> Ausdruck kann beispielsweise eines der folgenden Konstrukte darstellen: <br><br><ul><li>  Ausdruck <code>MultiplicativeExpression</code> . </li><li>  Ein <code>AdditiveExpression</code> Ausdruck, gefolgt von einem <code>+</code> -Token-Operator, gefolgt von einem <code>MultiplicativeExpression</code> Ausdruck. </li><li>  Ein <code>AdditiveExpression</code> Ausdruck, gefolgt von einem " <code>-</code> " <code>-</code> Token, gefolgt von einem <code>MultiplicativeExpression</code> Ausdruck. </li></ul><br>  Wenn wir also den Ausdruck <code>1 + 2 * 3</code> , sieht er folgenderma√üen aus: <br><br><pre> <code class="javascript hljs">(AdditiveExpression <span class="hljs-string"><span class="hljs-string">"+"</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (MultiplicativeExpression <span class="hljs-string"><span class="hljs-string">"*"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre> <br>  Aber es wird nicht so sein: <br><br><pre> <code class="javascript hljs">(MultiplicativeExpression <span class="hljs-string"><span class="hljs-string">"*"</span></span> (AdditiveExpression <span class="hljs-string"><span class="hljs-string">"+"</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Das Programm wird unter Verwendung dieser Regeln in vom Parser ausgegebenen Code konvertiert: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-comment"><span class="hljs-comment">// ...  parseAdditiveExpression() {    const left = this.parseMultiplicativeExpression();    //    -  `+`  `-`    if (this.match(tt.plus) || this.match(tt.minus)) {      const operator = this.state.type;      //          this.nextToken();      const right = this.parseMultiplicativeExpression();      //        this.finishNode(        {          operator,          left,          right,        },        'BinaryExpression'      );    } else {      //  MultiplicativeExpression      return left;    }  } }</span></span></code> </pre> <br>  Bitte beachten Sie, dass hier eine extrem vereinfachte Version dessen ist, was tats√§chlich in Babel vorhanden ist.  Ich hoffe jedoch, dass dieser Code es uns erm√∂glicht, die Essenz des Geschehens zu veranschaulichen. <br><br>  Wie Sie sehen k√∂nnen, ist der Parser von Natur aus rekursiv.  Es wechselt von den Designs mit der niedrigsten Priorit√§t zu den Designs mit der h√∂chsten Priorit√§t.  Beispielsweise ruft <code>parseMultiplicativeExpression</code> , und dieses Konstrukt ruft <code>parseExponentiationExpression</code> usw. auf.  Dieser rekursive Prozess wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rekursives Abstiegsparsing bezeichnet</a> . <br><br><h2>  <font color="#3AC1EF">Funktionen this.eat, this.match, this.next</font> </h2><br>  M√∂glicherweise haben Sie bemerkt, dass in den vorherigen Beispielen einige Hilfsfunktionen verwendet wurden, z. B. <code>this.eat</code> , <code>this.match</code> , <code>this.next</code> und andere.  Dies sind die internen Funktionen des Babel-Parsers.  Diese Funktionen sind jedoch nicht nur f√ºr Babel verf√ºgbar, sondern normalerweise auch in anderen Parsern vorhanden. <br><br><ul><li>  Die Funktion <code>this.match</code> gibt einen booleschen Wert zur√ºck, der angibt, ob das aktuelle Token die angegebene Bedingung erf√ºllt. </li><li>  Die Funktion <code>this.next</code> sich in der Liste der Token vorw√§rts zum n√§chsten Token. </li><li>  Die Funktion <code>this.eat</code> gibt dasselbe zur√ºck wie die Funktion <code>this.match</code> Wenn <code>this.match</code> <code>true</code> <code>this.eat</code> f√ºhrt <code>this.eat</code> vor der R√ºckgabe von <code>true</code> einen Aufruf von <code>this.next</code> . </li><li>  Mit der Funktion <code>this.lookahead</code> k√∂nnen Sie das n√§chste Token <code>this.lookahead</code> ohne vorw√§rts zu gehen. <code>this.lookahead</code> hilft Ihnen, eine Entscheidung √ºber den aktuellen Knoten zu treffen. </li></ul><br>  Wenn Sie sich den von uns ge√§nderten Parser-Code noch einmal ansehen, werden Sie feststellen, dass das Lesen viel einfacher geworden ist: <br><br><pre> <code class="javascript hljs">packages/babel-parser/src/parser/statement.js <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatementParser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionParser</span></span></span><span class="hljs-class"> </span></span>{  parseStatementContent(<span class="hljs-comment"><span class="hljs-comment">/* ...*/</span></span>) {    <span class="hljs-comment"><span class="hljs-comment">// ...    // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment">   match        if (this.match(tt._function)) {      this.next();      // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment">     ,          this.parseFunction();    }  }  // ...  parseFunction(/* ... */) {    // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment">   eat         node.generator = this.eat(tt.star);    node.curry = this.eat(tt.atat);    node.id = this.parseFunctionId();  } }</span></span></code> </pre> <br>  Ich wei√ü, dass ich mich nicht eingehend mit den Funktionen von Parsern befasst habe.  Deshalb <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">da</a> - ein paar n√ºtzliche Ressourcen zu diesem Thema.  Ich habe viele davon gelernt und kann sie Ihnen empfehlen. <br><br>  Vielleicht m√∂chten Sie wissen, wie ich die in Babel AST Explorer erstellte Syntax visualisieren konnte, als ich das neue <code>curry</code> Attribut in AST zeigte. <br><br>  Dies wurde m√∂glich, weil ich im Babel AST Explorer eine neue Funktion hinzugef√ºgt habe, mit der Sie Ihren eigenen Parser in dieses AST-Recherchetool laden k√∂nnen. <br><br>  Wenn Sie dem Pfad <code>packages/babel-parser/lib</code> , finden Sie eine kompilierte Version des Parsers und eine Codezuordnung.  Im <code>Babel AST Explorer</code> Bedienfeld sehen Sie die Schaltfl√§che zum Laden Ihres eigenen Parsers.  Durch Herunterladen der <code>packages/babel-parser/lib/index.js</code> Sie den mit Ihrem eigenen Parser generierten AST visualisieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/965/5bf/2b7/9655bf2b7ba72e0c61e31a63a29e3f22.gif"></div><br>  <i><font color="#999999">AST-Visualisierung</font></i> <br><br><h2>  <font color="#3AC1EF">Unser Plugin f√ºr Babel</font> </h2><br>  Nachdem der Parser vollst√§ndig ist, schreiben wir ein Plugin f√ºr Babel. <br><br>  Aber vielleicht haben Sie jetzt einige Zweifel, wie genau wir unseren eigenen Babel-Parser verwenden werden, insbesondere wenn man bedenkt, welchen Technologie-Stack wir zum Erstellen des Projekts verwenden. <br><br>  Es gibt zwar nichts zu bef√ºrchten.  Das Babel-Plugin kann Parser-Funktionen bereitstellen.  Zugeh√∂rige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentationen</a> finden Sie auf der Babel-Website. <br><br><pre> <code class="javascript hljs">babel-plugin-transformation-curry-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">js</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">import</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">customParser</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> './</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">custom</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser</span></span></span><span class="hljs-function">'; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ourBabelPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {    parserOverride(code, opts) {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> customParser.parse(code, opts);    },  }; }</code> </pre> <br>  Da wir einen Fork des Babel-Parsers erstellt haben, funktionieren alle vorhandenen Parser-Funktionen sowie die integrierten Plugins weiterhin einwandfrei. <br><br>  Nachdem wir diese Zweifel beseitigt haben, schauen wir uns an, wie eine Funktion so erstellt wird, dass sie das Curry unterst√ºtzt. <br><br>  Wenn Sie die Erwartungen nicht erf√ºllen konnten und bereits versucht haben, unser Plug-In zu Ihrem Projekterstellungssystem hinzuzuf√ºgen, werden Sie m√∂glicherweise feststellen, dass Funktionen, die das Currying unterst√ºtzen, zu regul√§ren Funktionen kompiliert werden. <br><br>  Dies geschieht, weil Babel nach dem Parsen und Transformieren des Codes <code>@babel/generator</code> , um Code aus dem transformierten AST zu generieren.  Da <code>@babel/generator</code> nichts √ºber das neue <code>curry</code> Attribut wei√ü, wird es einfach ignoriert. <br><br>  Wenn eines Tages Funktionen, die das Currying unterst√ºtzen, in den JavaScript-Standard aufgenommen werden, m√∂chten Sie m√∂glicherweise eine PR durchf√ºhren, um hier neuen Code hinzuzuf√ºgen. <br><br>  Damit die Funktion das Currying unterst√ºtzt, k√∂nnen Sie sie in ein Funktionscurrying h√∂herer Ordnung einwickeln: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">currying</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numParamsRequired = fn.length;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curryFactory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">params</span></span></span><span class="hljs-function">) </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newParams = params.concat(args);      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newParams.length &gt;= numParamsRequired) {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...newParams);      }      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> curryFactory(newParams);    }  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> curryFactory([]); }</code> </pre> <br>  Wenn Sie an den Funktionen der Implementierung des Mechanismus der Currying-Funktionen in JS interessiert sind, schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Material an. <br><br>  Infolgedessen k√∂nnen wir eine Funktion transformieren, die das Currying unterst√ºtzt: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   function @@ foo(a, b, c) {  return a + b + c; } //    const foo = currying(function foo(a, b, c) {  return a + b + c; })</span></span></code> </pre> <br>  Im Moment werden wir uns nicht mit dem Mechanismus zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausl√∂sen von Funktionen</a> in JavaScript befassen, mit dem Sie die Funktion <code>foo</code> aufrufen k√∂nnen, bevor sie definiert ist. <br><br>  So sieht der Transformationscode aus: <br><br><pre> <code class="javascript hljs">babel-plugin-transformation-curry-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">js</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ourBabelPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {    <span class="hljs-comment"><span class="hljs-comment">// ... &lt;i&gt;    visitor: {      FunctionDeclaration(path) {        if (path.get('curry').node) {          // const foo = curry(function () { ... });          path.node.curry = false;          path.replaceWith(            t.variableDeclaration('const', [              t.variableDeclarator(                t.identifier(path.get('id.name').node),                t.callExpression(t.identifier('currying'), [                  t.toExpression(path.node),                ])              ),            ])          );        }      },    },&lt;/i&gt;  }; }</span></span></code> </pre> <br>  Es wird f√ºr Sie viel einfacher sein, es herauszufinden, wenn Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Material √ºber Transformationen in Babel lesen. <br><br>  Nun stehen wir vor der Frage, wie dieser Mechanismus Zugang zur <code>currying</code> Funktion erhalten kann.  Hier k√∂nnen Sie einen von zwei Ans√§tzen verwenden. <br><br><h3>  <font color="#3AC1EF">‚ñçAnsatz Nr. 1: Es kann davon ausgegangen werden, dass die Currying-Funktion im globalen Bereich deklariert ist</font> </h3><br>  Wenn ja, ist die Arbeit bereits erledigt. <br><br>  Wenn sich beim Ausf√ºhren des kompilierten Codes herausstellt, dass die <code>currying</code> Funktion nicht definiert ist, wird eine Fehlermeldung angezeigt, die wie <code>currying is not defined</code> aussieht: " <code>currying is not defined</code> ".  Es ist der Meldung " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">regeneratorRuntime is not defined</a> " sehr √§hnlich. <br><br>  Wenn jemand Ihr <code>babel-plugin-transformation-curry-function</code> , m√ºssen Sie ihn m√∂glicherweise dar√ºber informieren, dass er die <code>currying</code> Polyf√ºllung installieren muss, um sicherzustellen, dass dieses Plugin ordnungsgem√§√ü funktioniert. <br><br><h3>  <font color="#3AC1EF">‚ñç Ansatz 2: Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Babel</a> / Helfer verwenden</font> </h3><br>  Sie k√∂nnen <code>@babel/helpers</code> eine neue Hilfsfunktion hinzuf√ºgen.  Es ist unwahrscheinlich, dass diese Entwicklung mit dem offiziellen <code>@babel/helpers</code> kombiniert wird.  Infolgedessen m√ºssen Sie einen Weg finden, um <code>@babel/core</code> den Speicherort Ihres <code>@babel/helpers</code> : <br><br><pre> <code class="javascript hljs">package.json {  <span class="hljs-string"><span class="hljs-string">"resolutions"</span></span>: {    <span class="hljs-string"><span class="hljs-string">"@babel/helpers"</span></span>: <span class="hljs-string"><span class="hljs-string">"7.6.0--your-custom-forked-version"</span></span>,  }</code> </pre> <br>  Ich habe es selbst nicht versucht, aber ich glaube, dass dieser Mechanismus funktionieren wird.  Wenn Sie es versuchen und auf Probleme sto√üen, werde ich es gerne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">besprechen</a> . <br><br>  <code>@babel/helpers</code> neuen Hilfsfunktion zu <code>@babel/helpers</code> sehr einfach. <br><br>  <a href="">Wechseln Sie zun√§chst zur Datei packages / babel-helpers / src / helpers.js</a> und f√ºgen Sie einen neuen Eintrag hinzu: <br><br><pre> <code class="javascript hljs">helpers.currying = helper(<span class="hljs-string"><span class="hljs-string">"7.6.0"</span></span>)<span class="hljs-string"><span class="hljs-string">`  export default function currying(fn) {    const numParamsRequired = fn.length;    function curryFactory(params) {      return function (...args) {        const newParams = params.concat(args);        if (newParams.length &gt;= numParamsRequired) {          return fn(...newParams);        }        return curryFactory(newParams);      }    }    return curryFactory([]);  } `</span></span>;</code> </pre> <br>  Bei der Beschreibung einer Hilfsfunktion wird die erforderliche Version <code>@babel/core</code> angegeben.  Einige Schwierigkeiten k√∂nnen hier durch den <code>export default</code> der <code>currying</code> Funktion verursacht werden. <br><br>  Um eine <code>this.addHelper()</code> zu verwenden, rufen <code>this.addHelper()</code> einfach <code>this.addHelper()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ... path.replaceWith(  t.variableDeclaration('const', [    t.variableDeclarator(      t.identifier(path.get('id.name').node),      t.callExpression(this.addHelper("currying"), [        t.toExpression(path.node),      ])    ),  ]) );</span></span></code> </pre> <br>  Der Befehl <code>this.addHelper</code> bei Bedarf die <code>this.addHelper</code> oben in die Datei ein und gibt einen <code>Identifier</code> , der die implementierte Funktion angibt. <br><br><h2>  <font color="#3AC1EF">Anmerkungen</font> </h2><br>  Ich bin schon seit einiger Zeit an der Arbeit an Babel beteiligt, musste jedoch noch keine Funktionen hinzuf√ºgen, um die neue JavaScript-Syntax f√ºr den Parser zu unterst√ºtzen.  Ich habe haupts√§chlich daran gearbeitet, Fehler zu beheben und die f√ºr die offiziellen Sprachfunktionen relevanten Funktionen zu verbessern. <br><br>  Seit einiger Zeit besch√§ftigte ich mich jedoch mit der Idee, der Sprache neue Syntaxkonstrukte hinzuzuf√ºgen.  Aus diesem Grund habe ich beschlossen, Material dar√ºber zu schreiben und es auszuprobieren.  Es ist unglaublich sch√∂n zu sehen, dass alles genau wie erwartet funktioniert. <br><br>  Die M√∂glichkeit, die Syntax der von Ihnen verwendeten Sprache zu steuern, ist eine starke Inspirationsquelle.  Dies erm√∂glicht es, durch die Implementierung einiger komplexer Konstruktionen weniger Code zu schreiben oder einfacheren Code als zuvor zu schreiben.  Die Mechanismen zur Umwandlung von einfachem Code in komplexe Konstruktionen werden automatisiert und in die Kompilierungsphase √ºbertragen.  Dies erinnert daran, wie <code>async/await</code> die Probleme von H√∂llenr√ºckrufen und langen Versprechungsketten l√∂st. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Hier haben wir dar√ºber gesprochen, wie die Funktionen des Babel-Parsers ge√§ndert werden k√∂nnen. Wir haben unser eigenes Code-Transformations-Plugin geschrieben, kurz √ºber <code>@babel/generator</code> und √ºber das Erstellen von Hilfsfunktionen mit <code>@babel/helpers</code> .  Informationen zur Transformation des Codes werden nur schematisch gegeben.  Lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> mehr dar√ºber. <br><br>  Dabei haben wir einige Funktionen der Parser angesprochen.  Wenn Sie sich f√ºr dieses Thema interessieren - dann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">da</a> - Ressourcen, die f√ºr Sie n√ºtzlich sind. <br><br>  Die Reihenfolge der Aktionen, die wir ausgef√ºhrt haben, ist einem Teil des Prozesses sehr √§hnlich, der ausgef√ºhrt wird, wenn eine neue JavaScript-Funktion an TC39 gesendet wird.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auf</a> der TC39-Repository-Seite finden Sie Informationen zu aktuellen Angeboten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier finden</a> Sie detailliertere Informationen zur Arbeit mit √§hnlichen Angeboten.  Wenn Sie eine neue JavaScript-Funktion vorschlagen, schreibt derjenige, der sie anbietet, normalerweise Polyfills oder bereitet durch Verzweigen von Babel eine Demonstration vor, die beweist, dass der Satz funktioniert.  Wie Sie sehen, ist das Erstellen einer Abzweigung eines Parsers oder das Schreiben einer Polyf√ºllung nicht der schwierigste Teil des Prozesses zum Vorschlagen neuer JS-Funktionen.  Es ist schwierig, den Themenbereich Innovation zu bestimmen, Optionen f√ºr seine Verwendung und Grenzf√§lle zu planen und zu √ºberdenken.  Es ist schwierig, die Meinungen und Vorschl√§ge von Mitgliedern der JavaScript-Programmierer-Community zu sammeln  Daher m√∂chte ich all jenen meinen Dank aussprechen, die die Kraft finden, TC39 neue JavaScript-Funktionen anzubieten und damit diese Sprache zu entwickeln. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist eine</a> Seite auf GitHub, auf der Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen</a> √úberblick √ºber das bekommen, was wir hier gemacht haben. <br><br>  <b>Liebe Leser!</b>  Wollten Sie schon immer die Syntax von JavaScript erweitern? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470878/">https://habr.com/ru/post/de470878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470868/index.html">Zeit bis zum ersten Byte: Was ist das und warum ist es wichtig?</a></li>
<li><a href="../de470870/index.html">Schriftarten vorladen</a></li>
<li><a href="../de470872/index.html">Leistungsmetriken f√ºr die Suche nach unglaublich schnellen Webanwendungen</a></li>
<li><a href="../de470874/index.html">Optimierung des Ladens von JavaScript auf Wikipedia</a></li>
<li><a href="../de470876/index.html">Erstellen Sie mit Babel benutzerdefinierte JavaScript-Syntaxkonstrukte. Teil 1</a></li>
<li><a href="../de470880/index.html">Spielmechanik. Abenteuer, das Konzept der Null und √ºberzeugende Sprachtherapie</a></li>
<li><a href="../de470882/index.html">Warum hast du meine Maus oder ein Brettspiel als Modell f√ºr soziale Interaktion erwischt?</a></li>
<li><a href="../de470884/index.html">Schreiben und Lesen von Daten in der Bitcoin-Blockchain</a></li>
<li><a href="../de470888/index.html">Russische und internationale Gesetzgebung im Bereich des Schutzes personenbezogener Daten</a></li>
<li><a href="../de470892/index.html">Einfache Implementierung eines kleinen CAM auf einem FPGA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>