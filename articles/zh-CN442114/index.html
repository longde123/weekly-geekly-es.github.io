<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑‍🤝‍🧑 🗜️ 🍜 智能合约自动审核指南。 第3部分：秘银 🦕 👨‍🎓 🌟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="警告 


 本文未对自动分析仪的有效性进行评级。 我将它们应用于我自己的合同，有意地综合错误并研究反应。 此类研究不能成为确定“优劣”的基础；因此，对大量合同样本进行盲目研究是有意义的，考虑到此类软件的反复无常，这非常困难。 合同中的小错误很可能会禁用大量的分析器逻辑，而简单的启发式符号可能会通过...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>智能合约自动审核指南。 第3部分：秘银</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442114/"><h2 id="warning">  <strong>警告</strong> </h2><br><p> 本文未对自动分析仪的有效性进行评级。 我将它们应用于我自己的合同，有意地综合错误并研究反应。 此类研究不能成为确定“优劣”的基础；因此，对大量合同样本进行盲目研究是有意义的，考虑到此类软件的反复无常，这非常困难。 合同中的小错误很可能会禁用大量的分析器逻辑，而简单的启发式符号可能会通过发现竞争对手根本无法添加的普遍错误而为分析器增加大量点。 合同编制和编制中的错误也可能起作用。 所涉及的所有软件都还很年轻，并且正在不断开发中，因此不要将批评意见视为不可弥补的问题。 </p><br><p>本文的目的是使读者了解不同分析器中的代码分析方法如何工作以及正确使用它们的能力，而不是“做出选择”。 合理的选择是一次使用多个工具，重点放在最适合所分析合同的工具上。 </p><a name="habracut"></a><br><h2 id="nastroyka-i-podgotovka-k-zapusku">  <strong>设置和启动准备</strong> </h2><br><p>  Mythril一次使用几种类型的分析，以下是有关它的几篇好文章： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最重要的</a>是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">this</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">this</a> 。 在继续之前，有必要先阅读它们。 </p><br><p> 首先，让我们构建自己的Mythril Docker镜像（我们想要更改其中的内容是否重要？）： </p><br><pre><code class="plaintext hljs">git clone https://github.com/ConsenSys/mythril-classic.git cd mythril-classic docker build -t myth .</code> </pre> <br><p> 现在，尝试在我们的<code>contracts/flattened.sol</code> （我使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引言</a>中讨论的同一合同）上运行它，其中有两个主要合同， <code>Ownable</code>是Zeppelin拥有的和<code>Booking</code> 。 我们仍然对编译器版本有问题，我以与上一篇文章相同的方式修复了它，在Dockerfile中添加了将替换编译器版本的行： </p><br><pre> <code class="plaintext hljs">COPY --from=ethereum/solc:0.4.20 /usr/bin/solc /usr/bin</code> </pre> <br><p> 重建图像后，您可以尝试运行合同分析。 立即让我们使用<code>-v4</code>和<code>--verbose-report</code>标志查看所有警告。 出发： </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp \ -w /tmp myth:latest \ -v4 \ --verbose-report \ -x contracts/flattened.sol</code> </pre> <br><p> 在这里，我们使用没有依赖性的扁平合约。 要分析单独的<code>Booking.sol</code>合同并让Mythril提取所有依赖项，可以使用以下方法： </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp \ -w /tmp myth:latest \ --solc-args="--allow-paths /tmp/node_modules/zeppelin-solidity/ zeppelin-solidity=/tmp/node_modules/zeppelin-solidity" \ -v4 \ --verbose-report \ -x contracts/Booking.sol</code> </pre> <br><p> 我更喜欢使用展平选项，因为 我们将在代码中进行很多修改。 但是Mythril也有一个非常方便的模式<code>--truffle</code> ，该模式仅<code>--truffle</code> <code>truffle</code>所有内容，并检查整个项目是否存在漏洞。 另一个重要功能是能够通过冒号指定要分析的合同名称的功能，否则Mythril将分析它遇到的所有合同。 我们认为<code>Ownable</code>的Ownable是一个安全的合同，我们只打算分析<code>Booking</code> ，所以运行的最后一行是： </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp -w /tmp myth:latest -x contracts/flattened.sol:Booking -v4 --verbose-report</code> </pre> <br><h2 id="zapusk-i-deploy-kontrakta">  <strong>启动和部署合同</strong> </h2><br><p> 我们从上一行开始分析器，查看输出，除其他外，我们得到以下行： </p><br><pre> <code class="plaintext hljs">mythril.laser.ethereum.svm [WARNING]: No contract was created during the execution of contract creation Increase the resources for creation execution (--max-depth or --create-timeout) The analysis was completed successfully. No issues were detected.</code> </pre> <br><p> 事实证明，我们的合同并未在仿真器中创建和“修复”。 因此，我建议对所有类型的分析使用<code>-v4</code>标志，以查看所有消息，并且不要遗漏任何重要的消息。 让我们找出问题所在。 解决这一实际问题对于理解如何正确使用秘银很重要。 </p><br><p> 因此，我们正在阅读有关Mythril的文章： <code>It uses concolic analysis, taint analysis and control flow checking to detect a variety of security vulnerabilities</code> 。 如果您不太熟悉这些术语，我建议您在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处提供</a>有关condical测试的Wiki，但这<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">是</a>有关x86污染检查<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>很好的介绍。 简而言之：Mythril模拟合同的执行情况，修复可以执行的分支，并尝试实现合同的“中断”状态，对各种参数组合进行排序，并设法避开所有可能的路径。 这是上面文章的示例操作图： </p><br><pre> <code class="plaintext hljs">1.      .   symbolic-,        . 2.      ,     ,   trace .    ,      ,    . 3.     . 4.       trace-. 5.  symbolic execution   trace,   symbolic ,    ,     ,     . 6.     ,          .    , . 7.   :   ,   ,   input-,     ,      .   input-   ,   .6    . 8.   .4</code> </pre> <br><p> 如果您对其进行了极大地简化，那么Mythril在代码中遇到了一个分支，便可以了解可以进入哪个变量集和另一个分支。 在每个分支中，Mythril都知道它是否导致<code>assert</code> ， <code>transfer</code> ，selfdestruct和其他与安全相关的操作码。 因此，Mythril分析哪些参数和事务集可能导致安全漏洞。  Mythril切断从未获得控制权的分支并分析控制流的方法是其主要技巧。 有关Mythril肠和分支行走的更多详细信息<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>编写。 </p><br><p> 由于智能合约执行的确定性，无论平台，体系结构或环境如何，相同的指令序列始终严格导致一组状态变化。 此外，智能合约中的功能相当短，并且资源非常有限，因此像Mythril这样的分析器将符号执行和本机执行相结合，可以非常有效地用于智能合约。 </p><br><p> 在此过程中，Mythril使用“状态”的概念-这是合同的代码，其环境，指向当前命令的指针，合同的存储以及堆栈的状态。 这里是文档： </p><br><pre> <code class="plaintext hljs">The machine state μ is defined as the tuple (g, pc, m, i, s) which are the gas available, the program counter pc ∈ P256, the memory contents, the active number of words in memory (counting continuously from position 0), and the stack contents. The memory contents μm are a series of zeroes of size 256.</code> </pre> <br><p> 状态之间的过渡图是研究的主要对象。 如果成功启动分析，则有关该图的信息将显示在分析日志中。 另外，Mythril可以使用<code>--graph</code>选项以<code>--graph</code>形式构建此图形。 </p><br><p> 现在或多或少地了解了Mythril会做什么，我们将继续了解为什么未解析合同以及合同的来源<code>[WARNING]: No contract was created during the execution of contract creation</code> 。 首先，我扭曲了<code>--create-timeout</code>和<code>--max-depth</code> （按照建议），但没有得到结果，我以为是构造函数的责任–它中的某些功能不起作用。 这是他的代码： </p><br><pre> <code class="plaintext hljs">function Booking( string _description, string _fileUrl, bytes32 _fileHash, uint256 _price, uint256 _cancellationFee, uint256 _rentDateStart, uint256 _rentDateEnd, uint256 _noCancelPeriod, uint256 _acceptObjectPeriod ) public payable { require(_price &gt; 0); require(_price &gt; _cancellationFee); require(_rentDateStart &gt; getCurrentTime()); require(_rentDateEnd &gt; _rentDateStart); require(_rentDateStart+_acceptObjectPeriod &lt; _rentDateEnd); require(_rentDateStart &gt; _noCancelPeriod); m_description = _description; m_fileUrl = _fileUrl; m_fileHash = _fileHash; m_price = _price; m_cancellationFee = _cancellationFee; m_rentDateStart = _rentDateStart; m_rentDateEnd = _rentDateEnd; m_noCancelPeriod = _noCancelPeriod; m_acceptObjectPeriod = _acceptObjectPeriod; }</code> </pre> <br><p> 回想一下秘银的动作算法。 要运行跟踪，您需要调用合同构造函数，因为所有后续执行将取决于调用构造函数的参数。 例如，如果您使用<code>_price == 0</code>调用构造函数，则构造函数将在<code>require(_price &gt; 0)</code>上引发异常。 即使Mythril迭代许多<code>_price</code>值，例如<code>_price &lt;= _cancellationFee</code> ，构造函数仍会中断。 在此合同中，有十二个与严格限制相关联的参数，而Mythril当然无法猜测参数的有效组合。 他尝试转到执行的下一个分支，对构造函数的参数进行排序，但是他几乎没有机会猜测-参数太多。 因此，合同的计算无法解决-所有方式都基于某种<code>require(...)</code> ，我们得到了上述问题。 </p><br><p> 现在我们有两种方法：第一种是通过将它们注释掉来禁用构造函数中的所有<code>require</code> 。 然后Mythril将能够使用任何参数集调用构造函数，并且一切正常。 但这意味着，通过检查带有此类参数的合同，Mythril将发现错误，而错误的值可能会传递给构造函数。 简而言之，如果Mythril发现如果合同创建者将<code>_cancellationFee</code>指定为<code>_cancellationFee</code>的十亿倍的价格时出现的<code>_mprice</code> ，那么在这种bug中就没有用-这样的合同将永远不会被阻塞，并且将花费大量资源来查找错误。 我们暗示该合同仍然停留在或多或少一致的参数上，因此为了进行进一步分析，有必要指定更切合实际的构造函数参数，以便Mythril不会查找如果正确关闭该合同永远不会发生的错误。 </p><br><p> 我花了很多时间试图确切了解部署的中断位置，包括并禁用构造函数的各个部分。 除了麻烦之外，构造函数还使用<code>getCurrentTime()</code>返回当前时间，目前尚不清楚此调用如何处理Mythril。 在这里我不会描述这些冒险，因为 这些细微之处很可能是经常使用的，因此审计人员知道了。 因此，我选择了第二种方法：限制输入数据，并简单地从构造函数中删除所有参数，甚至是<code>getCurrentTime()</code> ，也直接在构造函数中直接硬编码必要的参数（理想情况下，这些参数应从客户那里获得）： </p><br><pre> <code class="plaintext hljs"> function Booking( ) public payable { m_description = "My very long booking text about hotel and beautiful sea view!"; m_fileUrl = "https://ether-airbnb.bam/some-url/"; m_fileHash = 0x1628f3170cc16d40aad2e8fa1ab084f542fcb12e75ce1add62891dd75ba1ffd7; m_price = 1000000000000000000; // 1 ETH m_cancellationFee = 100000000000000000; // 0.1 ETH m_rentDateStart = 1550664800 + 3600 * 24; // current time + 1 day m_rentDateEnd = 1550664800 + 3600 * 24 * 4; // current time + 4 days m_acceptObjectPeriod = 3600 * 8; // 8 hours m_noCancelPeriod = 3600 * 24; // 1 day require(m_price &gt; 0); require(m_price &gt; m_cancellationFee); require(m_rentDateStart &gt; 1550664800); require(m_rentDateEnd &gt; m_rentDateStart); require((m_rentDateStart + m_acceptObjectPeriod) &lt; m_rentDateEnd); require(m_rentDateStart &gt; m_noCancelPeriod); }</code> </pre> <br><p> 另外，要开始一切，还必须设置<code>max-depth</code>参数。 它在AWS t2.medium实例上使用<code>--max-depth=34</code>此构造函数为我工作。 同时，在功能更强大的笔记本电脑上，一切开始时都没有<code>max-depth</code> 。 通过使用此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参数</a>判断，有必要构造用于分析的分支，并且其默认值为infinity（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码</a> ）。 因此，请旋转旋转此参数，但要确保分析了所需的合同。 您可以通过以下消息了解此信息： </p><br><pre> <code class="plaintext hljs">mythril.laser.ethereum.svm [INFO]: 248 nodes, 247 edges, 2510 total states mythril.laser.ethereum.svm [INFO]: Achieved 59.86% coverage for code: .............</code> </pre> <br><p> 第一行仅描述了将要分析的图形，请自己阅读其余几行。 需要大量的计算资源来分析可以执行的各种分支，因此在分析大型合同时，即使在快速的计算机上也必须等待。 </p><br><h2 id="poisk-oshibok">  <strong>搜索错误</strong> </h2><br><p> 现在，我们将查找错误并添加我们自己的错误。 秘银寻找分支，在分支中进行广播，自毁，声明和其他从安全角度来看很重要的动作。 如果以上说明之一出现在合同代码中某处，Mythril将检查可能进入此分支的方式，此外，还会显示通往该分支的交易顺序！ </p><br><p> 首先，让我们看看Mythril为长期受苦的<code>Booking</code>合同发行了什么。 第一个警告： </p><br><pre> <code class="plaintext hljs">==== Dependence on predictable environment variable ==== SWC ID: 116 Severity: Low Contract: Booking Function name: fallback PC address: 566 Estimated Gas Usage: 17908 - 61696 Sending of Ether depends on a predictable variable. The contract sends Ether depending on the values of the following variables: - block.timestamp Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and/or can be manipulated by a malicious miner. Don't use them for random number generation or to make critical decisions. -------------------- In file: contracts/flattened.sol:142 msg.sender.transfer(msg.value-m_price)</code> </pre> <br><p> 它的出现是因为 </p><br><pre> <code class="plaintext hljs">require(m_rentDateStart &gt; getCurrentTime());</code> </pre> <br><p> 在后备功能中。 </p><br><p> 请注意，Mythril意识到<code>getCurrentTime()</code>隐藏在<code>getCurrentTime()</code> 。 尽管合同的含义不是一个错误，但Mythril将<code>block.timestamp</code>与广播相关联的事实非常出色！ 在这种情况下，程序员必须理解，决策是基于矿工可以控制的值做出的。 而且，如果将来在合同的该地点进行拍卖或其他服务拍卖，则必须考虑到前期攻击的可能性。 </p><br><p> 让我们看看如果我们在这样的嵌套调用中隐藏变量， <code>block.timestamp</code>是否看到对<code>block.timestamp</code>的依赖： </p><br><pre> <code class="plaintext hljs">function getCurrentTime() public view returns (uint256) { - return now; + return getCurrentTimeInner(); } + function getCurrentTimeInner() internal returns (uint256) { + return now; + }</code> </pre> <br><p> 是的！  Mythril继续看到block.timestamp和广播传输之间的联系，这对于审核员而言非常重要。 攻击者控制的变量与合同状态几次更改后做出的决定之间的联系可以被逻辑掩盖，而Mythril允许您跟踪它。 尽管不值得依赖为所有可能的变量之间的所有可能的连接进行<code>getCurrentTime()</code>的事实：如果继续模拟<code>getCurrentTime()</code>函数并进行三层嵌套，则警告会消失。 对Mythril的每个函数调用都需要创建新的状态分支，因此分析非常深层的嵌套将需要大量资源。 </p><br><p> 当然，我很可能错误地使用了分析参数，或者在分析仪深度的某处发生了截断。 就像我说的那样，在撰写本文时，该产品正在积极开发中，我看到在仓库中提到了<code>max-depth</code>的提交，因此不要认真对待当前的问题，我们已经找到了足够的证据证明Mythril可以非常有效地寻找变量。 </p><br><p> 首先，在合同中添加一个功能，该功能可将广播提供给任何人，但仅在客户端将广播发送给合同之后。 我们允许任何人提取1/5的以太<code>State.PAID</code> ，但<code>State.PAID</code>是合同处于<code>State.PAID</code>状态（即仅在客户用以太<code>State.PAID</code>支付了租用的号码之后）。 这是函数： </p><br><pre> <code class="plaintext hljs">function collectTaxes() external onlyState(State.PAID) { msg.sender.transfer(address(this).balance / 5); }</code> </pre> <br><p> 秘银发现了问题： </p><br><pre> <code class="plaintext hljs">==== Unprotected Ether Withdrawal ==== SWC ID: 105 Severity: High Contract: Booking Function name: collectTaxes() PC address: 2492 Estimated Gas Usage: 2135 - 2746 Anyone can withdraw ETH from the contract account. Arbitrary senders other than the contract creator can withdraw ETH from the contract account without previously having sent a equivalent amount of ETH to it. This is likely to be a vulnerability. -------------------- In file: contracts/flattened.sol:149 msg.sender.transfer(address(this).balance / 5) -------------------- -------------------- Transaction Sequence: { "2": { "calldata": "0x", "call_value": "0xde0b6b3a7640000", "caller": "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef" }, "3": { "calldata": "0x01b613a5", "call_value": "0x0", "caller": "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef" } }</code> </pre> <br><p> 太好了 秘银甚至带来了两笔交易，导致您可以从合约中提取以太币。 现在将<code>State.PAID</code>需求更改为<code>State.RENT</code> ，如下所示： </p><br><pre> <code class="plaintext hljs">- function collectTaxes() external onlyState(State.PAID){ + function collectTaxes() external onlyState(State.RENT) {</code> </pre> <br><p> 现在仅在合同处于<code>State.RENT</code>状态时才可以调用<code>collectTaxes()</code> ，并且此时此刻没有任何余额，因为 合同已经将整个广播发送给了所有者。 重要的是，Mythril这次<strong>不会</strong>输出错误<code>==== Unprotected Ether Withdrawal ====</code>币取回<code>==== Unprotected Ether Withdrawal ====</code> ！ 在<code>onlyState(State.RENT)</code>的条件下，分析器没有到达代码分支，该代码分支从具有非零余额的合同发送以太<code>onlyState(State.RENT)</code> 。  Mythril为参数使用了不同的选项，但是只有将所有广播发送给出租人后，您才能进入<code>State.RENT</code> 。 因此，不可能以非零的余额到达代码的这一分支，并且Mythril绝对不会打扰审计人员！ </p><br><p> 同样，Mythril会发现<code>selfdestruct</code>并<code>assert</code> ，向审计师展示了哪些行为可能导致合同毁灭或破坏重要职能。 我将不给出这些示例，仅尝试使函数类似于上面的函数，仅调用<code>selfdestruct</code>并扭曲其逻辑。 </p><br><p> 另外，请不要忘记Mythril的一部分是符号执行，而这种方法本身可以在不模拟执行的情况下确定许多漏洞。 例如，如果攻击者以某种方式控制操作数之一，则对“ +”，“-”和其他算术运算符的任何使用都可以视为“整数溢出”的漏洞。 但是我再说一遍，Mythril最强大的功能是将符号和本机执行以及确定导致逻辑分支的参数值组合在一起。 </p><br><h2 id="zaklyuchenie">  <strong>结论</strong> </h2><br><p> 当然，要显示Mythril能够检测到的所有潜在问题，将不仅需要撰写一篇文章，还需要多篇文章。 对于其他所有事物，他都知道如何在真实的区块链中完成所有工作，通过签名找到必要的合同和漏洞，构建漂亮的调用图，格式化报告。  Mythril还允许您编写自己的测试脚本，为合同提供基于python的界面，并允许您测试单个功能，修复参数值，甚至实施自己的策略以任意程度的灵活性处理反汇编代码。 </p><br><p>  Mythril仍然是一个相当年轻的软件，它不是IDA Pro，除少数文章外，很少有文档。 许多参数的值只能从cli.py开头的Mythril代码中读取。 我希望在文档中对每个参数的操作进行完整而深入的描述。 </p><br><p> 另外，当合同或多或少很大时，一堆错误的输出会占用很多空间，但是我希望能够接收有关发现的错误的压缩信息，因为 使用Mythril时，您必须绝对查看分析路径，查看已尽力而为地测试了哪些合同，并能够强行禁用审计师认为错误肯定的特定错误。 </p><br><p> 但是总的来说，Mythril是一种用于分析智能合约的出色且功能非常强大的工具，目前应由任何审核员掌握。 它使您至少可以关注代码的关键部分，并检测变量之间的隐藏关系。 </p><br><p> 总结一下，使用Mythril的建议是： </p><br><ol><li> 尽可能缩小研究合同的起始条件。 如果在分析期间Mythril将大量资源花在分支上，而这些资源在实践中永远不会实现，那么它将失去发现真正重要的bug的能力，因此您应始终尝试缩小潜在分支的范围。 </li><li> 确保合同分析已经开始，不要错过<code>mythril.laser.ethereum.svm [WARNING]: No contract was created during the execution of contract creation Increase the resources for creation execution (--max-depth or --create-timeout)</code>类的<code>mythril.laser.ethereum.svm [WARNING]: No contract was created during the execution of contract creation Increase the resources for creation execution (--max-depth or --create-timeout)</code> ，否则您可能会误认为没有错误。 </li><li> 您可以在合同代码中任意禁用分支，从而使Mythril在选择分支和节省资源方面的变化更少。 尝试对<code>max-depth</code>进行无限制的操作，以免“砍掉”分析，但请注意不要掩盖错误。 </li><li> 注意每个警告，即使是简短的注释有时也值得至少在合同代码中添加注释，这对于其他开发人员来说更容易。 </li></ol><br><p> 在下一篇文章中，我们将处理Manticore分析器，但这是准备或计划编写的文章的目录： </p><br><p> 第1部分。 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">简介。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编译，展平，Solidity版本</a> <br> 第2部分。 <br>  3. Mythril ( ) <br>  4. Manticore (  ) <br>  5. Echidna (  ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN442114/">https://habr.com/ru/post/zh-CN442114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN442102/index.html">关于电池的问题</a></li>
<li><a href="../zh-CN442104/index.html">Kibana用户指南。 可视化。 第5部分</a></li>
<li><a href="../zh-CN442108/index.html">开发人员创建AI应用程序指南</a></li>
<li><a href="../zh-CN442110/index.html">反模式Vim</a></li>
<li><a href="../zh-CN442112/index.html">新的编程语言悄悄地杀死了我们与现实的联系</a></li>
<li><a href="../zh-CN442116/index.html">使用React.memo（）改善React组件的功能</a></li>
<li><a href="../zh-CN442118/index.html">Coinhive矿池停止工作</a></li>
<li><a href="../zh-CN442120/index.html">使用Azure机器学习服务训练TensorFlow模型</a></li>
<li><a href="../zh-CN442122/index.html">一个简单的莫斯科Levelord：采访Nukem公爵的创造者</a></li>
<li><a href="../zh-CN442124/index.html">Facebook将为用户提供清理故事的机会</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>