<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêª üòæ üñ•Ô∏è Wie kann die Erstellung virtueller Maschinen automatisiert werden? Wir erz√§hlen im Detail üì∏ üë®üèª‚Äç‚öñÔ∏è ‚óÄÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Erstellen einer neuen virtuellen Maschine ist eine zeitaufw√§ndige Routine. Und je mehr Infrastruktur und Organisation vorhanden sind, desto mehr V...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie kann die Erstellung virtueller Maschinen automatisiert werden? Wir erz√§hlen im Detail</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/icl_services/blog/425129/"> Das Erstellen einer neuen virtuellen Maschine ist eine zeitaufw√§ndige Routine.  Und je mehr Infrastruktur und Organisation vorhanden sind, desto mehr Verfahren sind mit diesem Prozess verbunden.  Wir haben diesen Prozess mit PowerShell automatisiert. <br><br>  Willkommen bei kat, wenn Sie interessiert sind. <br><br><img src="https://habrastorage.org/webt/fv/fr/cc/fvfrccl_crsi5nfvcnstarorits.jpeg"><br><br><a name="habracut"></a><br>  Programmierer arbeiten nicht gerne doppelt, auch Systemadministratoren. <br><br>  Nachfolgend finden Sie ein Beispiel f√ºr die Automatisierung eines unserer Kunden. <br><br>  Wir wollten sicherstellen, dass jeder Ingenieur oder Projektmanager mit minimalem Aufwand und f√ºr einen minimalen Zeitraum eine neue virtuelle Maschine erstellen kann.  Unser Kunde hat ein ITSM-System, in diesem Beispiel ist es ServiceNow, wir haben das entsprechende Webformular im Servicekatalog erstellt.  Um eine neue Maschine zu ‚Äûbestellen‚Äú, muss der Manager die Felder ausf√ºllen und die ‚ÄûBestellung‚Äú best√§tigen, nachdem die Prozesskette gestartet wurde, und am Ausgang wird die Maschine betriebsbereit gemacht. <br><br>  Schauen wir uns also an, was ein Manager definieren muss, um eine neue virtuelle Maschine zu erstellen: <br><br><img src="https://habrastorage.org/webt/3l/8d/yo/3l8dyowobrfvbgpznotayqjywvu.png"><br><br>  <b>VM-Beschreibung: Beschreibung der virtuellen Maschine</b> <b><br></b>  Hier sind einige Klarstellungen erforderlich.  In unserer L√∂sung wird PowerShell 5.1 aktiv verwendet. W√§hrend wir nur Windows verwenden, werden wir in Zukunft versuchen, Unterst√ºtzung f√ºr Unix-Computer hinzuzuf√ºgen und auf PowerShell Core zu wechseln. <br><br>  <b>Betriebssystem</b> , Betriebssystem.  Es gibt keine besonderen Hindernisse f√ºr die Verwendung von Windows 2008 (R2), aber wir verwenden 2012R2 oder 2016. <br><br>  <b>VM-Gr√∂√üe</b> , <b>Gr√∂√üe der</b> virtuellen Maschine.  F√ºr jeden kann dies auf seine eigene Weise bestimmt werden, in diesem Beispiel Small 1CPU-4Gb Ram, Medium 2CPU-8Gb, Large 4-16. <br><br>  <b>VM-Speicher</b> , Datentr√§ger 0 (C: \) hat eine feste Gr√∂√üe, die Sie nicht √§ndern k√∂nnen. Es ist nur die Auswahl f√ºr den schnellen / langsamen Speicher verf√ºgbar.  "Schnell" kann Speicherebene mit SSD sein, und "Langsam" kann Speicher auf "normalen" Festplatten (nat√ºrlich SAN) sein.  Disk1 (ab Disk2) verf√ºgt au√üerdem √ºber einen Selektor zur Auswahl von Speicher sowie Felder zur Eingabe der gew√ºnschten Gr√∂√üe in Gigabyte, Buchstaben f√ºr die Partition und Clustergr√∂√üe (wichtig f√ºr SQL Server). <br><br>  <b>Vertrauen</b> , wir stellen fest, dass der Computer einer Dom√§ne beitreten muss oder nicht, mit Zugriff √ºber das √∂ffentliche Netzwerk oder nicht. <br><br>  <b>Typ</b> , Maschinentyp.  Fast jede Maschine kann in allen anderen F√§llen als Front-End- oder Back-End-Anwendung oder als andere definiert werden.  Anhand des ausgew√§hlten Typs k√∂nnen wir das f√ºr die Maschine am besten geeignete Subnetz ermitteln. <br><br>  <b>Umgebung</b> , in der Infrastruktur des Kunden gibt es zwei Rechenzentren: Prim√§r (Produktion) und Sekund√§r (Entwicklung / Test), DC sind √ºber einen schnellen Kommunikationskanal verbunden und bieten Fehlertoleranz.  Nach Vereinbarung haben alle virtuellen Maschinen im prim√§ren DC eine IP-Adresse ab 10.230 und im sekund√§ren DC ab 10.231. <br><br>  <b>(SLA) Service Level Agreement</b> . Dieser Parameter wirkt sich auf die Servicequalit√§t dieser Maschine aus. <br><br>  <b>Anwendungen</b>  Wir haben die M√∂glichkeit hinzugef√ºgt, SQL Server zu installieren und zu konfigurieren.  Sie m√ºssen die Edition, den Instanznamen und die Sortierung ausw√§hlen.  Es ist auch m√∂glich, sowohl die Webserverrolle als auch vieles mehr zu konfigurieren. <br><br>  Jetzt m√ºssen wir bestimmen, wie die ausgew√§hlten Werte gespeichert werden sollen.  Wir haben entschieden, dass das bequemste Format eine JSON-Datei ist.  Wie bereits erw√§hnt, verwendet die Kundenumgebung ITSM ServiceNow.  Nachdem der Manager alle erforderlichen Werte ausgew√§hlt hat, klickt er auf die Schaltfl√§che "Bestellen". Danach √ºbergibt ServiceNow alle Parameter an unser PowerShell-Skript (an das Back-End-ServiceNow), das die JSON-Datei erstellt.  Es sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre><code class="plaintext hljs">.\CreateConfiguration.ps1 -SecurityZone trusted -VMDescription "VM for CRM System" -Requestor "evgeniy.vpro" -OSVersion 2k16 -OSEdition Standard -BuildNewVM -VMEnvironment Prod -VMServiceLevel GOLD -VMSize Medium -Disk0Tier Fast -Disk1Size 50 -Disk1Tier Eco -Disk1Letter D -MSSQLServer -MSSQLInstanceName "Instance1" -SQLCollation Latin1_General_CI_AS -SQLEdition Standard -Disk2Size 35 -Disk3Size 65</code> </pre> <br><br>  Im Hauptteil des Skripts CreateConfiguration .ps1: <br><br><pre> <code class="plaintext hljs"># PowerShell- $config = [ordered]@{} #    . $config.SecurityZone=$SecurityZone</code> </pre><br><br>  Exportieren Sie am Ende unser Objekt in eine JSON-Datei: <br><br><pre> <code class="plaintext hljs">$ServerConfig = New-Object ‚ÄìTypeName PSObject $config ConvertTo-Json -InputObject $ServerConfig -Depth 100 | Out-File "C:\Configs\TargetNodes\Build\$($Hostname.ToLower()).json" -Force</code> </pre><br><br>  Beispielkonfiguration: <br><br><pre> <code class="plaintext hljs">{ "Hostname": "dsctest552", "SecurityZone": "trusted", "Domain": "testdomain", "Requestor": "evgeniy.vpro", "VM": { "Size": "Medium", "Environment": "Prod", "SLA": "GOLD", "DbEngine": "MSSQL", "RAM": 8, "Storage": [ { "Id": 0, "Tier": "Fast", "Size": "100", "Allocation": 4, "Letter": "C" }, { "Id": 1, "Tier": "Eco", "Size": 50, "Label": "Data", "Allocation": 64, "Letter": "D" }, { "Id": 2, "Tier": "Fast", "Size": 35, "Label": "Data", "Allocation": 64, "Letter": "E" }, { "Id": 3, "Tier": "Fast", "Size": 65, "Label": "Data", "Allocation": 64, "Letter": "F" } ] }, "Network": { "MAC": "", "IP": "10.230.168.50", "Gateway": "10.230.168.1", "VLAN": ‚ÄúVLAN168‚Äù }, "OS": { "Version": "2k16", "Edition": "Standard", "Administrators": [ "LocaAdmin", "testdomain\\ Security-LocalAdmins" ] }, "OU": "OU=Servers,OU=Staging,DC=testdomain", "Applications": [ { "Application": "Microsoft SQL Server 2016", "InstanceName": "vd", "Collation": "Latin1_General_CI_AS", "Edition": "Standard", "Features": "SQLENGINE", "Folders": { "DataRoot": "E:\\MSSQL", "UserDB": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Data", "UserLog": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Log", "TempDB": "D:\\MSSQL\\MSSQL11.vd\\MSSQL\\TempDB", "TempDBLog": "D:\\MSSQL\\MSSQL11.vd\\MSSQL\\TempDB", "Backup": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Backup" }, "MaxMemory": 2147483647 } ], "Description": "VM for CRM", "Certificate": { "File": null, "Thumbprint": null }, "Version": 0 }</code> </pre><br><br>  M√∂glicherweise haben Sie bemerkt, dass das Webformular keinen Namen und keine IP-Adresse der virtuellen Maschine hatte.  Wir erhalten diese Werte automatisch wie folgt: <br><br>  <b>Der Name der Maschine</b> , ITSM ServiceNow, hat einen speziellen Abschnitt: CMDB (Configuration Management Data Base). In dieser Datenbank werden alle Datens√§tze √ºber vorhandene virtuelle Maschinen, deren Status, Support-Team und mehr gespeichert.  Wir haben ungef√§hr 200 Sicherungsdatens√§tze mit dem Status "Zugewiesen" erstellt.  Um einen Namen f√ºr die virtuelle Maschine zu erhalten, senden wir eine REST-Anfrage an CMDB, rufen den ersten "freien" Datensatz ab und √§ndern seinen Status von "Zugewiesen" in "Ausstehende Installation". <br><br>  <b>IP-Adresse und VLAN</b> haben wir IPAM in unserem Netzwerk bereitgestellt. Dies ist eine in Windows Server 2016 integrierte Funktion, mit der Sie IP-Adressen in Ihrem Netzwerk verwalten k√∂nnen.  Es ist √ºberhaupt nicht erforderlich, alle Funktionen von IPAM (DHCP, DNS, AD) zu verwenden, sondern nur als Datenbank mit IP-Adressen mit einer m√∂glichen Erweiterung der Funktionalit√§t.  Das Skript, das die JSON-Datei erstellt, fordert IPAM nach der ersten freien IP-Adresse im Subnetz an.  Das VLAN-Subnetz (x / 24-Subnetz) wird basierend auf den ausgew√§hlten Werten f√ºr SLA, Umgebung, Vertrauen und Typ bestimmt. <br>  Die Konfigurationsdatei ist fertig, alle Felder sind vorhanden, Sie k√∂nnen eine Maschine erstellen.  Die Frage lautet: "Wie werden Anmeldeinformationen f√ºr alle unsere Skripte gespeichert?".  Wir verwenden das <a href="">CredentialManager-</a> Paket.  Dieses Paket funktioniert mit der integrierten Windows Credential Manager-API zum Speichern von Kennw√∂rtern.  Beispiel f√ºr die Erstellung eines Passworts: <br><br><pre> <code class="plaintext hljs">New-StoredCredential -Target "ESXi" -UserName "testdomain.eu\vmwareadm" -Password "veryultraP@ssw00rd." -Type Generic -Persist LocalMachine</code> </pre><br><br>  Das Passwort kann auf diesem Computer und in diesem Konto gelesen werden. <br><br><pre> <code class="plaintext hljs">$ESXiAdmin = Get-StoredCredential -Type Generic -Target ESXi</code> </pre> <br><br>  Wir haben einen Server, auf dem alle Konfigurationen mit GIT gespeichert sind. Jetzt k√∂nnen wir alle Konfigurations√§nderungen zuverl√§ssig verfolgen: wer, was, wo und wann. <br><br>  Die geplante Aufgabe wird auf diesem Server konfiguriert: √úberpr√ºfen Sie den Ordner mit den Konfigurationen und schreiben Sie alle √Ñnderungen in das Windows-Ereignisprotokoll. <br><br>  Nach 15 Minuten schreibt die geplante Aufgabe in Windows EventLog, dass eine neue Konfigurationsdatei erkannt wurde. <br><br>  Es ist Zeit, diese Konfiguration zu √ºberpr√ºfen.  Zun√§chst m√ºssen wir sicherstellen, dass die Datei die richtige Formatierung hat: <br><br><pre> <code class="plaintext hljs">$Configuration=(Get-Content -Raw $File | Out-String | ConvertFrom-Json)</code> </pre> <br><br>  Wenn alles in Ordnung ist, ist es Zeit, mit der Erstellung des Computers zu beginnen und das Skript BuildVM.ps1 auszuf√ºhren. <br><br>  In BuildVM.ps1 √ºberpr√ºfen wir, ob die Konfigurationsdatei eine Beschreibung aller Merkmale der virtuellen Maschine enth√§lt: Gr√∂√üe, Umgebung, Sla, Typ, Speicher, RAM, Netzwerk. <br><br>  Stellen Sie sicher, dass in der Infrastruktur ein Computer mit demselben Namen vorhanden ist (CheckVM.ps1). <br>  Wir stellen √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VMWare PowerShell-CLI eine Verbindung</a> zu unserer vSphere her: <br><br><pre> <code class="plaintext hljs">$VmWareAdmin = Get-StoredCredential -Type Generic -Target ESXi Connect-VIServer -Server "vSphereSrv" -Credential $VmWareAdmin | Out-Null</code> </pre><br><br>  √úberpr√ºfen Sie, ob sich in der Infrastruktur ein Computer mit demselben Namen befindet <br><br><pre> <code class="plaintext hljs">$VM=Get-VM $server -ErrorAction SilentlyContinue</code> </pre> <br><br>  Und ausschalten: <br><br><pre> <code class="plaintext hljs">Disconnect-VIServer * -Force -Confirm:$false</code> </pre> <br><br>  Stellen Sie sicher, dass der Computer auch unter WinRM nicht verf√ºgbar ist <br><br><pre> <code class="plaintext hljs">$ping=Test-NetConnection -ComputerName $Configuration.Hostname -CommonTCPPort WINRM -InformationLevel Quiet -ErrorAction SilentlyContinue</code> </pre> <br><br>  Wenn $ VM und $ ping leer sind, k√∂nnen Sie einen neuen Computer erstellen.  (Wir behandeln Situationen, in denen ein Computer bereits manuell in ESXi erstellt wurde oder sich dieser Computer in einem anderen Rechenzentrum befindet.) <br><br><blockquote>  Ein paar Worte zum Auto.  Dies ist ein vorbereitetes Image der virtuellen Maschine, das von sysprep finalisiert und in unserer vSphere in eine Vorlage konvertiert wurde.  Der lokale Administrator mit dem uns bekannten Kennwort wird im Image gespeichert. Dieses Konto st√ºrzt nach sysprep nicht ab, sodass wir √ºber diese Vorlage auf jeden Computer zugreifen k√∂nnen. Sp√§ter k√∂nnen wir dieses Kennwort aus Sicherheitsgr√ºnden ersetzen. </blockquote><br><br><h3>  Erstellen einer virtuellen Maschine <br></h3><br>  Suchen Sie den entsprechenden SLR-Cluster: <br><br><pre> <code class="plaintext hljs">$Cluster=Get-Cluster -Name $Configuration.VM.SLA</code> </pre> <br><br>  √úberpr√ºfen Sie, ob im Datenspeicher gen√ºgend Speicherplatz vorhanden ist: <br><br><pre> <code class="plaintext hljs">$DatastoreCluster = Get-DatastoreCluster |Where-Object {$_.Name -like $Datastore1Name} $Datastore1 = Get-Datastore -Location $DatastoreCluster |sort -Property "FreeSpaceGB" |select -Last 1 IF ($Datastore1.FreeSpaceGB -le "200"){ Write-Host -foreground red "STOP: Not enough datastore capacity for DISK" $vdisk.Id Break }</code> </pre><br><br>  Und genug Speicher: <br><br><pre> <code class="plaintext hljs">$VMHost = Get-VMHost -Location $Cluster |sort -Property "MemoryUsageGB" |select -First 1 IF ($VMHost.MemoryUsageGB -le "20"){ Write-Host -foreground red "STOP: No enough ESXi host capacity" Break }</code> </pre><br><br>  Wir nehmen unsere Vorlage <br><br><pre> <code class="plaintext hljs">$VMTemplate = Get-Template -Name 'Win2016_Std_x64_Template'</code> </pre> <br><br>  Und erstellen Sie eine neue virtuelle Maschine <br><br><pre> <code class="plaintext hljs">New-VM -Name $Configuration.Hostname.ToUpper() -VMHost $VMHost -ResourcePool $ResourcePool -Datastore $Datastore -Template $VMTemplate -Location "AutoDeployed VMs"</code> </pre> <br><br>  Es ist wichtig, die Netzwerkschnittstelle mit einem Subnetz mit aktiviertem DHCP zu verbinden. <br><br>  Wir starten die virtuelle Maschine <br><br><pre> <code class="plaintext hljs">Start-VM $VM</code> </pre> <br><br>  Speichern Sie die Beschreibung des Computers, damit Sie den Computer sp√§ter auf VMWare-Ebene ermitteln k√∂nnen. <br><br><pre> <code class="plaintext hljs">Set-Annotation -Entity $VM -CustomAttribute "Change request" -Value $Configuration.Request -Confirm:$false Set-VM $VM -Notes $Configuration.Description -Confirm:$false</code> </pre><br><br>  Die Maschine wurde gestartet und jetzt k√∂nnen wir die empfangene MAC-Adresse herausfinden: <br><br><pre> <code class="plaintext hljs">$vMAC = (($VM | Get-NetworkAdapter | Select-Object -Property "MacAddress").MacAddress).Replace(':','')</code> </pre> <br><br>  Speichern Sie diesen Wert in unserer JSON-Datei. <br><br><pre> <code class="plaintext hljs">$Configuration.Network.MAC=$VMAC ConvertTo-Json -InputObject $Configuration -Depth 100 | Out-File "C:\Configs\TargetNodes\Build\$Hostname.json" -Force</code> </pre><br><br>  Hier ist die Zeit, um unserem Git zu verpflichten, dass die Maschine erstellt wurde und einen eigenen einzigartigen MAC hat. <br><br>  Das Ger√§t beginnt mit der Initialisierung (nach Sysprep), der Einrichtung des Ger√§ts und der Erstkonfiguration. <br><br>  Warten wir, bis unser WinRM-Computer mit dem Skript EstablishConnection.ps1 verf√ºgbar ist. <br><br>  Zuerst finden wir heraus, welche IP der Computer von DHCP erhalten hat: <br><br><pre> <code class="plaintext hljs"># $MAC = $vMAC while($isOnline -ne $true){ if((Get-DhcpServerv4Lease -ClientId $MAC -ScopeId $StagingDHCPScope -ComputerName $DHCPServer -ErrorAction Ignore).IPAddress.IPAddressToString){ $tempIP=(Get-DhcpServerv4Lease -ClientId $MAC -ScopeId $StagingDHCPScope -ComputerName $DHCPServer).IPAddress.IPAddressToString break } else{ if($isOnline -ne $true){ Write-Host "`r$i`t" -NoNewline $i++ } } }</code> </pre><br><br>  Und jetzt warten wir, bis die Maschine auf WinRM verf√ºgbar ist: <br><br><pre> <code class="plaintext hljs">$LocalAdmin = Get-StoredCredential -Type Generic -Target LocalAdmin $i=0 $isOnline=$false while($isOnline -ne $true){ if(Invoke-Command -ComputerName $tempIP -ScriptBlock{ Get-ItemProperty -Path "Registry::\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing" } -Credential $LocalAdmin -ErrorAction SilentlyContinue){ $isOnline=$true break } else{ if($isOnline -ne $true){ Write-Host "`r$i" -NoNewline $i++ Start-Sleep -Seconds 1 } } }</code> </pre><br><br>  Die Maschine ist fahrbereit. <br><br><h3>  Gew√ºnschte Zustandskonfiguration <br></h3><br>  Um die gew√ºnschte Konfiguration zu konfigurieren, verwenden wir den PowerShell-Teil - DSC (Desired State Configuration).  Im Netzwerk befindet sich ein konfigurierter DSC-Pull-Server: dscpull.testdomain.eu. <br>  Unten finden Sie die Konfiguration unseres DSC Pull Servers.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Guter Artikel zur Konfiguration von DSC Pull.</a> <br><br><pre> <code class="plaintext hljs">Node $NodeName { WindowsFeature DSCServiceFeature { Ensure = "Present" Name = "DSC-Service" } xDscWebService PSDSCPullServer { Ensure = "Present" EndpointName = "PSDSCPullServer" Port = 8080 PhysicalPath = "$env:SystemDrive\inetpub\PSDSCPullServer" CertificateThumbPrint = $certificateThumbPrint ModulePath = "$env:PROGRAMFILES\WindowsPowerShell\DscService\Modules" ConfigurationPath = "$env:PROGRAMFILES\WindowsPowerShell\DscService\Configuration" State = "Started" DependsOn = "[WindowsFeature]DSCServiceFeature" RegistrationKeyPath = "$env:PROGRAMFILES\WindowsPowerShell\DscService" AcceptSelfSignedCertificates = $true UseSecurityBestPractices = $true } File RegistrationKeyFile { Ensure = 'Present' Type = 'File' DestinationPath = "$env:ProgramFiles\WindowsPowerShell\DscService\RegistrationKeys.txt" Contents = $RegistrationKey } }</code> </pre><br><br>  Es ist verf√ºgbar unter: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://dscpull.testdomain.eu:8080</a> <br><br>  Sein Endpunkt: <a href="">https://dscpull.testdomain.eu:8080/PSDSCPullserver.svc</a> <br><br>  Auf allen Pull-Server-Clients muss PowerShell 5.1 installiert sein <br>  Wenn nicht PowerShell 5.1 installiert ist: <br><br><pre> <code class="plaintext hljs">$PSVersionTable.PSVersion.Major ‚Äìlt 5</code> </pre> <br><br>  Installieren Sie PowerShell 5.1: <br><br><pre> <code class="plaintext hljs">Write-Host "Download PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock { [System.Net.ServicePointManager]::SecurityProtocol=[System.Net.SecurityProtocolType]::Tls12;Invoke-WebRequest -Uri "https://dscpull.testdomain.eu:8080/Files/Updates/WMF.msu" -OutFile C:\TEMP\WMF.MSU } Write-Host "Extract PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock {Start-Process -FilePath 'wusa.exe' -ArgumentList "C:\temp\WMF.msu /extract:C:\temp\" -Wait -PassThru } Write-Host "Apply PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock {Start-Process -FilePath 'dism.exe' -ArgumentList "/online /add-package /PackagePath:C:\temp\WindowsBlue-KB3191564-x64.cab /Quiet" -Wait -PassThru } Write-Host "PowerShell 5.1 has been installed"</code> </pre><br><br>  Ein PKI-Server wird auch in unserem Netzwerk bereitgestellt.  Dies ist eine Bedingung f√ºr die sichere Verschl√ºsselung von Anmeldeinformationen, die in DSC-Mof-Dateien gespeichert sind (Mof-Dateien sind die ‚ÄûSprache‚Äú, in der Pull Server und seine Clients kommunizieren).  Wenn ein Client versucht, sich auf dem Pull-Server zu registrieren, muss ein Fingerabdruck-Zertifikat angegeben werden. Sp√§ter verwendet der Pull-Server dieses Zertifikat zum Verschl√ºsseln von Kennw√∂rtern.  Unten sehen wir, wie es funktioniert. <br><br>  Importieren Sie die Stammzertifizierungsstelle auf unseren neuen Computer: <br><br><pre> <code class="plaintext hljs"> Invoke-Command -ComputerName $server -ScriptBlock{ $PKI="-----BEGIN CERTIFICATE----- MIIF2TCCA8GgAwIBAgIQSPIjcff9rotNdxbg3+ygqDANBgkqhkiG9w0BAQUFADAe **************************************************************** znafMvVx0B4tGEz2PFss/FviGdC3RohBHG0rF5jO50J4nS/3cGGm+HGdn1w/tZd0 a0FWpn9VCOSmXM2It+tSW1f4nZVt6T2kr1ZlTxkDhT7HMSGsrX/XJswzCkDGe3dE qrVVjNUkhVTaeeBWdujB5J6mcx7YkNsAUhODiS9Cf7FnYnxLFA72M0pijI48P5F0 ShM9HWAAUIrLkv13ug== -----END CERTIFICATE-----" $PKI | Out-File RootCA.cer Import-Certificate RootCA.cer -CertStoreLocation Cert:\LocalMachine\Root | select Thumbprint | Out-Null } -Credential $LocalAdmin | Out-Null</code> </pre><br><br>  F√ºr die weitere Arbeit ben√∂tigen wir ein Paar RSA-Schl√ºssel.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir werden ein selbstsigniertes Zertifikat erstellen</a> und vor√ºbergehend damit arbeiten. <br><br>  Jetzt k√∂nnen wir uns auf dem Pull Server registrieren: <br><br><pre> <code class="plaintext hljs">$DscHostFQDN = [System.Net.Dns]::GetHostEntry([string]$env:computername).HostName $DscPullServerURL = "https://$($DscHostFQDN):8080/PSDSCPullserver.svc" $DscWebConfigChildPath = '\inetpub\psdscpullserver\web.config' $DscWebConfigPath = Join-Path -Path $env:SystemDrive -ChildPath $DscWebConfigChildPath $DscWebConfigXML = [xml](Get-Content $DscWebConfigPath) $DscRegKeyName = 'RegistrationKeys.txt' $DscRegKeyXMLNode = "//appSettings/add[@key = 'RegistrationKeyPath']" $DscRegKeyParentPath = ($DscWebConfigXML.SelectNodes($DscRegKeyXMLNode)).value $DscRegKeyPath = Join-Path -Path $DscRegKeyParentPath -ChildPath $DscRegKeyName $DscRegKey = Get-Content $DscRegKeyPath [DSCLocalConfigurationManager()] configuration RegisterOnPull { Node $Node { Settings { ConfigurationModeFrequencyMins = 1440 CertificateID = $Thumbprint RefreshMode ='Pull' RefreshFrequencyMins = 1440 RebootNodeIfNeeded = $true ConfigurationMode ='ApplyAndAutoCorrect' AllowModuleOverwrite = $true DebugMode = 'None' StatusRetentionTimeInDays = 1 } ConfigurationRepositoryWeb $([string]$env:computername) { ServerURL = $DscPullServerURL RegistrationKey = $DscRegKey CertificateID = $Thumbprint ConfigurationNames = @("$hostx") } } } RegisterOnPull -OutputPath $MetaConfigsStorage Set-DscLocalConfigurationManager -ComputerName $Node -Path $MetaConfigsStorage -Verbose -Force -Credential $LocalAdmin</code> </pre><br><br>  Senden Sie die erste Konfiguration an unsere Maschine <br><br><pre> <code class="plaintext hljs">Configuration Rename { param ( [Parameter()] [System.String[]] $Node, $hostname ) Import-DscResource -ModuleName xComputerManagement Import-DscResource ‚ÄìModuleName PSDesiredStateConfiguration Node $Node { xComputer JoinDomain { Name = $hostname } } } Rename -Node $Node -OutputPath $DscConfigPath -hostname $hostname New-DscChecksum $DscConfigPath -Force Invoke-Command -ComputerName $Node -ScriptBlock{Update-DscConfiguration -Verbose -Wait } -Credential $LocalAdmin -Verbose</code> </pre><br><br>  Der Server wird automatisch umbenannt und neu gestartet.  Jetzt k√∂nnen wir Join Domain ausf√ºhren. <br><br><pre> <code class="plaintext hljs">Configuration JoinAD { param ( [Parameter()] [System.String[]] $Node, [Parameter(Mandatory = $true)] [ValidateNotNullorEmpty()] [System.Management.Automation.PSCredential] $DomainAdmin, $hostname, $domain ) Import-DscResource -ModuleName xComputerManagement Import-DscResource ‚ÄìModuleName PSDesiredStateConfiguration Node $Node { xComputer JoinDomain { Name = $hostname DomainName = $domain Credential = $DomainAdmin JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu" } GroupSet LocalAdmins { GroupName = @( 'Administrators') Ensure = 'Present' MembersToInclude = @( 'testdomain-eu\dscstaging' ) } } } $cd = @{ AllNodes = @( @{ NodeName = $Node PSDscAllowPlainTextPassword = $false PSDscAllowDomainUser=$true Certificatefile = $CertFile Thumbprint = $Certificate.ToString() } ) } JoinAD -Node $Node -OutputPath $DscConfigPath -DomainAdmin $DomainAdmin -hostname $hostname -ConfigurationData $cd -domain $domain New-DscChecksum $DscConfigPath -Force Invoke-Command -ComputerName $Node -ScriptBlock{Update-DscConfiguration -Verbose -Wait } -Credential $LocalAdmin -Verbose</code> </pre><br><br>  So sieht unsere mof-Datei aus: <br><br><pre> <code class="plaintext hljs">instance of MSFT_Credential as $MSFT_Credential1ref { Password = "-----BEGIN CMS-----\nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H\nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO+BEyD2cr6vKHdn\nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT+GX4IkPezR\nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp+VQCx2ljlwif6ac4X/PqG\n-----END CMS-----"; UserName = "testdomain.eu\\service_DomainJoin_001"; }; instance of MSFT_xComputer as $MSFT_xComputer1ref { ResourceID = "[xComputer]JoinDomain"; Credential = $MSFT_Credential1ref; DomainName = "testdomain.eu"; SourceInfo = "C:\\Program Files\\WindowsPowerShell\\Scripts\\JoinAD.ps1::34::9::xComputer"; Name = "dsctest51"; JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu"; ModuleName = "xComputerManagement"; ModuleVersion = "4.1.0.0"; ConfigurationName = "JoinAD"; };</code> nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H \ nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO + BEyD2cr6vKHdn \ nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT + GX4IkPezR \ nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp + VQCx2ljlwif6ac4X / PQG \ n ----- END CMS -----"; <code class="plaintext hljs">instance of MSFT_Credential as $MSFT_Credential1ref { Password = "-----BEGIN CMS-----\nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H\nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO+BEyD2cr6vKHdn\nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT+GX4IkPezR\nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp+VQCx2ljlwif6ac4X/PqG\n-----END CMS-----"; UserName = "testdomain.eu\\service_DomainJoin_001"; }; instance of MSFT_xComputer as $MSFT_xComputer1ref { ResourceID = "[xComputer]JoinDomain"; Credential = $MSFT_Credential1ref; DomainName = "testdomain.eu"; SourceInfo = "C:\\Program Files\\WindowsPowerShell\\Scripts\\JoinAD.ps1::34::9::xComputer"; Name = "dsctest51"; JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu"; ModuleName = "xComputerManagement"; ModuleVersion = "4.1.0.0"; ConfigurationName = "JoinAD"; };</code> </pre><br><br>  DSC-verschl√ºsselte Anmeldeinformationen von einem Dienstkonto mit Dom√§nenadministratorrechten: testdomain.eu \\ service_DomainJoin_001 mit einem selbstsignierten Zertifikat.  Der DSC-Client mit seinem privaten Schl√ºssel entschl√ºsselt die Anmeldeinformationen und wendet alle Konfigurationsmodule mit den angegebenen Dom√§nenanmeldeinformationen an.  In diesem Fall wird der Dom√§nenbeitritt in der angegebenen Organisationseinheit ausgef√ºhrt. <br><br><pre> <code class="plaintext hljs">GroupSet LocalAdmins { GroupName = @( 'Administrators') Ensure = 'Present' MembersToInclude = @( testdomain-eu\dscstaging' ) }</code> </pre><br><br>  Dieses Modul f√ºgt lokalen Administratoren dscstaging zur weiteren Konfiguration hinzu. <br><br>  Nach dem Neustart k√∂nnen wir den Computer mit Dom√§nenanmeldeinformationen eingeben. <br><br>  Wir warten darauf, dass der Server ein Zertifikat von unserer PKI erh√§lt (wir haben die automatische Registrierung konfiguriert) und werden in Zukunft mit dem von unserer PKI ausgestellten Zertifikat arbeiten. <br><br><pre> <code class="plaintext hljs">$vmcert=Invoke-Command -ComputerName $server -ScriptBlock{ return Get-ChildItem -Path cert:\LocalMachine\My | where {$_.EnhancedKeyUsageList.FriendlyName -eq "Document Encryption"-and $_.Issuer -eq "CN=TestDomain Issuing CA, DC=testdomain, DC=eu"} } -ErrorAction Ignore</code> </pre> <br><br>  Melden Sie sich jetzt erneut mit dem aktualisierten Fingerabdruck bei Pull Server an. <br><br>  Das war's, der Computer mit Dom√§nenbeitritt, und wir k√∂nnen ihn so verwenden, wie es uns passt. <br><br><h3>  Installieren Sie SQL Server <br></h3><br>  Die JSON-Datei beschreibt die Anforderungen f√ºr MS SQL Server. Wir verwenden DSC auch zum Installieren und Konfigurieren von SQL Server.  So sieht die Konfiguration aus: <br><br><pre> <code class="plaintext hljs">Configuration $Node{ WindowsFeature "NetFramework35"{ Name = "NET-Framework-Core" Ensure = "Present" Source = "\\$DscHostFQDN\Files\Updates" } WindowsFeature "NetFramework45"{ Name = "NET-Framework-45-Core" Ensure= "Present" } SqlSetup "MSSQL2012NamedInstance"{ InstanceName = $MSSQL.InstanceName Features = $MSSQL.Features ProductKey = $ProductKey SQLCollation = $MSSQL.Collation SQLSysAdminAccounts = @('testdomain-EU\SQLAdmins',' testdomain-EU\Backup') InstallSharedDir = "C:\Program Files\Microsoft SQL Server" InstallSharedWOWDir = "C:\Program Files (x86)\Microsoft SQL Server" InstallSQLDataDir = $MSSQL.DataRoot SQLUserDBDir = $MSSQL.UserDBDir SQLUserDBLogDir = $MSSQL.UserLogDir SQLTempDBDir = $MSSQL.TempDBDir SQLTempDBLogDir = $MSSQL.TempDBLogDir SQLBackupDir = $MSSQL.BackupDir SourcePath = $SQLSource SAPwd = $SA SecurityMode = 'SQL' UpdateSource = ".\Updates" Action = "Install" ForceReboot = $True SQLSvcAccount = $SqlServiceCredential AgtSvcAccount = $SqlServiceCredential ISSvcAccount = $SqlServiceCredential BrowserSvcStartupType = "Automatic" DependsOn = '[WindowsFeature]NetFramework35', '[WindowsFeature]NetFramework45' }</code> </pre><br>  Wo $ MSSQL definiert ist: <br><pre> <code class="plaintext hljs">$MSSQL=$Configuration.Applications | where {$_.Application -eq "Microsoft SQL Server 2012"}</code> </pre> <br><br>  $ MSSQL.InstanceName - all dies ist in unserer Json-Datei angegeben.  Durch Anwenden dieser Konfiguration wird MS SQL Server mit allen Updates im Ordner "Updates" installiert und der Server bei Bedarf neu gestartet. <br><br>  Das Auto ist fertig. <br><br><h2>  Service jetzt </h2><br>  In Service-Now <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sind mehrere APIs verf√ºgbar</a> .  Wir verwenden die Rest-API. <br>  Um eine Liste der Computer mit dem Status "Zugewiesen" zu erhalten, wird eine Abfrage des Formulars verwendet: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">instance.service-now.com/cmdb_ci_server_list.do?sysparm_query=install_status=16</a> ^ u_subtype = ^ ORDERBYname <br>  In PowerShell sieht es folgenderma√üen aus: <br><pre> <code class="plaintext hljs">$url="https://instance.service-now.com/api/now/table/cmdb_ci_server?sysparm_query=install_status=16^u_subtype=^ORDERBYname" $uri= new-object System.Uri("https://instance.service-now.com/") #       $credentials = (Get-StoredCredential -Type Generic -Target DSC).GetNetworkCredential() $credentials = new-object System.Net.NetworkCredential $credentials.UserName, $credentials.SecurePassword Add-Type -AssemblyName System.Net.Http $handler = New-Object System.Net.Http.HttpClientHandler $handler.CookieContainer = New-Object System.Net.CookieContainer $handler.UseCookies=$true $handler.Credentials=$credentials $HttpClient = New-Object System.Net.Http.HttpClient($handler) $HttpClient.BaseAddress= $uri $Header = New-Object System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json") $HttpClient.DefaultRequestHeaders.Accept.Clear() $HttpClient.DefaultRequestHeaders.Accept.Add($Header); $response=$HttpClient.GetAsync($url) $respStream=$response.Result.Content.ReadAsStringAsync() $Servers = $respStream.Result | ConvertFrom-Json #   Configuration Items  $ServersCI=$Servers.result</code> </pre> <br>  Das erste Array-Objekt ist der Hostname, den wir ben√∂tigen. <br>  Wenn der Computer bereit ist, k√∂nnen Sie den Status des Computers in Service-Now √§ndern. Dazu das Skript UpdateCI.ps1: <br><pre> <code class="plaintext hljs">param( $CI, [ValidateSet("Allocated","In use","Pending install")] $NewStatus='In use' ) $url="https://instance.service-now.com/api/now/table/cmdb_ci_server?sysparm_query=name=$CI" $uri= new-object System.Uri("https://instance.service-now.com/") $credentials = (Get-StoredCredential -Type Generic -Target DSC).GetNetworkCredential() $credentials = new-object System.Net.NetworkCredential $credentials.UserName, $credentials.SecurePassword Add-Type -AssemblyName System.Net.Http $handler = New-Object System.Net.Http.HttpClientHandler $handler.CookieContainer = New-Object System.Net.CookieContainer $handler.UseCookies=$true $handler.Credentials=$credentials $HttpClient = New-Object System.Net.Http.HttpClient($handler) $HttpClient.BaseAddress= $uri $Header = New-Object System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json") $HttpClient.DefaultRequestHeaders.Accept.Clear() $HttpClient.DefaultRequestHeaders.Accept.Add($Header); $response=$HttpClient.GetAsync($url) $respStream=$response.Result.Content.ReadAsStringAsync() $Servers = $respStream.Result | ConvertFrom-Json $ServerCI=$Servers.result[0] $update=@{} if($NewStatus -eq "In use"){ $update.install_status=1 } if($NewStatus -eq "Pending install"){ $update.install_status=4 } $stringcontent = New-Object System.Net.Http.StringContent((ConvertTo-Json -InputObject $update -Depth 100),[System.Text.Encoding]::UTF8, "application/json"); $result=$HttpClient.PutAsync("https://instance.service-now.com/api/now/table/cmdb_ci_server/$($ServerCI.sys_id)", $stringcontent)</code> </pre> <br>  Um die Tabelle und die Datens√§tze abzurufen, werden REST-API-GET-Anforderungen verwendet, um die Datensatz-PUT / POST-Anforderungen zu √§ndern, in deren Hauptteil die Felder ge√§ndert werden m√ºssen. <br><br>  <i>Wir haben ein praktisches Tool mit einem grafischen Tool wie Azure Portal erstellt, mit dem wir die lokale Infrastruktur f√ºr uns und unsere Kunden so bequem wie m√∂glich verwalten k√∂nnen.</i> <br>  PS 12.24.2018.  Scheint alles veraltet zu sein?  Es ist Zeit, Azure DevOps zu verwenden.  Im n√§chsten Artikel werde ich Ihnen zeigen, wie Sie dies alles mit der Azure DevOps-Pipeline tun. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425129/">https://habr.com/ru/post/de425129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425113/index.html">"Digitale Typografie" oder meine Erfahrung in der mobilen Digitalisierung von B√ºchern</a></li>
<li><a href="../de425115/index.html">Ausgereifte DevOps: Griechische Trag√∂die in drei Akten</a></li>
<li><a href="../de425117/index.html">Zwei Bits pro Transistor: ROM mit hoher Dichte in einem Intel 8087-Gleitkomma-Chip</a></li>
<li><a href="../de425123/index.html">Das mysteri√∂se Herz der Roland TR-808 Drum Machine</a></li>
<li><a href="../de425125/index.html">@ Pythonetc September 2018</a></li>
<li><a href="../de425131/index.html">Was Sie √ºber Blockchain-Technologie lesen sollten: Anleitungen, B√ºcher und Artikel</a></li>
<li><a href="../de425133/index.html">Grenz√ºberschreitende Zahlungsprobleme - warum und wie wird Blockchain hier verwendet?</a></li>
<li><a href="../de425135/index.html">Warum VoIP in den USA als Informationsdienst anerkannt ist und was dies f√ºr die Telekommunikationsbranche und die Nutzer bedeutet</a></li>
<li><a href="../de425137/index.html">Wir arbeiten schnell und effizient in der Konsole</a></li>
<li><a href="../de425139/index.html">Popstars unter der Linse k√ºnstlicher Intelligenz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>