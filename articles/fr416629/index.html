<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤°ğŸ» ğŸš„ ğŸ’†ğŸ» RabbitMQ contre Kafka: deux approches de messagerie diffÃ©rentes ğŸ‘©ğŸ¼â€ğŸ³ ğŸ’¾ ğŸ§•ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans les deux derniers articles, nous avons parlÃ© de IIoT - l'Internet industriel des objets - construit une architecture pour recevoir les donnÃ©es de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ contre Kafka: deux approches de messagerie diffÃ©rentes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/416629/"><p>  Dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux</a> derniers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">articles,</a> nous avons parlÃ© de IIoT - l'Internet industriel des objets - construit une architecture pour recevoir les donnÃ©es des capteurs, soudÃ© les capteurs eux-mÃªmes.  La pierre angulaire des architectures IIoT et de toutes les architectures fonctionnant avec BigData est le traitement des flux de donnÃ©es.  Il est basÃ© sur le concept de messagerie et de mise en file d'attente.  La norme pour travailler avec la messagerie est dÃ©sormais devenue Apache Kafka.  Cependant, afin de comprendre ses avantages (et ses inconvÃ©nients), il serait bon de comprendre les bases du fonctionnement des systÃ¨mes de files d'attente dans leur ensemble, leurs mÃ©canismes de fonctionnement, leurs modes d'utilisation et leurs fonctionnalitÃ©s de base. </p><br><p><img src="https://habrastorage.org/webt/-5/p1/rn/-5p1rnrr3yks4ukkp0kyovqykli.png"></p><br><p>  Nous avons trouvÃ© une excellente sÃ©rie d'articles qui compare les fonctionnalitÃ©s d'Apache Kafka et d'un autre gÃ©ant (Ã  juste titre ignorÃ©) parmi les systÃ¨mes de file d'attente - RabbitMQ.  Nous avons traduit cette sÃ©rie d'articles, leur avons fourni des commentaires et les avons complÃ©tÃ©s.  Bien que la sÃ©rie ait Ã©tÃ© Ã©crite en dÃ©cembre 2017, le monde des systÃ¨mes de messagerie (et en particulier Apache Kafka) Ã©volue si rapidement qu'Ã  l'Ã©tÃ© 2018, certaines choses ont changÃ©. </p><a name="habracut"></a><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Source</a> </blockquote><br><h2 id="rabbitmq-vs-kafka">  RabbitMQ vs Kafka </h2><br><p>  La messagerie est la partie centrale de nombreuses architectures, et les deux piliers dans ce domaine sont RabbitMQ et Apache Kafka.  Ã€ ce jour, Apache Kafka est devenu une norme presque industrielle dans le traitement et l'analyse des donnÃ©es, donc dans cette sÃ©rie, nous examinerons de plus prÃ¨s RabbitMQ et Kafka dans le contexte de leur utilisation dans les infrastructures en temps rÃ©el. </p><br><p> Apache Kafka est maintenant Ã  la hausse, mais il semble qu'ils aient commencÃ© Ã  oublier RabbitMQ.  Tout le battage mÃ©diatique s'est concentrÃ© sur Kafka, et cela se produit pour des raisons Ã©videntes, mais RabbitMQ est toujours un excellent choix pour la messagerie.  L'une des raisons pour lesquelles Kafka s'est tournÃ©e vers lui-mÃªme est son obsession gÃ©nÃ©rale pour l'Ã©volutivitÃ©, et Ã©videmment Kafka est plus Ã©volutif que RabbitMQ, mais la plupart d'entre nous ne se soucient pas des Ã©chelles auxquelles RabbitMQ a des problÃ¨mes.  La plupart d'entre nous ne sont ni Google ni Facebook.  La plupart d'entre nous traitons des volumes quotidiens de messages de centaines de milliers Ã  des centaines de millions, et non des volumes de milliards Ã  des milliards (mais en passant, il y a des cas oÃ¹ les gens ont rÃ©duit RabbitMQ Ã  des milliards de messages quotidiens). </p><br><p>  Ainsi, dans notre sÃ©rie d'articles, nous ne parlerons pas de cas oÃ¹ une Ã©volutivitÃ© extrÃªme est requise (et c'est la prÃ©rogative de Kafka), mais nous nous concentrerons plutÃ´t sur les avantages uniques que chacun des systÃ¨mes considÃ©rÃ©s offre.  Fait intÃ©ressant, chaque systÃ¨me a ses propres avantages, mais en mÃªme temps, ils sont assez diffÃ©rents les uns des autres.  Bien sÃ»r, j'ai beaucoup Ã©crit sur RabbitMQ, mais je vous assure que je n'y accorde aucune prÃ©fÃ©rence particuliÃ¨re.  J'aime les choses bien faites, et RabbitMQ et Kafka sont tous deux des systÃ¨mes de messagerie assez matures, fiables et, oui, Ã©volutifs. </p><br><p>  Nous allons commencer au niveau supÃ©rieur, puis commencer Ã  Ã©tudier les diffÃ©rents aspects de ces deux technologies.  Cette sÃ©rie d'articles est destinÃ©e aux professionnels impliquÃ©s dans l'organisation de systÃ¨mes de messagerie ou aux architectes / ingÃ©nieurs qui souhaitent comprendre les dÃ©tails du niveau infÃ©rieur et leur application.  Nous n'Ã©crirons pas de code, mais nous nous concentrerons plutÃ´t sur les fonctionnalitÃ©s offertes par les deux systÃ¨mes, les modÃ¨les de processus de messagerie que chacun d'eux propose et les dÃ©cisions que les dÃ©veloppeurs et architectes de dÃ©cisions doivent prendre. </p><br><h2 id="rabbitmq-protiv-kafka-dva-raznyh-podhoda-k-obmenu-soobscheniyami">  RabbitMQ contre Kafka: deux approches de messagerie diffÃ©rentes </h2><br><p>  Dans cette partie, nous verrons ce que sont RabbitMQ et Apache Kafka, et leur approche de la messagerie.  Les deux systÃ¨mes abordent l'architecture de messagerie sous diffÃ©rents angles, chacun ayant ses forces et ses faiblesses.  Dans ce chapitre, nous ne tirerons pas de conclusions importantes; nous proposons plutÃ´t de prendre cet article comme un manuel technologique pour les dÃ©butants, afin que nous puissions approfondir les prochains articles de la sÃ©rie. </p><br><h3 id="rabbitmq">  Rabbitmq </h3><br><p>  RabbitMQ est un systÃ¨me de gestion de file d'attente de messages distribuÃ©.  DistribuÃ©, car il fonctionne gÃ©nÃ©ralement comme un cluster de nÅ“uds, oÃ¹ les files d'attente sont rÃ©parties entre les nÅ“uds et, Ã©ventuellement, sont rÃ©pliquÃ©es afin d'Ãªtre rÃ©sistantes aux erreurs et de haute disponibilitÃ©.  RÃ©guliÃ¨rement, il implÃ©mente AMQP 0.9.1 et propose d'autres protocoles, tels que STOMP, MQTT et HTTP via des modules supplÃ©mentaires. </p><br><p>  RabbitMQ utilise des approches de messagerie classiques et innovantes.  Classique dans le sens oÃ¹ il se concentre sur la file d'attente de messages et innovant - dans la possibilitÃ© d'un routage flexible.  Cette fonction de routage est son avantage unique.  La crÃ©ation d'un systÃ¨me de messagerie distribuÃ© rapide, Ã©volutif et fiable est une rÃ©ussite en soi, mais la fonctionnalitÃ© de routage de messagerie le rend vraiment exceptionnel parmi de nombreuses technologies de messagerie. </p><br><h3 id="exchangei-i-ocheredi">  Ã‰change et files d'attente </h3><br><p>  Revue super simplifiÃ©e: </p><br><ul><li>  Les Ã©diteurs (Ã©diteurs) envoient des messages aux Ã©changes </li><li>  Exchange'i envoie des messages dans les files d'attente et Ã  d'autres Ã©changes </li><li>  RabbitMQ envoie des confirmations aux Ã©diteurs dÃ¨s rÃ©ception d'un message </li><li>  Les destinataires (consommateurs) maintiennent des connexions TCP persistantes Ã  RabbitMQ et annoncent la ou les files d'attente qu'ils reÃ§oivent </li><li>  RabbitMQ envoie des messages aux destinataires </li><li>  Les destinataires envoient des confirmations de rÃ©ussite / d'erreur </li><li>  Une fois la rÃ©ception rÃ©ussie, les messages sont supprimÃ©s des files d'attente. </li></ul><br><p>  Cette liste contient un grand nombre de dÃ©cisions que les dÃ©veloppeurs et les administrateurs doivent prendre pour obtenir les garanties de livraison dont ils ont besoin, les caractÃ©ristiques de performance, etc., dont nous discuterons plus tard. </p><br><p>  Voyons un exemple de travail avec un seul Ã©diteur, Ã©change, file d'attente et destinataire: </p><br><p><img src="https://habrastorage.org/webt/u2/ii/3d/u2ii3dm9jk-nuzly06mpebzac8y.png"><br>  <em>Fig.</em>  <em>1. Un Ã©diteur et un destinataire</em> </p><br><p>  Que faire si vous avez plusieurs Ã©diteurs du mÃªme <br>  des messages?  Et si nous avons plusieurs destinataires, chacun souhaitant recevoir tous les messages? </p><br><p><img src="https://habrastorage.org/webt/ug/tw/3d/ugtw3df8efgqhmwpwfs47b9ivoo.png"><br>  <em>Fig.</em>  <em>2. Plusieurs Ã©diteurs, plusieurs destinataires indÃ©pendants</em> </p><br><p>  Comme vous pouvez le voir, les Ã©diteurs envoient leurs messages au mÃªme Ã©changeur, qui envoie chaque message dans trois files d'attente, chacune ayant un destinataire.  Dans le cas de RabbitMQ, les files d'attente permettent Ã  diffÃ©rents destinataires de recevoir tous les messages.  Comparez avec le tableau ci-dessous: </p><br><p><img src="https://habrastorage.org/webt/2_/dj/vd/2_djvdk1k1tnb9u-z9x3q9k2k6o.png"><br>  <em>Fig.</em>  <em>3. Plusieurs Ã©diteurs, une file d'attente avec plusieurs destinataires concurrents</em> <em><br></em> </p><br><p>  Dans la figure 3, nous voyons trois destinataires qui utilisent la mÃªme file d'attente.  Ce sont des destinataires concurrents, c'est-Ã -dire qu'ils sont en concurrence pour recevoir des messages de la file d'attente.  Ainsi, on peut s'attendre Ã  ce qu'en moyenne, chaque destinataire reÃ§oive un tiers des messages de la file d'attente.  Nous utilisons des destinataires concurrents pour faire Ã©voluer notre systÃ¨me de traitement des messages, et en utilisant RabbitMQ, il est trÃ¨s simple de le faire: ajouter ou supprimer des destinataires sur demande.  Quel que soit le nombre de destinataires concurrents dont vous disposez, RabbitMQ ne remettra des messages qu'Ã  un seul destinataire. </p><br><p>  Nous pouvons combiner du riz.  2 et 3 pour recevoir plusieurs ensembles de destinataires concurrents, chaque ensemble recevant chaque message. </p><br><p><img src="https://habrastorage.org/webt/gr/g4/pk/grg4pk5gfkbocpagiccsvcd3oro.png"><br>  <em>Fig.</em>  <em>4. Plusieurs Ã©diteurs, plusieurs files d'attente avec des destinataires concurrents</em> </p><br><p>  Les flÃ¨ches entre les Ã©changeurs et les files d'attente sont appelÃ©es liaisons, et nous en parlerons plus en dÃ©tail. </p><br><h3 id="garantii">  Garanties </h3><br><p>  RabbitMQ donne des garanties de Â«livraison uniqueÂ» et Â«au moins une livraisonÂ», mais pas Â«exactement une livraisonÂ». </p><br><p>  <em>Note du traducteur: Avant la version 0.11 de Kafka, la livraison d'un message de livraison en une seule fois n'Ã©tait pas disponible; actuellement, des fonctionnalitÃ©s similaires sont prÃ©sentes dans Kafka.</em> <em><br></em> </p><br><p>  Les messages sont remis dans l'ordre oÃ¹ ils arrivent dans la file d'attente (aprÃ¨s tout, c'est la dÃ©finition de la file d'attente).  Cela ne garantit pas que l'achÃ¨vement du traitement des messages correspond au mÃªme ordre lorsque vous avez des destinataires concurrents.  Ce n'est pas une erreur RabbitMQ, mais la rÃ©alitÃ© fondamentale du traitement parallÃ¨le d'un ensemble ordonnÃ© de messages.  Ce problÃ¨me peut Ãªtre rÃ©solu Ã  l'aide de l'Ã©change de hachage cohÃ©rent, comme vous le verrez dans le chapitre suivant sur les modÃ¨les et les topologies. </p><br><h3 id="protalkivanie-push-i-predvaritelnaya-vyborka-poluchateley">  Destinataires push et prefetch </h3><br><p>  RabbitMQ envoie des messages aux destinataires (il existe Ã©galement une API pour extraire les messages de RabbitMQ, mais cette fonctionnalitÃ© est obsolÃ¨te pour le moment).  Cela peut submerger les destinataires si les messages arrivent dans la file d'attente plus rapidement que les destinataires ne peuvent les traiter.  Pour Ã©viter cela, chaque destinataire peut dÃ©finir une limite de prÃ©lecture (Ã©galement appelÃ©e limite QoS).  En fait, la limite de QoS est une limite sur le nombre de messages qui n'ont pas Ã©tÃ© acquittÃ©s par le destinataire accumulÃ©s.  Il agit comme un fusible lorsque le rÃ©cepteur commence Ã  prendre du retard. </p><br><p>  Pourquoi a-t-il Ã©tÃ© dÃ©cidÃ© que les messages dans la file d'attente sont poussÃ©s (push) et non dÃ©chargÃ©s (pull)?  D'abord parce qu'il y a moins de temps de retard.  DeuxiÃ¨mement, idÃ©alement, lorsque nous avons des destinataires concurrents de la mÃªme file d'attente, nous voulons rÃ©partir uniformÃ©ment la charge entre eux.  Si chaque destinataire demande / tÃ©lÃ©charge des messages, selon la quantitÃ© demandÃ©e, la rÃ©partition du travail peut devenir assez inÃ©gale.  Plus la distribution des messages est inÃ©gale, plus le retard et la perte d'ordre des messages pendant le traitement sont importants.  Ces facteurs orientent l'architecture RabbitMQ vers un mÃ©canisme push Ã  message Ã  la fois.  C'est l'une des limites de la mise Ã  l'Ã©chelle de RabbitMQ.  La limitation est attÃ©nuÃ©e par le fait que les confirmations peuvent Ãªtre regroupÃ©es. </p><br><h3 id="marshrutizaciya">  Acheminement </h3><br><p>  Les Ã©changes sont essentiellement des routeurs de messages pour les files d'attente et / ou d'autres Ã©changes.  Pour qu'un message soit dÃ©placÃ© de l'Ã©change vers une file d'attente ou vers un autre Ã©change, une liaison est nÃ©cessaire.  DiffÃ©rents Ã©changes nÃ©cessitent des liaisons diffÃ©rentes.  Il existe quatre types d'Ã©changes et de liaisons associÃ©es: </p><br><ul><li>  Fanout  Dirige vers toutes les files d'attente et Ã©changeurs liÃ©s Ã  l'Ã©change du sous-modÃ¨le standard de Pub. </li><li>  Direct (direct).  Achemine les messages en fonction de la clÃ© de routage que le message emporte avec elle, dÃ©finie par l'Ã©diteur.  La clÃ© de routage est une chaÃ®ne courte.  Les Ã©changeurs directs envoient des messages aux files d'attente d'Ã©change / qui ont une clÃ© d'appariement qui correspond exactement Ã  la clÃ© de routage. </li><li>  Sujet (thÃ©matique).  Achemine les messages en fonction de la clÃ© de routage, mais autorise l'utilisation d'une correspondance incomplÃ¨te (caractÃ¨re gÃ©nÃ©rique). </li><li>  En-tÃªte (en-tÃªte).  RabbitMQ vous permet d'ajouter des en-tÃªtes de destinataire aux messages.  Les Ã©changes d'en-tÃªte envoient des messages en fonction de ces valeurs d'en-tÃªte.  Chaque liaison inclut une correspondance exacte des valeurs d'en-tÃªte.  Vous pouvez ajouter plusieurs valeurs Ã  la liaison avec TOUTES ou TOUTES les valeurs nÃ©cessaires pour correspondre. </li><li>  Hachage cohÃ©rent.  Il s'agit d'un Ã©changeur qui hache soit une clÃ© de routage, soit un en-tÃªte de message, et envoie uniquement dans une file d'attente.  Cela est utile lorsque vous devez respecter les garanties des ordres de traitement et Ãªtre en mesure de mettre Ã  l'Ã©chelle les destinataires. </li></ul><br><p><img src="https://habrastorage.org/webt/jb/2d/gr/jb2dgryq0qn6bivddj265nvuyeu.png"><br>  <em>Fig.</em>  <em>5. Exemple d'Ã©change de sujets</em> </p><br><p>  Nous considÃ©rerons Ã©galement le routage plus en dÃ©tail, mais l'exemple d'Ã©change de sujet est donnÃ© ci-dessus.  Dans cet exemple, les Ã©diteurs publient des journaux d'erreurs en utilisant le format de clÃ© de routage LEVEL (niveau d'erreur) .AppName. </p><br><p>  La file d'attente 1 recevra tous les messages car elle utilise un numÃ©ro gÃ©nÃ©rique avec plusieurs mots. </p><br><p>  La file d'attente 2 recevra n'importe quel niveau de journalisation d'application ECommerce.WebUI.  Il utilise un caractÃ¨re gÃ©nÃ©rique *, capturant ainsi le niveau d'une seule dÃ©nomination de sujet (ERROR.Ecommerce.WebUI, NOTICE.ECommerce.WebUI, etc.). </p><br><p>  La file d'attente 3 affichera tous les messages d'ERREUR de n'importe quelle application.  Il utilise le caractÃ¨re gÃ©nÃ©rique # pour couvrir toutes les applications (ERROR.ECommerce.WebUi, ERROR.SomeApp.SomeSublevel, etc.). </p><br><p>  GrÃ¢ce Ã  quatre mÃ©thodes d'acheminement des messages et avec la possibilitÃ© d'Ã©changer des messages pour envoyer des messages Ã  d'autres Ã©changes, RabbitMQ vous permet d'utiliser un ensemble puissant et flexible de modÃ¨les d'Ã©change de messages.  Plus loin, nous parlerons d'Ã©changes avec Ã©changes de lettres mortes, d'Ã©changes et de files d'attente sans donnÃ©es (Ã©changes et files d'attente Ã©phÃ©mÃ¨res), et RabbitMQ se dÃ©veloppera Ã  son plein potentiel. </p><br><h3 id="exchangei-s-nedostavlennymi-soobscheniyami">  Ã‰change non livrÃ© </h3><br><p>  <em>Note du traducteur: lorsque les messages de la file d'attente ne peuvent pas Ãªtre reÃ§us pour une raison ou une autre (la consommation Ã©lectrique n'est pas suffisante, problÃ¨mes de rÃ©seau, etc.), ils peuvent Ãªtre retardÃ©s et traitÃ©s sÃ©parÃ©ment.</em> </p><br><p>  Nous pouvons configurer des files d'attente pour que les messages soient envoyÃ©s Ã  l'Ã©change dans les conditions suivantes: </p><br><ul><li>  La file d'attente dÃ©passe le nombre de messages spÃ©cifiÃ©. </li><li>  La file d'attente dÃ©passe le nombre d'octets spÃ©cifiÃ©. </li><li>  Le dÃ©lai de transmission des messages (TTL) a expirÃ©.  L'Ã©diteur peut dÃ©finir la durÃ©e de vie du message et la file d'attente elle-mÃªme peut Ã©galement avoir un TTL spÃ©cifiÃ© pour le message.  Dans ce cas, un TTL plus court des deux sera utilisÃ©. </li></ul><br><p>  Nous crÃ©ons une file d'attente qui est liÃ©e aux Ã©changes avec des messages non livrÃ©s, et ces messages y sont stockÃ©s jusqu'Ã  ce qu'une action soit entreprise. </p><br><p>  Comme de nombreuses fonctions de RabbitMQ, les Ã©changes avec des messages non distribuables permettent d'utiliser des modÃ¨les qui n'Ã©taient pas fournis Ã  l'origine.  Nous pouvons utiliser des messages TTL et des Ã©changes avec des messages non livrÃ©s pour implÃ©menter des files d'attente diffÃ©rÃ©es et rÃ©essayer des files d'attente. </p><br><h3 id="obmenniki-i-ocheredi-bez-dannyh">  Ã‰changeurs et files d'attente sans donnÃ©es </h3><br><p>  Les Ã©changes et les files d'attente peuvent Ãªtre crÃ©Ã©s dynamiquement et vous pouvez dÃ©finir des critÃ¨res pour leur suppression automatique.  Cela permet l'utilisation de modÃ¨les tels que les RPC basÃ©s sur des messages. </p><br><h3 id="dopolnitelnye-moduli">  Modules supplÃ©mentaires </h3><br><p>  Le premier plug-in que vous souhaitez probablement installer est le plug-in de gestion, qui fournit un serveur HTTP avec une interface Web et une API REST.  Il est trÃ¨s facile Ã  installer et possÃ¨de une interface facile Ã  utiliser.  Le dÃ©ploiement de scripts via l'API REST est Ã©galement trÃ¨s simple. </p><br><p>  De plus: </p><br><ul><li>  Ã‰change de hachage cohÃ©rent, Ã©change de partage, etc. </li><li>  des protocoles comme STOMP et MQTT </li><li>  crochets Web </li><li>  types d'Ã©changeurs supplÃ©mentaires </li><li>  IntÃ©gration SMTP </li></ul><br><p>  Il y a beaucoup d'autres choses Ã  dire sur RabbitMQ, mais c'est un bon exemple qui vous permet de dÃ©crire ce que RabbitMQ peut faire.  Maintenant, nous regardons Kafka, qui utilise une approche complÃ¨tement diffÃ©rente de la messagerie et, en mÃªme temps, a Ã©galement son propre ensemble de fonctionnalitÃ©s distinctives et intÃ©ressantes. </p><br><h3 id="apache-kafka">  Apache kafka </h3><br><p>  Kafka est un journal de validation rÃ©pliquÃ© distribuÃ©.  Kafka n'a aucun concept de files d'attente, ce qui peut sembler Ã©trange au premier abord, Ã©tant donnÃ© qu'il est utilisÃ© comme systÃ¨me de messagerie.  Les files d'attente sont depuis longtemps synonymes de systÃ¨mes de messagerie.  Voyons d'abord ce que signifie un Â«journal de validation des modifications distribuÃ© et rÃ©pliquÃ©Â»: </p><br><ul><li>  DistribuÃ© car Kafka est dÃ©ployÃ© en tant que cluster de nÅ“uds, Ã  la fois pour la tolÃ©rance aux erreurs et pour la mise Ã  l'Ã©chelle </li><li>  RÃ©pliquÃ©, car les messages sont gÃ©nÃ©ralement rÃ©pliquÃ©s sur plusieurs nÅ“uds (serveurs). </li><li>  Un journal de validation, car les messages sont stockÃ©s dans des journaux segmentÃ©s et ajoutÃ©s uniquement appelÃ©s rubriques.  Ce concept de journalisation est le principal avantage unique de Kafka. </li></ul><br><p>  Comprendre le journal (et le sujet) et les partitions est la clÃ© pour comprendre Kafka.  En quoi un journal partitionnÃ© diffÃ¨re-t-il d'un ensemble de files d'attente?  Imaginons Ã  quoi Ã§a ressemble. </p><br><p><img src="https://habrastorage.org/webt/sg/r-/lr/sgr-lrlwlvgr-hxciwvo5uk3ix0.png"><br>  <em>Fig.</em>  <em>6 Un producteur, un segment, un destinataire</em> </p><br><p>  Au lieu de placer des messages dans la file d'attente FIFO et de surveiller l'Ã©tat de ce message dans la file d'attente, comme le fait RabbitMQ, Kafka l'ajoute simplement au journal, et c'est tout. </p><br><p>  Le message reste, qu'il soit reÃ§u une ou plusieurs fois.  Il est supprimÃ© conformÃ©ment Ã  la politique de conservation, Ã©galement appelÃ©e pÃ©riode de fenÃªtre.  Comment les informations sont-elles tirÃ©es du sujet? </p><br><p>  Chaque destinataire garde une trace de l'endroit oÃ¹ il se trouve dans le journal: il y a un pointeur vers le dernier message reÃ§u et ce pointeur est appelÃ© l'adresse de dÃ©calage.  Les destinataires prennent en charge cette adresse via les bibliothÃ¨ques clientes, et selon la version de Kafka, l'adresse est stockÃ©e dans ZooKeeper ou dans Kafka lui-mÃªme. </p><br><p>  Une caractÃ©ristique distinctive du modÃ¨le de journalisation est qu'il Ã©limine instantanÃ©ment de nombreuses difficultÃ©s concernant l'Ã©tat de la remise des messages et, plus important encore pour les destinataires, leur permet de rembobiner, retourner et recevoir des messages Ã  l'adresse relative prÃ©cÃ©dente.  Par exemple, imaginez que vous dÃ©ployez un service qui Ã©met des factures qui prennent en compte les commandes passÃ©es par les clients.  Le service a une erreur et ne calcule pas correctement toutes les factures en 24 heures.  Avec RabbitMQ au mieux, vous devrez en quelque sorte republier ces commandes uniquement sur le service de compte.  Mais avec Kafka, vous dÃ©placez simplement l'adresse relative de ce destinataire il y a 24 heures. </p><br><p>  Voyons donc Ã  quoi cela ressemble quand il y a un sujet dans lequel il y a une partition et deux destinataires, chacun devant recevoir chaque message. </p><br><p><img src="https://habrastorage.org/webt/w1/ii/zh/w1iizhiisxgsumup_ufs8rm_dvk.png"><br>  <em>Fig.</em>  <em>7. Un producteur, une partition, deux destinataires indÃ©pendants</em> </p><br><p>  Comme le montre le diagramme, deux destinataires indÃ©pendants reÃ§oivent la mÃªme partition, mais lisent Ã  des adresses de dÃ©calage diffÃ©rentes.  Le service de facturation prend peut-Ãªtre plus de temps pour traiter les messages que le service de notification push.  ou peut-Ãªtre que le service de facturation n'Ã©tait pas disponible depuis un certain temps et a essayÃ© de rattraper son retard plus tard.  Ou peut-Ãªtre qu'il y a eu une erreur et que l'adresse de dÃ©calage a dÃ» Ãªtre reportÃ©e de plusieurs heures. </p><br><p>  Supposons maintenant que le service de facturation doive Ãªtre divisÃ© en trois parties, car il ne peut pas suivre la vitesse du message.  Avec RabbitMQ, nous dÃ©ployons simplement deux autres applications de service de facturation qui proviennent de la file d'attente de facturation.  Mais Kafka ne prend pas en charge les destinataires concurrents dans la mÃªme partition; le bloc de concurrence Kafka est la partition elle-mÃªme.  Par consÃ©quent, si nous avons besoin de trois destinataires de factures, nous avons besoin d'au moins trois partitions.  Nous avons donc maintenant: </p><br><p><img src="https://habrastorage.org/webt/3k/fn/rd/3kfnrdjpllbt0nqidfaxrveqvfc.png"><br>  <em>Fig.</em>  <em>8. Trois partitions et deux groupes de trois destinataires</em> </p><br><p>  Ainsi, il est entendu que vous avez besoin d'au moins autant de partitions que le destinataire horizontal le plus Ã©voluÃ©.  Parlons un peu des partitions. </p><br><h3 id="particii-i-gruppy-poluchateley">  Partitions et groupes de destinataires </h3><br><p>  Chaque partition est un fichier distinct dans lequel la sÃ©quence des messages est garantie.  Il est important de s'en souvenir: l'ordre des messages est garanti dans une seule partition.  Ã€ l'avenir, cela peut conduire Ã  une certaine contradiction entre les exigences de mise en file d'attente des messages et les exigences de performances, car les performances dans Kafka sont Ã©galement mises Ã  l'Ã©chelle par les partitions.  La partition ne peut pas prendre en charge les destinataires concurrents, notre application de facturation ne peut donc utiliser qu'une seule partie pour chaque section. </p><br><p>  Les messages peuvent Ãªtre redirigÃ©s vers des segments par un algorithme cyclique ou via une fonction de hachage: hachage (clÃ© de message)% nombre de partitions.      ,      ,     , ,   ,     ,     .            . </p><br><p>       RabbitMQ.                .   ,     RabbitMQ    ,              .  ,                . </p><br><p>   RabbitMQ                    .  Kafka ,      . </p><br><p>  ,   ,    Kafka   ,   RabbitMQ   â€”    . RabbitMQ     ,            . Kafka      ,      . ,        ,  Kafka     ,     . </p><br><p> ,     ,      ,           (  ).       ,          ,     .  ,      ,      ,        . </p><br><p>      RabbitMQ â€”   Consistent Hashing exchange,      .   Kafka'   ,  Kafka      ,             ,   , ,     ,      -.  RabbitMQ      ,     ,    ,    . </p><br><p>     :   ,     ,    Id 1000     ,     Id 1000    .    ,    ,    .   ,      . </p><br><h3 id="protalkivanie-push-protiv-vygruzki-pull">  (push)   (pull) </h3><br><p> RabbitMQ    (push) ,  ,          .                RabbitMQ   .   , Kafka    (pull),         .     ,          , Kafka  long-polling. </p><br><p>   (pull)    Kafka -  .  Kafka        ,           ,       . </p><br><p>       RabbitMQ,             ,     ,       ,      .   Kafka       ,            . </p><br><h3 id="publikaciya-i-podpiska">    </h3><br><p> Kafka    /Â»    ,   ,       .       ,            . </p><br><p><img src="https://habrastorage.org/webt/w1/ii/zh/w1iizhiisxgsumup_ufs8rm_dvk.png"><br>  <em>Fig.</em> <em>9.     </em> </p><br><p>       ,       ,       Kafka     : </p><br><p>  Fig. 10.  ,         <br> <em><img src="https://habrastorage.org/webt/zl/uu/eu/zluueuxxppnji50tgqnar-pnmfk.png"></em> </p><br><p>           ,   : </p><br><p><img src="https://habrastorage.org/webt/xo/bw/op/xobwopr8b9fey8huqbclx85mh4y.png"><br>  <em>Fig.</em> <em>11.      </em> </p><br><p>         , ,               . </p><br><p> ,     ,  ,     ,  . </p><br><p><img src="https://habrastorage.org/webt/uf/wn/a4/ufwna4h-bmmmr48gp0yo8akk4je.png"><br>  <em>Fig.</em> <em>12.   </em> </p><br><p>          .         . </p><br><p><img src="https://habrastorage.org/webt/ok/vs/ce/okvsce2-xvrnztcupmx-fkbyg5w.png"></p><br><p>      : </p><br><ul><li>      </li><li>      ( ,       ) </li><li>    </li></ul><br><p>           ,               .     ,   ,    . </p><br><p>     Kafka â€“       , , ,     , ,     .    .            ,         .  ,   ,     . </p><br><h3 id="szhatie-zhurnala">   </h3><br><p>     â€”       . ,        50 .        â€“  .   ,   ,         ,  . </p><br><p>  ,    ,     .  ,    ,       .           ,         .  ,    ,      ,    . </p><br><p>                    .   ,  ,        . </p><br><h3 id="podrobnee-ob-uporyadochenii-soobscheniy">     </h3><br><p>  ,           RabbitMQ,    Kafka,   Kafka   .  RabbitMQ           ,    ,   ZooKeeper  Consul. </p><br><p>   RabbitMQ    ,    Kafka.      RabbitMQ,     ,      .  :            . </p><br><p>    .        ,         .     .         ,    .            .       .  ,   ,    -   . </p><br><p>           ,   Kafka,     .     .  ,         ,       . </p><br><p>  ,    . RabbitMQ        ,  Kafka        . </p><br><h3 id="vyvody">  Conclusions </h3><br><p> RabbitMQ          ,    .           ,     ,     .    ,           .             ,     ,    . </p><br><p>   Kafka         .               ,         .   Kafka       ,  RabbitMQ    . ,  Kafka    ,  RabbitMQ,         ,       . </p><br><p>              RabbitMQ. </p><br><blockquote> , ,      IoT  ,    . : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t.me/justiothings</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416629/">https://habr.com/ru/post/fr416629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416619/index.html">Webinaire ouvert Â«CrÃ©ation d'un site Web sur le framework Yii2Â»</a></li>
<li><a href="../fr416621/index.html">Homo Extensis. DÃ©velopper les capacitÃ©s humaines ou comment combiner l'homme et le robot</a></li>
<li><a href="../fr416623/index.html">L'objectivitÃ© de la psychothÃ©rapie</a></li>
<li><a href="../fr416625/index.html">Un nouveau systÃ¨me de reconnaissance faciale installÃ© par la police de Londres ne peut reconnaÃ®tre personne</a></li>
<li><a href="../fr416627/index.html">Gestion du convoyeur informatique, ou aller-retour</a></li>
<li><a href="../fr416633/index.html">QUIC, TLS 1.3, DNS sur HTTPS, puis partout</a></li>
<li><a href="../fr416635/index.html">De droite Ã  gauche. Comment transformer l'interface du site sous RTL</a></li>
<li><a href="../fr416637/index.html">Musique Ã  partir de papier et de carton: une brÃ¨ve histoire du variophone et du Â«son dessinÃ©Â»</a></li>
<li><a href="../fr416639/index.html">Entretien avec un pionnier du rajeunissement</a></li>
<li><a href="../fr416641/index.html">8 Ã©tapes du processus de dÃ©veloppement d'une interface d'application mobile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>