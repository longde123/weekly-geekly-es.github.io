<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⌨️ 🏹 👨‍💻 实现它-在Unity上开发逻辑游戏 🐁 🍟 🍆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我想分享由两个开发人员和一个艺术家进行的简单手机游戏的开发过程。 本文主要是对技术实现的描述。 
 注意，很多文字！ 

 尽管我希望读者可以从中学习到一些有用的东西，但本文不是指导性或课程。 为熟悉Unity并具有一定编程经验的开发人员设计。 

 内容： 
 主意 
 游戏玩法 
 情节 
 发...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>实现它-在Unity上开发逻辑游戏</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453564/"><img src="https://habrastorage.org/webt/4k/h-/6e/4kh-6e4-iwvtuaz42eqb2gg81iu.png"><br><br> 我想分享由两个开发人员和一个艺术家进行的简单手机游戏的开发过程。 本文主要是对技术实现的描述。 <br> 注意，很多文字！ <br><br> 尽管我希望读者可以从中学习到一些有用的东西，但本文不是指导性或课程。 为熟悉Unity并具有一定编程经验的开发人员设计。 <br><a name="habracut"></a><br><a name="Content"></a><h4> 内容： </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">主意</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">游戏玩法</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">情节</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发展历程</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">核心</a> <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">电气元件</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解算器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ElementsProvider</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">电路生成器</a> </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">游戏类</a> <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开发方法和DI</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">构型</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">电气元件</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">游戏管理</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">水平加载</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">过场动画</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">额外的游戏玩法</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">营利</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用者介面</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分析工具</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">相机位置和图表</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">配色方案</a> </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编辑器扩展</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发电机组</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解算器</a> </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有用的</a> <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">断言帮助</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SceneObjectsHelper</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">协程启动器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">小发明</a> </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">测试中</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发展总结</a> <br><br><a name="Idea"></a><h2> 主意 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目录内容</a> <br><br> 有一个想法是在短时间内制作一个简单的手机游戏。 <br><br> 条款： <br><br><ul><li> 易于实现的游戏 </li><li> 最低艺术要求 </li><li> 开发时间短（几个月） </li><li> 轻松自动化内容创建（关卡，位置，游戏元素） </li><li> 如果游戏包含有限数量的关卡，则可以快速创建关卡 </li></ul><br> 为了决定，但是实际上是做什么的？ 毕竟，提出游戏的想法，而不是游戏的想法。 决定从App Store寻求灵感。 <br><br> 在以上项目中添加： <br><br><ul><li> 该游戏应在玩家中具有一定的知名度（下载次数+评分） </li><li> 应用商店不应挤满类似游戏 </li></ul><br> 发现具有基于逻辑门的游戏玩法的游戏。 没有大量类似的游戏，该游戏具有许多下载量和正面评分。 但是，经过尝试，您的游戏中仍存在一些缺点。 <br><br> 游戏的玩法是，关卡是具有许多输入和输出的数字电路。 播放器必须选择输入的组合，以使输出为逻辑1。听起来并不困难。 该游戏还具有自动生成的关卡，这表明可以自动创建关卡，尽管听起来并不简单。 这个游戏也很适合学习，我非常喜欢。 <br><br> 优点： <br><br><ul><li> 游戏玩法的技术简化 </li><li> 看起来很容易通过自动测试进行测试 </li><li> 自动生成关卡的能力 </li></ul><br> 缺点： <br><br><ul><li> 您必须先创建关卡 </li></ul><br> 现在探索启发游戏的缺陷。 <br><br><ul><li> 无法适应自定义的宽高比，例如18：9 </li><li> 没有办法跳过困难的水平或获得提示 </li><li> 在评论中，关于少数几个级别的投诉 </li><li> 评论抱怨缺乏各种要素 </li></ul><br> 我们进行游戏的计划： <br><br><ul><li> 我们使用标准逻辑门（AND，NAND，OR，NOR，XOR，XNOR，NOR，NOT） </li><li> 门是用图片而不是文字显示的，这很容易区分。 由于元素具有标准的ANSI符号，因此我们使用它们。 </li><li> 我们丢弃了将一个输入连接到一个输出的开关。 由于它需要您单击自己，因此有点不适合实际的数字元素。 是的，很难想象芯片中的拨动开关。 </li><li> 添加编码器和解码器的元素。 </li><li> 我们引入一种模式，玩家必须在该模式中选择电路输入端具有固定值的单元中的所需元素。 </li><li> 我们为玩家提供帮助：提示+跳过级别。 </li><li> 添加一些情节会很好。 </li></ul><br><a name="Gameplay"></a><h2> 游戏玩法 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目录内容</a> <br><br> 模式1：播放器接收电路并有权更改输入上的值。 <br> 模式2：玩家收到一个电路，在其中他可以更改元素，但不能更改输入的值。 <br><br> 游戏将采用预先准备的关卡形式。 完成关卡后，玩家必须得到一些结果，这将根据传球的结果以传统的三颗星的形式完成。 <br><br> 绩效指标可以是： <br> 动作数量：与游戏元素的每次互动都会增加计数器。 <br> 结果状态与原始状态的差异数。 不考虑玩家必须完成多少次尝试。 不幸的是，它不适合第二种制度。 <br> 添加具有随机级别生成的相同模式会很好。 但是现在，将其推迟。 <br><br><a name="Plot"></a><h2> 情节 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目录内容</a> <br><br> 在考虑游戏玩法并开始开发时，出现了各种想法来改进游戏。 并且出现了一个足够有趣的想法-添加情节。 <br><br> 关于设计电路的工程师。 还不错，但是还不完整，也许值得根据玩家的表现来展示芯片的制造？ 不知何故，没有一个简单易懂的结果。 <br><br> 这个主意！ 工程师使用其逻辑电路开发了一款出色的机器人。 机器人是一件相当容易理解的事情，非常适合游戏玩法。 <br><br> 还记得第一段“对艺术的最低要求”吗？ 某些情节中的过场动画不适合。 然后，一位熟悉的艺术家来营救，他同意帮助我们。 <br><br> 现在，让我们决定过场动画的格式和集成方式。 <br><br> 该情节必须显示为过场动画，不计分或文字说明，以消除本地化问题，简化其理解以及许多在移动设备上播放而没有声音的情况。 游戏是数字电路中非常真实的元素，也就是说，很可能将它与现实联系起来。 <br><br> 过场动画和关卡应该是分开的场景。 在确定级别之前，将加载特定场景。 <br><br> 好了，任务已经确定，有资源可以完成，工作已经开始沸腾。 <br><br><a name="Development"></a><h2> 发展历程 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目录内容</a> <br><br> 我立即决定在平台上，这是Unity。 是的，有点矫kill过正，但我​​仍然认识她。 <br><br> 在开发过程中，代码会立即与测试一起编写，甚至在编写之后。 但是对于整体叙述，测试放在下面的单独部分中。 当前部分将与测试分开描述开发过程。 <br><br><a name="Core"></a><h3> 核心 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目录内容</a> <br><br> 游戏的核心看起来非常简单，并且与引擎无关，因此我们从C＃代码的形式开始设计。 看来您可以选择一个单独的核心核心逻辑。 将其带到一个单独的项目。 <br><br>  Unity使用C＃解决方案，对于常规的.Net开发人员而言，内部项目有些不寻常，.sln和.csproj文件是由Unity本身生成的，这些文件中的更改不接受Unity方面的考虑。 他将简单地覆盖它们并删除所有更改。 要创建一个新项目，必须使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">程序集定义</a>文件。 <br><br><img src="https://habrastorage.org/webt/b2/84/92/b28492ps5o-_mv62mdvo1frk4l8.png"><br><br><img src="https://habrastorage.org/webt/vd/xk/_k/vdxk_k9ydjfhu1aiee8ctlx3eau.png"><br><br> 现在，Unity会生成一个具有适当名称的项目。  .asmdef文件所在的文件夹中的所有内容都将与此项目和程序集相关。 <br><br><a name="CoreElectricalElements"></a><h4> 电气元件 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目录内容</a> <br><br> 任务是在代码中描述逻辑元素之间的相互作用。 <br><br><ul><li> 一个元素可以有多个输入和多个输出。 </li><li> 元素的输入必须连接到另一个元素的输出 </li><li> 元素本身必须包含自己的逻辑。 </li></ul><br> 让我们开始吧。 <br><br><ul><li>  <b>该元素</b>包含自己的操作逻辑并链接到其输入。 当从元素请求值时，它从输入中获取值，对其应用逻辑，然后返回结果。 可能有多个输出，因此请求特定输出的值，默认值为0。 </li><li> 要在输入处获取值，将有一个<b>输入连接器</b> p，它存储到另一个连接器-输出连接器。 </li><li>  <b>输出连接器</b>引用特定元素，并存储到其元素的链接，当请求值时，它从该元素请求它。 </li></ul><br><img src="https://habrastorage.org/webt/am/7q/yo/am7qyonro-bohnomthogk8qy8o0.png"><br><br> 箭头指示数据的方向，即元素在相反方向上的依赖性。 <br> 定义连接器的接口。 您可以从中获得价值。 <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IConnector</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br> 只是如何将其连接到另一个连接器？ <br><br> 定义更多接口。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IInputConnector</span></span> : <span class="hljs-title"><span class="hljs-title">IConnector</span></span> { IOutputConnector ConnectedOtherConnector { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  IInputConnector是一个输入连接器，它具有到另一个连接器的链接。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IOutputConnector</span></span> : <span class="hljs-title"><span class="hljs-title">IConnector</span></span> { IElectricalElement Element { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br> 输出连接器引用其元素，它将请求一个值。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IElectricalElement</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br> 电气元件必须包含在特定输出上返回值的方法，数字是输出的编号。 <br><br>  <i>我将其称为IElectricalElement，尽管它仅传输逻辑电压电平，但另一方面，它可以是根本不添加逻辑的元素，只是像导体一样传递一个值。</i> <br><br> 现在让我们继续执行 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">InputConnector</span></span> : <span class="hljs-title"><span class="hljs-title">IInputConnector</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IOutputConnector ConnectedOtherConnector { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ConnectedOtherConnector?.Value ?? <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre> <br> 传入连接器可能未连接，在这种情况下它将返回false。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OutputConnector</span></span> : <span class="hljs-title"><span class="hljs-title">IOutputConnector</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> number; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OutputConnector</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.number = number; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IElectricalElement Element { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Value =&gt; Element.GetValue(number); } }</code> </pre> <br> 输出应具有指向其元素的链接以及与元素有关的编号。 <br> 此外，他使用该数字从元素请求一个值。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ElectricalElementBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IInputConnector[] Input { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br> 所有元素的基类仅包含输入数组。 <br><br> 元素的示例实现： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">And</span></span> : <span class="hljs-title"><span class="hljs-title">ElectricalElementBase</span></span>, <span class="hljs-title"><span class="hljs-title">IElectricalElement</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> outputValue = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input?.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { outputValue = Input[<span class="hljs-number"><span class="hljs-number">0</span></span>].Value; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Input) { outputValue &amp;= item.Value; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outputValue; } }</code> </pre> <br> 该实现完全基于逻辑操作而没有硬性事实表。 也许不像该表那样明确，但是它将很灵活，可以在任意数量的输入上使用。 <br> 所有逻辑门都有一个输出，因此输出上的值将不取决于输入数字。 <br><br> 反转元素如下所示： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Nand</span></span> : <span class="hljs-title"><span class="hljs-title">And</span></span>, <span class="hljs-title"><span class="hljs-title">IElectricalElement</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> new </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.GetValue(number); } }</code> </pre> <br> 值得注意的是，这里的GetValue方法已被覆盖，实际上并未被覆盖。 这是基于以下逻辑完成的：如果Nand保存到And，他将继续表现为And。 也可以应用合成，但这将需要额外的代码，这没有多大意义。 <br><br> 除常规阀外，还创建了以下元素： <br> 来源-0或1的恒定值来源。 <br> 导体-相同的导体或导体，但用途略有不同，请参见生成。 <br>  AlwaysFalse-始终返回第二模式所需的0。 <br><br><a name="Solver"></a><h4> 解算器 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目录内容</a> <br><br> 接下来，一个类对于自动查找在电路输出端给出1的组合很有用。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISolver</span></span> { ICollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[]&gt; GetSolutions(IElectricalElement root, <span class="hljs-keyword"><span class="hljs-keyword">params</span></span> Source[] sources); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Solver</span></span> : <span class="hljs-title"><span class="hljs-title">ISolver</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ICollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[]&gt; GetSolutions(IElectricalElement root, <span class="hljs-keyword"><span class="hljs-keyword">params</span></span> Source[] sources) { <span class="hljs-comment"><span class="hljs-comment">// max value can be got with this count of bits(sources count), also it's count of combinations -1 // for example 8 bits provide 256 combinations, and max value is 255 int maxValue = Pow(sources.Length); // inputs that can solve circuit var rightInputs = new List&lt;bool[]&gt;(); for (int i = 0; i &lt; maxValue; i++) { var inputs = GetBoolArrayFromInt(i, sources.Length); for (int j = 0; j &lt; sources.Length; j++) { sources[j].Value = inputs[j]; } if (root.GetValue()) { rightInputs.Add(inputs); } } return rightInputs; } private static int Pow(int power) { int x = 2; for (int i = 1; i &lt; power; i++) { x *= 2; } return x; } private static bool[] GetBoolArrayFromInt(int value, int length) { var bitArray = new BitArray(new[] {value}); var boolArray = new bool[length]; for (int i = length - 1; i &gt;= 0; i—) { boolArray[i] = bitArray[i]; } return boolArray; }</span></span></code> </pre> <br> 解决方案是蛮力的。 为此，确定最大数量，该最大数量可以由一组比特来表示，其数量等于源的数量。 也就是说，4个源= 4位=最大数量15。我们对从0到15的所有数字进行排序。 <br><br><a name="ElementsProvider"></a><h4>  ElementsProvider </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目录内容</a> <br><br> 为了方便生成，我决定为每个元素定义一个数字，为​​此，我使用IElementsProvider接口创建了ElementsProvider类。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IElementsProvider</span></span> { IList&lt;Func&lt;IElectricalElement&gt;&gt; Gates { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } IList&lt;Func&lt;IElectricalElement&gt;&gt; Conductors { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } IList&lt;ElectricalElementType&gt; GateTypes { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } IList&lt;ElectricalElementType&gt; ConductorTypes { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ElementsProvider</span></span> : <span class="hljs-title"><span class="hljs-title">IElementsProvider</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;Func&lt;IElectricalElement&gt;&gt; Gates { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Func&lt;IElectricalElement&gt;&gt; { () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> And(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Nand(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Or(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Nor(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Xor(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Xnor() }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;Func&lt;IElectricalElement&gt;&gt; Conductors { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Func&lt;IElectricalElement&gt;&gt; { () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Conductor(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Not() }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;ElectricalElementType&gt; GateTypes { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ElectricalElementType&gt; { ElectricalElementType.And, ElectricalElementType.Nand, ElectricalElementType.Or, ElectricalElementType.Nor, ElectricalElementType.Xor, ElectricalElementType.Xnor }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;ElectricalElementType&gt; ConductorTypes { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ElectricalElementType&gt; { ElectricalElementType.Conductor, ElectricalElementType.Not }; }</code> </pre> <br> 前两个列表就像工厂一样，以指定的编号提供商品。 由于Unity的功能，最后两个列表是必须使用的拐杖。 关于它进一步。 <br><br><a name="CircuitGenerator"></a><h4> 电路生成器 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目录内容</a> <br><br> 现在，开发中最困难的部分是电路生成。 <br><br> 任务是生成一个方案列表，然后您可以在编辑器中从中选择所需的方案。 仅对于简单的阀门才需要生成。 <br><br> 设置方案的某些参数，这些参数是：层数（元素的水平线）和层中元素的最大数量。 还必须确定需要从哪些门生成电路。 <br><br> 我的方法是将任务分为两部分-结构生成和选项选择。 <br><br> 结构生成器确定逻辑元素的位置和连接。 <br> 变量生成器选择位置中元素的有效组合。 <br><br><h4> 结构生成器 </h4><br> 该结构由逻辑元件层和导体/反相器层组成。 整个结构不包含真实元素，而是包含它们的容器。 <br><br> 容器是从IElectricalElement继承的类，该类内部包含有效元素的列表，并且可以在它们之间进行切换。 每个项目在列表中都有其自己的编号。 <br><br><pre> <code class="cs hljs">ElectricalElementContainer : ElectricalElementBase, IElectricalElement</code> </pre> <br><br> 容器可以将“自身”设置为列表中的元素之一。 在初始化期间，必须给它提供将创建项目的代表列表。 在内部，它调用每个委托并获取项目。 然后，您可以设置此元素的特定类型，这会将内部元素连接到与容器中相同的输入，并且容器的输出将从该元素的输出中获取。 <br><br><img src="https://habrastorage.org/webt/wq/kt/bn/wqktbn6x7esbfnqxkuwh606qvqa.png"><br><br> 设置元素列表的方法： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;Func&lt;IElectricalElement&gt;&gt; elements</span></span></span><span class="hljs-function">)</span></span> { Elements = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;IElectricalElement&gt;(elements.Count); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> elements) { Elements.Add(item()); } }</code> </pre> <br> 接下来，您可以通过以下方式设置类型： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isInitialized == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(UnitializedElementsExceptionMessage); } SelectedType = number; RealElement = Elements[number]; ((ElectricalElementBase) RealElement).Input = Input; }</code> </pre> <br> 之后，它将作为指定项目。 <br><br> 为该电路创建了以下结构： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CircuitStructure</span></span> : <span class="hljs-title"><span class="hljs-title">ICloneable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, ElectricalElementContainer[]&gt; Gates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, ElectricalElementContainer[]&gt; Conductors; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Source[] Sources; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> And FinalDevice; }</code> </pre> <br> 此处的词典将层号存储在键中，并存储该层的一组容器。 接下来是一系列源和一个将所有内容都连接到的FinalDevice。 <br><br> 因此，结构生成器创建容器并将它们彼此连接。 这都是从下到上的分层创建的。 底部是最宽的（大多数元素）。 上面的层包含的元素要少两倍，依此类推，直到达到最小值。 顶层所有元素的输出都连接到最终设备。 <br><br> 逻辑元素层包含用于门的容器。 在导体层中，存在具有一个输入和输出的元素。 元素可以是导体或NO元素。 导体将输入的内容传递到输出，而NO元素在输出处返回取反的值。 <br><br> 第一个创建源数组。 生成从下往上进行，首先生成导体层，然后生成逻辑层，然后再从逻辑层输出导体。 <br><br><img src="https://habrastorage.org/webt/pq/bj/hs/pqbjhsbn3xxxi6r6wosryczrdjc.png"><br><br> 但是这样的方案很无聊！ 我们想进一步简化生活，并决定使生成的结构更有趣（复杂），并决定添加结构修改，并通过许多层进行分支或连接。 <br><br> 好吧，说“简化”-这意味着使您的生活变得更加复杂。 <br> 产生具有最大可修改性水平的电路被证明是费力的并且不是很实际的任务。 因此，我们的团队决定采取符合以下条件的措施： <br> 这项任务的开发并不需要很多时间。 <br> 或多或少地产生了修饰结构。 <br> 导体之间没有交叉点。 <br> 经过漫长而艰辛的编程，该解决方案于下午4点编写。 <br> 让我们看一下代码和̶̶̶̶̶̶̶̶̶̶。 <br><br>  <i>在这里遇到OverflowArray类。</i>  <i>由于历史原因，它是在基本结构世代之后添加的，并且与变体世代有更多关系，因此位于下面。</i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">友情链接</a></i> <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;CircuitStructure&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateStructure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lines, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxElementsInLine, StructureModification modification</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> baseStructure = GenerateStructure(lines, maxElementsInLine); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; lines; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxValue = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> branchingSign = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (modification == StructureModification.All) { maxValue = <span class="hljs-number"><span class="hljs-number">2</span></span>; branchingSign = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lengthOverflowArray = baseStructure.Gates[(i * <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>].Length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OverflowArray(lengthOverflowArray, maxValue); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> numberOfOption = Math.Pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, lengthOverflowArray); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">1</span></span>; k &lt; numberOfOption - <span class="hljs-number"><span class="hljs-number">1</span></span>; k++) { elementArray.Increase(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (modification == StructureModification.Branching || modification == StructureModification.All) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CheckOverflowArrayForAllConnection(elementArray, branchingSign, lengthOverflowArray)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// Clone CircuitStructure var structure = (CircuitStructure) baseStructure.Clone(); ConfigureInputs(lines, structure.Conductors, structure.Gates); var sources = AddSourcesLayer(structure.Conductors, maxElementsInLine); var finalElement = AddFinalElement(structure.Conductors); structure.Sources = sources; structure.FinalDevice = finalElement; int key = (i * 2) + 1; ModifyStructure(structure, elementArray, key, modification); ClearStructure(structure); yield return structure; } } }</span></span></code> </pre> <br> 查看此代码后，我想了解其中发生了什么。 <br> 不用担心！ 简短的解释，没有详细信息，请您尽快处理。 <br><br> 我们要做的第一件事是创建一个普通的（基本）结构。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> baseStructure = GenerateStructure(lines, maxElementsInLine);</code> </pre> <br> 然后，作为简单检查的结果，我们将分支符号（branchingSign）设置为适当的值，为什么这样做是必要的？ 进一步将是清楚的。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxValue = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> branchingSign = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (modification == StructureModification.All) { maxValue = <span class="hljs-number"><span class="hljs-number">2</span></span>; branchingSign = <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br> 现在，我们确定OverflowArray的长度并对其进行初始化。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lengthOverflowArray = baseStructure.Gates[(i * <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>].Length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OverflowArray(lengthOverflowArray, maxValue);</code> </pre> <br> 为了使我们能够继续对该结构进行操作，我们需要找出OverflowArray的可能变体的数量。 为此，在下一行应用了一个公式。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lengthOverflowArray = baseStructure.Gates[(i * <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>].Length;</code> </pre> <br> 接下来是一个嵌套循环，其中发生了所有“魔术”，并且有了所有这些序言，从一开始，我们就增加了数组的值。 <br><br><pre> <code class="cs hljs">elementArray.Increase();</code> </pre><br> 之后，我们会看到一个验证检查，因此我们将继续进行下一个迭代或下一个迭代。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (modification == StructureModification.Branching || modification == StructureModification.All) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CheckOverflowArrayForAllConnection(elementArray, branchingSign, lengthOverflowArray)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } }</code> </pre><br> 如果数组通过了验证检查，那么我们将克隆我们的基本结构。 需要克隆，因为我们将修改结构以进行更多迭代。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Clone CircuitStructure var structure = (CircuitStructure) baseStructure.Clone(); ConfigureInputs(lines, structure.Conductors, structure.Gates); var sources = AddSourcesLayer(structure.Conductors, maxElementsInLine); var finalElement = AddFinalElement(structure.Conductors); structure.Sources = sources; structure.FinalDevice = finalElement;</span></span></code> </pre> <br> 最后，我们开始修改结构并清除不必要的元素。 由于结构修改，它们变得不必要。 <br><br><pre> <code class="cs hljs">ModifyStructure(structure, elementArray, key, modification); ClearStructure(structure);</code> </pre> <br> 我没有更详细地分析深度在“某处”执行的许多小功能的要点。 <br><br><h4> 变体发生器 </h4><br> 应该包含在其中的结构+元素称为CircuitVariant。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> CircuitVariant { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CircuitStructure Structure; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]&gt; Gates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]&gt; Conductors; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[]&gt; Solutions; }</code> </pre> <br> 第一个字段是指向结构的链接。 第二两个字典，其中的键是层的编号，而值是一个数组，其中包含元素在结构中位置的数量。 <br><br> 我们继续选择组合。 我们可以有一定数量的有效逻辑元素和导体。 总共可以有6个逻辑元件和2个导体。 <br> 您可以想象一个以6为底的数字系统，并在每个类别中获取与元素相对应的数字。 因此，通过增加此十六进制数，您可以遍历元素的所有组合。 <br><br> 即，三位数的十六进制数将是3个元素。 仅值得考虑的是，可以传输的元素数不是6而是4。 <br><br> 为了释放这样一个数字，我确定了结构 <br><a name="ClampedInt"></a><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClampedInt { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = Mathf.Clamp(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, MaxValue); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampedInt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue</span></span></span><span class="hljs-function">)</span></span> { MaxValue = maxValue; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryIncrease</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;= MaxValue) { Value++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// overflow return true; } }</span></span></code> </pre> <br><a name="OverflowArray"></a><br> 接下来是一个具有奇怪名称<b>OverflowArray的类</b> 。 其本质是，它存储<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ClampedInt</a></b>数组并在<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">低位</a></b>发生溢出的情况下增加高位，依此类推，直到它在所有单元中都达到最大值。 <br><br> 根据每个ClampedInt，设置相应的ElectricalElementContainer的值。 因此，可以对所有可能的组合进行分类。 值得注意的是，如果要使用元素生成方案（例如，And（0）和Xor（4）），则无需对所有选项进行排序，包括元素1,2,3。 为此，在生成过程中，元素将获得其本地编号（例如，And = 0，Xor = 1），然后将它们转换回全局编号。 <br><br> 因此，您可以遍历所有元素中的所有可能组合。 <br><br> 设置容器中的值之后，使用<b>Solver</b>检查电路中是否有解决方案。 如果电路通过判决，则返回。 <br><br> 生成电路后，将检查解决方案的数量。 它不应超过限制，并且不应具有完全由0或1组成的决策。 <br><br><div class="spoiler">  <b class="spoiler_title">很多代码</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IVariantsGenerator</span></span> { <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;CircuitVariant&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;CircuitStructure&gt; structures, ICollection&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; availableGates, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> useNot, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxSolutions = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">.MaxValue</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">VariantsGenerator</span></span> : <span class="hljs-title"><span class="hljs-title">IVariantsGenerator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ISolver solver; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IElementsProvider elementsProvider; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VariantsGenerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISolver solver, IElementsProvider elementsProvider</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.solver = solver; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementsProvider = elementsProvider; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;CircuitVariant&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;CircuitStructure&gt; structures, ICollection&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; availableGates, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> useNot, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxSolutions = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">.MaxValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> manyGates = availableGates.Count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> availableLeToGeneralNumber = GetDictionaryFromAllowedElements(elementsProvider.Gates, availableGates); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gatesList = GetElementsList(availableLeToGeneralNumber, elementsProvider.Gates); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> availableConductorToGeneralNumber = useNot ? GetDictionaryFromAllowedElements(elementsProvider.Conductors, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}) : GetDictionaryFromAllowedElements(elementsProvider.Conductors, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {<span class="hljs-number"><span class="hljs-number">0</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conductorsList = GetElementsList(availableConductorToGeneralNumber, elementsProvider.Conductors); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> structure <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> structures) { InitializeCircuitStructure(structure, gatesList, conductorsList); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gates = GetListFromLayersDictionary(structure.Gates); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conductors = GetListFromLayersDictionary(structure.Conductors); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gatesArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OverflowArray(gates.Count, availableGates.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conductorsArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OverflowArray(conductors.Count, useNot ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useNot &amp;&amp; conductorsArray.EqualInts) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } SetContainerValuesAccordingToArray(conductors, conductorsArray); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (manyGates &amp;&amp; gatesArray.Length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; gatesArray.EqualInts) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } SetContainerValuesAccordingToArray(gates, gatesArray); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> solutions = solver.GetSolutions(structure.FinalDevice, structure.Sources); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (solutions.Any() &amp;&amp; solutions.Count &lt;= maxSolutions &amp;&amp; !(solutions.Any(s =&gt; s.All(b =&gt; b)) || solutions.Any(s =&gt; s.All(b =&gt; !b)))) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> variant = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CircuitVariant { Conductors = GetElementsNumberFromLayers(structure.Conductors, availableConductorToGeneralNumber), Gates = GetElementsNumberFromLayers(structure.Gates, availableLeToGeneralNumber), Solutions = solutions, Structure = structure }; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> variant; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!gatesArray.Increase()); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (useNot &amp;&amp; !conductorsArray.Increase()); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeCircuitStructure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CircuitStructure structure, IList&lt;Func&lt;IElectricalElement&gt;&gt; gates, IList&lt;Func&lt;IElectricalElement&gt;&gt; conductors</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lElements = GetListFromLayersDictionary(structure.Gates); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lElements) { item.SetElements(gates); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cElements = GetListFromLayersDictionary(structure.Conductors); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cElements) { item.SetElements(conductors); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IList&lt;Func&lt;IElectricalElement&gt;&gt; GetElementsList(IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; availableToGeneralGate, IReadOnlyList&lt;Func&lt;IElectricalElement&gt;&gt; elements) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Func&lt;IElectricalElement&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> availableToGeneralGate) { list.Add(elements[item.Value]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IDictionary&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDictionaryFromAllowedElements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IReadOnlyCollection&lt;Func&lt;IElectricalElement&gt;&gt; allElements, IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; availableElements</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enabledDic = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(allElements.Count); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; allElements.Count; i++) { enabledDic.Add(i, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> availableElements) { enabledDic[item] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> availableToGeneralNumber = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enabledDic) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item.Value) { availableToGeneralNumber.Add(index, item.Key); index++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> availableToGeneralNumber; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetContainerValuesAccordingToArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IReadOnlyList&lt;ElectricalElementContainer&gt; containers, IOverflowArray overflowArray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; containers.Count; i++) { containers[i].SetType(overflowArray[i].Value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IReadOnlyList&lt;ElectricalElementContainer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetListFromLayersDictionary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ElectricalElementContainer[]&gt; layers</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elements = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ElectricalElementContainer&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> layer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> layers) { elements.AddRange(layer.Value); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elements; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]&gt; GetElementsNumberFromLayers(IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, ElectricalElementContainer[]&gt; layers, IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; elementIdToGlobal = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dic = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]&gt;(layers.Count); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> convert = elementIdToGlobal != <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> layer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> layers) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[layer.Value.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; layer.Value.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!convert) { values[i] = layer.Value[i].SelectedType; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { values[i] = elementIdToGlobal[layer.Value[i].SelectedType]; } } dic.Add(layer.Key, values); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dic; } }</code> </pre> <br></div></div><br> 每个生成器都使用yield语句返回一个变体。 因此，使用StructureGenerator和VariantsGenerator的CircuitGenerator生成IEnumerable（具有收益率的方法在将来很有帮助，请参见下文）。 <br><br> 根据选项生成器接收结构列表这一事实。 您可以为每个结构独立生成选项。 这可以并行化，但是添加AsParallel不起作用（可能是产量干扰）。 手动并行化将花费很长时间，因为我们放弃了此选项。  <i>实际上，我尝试进行并行生成，但确实可行，但是存在一些困难，因为它没有进入存储库。</i> <br><br><a name="GameClasses"></a><h3> 游戏类 </h3><br><a name="Approach"></a><h4> 开发方法和DI </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目录内容</a> <br><br> 该项目是在<b>依赖注入</b> （DI）下构建的。 这意味着类可以简单地要求自己对应于该接口的某种对象，而无需参与创建该对象。 有什么好处： <br><br><ul><li> 依赖对象的创建和初始化位置定义在一个位置，并且与依赖类的逻辑分开，从而消除了代码重复。 </li><li> 无需挖掘整个依赖关系树并实例化所有依赖关系。 </li><li> 使您可以轻松更改在许多地方使用的接口的实现。 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://github.com/modesttree/Zenject">Zenject</a>作为项目中的DI容器使用。 <br><br>  Zenject有几个上下文，我仅使用其中两个： <br><br><ul><li> 项目上下文-整个应用程序中依赖项的注册。 </li><li> 场景上下文：仅在特定场景中存在的类的注册，其寿命受场景寿命的限制。 </li><li> 静态上下文是所有事物的通用上下文，其独特之处在于它存在于编辑器中。 我在编辑器中使用注入 </li></ul><br> 类注册存储在<b>Installer中</b> 。 我将<b>ScriptableObjectInstaller</b>用于项目上下文，将<b>MonoInstaller</b>用于场景上下文。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我在AsSingle中注册的大多数类，因为它们不包含状态，所以很可能只是方法的容器。我将AsTransient用于存在内部状态不应该为其他类所共有的类。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之后，您需要以某种方式创建将代表这些元素的MonoBehaviour类。我还根据Core项目将与Unity相关的类分配给一个单独的项目。</font></font><br><br><img src="https://habrastorage.org/webt/eg/s1/se/egs1seui5csmxylqk9we7qhedwc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于MonoBehaviour类，我更喜欢创建自己的接口。除了接口的标准优点之外，这还允许您隐藏大量的MonoBehaviour成员。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了方便起见，DI通常创建一个简单的类来运行所有逻辑，并为其提供MonoBehaviour包装器。</font><font style="vertical-align: inherit;">例如，该类具有Start和Update方法，我在该类中创建此类方法，然后在MonoBehaviour类中添加一个依赖项字段，并在相应的方法中称为Start和Update。</font><font style="vertical-align: inherit;">这为构造函数提供了“正确”的注入，使主类与DI容器分离，并且可以轻松进行测试。</font></font><br><br><a name="Config"></a><h4> 构型 </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过配置，我的意思是整个应用程序共有的数据。</font><font style="vertical-align: inherit;">就我而言，这些是预制件，广告和购买的标识符，标签，场景名称等。</font><font style="vertical-align: inherit;">为此，我使用ScriptableObjects：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 对于每个数据组，将分配一个ScriptableObject后代类。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 它创建必要的可序列化字段 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 添加了来自这些字段的读取属性。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 具有以上字段的界面将突出显示 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 类注册到DI容器中的接口 </font></font></li><li> 获利 </li></ol><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ITags</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FixedColor { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BackgroundColor { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ForegroundColor { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> AccentedColor { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } [CreateAssetMenu(fileName = <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(Tags), menuName = <span class="hljs-string"><span class="hljs-string">"Configuration/"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(Tags))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tags</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span>, <span class="hljs-title"><span class="hljs-title">ITags</span></span> { [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fixedColor; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> backgroundColor; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> foregroundColor; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> accentedColor; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FixedColor =&gt; fixedColor; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BackgroundColor =&gt; backgroundColor; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ForegroundColor =&gt; foregroundColor; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> AccentedColor =&gt; accentedColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { fixedColor.AssertNotEmpty(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(fixedColor)); backgroundColor.AssertNotEmpty(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(backgroundColor)); foregroundColor.AssertNotEmpty(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(foregroundColor)); accentedColor.AssertNotEmpty(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(accentedColor)); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 对于配置，使用单独的安装程序（代码缩写）： </font></font><br><br><pre> <code class="cs hljs">CreateAssetMenu(fileName = <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(ConfigurationInstaller), menuName = <span class="hljs-string"><span class="hljs-string">"Installers/"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(ConfigurationInstaller))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConfigurationInstaller</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObjectInstaller</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ConfigurationInstaller</span></span>&gt; { [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EditorElementsPrefabs editorElementsPrefabs; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LevelCompletionSteps levelCompletionSteps; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CommonValues commonValues; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> AdsConfiguration adsConfiguration; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CutscenesConfiguration cutscenesConfiguration; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Colors colors; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Tags tags; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstallBindings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container.Bind&lt;IEditorElementsPrefabs&gt;().FromInstance(editorElementsPrefabs).AsSingle(); Container.Bind&lt;ILevelCompletionSteps&gt;().FromInstance(levelCompletionSteps).AsSingle(); Container.Bind&lt;ICommonValues&gt;().FromInstance(commonValues).AsSingle(); Container.Bind&lt;IAdsConfiguration&gt;().FromInstance(adsConfiguration).AsSingle(); Container.Bind&lt;ICutscenesConfiguration&gt;().FromInstance(cutscenesConfiguration).AsSingle(); Container.Bind&lt;IColors&gt;().FromInstance(colors).AsSingle(); Container.Bind&lt;ITags&gt;().FromInstance(tags).AsSingle(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { editorElementsPrefabs.AssertNotNull(); levelCompletionSteps.AssertNotNull(); commonValues.AssertNotNull(); adsConfiguration.AssertNotNull(); cutscenesConfiguration.AssertNotNull(); colors.AssertNOTNull(); tags.AssertNotNull(); } }</code> </pre> <br><a name="GameElectricalElements"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 电气元件 </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在您需要以某种方式想象一下电气元件</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IElectricalElementMb</span></span> { GameObject GameObject { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } IElectricalElement Element { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } IOutputConnectorMb[] OutputConnectorsMb { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } IInputConnectorMb[] InputConnectorsMb { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } Transform Transform { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetInputConnectorsMb</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">InputConnectorMb[] inputConnectorsMb</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutputConnectorsMb</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OutputConnectorMb[] outputConnectorsMb</span></span></span><span class="hljs-function">)</span></span>; } [DisallowMultipleComponent] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ElectricalElementMb</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span>, <span class="hljs-title"><span class="hljs-title">IElectricalElementMb</span></span> { [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OutputConnectorMb[] outputConnectorsMb; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> InputConnectorMb[] inputConnectorsMb; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform Transform =&gt; transform; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject GameObject =&gt; gameObject; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; name; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> =&gt; name = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> IElectricalElement Element { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IOutputConnectorMb[] OutputConnectorsMb =&gt; outputConnectorsMb; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IInputConnectorMb[] InputConnectorsMb =&gt; inputConnectorsMb; }</code> </pre> <br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Provide additional data to be able to configure it after manual install. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public interface IElectricalElementMbEditor : IElectricalElementMb { ElectricalElementType Type { get; } } public class ElectricalElementMbEditor : ElectricalElementMb, IElectricalElementMbEditor { [SerializeField] private ElectricalElementType type; public ElectricalElementType Type =&gt; type; }</span></span></code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IInputConnectorMb</span></span> : <span class="hljs-title"><span class="hljs-title">IConnectorMb</span></span> { IOutputConnectorMb OutputConnectorMb { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } IInputConnector InputConnector { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">InputConnectorMb</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span>, <span class="hljs-title"><span class="hljs-title">IInputConnectorMb</span></span> { [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OutputConnectorMb outputConnectorMb; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform Transform =&gt; transform; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IOutputConnectorMb OutputConnectorMb { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; outputConnectorMb; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> =&gt; outputConnectorMb = (OutputConnectorMb) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IInputConnector InputConnector { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputConnector(); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR private void OnDrawGizmos() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (outputConnectorMb != null) { Handles.DrawLine(transform.position, outputConnectorMb.Transform.position); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有一行public IElectricalElement Element {get; </font><font style="vertical-align: inherit;">设置</font></font> } <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只有这里是如何安装此项目？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个不错的选择是使通用：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公共类ElectricalElementMb：MonoBehaviour，IElectricalElementMb其中T：IElectricalElement </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，要注意的是Unity在MonoBehavior类中不支持通用。</font><font style="vertical-align: inherit;">而且，Unity不支持属性和接口的序列化。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不过，在运行时，很有可能传入IElectricalElement Element {get; </font><font style="vertical-align: inherit;">设置</font></font> } <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">期望值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我做了枚举ElectricalElementType，其中将包含所有必需的类型。</font><font style="vertical-align: inherit;">Enum已由Unity很好地序列化，并在检查器中很好地显示为下拉列表。</font><font style="vertical-align: inherit;">定义了两种类型的元素：一种是在运行时创建的，另一种是在编辑器中创建的并且可以保存的。</font><font style="vertical-align: inherit;">因此，存在IElectricalElementMb和IElectricalElementMbEditor，它们另外包含类型为ElectricalElementType的字段。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二种类型也需要在运行时初始化。</font><font style="vertical-align: inherit;">为此，有一类在开始时将绕过所有元素并根据枚举字段中的类型对其进行初始化。</font><font style="vertical-align: inherit;">如下：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;ElectricalElementType, Func&lt;IElectricalElement&gt;&gt; ElementByType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;ElectricalElementType, Func&lt;IElectricalElement&gt;&gt; { {ElectricalElementType.And, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> And()}, {ElectricalElementType.Or, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Or()}, {ElectricalElementType.Xor, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Xor()}, {ElectricalElementType.Nand, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Nand()}, {ElectricalElementType.Nor, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Nor()}, {ElectricalElementType.NOT, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NOT()}, {ElectricalElementType.Xnor, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Xnor()}, {ElectricalElementType.Source, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Source()}, {ElectricalElementType.Conductor, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Conductor()}, {ElectricalElementType.Placeholder, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AlwaysFalse()}, {ElectricalElementType.Encoder, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Encoder()}, {ElectricalElementType.Decoder, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Decoder()} };</code> </pre> <br><a name="GameManagement"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 游戏管理 </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，出现一个问题，将游戏本身的逻辑放在哪里（检查段落的条件，计算段落的读数并帮助玩家）？..还有一些关于保存和加载进度，设置等内容的逻辑的位置的问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，我区分了负责某类任务的某些经理类。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DataManager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">负责根据传递用户和游戏设置的结果存储数据。它由AsSingle在项目上下文中注册。这意味着他是整个应用程序中的一员。在应用程序运行时，数据直接存储在DataManager内部的内存中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IFileStoreService</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它负责加载和保存数据以及</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IFileSerializer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">负责以现成的格式序列化文件以进行保存。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LevelGameManager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是单个场景中的游戏管理器。</font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我得到了一点GodObject，因为他仍然负责UI，即打开和关闭菜单以及对按钮的反应。但是，考虑到项目的规模以及无需扩展项目，这是可以接受的，因此操作序列更加简单，清晰。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两种选择。这就是分别</font><font style="vertical-align: inherit;">为模式1和2 </font><font style="vertical-align: inherit;">调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LevelGameManager1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LevelGameManager2的内容</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第一种情况下，逻辑基于对一个源中的值发生更改的反应，并检查电路输出端的值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第二种情况下，逻辑响应元素更改事件，并检查电路输出端的值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前有一些关卡信息，例如关卡号和玩家帮助。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关当前级别的数据存储在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CurrentLevelData中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。一个关卡号存储在其中-一个布尔属性，带有检查帮助，用于评估游戏的offer标志和用于帮助玩家的数据。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ICurrentLevelData</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LevelNumber { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HelpExist { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ProposeRate { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ICurrentLevelDataMode1</span></span> : <span class="hljs-title"><span class="hljs-title">ICurrentLevelData</span></span> { IEnumerable&lt;SourcePositionValueHelp&gt; PartialHelp { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ICurrentLevelDataMode2</span></span> : <span class="hljs-title"><span class="hljs-title">ICurrentLevelData</span></span> { IEnumerable&lt;PlaceTypeHelp&gt; PartialHelp { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一种模式的帮助是它们上的源编号和值。在第二种模式下，这是需要在单元格中设置的元素的类型。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集合包含存储必须在指定位置设置的位置和值的结构。字典会更漂亮，但是Unity无法序列化字典。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同模式的场景之间的差异在于，在场景的上下文中，设置了另一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LevelGameManager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和另一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICurrentLevelData</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总的来说，我有一种事件驱动的元素沟通方法。</font><font style="vertical-align: inherit;">一方面，这是合乎逻辑且方便的。</font><font style="vertical-align: inherit;">另一方面，有必要在不取消订阅的情况下解决问题。</font><font style="vertical-align: inherit;">不过，这个项目没有问题，规模也不算太大。</font><font style="vertical-align: inherit;">通常，订阅会在场景开始时针对您需要的所有内容进行。</font><font style="vertical-align: inherit;">在运行时几乎不会创建任何内容，因此不会造成混乱。</font></font><br><br><a name="LevelsLoading"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 水平加载 </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏中的每个关卡都由一个Unity场景表示，它必须包含一个关卡前缀和一个数字，例如“ Level23”。</font><font style="vertical-align: inherit;">前缀包含在配置中。</font><font style="vertical-align: inherit;">级别的加载按名称进行，该名称由前缀组成。</font><font style="vertical-align: inherit;">因此，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LevelsManager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">可以按数字加载级别。</font></font><br><br><a name="Cutscenes"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 过场动画 </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过场动画</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">的内容</font></a><font style="vertical-align: inherit;">是普通的统一场景，在标题中带有数字，与级别类似。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动画本身是使用时间轴实现的。</font><font style="vertical-align: inherit;">不幸的是，我既没有动画技能，也没有与时间轴合作的能力，所以“不要射击钢琴家，他会尽其所能。” </font></font><br><br><img src="https://habrastorage.org/webt/h8/ny/rf/h8nyrfwesvjp8v6kmy70tcfiduc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，一个逻辑过场动画应该由具有不同对象的不同场景组成。</font><font style="vertical-align: inherit;">事实证明，这有点迟了，但决定很简单：将过场动画的一部分放在舞台上的不同位置，然后立即移动摄像机。</font></font><br><br><img src="https://habrastorage.org/webt/s1/jq/jc/s1jqjces_osngyiexu03i3inrlk.png"><br><br><a name="AdditionalGameplay"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 额外的游戏玩法 </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏是通过每个级别的动作数和线索的使用来评估的。动作越少越好。使用工具提示可将最大评级降低为2星，而将级别降低为1星。为了评估通过，存储通过的步骤数。它由两个值组成：最小值（3星）和最大值（1星）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过级别的步骤数不存储在场景文件本身中，而是存储在配置文件中，因为您需要显示通过的级别的星数。这稍微增加了创建关卡的过程。看到版本控制系统中的更改特别有趣：</font></font><br><br><img src="https://habrastorage.org/webt/fl/uc/4q/fluc4q2iu7946a11fywzat8afck.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尝试猜测它属于哪个级别。当然，可以存储字典，但是首先它不会被Unity序列化，而第二个则必须手动设置数字。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果玩家难以完成关卡，他可以得到提示-一些输入的正确值，或第二模式下的正确元素。尽管它可以自动执行，但也可以手动完成。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果玩家的帮助没有帮助，他可以完全跳过该级别。万一缺少关卡，玩家将获得1星。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过提示的关卡的用户无法在一段时间内重新运行该关卡，因此很难以新鲜的内存重新运行该关卡，就像没有提示一样。</font></font><br><br><a name="Monetization"></a><h4> 营利 </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容游戏中</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两种获利类型：展示广告和为钱而禁用广告。广告显示包括在各个级别之间显示广告，以及查看奖励广告以跳过某个级别。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果玩家愿意为禁用广告付费，那么他可以这样做。在这种情况下，将不会显示级别之间以及跳过级别时的广告。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于广告，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了一个</font><font style="vertical-align: inherit;">名为</font><b><font style="vertical-align: inherit;">AdsService</font></b><font style="vertical-align: inherit;">的类</font><font style="vertical-align: inherit;">，并带有一个接口</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IAdsService</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AdsDisabled { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadBetweenLevelAd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowBetweenLevelAd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> force = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadHelpAd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action onLoaded = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowHelpAd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action onRewarded, Action onClosed</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HelpAdLoaded { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里的HelpAd是用于跳过级别的奖励广告。最初，我们将帮助称为部分和完全帮助。部分是提示，完全是跳过级别。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此类在首次启动游戏后便包含了按时间显示广告的频率的限制。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该实现使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Mobile Ads Unity插件</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过奖励性广告，我踩到了耙子-事实证明，可以在另一个线程中调用忠诚的代表，原因还不是很清楚。因此，最好是那些代表不要在与Unity相关的代码中调用任何东西。如果购买了禁用广告的广告，则不会显示该广告，并且代表将立即成功执行该广告的显示。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一个购物界面</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPurchaseService</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsAdsDisablePurchased { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action DisableAdsPurchased; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuyDisableAds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveDisableAd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在实现中使用了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity IAP</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是购买广告断开连接的技巧。</font><font style="vertical-align: inherit;">Google Play似乎没有提供有关玩家购买的信息。</font><font style="vertical-align: inherit;">只需确认一下她就通过了。</font><font style="vertical-align: inherit;">但是，如果您在购买后未</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正在等待中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">放置产品状态</font><b><font style="vertical-align: inherit;">，</font></b><font style="vertical-align: inherit;">这将使您可以检查</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasReceipt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">产品的属性</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果为真，则购买已完成。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管这当然会使这种方法感到困惑，但我怀疑这可能并不十分顺利。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试时需要RemoveDisableAd方法，它可以消除购买的广告中断。</font></font><br><br><a name="UI"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用者介面 </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有界面元素均按照面向事件的方法进行工作。</font><font style="vertical-align: inherit;">接口元素本身通常不包含除Unity可以使用的公共方法调用的事件以外的逻辑。</font><font style="vertical-align: inherit;">尽管它也恰好执行一些仅与接口有关的职责。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UiElementBase</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span>, <span class="hljs-title"><span class="hljs-title">IUiElement</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action ShowClick; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action HideCLick; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); ShowClick?.Invoke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Hide</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HideCLick?.Invoke(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PauseMenu</span></span> : <span class="hljs-title"><span class="hljs-title">UiElementEscapeClose</span></span>, <span class="hljs-title"><span class="hljs-title">IPauseMenu</span></span> { [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Text levelNumberText; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalizedText finishedText; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject restartButton; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> levelNumber; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action GoToMainMenuClick; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action RestartClick; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LevelNumber { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> =&gt; levelNumberText.text = <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{finishedText.Value}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisableRestartButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { restartButton.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GoToMainMenu</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GoToMainMenuClick?.Invoke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Restart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RestartClick?.Invoke(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，并非总是如此。</font><font style="vertical-align: inherit;">最好将这些元素保留为活动视图，从中创建事件侦听器，就像控制器一样，它将触发对管理者的必要操作。</font></font><br><br><a name="Analytics"></a><h4> 分析工具 </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在阻力最小的道路上，选择了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity分析</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。易于实施，尽管仅限于免费订阅-无法导出源数据。事件数也有限制-每位玩家每小时100个。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于分析，创建了包装类</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AnalyticsService</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它具有每种事件类型的方法，接收必要的参数，并使用Unity内置的工具发送事件。从整体上来说，为每个事件创建方法当然不是最佳实践，但是在一个已知的小项目中，这比做大而复杂的事情要好。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用的所有事件均为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomEvent。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它们是根据事件的名称以及字典参数的名称和值构建的。</font><font style="vertical-align: inherit;">AnalyticsService从参数中获取所需的值，并在其中创建字典。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有事件名称和参数都放在常量中。</font><font style="vertical-align: inherit;">不能采用ScriptableObject的传统方法的形式，因为这些值永远都不应更改。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法示例：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LevelComplete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stars, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> actionCount, TimeSpan timeSpent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> levelMode</span></span></span><span class="hljs-function">)</span></span> { CustomEvent(LevelCompleteEventName, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; { {LevelNumber, number}, {LevelStars, stars}, {LevelActionCount, actionCount}, {LevelTimeSpent, timeSpent}, {LevelMode, levelMode} }); }</code> </pre> <br><a name="CameraAlign"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 相机位置和图表 </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任务是将FinalDevice放置在屏幕顶部，与上边框的距离相同，而Sources与底部的距离也始终与下边框相等。</font><font style="vertical-align: inherit;">此外，屏幕的纵横比不同，您需要在启动水平仪之前调整摄像机的尺寸，以使其正确适合电路。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了</font><b><font style="vertical-align: inherit;">CameraAlign</font></b><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">尺寸算法：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在舞台上找到所有必要的元素 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 根据宽高比找到最小宽度和高度 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 确定相机尺寸 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将相机置于中央 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将FinalDevice移到屏幕顶部 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将源移到屏幕底部 </font></font></li></ol><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CameraAlign</span></span> : <span class="hljs-title"><span class="hljs-title">ICameraAlign</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ISceneObjectsHelper sceneObjectsHelper; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ICommonValues commonValues; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CameraAlign</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISceneObjectsHelper sceneObjectsHelper, ICommonValues commonValues</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sceneObjectsHelper = sceneObjectsHelper; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.commonValues = commonValues; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Align</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Camera camera</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elements = sceneObjectsHelper.FindObjectsOfType&lt;IElectricalElementMb&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalDevice = sceneObjectsHelper.FindObjectOfType&lt;IFinalDevice&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sources = elements.OfType&lt;ISourceMb&gt;().ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (finalDevice != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; sources.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> leftPos = elements.Min(s =&gt; s.Transform.position.x); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rightPos = elements.Max(s =&gt; s.Transform.position.x); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> width = Mathf.Abs(leftPos - rightPos); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fPos = finalDevice.Transform.position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height = Mathf.Abs(sources.First().Transform.position.y - fPos.y) * camera.aspect; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> size = Mathf.Max(width * commonValues.CameraOffset, height * commonValues.CameraOffset); camera.orthographicSize = Mathf.Clamp(size, commonValues.MinCameraSize, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.MaxValue); camera.transform.position = GetCenterPoint(elements, <span class="hljs-number"><span class="hljs-number">-1</span></span>); fPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(fPos.x, camera.ScreenToWorldPoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(Screen.width, Screen.height)).y - commonValues.FinalDeviceTopOffset * camera.orthographicSize); finalDevice.Transform.position = fPos; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sourceY = camera.ScreenToWorldPoint(Vector2.zero).y + commonValues.SourcesBottomOffset; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sources) { item.Transform.position = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(item.Transform.position.x, sourceY); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.Log(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(CameraAlign)}</span></span></span><span class="hljs-string">: No final device or no sources in scene"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCenterPoint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ICollection&lt;IElectricalElementMb&gt; elements, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> top = elements.Max(e =&gt; e.Transform.position.y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottom = elements.Min(e =&gt; e.Transform.position.y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> left = elements.Min(e =&gt; e.Transform.position.x); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> right = elements.Max(e =&gt; e.Transform.position.x); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = left + ((right - left) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = bottom + ((top - bottom) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(x, y, z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 当场景在包装类中启动时，将调用此方法。 </font></font><br><br><a name="Colors"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 配色方案 </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于游戏将具有非常原始的界面，因此我决定使用黑白两种配色方案进行制作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，创建了一个界面</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IColors</span></span> { Color ColorAccent { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } Color Background { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } Color Foreground { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action ColorsChanged; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以直接在Unity编辑器中设置颜色；该颜色可用于测试。然后可以将它们切换为两种颜色。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景和前景颜色可以更改，在任何模式下都可以改变一种颜色。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于播放器可以设置非标准主题，因此颜色数据必须存储在设置文件中。如果设置文件不包含颜色数据，则将使用标准值填充它们。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后有几个类：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CameraColorAdjustment-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">负责设置相机的背景色，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UiColorAdjustment-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置界面元素和</font><b><font style="vertical-align: inherit;">TextMeshColorAdjustment</font></b><font style="vertical-align: inherit;">的颜色</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-设置来源上数字的颜色。</font><font style="vertical-align: inherit;">UiColorAdjustment也使用标签。</font><font style="vertical-align: inherit;">在编辑器中，可以用标记标记每个元素，该标记将指示应设置的颜色类型（背景，前景，AccentColor和FixedColor）。</font><font style="vertical-align: inherit;">全部设置在场景开始时或通过更改配色方案来设置。</font></font><br><br> 结果： <br><br><img src="https://habrastorage.org/webt/jk/6o/zz/jk6ozzdaz6h8ixxrykmnocrtgze.png"><br><br><img src="https://habrastorage.org/webt/kl/4d/u6/kl4du6hxim70hyncofiakaiqsi4.png"><br><br><a name="Editor"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 编辑器扩展 </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了简化和加快开发过程，通常需要创建正确的工具，而标准编辑器工具没有提供该工具。</font><font style="vertical-align: inherit;">Unity中的传统方法是创建一个EditorWindow后代类。</font><font style="vertical-align: inherit;">UiElements也有一种方法，但是它仍在开发中，因此我决定使用传统方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您仅创建一个使用UnityEditor命名空间中某些内容的类，然后在游戏的其他类旁边使用该类，则该项目将不会被汇编，因为该命名空间在构建中不可用。</font><font style="vertical-align: inherit;">有几种解决方案：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为编辑器脚本选择一个单独的项目 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将文件放在Assets / Editor文件夹中 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将这些文件包装在#if UNITY_EDITOR中 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目使用第一种方法，有时使用#if UNITY_EDITOR，如有必要，将编辑器的一小部分添加到构建所需的类中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我在程序集中定义的编辑器中仅需要的所有类，这些类仅在编辑器中可用。</font><font style="vertical-align: inherit;">她不会去玩游戏。</font></font><br><br><img src="https://habrastorage.org/webt/-u/yv/ie/-uyviepp1z3u4aal0mgbzlothxg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在在您的编辑器扩展中添加DI会很好。</font><font style="vertical-align: inherit;">为此，我使用Zenject.StaticContext。</font><font style="vertical-align: inherit;">为了在编辑器中进行设置，使用了带有InitializeOnLoad属性的类，该类中有一个静态构造函数。</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">InitializeOnLoad</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EditorInstaller</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditorInstaller</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = StaticContext.Container; container.Bind&lt;IElementsProvider&gt;().To&lt;ElementsProvider&gt;().AsSingle(); container.Bind&lt;ISolver&gt;().To&lt;Solver&gt;().AsSingle(); .... } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为了在静态上下文中注册ScriptableObject类，我使用以下代码： </font></font><br><br><pre> <code class="cs hljs">BindFirstScriptableObject&lt;ISceneNameConfiguration, SceneNameConfiguration&gt;(container); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BindFirstScriptableObject&lt;TInterface, TImplementation&gt;(DiContainer container) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TImplementation : ScriptableObject, TInterface { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = GetFirstScriptableObject&lt;TImplementation&gt;(); container.Bind&lt;TInterface&gt;().FromInstance(obj).AsSingle(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T GetFirstScriptableObject&lt;T&gt;() <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : ScriptableObject { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> guids = AssetDatabase.FindAssets(<span class="hljs-string"><span class="hljs-string">"t:"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).Name); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = AssetDatabase.GUIDToAssetPath(guids.First()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = AssetDatabase.LoadAssetAtPath&lt;T&gt;(path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅此行要求TImplementation AssetDatabase.LoadAssetAtPath（路径）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无法向构造函数</font><font style="vertical-align: inherit;">添加</font><font style="vertical-align: inherit;">依赖项。</font><font style="vertical-align: inherit;">而是将[Inject]属性添加到窗口类中的依赖项字段，并在窗口</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动时</font><font style="vertical-align: inherit;">调用</font><font style="vertical-align: inherit;">StaticContext.Container.Inject（this）；</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我还建议向窗口更新周期中添加对相关字段之一的空检查，如果该字段为空，请执行上面的行。</font><font style="vertical-align: inherit;">因为更改项目中的代码后，Unity可以重新创建窗口，而无需在其上调用Awake。</font></font><br><br><a name="GeneratorWindow"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 发电机组 </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录</font></font></a> <br><br><img src="https://habrastorage.org/webt/4i/cp/ud/4icpudizv2-8r-bwrbkk3bva8kq.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成器</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">的</font></a><font style="vertical-align: inherit;">初始视图，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该窗口应提供一个界面以生成带参数的方案列表，显示方案列表并将所选方案放置在当前场景上。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该窗口从左到右包括三个部分：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 世代设定 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 按钮形式的选项列表 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 选择的选项作为文本 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用EditorGUILayout.BeginVertical（）和EditorGUILayout.EndVertical（）创建列。不幸的是，它不能用来固定和限制大小，但这并不是那么关键。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，大量电路的生成过程并不那么快。使用I的元素可获得很多组合。如剖析器所示，最慢的部分是电路本身。并行化不是一个选项；所有选项都使用一种方案，但是很难克隆该结构。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，我认为编辑器扩展的所有代码都可能在Debug模式下工作。在“发行版”下，调试效果不佳，断点无法停止，行被跳过等。确实，在测量了性能之后，事实证明，Unity中生成器的速度与从控制台应用程序启动的Debug程序集相对应，它的速度比Release慢6倍。</font></font>请记住这一点。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或者，您可以进行外部组装，并随该组装一起添加到Unity DLL中，但这会使组装和项目编辑变得非常复杂。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">立即将生成过程放入一个包含以下代码的单独Task中：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">circuitGenerator.Generate（行，maxElementsInLine，availableLogicalElements，useNOT，modification）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是仍然有必要等待很长时间，几分钟（在大型电路上超过20分钟）。</font><font style="vertical-align: inherit;">另外，存在一个问题，即任务无法如此轻松地完成，并且一直持续到生成完成为止。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很多代码</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Ext</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IEnumerable&lt;CircuitVariant&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OrderVariants</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IEnumerable&lt;CircuitVariant&gt; circuitVariants</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> circuitVariants.OrderBy(a =&gt; a.Solutions.Count()) .ThenByDescending(a =&gt; a.Solutions .Select(b =&gt; b.Sum(i =&gt; i ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">-1</span></span>)) .OrderByDescending(b=&gt;b) .First()); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IEditorGenerator</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { CircuitVariant[] FilteredVariants { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LastPage { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FilterVariants</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> page</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lines, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxElementsInLine, ICollection&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; availableGates, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> useNOT, StructureModification? modification, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxSolutions</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EditorGenerator</span></span> : <span class="hljs-title"><span class="hljs-title">IEditorGenerator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PageSize = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ICircuitGenerator circuitGenerator; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ConcurrentBag&lt;CircuitVariant&gt; variants; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CircuitVariant&gt; sortedVariants; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Thread generatingThread; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditorGenerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ICircuitGenerator circuitGenerator</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.circuitGenerator = circuitGenerator; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { generatingThread?.Abort(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CircuitVariant[] FilteredVariants { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LastPage { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FilterVariants</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> page</span></span></span><span class="hljs-function">)</span></span> { CheckVariants(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sortedVariants == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Fetch(); } FilteredVariants = sortedVariants.Skip(page * PageSize) .Take(PageSize) .ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = sortedVariants.Count; LastPage = count % PageSize == <span class="hljs-number"><span class="hljs-number">0</span></span> ? (count / PageSize) - <span class="hljs-number"><span class="hljs-number">1</span></span> : count / PageSize; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CheckVariants(); sortedVariants = variants.OrderVariants() .ToList(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lines, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxElementsInLine, ICollection&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; availableGates, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> useNOT, StructureModification? modification, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxSolutions</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generatingThread != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Stop(); } variants = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentBag&lt;CircuitVariant&gt;(); generatingThread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = circuitGenerator.Generate(lines, maxElementsInLine, availableGates, useNOT, modification, maxSolutions); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v) { variants.Add(item); } }); generatingThread.Start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { generatingThread?.Abort(); sortedVariants = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; variants = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; generatingThread = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; FilteredVariants = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckVariants</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (variants == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"VariantsGeneration is not started. Use Start before."</span></span>); } } ~EditorGenerator() { generatingThread.Abort(); } }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">想法是应生成背景，并应要求更新排序选项的内部列表。然后，您可以逐页选择选项。因此，无需每次都进行排序，这大大加快了大型列表的工作。方案按“有趣程度”分类：按解决方案的数量，增加的数量以及解决方案要求各种值的方式。也就是说，解为1 1 1 1的电路比1 0 1 1有趣。</font></font><br><br><img src="https://habrastorage.org/webt/mr/ud/aa/mrudaajqtmoetizlrvzd1muja4q.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，事实证明，无需等待生成结束，就已经为该电平选择了电路。另一个优点是，由于分页，编辑器不会像牛一样放慢速度。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity功能非常令人不安，因为当您单击“播放”时，窗口的内容会像所有生成的数据一样被重置。</font><font style="vertical-align: inherit;">如果它们易于序列化，则可以将它们存储为文件。</font><font style="vertical-align: inherit;">这样，您甚至可以缓存生成的结果。</font><font style="vertical-align: inherit;">但是，遗憾的是，很难序列化对象之间相互引用的复杂结构。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，我在每个门上都添加了行</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.Length == <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Input[<span class="hljs-number"><span class="hljs-number">0</span></span>].Value &amp;&amp; Input[<span class="hljs-number"><span class="hljs-number">1</span></span>].Value; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 从而大大提高了性能。 </font></font><br><br><a name="SolverWindow"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 解算器 </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在编辑器中组装电路时，您需要能够快速了解​​它是否正在解决以及有多少解决方案。</font><font style="vertical-align: inherit;">为此，我创建了一个“求解器”窗口。</font><font style="vertical-align: inherit;">它以文本形式提供当前方案的解决方案</font></font><br><br><img src="https://habrastorage.org/webt/k4/4e/pk/k44epkd08ngv_gh2rpejtr6jzkg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其“后端”的逻辑是：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSourcesLabel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sourcesMb = sceneObjectsHelper.FindObjectsOfType&lt;SourceMb&gt;().OrderBy(s =&gt; s.name); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sourcesLabelSb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sourcesMb) { sourcesLabelSb.Append(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item.name.Replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"Source"</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"Src"</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">\t"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sourcesLabelSb.ToString(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[]&gt; FindSolutions() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementsMb = sceneObjectsHelper.FindObjectsOfType&lt;IElectricalElementMbEditor&gt;(); elementsConfigurator.Configure(elementsMb); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = sceneObjectsHelper.FindObjectOfType&lt;FinalDevice&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"No final device in scene"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sourcesMb = sceneObjectsHelper.FindObjectsOfType&lt;SourceMb&gt;().OrderBy(s =&gt; s.name); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sources = sourcesMb.Select(mb =&gt; (Source) mb.Element).ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> solver.GetSolutions(root.Element, sources); }</code> </pre> <br><a name="Useful"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 有用的 </font></font></h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录内容</font></font></a> <br><br><a name="AssertHelper"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 断言帮助 </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了验证值是否在资产中设置，我使用在OnEnable中调用的扩展方法</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AssertHelper</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssertType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IElectricalElementMbEditor elementMbEditor, ElectricalElementType expectedType</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elementMbEditor.Type != expectedType) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">$"Field for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{expectedType}</span></span></span><span class="hljs-string"> require element with such type, but given element is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{elementMbEditor.Type}</span></span></span><span class="hljs-string">"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AssertNOTNull&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T obj, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fieldName = <span class="hljs-string"><span class="hljs-string">""</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(fieldName)) { fieldName = <span class="hljs-string"><span class="hljs-string">$"of type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(T).Name}</span></span></span><span class="hljs-string">"</span></span>; } Debug.LogError(<span class="hljs-string"><span class="hljs-string">$"Field </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{fieldName}</span></span></span><span class="hljs-string"> is not installed"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssertNOTEmpty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fieldName = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(str)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">$"Field </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{fieldName}</span></span></span><span class="hljs-string"> is not installed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssertSceneCanBeLoaded</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Application.CanStreamedLevelBeLoaded(name)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">$"Scene </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{name}</span></span></span><span class="hljs-string"> can't be loaded."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管可以加载场景，但有时无法验证场景是否具有加载能力。</font><font style="vertical-align: inherit;">也许这是Unity中的错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用示例：</font></font><br><br><pre> <code class="cs hljs">mainMenuSceneName.AssertNOTEmpty(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(mainMenuSceneName)).AssertSceneCanBeLoaded(); levelNamePrefix.AssertNOTEmpty(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(levelNamePrefix)); editorElementsPrefabs.AssertNOTNull(); not.AssertType(ElectricalElementType.NOT); <span class="hljs-comment"><span class="hljs-comment">//     enum    </span></span></code> </pre> <br><a name="SceneObjectsHelper"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SceneObjectsHelper </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要使用场景元素，SceneObjectsHelper类也很有用：</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很多代码</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Circuit.Game.Utility</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISceneObjectsHelper</span></span> { T[] FindObjectsOfType&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeDisabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>; T FindObjectOfType&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeDisabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>; T Instantiate&lt;T&gt;(T prefab) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Object; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DestroyObjectsOfType&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeDisabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> immediate = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Destroy&lt;T&gt;(T obj, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> immediate = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Object; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyAllChildren</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform transform</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span>; T GetComponent&lt;T&gt;(GameObject obj) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SceneObjectsHelper</span></span> : <span class="hljs-title"><span class="hljs-title">ISceneObjectsHelper</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> DiContainer diContainer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SceneObjectsHelper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DiContainer diContainer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.diContainer = diContainer; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T GetComponent&lt;T&gt;(GameObject obj) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.GetComponents&lt;Component&gt;().OfType&lt;T&gt;().FirstOrDefault(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T[] FindObjectsOfType&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeDisabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (includeDisabled) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Resources.FindObjectsOfTypeAll(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Object)).OfType&lt;T&gt;().ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.FindObjectsOfType&lt;Component&gt;().OfType&lt;T&gt;().ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DestroyObjectsOfType&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeDisabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> immediate = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objects = includeDisabled ? Resources.FindObjectsOfTypeAll(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Object)).OfType&lt;T&gt;().ToArray() : Object.FindObjectsOfType&lt;Component&gt;().OfType&lt;T&gt;().ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> objects) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (immediate) { Object.DestroyImmediate((item <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Component)?.gameObject); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Object.Destroy((item <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Component)?.gameObject); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Destroy&lt;T&gt;(T obj, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> immediate = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Object { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (immediate) { Object.DestroyImmediate(obj); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Object.Destroy(obj); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyAllChildren</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform transform</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> childCount = transform.childCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; childCount; i++) { Destroy(transform.GetChild(i).gameObject); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T FindObjectOfType&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeDisabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (includeDisabled) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Resources.FindObjectsOfTypeAll(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Object)).OfType&lt;T&gt;().FirstOrDefault(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.FindObjectsOfType&lt;Component&gt;().OfType&lt;T&gt;().FirstOrDefault(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { diContainer.Inject(obj); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Instantiate&lt;T&gt;(T prefab) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Object { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = Object.Instantiate(prefab); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Component) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> components = ((Component) (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) obj).gameObject.GetComponents&lt;Component&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> components) { Inject(component); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Inject(obj); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; } } }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，在需要高性能的地方有些事情可能不是很有效，但是很少有人要求我这样做，并且不会产生任何影响。</font><font style="vertical-align: inherit;">但是它们允许您通过界面来查找对象，例如，看起来很漂亮。</font></font><br><br><a name="CoroutineStarter"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 协程启动器 </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发布协程只能具有MonoBehaviour。</font><font style="vertical-align: inherit;">因此，我创建了CoroutineStarter类，并将其注册到场景的上下文中。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ICoroutineStarter</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginCoroutine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerator routine</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CoroutineStarter</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span>, <span class="hljs-title"><span class="hljs-title">ICoroutineStarter</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginCoroutine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerator routine</span></span></span><span class="hljs-function">)</span></span> { StartCoroutine(routine); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了方便之外，此类工具的引入使自动测试变得更加容易。</font><font style="vertical-align: inherit;">例如，在测试中执行协程：</font></font><br><br><pre> <code class="cs hljs">coroutineStarter.When(x =&gt; x.BeginCoroutine(Arg.Any&lt;IEnumerator&gt;())).Do(info =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = (IEnumerator) info[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (a.MoveNext()) { } });</code> </pre> <br><a name="Gizmo"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 小发明 </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了方便显示不可见元素，建议您使用仅在场景中可见的Gizmo图片。</font><font style="vertical-align: inherit;">它们使您只需单击即可轻松选择不可见的元素。</font><font style="vertical-align: inherit;">还以线的形式进行元素的连接：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outputConnectorMb != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Handles.DrawLine(transform.position, outputConnectorMb.Transform.position); } }</code> </pre> <br><img src="https://habrastorage.org/webt/ta/ce/d5/taced5wyeyhwkpj5vtiuvauu68s.png"><br><br><a name="Testing"></a><h3> 测试中 </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我想从自动测试中获得最大的收益，因为在可能且易于使用的地方都使用了测试。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于单元测试，习惯上使用模拟对象而不是实现测试类所依赖的接口的类。为此，我使用了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NSubstitute</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库</font><font style="vertical-align: inherit;">。什么很高兴。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity不支持NuGet，因此我必须单独获取DLL，然后将程序集作为依赖项添加到AssemblyDefinition文件中，并且可以正常使用。</font></font><br><br><img src="https://habrastorage.org/webt/y-/bh/sp/y-bhsprsfvxo-j9javgdhdzzhig.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于自动测试，Unity提供了TestRunner，它可以与非常流行的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUnit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试框架一起使用</font><font style="vertical-align: inherit;">。从TestRunner的角度来看，有两种类型的测试：</font></font><br><br><ul><li> EditMode —     ,   .    Nunit .    ,    .        GameObject  Monobehaviour .   ,     EditMode . </li><li> PlayMode —     .    </li></ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编辑模式以我的经验，这种模式会带来许多不便和奇怪的行为。但是，它们很方便地自动检查整个应用程序的运行状况。它们还为诸如Start，Update之类的方法中的代码提供诚实的验证。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayMode测试可以描述为正常的NUnit测试，但是还有另一种选择。在播放模式下，您可能需要等待一段时间或一定数量的帧。为此，必须以类似于协程的方式描述测试。返回的值应该是IEnumerator / IEnumerable，并且在里面，要跳过时间，必须使用例如：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre> <br> 或 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有其他返回值。</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样的测试需要设置</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnityTest</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">只要有属性</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnitySetUp UnityTearDown和谁在一起，你要使用类似的方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反过来，我将共享用于模块化和集成的EditMode测试。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单元测试仅测试一个类，使其与其他类完全隔离。</font><font style="vertical-align: inherit;">这样的测试通常可以更轻松地为测试的类准备环境，而错误通过后，可以使您更准确地定位问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在单元测试中，我测试了许多Core类以及游戏中直接需要的类。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电路元件测试非常相似，因此我创建了一个基类</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ElectricalElementTestsBase</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TElement</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TElement</span></span> : <span class="hljs-title"><span class="hljs-title">ElectricalElementBase</span></span>, <span class="hljs-title"><span class="hljs-title">IElectricalElement</span></span>, <span class="hljs-title"><span class="hljs-title">new</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> TElement element; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> IInputConnector mInput1; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> IInputConnector mInput2; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> IInputConnector mInput3; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> IInputConnector mInput4; [OneTimeSetUp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { element = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TElement(); mInput1 = Substitute.For&lt;IInputConnector&gt;(); mInput2 = Substitute.For&lt;IInputConnector&gt;(); mInput3 = Substitute.For&lt;IInputConnector&gt;(); mInput4 = Substitute.For&lt;IInputConnector&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue_3Input</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> expectedOutput</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// arrange mInput1.Value.Returns(input1); mInput2.Value.Returns(input2); mInput3.Value.Returns(input3); element.Input = new[] {mInput1, mInput2, mInput3}; // act bool result = element.GetValue(); // assert Assert.AreEqual(expectedOutput, result); } protected void GetValue_2Input(bool input1, bool input2, bool expectedOutput) { // arrange mInput1.Value.Returns(input1); mInput2.Value.Returns(input2); element.Input = new[] {mInput1, mInput2}; // act bool result = element.GetValue(); // assert Assert.AreEqual(expectedOutput, result); } protected void GetValue_1Input(bool input, bool expectedOutput) { // arrange mInput1.Value.Returns(input); element.Input = new[] {mInput1}; // act bool result = element.GetValue(); // assert Assert.AreEqual(expectedOutput, result); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 进一步的元素测试如下所示： </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AndTests</span></span> : <span class="hljs-title"><span class="hljs-title">ElectricalElementTestsBase</span></span>&lt;<span class="hljs-title"><span class="hljs-title">And</span></span>&gt; { [TestCase(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] [TestCase(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] [TestCase(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] [TestCase(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> new </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue_2Input</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> output</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.GetValue_2Input(input1, input2, output); } [TestCase(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] [TestCase(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> new </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue_1Input</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> expectedOutput</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.GetValue_1Input(input, expectedOutput); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从易于理解的角度来看，这可能是一个复杂的问题，通常在测试中没有必要，但是我不想将同一件事复制粘贴11次。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也有GameManagers的测试。</font><font style="vertical-align: inherit;">由于它们有很多共同点，因此它们也具有测试的基类。</font><font style="vertical-align: inherit;">两种模式下的游戏管理器应具有相同的功能，但应具有不同的功能。</font><font style="vertical-align: inherit;">对于每个后继者，将使用相同的测试来测试常规事物，并且还会测试特定的行为。</font><font style="vertical-align: inherit;">尽管采用了事件方法，但是测试事件执行的行为并不困难：</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FullHelpAgree_FinishLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// arrange levelGameManager.Start(); helpMenu.ClearReceivedCalls(); dataManager.ClearReceivedCalls(); // act helpMenu.FullHelpClick += Raise.Event&lt;Action&gt;(); fullHelpWindow.Agreed += Raise.Event&lt;Action&lt;bool&gt;&gt;(true); // assert dataManager.Received().SaveGame(); helpMenu.Received().Hide(); } [Test] public void ChangeSource_RootOutBecomeTrue_SavesGameOpensMenu() { // arrange currentLevelData.IsTestLevel.Returns(false); rootOutputMb.OutputConnector.Value.Returns(true); // act levelGameManager.Start(); levelFinishedMenu.ClearReceivedCalls(); dataManager.ClearReceivedCalls(); source.ValueChanged += Raise.Event&lt;Action&lt;bool&gt;&gt;(true); // assert dataManager.Received().SaveGame(); levelFinishedMenu.Received().Show(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在集成测试中，我还测试了编辑器的类，并从DI容器的静态上下文中获取了它们。</font><font style="vertical-align: inherit;">因此，检查包括正确的注射，这与单元测试同样重要。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlacerTests</span></span> { [Inject] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ICircuitEditorPlacer circuitEditorPlacer; [Inject] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ICircuitGenerator circuitGenerator; [Inject] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEditorSolver solver; [Inject] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ISceneObjectsHelper sceneObjectsHelper; [TearDown] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TearDown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { sceneObjectsHelper.DestroyObjectsOfType&lt;IElectricalElementMb&gt;(immediate: <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } [OneTimeSetUp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = StaticContext.Container; container.Inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } [TestCase(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)] [TestCase(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)] [TestCase(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlaceSolve_And_NoModifications_AllVariantsSolved</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lines, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elementsInLine</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> variants = circuitGenerator.Generate(lines, elementsInLine, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; {<span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> variant <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> variants) { circuitEditorPlacer.PlaceCircuit(variant); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> solutions = solver.FindSolutions(); CollectionAssert.IsNOTEmpty(solutions); } } [TestCase(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, StructureModification.Branching)] [TestCase(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, StructureModification.ThroughLayer)] [TestCase(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, StructureModification.All)] [TestCase(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, StructureModification.Branching)] [TestCase(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, StructureModification.ThroughLayer)] [TestCase(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, StructureModification.All)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlaceSolve_And_Modifications_AllVariantsSolved</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lines, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elementsInLine, StructureModification modification</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> variants = circuitGenerator.Generate(lines, elementsInLine, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; {<span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, modification); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> variant <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> variants) { circuitEditorPlacer.PlaceCircuit(variant); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> solutions = solver.FindSolutions(); CollectionAssert.IsNOTEmpty(solutions); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该测试使用所有依赖项的真实实现，并在舞台上设置对象，这在EditMode测试中是很可能的。测试它确实使它们理智是正确的-我几乎不知道如何做，所以我检查发布的电路是否有解决方案。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在集成中，还对CircuitGenerator（StructureGenerator + VariantsGenerator）和Solver进行测试</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CircuitGeneratorTests</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ICircuitGenerator circuitGenerator; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ISolver solver; [SetUp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { solver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Solver(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gates = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Func&lt;IElectricalElement&gt;&gt; { () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> And(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Or(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Xor() }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conductors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Func&lt;IElectricalElement&gt;&gt; { () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Conductor(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Not() }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elements = Substitute.For&lt;IElementsProvider&gt;(); elements.Conductors.Returns(conductors); elements.Gates.Returns(gates); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> structGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StructureGenerator(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> variantsGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VariantsGenerator(solver, elements); circuitGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CircuitGenerator(structGenerator, variantsGenerator); } [Test] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generate_2l_2max_ReturnsVariants</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// act var variants = circuitGenerator.Generate(2, 2, new[] {0, 1, 2}, false).ToArray(); // assert Assert.True(variants.Any()); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Nand)); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Nor)); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Xnor)); AssertLayersNotContains(variants.First().Structure.Conductors, typeof(Not)); AssertLayersContains(variants.First().Structure.Gates, typeof(Or)); AssertLayersContains(variants.First().Structure.Gates, typeof(Xor)); AssertLayersContains(variants.First().Structure.Conductors, typeof(Conductor)); } [Test] public void Generate_2l_2max_RestrictedElementsWithConductors() { // arrange var available = new[] {0}; // act var variants = circuitGenerator.Generate(2, 2, available, true).ToArray(); // assert Assert.True(variants.Any()); var lElements = new List&lt;int&gt;(); var layers = variants.Select(v =&gt; v.Gates); foreach (var layer in layers) { foreach (var item in layer.Values) { lElements.AddRange(item); } } Assert.True(lElements.Contains(0)); Assert.False(lElements.Contains(1)); Assert.False(lElements.Contains(2)); AssertLayersContains(variants.First().Structure.Gates, typeof(And)); AssertLayersContains(variants.First().Structure.Conductors, typeof(Conductor)); AssertLayersContains(variants.First().Structure.Conductors, typeof(Not)); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Nand)); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Or)); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Nor)); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Xnor)); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Xor)); } private static void AssertLayersContains(IDictionary&lt;int, ElectricalElementContainer[]&gt; layers, Type elementType) { AssertLayersContains(layers, elementType, true); } private static void AssertLayersNotContains(IDictionary&lt;int, ElectricalElementContainer[]&gt; layers, Type elementType) { AssertLayersContains(layers, elementType, false); } private static void AssertLayersContains(IDictionary&lt;int, ElectricalElementContainer[]&gt; layers, Type elementType, bool shouldContain) { bool contains = false; foreach (var layer in layers) { foreach (var item in layer.Value) { contains |= item.Elements.Select(e =&gt; e.GetType()).Contains(elementType); } } Assert.AreEqual(shouldContain, contains); } } }</span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayMode测试用作系统测试。他们检查预制件，注射剂等。一个好的选择是使用现成的场景，其中测试仅加载并产生一些交互。但是我使用准备好的空白场景进行测试，其中的环境不同于游戏中的环境。曾经尝试使用PlayMode测试整个游戏过程，例如进入菜单，进入关卡等等，但是这些测试的工作结果很不稳定，因此决定将其推迟（以后再也不做）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用覆盖率评估工具编写测试很方便，但不幸的是，我还没有找到任何可与Unity配合使用的解决方案。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我发现一个问题，因为将Unity升级到2018.3，测试开始工作的速度慢得多，最多慢了10倍（在一个综合示例中）。</font><font style="vertical-align: inherit;">该项目包含288个EditMode测试，这些测试运行11秒钟，尽管到目前为止没有进行任何操作。</font></font><br><br><a name="Resume"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 发展总结 </font></font></h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a> <br><br><img src="https://habrastorage.org/webt/kl/4d/u6/kl4du6hxim70hyncofiakaiqsi4.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏级别的屏幕快照</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无论平台如何，都可以制定某些游戏</font><i><font style="vertical-align: inherit;">的</font></i><font style="vertical-align: inherit;">逻辑。在早期阶段，这可以通过自动测试简化开发和可测试性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DI很方便。即使考虑到Unity本身没有它的事实，侧面的螺钉也可以忍受。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity使您可以自动测试项目。没错，因为所有内置的GameObject组件都没有接口，只能直接用于模拟Collider，SpriteRenderer，MeshRenderer等。将无法解决。尽管GetComponent允许您在界面上获取组件。作为一种选择，为所有内容编写自己的包装器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用自动测试简化了生成初始逻辑的过程，而代码没有用户界面。测试多次会在开发过程中立即发现错误，自然，错误会进一步出现，但是通常可以编写其他测试/更改现有测试，然后自动捕获它。 DI，预制件，可编写脚本的对象等错误，测试很难捕获，但是有可能，因为您可以为Zenject使用真正的安装程序，这会加强依赖关系，因为它会在构建过程中发生。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity会产生大量的错误，崩溃。</font><font style="vertical-align: inherit;">通常，错误是通过重新启动编辑器来解决的。</font><font style="vertical-align: inherit;">面对对预制件中对象的引用的奇怪丢失。</font><font style="vertical-align: inherit;">有时，按引用的预制件被破坏（ToString（）返回“ null”），尽管一切看起来正常，但预制件被拖到场景上，链接也不为空。</font><font style="vertical-align: inherit;">有时在所有场景中都会失去一些联系。</font><font style="vertical-align: inherit;">一切似乎都已安装并且可以正常工作，但是当切换到另一个分支时，所有场景都被破坏了-元素之间没有链接。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幸运的是，这些错误通常可以通过重新启动编辑器或有时删除“库”文件夹来纠正。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从构思到在Google Play上发布，总共已有大约半年的时间。</font><font style="vertical-align: inherit;">开发本身花费了大约3个月的时间，而主要工作却没有时间。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN453564/">https://habr.com/ru/post/zh-CN453564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN453546/index.html">需要一个小键盘-自己动手做</a></li>
<li><a href="../zh-CN453548/index.html">我们复兴了制动的三星银河TAB 2 WiFi</a></li>
<li><a href="../zh-CN453554/index.html">SpaceX的Starlink发生了怎样的变化</a></li>
<li><a href="../zh-CN453558/index.html">机器学习导论</a></li>
<li><a href="../zh-CN453562/index.html">5月27日至6月2日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN453566/index.html">恢复图例：进行开放数据交换的电话，可以帮助恢复巴黎圣母院</a></li>
<li><a href="../zh-CN453568/index.html">重建图标：调用共享开放数据以帮助还原Notre-Dame</a></li>
<li><a href="../zh-CN453570/index.html">适用于macOS的Microsoft Edge</a></li>
<li><a href="../zh-CN453572/index.html">适用于macOS的Microsoft Edge</a></li>
<li><a href="../zh-CN453574/index.html">B2B产品管理</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>