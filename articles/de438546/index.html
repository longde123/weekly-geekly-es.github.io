<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùÔ∏è üéÄ üßòüèª Analyse von Modulbindungsans√§tzen in Node.js. ü§πüèº üïäÔ∏è üéí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Node.js-Entwickler verwenden Modul-Abh√§ngigkeiten (ausschlie√ülich) mit require (), um Module zu binden. Es gibt jedoch auch andere Ans√§tze mit i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse von Modulbindungsans√§tzen in Node.js.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438546/"> Viele Node.js-Entwickler verwenden Modul-Abh√§ngigkeiten (ausschlie√ülich) mit require (), um Module zu binden. Es gibt jedoch auch andere Ans√§tze mit ihren Vor- und Nachteilen.  Ich werde in diesem Artikel dar√ºber sprechen.  Es werden vier Ans√§tze betrachtet: <br><br><ul><li>  Harte Abh√§ngigkeiten (require ()) </li><li>  Abh√§ngigkeitsinjektion </li><li>  Service Locator </li><li>  Eingebettete Abh√§ngigkeitscontainer (DI-Container) </li></ul><a name="habracut"></a><br><h4>  Ein bisschen √ºber Module </h4><br>  Module und modulare Architektur bilden die Grundlage von Node.js.  Module bieten Kapselung (Ausblenden von Implementierungsdetails und √ñffnen nur der Schnittstelle mit module.exports), Wiederverwendung von Code und Aufteilen von logischem Code in Dateien.  Fast alle Node.js-Anwendungen bestehen aus vielen Modulen, die irgendwie interagieren m√ºssen.  Wenn Sie die Module falsch binden oder sogar die Interaktion der Module abdriften lassen, k√∂nnen Sie sehr schnell feststellen, dass die Anwendung ‚Äûauseinanderf√§llt‚Äú: √Ñnderungen im Code an einer Stelle f√ºhren zu einer Panne an einer anderen Stelle, und Unit-Tests werden einfach unm√∂glich.  Idealerweise sollten die Module eine hohe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konnektivit√§t</a> , aber eine geringe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kopplung aufweisen</a> . <br><br><h2>  Harte Sucht </h2><br>  Eine starke Abh√§ngigkeit eines Moduls von einem anderen tritt auf, wenn require () verwendet wird.  Dies ist ein effektiver, einfacher und allgemeiner Ansatz.  Zum Beispiel m√∂chten wir nur das Modul verbinden, das f√ºr die Interaktion mit der Datenbank verantwortlich ist: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js const db = require('db'); //    ...</span></span></code> </pre> <br><h4>  Vorteile: </h4><br><ul><li>  Einfachheit </li><li>  Visuelle Organisation von Modulen </li><li>  Einfaches Debuggen </li></ul><br><h4>  Nachteile: </h4><br><ul><li>  Schwierigkeiten bei der Wiederverwendung des Moduls (z. B. wenn wir unser Modul wiederholt verwenden m√∂chten, jedoch mit einer anderen Instanz der Datenbank) </li><li>  Schwierigkeit beim Testen von Einheiten (Sie m√ºssen eine Dummy-Datenbankinstanz erstellen und sie irgendwie an das Modul √ºbergeben) </li></ul><br><h4>  Zusammenfassung: </h4><br>  Der Ansatz eignet sich sowohl f√ºr kleine Anwendungen oder Prototypen als auch f√ºr den Anschluss zustandsloser Module: Fabriken, Designer und Funktionss√§tze. <br><br><h2>  Abh√§ngigkeitsinjektion </h2><br>  Die Hauptidee der Abh√§ngigkeitsinjektion besteht darin, Abh√§ngigkeiten von einer externen Komponente auf das Modul zu √ºbertragen.  Dadurch wird die harte Abh√§ngigkeit im Modul beseitigt und es wird m√∂glich, es in verschiedenen Kontexten (z. B. mit verschiedenen Datenbankinstanzen) wiederzuverwenden. <br><br>  Die Abh√§ngigkeitsinjektion kann durch √úbergeben der Abh√§ngigkeit im Konstruktorargument oder durch Festlegen von Moduleigenschaften implementiert werden. In der Praxis ist es jedoch besser, die erste Methode zu verwenden.  Wenden wir die Implementierung von Abh√§ngigkeiten in der Praxis an, indem wir eine Instanz der Datenbank mithilfe der Factory erstellen und an unser Modul √ºbergeben: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (db) =&gt; { //       ... };</span></span></code> </pre> <br>  Externes Modul: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dbFactory = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OurModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./ourModule.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dbInstance = dbFactory.createInstance(<span class="hljs-string"><span class="hljs-string">'instance1'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = OurModule(dbInstance);</code> </pre> <br>  Jetzt k√∂nnen wir unser Modul nicht nur wiederverwenden, sondern auch einfach einen Komponententest daf√ºr schreiben: Erstellen Sie einfach ein Scheinobjekt f√ºr die Datenbankinstanz und √ºbergeben Sie es an das Modul. <br><br><h4>  Vorteile: </h4><br><ul><li>  Einfache Schreibeinheitentests </li><li>  Erh√∂hen Sie die Wiederverwendbarkeit von Modulen </li><li>  Vermindertes Engagement, erh√∂hte Konnektivit√§t </li><li>  Verlagerung der Verantwortung f√ºr das Erstellen von Abh√§ngigkeiten auf eine h√∂here Ebene - dies verbessert h√§ufig die Lesbarkeit des Programms, da wichtige Abh√§ngigkeiten an einem Ort gesammelt und nicht nach Modulen verteilt werden </li></ul><br><h4>  Nachteile: </h4><br><ul><li>  Die Notwendigkeit eines gr√ºndlicheren Abh√§ngigkeitsentwurfs: Beispielsweise muss eine bestimmte Reihenfolge der Modulinitialisierung eingehalten werden </li><li>  Die Komplexit√§t des Abh√§ngigkeitsmanagements, insbesondere wenn es viele gibt </li><li>  Verschlechterung der Verst√§ndlichkeit des Modulcodes: Das Schreiben von Modulcode, wenn eine Abh√§ngigkeit von au√üen kommt, ist schwieriger, da wir diese Abh√§ngigkeit nicht direkt betrachten k√∂nnen. </li></ul><br><h4>  Zusammenfassung: </h4><br>  Die Abh√§ngigkeitsinjektion erh√∂ht die Komplexit√§t und Gr√∂√üe der Anwendung, erm√∂glicht jedoch im Gegenzug die Wiederverwendung und erleichtert das Testen.  Der Entwickler sollte entscheiden, was in einem bestimmten Fall f√ºr ihn wichtiger ist - die Einfachheit einer harten Abh√§ngigkeit oder die breiteren M√∂glichkeiten, eine Abh√§ngigkeit einzuf√ºhren. <br><br><h2>  Service Locator </h2><br>  Die Idee ist, eine Abh√§ngigkeitsregistrierung zu haben, die als Vermittler beim Laden einer Abh√§ngigkeit mit einem beliebigen Modul fungiert.  Anstelle einer festen Bindung werden vom Modul Abh√§ngigkeiten vom Service Locator angefordert.  Offensichtlich haben die Module eine neue Abh√§ngigkeit - den Service Locator selbst.  Ein Beispiel f√ºr einen Service Locator ist das Node.js-Modulsystem: Module fordern mit require () eine Abh√§ngigkeit an.  Im folgenden Beispiel erstellen wir einen Service Locator, registrieren Datenbankinstanzen und unser Modul darin. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// serviceLocator.js const dependencies = {}; const factories = {}; const serviceLocator = {}; serviceLocator.register = (name, instance) =&gt; { //[2] dependencies[name] = instance; }; serviceLocator.factory = (name, factory) =&gt; { //[1] factories[name] = factory; }; serviceLocator.get = (name) =&gt; { //[3] if(!dependencies[name]) { const factory = factories[name]; dependencies[name] = factory &amp;&amp; factory(serviceLocator); if(!dependencies[name]) { throw new Error('Cannot find module: ' + name); } } return dependencies[name]; };</span></span></code> </pre> <br>  Externes Modul: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> serviceLocator = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./serviceLocator.js'</span></span>)(); serviceLocator.register(<span class="hljs-string"><span class="hljs-string">'someParameter'</span></span>, <span class="hljs-string"><span class="hljs-string">'someValue'</span></span>); serviceLocator.factory(<span class="hljs-string"><span class="hljs-string">'db'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>)); serviceLocator.factory(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = serviceLocator.get(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>);</code> </pre> <br>  Unser Modul: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (serviceLocator) =&gt; { const db = serviceLocator.get('db'); const someValue = serviceLocator.get('someParameter'); const ourModule = {}; //  ,   ... return ourModule; };</span></span></code> </pre> <br>  Es sollte beachtet werden, dass der Service Locator Servicefabriken anstelle von Instanzen speichert, und das ist sinnvoll.  Wir haben die Vorteile einer verz√∂gerten Initialisierung und m√ºssen uns jetzt nicht mehr um die Initialisierungsreihenfolge der Module k√ºmmern - alle Module werden bei Bedarf initialisiert.  Au√üerdem hatten wir die M√∂glichkeit, Parameter im Service Locator zu speichern (siehe "someParameter"). <br><br><h4>  Vorteile: </h4><br><ul><li>  Einfache Schreibeinheitentests </li><li>  Die Wiederverwendung eines Moduls ist einfacher als bei einer harten Sucht </li><li>  Reduziertes Engagement, erh√∂hte Konnektivit√§t im Vergleich zu harter Sucht </li><li>  Verlagerung der Verantwortung f√ºr die Erstellung von Abh√§ngigkeiten auf eine h√∂here Ebene </li><li>  Die Reihenfolge der Modulinitialisierung muss nicht eingehalten werden </li></ul><br><h4>  Nachteile: </h4><br><ul><li>  Die Wiederverwendung eines Moduls ist schwieriger als die Implementierung einer Abh√§ngigkeit (aufgrund der zus√§tzlichen Abh√§ngigkeit des Service Locator). </li><li>  Lesbarkeit: Es ist noch schwieriger zu verstehen, was die vom Service Locator geforderte Abh√§ngigkeit bewirkt </li><li>  Erh√∂htes Engagement im Vergleich zur Abh√§ngigkeitsinjektion </li></ul><br><h4>  Zusammenfassung </h4><br>  Im Allgemeinen √§hnelt ein Service Locator der Abh√§ngigkeitsinjektion. In mancher Hinsicht ist dies einfacher (es gibt keine Initialisierungsreihenfolge), in einigen F√§llen ist es schwieriger (weniger als die M√∂glichkeit, Code wiederzuverwenden). <br><br><h2>  Eingebettete Abh√§ngigkeitscontainer (DI-Container) </h2><br>  Der Service Locator hat einen Nachteil, aufgrund dessen er in der Praxis selten angewendet wird - die Abh√§ngigkeit der Module vom Locator selbst.  Eingebettete Abh√§ngigkeitscontainer (DI-Container) haben diesen Nachteil nicht.  Tats√§chlich ist dies derselbe Service Locator mit einer zus√§tzlichen Funktion, die die Abh√§ngigkeiten des Moduls vor dem Erstellen seiner Instanz ermittelt.  Sie k√∂nnen Modulabh√§ngigkeiten ermitteln, indem Sie Argumente aus dem Modulkonstruktor analysieren und extrahieren (in JavaScript k√∂nnen Sie mit toString () einen Link zu einer Funktion in eine Zeichenfolge umwandeln).  Diese Methode eignet sich, wenn die Entwicklung ausschlie√ülich f√ºr den Server erfolgt.  Wenn Client-Code geschrieben wird, wird er h√§ufig minimiert und es ist sinnlos, die Namen der Argumente zu extrahieren.  In diesem Fall kann die Liste der Abh√§ngigkeiten als Array von Zeichenfolgen √ºbergeben werden (in Angular.js wird dieser Ansatz basierend auf der Verwendung von DI-Containern verwendet).  Wir implementieren den DI-Container mithilfe der Analyse von Konstruktorargumenten: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fnArgs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'parse-fn-args'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dependencies = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factories = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> diContainer = {}; diContainer.factory = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, factory</span></span></span><span class="hljs-function">) =&gt;</span></span> { factories[name] = factory; }; diContainer.register = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, dep</span></span></span><span class="hljs-function">) =&gt;</span></span> { dependencies[name] = dep; }; diContainer.get = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!dependencies[name]) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factory = factories[name]; dependencies[name] = factory &amp;&amp; diContainer.inject(factory); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!dependencies[name]) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Cannot find module: '</span></span> + name); } } diContainer.inject = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">factory</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args = fnArgs(factory) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dependency</span></span></span><span class="hljs-function"> =&gt;</span></span> diContainer.get(dependency)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dependencies[name]; };</code> </pre> <br>  Im Vergleich zum Service Locator wurde die Inject-Methode hinzugef√ºgt, mit der die Abh√§ngigkeiten des Moduls vor dem Erstellen seiner Instanz ermittelt werden.  Der externe Modulcode hat sich nicht wesentlich ge√§ndert: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> diContainer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./diContainer.js'</span></span>)(); diContainer.register(<span class="hljs-string"><span class="hljs-string">'someParameter'</span></span>, <span class="hljs-string"><span class="hljs-string">'someValue'</span></span>); diContainer.factory(<span class="hljs-string"><span class="hljs-string">'db'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>)); diContainer.factory(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = diContainer.get(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>);</code> </pre> <br>  Unser Modul sieht genauso aus wie bei einer einfachen Abh√§ngigkeitsinjektion: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (db) =&gt; { //       ... };</span></span></code> </pre> <br>  Jetzt kann unser Modul sowohl mit Hilfe eines DI-Containers aufgerufen werden als auch die erforderlichen Instanzen von Abh√§ngigkeiten mithilfe einer einfachen Abh√§ngigkeitsinjektion direkt √ºbergeben werden. <br><br><h4>  Vorteile: </h4><br><ul><li>  Einfache Schreibeinheitentests </li><li>  Einfache Wiederverwendung von Modulen </li><li>  Reduziertes Engagement, erh√∂hte Konnektivit√§t der Module (insbesondere im Vergleich zu einem Service Locator) </li><li>  Verlagerung der Verantwortung f√ºr die Erstellung von Abh√§ngigkeiten auf eine h√∂here Ebene </li><li>  Sie m√ºssen die Modulinitialisierung nicht verfolgen </li></ul><br><h4>  Das gr√∂√üte Minus: </h4><br><ul><li>  Signifikante Komplikation der Modulbindungslogik </li></ul><br><h4>  Zusammenfassung </h4><br>  Dieser Ansatz ist schwieriger zu verstehen und enth√§lt etwas mehr Code, aber aufgrund seiner Kraft und Eleganz lohnt sich die daf√ºr aufgewendete Zeit.  In kleinen Projekten kann dieser Ansatz redundant sein, sollte jedoch ber√ºcksichtigt werden, wenn eine gro√üe Anwendung entworfen wird. <br><br><h2>  Fazit </h2><br>  Die grundlegenden Ans√§tze zur Modulbindung in Node.js. wurden ber√ºcksichtigt.  Wie es normalerweise der Fall ist, gibt es keine ‚ÄûSilberkugel‚Äú, aber der Entwickler sollte sich der m√∂glichen Alternativen bewusst sein und f√ºr jeden Einzelfall die am besten geeignete L√∂sung ausw√§hlen. <br><br>  Der Artikel basiert auf einem Kapitel aus dem 2017 ver√∂ffentlichten Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js Design Patterns</a> .  Leider sind viele Dinge in dem Buch bereits veraltet, sodass ich es nicht zu 100% empfehlen kann, es zu lesen, aber einige Dinge sind heute noch relevant. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438546/">https://habr.com/ru/post/de438546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438536/index.html">Unter der Haube des Chatbots: Was RocketBot kann und wie es funktioniert</a></li>
<li><a href="../de438538/index.html">Teamlead Conf 2019 Msk: √ºber ein anderes Kommunikationsformat</a></li>
<li><a href="../de438540/index.html">Trends in der Dokumentenverwaltung und Datenspeicherung f√ºr 2019</a></li>
<li><a href="../de438542/index.html">Wie wir einen Empfehlungsdienst f√ºr die Auswahl von Kleidung in neuronalen Netzen erstellt haben</a></li>
<li><a href="../de438544/index.html">Wir schauen zu Hause Filme: 10 Materialien √ºber den Bau eines Heimkinos und die Auswahl der Ausr√ºstung</a></li>
<li><a href="../de438548/index.html">Lombok, sources.jar und praktisches Debuggen</a></li>
<li><a href="../de438550/index.html">Ein weiteres Manifest</a></li>
<li><a href="../de438554/index.html">Verwalten des Status und der Ereignisse zwischen Komponenten in GameObject</a></li>
<li><a href="../de438556/index.html">Daten bequem s√§gen</a></li>
<li><a href="../de438560/index.html">XGBoost von Grund auf neu schreiben - Teil 1: Entscheidungsb√§ume</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>