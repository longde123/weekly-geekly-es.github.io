<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏿 🍔 👩🏽‍🤝‍👨🏻 使用一组回归树在一毫秒内搜索面部轮廓 🤙🏼 👨🏽‍✈️ ✒️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文的翻译是为“数据科学数学”课程的学生准备的 

 注解 


 本文讨论了为单个图像查找面部轮廓的任务。 我们展示了如何使用回归树的集合直接从像素强度的分散子集直接预测面部轮廓的位置，并通过高质量的预测实时实现超级性能。 我们提出了一种基于梯度提升的通用结构，用于研究回归树的集合，该树优化了二次...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用一组回归树在一毫秒内搜索面部轮廓</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/460541/"><p><img src="https://habrastorage.org/webt/eb/rn/3a/ebrn3a_ugfcxc9tuhkdmwgnrut8.png"></p><br><p>  <em>本文的翻译是为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“数据科学数学”</a>课程的学生准备的</em> </p><br><hr><br><h1 id="annotaciya"> 注解 </h1><br><p>  <em>本文讨论了为单个图像查找面部轮廓的任务。</em>  <em>我们展示了如何使用回归树的集合直接从像素强度的分散子集直接预测面部轮廓的位置，并通过高质量的预测实时实现超级性能。</em>  <em>我们提出了一种基于梯度提升的通用结构，用于研究回归树的集合，该树优化了二次损失的总和并自然处理了缺失或部分标记的数据。</em>  <em>我们将展示考虑图像数据结构的适当分布如何帮助有效地选择轮廓。</em>  <em>还研究了各种正则化策略及其在对抗再培训中的重要性。</em>  <em>此外，我们分析了训练数据量对预测准确性的影响，并使用综合数据检验了增加数据的影响。</em> <a name="habracut"></a></p><br><h1 id="1-vvedenie">  1.简介 </h1><br><p> 在本文中，我们提出了一种新算法，该算法可在毫秒内搜索面部轮廓，并获得优于或可与标准数据集上的现代方法相媲美的精度。 与以前的方法相比，速度的提高是由于确定了先前算法的主要组成部分，这些算法用于搜索面部轮廓并将其随后以优化的形式包含在具有梯度提升功能的高带宽回归模型级联中。 </p><br><p> 正如我们在[8，2]之前所做的那样，我们证明了可以使用级联回归模型来进行面部轮廓的搜索。 在我们的案例中，级联中的每个回归模型都会根据初始预测和相对于该初始预测索引的稀疏像素集的强度，有效预测人脸的形状。 我们的工作是基于过去十年中进行的大量研究而得出的，这些研究在寻找面部轮廓的任务上取得了重大进展[9、4、13、7、15、1、16、18、3、6、19]。 特别是，我们在调整后的回归模型中包含了以下几个成功算法中存在的两个关键元素，现在我们将详细介绍这些元素。 </p><br><p><img src="https://habrastorage.org/webt/xe/fn/ux/xefnuxzvuozcmpu5xjzvwwm3kq4.png"></p><br><p>  <em>图1.在HELEN数据集上的选定结果。</em>  <em>为了在一毫秒内在一幅图像中检测到面部的194个关键点（地标），使用了一组随机回归树。</em> </p><br><p> 首先围绕相对于当前面部形状预测的像素强度索引进行。 面部图像的矢量表示中的显着特征可能会由于形状的变形以及照明条件变化等干扰因素而发生很大变化。 这使得难以使用这些功能准确地预测形状。 难题是我们需要可靠的符号来准确预测形状，另一方面，我们需要对形状的准确预测以提取可靠的符号。 在先前的工作[4、9、5、8]中以及在这项工作中，使用迭代方法（级联）来解决此问题。 代替基于全局图像坐标系中提取的特征对形状参数进行回归，基于当前形状预测将图像转换为归一化坐标系，然后提取符号以预测形状参数的更新矢量。 此过程通常重复几次，直到收敛为止。 </p><br><p> 第二部分研究如何处理解释/预测问题的复杂性。 在测试过程中，轮廓搜索算法应预测人脸的形状-一种高维向量，该向量与图像数据和我们的形状模型最一致。 问题是具有许多局部最优值的非凸性。 成功的算法[4，9]解决了这个问题，假设预测形式应该位于可以通过例如找到训练形式的主要成分而被检测到的线性子空间中。 该假设显着减少了在解释过程中考虑的潜在形式的数量，并且可以帮助避免局部最优。 </p><br><p> 最近的一项工作[8，11，2]利用了这样的事实，即一定的回归变量可以保证创建位于由学习形式定义的线性子空间中的预测，并且不需要其他限制。 重要的是我们的回归模型必须包含这两个要素。 <br> 这两个因素与我们对回归模型的有效培训有关。 我们优化相应的损失函数，并根据数据执行特征选择。 特别是，我们使用二次损失函数使用梯度提升[10]训练每个回归器，二次损失函数是我们希望在测试期间最小化的相同损失函数。 使用梯度提升算法和输入像素对之间的距离的先验概率的组合来选择用作回归器输入的稀疏像素集。 先验分布使增强算法可以有效地研究大量相关特征。 结果是级联的回归器，当从正面初始化时可以定位面部标志。 </p><br><p> 本文的主要贡献是： </p><br><ol><li> 一种基于回归树（决策树）的整体来查找面部轮廓的新方法，该方法执行对表单不变特征的选择，同时使我们希望在测试期间最小化的训练过程中的损失函数最小化。 </li><li> 我们对处理缺失或未定义标签的方法进行了自然扩展。 </li><li> 给出了定量和定性的结果，这证实了我们的方法可以提供高质量的预测，比以前的最佳方法有效得多（图1）。 </li><li> 分析了训练数据量，使用部分标记的数据和广义数据对预测质量的影响。 </li></ol><br><h1 id="2-metod">  2.方法 </h1><br><p> 本文提出了一种在计算效率方面可以准确评估面部标志（关键点）位置的算法。 与先前的工作[8，2]一样，在我们的方法中使用了级联回归器。 在本节的其余部分，我们将描述级联的各个组件的形状以及如何进行训练的详细信息。 </p><br><h4 id="21-kaskad-regressorov">  2.1。 回归级联 </h4><br><p> 首先，我们介绍一些符号。 让 <img src="https://habrastorage.org/getpro/habr/post_images/96b/8a8/cd3/96b8a8cd39c5f39cf67191c499d17a36.svg">  ，图像I中人脸的第i个界标的y坐标。然后是向量 <img src="https://habrastorage.org/getpro/habr/post_images/bd9/f10/315/bd9f10315460922e284cfe03581f1e91.svg"> 表示I中所有p个面的坐标。在本文中，我们通常将向量S称为形状。 我们用 <img src="https://habrastorage.org/getpro/habr/post_images/765/839/4d5/7658394d527b5ec58206aa0bde88e139.svg"> 表示我们当前的等级S。每个回归变量 <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg">  （·，·）在级联中根据图像预测更新向量并 <img src="https://habrastorage.org/getpro/habr/post_images/765/839/4d5/7658394d527b5ec58206aa0bde88e139.svg"> 已添加到当前表单评估中 <img src="https://habrastorage.org/getpro/habr/post_images/765/839/4d5/7658394d527b5ec58206aa0bde88e139.svg"> 要提高评分： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/813/e90/80c/813e9080c1daa94987bfd323fcf05d75.svg">  ） <em>（1）</em> </p><br><p> 级联的关键是回归器 <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg"> 根据属性进行预测，例如由I计算并相对于当前形状估计值索引的像素强度 <img src="https://habrastorage.org/getpro/habr/post_images/765/839/4d5/7658394d527b5ec58206aa0bde88e139.svg">  。 这在过程中引入了某种几何不变性，并且随着级联的进行，您可以更有信心确定面部上的确切语义位置已被索引。 稍后我们将描述如何执行此索引编制。 </p><br><p> 请注意，如果初始估计，则合奏扩展的输出范围保证在训练数据的线性子空间中 <img src="https://habrastorage.org/getpro/habr/post_images/f0d/6ae/457/f0d6ae4573955eb6abc901db0a68bc4a.svg"> 属于这个空间。 因此，我们不需要对预测引入其他限制，从而大大简化了我们的方法。 初始形式可以简单地选择为训练数据的中间形式，根据通用面部检测器的边界框的输出进行居中和缩放。 </p><br><p> 教育大家 <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg"> 如[10]中所述，我们对具有二次损失总和的树使用梯度提升算法。 现在，我们将提供此过程的详细信息。 </p><br><h4 id="22-obuchenie-kazhdogo-regressora-v-kaskade">  2.2。 级联训练每个回归器 </h4><br><p> 假设我们有训练数据 <img src="https://habrastorage.org/getpro/habr/post_images/a81/786/c9b/a81786c9b9d6dc27492f55b19afb5055.svg"> 每个人在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/e19/7a8/ea5/e197a8ea5f9ce816e060678de54e7ba9.svg"> 是一张脸部图像，并且 <img src="https://habrastorage.org/getpro/habr/post_images/7a3/62f/59e/7a362f59eba33ebc236fefd712440e76.svg"> 它的形状矢量。 找出第一个回归函数 <img src="https://habrastorage.org/getpro/habr/post_images/0ac/302/657/0ac302657b1d8e45efa7f7b9b2557268.svg"> 在级联中，我们从训练数据的面部图像三元组创建初始形状预测和目标更新步骤，即 <img src="https://habrastorage.org/getpro/habr/post_images/6a1/450/b9e/6a1450b9ea40a582ec2794d9df7afd31.svg">  ）哪里 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f29/a62/581/f29a625813ba6c6cd00aea30a8cfe019.svg">  <em>（2）</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6c3/a0d/468/6c3a0d468f609ada0672c0f473c589ec.svg">  <em>（3）</em>和 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/691/50d/5cf/69150d5cfe48125a51002916c28453e8.svg">  <em>（4）</em> </p><br><p> 对于i = 1，...，N. </p><br><p> 我们将这些三元组的总数设置为N = nR，其中R是图像Ii上使用的初始化次数。 从图像中平均选择图像的每个初始形状预测 <img src="https://habrastorage.org/getpro/habr/post_images/d1c/fb5/092/d1cfb5092f0e598893288582f2114b37.svg"> 无需更换。 </p><br><p> 根据这些数据，我们训练回归函数 <img src="https://habrastorage.org/getpro/habr/post_images/bcb/830/694/bcb83069438bb8a2d3e1e51f76a276f4.svg">  （请参阅算法1），使用树的梯度增强和二次损失之和。 然后更新训练三元组集以提供训练数据。 <img src="https://habrastorage.org/getpro/habr/post_images/f56/e5c/4a8/f56e5c4a803f2c95ebe20dae215895cf.svg">  ％20）用于下一个回归 <img src="https://habrastorage.org/getpro/habr/post_images/dc5/512/a85/dc5512a85c881619a2c05faa3c2a2806.svg"> 通过设置（t = 0）来级联。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/146/29d/692/14629d6922ca89d70fed70bbeb3287bd.svg">  ％20） <em>（5）</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/17d/8a5/44a/17d8a544a843aa72dc68d79ab9c2236d.svg">  <em>（6）</em> </p><br><p> 重复此过程，直到训练出级联的T回归器为止。 <img src="https://habrastorage.org/getpro/habr/post_images/ee6/6a5/503/ee66a5503085c7bbaa7a616585c4ae2e.svg"> 结合起来可以提供足够的准确性。 </p><br><p> 如图所示，每个回归器 <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg"> 学习使用梯度树增强算法。 应当记住，使用了二次损失函数，在内环中计算出的残差与每个训练样本中估计的该损失函数的梯度相对应。 该算法的公式包括学习速率参数0 &lt;ν≤1，也称为正则化系数。 将ν设置为&lt;1有助于对抗重构，通常会导致回归器的泛化性比经过ν= 1训练的回归器好得多[10]。 </p><br><hr><br><p>  <strong>学习算法1</strong> <strong><img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg"></strong>  <strong>级联</strong> </p><br><p> 我们有训练数据 <img src="https://habrastorage.org/getpro/habr/post_images/2d4/805/43a/2d480543a349544ead268291984b1e6a.svg"> 和学习率（正则化系数）0 &lt;ν&lt;1 </p><br><ol><li> 初始化 <br><img src="https://habrastorage.org/getpro/habr/post_images/e54/d75/bae/e54d75bae7a82091f8d5c1f04a92cc22.svg"></li><li> 对于k = 1，...，K： <br>  a）我们设置为i = 1，...， <br><img src="https://habrastorage.org/getpro/habr/post_images/759/573/b03/759573b032b3bb95986dfe5d42d8e5d8.svg"><br>  b）我们将回归树调整为目标 <img src="https://habrastorage.org/getpro/habr/post_images/683/2f3/54e/6832f354e8f4ecad8283cc1be6a6899a.svg"> 回归函数弱 <img src="https://habrastorage.org/getpro/habr/post_images/425/db2/33f/425db233f09794bfe60e62a49da89a98.svg">  。 <br>  c）更新 <img src="https://habrastorage.org/getpro/habr/post_images/376/5d0/ac3/3765d0ac3de75d838ad520821c141c21.svg"></li><li> 结论 <br><img src="https://habrastorage.org/getpro/habr/post_images/7c0/9c4/2b9/7c09c42b9cc35b3225f89435a9d4ce22.svg"></li></ol><br><hr><br><h4 id="23-drevovidnyy-regressor">  2.3。 树回归器 </h4><br><p> 每个rt回归函数的核心是适合于梯度提升算法期间残差目标的树状回归器。 现在，我们将研究训练每个回归树的最重要的实现细节。 </p><br><h4 id="231-invariantnye-split-testy-formy">  2.3.1不变分裂形式检验 </h4><br><p> 在回归树的每个分离节点上，我们都基于两个像素强度之间差异的阈值进行决策。 当在中间形状坐标系中定义像素时，测试中使用的像素位于u和v位置。 对于具有任意形状的脸部图像，我们希望索引相对于其形状与u和v具有相同位置的点，以求平均形状。 为此，在提取元素之前，可以基于当前形状估计将图像变形为中间形状。 由于我们仅使用非常稀疏的图像表示，因此变形点的排列比整个图像更有效。 另外，如[2]中所提出的，除了局部位移之外，仅使用全局相似性变换就可以对变形进行粗略近似。 </p><br><p> 确切的细节如下。 让 <img src="https://habrastorage.org/getpro/habr/post_images/482/2f7/60f/4822f760fdf061f414f323d30d0c14cd.svg"> 是中间形式中人脸上地标的索引最接近u，并将其相对于u的位移定义为 <img src="https://habrastorage.org/getpro/habr/post_images/0fa/bbb/f81/0fabbbf8125f80b9f31e3b5ce093bc3c.svg">  。 </p><br><p> 然后对于图像中定义的形式Si <img src="https://habrastorage.org/getpro/habr/post_images/e19/7a8/ea5/e197a8ea5f9ce816e060678de54e7ba9.svg"> 位置在 <img src="https://habrastorage.org/getpro/habr/post_images/e19/7a8/ea5/e197a8ea5f9ce816e060678de54e7ba9.svg"> 在质量上与u在图像中的形状相似，定义为 <br><img src="https://habrastorage.org/getpro/habr/post_images/e2d/e8d/0d4/e2de8d0d461e2ef6e76642d39a803b27.svg">  <em>（7）</em> </p><br><p> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/7a3/62f/59e/7a362f59eba33ebc236fefd712440e76.svg"> 和 <img src="https://habrastorage.org/getpro/habr/post_images/8f6/b4a/913/8f6b4a913e518f22483a28148144b54e.svg">  -变换的相似度变换的比例和旋转矩阵 <img src="https://habrastorage.org/getpro/habr/post_images/7a3/62f/59e/7a362f59eba33ebc236fefd712440e76.svg"> 在 <img src="https://habrastorage.org/getpro/habr/post_images/919/800/718/919800718f235e7487c36b01db6739e1.svg">  ，中间形式。 </p><br><p> 缩放和旋转最小化 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cf0/581/e89/cf0581e890e027fcaf3327e3be6f194c.svg">  <em>（8）</em> </p><br><p> 中间形状的界标点之间的平方和， <img src="https://habrastorage.org/getpro/habr/post_images/c73/942/e7f/c73942e7f47a9adb6091e024085fc1bb.svg"> 和点翘曲。 <img src="https://habrastorage.org/getpro/habr/post_images/b2d/a25/52e/b2da2552e44457f6bcbf5d1aab251267.svg"> 类似地定义。 </p><br><p> 形式上，每个除法都是一个包含3个参数θ=（τ，u，v）的解决方案，并应用于每个训练和测试示例 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bfe/6ee/9c7/bfe6ee9c7e9da21fb2b81caca3d8abad.svg">  <em>（9）</em> </p><br><p> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/ff8/c77/429/ff8c77429402ff15260663452a693e8d.svg"> 和 <img src="https://habrastorage.org/getpro/habr/post_images/b2d/a25/52e/b2da2552e44457f6bcbf5d1aab251267.svg"> 使用最能变形的比例和旋转矩阵确定 <img src="https://habrastorage.org/getpro/habr/post_images/5ac/ad7/803/5acad7803f7a79cc10fa8c714205eeab.svg"> 在 <img src="https://habrastorage.org/getpro/habr/post_images/919/800/718/919800718f235e7487c36b01db6739e1.svg"> 根据等式（7）。 实际上，在训练阶段确定任务和局部位移。 在测试此过程中最昂贵的部分期间，相似度转换的计算仅在级联的每个级别上执行一次。 </p><br><h4 id="232-vybor-uzlovyh-razbieniy">  2.3.2节点分区的选择 </h4><br><p> 对于每个回归树，我们通过分段线性函数近似基本函数，其中常数向量适用于每个有限节点。 为了训练回归树，我们在每个节点中随机生成一组合适的分区，即θ。 然后，我们急切地从这些候选项中选择θ*，这将使二次误差之和最小。 如果Q是节点中训练示例的索引集，则这对应于最小化 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8b2/8f1/e02/8b28f1e02ab50c802525c5ded6aaeeaf.svg">  <em>（10）</em> </p><br><p> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/fd5/fa1/737/fd5fa1737973ecd7a303b2862a32f8ec.svg">  -由于决策θ发送到左节点的示例的索引， <img src="https://habrastorage.org/getpro/habr/post_images/ab1/ee0/4fb/ab1ee04fb1210c9352cc942823f6dcd1.svg"> 是在梯度增强算法中为图像<em>i</em>计算的所有残差的向量，并且 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c7f/e61/cc7/c7fe61cc7d441d07443317d12fc860c4.svg"> 为 <img src="https://habrastorage.org/getpro/habr/post_images/e17/6e7/ece/e176e7ece99e70aeee6c4ffe2949bb2f.svg">  <em>（11）</em> </p><br><p> 可以非常有效地找到最佳分区，因为如果我们转换方程式（10）并忽略与θ无关的因子，我们可以看到 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/517/57c/a5c/51757ca5c227156f25de32c995a6c1eb.svg"></p><br><p> 在这里我们只需要计算 <img src="https://habrastorage.org/getpro/habr/post_images/88d/4eb/4bb/88d4eb4bb69acbcbbbf4ad0e10098a80.svg"> 在评估各种θ时， <img src="https://habrastorage.org/getpro/habr/post_images/ba2/1c8/eeb/ba21c8eeb00ef767cf6f5bd5297f986e.svg"> 可以根据父节点µ和 <img src="https://habrastorage.org/getpro/habr/post_images/88d/4eb/4bb/88d4eb4bb69acbcbbbf4ad0e10098a80.svg"> 如下： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b0a/e76/10a/b0ae7610afe1aa13d10de797871193c6.svg"></p><br><h4 id="233-vybor-priznakov">  2.3.3特性选择 </h4><br><p> 每个节点处的解决方案基于一对像素中强度值差异的阈值。 这是一个相当简单的测试，但是由于它对全局照明的变化相对不敏感，因此它比具有单个强度的阈值有效得多。 不幸的是，使用像素差的缺点是潜在的候选间隔（特征）的数量相对于平均图像中的像素数量是二次的。 这使得很难在不搜索大量θ的情况下找到它们。 但是，考虑到图像数据的结构，该限制因素可能会有所减弱。 </p><br><p> 我们介绍指数分布 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f30/6b8/6c4/f306b86c47bfa440c1d1c716e3c9d6b8.svg">  <em>（12）</em> </p><br><p> 通过分割中使用的像素之间的距离来鼓励选择更接近的像素对。 </p><br><p> 我们发现，使用这种简单的分布可以减少许多面部数据集的预测误差。 图4比较了选择和不选择时的特征，其中两种情况下对象池的大小都设置为20。 </p><br><h1 id="24-obrabotka-propuschennyh-metok">  2.4。 处理丢失的标签 </h1><br><p> 方程（10）的问题可以轻松扩展，以处理某些路标未在某些训练图像上标记的情况（或者我们对每个路标都有不确定性的度量）。 输入变量 <img src="https://habrastorage.org/getpro/habr/post_images/7e0/805/7ed/7e08057ed464a0c8c2af586f05a009aa.svg"> 对于每个训练图像<em>i</em>和每个界标<em>j</em> ，[0，1]。 安装方式 <img src="https://habrastorage.org/getpro/habr/post_images/260/ce8/a6b/260ce8a6b696864e07aaa5de561923e6.svg"> 值0表示在第<em>i</em>个图像中未标记界标<em>j</em> ，设置1表示已标记。 那么等式（10）可以表示如下 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7e5/183/d89/7e5183d8955912640ff62a62fd8913de.svg"></p><br><p> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/07f/821/26e/07f82126e42fc56123ae1a571fcaac7b.svg">  -具有向量的对角矩阵 <img src="https://habrastorage.org/getpro/habr/post_images/a77/988/515/a779885154cabacbcccfb17d823fd818.svg"> 在她的对角线上 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a7/975/451/7a79754517a719b74cff33c43743171f.svg"> 为 <img src="https://habrastorage.org/getpro/habr/post_images/e17/6e7/ece/e176e7ece99e70aeee6c4ffe2949bb2f.svg">  <em>（13）</em> </p><br><p> 还必须修改梯度提升算法以考虑这些权重。 可以通过简单地用目标的加权平均值初始化集合模型，并将回归树拟合算法1中的加权残差来完成此操作，如下所示 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/396/468/7a9/3964687a9c8c905316ef8d6b69d73888.svg">  <em>（14）</em> </p><br><h1 id="3-eksperimenty">  3.实验 </h1><br><p>  <strong>基础：</strong>为了准确评估我们提出的方法的性能，回归树集成（ERT），我们创建了另外两个基础。 第一种是基于随机蕨类（随机蕨类），具有特征的随机选择（EF），另一种是基于关联性（EF + CB）的特征选择的这种方法的更高级版本，这是我们的新实现[2]。 所有这三种方法的参数都是固定的。 </p><br><p>  EF直接使用随机蕨类作为整体中的弱回归函数，并且训练最快。 我们使用与[2]中建议的相同的正则化方法对蕨类进行正则化。 </p><br><p>  EF + CB使用基于相关性的对象选择方法来投影输出值， <img src="https://habrastorage.org/getpro/habr/post_images/ab1/ee0/4fb/ab1ee04fb1210c9352cc942823f6dcd1.svg"> 朝随机方向w的方向，并为其选择符号对（u，v） <img src="https://habrastorage.org/getpro/habr/post_images/dcf/e8f/3cc/dcfe8f3ccb1ca1095fc35db5b623abc0.svg"> 具有预测目标的训练数据的样本相关性最高 <img src="https://habrastorage.org/getpro/habr/post_images/b63/418/2d8/b634182d884088b10405bc691e479fd8.svg">  。 </p><br><p>  <strong>参量</strong> <br> 除非另有说明，否则所有实验均使用以下固定参数设置进行。 级联中的强回归数rt的数量为T = 10，每个 <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg"> 由K = 500个弱回归变量组成 <img src="https://habrastorage.org/getpro/habr/post_images/cfb/227/fd2/cfb227fd27d043451a49e2337d85a6bf.svg">  。 用来表示树木（或蕨类）的深度 <img src="https://habrastorage.org/getpro/habr/post_images/cfb/227/fd2/cfb227fd27d043451a49e2337d85a6bf.svg"> 设置为F =5。在级联的每个级别上，从图像中选择P = 400像素。 为了训练弱回归，我们根据分布随机选择一对P像素，然后选择随机阈值以创建电势隔离，如公式（9）所述。 通过重复此过程S = 20次并选择最优化目标的过程，可以实现最佳分离。        ,   R = 20      . </p><br><p><img src="https://habrastorage.org/webt/7j/we/fs/7jwefsr7puidwxuehw6owexel8k.png"></p><br><p> <em> 2.       ,             Viola &amp; Jones [17].        .</em> </p><br><p> <strong></strong> <br>          O (TKF).          O (NDTKF S),  N —   ,  D —  .                HELEN [12],           . </p><br><p> <strong> </strong> <br>   ,   ,      HELEN [12], ,   ,      .    2330 ,     194 .      2000    ,    . </p><br><p>           LFPW [1],    1432 .  ,     778    216   ,         ,      . </p><br><p>  <strong>比较方式</strong> <br>  1         .                  (Active Shape Models) — STASM [14]  CompASM [12]. </p><br><p><img src="https://habrastorage.org/webt/89/fk/kc/89fkkczbo119vyy4oo7hhu7cmno.png"></p><br><p> <em> 1.        HELEN.  —          .       .      ,        .    ,       .              .</em> </p><br><p>   ,    ,        .   3       ,  ,  ERT     ,   .  ,        EF + CB     .  ,      EF + CB       ,     . </p><br><p>          LFPW [1] ( 2).    EF + CB     ,   [2]. (     ,        .)              ,      ,     . </p><br><p><img src="https://habrastorage.org/webt/ef/uu/nz/efuunznz_ljfv_sr1v1vi5fujoy.png"></p><br><p> <em> 2.        LFPW.       1.</em> </p><br><p> <strong> </strong> <br>  4     (12)       ,   ,      .  λ               0,1   .            <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg">         .  4          . </p><br><p><img src="https://habrastorage.org/webt/do/pm/v4/dopmv4u-mj6pa5tcaioawlcvegs.png"></p><br><p> <em> 3.           .         ,  , .  (12).</em> </p><br><p> <strong></strong> <br>        ,   .     ,     .    — .        ν      1 (   ν = 0.1).           .  , <img src="https://habrastorage.org/getpro/habr/post_images/cfb/227/fd2/cfb227fd27d043451a49e2337d85a6bf.svg">   ,    ,    ν = 1.                   (10   )   . (      .) </p><br><p><img src="https://habrastorage.org/webt/lp/hv/hv/lphvhvclakdn02mzwrfe5rtt28w.png"></p><br><p> <em> 3.       HELEN (a)  LFPW (b). EF —    ,  EF + CB —      ,   .          (5  10),    [2].  ,      (ERT),     ,     ,             .</em> </p><br><p><img src="https://habrastorage.org/webt/xm/3y/pp/xm3yppxdejbgcglidfb-ecofaza.png"></p><br><p> <em> 4.   ,    .       ,      .</em> </p><br><p>             ,   .         ,    . </p><br><p><img src="https://habrastorage.org/webt/0r/hv/l0/0rhvl0mowqozwdscxpkc-lp-w7e.png"></p><br><p> <em> 4.      HELEN     .                .</em> </p><br><p>    ,          .   ,        ,    ,        ,       . </p><br><p> <strong></strong> <br>                 .              .  5          .    ,    ,      [8, 2] (           10 × 400 .) </p><br><p><img src="https://habrastorage.org/webt/rt/sa/n3/rtsan3fkhl6houggpnk8zyiwqie.png"></p><br><p> <em> 5.             .</em> </p><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">训练数据</font></font></strong> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了测试训练图像数量的有效性，我们从训练数据的不同子集中训练了各种模型。</font><font style="vertical-align: inherit;">表6总结了最终结果，图5显示了级联每个级别的误差图。</font><font style="vertical-align: inherit;">当我们有大量的训练示例时，使用多个级别的回归器最为有用。</font></font></p><br><p>我们以固定数量的扩展示例重复了相同的实验，但是从一个标记的面部示例和许多用于研究级联的带注释的图像中更改了用于创建训练示例的初始形式的组合（表7）。 </p><br><p><img src="https://habrastorage.org/webt/8p/-8/bb/8p-8bbob2qvordp1hhebxruts38.png"></p><br><p>  <em>表6.培训示例数的最终错误率。</em>  <em>在创建用于研究级联回归器的训练数据时，每个标记的面部图像都使用20个不同的标记面部作为关于面部形状的初始假设，生成了20个训练示例。</em> </p><br><p><img src="https://habrastorage.org/webt/0o/ft/7s/0oft7ss-mbxhjnln3wje3hqzxau.png"></p><br><p>  <em>图5.根据所使用训练示例的数量，给出了级联每个级别的平均误差。</em>  <em>当训练示例的数量很大时，使用多个级别的回归器最为有用。</em> </p><br><p><img src="https://habrastorage.org/webt/am/mj/aq/ammjaqyvpgnzjynmk0ychb7lnw8.png"></p><br><p>  <em>表7.这里训练示例的有效数量是固定的，但是我们使用了训练图像数量和用于每个标记面部图像的初始形式数量的各种组合。</em> </p><br><p> 使用各种初始形式来增加训练数据可以从形式上扩展数据集。 我们的结果表明，这种类型的补充不能完全弥补没有带注释的训练图像的不足。 尽管通过增加训练图像数量获得的改善率在前几百幅图像之后迅速下降。 </p><br><p>  <strong>部分注释</strong> <br> 表8显示了使用部分注释的数据的结果。 完整注释了200个案例研究，其余仅部分注释。 </p><br><p><img src="https://habrastorage.org/webt/iu/j9/7q/iuj97qa3-awn35lf8z3yibbuzhw.png"></p><br><p>  <em>表8.使用部分标记数据的结果。</em>  <em>始终会完全注释200个示例。</em>  <em>括号中的值表示观察到的界标的百分比。</em> </p><br><p> 结果表明，使用部分标记的数据可以实现显着的改进。 但是，由于我们知道形状参数的基本大小比地标的大小（194×2）小得多，因此显示的改进可能不会被饱和。 因此，如果您明确使用界标位置之间的相关性，则使用局部标记可能会带来更大的改进。 请注意，本文介绍的梯度增强过程不使用界标之间的相关性。 这个问题可以在以后的工作中解决。 </p><br><h1 id="4-vyvod">  4.结论 </h1><br><p> 我们描述了如何使用一组回归树来从从输入图像中提取的强度值的分散子集中回归面部标志的位置。 所呈现的结构比以前的工作更快地减少了错误，并且还可以处理部分或未定义的标记。 尽管我们算法的主要组件将各种目标测量值视为独立变量，但这项工作的自然延续将是使用表单参数的相关性，以进行更有效的训练并更好地使用部分标签。 </p><br><p><img src="https://habrastorage.org/webt/am/cu/xs/amcuxsbdkp6du3rohxpnoey0r2q.png"></p><br><p>  <em>图6. HELEN数据库中的最终结果。</em> </p><br><p>  <strong>致谢</strong> <br> 这项工作是由瑞典战略研究基金会作为VINST项目的一部分资助的。 </p><br><h1 id="ispolzovannaya-literatura"> 二手文献 </h1><br><p>  [1] PN Belhumeur，DW Jacobs，DJ Kriegman和N. Kumar。 使用样例的共识来定位面部的局部。 在CVPR中，第545–552页，2011年。1、5 <br>  [2]曹X，魏Y，温F，和孙J。 通过显式形状回归进行面部对齐。 在CVPR中，第2887–2894页，2012年。1、2、3、4、5、6 <br>  [3] TF Coo​​tes，M。Ionita，C。Lindner和P. Sauer。 使用随机森林回归投票进行稳健而准确的形状模型拟合。 在ECCV中，2012.1 <br>  [4] TF Coo​​tes，CJ Taylor，DH Cooper和J. Graham。 主动形状模型-他们的训练和应用。 计算机视觉与图像理解，61（1）：38–59，1995.1，2 <br>  [5] D. Cristinacce和TF库茨。 增强了回归活动形状模型。 在BMVC中，第79.1–79.10页，2007.1 <br>  [6] M. Dantone，J。Gall，G。Fanelli和LV Gool。 使用条件回归森林进行实时面部特征检测。 在CVPR中，2012.1 <br>  [7]丁·丁和AM·马丁内斯。 精确，详细地检测面部和面部特征。 在CVPR中，2008.1 <br>  [8] P. Dollar，P。Welinder和P. Perona。 级联姿势回归。 在CVPR中，第1078–1085页，2010年。1、2、6 <br>  [9] GJ Edwards，TF Coo​​tes和CJ Taylor。 主动外观模型的进步。 在ICCV中，第137-142页，1999年。1、2 <br>  [10] T. Hastie，R。Tibshirani和JH Friedman。 统计学习的要素：数据挖掘，推理和预测。 纽约：Springer-Verlag，2001.2,3 <br>  [11] V. Kazemi和J. Sullivan。 使用基于零件的建模进行面部对齐。 在BMVC中，第27.1–27.10页，2011.2 <br>  [12] V. Le，J。Brandt，Z。Lin，LD Bourdev和TS Huang。 交互式面部特征本地化。 在[13]中，L。Liang，R。Xiao，F。Wen和J.Sun。 通过基于组件的判别搜索进行人脸对齐。 在ECCV中，第72–85页，2008年。1ECCV，第679–692页，第2012.5页 <br>  [14] S. Milborrow和F. Nicolls。 使用扩展的活动形状模型定位面部特征。 在ECCV中，第504–513页，2008.5 <br>  [15]萨拉吉（J. Saragih），露西（S. Lucey）和科恩（J. Cohn）。 通过正则化地标均值平移对可变形模型进行拟合。 国际计算机视觉杂志，91：200–215，2010.1 <br>  [16] BM Smith和L. Zhang。 非参数形状模型的关节面对齐。 在ECCV中，第43-56页，2012.1 <br>  [17] PA Viola和MJ Jones。 强大的实时人脸检测。 在ICCV中，第747页，2001.5 <br>  [18] X. Zhao，X。Chai和S. Shan。 关节面对齐：通过常规的重新拟合，以良好的对齐来纠正不良的对齐。 在ECCV中，2012.1 <br>  [19] X. Zhu和D. Ramanan。 野外的人脸检测，姿态估计和界标定位。 在CVPR中，第2879-2886页，2012.1 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN460541/">https://habr.com/ru/post/zh-CN460541/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN460527/index.html">使用pwnable.kr 06-随机和09-错误解决问题</a></li>
<li><a href="../zh-CN460531/index.html">来自IT世界的好奇变态-5</a></li>
<li><a href="../zh-CN460535/index.html">为Go应用创建最小的Docker容器</a></li>
<li><a href="../zh-CN460537/index.html">ZuriHac：练习函数式编程</a></li>
<li><a href="../zh-CN460539/index.html">Vue中的错误处理</a></li>
<li><a href="../zh-CN460543/index.html">面向思科开发人员的新认证。 行业认证概述</a></li>
<li><a href="../zh-CN460547/index.html">上古物品：Psion 5MX和退休生活</a></li>
<li><a href="../zh-CN460551/index.html">葡萄牙 每年最好的海滩和一千家创业公司</a></li>
<li><a href="../zh-CN460553/index.html">技术，外包和思维方式：我们如何在Lamoda的德国办事处实施Microsoft Dynamics 365</a></li>
<li><a href="../zh-CN460555/index.html">PyDaCon聚会在Mail.ru集团的报告，6月22日</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>