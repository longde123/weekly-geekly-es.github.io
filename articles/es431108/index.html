<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨áÔ∏è üë®‚Äçüë©‚Äçüëß‚Äçüë¶ ü§´ C√≥mo convertir im√°genes de sat√©lite en mapas. Visi√≥n por computadora en Yandex üë©üèΩ‚Äçüöí üîü üçπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una de las principales fuentes de datos para el servicio Yandex.Maps son las im√°genes satelitales. Para facilitar el trabajo con el mapa, los objetos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo convertir im√°genes de sat√©lite en mapas. Visi√≥n por computadora en Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/431108/">  Una de las principales fuentes de datos para el servicio Yandex.Maps son las im√°genes satelitales.  Para facilitar el trabajo con el mapa, los objetos est√°n marcados con pol√≠gonos en las im√°genes: bosques, estanques, calles, casas, etc. Por lo general, los cart√≥grafos se dedican al marcado.  Decidimos ayudarlos y ense√±arles a la computadora a agregar pol√≠gonos de casas sin la participaci√≥n de personas. <br><br>  Para operaciones con im√°genes cumple con el campo de TI, que se llama visi√≥n por computadora.  En los √∫ltimos a√±os, la mayor√≠a de las tareas en esta √°rea se han resuelto con mucho √©xito utilizando redes neuronales.  Hoy les diremos a los lectores de Habr sobre nuestra experiencia de usar redes neuronales en el mapeo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/xz/e2/rnxze2-1b6bobojodppliybmehe.jpeg"></div><a name="habracut"></a><br>  En primer lugar, entrenaremos una red neuronal, que participar√° en la segmentaci√≥n sem√°ntica, es decir, determinar√° si cada punto de la imagen de sat√©lite est√° relacionado con la casa.  ¬øPor qu√© la segmentaci√≥n sem√°ntica y no solo la detecci√≥n de objetos?  Cuando se resuelva el problema de detecci√≥n, obtendremos en la salida un conjunto de rect√°ngulos, adem√°s espec√≠ficos: dos lados son verticales, dos son horizontales.  Y las casas generalmente se rotan en relaci√≥n con los ejes de la imagen, y algunos edificios tambi√©n tienen una forma compleja. <br><br>  La tarea de segmentaci√≥n sem√°ntica ahora est√° siendo resuelta por varias redes ( <a href="">FCN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SegNet</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UNet</a> , etc.).  Solo necesita elegir cu√°l es el mejor para nosotros. <br><br>  Una vez recibida la m√°scara de la imagen satelital, seleccionamos grupos de puntos suficientemente grandes que pertenecen a las casas, los reunimos en √°reas conectadas y presentamos los l√≠mites de las √°reas en forma de vector en forma de pol√≠gonos. <br><br>  Est√° claro que la m√°scara no ser√° absolutamente precisa, lo que significa que las casas cercanas se pueden unir en un √°rea conectada.  Para hacer frente a este problema, decidimos capacitar m√°s a la red.  Ella encontrar√° en la imagen las costillas (los l√≠mites de las casas) y separar√° los edificios que est√°n pegados. <br><br>  Entonces, tal esquema surgi√≥: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7z/dw/lt/7zdwlt1z0orhy2i9fhkgifjwkcw.jpeg"></div><br>  No descartamos por completo las redes de detecci√≥n y probamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mask R-CNN</a> .  Su ventaja en comparaci√≥n con la segmentaci√≥n habitual es que la m√°scara R-CNN detecta objetos y genera una m√°scara, por lo que no hay necesidad de dividir la m√°scara com√∫n en √°reas conectadas.  Bueno, menos (como sin √©l) en la resoluci√≥n fija de la m√°scara de cada objeto, es decir, para casas grandes con un borde complejo, este borde obviamente se simplificar√°. <br><br><h2>  Las herramientas </h2><br>  Luego fue necesario decidir sobre las herramientas.  Aqu√≠ todo era bastante obvio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenCV</a> es el m√°s adecuado para tareas de visi√≥n por computadora.  La elecci√≥n de las redes neuronales es algo m√°s amplia.  Nos instalamos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tensorflow</a> .  Sus ventajas: <br><br><ul><li>  un conjunto bastante desarrollado de "cubos" listos para usar desde los cuales puede ensamblar sus redes; </li><li>  Python API, conveniente para crear r√°pidamente una estructura de red y para capacitaci√≥n; </li><li>  Se puede utilizar una red entrenada en su programa a trav√©s de una interfaz C ++ (muy pobre en comparaci√≥n con la parte de Python, pero suficiente para ejecutar redes preparadas). </li></ul><br>  Para el entrenamiento y otras computadoras pesadas, planeamos usar Nirvana, la maravillosa plataforma Yandex de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">que ya hablamos</a> . <br><br><h2>  Datacet </h2><br>  El ochenta por ciento de √©xito en trabajar con una red neuronal consiste en un buen conjunto de datos.  Entonces, para empezar, deber√≠amos haber ensamblado tal conjunto de datos.  Yandex tiene una gran cantidad de im√°genes de sat√©lite con objetos ya marcados.  Todo parece ser simple: solo suba estos datos y rec√≥jalos en un conjunto de datos.  Sin embargo, hay una advertencia. <br><br><h3>  Refinar conjunto de datos </h3><br>  Cuando una persona busca una casa en una imagen satelital, lo primero que ve es el techo.  Pero la altura de las casas var√≠a, el sat√©lite puede tomar el mismo terreno desde diferentes √°ngulos, y si colocamos un pol√≠gono correspondiente al techo en el mapa vectorial, no hay garant√≠a de que el techo no se vaya cuando se actualice la imagen.  Pero la base est√° excavada en el suelo y, desde cualquier √°ngulo que la quite, todo el tiempo permanece en un solo lugar.  Es por eso que las casas en el vector Yandex.Map est√°n marcadas "en los cimientos".  Esto es correcto, pero para la tarea de segmentar im√°genes es mejor ense√±ar a la red a buscar techos: la esperanza de que la red est√© capacitada para reconocer los cimientos es muy peque√±a.  Por lo tanto, en el conjunto de datos, todo debe estar marcado en los techos.  Por lo tanto, para crear un buen conjunto de datos, necesitamos aprender c√≥mo cambiar el dise√±o vectorial de las casas desde los cimientos hasta los techos. <br><br>  <i>Intentamos no cambiar, pero la calidad no era muy buena, y esto es comprensible: los √°ngulos de disparo del sat√©lite son diferentes, las alturas de las casas son diferentes, como resultado, en las fotograf√≠as la base se movi√≥ en diferentes direcciones y a diferentes distancias del techo.</i>  <i>La red se pierde de tanta variedad y, en el mejor de los casos, entrena para algo intermedio, en el peor de los casos, para algo incomprensible.</i>  <i>Adem√°s, la red para la segmentaci√≥n sem√°ntica produce un resultado similar a algo aceptable, pero al buscar bordes, la calidad disminuye dr√°sticamente.</i> <br><br><h4>  Enfoque de trama </h4><br>  Desde que entramos en el campo de la visi√≥n por computadora, lo primero que hicimos fue probar un enfoque relevante para esta visi√≥n por computadora.  Primero, el mapa vectorial est√° rasterizado (los pol√≠gonos de las casas se dibujan con l√≠neas blancas sobre fondo negro), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el filtro Sobel</a> selecciona los bordes en la imagen de sat√©lite.  Y luego hay un desplazamiento de dos im√°genes entre s√≠, lo que maximiza la correlaci√≥n entre ellas.  Los bordes despu√©s del filtro Sobel son bastante ruidosos, por lo tanto, si este enfoque se aplica a un edificio, no siempre se obtiene un resultado aceptable.  Sin embargo, el m√©todo funciona bien en territorios con edificios de la misma altura: si busca un desplazamiento inmediatamente sobre un √°rea grande de la imagen, el resultado ser√° m√°s estable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7q/re/nq/7qrenqshfovrbc1y84j0y_5q7do.jpeg"></div><br><h4>  Enfoque "geom√©trico" </h4><br>  Si el territorio se construye no con el mismo tipo, sino con varias casas, el m√©todo anterior no funcionar√°.  Afortunadamente, a veces sabemos la altura de los edificios en el mapa vectorial de Yandex y la posici√≥n del sat√©lite durante el disparo.  Por lo tanto, podemos usar el conocimiento escolar de geometr√≠a y calcular d√≥nde y a qu√© distancia se mover√° el techo en relaci√≥n con la base.  Este m√©todo ha mejorado el conjunto de datos en √°reas con edificios de gran altura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/v3/wp/inv3wppmsi5dhhk5jcbmiwymqas.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/kj/_h/yqkj_h0okr891jlbdoaljqfhfsu.jpeg"></div><br><h4>  Enfoque "manual" </h4><br>  La forma m√°s lenta: arremangarse, destapar el mouse, mirar el monitor y cambiar manualmente el dise√±o vectorial de las casas desde los cimientos hasta los techos.  La t√©cnica trae un resultado que es simplemente sorprendente en calidad, pero no se recomienda usarlo en grandes cantidades: los desarrolladores que se dedican a tales tareas r√°pidamente caen en la apat√≠a y pierden inter√©s en la vida. <br><br><h4>  Red neuronal </h4><br>  Al final, obtuvimos suficientes im√°genes de sat√©lite, bien marcadas en los techos.  Entonces, hubo una oportunidad de entrenar la red neuronal (por ahora, sin embargo, no para la segmentaci√≥n, sino para mejorar el dise√±o de otras im√°genes de sat√©lite).  Y lo hicimos <br><br>  Los datos de entrada de la red neuronal convolucional fueron una imagen satelital y una marca rasterizada desplazada.  En la salida, recibimos un vector bidimensional: desplazamientos verticales y horizontales. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ad/qy/i9/adqyi95ityf_cueqvd-f2krrknk.png"></div><br>  Con la ayuda de una red neuronal, encontramos el desplazamiento necesario, lo que nos permiti√≥ lograr buenos resultados en edificios para los que la altura no est√° indicada.  Como resultado, redujimos significativamente la correcci√≥n de marcado manual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s6/tj/v1/s6tjv13fffnmhkxrs7etzhiv1g0.jpeg"></div><br><h3>  Diferentes territorios - diferentes casas </h3><br>  Hay muchos territorios y estados interesantes en Yandex.Maps.  Pero incluso en Rusia, las casas son extremadamente diversas, lo que afecta su aspecto en las im√°genes satelitales.  Por lo tanto, debe reflejar la diversidad en el conjunto de datos.  E inicialmente no entendimos realmente c√≥mo hacer frente a todo este esplendor.  ¬øRecopilar un gran conjunto de datos y luego entrenar una red en √©l?  ¬øCrea su propio conjunto de datos para cada tipo de desarrollo (condicional) y forma una red separada?  ¬øEntrenar una determinada red central y luego entrenarla para un tipo espec√≠fico de desarrollo? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/pa/fd/nypafdcjqd3vny1_uqpujrfn0ci.jpeg"></div><br>  Emp√≠ricamente, encontramos que: <br><br><ol><li>  Sin lugar a dudas, es necesario expandir el conjunto de datos para diferentes tipos de edificios en los que se planea utilizar la herramienta.  Una red capacitada en un tipo es capaz de distinguir edificios de otro tipo, aunque de manera muy pobre. </li><li>  Es mejor entrenar una gran red en todo el conjunto de datos.  Se generaliza bastante bien a varios territorios.  Si entrena redes separadas para cada tipo de desarrollo, la calidad seguir√° siendo la misma o apenas mejorar√°.  Por lo tanto, no tiene sentido implementar diferentes redes para diferentes territorios.  Adem√°s, esto requiere m√°s datos y un clasificador adicional del tipo de desarrollo. </li><li>  Si usa redes antiguas al agregar nuevos territorios a los datos, las redes aprenden mucho m√°s r√°pido.  Volver a entrenar redes antiguas en datos extendidos genera aproximadamente el mismo resultado que entrenar una red desde cero, pero requiere mucho menos tiempo. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vk/_v/zq/vk_vzq0fxfhcjlusrbqjjqhnfre.jpeg"></div><br><h2>  Opciones de solucion </h2><br><h3>  Segmentaci√≥n sem√°ntica </h3><br>  La segmentaci√≥n sem√°ntica es una tarea bastante bien investigada.  Despu√©s de la aparici√≥n del art√≠culo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Redes totalmente convolucionales</a> , se resuelve principalmente mediante redes neuronales.  Todo lo que queda es elegir una red (consideramos <a href="">FCN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SegNet</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UNet</a> ), pensar si necesitamos trucos adicionales como CRF en la salida y decidir c√≥mo y con qu√© funci√≥n de error se capacitar√° la capacitaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/un/ay/gn/unaygnyzsdhk_2dbk4qq2-2m340.png"></div><br>  Como resultado, nos decidimos por una arquitectura similar a U-Net con una funci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intersecci√≥n generalizada sobre uni√≥n</a> como una funci√≥n de error.  Para el entrenamiento, cortamos las im√°genes satelitales y sus marcas correspondientes (por supuesto, rasterizadas) en cuadrados y los ensamblamos en conjuntos de datos.  Result√≥ bastante agradable, y a veces bien. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z1/rv/ub/z1rvubhjv5xcruynmvarimca3zy.jpeg"></div><br>  En los territorios con edificios individuales, la segmentaci√≥n sem√°ntica fue suficiente para pasar a la siguiente etapa: la vectorizaci√≥n.  Donde el edificio es denso, las casas a veces se juntan en un √°rea cohesiva.  Tom√≥ separarlos. <br><br><h3>  Detecci√≥n de bordes </h3><br>  Para hacer frente a esta tarea, puede encontrar los bordes en la imagen.  Para detectar bordes, tambi√©n decidimos entrenar la red (los algoritmos de b√∫squeda de bordes que no usan redes neuronales son claramente una cosa del pasado).  Se form√≥ una red de tipo HED, que se describe en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Detecci√≥n de bordes anidada hol√≠sticamente</a> .  En el art√≠culo original, la red recibi√≥ capacitaci√≥n sobre el conjunto de datos BSDS-500, en el que todos los bordes est√°n marcados en las im√°genes.  Una red entrenada encuentra todos los bordes pronunciados: los l√≠mites de las casas, carreteras, lagos, etc. Esto ya es suficiente para separar los edificios cercanos.  Pero decidimos ir m√°s all√° y usar el mismo conjunto de datos para el entrenamiento que para la segmentaci√≥n sem√°ntica, pero al rasterizar, no pinte los pol√≠gonos completos de los edificios, sino que dibuje solo sus l√≠mites. <br><br>  El resultado fue tan abrumadoramente hermoso que decidimos vectorizar los edificios directamente por los bordes recibidos de la red.  Y sucedi√≥ bastante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/am/uz/h-/amuzh-xo7mzssz9jtzkppm3_nag.jpeg"></div><br><h3>  Detecci√≥n de v√©rtices </h3><br>  Como una red como HED dio un excelente resultado en los bordes, decidimos entrenarla para detectar v√©rtices.  De hecho, tenemos una red con pesos generales en capas convolucionales.  Ten√≠a dos salidas al mismo tiempo: para bordes y para picos.  Como resultado, hicimos otra versi√≥n de la vectorizaci√≥n de edificios, y en algunos casos mostr√≥ resultados bastante sanos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fj/50/wl/fj50wlerknjc02f8cnhgguizu2o.jpeg"></div><br><h3>  M√°scara r-cnn </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mask R-CNN</a> es una expansi√≥n relativamente nueva de redes como Faster R-CNN.  M√°scara R-CNN busca objetos y selecciona una m√°scara para cada uno de ellos.  Como resultado, para las casas obtenemos no solo rect√°ngulos delimitadores, sino tambi√©n una estructura refinada.  Este enfoque se compara favorablemente con la detecci√≥n simple (no sabemos c√≥mo se ubica el edificio dentro del rect√°ngulo) y la segmentaci√≥n normal (varias casas pueden unirse en una, y no est√° claro c√≥mo separarlas).  Con la m√°scara R-CNN, ya no necesita pensar en trucos adicionales: es suficiente con vectorizar el borde de la m√°scara para cada objeto e inmediatamente obtener el resultado.  Tambi√©n hay un signo negativo: el tama√±o de la m√°scara para el objeto siempre es fijo, es decir, para edificios grandes, la precisi√≥n del dise√±o de p√≠xeles ser√° baja.  El resultado de Mask R-CNN se ve as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/it/8v/4w/it8v4wy0axix-hpi2gfxkomo3nk.jpeg"></div><br>  Probamos la m√°scara R-CNN en √∫ltimo lugar y nos aseguramos de que para algunos tipos de edificios este enfoque supere a otros. <br><br><h2>  Vectorizaci√≥n </h2><br><h3>  Vectorizaci√≥n Rect√°ngulo </h3><br>  Con toda la diversidad arquitect√≥nica moderna, las casas en im√°genes satelitales todav√≠a parecen rect√°ngulos.  Adem√°s, para la masa de territorios, no es necesario marcar con pol√≠gonos complejos.  Pero aun as√≠ quiero que se marquen las casas en el mapa.  (Bueno, por ejemplo, una asociaci√≥n hort√≠cola: generalmente hay muchas casas all√≠, marcar manualmente no es tan importante, pero marcar con rect√°ngulos en el mapa es muy bueno). Por lo tanto, el primer enfoque para la vectorizaci√≥n fue extremadamente simple. <br><br><ol><li>  Tome la regi√≥n r√°ster correspondiente a la "casa". </li><li>  Encuentre el rect√°ngulo del √°rea m√≠nima que contiene esta √°rea (por ejemplo, as√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenCV :: minAreaRect</a> ).  El problema est√° resuelto. </li></ol><br>  Est√° claro que la calidad de este enfoque est√° lejos de ser ideal.  Sin embargo, el algoritmo es bastante simple y en muchos casos funciona. <br><br><h3>  Vectorizaci√≥n de pol√≠gonos </h3><br>  Si la calidad de la segmentaci√≥n es lo suficientemente buena, puede recrear con mayor precisi√≥n el contorno de la casa.  En la mayor√≠a de los edificios de forma compleja, los √°ngulos son en su mayor√≠a correctos, por lo que decidimos reducir el problema a la tarea de construir un pol√≠gono con lados ortogonales.  Resolvi√©ndolo, queremos lograr dos objetivos a la vez: encontrar el pol√≠gono m√°s simple y repetir la forma de los edificios con la mayor precisi√≥n posible.  Estos objetivos entran en conflicto entre s√≠, por lo que debe introducir condiciones adicionales: limitar la longitud m√≠nima de las paredes, la desviaci√≥n m√°xima de la regi√≥n r√°ster, etc. <br><br>  El algoritmo que se nos ocurri√≥ por primera vez se bas√≥ en la construcci√≥n de la proyecci√≥n de puntos en l√≠neas rectas: <br><br><ol><li>  Encuentre el contorno de la regi√≥n r√°ster correspondiente a una casa. </li><li>  Reduzca el n√∫mero de puntos en el circuito simplific√°ndolo, por ejemplo, con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el algoritmo Douglas-Pecker</a> . </li><li>  Encuentra el lado m√°s largo del contorno.  Es su √°ngulo de inclinaci√≥n lo que determinar√° el √°ngulo de todo el futuro pol√≠gono ortogonal. </li><li>  Construya una proyecci√≥n desde el siguiente punto de contorno hasta el lado anterior. </li><li>  Extienda el lado al punto de proyecci√≥n.  Si la distancia desde el punto hasta su proyecci√≥n es mayor que la pared m√°s corta del edificio, agregue el segmento resultante al contorno del edificio. </li><li>  Repita los pasos 4 y 5 hasta que se cierre el circuito. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/ok/y5/eyoky5b1d4ayzcflogdwsxfyi8g.png"></div><br>  Este algoritmo es extremadamente simple y produce resultados r√°pidamente, pero a√∫n as√≠ el contorno del edificio a veces resulta ser bastante ruidoso.  Al tratar de hacer frente a este problema, encontramos una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soluci√≥n</a> bastante interesante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para el</a> problema, que utiliza una cuadr√≠cula cuadrada en el espacio para aproximar el pol√≠gono.  Descrito brevemente, el algoritmo consta de tres acciones: <br><br><ol><li>  Construya una cuadr√≠cula cuadrada en el espacio centrado en cero. </li><li>  En los puntos de la cuadr√≠cula que se encuentran a una distancia determinada del contorno original, construya diferentes pol√≠gonos. </li><li>  Seleccione un pol√≠gono con un n√∫mero m√≠nimo de v√©rtices. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5f/em/ti/5femtieuuectay9wjhoncxi2rh4.png"></div><br>  Dado que el √°ngulo de rotaci√≥n requerido de la cuadr√≠cula no se conoce de antemano, es necesario clasificar varios valores, lo que afecta mal el rendimiento.  Sin embargo, el algoritmo le permite lograr resultados visualmente m√°s hermosos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yz/rb/u1/yzrbu1in149ocfxxmdv_h6gctug.jpeg"></div><br><h2>  Mejora de vectorizaci√≥n </h2><br>  Si bien en realidad trabajamos con cada casa por separado.  Cuando se completa la primera etapa, ya puede trabajar con la imagen como un todo y mejorar el resultado.  Para esto, se ha agregado un algoritmo para el procesamiento posterior de un conjunto de pol√≠gonos.  Utilizamos las siguientes heur√≠sticas: <br><br><ul><li>  Por lo general, las paredes de las casas adyacentes son paralelas.  Adem√°s: con mayor frecuencia, las casas se pueden combinar en conjuntos, dentro de los cuales se alinean todos los elementos. </li><li>  Si las calles ya est√°n marcadas en la imagen, es muy probable que los lados de los pol√≠gonos sean paralelos a las calles. </li><li>  Si los pol√≠gonos se cruzan, lo m√°s probable es que tenga sentido mover los muros para que la intersecci√≥n desaparezca. </li></ul><br>  Como resultado, apareci√≥ el siguiente algoritmo: <br><br><ol><li>  Agrupamos las casas encontradas por la distancia entre ellas y el √°ngulo de rotaci√≥n.  Hacemos un promedio de las vueltas de los edificios en cada grupo.  Repetimos hasta que la posici√≥n de los edificios deje de cambiar o hasta que las casas comiencen a desviarse demasiado de la posici√≥n inicial. </li><li>  Elegimos casas cerca de las carreteras, encontramos las m√°s largas y cercanas a la carretera.  Llevamos la casa al paralelismo del lado seleccionado y el camino. </li><li>  Eliminamos las intersecciones entre los pol√≠gonos, desplazando los lados de dos edificios que se cruzan en proporci√≥n al tama√±o de los lados. </li></ol><br><h2>  Resultado </h2><br>  Como resultado, obtuvimos una herramienta que puede reconocer edificios de varios tipos de edificios.  Ayuda a los cart√≥grafos en su arduo trabajo: acelera significativamente la b√∫squeda de casas faltantes y rellena √°reas nuevas, a√∫n no cultivadas.  Actualmente, se han agregado m√°s de 800 mil objetos nuevos al Mapa de personas utilizando esta herramienta. <br><br>  A continuaci√≥n ver√° algunos ejemplos de reconocimiento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bn/pk/o0/bnpko0puk1vcvnd1oxanqo7pvty.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nr/qi/q5/nrqiq5mdh2wl8fjaqmr28sn0oys.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xz/3a/iw/xz3aiwhlc_g1lo_huyb8yml_6ms.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/xz/e2/rnxze2-1b6bobojodppliybmehe.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jm/_j/cv/jm_jcvdv8pxm60tlwmoj2hmcgjc.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9x/k_/u3/9xk_u3nlc82ymdbtht8ebtbx6ue.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mw/zk/8g/mwzk8g2ga_798vg986flckxculo.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/37/gu/ue37gu16xwfvt3zqh0akmtmxnyi.jpeg"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431108/">https://habr.com/ru/post/es431108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431096/index.html">C√≥mo construir un producto de chat bot</a></li>
<li><a href="../es431098/index.html">Incluso un incendio no es un obst√°culo, o Zimbra Speed ‚Äã‚ÄãRecovery despu√©s de un desastre</a></li>
<li><a href="../es431102/index.html">C√≥mo se muestra la direcci√≥n f√≠sica en cadenas y bancos DRAM</a></li>
<li><a href="../es431104/index.html">C√≥mo en Neoflex desarrollamos la experiencia de DevOps</a></li>
<li><a href="../es431106/index.html">¬øCu√°nto dinero gastaron los estadounidenses este Black Friday y qu√© tienen que ver los tel√©fonos inteligentes con √©l?</a></li>
<li><a href="../es431110/index.html">Deja de alimentar a los editores. La UE est√° desarrollando normas para el libre acceso obligatorio a la investigaci√≥n.</a></li>
<li><a href="../es431112/index.html">C√≥mo utilizar m√©todos de m√≠nimos cuadrados para evaluar recursos y monitorear bases de datos Oracle</a></li>
<li><a href="../es431116/index.html">Quiero extra√±o: revisi√≥n de la pr√≥xima conferencia DartUP en San Petersburgo</a></li>
<li><a href="../es431118/index.html">Toda la verdad sobre RTOS. Art√≠culo # 22. Buzones: servicios auxiliares y estructuras de datos</a></li>
<li><a href="../es431120/index.html">Sufrir en el trabajo no es necesario.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>