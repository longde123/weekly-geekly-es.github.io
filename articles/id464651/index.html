<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ½â€âš•ï¸ ğŸ¦ ğŸ‘ƒğŸ¼ Perpustakaan generator kode assembler untuk mikrokontroler AVR. Bagian 5 ğŸ” ğŸ†— ğŸˆº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="â† Bagian 4. Memprogram perangkat dan menangani interupsi 
 Perpustakaan Generator Kode Assembler untuk Mikrokontroler AVR 
 Bagian 5. Merancang aplika...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perpustakaan generator kode assembler untuk mikrokontroler AVR. Bagian 5</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464651/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">â† Bagian 4. Memprogram perangkat dan menangani interupsi</a> </p><br><h2 id="biblioteka-generatora-assemblernogo-koda-dlya-mikrokontrollerov-avr">  Perpustakaan Generator Kode Assembler untuk Mikrokontroler AVR </h2><br><h3 id="chast-5-proektirovanie-mnogopotochnyh-prilozheniy">  Bagian 5. Merancang aplikasi multi-utas </h3><br><p>  Pada bagian sebelumnya dari artikel ini, kami menguraikan dasar-dasar pemrograman menggunakan perpustakaan.  Di bagian sebelumnya, kami berkenalan dengan implementasi interupsi dan batasan yang mungkin muncul saat bekerja dengan mereka.  Di bagian postingan ini, kita akan membahas salah satu opsi yang mungkin untuk memprogram proses paralel menggunakan kelas <em>Paralel</em> .  Penggunaan kelas ini memungkinkan untuk menyederhanakan pembuatan aplikasi di mana data harus diproses di beberapa aliran program independen. </p><a name="habracut"></a><br><p>  Semua sistem multitasking untuk sistem single-core mirip satu sama lain.  Multithreading diimplementasikan melalui pekerjaan dispatcher, yang mengalokasikan slot waktu untuk setiap utas, dan ketika selesai, ia mengambil kendali dan memberikan kendali ke utas berikutnya.  Perbedaan antara berbagai implementasi hanya pada detailnya, jadi kami akan membahas lebih detail terutama pada fitur-fitur spesifik dari implementasi ini. </p><br><p>  Unit pelaksanaan proses di utas adalah tugas.  Jumlah tugas yang tidak terbatas dapat ada dalam sistem, tetapi pada waktu tertentu hanya sejumlah tugas yang dapat diaktifkan, dibatasi oleh jumlah alur kerja di operator.  Dalam implementasi ini, jumlah alur kerja ditentukan dalam konstruktor manajer dan selanjutnya tidak dapat diubah.  Dalam prosesnya, utas dapat melakukan tugas atau tetap gratis.  Tidak seperti solusi lain, <em>Parallel</em> Manager tidak berganti tugas.  Agar tugas mengembalikan kontrol ke operator, perintah yang sesuai harus dimasukkan dalam kodenya.  Dengan demikian, tanggung jawab untuk durasi slot waktu dalam tugas ada pada programmer, yang harus memasukkan perintah interupsi di tempat-tempat tertentu dalam kode jika tugas tersebut terlalu lama, dan juga menentukan perilaku utas setelah menyelesaikan tugas.  Keuntungan dari pendekatan ini adalah bahwa programmer mengontrol titik-titik peralihan di antara tugas-tugas, yang memungkinkan Anda untuk secara signifikan mengoptimalkan kode simpan / mengembalikan ketika berpindah tugas, serta menyingkirkan sebagian besar masalah yang terkait dengan akses data yang aman untuk thread. </p><br><p>  Untuk mengontrol pelaksanaan tugas yang sedang berjalan, kelas <em>Sinyal</em> khusus digunakan.  Sinyal adalah variabel bit, pengaturan yang digunakan sebagai sinyal aktif untuk memulai tugas dalam aliran.  Nilai sinyal dapat diatur baik secara manual atau oleh peristiwa yang terkait dengan sinyal ini. </p><br><p>  Sinyal diatur ulang ketika tugas diaktifkan oleh operator atau dapat dilakukan secara terprogram. </p><br><p>  Tugas dalam sistem dapat dalam status berikut: </p><br><p>  <strong>Deactivated</strong> - state awal untuk semua tugas.  Tugas tidak mengambil aliran dan kontrol pelaksanaan tidak ditransfer.  Kembali ke keadaan ini untuk tugas yang diaktifkan terjadi setelah perintah selesai. </p><br><p>  <strong>Diaktifkan</strong> - keadaan di mana tugas itu berada setelah aktivasi.  Proses aktivasi mengaitkan tugas dengan utas eksekusi dan sinyal aktivasi.  Manajer polling utas dan memulai tugas jika sinyal tugas diaktifkan. </p><br><p>  <strong>Diblokir</strong> - saat tugas diaktifkan, sinyal mungkin sudah ditetapkan sebagai sinyal, yang sudah digunakan untuk mengontrol utas lainnya.  Dalam hal ini, untuk menghindari ambiguitas perilaku program, tugas yang diaktifkan masuk ke keadaan terkunci.  Dalam keadaan ini, tugas menempati utas, tetapi tidak dapat menerima kontrol, bahkan jika sinyalnya diaktifkan.  Setelah menyelesaikan tugas atau ketika mengubah sinyal aktivasi, operator memeriksa dan mengubah status tugas di utas.  Jika utas telah memblokir tugas yang sinyalnya cocok dengan yang dilepaskan, yang pertama ditemukan diaktifkan.  Jika perlu, pemrogram dapat mengunci dan membuka kunci tugas secara independen, berdasarkan pada logika program yang diperlukan. </p><br><p>  <strong>Menunggu</strong> - status tugas setelah menjalankan perintah <em>Delay</em> .  Dalam keadaan ini, tugas tidak menerima kontrol sampai interval yang diperlukan telah berlalu.  Di kelas <em>Paralel</em> , interupsi WDT 16 ms digunakan untuk mengontrol penundaan, yang memungkinkan untuk tidak menggunakan timer untuk kebutuhan sistem.  Jika Anda membutuhkan lebih banyak stabilitas atau resolusi dalam interval kecil, alih-alih <em>Tunda,</em> Anda dapat menggunakan aktivasi dengan sinyal timer.  Harus diingat bahwa keakuratan penundaan masih rendah dan akan berfluktuasi dalam kisaran <em>"waktu respons operator" - "durasi slot waktu maksimum dalam sistem + waktu respons operator"</em> .  Untuk tugas dengan rentang waktu yang tepat, mode hybrid harus digunakan, di mana timer tidak digunakan di kelas <em>Paralel</em> bekerja secara independen dari aliran tugas dan memproses interval dalam mode interrupt murni. </p><br><p>  Setiap tugas yang dijalankan dalam utas adalah proses yang terisolasi.  Ini memerlukan definisi dari dua jenis data: data lokal dari suatu aliran, yang harus terlihat dan diubah hanya dalam kerangka aliran ini, dan data global untuk pertukaran antara aliran dan akses ke sumber daya bersama.  Dalam kerangka implementasi ini, data global dibuat oleh perintah yang sebelumnya dianggap di tingkat perangkat.  Untuk membuat variabel tugas lokal, mereka harus dibuat menggunakan metode dari kelas tugas.  Perilaku variabel tugas lokal adalah sebagai berikut: ketika tugas terputus sebelum mentransfer kontrol ke operator, semua variabel register lokal disimpan dalam memori stream.  Ketika kontrol dikembalikan, variabel register lokal dikembalikan sebelum perintah berikutnya dijalankan. <br>  Kelas dengan antarmuka <em>IHeap yang</em> terkait dengan properti <em>Heap</em> dari kelas <em>Paralel</em> bertanggung jawab untuk menyimpan data lokal dari aliran.  Implementasi paling sederhana dari kelas ini adalah <em>StaticHeap</em> , yang mengimplementasikan alokasi statis dari blok memori yang sama untuk setiap utas.  Jika tugas memiliki penyebaran besar sesuai dengan permintaan untuk jumlah data lokal, Anda dapat menggunakan <em>DynamicHeap</em> , yang memungkinkan Anda untuk menentukan ukuran memori lokal secara individual untuk setiap tugas.  Jelas, overhead bekerja dengan memori aliran dalam hal ini akan jauh lebih tinggi. </p><br><p>  Sekarang mari kita melihat lebih dekat pada sintaks kelas menggunakan dua aliran sebagai contoh, yang masing-masing secara independen beralih output port terpisah. </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328 { FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>, CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; m.PortB.Direction(<span class="hljs-number"><span class="hljs-number">0x07</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit1 = m.PortB[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit2 = m.PortB[<span class="hljs-number"><span class="hljs-number">2</span></span>]; m.PortB.Activate(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">2</span></span>); tasks.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(tasks, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit1.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">32</span></span>); tsk.TaskContinue(loop); },<span class="hljs-string"><span class="hljs-string">"Task1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit2.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">48</span></span>); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"Task2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ca = tasks.ContinuousActivate(tasks.AlwaysOn, t1); tasks.ActivateNext(ca, tasks.AlwaysOn, t2); ca.Dispose(); m.EnableInterrupt(); tasks.Loop();</code> </pre> <br><p>  Baris teratas dari program ini sudah tidak asing lagi bagi Anda.  Di dalamnya, kami menentukan jenis pengontrol dan menetapkan bit pertama dan kedua port B sebagai output.  Berikutnya adalah inisialisasi variabel kelas <em>Paralel</em> , di mana pada parameter kedua kita menentukan jumlah maksimum utas eksekusi.  Pada baris berikutnya, kami mengalokasikan memori untuk mengakomodasi aliran variabel lokal.  Kami memiliki tugas yang sama, jadi kami menggunakan <em>StaticHeap</em> .  Blok kode berikutnya adalah definisi tugas.  Di dalamnya, kita mendefinisikan dua tugas yang hampir identik.  Satu-satunya perbedaan adalah port kontrol dan jumlah penundaan.  Untuk bekerja dengan objek tugas lokal, sebuah pointer ke <em>tsk</em> tugas lokal dilewatkan ke <em>blok kode</em> tugas.  Teks tugas itu sendiri sangat sederhana: </p><br><ul><li>  label lokal dibuat untuk mengatur siklus switching yang tak terbatas </li><li>  status port dibalik </li><li>  kontrol dikembalikan ke operator, dan tugas masuk ke status menunggu untuk jumlah milidetik yang ditentukan </li><li>  Pointer kembali diatur ke blok awal blok dan kontrol dikembalikan ke operator. <br>  Jelas, dalam contoh konkret, perintah terakhir dapat diganti dengan perintah normal untuk pergi ke awal blok dan diberikan dalam contoh hanya untuk tujuan menunjukkannya.  Jika diinginkan, contoh dapat dengan mudah diperluas untuk mengontrol sejumlah besar kesimpulan, dengan menyalin tugas dan meningkatkan jumlah utas. </li></ul><br><p>  Daftar lengkap perintah pembatalan tugas untuk mentransfer kontrol ke operator adalah sebagai berikut <br>  <strong>AWAIT (signal)</strong> - stream menyimpan semua variabel dalam memori stream dan mentransfer kontrol ke dispatcher.  Kali berikutnya aliran diaktifkan, variabel dikembalikan dan eksekusi berlanjut, dimulai dengan instruksi berikutnya setelah <em>AWAIT</em> .  Perintah ini dirancang untuk membagi tugas ke dalam slot waktu dan untuk mengimplementasikan mesin keadaan sesuai dengan skema. <em>Sinyal â†’ Pemrosesan 1 â†’ Sinyal â†’ Pemrosesan 2</em> , dll. </p><br><p>  Perintah AWAIT mungkin memiliki sinyal sebagai parameter opsional.  Jika parameter kosong, sinyal aktivasi disimpan.  Jika ditentukan dalam parameter, maka semua panggilan tugas selanjutnya akan dilakukan ketika sinyal yang ditentukan diaktifkan, dan komunikasi dengan sinyal sebelumnya terputus. </p><br><p>  <strong>TaskContinue (label, signal)</strong> - perintah menghentikan streaming dan memberikan kontrol kepada operator tanpa menyimpan variabel.  Lain kali aliran diaktifkan, kontrol ditransfer ke label <em>label</em> .  Parameter <em>Sinyal</em> opsional memungkinkan Anda mengganti sinyal aktivasi streaming untuk panggilan berikutnya.  Jika tidak ditentukan, sinyalnya tetap sama.  Perintah tanpa menentukan sinyal dapat digunakan untuk mengatur siklus dalam satu tugas, di mana setiap siklus dilakukan dalam slot waktu yang terpisah.  Itu juga dapat digunakan untuk menetapkan tugas baru ke utas saat ini setelah menyelesaikan yang sebelumnya.  Keuntungan dari pendekatan ini dibandingkan dengan siklus <em>Membebaskan utas â†’ Menyoroti aliran</em> adalah program yang lebih efisien.  Menggunakan <em>TaskContinue</em> menghilangkan kebutuhan bagi manajer untuk mencari utas gratis di kolam renang dan menjamin kesalahan ketika mencoba mengalokasikan utas tanpa adanya utas gratis. </p><br><p>  <strong>TaskEnd ()</strong> - menghapus aliran setelah tugas selesai.  Tugas berakhir, utas dibebaskan, dan dapat digunakan untuk menetapkan tugas baru dengan perintah <em>Aktifkan</em> . </p><br><p>  <strong>Delay (ms)</strong> - stream, seperti dalam kasus menggunakan <em>AWAIT</em> , menyimpan semua variabel dalam memori stream dan mentransfer kontrol ke dispatcher.  Dalam kasus ini, nilai penundaan dalam milidetik direkam di header aliran.  Di loop dispatcher, dalam kasus nilai yang tidak nol di bidang penundaan, aliran tidak diaktifkan.  Mengubah nilai dalam bidang penundaan untuk semua aliran dilakukan dengan memotong timer WDT setiap 16 ms.  Ketika nilai nol tercapai, larangan eksekusi dihapus dan sinyal aktivasi aliran diatur.  Hanya nilai byte tunggal untuk penundaan yang disimpan dalam header, yang memberikan kisaran kemungkinan penundaan yang relatif sempit, oleh karena itu, untuk menerapkan penundaan yang lebih lama, <em>Delay ()</em> membuat loop internal menggunakan variabel aliran lokal. <br>  Aktivasi perintah dalam contoh dilakukan menggunakan perintah <em>ContinuousActivate</em> dan <em>ActivateNext</em> .  Ini adalah jenis khusus aktivasi tugas awal saat startup.  Pada tahap aktivasi awal, kami dijamin tidak memiliki utas sibuk tunggal, sehingga proses aktivasi tidak memerlukan pencarian pendahuluan untuk utas gratis untuk suatu tugas dan memungkinkan Anda untuk mengaktifkan tugas secara berurutan.  <em>ContinuousActivate</em> mengaktifkan tugas di utas nol dan mengembalikan pointer ke header utas berikutnya, dan fungsi <em>ActivateNext</em> menggunakan pointer ini untuk mengaktifkan tugas berikut dalam utas berurutan. </p><br><p>  Sebagai sinyal aktivasi, contoh menggunakan sinyal <em>AlwaysOn</em> .  Ini adalah salah satu sinyal sistem.  Tujuannya berarti bahwa tugas akan selalu dieksekusi, karena ini adalah satu-satunya sinyal yang selalu diaktifkan dan tidak diatur ulang saat digunakan. </p><br><p>  Contoh ini diakhiri dengan panggilan <em>Loop</em> .  Fungsi ini memulai siklus operator, jadi perintah ini harus menjadi yang terakhir dalam kode. </p><br><p>  Pertimbangkan contoh lain di mana penggunaan perpustakaan dapat secara signifikan menyederhanakan struktur kode.  Biarkan itu menjadi perangkat kontrol bersyarat yang mendaftarkan sinyal analog dan mengirimkannya dalam bentuk kode HEX ke terminal. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cData = m.DREG(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outDigit = m.ARRAY(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chex = Const.String(<span class="hljs-string"><span class="hljs-string">"0123456789ABCDEF"</span></span>); m.ADC.Clock = eADCPrescaler.S64; m.ADC.ADCReserved = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; m.ADC.Source = eASource.ADC0; m.Usart.Baudrate = <span class="hljs-number"><span class="hljs-number">9600</span></span>; m.Usart.FrameFormat = eUartFrame.U8N1; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> os = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">4</span></span>); os.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(os, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ADS = os.AddSignal(m.ADC.Handler, () =&gt; m.ADC.Data(cData)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trm = os.AddSignal(m.Usart.TXC_Handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> starts = os.AddLocker(); os.PrepareSignals(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t0 = os.CreateTask((tsk) =&gt; { m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r, l) =&gt; { m.ADC.ConvertAsync(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">500</span></span>); }); }, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mref = m.ROMPTR(); mref.Load(chex); m.TempL.Load(cData.High); m.TempL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">0</span></span>]); mref.Load(chex); m.TempL.Load(cData.High); m.TempL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">1</span></span>]); mref.Load(chex); m.TempL.Load(cData.Low); m.TempL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">2</span></span>]); mref.Load(chex); m.TempL.Load(cData.Low); m.TempL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">3</span></span>]); starts.Set(); tsk.TaskContinue(loop); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); trm.Clear(); m.TempL.Load(<span class="hljs-string"><span class="hljs-string">'0'</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(trm); m.TempL.Load(<span class="hljs-string"><span class="hljs-string">'x'</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">0</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">1</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">2</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">3</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.Load(<span class="hljs-number"><span class="hljs-number">13</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.Load(<span class="hljs-number"><span class="hljs-number">10</span></span>); m.Usart.Transmit(m.TempL); tsk.TaskContinue(loop, starts); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = os.ContinuousActivate(os.AlwaysOn, t0); os.ActivateNext(p, ADS, t1); os.ActivateNext(p, starts, t2); m.ADC.Activate(); m.Usart.Activate(); m.EnableInterrupt(); os.Loop();</code> </pre> <br><p>  Ini bukan untuk mengatakan bahwa kami melihat banyak hal baru di sini, tetapi Anda dapat melihat sesuatu yang menarik dalam kode ini. </p><br><p>  Dalam contoh ini, ADC (konverter analog-ke-digital) pertama kali disebutkan.  Perangkat periferal ini dirancang untuk mengubah tegangan sinyal input menjadi kode digital.  Siklus konversi dimulai oleh fungsi <em>ConvertAsync</em> , yang hanya memulai proses tanpa menunggu hasilnya.  Ketika konversi selesai, ADC menghasilkan interupsi yang mengaktifkan sinyal <em>adcSig</em> .  Perhatikan definisi sinyal <em>adcSig</em> .  Selain penunjuk interupsi, ini juga berisi blok kode untuk menyimpan nilai dari register data ADC.  Semua kode yang sebaiknya dijalankan segera setelah gangguan terjadi (misalnya, membaca data dari register perangkat) harus ditempatkan di tempat ini. <br>  Tugas <em>konversi</em> adalah untuk mengubah kode tegangan biner menjadi representasi HEX empat karakter untuk terminal kondisional kami.  Di sini kita dapat mencatat penggunaan fungsi untuk menggambarkan fragmen berulang untuk mengurangi ukuran kode sumber dan penggunaan string konstan untuk konversi data. </p><br><p>  Masalah <em>transmisi</em> menarik dari sudut pandang implementasi output string yang diformat di mana output data statis dan dinamis digabungkan.  Mekanisme itu sendiri tidak dapat dianggap ideal, melainkan merupakan demonstrasi kemungkinan mengelola penangan.  Di sini Anda juga dapat memperhatikan redefinisi sinyal aktivasi selama eksekusi, yang mengubah sinyal aktivasi dari <em>ConvS</em> ke <em>TxS</em> dan sebaliknya. </p><br><p>  Untuk pemahaman yang lebih baik, kami menjelaskan algoritma kata-kata dari program ini. </p><br><p>  Pada kondisi awal, kami telah meluncurkan tiga tugas.  Dua di antaranya memiliki sinyal tidak aktif, karena sinyal untuk tugas <em>konversi (adcSig)</em> diaktifkan pada akhir siklus pembacaan sinyal analog, dan <em>ConvS</em> untuk tugas <em>transmisi</em> diaktifkan oleh kode yang belum dieksekusi.  Akibatnya, tugas pertama yang akan diluncurkan setelah peluncuran akan selalu menjadi pengukuran.  Kode untuk tugas ini memulai siklus konversi ADC, setelah itu tugas 500 ms masuk ke siklus tunggu.  Di akhir siklus konversi, flag <em>adcSig diaktifkan</em> , yang memicu tugas <em>konversi</em> .  Dalam tugas ini, siklus mengubah data yang diterima ke string diimplementasikan.  Sebelum keluar dari tugas, kami mengaktifkan bendera <em>ConvS</em> , membuatnya jelas bahwa kami memiliki data baru untuk dikirim ke terminal.  Perintah keluar me-reset titik kembali ke awal tugas dan memberikan kontrol kepada operator.  <em>Set</em> bendera <em>ConvS</em> memungkinkan transfer kontrol ke tugas <em>transmisi</em> .  Setelah mentransmisikan byte pertama dari urutan, sinyal aktivasi dalam tugas berubah menjadi <em>TxS</em> .  Sebagai akibatnya, setelah transfer byte selesai, tugas transmisi akan dipanggil lagi, yang akan mengarah pada transfer byte berikutnya.  Setelah byte terakhir dari urutan ditransmisikan, tugas mengembalikan <em>sinyal</em> aktivasi <em>ConvS</em> dan mengatur ulang titik kembali ke awal tugas.  Siklus selesai.  Siklus berikutnya akan dimulai ketika tugas pengukuran selesai menunggu dan mengaktifkan siklus pengukuran berikutnya. </p><br><p>  Di hampir semua sistem multitasking, ada konsep antrian untuk interaksi antara utas.  Kami telah menemukan bahwa sejak beralih antar tugas dalam sistem ini adalah proses yang sepenuhnya terkontrol, menggunakan variabel global untuk bertukar data antar tugas sangat mungkin dilakukan.  Namun, ada sejumlah tugas di mana penggunaan antrian dibenarkan.  Karenanya, kami tidak akan mengesampingkan topik ini dan melihat bagaimana penerapannya di perpustakaan. </p><br><p>  Untuk mengimplementasikan antrian dalam suatu program, yang terbaik adalah menggunakan kelas <em>RingBuff</em> .  Kelas, seperti namanya, mengimplementasikan buffer cincin dengan perintah tulis dan ambil.  Membaca dan menulis data dilakukan oleh perintah <em>Baca</em> dan <em>Tulis</em> .  Perintah baca dan tulis tidak memiliki parameter.  Buffer menggunakan variabel register yang ditentukan dalam konstruktor sebagai sumber / penerima data.  Akses ke variabel ini dilakukan melalui parameter kelas <em>IOReg</em> .  Status buffer ditentukan oleh dua flag <em>Ovf</em> dan <em>Empty</em> , yang membantu menentukan status overflow selama penulisan dan overflow saat membaca.  Selain itu, kelas memiliki kemampuan untuk menentukan kode yang berjalan pada peristiwa overflow / overflow.  <em>RingBuff</em> tidak memiliki dependensi pada kelas <em>Paralel</em> dan dapat digunakan secara terpisah.  Batasan ketika bekerja dengan kelas adalah kapasitas yang diijinkan, yang seharusnya merupakan kelipatan dari kekuatan dua (8.16.32, dll.) Karena alasan optimasi kode. </p><br><p>  Contoh bekerja dengan kelas diberikan di bawah ini. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> io = m.REG(); <span class="hljs-comment"><span class="hljs-comment">//     16     io. var bf = new RingBuff(m, 16, io) { //    OnOverflow = () =&gt; { AVRASM.Comment("   "); }, OnEmpty = () =&gt; { AVRASM.Comment("   "); } }; var cntr = m.REG(); cntr.Load(16); //       m.LOOP(cntr, (r, l) =&gt; { cntr--; m.IFNOTEMPTY(l); },(r)=&gt; { //         //m.IF(bf.Ovf,()=&gt;{AVRASM.Comment("â€)}; bf.IOReg.Load(cntr); //      bf.Write(); //    }); //     m.LOOP(cntr, (r, l) =&gt; { m.GO(l); }, (r) =&gt; { //         //m.IF(bf.Ovf,()=&gt;{AVRASM.Comment(" â€)}; bf.Read(); //       IOReg //    });</span></span></code> </pre> <br><p>  Bagian ini menyimpulkan gambaran umum fitur perpustakaan.  Sayangnya, masih ada sejumlah aspek berkenaan dengan kemampuan perpustakaan, yang bahkan tidak disebutkan.  Di masa depan, jika tertarik dengan proyek ini, artikel direncanakan didedikasikan untuk menyelesaikan masalah spesifik menggunakan perpustakaan dan deskripsi yang lebih rinci tentang masalah kompleks yang membutuhkan publikasi terpisah. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464651/">https://habr.com/ru/post/id464651/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464641/index.html">Cara mengatur PVS-Studio di Travis CI menggunakan contoh emulator konsol game PSP</a></li>
<li><a href="../id464643/index.html">Bukan pemindaian tunggal, atau bagaimana membangun proses manajemen kerentanan dalam 9 langkah</a></li>
<li><a href="../id464645/index.html">Bagaimana mengkonfigurasi PVS-Studio di Travis CI menggunakan emulator konsol game PSP sebagai contoh</a></li>
<li><a href="../id464647/index.html">Surat Kabar Harry Potter</a></li>
<li><a href="../id464649/index.html">Sistem Kolaborasi Dokumen untuk Zimbra Open-Source Edition</a></li>
<li><a href="../id464655/index.html">Bagaimana gaji dan popularitas bahasa pemrograman telah berubah selama 2 tahun terakhir</a></li>
<li><a href="../id464657/index.html">Membalikkan cornice listrik AM82TV</a></li>
<li><a href="../id464659/index.html">Keamanan Aplikasi, atau Cara Menanamkan Keamanan dalam Pengembangan Kustom. Pengalaman pribadi di AGIMA</a></li>
<li><a href="../id464661/index.html">Kepada siapa dipercayakan desain peralatan teknis dan fasilitas rekonstruksi</a></li>
<li><a href="../id464665/index.html">Partisi dalam SQL Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>