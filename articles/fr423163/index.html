<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏿 📑 😡 Connexion de CryptoPro à Mono 👩🏽‍⚖️ 🐇 🐙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le cadre de la transition vers Linux, il est devenu nécessaire de porter l'un de nos systèmes serveurs écrits en C # vers Mono. Le système foncti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Connexion de CryptoPro à Mono</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423163/"><p>  Dans le cadre de la transition vers Linux, il est devenu nécessaire de porter l'un de nos systèmes serveurs écrits en C # vers Mono.  Le système fonctionne avec des signatures numériques améliorées, donc l'une des tâches auxquelles nous avons été confrontés était de vérifier les performances des certificats GOST de CryptoPro en mono.  CryptoPro lui-même a implémenté <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CSP</a> pour Linux depuis un certain temps, mais la première tentative d'utilisation a montré que les classes de cryptographie Mono natives (similaires à celles de la base .Net - X509Store, X509Certificate2, etc.) non seulement ne fonctionnent pas avec les clés invitées, mais même ne les voyez pas dans leurs coffres.  Pour cette raison, le travail avec la cryptographie devait être connecté directement via les bibliothèques CryptoPro. </p><br><a name="habracut"></a><br><h2>  Installation de certificat </h2><br><p>  Avant d'implémenter le code, vous devez installer le certificat et vous assurer qu'il fonctionne correctement. </p><br><div class="spoiler">  <b class="spoiler_title">Installation de certificat</b> <div class="spoiler_text"><p>  La version 3.9 du composant CSP CryptoPro a été installée sur Centos 7 dans le dossier / opt / cprocsp.  Afin d'éviter les conflits entre les utilitaires mono et CryptoPro portant le même nom (par exemple, certmgr), le chemin d'accès au dossier n'a pas été ajouté aux variables d'environnement et tous les utilitaires ont été appelés dans le chemin d'accès complet. </p><br><p> Tout d'abord, nous définissons une liste de lecteurs: <br> <code>/opt/cprocsp/bin/amd64/csptest -enum -info -type PP_ENUMREADERS | iconv -f cp1251</code> </p> <br><p>  S'il n'y a pas de lecteur du dossier sur le disque (HDIMAGE) dans la liste, mettez-le: <br> <code>/opt/cprocsp/sbin/amd64/cpconfig -hardware reader -add HDIMAGE store</code> </p> <br><p>  Ensuite, vous pouvez créer des conteneurs de la forme '\\. \ HDIMAGE \ {nom du conteneur}' en créant un nouveau conteneur avec des clés: <br> <code>/opt/cprocsp/bin/amd64/csptest -keyset -provtype 75 -newkeyset -cont '\\.\HDIMAGE\test'</code> </p> <br><p>  ou en créant le dossier / var / opt / cprocsp / keys / root / {nom du conteneur} .000, qui contient l'ensemble standard de fichiers conteneurs CryptoPro (* .key, * .mask, etc.). </p><br><p>  Après cela, le certificat du conteneur peut être installé dans le magasin de certificats: <br> <code>/opt/cprocsp/bin/amd64/certmgr -inst mMy -cont '\\.\HDIMAGE\{ }'</code> </p> <br><p>  Le certificat installé peut être vu avec la commande suivante: <br> <code>/opt/cprocsp/bin/amd64/certmgr -list mMy</code> </p> <br><p>  Le fonctionnement du certificat peut être vérifié comme suit: <br> <code>/opt/cprocsp/bin/amd64/cryptcp – sign -norev -thumbprint {} {} { }</code> <br> <code>/opt/cprocsp/bin/amd64/cryptcp – verify -norev { }</code> </p> <br><p>  Si tout va bien avec le certificat, vous pouvez procéder à la connexion dans le code. </p><br></div></div><br><h2>  Connexion en code </h2><br><p>  Malgré le processus de portage vers Linux, le système était censé continuer à fonctionner dans l'environnement Windows, donc extérieurement, le travail avec la cryptographie devait être effectué par le biais de méthodes générales de la forme «octet [] SignData (octet [] _arData, X509Certificate2 _pCert)», qui devrait fonctionner de la même manière que sous Linux ainsi que sous Windows. </p><br><p>  L'analyse des méthodes des bibliothèques de cryptographie s'est avérée réussie, car CryptoPro a implémenté la bibliothèque «libcapi20.so» qui imite complètement les bibliothèques de cryptage standard Windows - «crypt32.dll» et «advapi32.dll».  Peut-être, bien sûr, pas entièrement, mais toutes les méthodes nécessaires pour travailler avec la cryptographie y sont disponibles, et presque toutes fonctionnent. </p><br><p>  Par conséquent, nous formons deux classes statiques «WCryptoAPI» et «LCryptoAPI», chacune important l'ensemble de méthodes nécessaire comme suit: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(LIBCAPI20, SetLastError = true)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CertCloseStore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertStore, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iFlags</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br><p>  La syntaxe de connexion pour chacune des méthodes peut être créée indépendamment, ou utiliser le site Web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pinvoke</a> , ou être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">copiée à</a> partir de sources .Net (classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CAPISafe</a> ).  À partir du même module, vous pouvez dessiner des constantes et des structures associées à la cryptographie, dont la présence facilite toujours la vie lorsque vous travaillez avec des bibliothèques externes. </p><br><p>  Et puis nous formons la classe statique "UCryptoAPI" qui, selon le système, appellera la méthode de l'une des deux classes: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_iFlags"&gt; (  0)&lt;/param&gt; * &lt;param name="_hCertStore"&gt;   &lt;/param&gt; * &lt;returns&gt;   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CertCloseStore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertStore, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iFlags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsLinux) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LCryptoAPI.CertCloseStore(_hCertStore, _iFlags); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WCryptoAPI.CertCloseStore(_hCertStore, _iFlags); } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt;**/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fIsLinux { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iPlatform = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) Environment.OSVersion.Platform; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (iPlatform == <span class="hljs-number"><span class="hljs-number">4</span></span>) || (iPlatform == <span class="hljs-number"><span class="hljs-number">6</span></span>) || (iPlatform == <span class="hljs-number"><span class="hljs-number">128</span></span>); } }</code> </pre><br><p>  Ainsi, en utilisant les méthodes de la classe UCryptoAPI, vous pouvez implémenter du code presque uniforme pour les deux systèmes. </p><br><h3>  Recherche de certificat </h3><br><p>  Le travail avec la cryptographie commence généralement par une recherche de certificat, pour cela dans crypt32.dll, il existe deux méthodes CertOpenStore (ouvre le magasin de certificats spécifié) et un simple CertOpenSystemStore (ouvre les certificats personnels de l'utilisateur).  Étant donné que l'utilisation des certificats ne se limite pas aux certificats d'utilisateur personnels, nous connectons le premier: </p><br><div class="spoiler">  <b class="spoiler_title">Recherche de certificat</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  (   )&lt;/summary&gt; * &lt;param name="_pFindType"&gt; &lt;/param&gt; * &lt;param name="_pFindValue"&gt; &lt;/param&gt; * &lt;param name="_pLocation"&gt; &lt;/param&gt; * &lt;param name="_pName"&gt; &lt;/param&gt; * &lt;param name="_pCert"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_fVerify"&gt; &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindCertificateCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _pFindValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, StoreLocation _pLocation = StoreLocation.CurrentUser, StoreName _pName = StoreName.My, X509FindType _pFindType = X509FindType.FindByThumbprint, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _fVerify = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; IntPtr hCert = IntPtr.Zero; GCHandle hInternal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GCHandle(); GCHandle hFull = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GCHandle(); IntPtr hSysStore = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   hSysStore = UCryptoAPI.CertOpenStore(UCConsts.AR_CERT_STORE_PROV_SYSTEM[fIsLinux.ToByte()], UCConsts.PKCS_7_OR_X509_ASN_ENCODING, IntPtr.Zero, UCUtils.MapX509StoreFlags(_pLocation, OpenFlags.ReadOnly), UCConsts.AR_CRYPTO_STORE_NAME[(int)_pName]); if (hSysStore == IntPtr.Zero) { _sError = UCConsts.S_ERR_STORE_OPEN.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 1)     if ((_pFindType == X509FindType.FindByThumbprint) || (_pFindType == X509FindType.FindBySerialNumber)) { byte[] arData = _pFindValue.FromHex(); CRYPTOAPI_BLOB cryptBlob; cryptBlob.cbData = arData.Length; hInternal = GCHandle.Alloc(arData, GCHandleType.Pinned); cryptBlob.pbData = hInternal.AddrOfPinnedObject(); hFull = GCHandle.Alloc(cryptBlob, GCHandleType.Pinned); } else { byte[] arData; if(fIsLinux) arData = Encoding.UTF8.GetBytes(_pFindValue); else arData = Encoding.Unicode.GetBytes(_pFindValue); hFull = GCHandle.Alloc(arData, GCHandleType.Pinned); } // 2)  IntPtr hPrev = IntPtr.Zero; do { hCert = UCryptoAPI.CertFindCertificateInStore(hSysStore, UCConsts.PKCS_7_OR_X509_ASN_ENCODING, 0, UCConsts.AR_CRYPT_FIND_TYPE[(int)_pFindType, fIsLinux.ToByte()], hFull.AddrOfPinnedObject(), hPrev); // 2.1)   if(hPrev != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hPrev); // 2.2)    if(hCert == IntPtr.Zero) return UConsts.E_NO_CERTIFICATE; // 2.3)    X509Certificate2 pCert = new ISDP_X509Cert(hCert); if (!_fVerify || pCert.ISDPVerify()) { hCert = IntPtr.Zero; _pCert = pCert; return UConsts.S_OK; } hPrev = hCert; //    hCert = IntPtr.Zero; } while(hCert != IntPtr.Zero); return UConsts.E_NO_CERTIFICATE; } catch (Exception E) { _sError = UCConsts.S_FIND_CERT_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { //      if(hInternal.IsAllocated) hInternal.Free(); if(hFull.IsAllocated) hFull.Free(); if (hCert != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hCert); UCryptoAPI.CertCloseStore(hSysStore, 0); } }</span></span></code> </pre><br></div></div><br>  La recherche se déroule en plusieurs étapes: <br><ol><li>  ouverture de stockage; </li><li>  formation de la structure de données par laquelle nous recherchons; </li><li>  recherche de certificats; </li><li>  si nécessaire, vérification du certificat (décrite dans une section distincte); </li><li>  fermer le référentiel et libérer la structure à partir du point 2 (car partout où il y a du travail avec de la mémoire .Net non gérée, rien ne sera fait pour que nous le nettoyions); </li></ol><br><p>  Il y a quelques points subtils lors de la recherche de certificats. </p><br><p>  CryptoPro sur Linux fonctionne avec des chaînes ANSI, et sur Windows avec UTF8, donc: </p><br><ol><li>  lors de la connexion de la méthode d'ouverture de stockage sous Linux, il est nécessaire d'indiquer explicitement le type de marshaling [In, MarshalAs (UnmanagedType.LPStr)] pour le paramètre de code de stockage; </li><li>  en passant la chaîne de recherche (par exemple, par le nom de Subject), elle doit être convertie en un ensemble d'octets avec différents encodages; </li><li>  pour toutes les constantes cryptographiques qui varient selon le type de chaîne (par exemple, CERT_FIND_SUBJECT_STR_A et CERT_FIND_SUBJECT_STR_W) sous Windows, vous devez sélectionner * _W et sous Linux * _A; </li></ol><br><p>  La méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MapX509StoreFlags</a> peut être prise directement à partir de sources Microsoft sans modifications, elle forme simplement un masque final basé sur des indicateurs .Net. </p><br><p>  La valeur par laquelle la recherche a lieu dépend du type de recherche (vérifiez auprès de MSDN pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CertFindCertificateInStore</a> ), l'exemple montre les deux options les plus couramment utilisées - pour le format de chaîne (noms Subject, Issuer, etc.) et binaire (empreinte digitale, numéro de série). </p><br><p>  Le processus de création d'un certificat à partir d'IntPtr sur Windows et Linux est très différent.  Windows créera le certificat de manière simple: <br></p><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X509Certificate2(hCert);</code> </pre> <p></p><br><p>  sous Linux, vous devez créer un certificat en deux étapes: <br></p><pre> <code class="cs hljs">X509Certificate2(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X509Certificate(hCert));</code> </pre> <p></p><br><p>  À l'avenir, nous aurons besoin d'accéder à hCert pour le travail, et il devra être stocké dans l'objet de certificat.  Sous Windows, il peut être récupéré ultérieurement à partir de la propriété Handle, mais Linux convertit la structure CERT_CONTEXT qui suit le lien hCert en un lien vers la structure x509_st (OpenSSL) et l'enregistre dans Handle.  Par conséquent, il vaut la peine de créer un héritier de X509Certificate2 (ISDP_X509Cert dans l'exemple), qui stockera hCert dans les deux systèmes sur un champ distinct. </p><br><p>  N'oubliez pas qu'il s'agit d'un lien vers une zone de mémoire non managée et qu'il doit être libéré après la fin du travail.  Parce que  dans .Net 4.5 X509Certificate2 n'est pas jetable - le nettoyage à l'aide de la méthode CertFreeCertificateContext doit être effectué dans le destructeur. </p><br><h3>  Formation Signature </h3><br><p>  Lorsque vous travaillez avec des certificats GOST, les signatures déconnectées avec un seul signataire sont presque toujours utilisées.  Pour créer une telle signature, un bloc de code assez simple est requis: </p><br><div class="spoiler">  <b class="spoiler_title">Formation Signature</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt; * &lt;param name="_arData"&gt;  &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_arRes"&gt; &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignDataCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// 0)   CRYPT_SIGN_MESSAGE_PARA pParams = new CRYPT_SIGN_MESSAGE_PARA(); pParams.cbSize = Marshal.SizeOf(typeof(CRYPT_SIGN_MESSAGE_PARA)); pParams.dwMsgEncodingType = (int)(UCConsts.PKCS_7_OR_X509_ASN_ENCODING); pParams.pSigningCert = _pCert.getRealHandle(); pParams.cMsgCert = 1; pParams.HashAlgorithm.pszObjId = _pCert.getHashAlgirtmOid(); IntPtr pGlobData = Marshal.AllocHGlobal(_arData.Length); GCHandle pGC = GCHandle.Alloc(_pCert.getRealHandle(), GCHandleType.Pinned); try { pParams.rgpMsgCert = pGC.AddrOfPinnedObject(); Marshal.Copy(_arData, 0, pGlobData, _arData.Length); uint iLen = 50000; byte[] arRes = new byte[iLen]; // 1)   if (!UCryptoAPI.CryptSignMessage(ref pParams, true, 1, new IntPtr[1] { pGlobData }, new uint[1] { (uint)_arData.Length }, arRes, ref iLen)) { _sError = UCConsts.S_MAKE_SIGN_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } Array.Resize(ref arRes, (int)iLen); _arRes = arRes; return UConsts.S_OK;; } catch (Exception E) { _sError = UCConsts.S_MAKE_SIGN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { pGC.Free(); Marshal.FreeHGlobal(pGlobData); } }</span></span></code> </pre></div></div><br><p>  Pendant le travail de la méthode, une structure avec des paramètres est formée et la méthode de signature est appelée.  La structure des paramètres peut vous permettre d'enregistrer des certificats dans la signature pour former une chaîne complète (les champs cMsgCert et rgpMsgCert, le premier stocke le nombre de certificats, la deuxième liste de liens vers les structures de ces certificats). </p><br><p>  La méthode de signature peut recevoir un ou plusieurs documents pour une signature simultanée avec une signature.  Soit dit en passant, cela ne contredit pas la loi fédérale 63 et est très pratique, car il est peu probable que l'utilisateur soit satisfait de la nécessité de cliquer plusieurs fois sur le bouton «signer». </p><br><p>  La principale bizarrerie de cette méthode est qu'elle ne fonctionne pas en mode deux appels, ce qui est typique de la plupart des méthodes de bibliothèque qui fonctionnent avec de grands blocs de mémoire (la première avec null - renvoie la longueur de tampon requise, la seconde remplit le tampon).  Par conséquent, il est nécessaire de créer un grand tampon, puis de le raccourcir à sa longueur réelle. </p><br><p>  Le seul problème sérieux est la recherche de l'OID de l'algorithme de hachage (Digest) utilisé lors de la signature - sous forme explicite, il ne se trouve pas dans le certificat (il n'y a que l'algorithme de la signature elle-même).  Et si sous Windows vous pouvez le spécifier avec une chaîne vide - il reprendra automatiquement, mais Linux refusera de signer si l'algorithme n'est pas le même. </p><br><p>  Mais il y a une astuce - dans les informations sur l'algorithme de signature (structure CRYPT_OID_INFO), l'OID de signature est stocké dans pszOID et l'identifiant de l'algorithme de hachage est stocké dans Algid.  Et la conversion d'Algid en OID est déjà une question technique: </p><br><div class="spoiler">  <b class="spoiler_title">Obtention de l'OID de l'algorithme de hachage</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; OID   &lt;/summary&gt; * &lt;param name="_hCertHandle"&gt; &lt;/param&gt; * &lt;param name="_sOID"&gt;  OID&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashAlgoritmOID</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertHandle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sOID, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _sOID = <span class="hljs-string"><span class="hljs-string">""</span></span>; IntPtr hHashAlgInfo = IntPtr.Zero; IntPtr hData = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { CERT_CONTEXT pContext = (CERT_CONTEXT)Marshal.PtrToStructure(_hCertHandle, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_CONTEXT)); CERT_INFO pCertInfo = (CERT_INFO)Marshal.PtrToStructure(pContext.pCertInfo, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_INFO)); <span class="hljs-comment"><span class="hljs-comment">//  AlgID //  UCryptoAPI.CertAlgIdToOID  Windows   ,   byte[] arData = BitConverter.GetBytes(UCryptoAPI.CertOIDToAlgId(pCertInfo.SignatureAlgorithm.pszObjId)); hData = Marshal.AllocHGlobal(arData.Length); Marshal.Copy(arData, 0, hData, arData.Length); //  OID hHashAlgInfo = UCryptoAPI.CryptFindOIDInfo(UCConsts.CRYPT_OID_INFO_ALGID_KEY, hData, UCConsts.CRYPT_HASH_ALG_OID_GROUP_ID); if (hHashAlgInfo == IntPtr.Zero) { _sError = UCConsts.S_NO_HASH_ALG_ERR.Frm( Marshal.GetLastWin32Error()); return UConsts.E_GEN_EXCEPTION; } CRYPT_OID_INFO pHashAlgInfo = (CRYPT_OID_INFO)Marshal.PtrToStructure(hHashAlgInfo, typeof(CRYPT_OID_INFO)); _sOID = pHashAlgInfo.pszOID; return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_DETERM_HASH_ALG_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { Marshal.FreeHGlobal(hData); } }</span></span></code> </pre></div></div><br><p>  Après avoir lu attentivement le code, vous serez peut-être surpris que l'identifiant de l'algorithme soit obtenu de manière simple (CertOIDToAlgId) et que l'Oid qu'il contient est compliqué (CryptFindOIDInfo).  Il serait logique de supposer l'utilisation de méthodes complexes ou simples, et sous Linux, les deux options fonctionnent correctement.  Cependant, sous Windows, l'option difficile d'obtenir un identifiant et d'obtenir simplement un OID est instable, donc un hybride aussi étrange serait une solution stable. </p><br><h3>  Vérification de signature </h3><br><p>  La vérification de la signature se déroule en deux étapes, au début la signature elle-même est vérifiée, puis le certificat avec lequel elle a été générée est vérifié (chaîne, date de signature, etc.). <br>  En plus de la signature, vous devez spécifier l'ensemble de données à signer, les paramètres de signature et la signature elle-même: </p><br><div class="spoiler">  <b class="spoiler_title">Vérification de signature</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;      &lt;/summary&gt; * &lt;returns&gt;&lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CRYPT_VERIFY_MESSAGE_PARA </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStdSignVerifyPar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CRYPT_VERIFY_MESSAGE_PARA pVerifyParams = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CRYPT_VERIFY_MESSAGE_PARA(); pVerifyParams.cbSize = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Marshal.SizeOf(pVerifyParams); pVerifyParams.dwMsgEncodingType = UCConsts.PKCS_7_OR_X509_ASN_ENCODING; pVerifyParams.hCryptProv = <span class="hljs-number"><span class="hljs-number">0</span></span>; pVerifyParams.pfnGetSignerCertificate = IntPtr.Zero; pVerifyParams.pvGetArg = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pVerifyParams; } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arData"&gt;,   &lt;/param&gt; * &lt;param name="_pSign"&gt;&lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_fVerifyOnlySign"&gt;  &lt;/param&gt; * &lt;param name="_pRevMode"&gt;  &lt;/param&gt; * &lt;param name="_pRevFlag"&gt;  &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * &lt;remarks&gt;   &lt;/remarks&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSignCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _pSign, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _fVerifyOnlySign = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, X509RevocationMode _pRevMode = X509RevocationMode.Online, X509RevocationFlag _pRevFlag = X509RevocationFlag.ExcludeRoot</span></span></span><span class="hljs-function">)</span></span>{ _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; IntPtr pHData = Marshal.AllocHGlobal(_arData.Length); GCHandle pCertContext = GCHandle.Alloc(IntPtr.Zero, GCHandleType.Pinned); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Marshal.Copy(_arData, <span class="hljs-number"><span class="hljs-number">0</span></span>, pHData, _arData.Length); CRYPT_VERIFY_MESSAGE_PARA pVerParam = UCUtils.GetStdSignVerifyPar(); <span class="hljs-comment"><span class="hljs-comment">// 0)   bool fRes = UCryptoAPI.CryptVerifyDetachedMessageSignature( ref pVerParam, //   0, //   _pSign, //  _pSign.Length, //   1, // -    new IntPtr[1] { pHData }, //   new int[1] { _arData.Length }, //    pCertContext.AddrOfPinnedObject());//    if (!fRes) { _sError = UCConsts.S_SIGN_CHECK_ERR.Frm(Marshal.GetLastWin32Error().ToString("X")); return UConsts.E_CRYPTO_ERR; } // 1)   _pCert = new ISDP_X509Cert((IntPtr)pCertContext.Target); if (_pCert == null) { _sError = UCConsts.S_SIGN_CHECK_CERT_ERR; return UConsts.E_CRYPTO_ERR; } // 2)   if (!_fVerifyOnlySign) { List&lt;DateTime&gt; pDates; // 2.1)    int iRes = GetSignDateTimeCP(_pSign, out pDates, ref _sError); // 2.2)    iRes = _pCert.ISDPVerify(ref _sError, pDates[0], _pRevMode, _pRevFlag); if (iRes != UConsts.S_OK) return iRes; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_SIGN_CHECK_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION;; } finally { Marshal.FreeHGlobal(pHData); if ((_pCert == null) &amp;&amp; pCertContext.IsAllocated &amp;&amp; ((IntPtr)pCertContext.Target != IntPtr.Zero)) UCryptoAPI.CertFreeCertificateContext((IntPtr)pCertContext.Target); pCertContext.Free(); } }</span></span></code> </pre></div></div><br><p>  Pour plus de commodité, le processus de formation d'une structure avec des paramètres a été déplacé vers une méthode distincte (GetStdSignVerifyPar).  Après cela, la signature elle-même est vérifiée et le premier signataire est extrait (pour de bon il faudrait tout extraire, mais une signature contenant plusieurs signataires est toujours exotique). </p><br><p>  Après avoir extrait le certificat du signataire, nous le convertirons dans notre classe et le vérifierons (si spécifié dans les paramètres de la méthode).  Pour la vérification, la date de signature du premier signataire est utilisée (voir la section sur l'extraction des informations de la signature et la section sur la vérification des certificats). </p><br><h2>  Extraire les informations de signature </h2><br><p>  Souvent, les systèmes cryptographiques nécessitent une représentation imprimée de la signature.  Dans chaque cas, c'est différent, il est donc préférable de créer une classe d'informations sur la signature, qui contiendra des informations sous une forme pratique à utiliser et, avec son aide, fournira une présentation imprimée.  Dans .Net, il existe une telle classe - SignedCms, cependant, son analogue en mono avec les signatures de CritoPro refuse de fonctionner dans le premier, deuxièmement il contient le modificateur scellé et troisièmement presque toutes ses propriétés sont protégées en écriture, vous devez donc créer votre propre analogue. </p><br><p>  La signature elle-même contient deux éléments principaux - une liste de certificats et une liste de signataires.  La liste des certificats peut être vide ou contenir tous les certificats à vérifier, y compris les chaînes complètes.  La liste des signataires indique le nombre de signatures réelles.  La communication entre eux s'effectue par le numéro de série et l'éditeur (émetteur).  Théoriquement, dans une signature, il peut y avoir deux certificats d'éditeurs différents avec le même numéro de série, mais en pratique, cela ne peut être négligé et recherché que par le numéro de série. </p><br><p>  La lecture de la signature est la suivante: </p><br><div class="spoiler">  <b class="spoiler_title">Extraire les informations de signature</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;&lt;/summary&gt; * &lt;param name="_arSign"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arSign, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { IntPtr hMsg = IntPtr.Zero; <span class="hljs-comment"><span class="hljs-comment">// 0)   try { hMsg = UCryptoAPI.CryptMsgOpenToDecode(UCConsts.PKCS_7_OR_X509_ASN_ENCODING, UCConsts.CMSG_DETACHED_FLAG, 0, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero); if (hMsg == IntPtr.Zero) { _sError = UCConsts.S_CRYP_MSG_FORM_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 1)   if (!UCryptoAPI.CryptMsgUpdate(hMsg, _arSign, (uint)_arSign.Length, true)) { _sError = UCConsts.S_CRYP_MSG_SIGN_COPY_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 2)   (PKCS7 SignedData) uint iMessType = UCUtils.GetCryptMsgParam&lt;uint&gt;(hMsg, UCConsts.CMSG_TYPE_PARAM); if (UCConsts.CMSG_SIGNED != iMessType) { _sError = UCConsts.S_CRYP_MSG_SIGN_TYPE_ERR.Frm(iMessType, UCConsts.CMSG_SIGNED); return UConsts.E_CRYPTO_ERR; } // 3)    fpCertificates = UCUtils.GetSignCertificates(hMsg); // 4)   uint iSignerCount = UCUtils.GetCryptMsgParam&lt;uint&gt;(hMsg, UCConsts.CMSG_SIGNER_COUNT_PARAM); for (int i = 0; i &lt; iSignerCount; i++) { ISDPSignerInfo pInfo = new ISDPSignerInfo(); fpSignerInfos.Add(pInfo); int iRes = pInfo.Decode(hMsg, i, this, ref _sError); if (iRes != UConsts.S_OK) return iRes; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_SIGN_INFO_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hMsg != IntPtr.Zero) UCryptoAPI.CryptMsgClose(hMsg); } }</span></span></code> </pre></div></div><br><p>  La signature est analysée en plusieurs étapes, d'abord la structure du message (CryptMsgOpenToDecode) est formée, puis les données de signature réelles (CryptMsgUpdate) y sont entrées.  Reste à vérifier qu'il s'agit bien d'une véritable signature et à obtenir d'abord une liste de certificats, puis une liste de signataires.  La liste des certificats est récupérée séquentiellement: </p><br><div class="spoiler">  <b class="spoiler_title">Obtenir une liste de certificats</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;     &lt;/summary&gt; * &lt;param name="_hMsg"&gt;Handle &lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> X509Certificate2Collection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSignCertificates</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hMsg</span></span></span><span class="hljs-function">)</span></span> { X509Certificate2Collection certificates = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X509Certificate2Collection(); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iCnt = GetCryptMsgParam&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt;(_hMsg, UCConsts.CMSG_CERT_COUNT_PARAM); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iCnt; i++) { IntPtr hInfo = IntPtr.Zero; IntPtr hCert = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetCryptMsgParam(_hMsg, UCConsts.CMSG_CERT_PARAM, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hInfo, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> iLen)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; hCert = UCryptoAPI.CertCreateCertificateContext(UCConsts.PKCS_7_OR_X509_ASN_ENCODING, hInfo, iLen); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hCert != IntPtr.Zero) { certificates.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ISDP_X509Cert(hCert)); hCert = IntPtr.Zero; } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hInfo != IntPtr.Zero) Marshal.FreeHGlobal(hInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hInfo != IntPtr.Zero) Marshal.FreeHGlobal(hCert); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> certificates; }</code> </pre></div></div><br><p>  Tout d'abord, le nombre de certificats est déterminé à partir du paramètre CMSG_CERT_COUNT_PARAM, puis les informations sur chaque certificat sont récupérées séquentiellement.  Le processus de création du contexte du certificat et sur la base du certificat lui-même achève le processus de création. </p><br><p>  La récupération des données des signataires est plus difficile.  Ils contiennent une indication du certificat et une liste des paramètres de signature (par exemple, la date de signature).  Le processus d'extraction des données est le suivant: </p><br><div class="spoiler">  <b class="spoiler_title">Récupération des informations du signataire</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;   &lt;/summary&gt; * &lt;param name="_hMsg"&gt;Handler &lt;/param&gt; * &lt;param name="_iIndex"&gt; &lt;/param&gt; * &lt;param name="_pSignedCms"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hMsg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iIndex, ISDPSignedCms _pSignedCms, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1)   uint iLen = 0; // 2)  IntPtr hInfo = IntPtr.Zero; try { if (!UCryptoAPI.CryptMsgGetParam(_hMsg, UCConsts.CMSG_SIGNER_INFO_PARAM, (uint)_iIndex, IntPtr.Zero, ref iLen)) { _sError = UCConsts.S_ERR_SIGNER_INFO_LEN.Frm(_iIndex, Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } hInfo = Marshal.AllocHGlobal((int)iLen); if (!UCryptoAPI.CryptMsgGetParam(_hMsg, UCConsts.CMSG_SIGNER_INFO_PARAM, (uint)_iIndex, hInfo, ref iLen)) { _sError = UCConsts.S_ERR_SIGNER_INFO.Frm(_iIndex, Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } CMSG_SIGNER_INFO pSignerInfo = (CMSG_SIGNER_INFO) Marshal.PtrToStructure(hInfo, typeof(CMSG_SIGNER_INFO)); // 2.1)   byte[] arSerial = new byte[pSignerInfo.SerialNumber.cbData]; Marshal.Copy(pSignerInfo.SerialNumber.pbData, arSerial, 0, arSerial.Length); X509Certificate2Collection pLocCerts = _pSignedCms.pCertificates.Find(X509FindType.FindBySerialNumber, arSerial.Reverse().ToArray().ToHex(), false); if (pLocCerts.Count != 1) { _sError = UCConsts.S_ERR_SIGNER_INFO_CERT.Frm(_iIndex); return UConsts.E_NO_CERTIFICATE; } fpCertificate = pLocCerts[0]; fpSignedAttributes = UCUtils.ReadCryptoAttrsCollection(pSignerInfo.AuthAttrs); return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_ERR_SIGNER_INFO_READ.Frm(_iIndex, E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hInfo != IntPtr.Zero) Marshal.FreeHGlobal(hInfo); } }</span></span></code> </pre></div></div><br><p>        ,       CMSG_SIGNER_INFO.                 .  ,       . </p><br><p>       ,     —   (        ,     ). </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;   &lt;/summary&gt; * &lt;param name="_pAttrs"&gt; &lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CryptographicAttributeObjectCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadCryptoAttrsCollection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CRYPT_ATTRIBUTES _pAttrs</span></span></span><span class="hljs-function">)</span></span> { CryptographicAttributeObjectCollection pRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CryptographicAttributeObjectCollection(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _pAttrs.cAttr; i++) { IntPtr hAttr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPtr((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)_pAttrs.rgAttr + (i * Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CRYPT_ATTRIBUTE)))); CRYPT_ATTRIBUTE pAttr = (CRYPT_ATTRIBUTE) Marshal.PtrToStructure(hAttr, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CRYPT_ATTRIBUTE)); CryptographicAttributeObject pAttrInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CryptographicAttributeObject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Oid(pAttr.pszObjId), GetAsnEncodedDataCollection(pAttr)); pRes.Add(pAttrInfo); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pRes; }</code> </pre></div></div><br><p>        Oid –   (     ASN.1).       : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;      &lt;/summary&gt; * &lt;param name="_sName"&gt;&lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Pkcs9AttributeObject </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pkcs9AttributeFromOID</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_sName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> UCConsts.S_SIGN_DATE_OID : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pkcs9SigningTime(); <span class="hljs-comment"><span class="hljs-comment">// case UConsts.S_CONTENT_TYPE_OID : return new Pkcs9ContentType(); -&gt;&gt;  Mono  // case UConsts.S_MESS_DIGEST_OID : return new Pkcs9MessageDigest(); default: return new Pkcs9AttributeObject(); } } /**&lt;summary&gt;  ASN&lt;/summary&gt; * &lt;param name="_pAttr"&gt;&lt;/param&gt; * &lt;returns&gt;&lt;/returns&gt; * **/ internal static AsnEncodedDataCollection GetAsnEncodedDataCollection (CRYPT_ATTRIBUTE _pAttr) { AsnEncodedDataCollection pRes = new AsnEncodedDataCollection(); Oid pOid = new Oid(_pAttr.pszObjId); string sOid = pOid.Value; for (uint i = 0; i &lt; _pAttr.cValue; i++) { checked { IntPtr pAttributeBlob = new IntPtr((long)_pAttr.rgValue + (i * Marshal.SizeOf(typeof(CRYPTOAPI_BLOB)))); Pkcs9AttributeObject attribute = new Pkcs9AttributeObject(pOid, BlobToByteArray(pAttributeBlob)); Pkcs9AttributeObject customAttribute = Pkcs9AttributeFromOID(sOid); if (customAttribute != null) { customAttribute.CopyFrom(attribute); attribute = customAttribute; } pRes.Add(attribute); } } return pRes; }</span></span></code> </pre></div></div><br><p>         Pkcs9AttributeObject.   ,      mono          .       Mono       . </p><br><p>        —        —   SignedCms,        . </p><br><h3>  </h3><br><p>       ,   ,         .                 (,      ,       ). </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arInput"&gt;  &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_arRes"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;   ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncryptDataCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arInput, X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   CRYPT_ENCRYPT_MESSAGE_PARA pParams = new CRYPT_ENCRYPT_MESSAGE_PARA(); pParams.dwMsgEncodingType = UCConsts.PKCS_7_OR_X509_ASN_ENCODING; pParams.ContentEncryptionAlgorithm.pszObjId = _pCert.getEncodeAlgirtmOid(); pParams.cbSize = Marshal.SizeOf(pParams); // 1)   int iLen = 0; if (!UCryptoAPI.CryptEncryptMessage(ref pParams, 1, new IntPtr[] { _pCert.getRealHandle() }, _arInput, _arInput.Length, null, ref iLen)) { _sError = UCConsts.S_CRYPT_ENCODE_LEN_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 2)     _arRes = new byte[iLen]; if (!UCryptoAPI.CryptEncryptMessage(ref pParams, 1, new IntPtr[] {_pCert.getRealHandle() }, _arInput, _arInput.Length, _arRes, ref iLen)) { _sError = UCConsts.S_CRYPT_ENCODE_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_CRYPT_ENCODE_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } }</span></span></code> </pre></div></div><br><p>       —  ,     .     , ,      . </p><br><p>       ,              ,    . </p><br><p>      .     ,            (    ).        : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; OID   &lt;/summary&gt; * &lt;param name="_hCertHandle"&gt; &lt;/param&gt; * &lt;param name="_sOID"&gt;  OID&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEncodeAlgoritmOID</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertHandle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sOID, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fNeedRelease = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _sOID = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iKeySpec = <span class="hljs-number"><span class="hljs-number">0</span></span>; IntPtr hCrypto = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)    if (!UCryptoAPI.CryptAcquireCertificatePrivateKey(_hCertHandle, 0, IntPtr.Zero, ref hCrypto, ref iKeySpec, ref fNeedRelease)) { _sError = UCConsts.S_CRYPTO_PROV_INIT_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } uint iLen = 1000; byte[] arData = new byte[1000]; uint iFlag = 1; //  // 1)      while (UCryptoAPI.CryptGetProvParam(hCrypto, UCConsts.PP_ENUMALGS, arData, ref iLen, iFlag)){ iFlag = 2; //  PROV_ENUMALGS pInfo = ConvertBytesToStruct&lt;PROV_ENUMALGS&gt;(arData); // 2)   OID     byte[] arDataAlg = BitConverter.GetBytes(pInfo.aiAlgid); IntPtr hDataAlg = Marshal.AllocHGlobal(arDataAlg.Length); try { Marshal.Copy(arDataAlg, 0, hDataAlg, arDataAlg.Length); IntPtr hHashAlgInfo2 = UCryptoAPI.CryptFindOIDInfo(UCConsts.CRYPT_OID_INFO_ALGID_KEY, hDataAlg, UCConsts.CRYPT_ENCRYPT_ALG_OID_GROUP_ID); // 2.1)  -  if (hHashAlgInfo2 != IntPtr.Zero) { CRYPT_OID_INFO pHashAlgInfo2 = (CRYPT_OID_INFO)Marshal.PtrToStructure(hHashAlgInfo2, typeof(CRYPT_OID_INFO)); _sOID = pHashAlgInfo2.pszOID ; return UConsts.S_OK; } } finally { Marshal.FreeHGlobal(hDataAlg); } } // 3)   -  _sError = UCConsts.S_NO_ENCODE_ALG_ERR; return UConsts.E_CRYPTO_ERR; } catch (Exception E) { _sError = UCConsts.S_DETERM_ENCODE_ALG_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; }finally { if((hCrypto != IntPtr.Zero) &amp;&amp; fNeedRelease) UCryptoAPI.CryptReleaseContext(hCrypto, 0); } }</span></span></code> </pre></div></div><br><p>             .        ( , , ,   .),      .          (UCConsts.CRYPT_ENCRYPT_ALG_OID_GROUP_ID).     —    . </p><br><p>               (    ). </p><br><h3>  </h3><br><p>  ,   ,               .        .       —  ,      : </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arInput"&gt;  &lt;/param&gt; * &lt;param name="_arRes"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;returns&gt;  ,  UCOnsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecryptDataCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arInput, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; IntPtr hSysStore = UCryptoAPI.CertOpenSystemStore(IntPtr.Zero, UCConsts.AR_CRYPTO_STORE_NAME[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)StoreName.My]); GCHandle GC = GCHandle.Alloc(hSysStore, GCHandleType.Pinned); IntPtr hOutCertL = IntPtr.Zero; IntPtr hOutCert = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   CRYPT_DECRYPT_MESSAGE_PARA pParams = new CRYPT_DECRYPT_MESSAGE_PARA(); pParams.dwMsgAndCertEncodingType = UCConsts.PKCS_7_OR_X509_ASN_ENCODING; pParams.cCertStore = 1; pParams.rghCertStore = GC.AddrOfPinnedObject(); pParams.cbSize = Marshal.SizeOf(pParams); int iLen = 0; // 1)     if (!UCryptoAPI.CryptDecryptMessage(ref pParams, _arInput, _arInput.Length, null, ref iLen, ref hOutCertL)) { _sError = UCConsts.S_DECRYPT_LEN_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 2)    _arRes = new byte[iLen]; if (!UCryptoAPI.CryptDecryptMessage(ref pParams, _arInput, _arInput.Length, _arRes, ref iLen, ref hOutCert)) { _sError = UCConsts.S_DECRYPT_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 3)     if (hOutCert != IntPtr.Zero) _pCert = new ISDP_X509Cert(hOutCert); if(_pCert != null) hOutCert = IntPtr.Zero; //    return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_DECRYPT_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if (hOutCertL != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hOutCertL); if (hOutCert != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hOutCert); GC.Free(); UCryptoAPI.CertCloseStore(hSysStore, 0); } }</span></span></code> </pre></div></div><br><p>     ,          .         ,    ( Linux    ). </p><br><h3>   </h3><br><p>      ,         ,  ,       ,      .          ,   .       : </p><br><ol><li>   ( ,    ,  . .); </li><li>    —       ; </li><li>     —         ; <br></li><li>     ,  ,         (CRL); </li></ol><br><p>        ,       . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme il ressort déjà de l'introduction, la vérification de la validité du certificat est l'une des tâches les plus difficiles. </font><font style="vertical-align: inherit;">C'est pourquoi la bibliothèque dispose de nombreuses méthodes pour implémenter chacun des éléments individuellement. </font><font style="vertical-align: inherit;">Par conséquent, pour plus de simplicité, nous nous tournons vers les sources .Net pour la méthode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X509Certificate2.Verify ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et les prenons comme base.</font></font></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La vérification comprend deux étapes: </font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> former une chaîne de certificats jusqu'à la racine; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vérifier chacun des certificats qu'il contient (révocation, délai, etc.); </font></font></li></ol><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette vérification doit être effectuée avant la signature et le cryptage à la date du jour, et au moment de la vérification de la signature à la date de la signature. </font><font style="vertical-align: inherit;">La méthode de vérification elle-même est petite:</font></font></p><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vérification du certificat</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_iRevFlag"&gt; &lt;/param&gt; * &lt;param name="_iRevMode"&gt; &lt;/param&gt; * &lt;param name="_hPolicy"&gt;   &lt;/param&gt; * &lt;param name="_hCert"&gt; &lt;/param&gt; * &lt;param name="_iCTLTimeout"&gt;   &lt;/param&gt; * &lt;param name="_rOnDate"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VerifyCertificate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCert, X509RevocationMode _iRevMode, X509RevocationFlag _iRevFlag, DateTime _rOnDate, TimeSpan _iCTLTimeout, IntPtr _hPolicy, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_hCert == IntPtr.Zero) { _sError = UCConsts.S_CRYPTO_CERT_CHECK_ERR; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UConsts.E_NO_CERTIFICATE; } CERT_CHAIN_POLICY_PARA pPolicyParam = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CERT_CHAIN_POLICY_PARA(Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_CHAIN_POLICY_PARA))); CERT_CHAIN_POLICY_STATUS pPolicyStatus = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CERT_CHAIN_POLICY_STATUS(Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_CHAIN_POLICY_STATUS))); <span class="hljs-comment"><span class="hljs-comment">// 1)   IntPtr hChain = IntPtr.Zero; try { int iRes = BuildChain(new IntPtr(UCConsts.HCCE_CURRENT_USER), _hCert, __iRevMode, _iRevFlag, _rOnDate, _iCTLTimeout, ref hChain, ref _sError); if (iRes != UConsts.S_OK) return iRes; // 2)   if (UCryptoAPI.CertVerifyCertificateChainPolicy(_hPolicy, hChain, ref pPolicyParam, ref pPolicyStatus)) { if (pPolicyStatus.dwError != 0) { _sError = UCConsts.S_CRYPTO_CHAIN_CHECK_ERR.Frm(pPolicyStatus.dwError); return UConsts.E_CRYPTO_ERR; } } else{ _sError = UCConsts.S_CRYPTO_CHAIN_CHECK_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_CRYPTO_CERT_VERIFY_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hChain != IntPtr.Zero) UCryptoAPI.CertFreeCertificateChain(hChain); } }</span></span></code> </pre></div></div><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, une chaîne est formée à l'aide de la méthode BuildChain, puis elle est vérifiée. </font><font style="vertical-align: inherit;">Lors de la formation de la chaîne, la structure des paramètres, la date de vérification et les drapeaux de contrôle sont formés:</font></font></p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;    &lt;/summary&gt; * &lt;param name="_hChain"&gt;  &lt;/param&gt; * &lt;param name="_iRevFlag"&gt; &lt;/param&gt; * &lt;param name="_iRevMode"&gt; &lt;/param&gt; * &lt;param name="_hChainEngine"&gt; &lt;/param&gt; * &lt;param name="_hCert"&gt; &lt;/param&gt; * &lt;param name="_rCTLTimeOut"&gt;   &lt;/param&gt; * &lt;param name="_rOnDate"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildChain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hChainEngine, IntPtr _hCert, X509RevocationMode _iRevMode, X509RevocationFlag _iRevFlag, DateTime _rOnDate, TimeSpan _rCTLTimeOut, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntPtr _hChain, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)    if (_hCert == IntPtr.Zero) { _sError = UCConsts.S_CRYPTO_CERT_CHAIN_ERR; return UConsts.E_NO_CERTIFICATE; } // 1)  CERT_CHAIN_PARA pChainParams = new CERT_CHAIN_PARA(); pChainParams.cbSize = (uint) Marshal.SizeOf(pChainParams); IntPtr hAppPolicy = IntPtr.Zero; IntPtr hCertPolicy = IntPtr.Zero; try { // 2)    pChainParams.dwUrlRetrievalTimeout = (uint)Math.Floor(_rCTLTimeOut.TotalMilliseconds); // 3)   FILETIME pVerifyTime = new FILETIME(_rOnDate.ToFileTime()); // 4)   uint _iFlags = MapRevocationFlags(_iRevMode, _iRevFlag); // 5)   if (!UCryptoAPI.CertGetCertificateChain(_hChainEngine, _hCert, ref pVerifyTime, IntPtr.Zero, ref pChainParams, _iFlags, IntPtr.Zero, ref _hChain)) { _sError = UCConsts.S_CRYPTO_CHAIN_BUILD_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } } catch(Exception E) { _sError = UCConsts.S_CRYPTO_CHAIN_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { Marshal.FreeHGlobal(hAppPolicy); Marshal.FreeHGlobal(hCertPolicy); } return UConsts.S_OK; }</span></span></code> </pre></div></div><br><p>          ,    Microsoft.  hCertPolicy  hAppPolicy   OID-,    ,     .   ,  ,     . </p><br><p>            (,   ). </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MapRevocationFlags</a> —      .Net   —   uint    . </p><br><h3>  Conclusion </h3><br><p>               : </p><br><ol><li>  10 ; </li><li>  ; </li><li>  byte[] {1, 2, 3, 4, 5}; </li><li>   ; </li><li>   ; </li><li>  byte[] {1, 2, 3, 4, 5}; </li><li>   ; </li></ol><br><p>      Windows   Linux  1-, 10-  50- ,     Linux    .   Linux     -   -  (   ,    ),   «» .       (deadlock-)   (             «Access Violation»). </p><br><p>           UCryptoAPI    .     fpCPSection  object        : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> fpCPSection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_hCryptMsg"&gt;  &lt;/param&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CryptMsgClose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCryptMsg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (pCPSection) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsLinux) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LCryptoAPI.CryptMsgClose(_hCryptMsg); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WCryptoAPI.CryptMsgClose(_hCryptMsg); } } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;     &lt;/summary&gt;**/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> pCPSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fpCPSection;} }</code> </pre><br><p>   ,         Linux- . </p><br><p>         mono     Issuer  Subject . , ,    mono   X500DistinguishedName    .  , mono      (     ),           (impl.issuerName  impl.subjectName).         (Reflection)      X500DistinguishedName,       CERT_CONTEXT . </p><br><h2>  Les références </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  CAPILite </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> c      # </li><li>  .Net: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CAPIBase</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">X509Certificate2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SignedCMS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SignerInfo</a> </li></ol><br></li><li>  mono: <br><ol><li>  <a href="">X509Certificate2</a> </li><li>  <a href="">X509CertificateImplBtls</a> </li></ol><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423163/">https://habr.com/ru/post/fr423163/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423153/index.html">Guide Node.js, partie 2: JavaScript, V8, quelques astuces de développement</a></li>
<li><a href="../fr423155/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 8: Modèle de sécurité réseau, partie 2</a></li>
<li><a href="../fr423157/index.html">Utilisation de la fonction connect () de react-redux</a></li>
<li><a href="../fr423159/index.html">Bonne fête du programmeur! Aimez vos développeurs</a></li>
<li><a href="../fr423161/index.html">Les entreprises veulent des données personnelles</a></li>
<li><a href="../fr423165/index.html">Dessin de maillage dynamique dans Unreal Engine 4</a></li>
<li><a href="../fr423167/index.html">Ce que Mark Zuckerberg parle des problèmes de Facebook. L'essentiel de l'article du New Yorker</a></li>
<li><a href="../fr423169/index.html">Démarrage de la journée (juillet-août 2018)</a></li>
<li><a href="../fr423171/index.html">Comment Discord sert simultanément 2,5 millions de chats vocaux à l'aide de WebRTC</a></li>
<li><a href="../fr423173/index.html">Temps minimum - douleur maximale</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>