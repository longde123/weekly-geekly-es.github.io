<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèø üìë üò° Connexion de CryptoPro √† Mono üë©üèΩ‚Äç‚öñÔ∏è üêá üêô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le cadre de la transition vers Linux, il est devenu n√©cessaire de porter l'un de nos syst√®mes serveurs √©crits en C # vers Mono. Le syst√®me foncti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Connexion de CryptoPro √† Mono</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423163/"><p>  Dans le cadre de la transition vers Linux, il est devenu n√©cessaire de porter l'un de nos syst√®mes serveurs √©crits en C # vers Mono.  Le syst√®me fonctionne avec des signatures num√©riques am√©lior√©es, donc l'une des t√¢ches auxquelles nous avons √©t√© confront√©s √©tait de v√©rifier les performances des certificats GOST de CryptoPro en mono.  CryptoPro lui-m√™me a impl√©ment√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CSP</a> pour Linux depuis un certain temps, mais la premi√®re tentative d'utilisation a montr√© que les classes de cryptographie Mono natives (similaires √† celles de la base .Net - X509Store, X509Certificate2, etc.) non seulement ne fonctionnent pas avec les cl√©s invit√©es, mais m√™me ne les voyez pas dans leurs coffres.  Pour cette raison, le travail avec la cryptographie devait √™tre connect√© directement via les biblioth√®ques CryptoPro. </p><br><a name="habracut"></a><br><h2>  Installation de certificat </h2><br><p>  Avant d'impl√©menter le code, vous devez installer le certificat et vous assurer qu'il fonctionne correctement. </p><br><div class="spoiler">  <b class="spoiler_title">Installation de certificat</b> <div class="spoiler_text"><p>  La version 3.9 du composant CSP CryptoPro a √©t√© install√©e sur Centos 7 dans le dossier / opt / cprocsp.  Afin d'√©viter les conflits entre les utilitaires mono et CryptoPro portant le m√™me nom (par exemple, certmgr), le chemin d'acc√®s au dossier n'a pas √©t√© ajout√© aux variables d'environnement et tous les utilitaires ont √©t√© appel√©s dans le chemin d'acc√®s complet. </p><br><p> Tout d'abord, nous d√©finissons une liste de lecteurs: <br> <code>/opt/cprocsp/bin/amd64/csptest -enum -info -type PP_ENUMREADERS | iconv -f cp1251</code> </p> <br><p>  S'il n'y a pas de lecteur du dossier sur le disque (HDIMAGE) dans la liste, mettez-le: <br> <code>/opt/cprocsp/sbin/amd64/cpconfig -hardware reader -add HDIMAGE store</code> </p> <br><p>  Ensuite, vous pouvez cr√©er des conteneurs de la forme '\\. \ HDIMAGE \ {nom du conteneur}' en cr√©ant un nouveau conteneur avec des cl√©s: <br> <code>/opt/cprocsp/bin/amd64/csptest -keyset -provtype 75 -newkeyset -cont '\\.\HDIMAGE\test'</code> </p> <br><p>  ou en cr√©ant le dossier / var / opt / cprocsp / keys / root / {nom du conteneur} .000, qui contient l'ensemble standard de fichiers conteneurs CryptoPro (* .key, * .mask, etc.). </p><br><p>  Apr√®s cela, le certificat du conteneur peut √™tre install√© dans le magasin de certificats: <br> <code>/opt/cprocsp/bin/amd64/certmgr -inst mMy -cont '\\.\HDIMAGE\{ }'</code> </p> <br><p>  Le certificat install√© peut √™tre vu avec la commande suivante: <br> <code>/opt/cprocsp/bin/amd64/certmgr -list mMy</code> </p> <br><p>  Le fonctionnement du certificat peut √™tre v√©rifi√© comme suit: <br> <code>/opt/cprocsp/bin/amd64/cryptcp ‚Äì sign -norev -thumbprint {} {} { }</code> <br> <code>/opt/cprocsp/bin/amd64/cryptcp ‚Äì verify -norev { }</code> </p> <br><p>  Si tout va bien avec le certificat, vous pouvez proc√©der √† la connexion dans le code. </p><br></div></div><br><h2>  Connexion en code </h2><br><p>  Malgr√© le processus de portage vers Linux, le syst√®me √©tait cens√© continuer √† fonctionner dans l'environnement Windows, donc ext√©rieurement, le travail avec la cryptographie devait √™tre effectu√© par le biais de m√©thodes g√©n√©rales de la forme ¬´octet [] SignData (octet [] _arData, X509Certificate2 _pCert)¬ª, qui devrait fonctionner de la m√™me mani√®re que sous Linux ainsi que sous Windows. </p><br><p>  L'analyse des m√©thodes des biblioth√®ques de cryptographie s'est av√©r√©e r√©ussie, car CryptoPro a impl√©ment√© la biblioth√®que ¬´libcapi20.so¬ª qui imite compl√®tement les biblioth√®ques de cryptage standard Windows - ¬´crypt32.dll¬ª et ¬´advapi32.dll¬ª.  Peut-√™tre, bien s√ªr, pas enti√®rement, mais toutes les m√©thodes n√©cessaires pour travailler avec la cryptographie y sont disponibles, et presque toutes fonctionnent. </p><br><p>  Par cons√©quent, nous formons deux classes statiques ¬´WCryptoAPI¬ª et ¬´LCryptoAPI¬ª, chacune important l'ensemble de m√©thodes n√©cessaire comme suit: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(LIBCAPI20, SetLastError = true)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CertCloseStore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertStore, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iFlags</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br><p>  La syntaxe de connexion pour chacune des m√©thodes peut √™tre cr√©√©e ind√©pendamment, ou utiliser le site Web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pinvoke</a> , ou √™tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">copi√©e √†</a> partir de sources .Net (classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CAPISafe</a> ).  √Ä partir du m√™me module, vous pouvez dessiner des constantes et des structures associ√©es √† la cryptographie, dont la pr√©sence facilite toujours la vie lorsque vous travaillez avec des biblioth√®ques externes. </p><br><p>  Et puis nous formons la classe statique "UCryptoAPI" qui, selon le syst√®me, appellera la m√©thode de l'une des deux classes: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_iFlags"&gt; (  0)&lt;/param&gt; * &lt;param name="_hCertStore"&gt;   &lt;/param&gt; * &lt;returns&gt;   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CertCloseStore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertStore, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iFlags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsLinux) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LCryptoAPI.CertCloseStore(_hCertStore, _iFlags); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WCryptoAPI.CertCloseStore(_hCertStore, _iFlags); } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt;**/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fIsLinux { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iPlatform = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) Environment.OSVersion.Platform; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (iPlatform == <span class="hljs-number"><span class="hljs-number">4</span></span>) || (iPlatform == <span class="hljs-number"><span class="hljs-number">6</span></span>) || (iPlatform == <span class="hljs-number"><span class="hljs-number">128</span></span>); } }</code> </pre><br><p>  Ainsi, en utilisant les m√©thodes de la classe UCryptoAPI, vous pouvez impl√©menter du code presque uniforme pour les deux syst√®mes. </p><br><h3>  Recherche de certificat </h3><br><p>  Le travail avec la cryptographie commence g√©n√©ralement par une recherche de certificat, pour cela dans crypt32.dll, il existe deux m√©thodes CertOpenStore (ouvre le magasin de certificats sp√©cifi√©) et un simple CertOpenSystemStore (ouvre les certificats personnels de l'utilisateur).  √âtant donn√© que l'utilisation des certificats ne se limite pas aux certificats d'utilisateur personnels, nous connectons le premier: </p><br><div class="spoiler">  <b class="spoiler_title">Recherche de certificat</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  (   )&lt;/summary&gt; * &lt;param name="_pFindType"&gt; &lt;/param&gt; * &lt;param name="_pFindValue"&gt; &lt;/param&gt; * &lt;param name="_pLocation"&gt; &lt;/param&gt; * &lt;param name="_pName"&gt; &lt;/param&gt; * &lt;param name="_pCert"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_fVerify"&gt; &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindCertificateCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _pFindValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, StoreLocation _pLocation = StoreLocation.CurrentUser, StoreName _pName = StoreName.My, X509FindType _pFindType = X509FindType.FindByThumbprint, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _fVerify = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; IntPtr hCert = IntPtr.Zero; GCHandle hInternal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GCHandle(); GCHandle hFull = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GCHandle(); IntPtr hSysStore = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   hSysStore = UCryptoAPI.CertOpenStore(UCConsts.AR_CERT_STORE_PROV_SYSTEM[fIsLinux.ToByte()], UCConsts.PKCS_7_OR_X509_ASN_ENCODING, IntPtr.Zero, UCUtils.MapX509StoreFlags(_pLocation, OpenFlags.ReadOnly), UCConsts.AR_CRYPTO_STORE_NAME[(int)_pName]); if (hSysStore == IntPtr.Zero) { _sError = UCConsts.S_ERR_STORE_OPEN.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 1)     if ((_pFindType == X509FindType.FindByThumbprint) || (_pFindType == X509FindType.FindBySerialNumber)) { byte[] arData = _pFindValue.FromHex(); CRYPTOAPI_BLOB cryptBlob; cryptBlob.cbData = arData.Length; hInternal = GCHandle.Alloc(arData, GCHandleType.Pinned); cryptBlob.pbData = hInternal.AddrOfPinnedObject(); hFull = GCHandle.Alloc(cryptBlob, GCHandleType.Pinned); } else { byte[] arData; if(fIsLinux) arData = Encoding.UTF8.GetBytes(_pFindValue); else arData = Encoding.Unicode.GetBytes(_pFindValue); hFull = GCHandle.Alloc(arData, GCHandleType.Pinned); } // 2)  IntPtr hPrev = IntPtr.Zero; do { hCert = UCryptoAPI.CertFindCertificateInStore(hSysStore, UCConsts.PKCS_7_OR_X509_ASN_ENCODING, 0, UCConsts.AR_CRYPT_FIND_TYPE[(int)_pFindType, fIsLinux.ToByte()], hFull.AddrOfPinnedObject(), hPrev); // 2.1)   if(hPrev != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hPrev); // 2.2)    if(hCert == IntPtr.Zero) return UConsts.E_NO_CERTIFICATE; // 2.3)    X509Certificate2 pCert = new ISDP_X509Cert(hCert); if (!_fVerify || pCert.ISDPVerify()) { hCert = IntPtr.Zero; _pCert = pCert; return UConsts.S_OK; } hPrev = hCert; //    hCert = IntPtr.Zero; } while(hCert != IntPtr.Zero); return UConsts.E_NO_CERTIFICATE; } catch (Exception E) { _sError = UCConsts.S_FIND_CERT_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { //      if(hInternal.IsAllocated) hInternal.Free(); if(hFull.IsAllocated) hFull.Free(); if (hCert != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hCert); UCryptoAPI.CertCloseStore(hSysStore, 0); } }</span></span></code> </pre><br></div></div><br>  La recherche se d√©roule en plusieurs √©tapes: <br><ol><li>  ouverture de stockage; </li><li>  formation de la structure de donn√©es par laquelle nous recherchons; </li><li>  recherche de certificats; </li><li>  si n√©cessaire, v√©rification du certificat (d√©crite dans une section distincte); </li><li>  fermer le r√©f√©rentiel et lib√©rer la structure √† partir du point 2 (car partout o√π il y a du travail avec de la m√©moire .Net non g√©r√©e, rien ne sera fait pour que nous le nettoyions); </li></ol><br><p>  Il y a quelques points subtils lors de la recherche de certificats. </p><br><p>  CryptoPro sur Linux fonctionne avec des cha√Ænes ANSI, et sur Windows avec UTF8, donc: </p><br><ol><li>  lors de la connexion de la m√©thode d'ouverture de stockage sous Linux, il est n√©cessaire d'indiquer explicitement le type de marshaling [In, MarshalAs (UnmanagedType.LPStr)] pour le param√®tre de code de stockage; </li><li>  en passant la cha√Æne de recherche (par exemple, par le nom de Subject), elle doit √™tre convertie en un ensemble d'octets avec diff√©rents encodages; </li><li>  pour toutes les constantes cryptographiques qui varient selon le type de cha√Æne (par exemple, CERT_FIND_SUBJECT_STR_A et CERT_FIND_SUBJECT_STR_W) sous Windows, vous devez s√©lectionner * _W et sous Linux * _A; </li></ol><br><p>  La m√©thode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MapX509StoreFlags</a> peut √™tre prise directement √† partir de sources Microsoft sans modifications, elle forme simplement un masque final bas√© sur des indicateurs .Net. </p><br><p>  La valeur par laquelle la recherche a lieu d√©pend du type de recherche (v√©rifiez aupr√®s de MSDN pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CertFindCertificateInStore</a> ), l'exemple montre les deux options les plus couramment utilis√©es - pour le format de cha√Æne (noms Subject, Issuer, etc.) et binaire (empreinte digitale, num√©ro de s√©rie). </p><br><p>  Le processus de cr√©ation d'un certificat √† partir d'IntPtr sur Windows et Linux est tr√®s diff√©rent.  Windows cr√©era le certificat de mani√®re simple: <br></p><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X509Certificate2(hCert);</code> </pre> <p></p><br><p>  sous Linux, vous devez cr√©er un certificat en deux √©tapes: <br></p><pre> <code class="cs hljs">X509Certificate2(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X509Certificate(hCert));</code> </pre> <p></p><br><p>  √Ä l'avenir, nous aurons besoin d'acc√©der √† hCert pour le travail, et il devra √™tre stock√© dans l'objet de certificat.  Sous Windows, il peut √™tre r√©cup√©r√© ult√©rieurement √† partir de la propri√©t√© Handle, mais Linux convertit la structure CERT_CONTEXT qui suit le lien hCert en un lien vers la structure x509_st (OpenSSL) et l'enregistre dans Handle.  Par cons√©quent, il vaut la peine de cr√©er un h√©ritier de X509Certificate2 (ISDP_X509Cert dans l'exemple), qui stockera hCert dans les deux syst√®mes sur un champ distinct. </p><br><p>  N'oubliez pas qu'il s'agit d'un lien vers une zone de m√©moire non manag√©e et qu'il doit √™tre lib√©r√© apr√®s la fin du travail.  Parce que  dans .Net 4.5 X509Certificate2 n'est pas jetable - le nettoyage √† l'aide de la m√©thode CertFreeCertificateContext doit √™tre effectu√© dans le destructeur. </p><br><h3>  Formation Signature </h3><br><p>  Lorsque vous travaillez avec des certificats GOST, les signatures d√©connect√©es avec un seul signataire sont presque toujours utilis√©es.  Pour cr√©er une telle signature, un bloc de code assez simple est requis: </p><br><div class="spoiler">  <b class="spoiler_title">Formation Signature</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt; * &lt;param name="_arData"&gt;  &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_arRes"&gt; &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignDataCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// 0)   CRYPT_SIGN_MESSAGE_PARA pParams = new CRYPT_SIGN_MESSAGE_PARA(); pParams.cbSize = Marshal.SizeOf(typeof(CRYPT_SIGN_MESSAGE_PARA)); pParams.dwMsgEncodingType = (int)(UCConsts.PKCS_7_OR_X509_ASN_ENCODING); pParams.pSigningCert = _pCert.getRealHandle(); pParams.cMsgCert = 1; pParams.HashAlgorithm.pszObjId = _pCert.getHashAlgirtmOid(); IntPtr pGlobData = Marshal.AllocHGlobal(_arData.Length); GCHandle pGC = GCHandle.Alloc(_pCert.getRealHandle(), GCHandleType.Pinned); try { pParams.rgpMsgCert = pGC.AddrOfPinnedObject(); Marshal.Copy(_arData, 0, pGlobData, _arData.Length); uint iLen = 50000; byte[] arRes = new byte[iLen]; // 1)   if (!UCryptoAPI.CryptSignMessage(ref pParams, true, 1, new IntPtr[1] { pGlobData }, new uint[1] { (uint)_arData.Length }, arRes, ref iLen)) { _sError = UCConsts.S_MAKE_SIGN_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } Array.Resize(ref arRes, (int)iLen); _arRes = arRes; return UConsts.S_OK;; } catch (Exception E) { _sError = UCConsts.S_MAKE_SIGN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { pGC.Free(); Marshal.FreeHGlobal(pGlobData); } }</span></span></code> </pre></div></div><br><p>  Pendant le travail de la m√©thode, une structure avec des param√®tres est form√©e et la m√©thode de signature est appel√©e.  La structure des param√®tres peut vous permettre d'enregistrer des certificats dans la signature pour former une cha√Æne compl√®te (les champs cMsgCert et rgpMsgCert, le premier stocke le nombre de certificats, la deuxi√®me liste de liens vers les structures de ces certificats). </p><br><p>  La m√©thode de signature peut recevoir un ou plusieurs documents pour une signature simultan√©e avec une signature.  Soit dit en passant, cela ne contredit pas la loi f√©d√©rale 63 et est tr√®s pratique, car il est peu probable que l'utilisateur soit satisfait de la n√©cessit√© de cliquer plusieurs fois sur le bouton ¬´signer¬ª. </p><br><p>  La principale bizarrerie de cette m√©thode est qu'elle ne fonctionne pas en mode deux appels, ce qui est typique de la plupart des m√©thodes de biblioth√®que qui fonctionnent avec de grands blocs de m√©moire (la premi√®re avec null - renvoie la longueur de tampon requise, la seconde remplit le tampon).  Par cons√©quent, il est n√©cessaire de cr√©er un grand tampon, puis de le raccourcir √† sa longueur r√©elle. </p><br><p>  Le seul probl√®me s√©rieux est la recherche de l'OID de l'algorithme de hachage (Digest) utilis√© lors de la signature - sous forme explicite, il ne se trouve pas dans le certificat (il n'y a que l'algorithme de la signature elle-m√™me).  Et si sous Windows vous pouvez le sp√©cifier avec une cha√Æne vide - il reprendra automatiquement, mais Linux refusera de signer si l'algorithme n'est pas le m√™me. </p><br><p>  Mais il y a une astuce - dans les informations sur l'algorithme de signature (structure CRYPT_OID_INFO), l'OID de signature est stock√© dans pszOID et l'identifiant de l'algorithme de hachage est stock√© dans Algid.  Et la conversion d'Algid en OID est d√©j√† une question technique: </p><br><div class="spoiler">  <b class="spoiler_title">Obtention de l'OID de l'algorithme de hachage</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; OID   &lt;/summary&gt; * &lt;param name="_hCertHandle"&gt; &lt;/param&gt; * &lt;param name="_sOID"&gt;  OID&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashAlgoritmOID</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertHandle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sOID, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _sOID = <span class="hljs-string"><span class="hljs-string">""</span></span>; IntPtr hHashAlgInfo = IntPtr.Zero; IntPtr hData = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { CERT_CONTEXT pContext = (CERT_CONTEXT)Marshal.PtrToStructure(_hCertHandle, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_CONTEXT)); CERT_INFO pCertInfo = (CERT_INFO)Marshal.PtrToStructure(pContext.pCertInfo, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_INFO)); <span class="hljs-comment"><span class="hljs-comment">//  AlgID //  UCryptoAPI.CertAlgIdToOID  Windows   ,   byte[] arData = BitConverter.GetBytes(UCryptoAPI.CertOIDToAlgId(pCertInfo.SignatureAlgorithm.pszObjId)); hData = Marshal.AllocHGlobal(arData.Length); Marshal.Copy(arData, 0, hData, arData.Length); //  OID hHashAlgInfo = UCryptoAPI.CryptFindOIDInfo(UCConsts.CRYPT_OID_INFO_ALGID_KEY, hData, UCConsts.CRYPT_HASH_ALG_OID_GROUP_ID); if (hHashAlgInfo == IntPtr.Zero) { _sError = UCConsts.S_NO_HASH_ALG_ERR.Frm( Marshal.GetLastWin32Error()); return UConsts.E_GEN_EXCEPTION; } CRYPT_OID_INFO pHashAlgInfo = (CRYPT_OID_INFO)Marshal.PtrToStructure(hHashAlgInfo, typeof(CRYPT_OID_INFO)); _sOID = pHashAlgInfo.pszOID; return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_DETERM_HASH_ALG_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { Marshal.FreeHGlobal(hData); } }</span></span></code> </pre></div></div><br><p>  Apr√®s avoir lu attentivement le code, vous serez peut-√™tre surpris que l'identifiant de l'algorithme soit obtenu de mani√®re simple (CertOIDToAlgId) et que l'Oid qu'il contient est compliqu√© (CryptFindOIDInfo).  Il serait logique de supposer l'utilisation de m√©thodes complexes ou simples, et sous Linux, les deux options fonctionnent correctement.  Cependant, sous Windows, l'option difficile d'obtenir un identifiant et d'obtenir simplement un OID est instable, donc un hybride aussi √©trange serait une solution stable. </p><br><h3>  V√©rification de signature </h3><br><p>  La v√©rification de la signature se d√©roule en deux √©tapes, au d√©but la signature elle-m√™me est v√©rifi√©e, puis le certificat avec lequel elle a √©t√© g√©n√©r√©e est v√©rifi√© (cha√Æne, date de signature, etc.). <br>  En plus de la signature, vous devez sp√©cifier l'ensemble de donn√©es √† signer, les param√®tres de signature et la signature elle-m√™me: </p><br><div class="spoiler">  <b class="spoiler_title">V√©rification de signature</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;      &lt;/summary&gt; * &lt;returns&gt;&lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CRYPT_VERIFY_MESSAGE_PARA </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStdSignVerifyPar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CRYPT_VERIFY_MESSAGE_PARA pVerifyParams = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CRYPT_VERIFY_MESSAGE_PARA(); pVerifyParams.cbSize = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Marshal.SizeOf(pVerifyParams); pVerifyParams.dwMsgEncodingType = UCConsts.PKCS_7_OR_X509_ASN_ENCODING; pVerifyParams.hCryptProv = <span class="hljs-number"><span class="hljs-number">0</span></span>; pVerifyParams.pfnGetSignerCertificate = IntPtr.Zero; pVerifyParams.pvGetArg = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pVerifyParams; } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arData"&gt;,   &lt;/param&gt; * &lt;param name="_pSign"&gt;&lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_fVerifyOnlySign"&gt;  &lt;/param&gt; * &lt;param name="_pRevMode"&gt;  &lt;/param&gt; * &lt;param name="_pRevFlag"&gt;  &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * &lt;remarks&gt;   &lt;/remarks&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSignCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _pSign, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _fVerifyOnlySign = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, X509RevocationMode _pRevMode = X509RevocationMode.Online, X509RevocationFlag _pRevFlag = X509RevocationFlag.ExcludeRoot</span></span></span><span class="hljs-function">)</span></span>{ _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; IntPtr pHData = Marshal.AllocHGlobal(_arData.Length); GCHandle pCertContext = GCHandle.Alloc(IntPtr.Zero, GCHandleType.Pinned); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Marshal.Copy(_arData, <span class="hljs-number"><span class="hljs-number">0</span></span>, pHData, _arData.Length); CRYPT_VERIFY_MESSAGE_PARA pVerParam = UCUtils.GetStdSignVerifyPar(); <span class="hljs-comment"><span class="hljs-comment">// 0)   bool fRes = UCryptoAPI.CryptVerifyDetachedMessageSignature( ref pVerParam, //   0, //   _pSign, //  _pSign.Length, //   1, // -    new IntPtr[1] { pHData }, //   new int[1] { _arData.Length }, //    pCertContext.AddrOfPinnedObject());//    if (!fRes) { _sError = UCConsts.S_SIGN_CHECK_ERR.Frm(Marshal.GetLastWin32Error().ToString("X")); return UConsts.E_CRYPTO_ERR; } // 1)   _pCert = new ISDP_X509Cert((IntPtr)pCertContext.Target); if (_pCert == null) { _sError = UCConsts.S_SIGN_CHECK_CERT_ERR; return UConsts.E_CRYPTO_ERR; } // 2)   if (!_fVerifyOnlySign) { List&lt;DateTime&gt; pDates; // 2.1)    int iRes = GetSignDateTimeCP(_pSign, out pDates, ref _sError); // 2.2)    iRes = _pCert.ISDPVerify(ref _sError, pDates[0], _pRevMode, _pRevFlag); if (iRes != UConsts.S_OK) return iRes; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_SIGN_CHECK_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION;; } finally { Marshal.FreeHGlobal(pHData); if ((_pCert == null) &amp;&amp; pCertContext.IsAllocated &amp;&amp; ((IntPtr)pCertContext.Target != IntPtr.Zero)) UCryptoAPI.CertFreeCertificateContext((IntPtr)pCertContext.Target); pCertContext.Free(); } }</span></span></code> </pre></div></div><br><p>  Pour plus de commodit√©, le processus de formation d'une structure avec des param√®tres a √©t√© d√©plac√© vers une m√©thode distincte (GetStdSignVerifyPar).  Apr√®s cela, la signature elle-m√™me est v√©rifi√©e et le premier signataire est extrait (pour de bon il faudrait tout extraire, mais une signature contenant plusieurs signataires est toujours exotique). </p><br><p>  Apr√®s avoir extrait le certificat du signataire, nous le convertirons dans notre classe et le v√©rifierons (si sp√©cifi√© dans les param√®tres de la m√©thode).  Pour la v√©rification, la date de signature du premier signataire est utilis√©e (voir la section sur l'extraction des informations de la signature et la section sur la v√©rification des certificats). </p><br><h2>  Extraire les informations de signature </h2><br><p>  Souvent, les syst√®mes cryptographiques n√©cessitent une repr√©sentation imprim√©e de la signature.  Dans chaque cas, c'est diff√©rent, il est donc pr√©f√©rable de cr√©er une classe d'informations sur la signature, qui contiendra des informations sous une forme pratique √† utiliser et, avec son aide, fournira une pr√©sentation imprim√©e.  Dans .Net, il existe une telle classe - SignedCms, cependant, son analogue en mono avec les signatures de CritoPro refuse de fonctionner dans le premier, deuxi√®mement il contient le modificateur scell√© et troisi√®mement presque toutes ses propri√©t√©s sont prot√©g√©es en √©criture, vous devez donc cr√©er votre propre analogue. </p><br><p>  La signature elle-m√™me contient deux √©l√©ments principaux - une liste de certificats et une liste de signataires.  La liste des certificats peut √™tre vide ou contenir tous les certificats √† v√©rifier, y compris les cha√Ænes compl√®tes.  La liste des signataires indique le nombre de signatures r√©elles.  La communication entre eux s'effectue par le num√©ro de s√©rie et l'√©diteur (√©metteur).  Th√©oriquement, dans une signature, il peut y avoir deux certificats d'√©diteurs diff√©rents avec le m√™me num√©ro de s√©rie, mais en pratique, cela ne peut √™tre n√©glig√© et recherch√© que par le num√©ro de s√©rie. </p><br><p>  La lecture de la signature est la suivante: </p><br><div class="spoiler">  <b class="spoiler_title">Extraire les informations de signature</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;&lt;/summary&gt; * &lt;param name="_arSign"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arSign, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { IntPtr hMsg = IntPtr.Zero; <span class="hljs-comment"><span class="hljs-comment">// 0)   try { hMsg = UCryptoAPI.CryptMsgOpenToDecode(UCConsts.PKCS_7_OR_X509_ASN_ENCODING, UCConsts.CMSG_DETACHED_FLAG, 0, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero); if (hMsg == IntPtr.Zero) { _sError = UCConsts.S_CRYP_MSG_FORM_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 1)   if (!UCryptoAPI.CryptMsgUpdate(hMsg, _arSign, (uint)_arSign.Length, true)) { _sError = UCConsts.S_CRYP_MSG_SIGN_COPY_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 2)   (PKCS7 SignedData) uint iMessType = UCUtils.GetCryptMsgParam&lt;uint&gt;(hMsg, UCConsts.CMSG_TYPE_PARAM); if (UCConsts.CMSG_SIGNED != iMessType) { _sError = UCConsts.S_CRYP_MSG_SIGN_TYPE_ERR.Frm(iMessType, UCConsts.CMSG_SIGNED); return UConsts.E_CRYPTO_ERR; } // 3)    fpCertificates = UCUtils.GetSignCertificates(hMsg); // 4)   uint iSignerCount = UCUtils.GetCryptMsgParam&lt;uint&gt;(hMsg, UCConsts.CMSG_SIGNER_COUNT_PARAM); for (int i = 0; i &lt; iSignerCount; i++) { ISDPSignerInfo pInfo = new ISDPSignerInfo(); fpSignerInfos.Add(pInfo); int iRes = pInfo.Decode(hMsg, i, this, ref _sError); if (iRes != UConsts.S_OK) return iRes; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_SIGN_INFO_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hMsg != IntPtr.Zero) UCryptoAPI.CryptMsgClose(hMsg); } }</span></span></code> </pre></div></div><br><p>  La signature est analys√©e en plusieurs √©tapes, d'abord la structure du message (CryptMsgOpenToDecode) est form√©e, puis les donn√©es de signature r√©elles (CryptMsgUpdate) y sont entr√©es.  Reste √† v√©rifier qu'il s'agit bien d'une v√©ritable signature et √† obtenir d'abord une liste de certificats, puis une liste de signataires.  La liste des certificats est r√©cup√©r√©e s√©quentiellement: </p><br><div class="spoiler">  <b class="spoiler_title">Obtenir une liste de certificats</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;     &lt;/summary&gt; * &lt;param name="_hMsg"&gt;Handle &lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> X509Certificate2Collection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSignCertificates</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hMsg</span></span></span><span class="hljs-function">)</span></span> { X509Certificate2Collection certificates = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X509Certificate2Collection(); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iCnt = GetCryptMsgParam&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt;(_hMsg, UCConsts.CMSG_CERT_COUNT_PARAM); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iCnt; i++) { IntPtr hInfo = IntPtr.Zero; IntPtr hCert = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetCryptMsgParam(_hMsg, UCConsts.CMSG_CERT_PARAM, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hInfo, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> iLen)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; hCert = UCryptoAPI.CertCreateCertificateContext(UCConsts.PKCS_7_OR_X509_ASN_ENCODING, hInfo, iLen); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hCert != IntPtr.Zero) { certificates.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ISDP_X509Cert(hCert)); hCert = IntPtr.Zero; } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hInfo != IntPtr.Zero) Marshal.FreeHGlobal(hInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hInfo != IntPtr.Zero) Marshal.FreeHGlobal(hCert); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> certificates; }</code> </pre></div></div><br><p>  Tout d'abord, le nombre de certificats est d√©termin√© √† partir du param√®tre CMSG_CERT_COUNT_PARAM, puis les informations sur chaque certificat sont r√©cup√©r√©es s√©quentiellement.  Le processus de cr√©ation du contexte du certificat et sur la base du certificat lui-m√™me ach√®ve le processus de cr√©ation. </p><br><p>  La r√©cup√©ration des donn√©es des signataires est plus difficile.  Ils contiennent une indication du certificat et une liste des param√®tres de signature (par exemple, la date de signature).  Le processus d'extraction des donn√©es est le suivant: </p><br><div class="spoiler">  <b class="spoiler_title">R√©cup√©ration des informations du signataire</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;   &lt;/summary&gt; * &lt;param name="_hMsg"&gt;Handler &lt;/param&gt; * &lt;param name="_iIndex"&gt; &lt;/param&gt; * &lt;param name="_pSignedCms"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hMsg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iIndex, ISDPSignedCms _pSignedCms, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1)   uint iLen = 0; // 2)  IntPtr hInfo = IntPtr.Zero; try { if (!UCryptoAPI.CryptMsgGetParam(_hMsg, UCConsts.CMSG_SIGNER_INFO_PARAM, (uint)_iIndex, IntPtr.Zero, ref iLen)) { _sError = UCConsts.S_ERR_SIGNER_INFO_LEN.Frm(_iIndex, Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } hInfo = Marshal.AllocHGlobal((int)iLen); if (!UCryptoAPI.CryptMsgGetParam(_hMsg, UCConsts.CMSG_SIGNER_INFO_PARAM, (uint)_iIndex, hInfo, ref iLen)) { _sError = UCConsts.S_ERR_SIGNER_INFO.Frm(_iIndex, Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } CMSG_SIGNER_INFO pSignerInfo = (CMSG_SIGNER_INFO) Marshal.PtrToStructure(hInfo, typeof(CMSG_SIGNER_INFO)); // 2.1)   byte[] arSerial = new byte[pSignerInfo.SerialNumber.cbData]; Marshal.Copy(pSignerInfo.SerialNumber.pbData, arSerial, 0, arSerial.Length); X509Certificate2Collection pLocCerts = _pSignedCms.pCertificates.Find(X509FindType.FindBySerialNumber, arSerial.Reverse().ToArray().ToHex(), false); if (pLocCerts.Count != 1) { _sError = UCConsts.S_ERR_SIGNER_INFO_CERT.Frm(_iIndex); return UConsts.E_NO_CERTIFICATE; } fpCertificate = pLocCerts[0]; fpSignedAttributes = UCUtils.ReadCryptoAttrsCollection(pSignerInfo.AuthAttrs); return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_ERR_SIGNER_INFO_READ.Frm(_iIndex, E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hInfo != IntPtr.Zero) Marshal.FreeHGlobal(hInfo); } }</span></span></code> </pre></div></div><br><p>        ,       CMSG_SIGNER_INFO.                 .  ,       . </p><br><p>       ,     ‚Äî   (        ,     ). </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;   &lt;/summary&gt; * &lt;param name="_pAttrs"&gt; &lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CryptographicAttributeObjectCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadCryptoAttrsCollection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CRYPT_ATTRIBUTES _pAttrs</span></span></span><span class="hljs-function">)</span></span> { CryptographicAttributeObjectCollection pRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CryptographicAttributeObjectCollection(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _pAttrs.cAttr; i++) { IntPtr hAttr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPtr((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)_pAttrs.rgAttr + (i * Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CRYPT_ATTRIBUTE)))); CRYPT_ATTRIBUTE pAttr = (CRYPT_ATTRIBUTE) Marshal.PtrToStructure(hAttr, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CRYPT_ATTRIBUTE)); CryptographicAttributeObject pAttrInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CryptographicAttributeObject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Oid(pAttr.pszObjId), GetAsnEncodedDataCollection(pAttr)); pRes.Add(pAttrInfo); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pRes; }</code> </pre></div></div><br><p>        Oid ‚Äì   (     ASN.1).       : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;      &lt;/summary&gt; * &lt;param name="_sName"&gt;&lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Pkcs9AttributeObject </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pkcs9AttributeFromOID</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_sName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> UCConsts.S_SIGN_DATE_OID : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pkcs9SigningTime(); <span class="hljs-comment"><span class="hljs-comment">// case UConsts.S_CONTENT_TYPE_OID : return new Pkcs9ContentType(); -&gt;&gt;  Mono  // case UConsts.S_MESS_DIGEST_OID : return new Pkcs9MessageDigest(); default: return new Pkcs9AttributeObject(); } } /**&lt;summary&gt;  ASN&lt;/summary&gt; * &lt;param name="_pAttr"&gt;&lt;/param&gt; * &lt;returns&gt;&lt;/returns&gt; * **/ internal static AsnEncodedDataCollection GetAsnEncodedDataCollection (CRYPT_ATTRIBUTE _pAttr) { AsnEncodedDataCollection pRes = new AsnEncodedDataCollection(); Oid pOid = new Oid(_pAttr.pszObjId); string sOid = pOid.Value; for (uint i = 0; i &lt; _pAttr.cValue; i++) { checked { IntPtr pAttributeBlob = new IntPtr((long)_pAttr.rgValue + (i * Marshal.SizeOf(typeof(CRYPTOAPI_BLOB)))); Pkcs9AttributeObject attribute = new Pkcs9AttributeObject(pOid, BlobToByteArray(pAttributeBlob)); Pkcs9AttributeObject customAttribute = Pkcs9AttributeFromOID(sOid); if (customAttribute != null) { customAttribute.CopyFrom(attribute); attribute = customAttribute; } pRes.Add(attribute); } } return pRes; }</span></span></code> </pre></div></div><br><p>         Pkcs9AttributeObject.   ,      mono          .       Mono       . </p><br><p>        ‚Äî        ‚Äî   SignedCms,        . </p><br><h3>  </h3><br><p>       ,   ,         .                 (,      ,       ). </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arInput"&gt;  &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_arRes"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;   ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncryptDataCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arInput, X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   CRYPT_ENCRYPT_MESSAGE_PARA pParams = new CRYPT_ENCRYPT_MESSAGE_PARA(); pParams.dwMsgEncodingType = UCConsts.PKCS_7_OR_X509_ASN_ENCODING; pParams.ContentEncryptionAlgorithm.pszObjId = _pCert.getEncodeAlgirtmOid(); pParams.cbSize = Marshal.SizeOf(pParams); // 1)   int iLen = 0; if (!UCryptoAPI.CryptEncryptMessage(ref pParams, 1, new IntPtr[] { _pCert.getRealHandle() }, _arInput, _arInput.Length, null, ref iLen)) { _sError = UCConsts.S_CRYPT_ENCODE_LEN_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 2)     _arRes = new byte[iLen]; if (!UCryptoAPI.CryptEncryptMessage(ref pParams, 1, new IntPtr[] {_pCert.getRealHandle() }, _arInput, _arInput.Length, _arRes, ref iLen)) { _sError = UCConsts.S_CRYPT_ENCODE_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_CRYPT_ENCODE_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } }</span></span></code> </pre></div></div><br><p>       ‚Äî  ,     .     , ,      . </p><br><p>       ,              ,    . </p><br><p>      .     ,            (    ).        : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; OID   &lt;/summary&gt; * &lt;param name="_hCertHandle"&gt; &lt;/param&gt; * &lt;param name="_sOID"&gt;  OID&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEncodeAlgoritmOID</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertHandle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sOID, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fNeedRelease = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _sOID = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iKeySpec = <span class="hljs-number"><span class="hljs-number">0</span></span>; IntPtr hCrypto = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)    if (!UCryptoAPI.CryptAcquireCertificatePrivateKey(_hCertHandle, 0, IntPtr.Zero, ref hCrypto, ref iKeySpec, ref fNeedRelease)) { _sError = UCConsts.S_CRYPTO_PROV_INIT_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } uint iLen = 1000; byte[] arData = new byte[1000]; uint iFlag = 1; //  // 1)      while (UCryptoAPI.CryptGetProvParam(hCrypto, UCConsts.PP_ENUMALGS, arData, ref iLen, iFlag)){ iFlag = 2; //  PROV_ENUMALGS pInfo = ConvertBytesToStruct&lt;PROV_ENUMALGS&gt;(arData); // 2)   OID     byte[] arDataAlg = BitConverter.GetBytes(pInfo.aiAlgid); IntPtr hDataAlg = Marshal.AllocHGlobal(arDataAlg.Length); try { Marshal.Copy(arDataAlg, 0, hDataAlg, arDataAlg.Length); IntPtr hHashAlgInfo2 = UCryptoAPI.CryptFindOIDInfo(UCConsts.CRYPT_OID_INFO_ALGID_KEY, hDataAlg, UCConsts.CRYPT_ENCRYPT_ALG_OID_GROUP_ID); // 2.1)  -  if (hHashAlgInfo2 != IntPtr.Zero) { CRYPT_OID_INFO pHashAlgInfo2 = (CRYPT_OID_INFO)Marshal.PtrToStructure(hHashAlgInfo2, typeof(CRYPT_OID_INFO)); _sOID = pHashAlgInfo2.pszOID ; return UConsts.S_OK; } } finally { Marshal.FreeHGlobal(hDataAlg); } } // 3)   -  _sError = UCConsts.S_NO_ENCODE_ALG_ERR; return UConsts.E_CRYPTO_ERR; } catch (Exception E) { _sError = UCConsts.S_DETERM_ENCODE_ALG_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; }finally { if((hCrypto != IntPtr.Zero) &amp;&amp; fNeedRelease) UCryptoAPI.CryptReleaseContext(hCrypto, 0); } }</span></span></code> </pre></div></div><br><p>             .        ( , , ,   .),      .          (UCConsts.CRYPT_ENCRYPT_ALG_OID_GROUP_ID).     ‚Äî    . </p><br><p>               (    ). </p><br><h3>  </h3><br><p>  ,   ,               .        .       ‚Äî  ,      : </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arInput"&gt;  &lt;/param&gt; * &lt;param name="_arRes"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;returns&gt;  ,  UCOnsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecryptDataCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arInput, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; IntPtr hSysStore = UCryptoAPI.CertOpenSystemStore(IntPtr.Zero, UCConsts.AR_CRYPTO_STORE_NAME[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)StoreName.My]); GCHandle GC = GCHandle.Alloc(hSysStore, GCHandleType.Pinned); IntPtr hOutCertL = IntPtr.Zero; IntPtr hOutCert = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   CRYPT_DECRYPT_MESSAGE_PARA pParams = new CRYPT_DECRYPT_MESSAGE_PARA(); pParams.dwMsgAndCertEncodingType = UCConsts.PKCS_7_OR_X509_ASN_ENCODING; pParams.cCertStore = 1; pParams.rghCertStore = GC.AddrOfPinnedObject(); pParams.cbSize = Marshal.SizeOf(pParams); int iLen = 0; // 1)     if (!UCryptoAPI.CryptDecryptMessage(ref pParams, _arInput, _arInput.Length, null, ref iLen, ref hOutCertL)) { _sError = UCConsts.S_DECRYPT_LEN_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 2)    _arRes = new byte[iLen]; if (!UCryptoAPI.CryptDecryptMessage(ref pParams, _arInput, _arInput.Length, _arRes, ref iLen, ref hOutCert)) { _sError = UCConsts.S_DECRYPT_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 3)     if (hOutCert != IntPtr.Zero) _pCert = new ISDP_X509Cert(hOutCert); if(_pCert != null) hOutCert = IntPtr.Zero; //    return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_DECRYPT_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if (hOutCertL != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hOutCertL); if (hOutCert != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hOutCert); GC.Free(); UCryptoAPI.CertCloseStore(hSysStore, 0); } }</span></span></code> </pre></div></div><br><p>     ,          .         ,    ( Linux    ). </p><br><h3>   </h3><br><p>      ,         ,  ,       ,      .          ,   .       : </p><br><ol><li>   ( ,    ,  . .); </li><li>    ‚Äî       ; </li><li>     ‚Äî         ; <br></li><li>     ,  ,         (CRL); </li></ol><br><p>        ,       . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme il ressort d√©j√† de l'introduction, la v√©rification de la validit√© du certificat est l'une des t√¢ches les plus difficiles. </font><font style="vertical-align: inherit;">C'est pourquoi la biblioth√®que dispose de nombreuses m√©thodes pour impl√©menter chacun des √©l√©ments individuellement. </font><font style="vertical-align: inherit;">Par cons√©quent, pour plus de simplicit√©, nous nous tournons vers les sources .Net pour la m√©thode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X509Certificate2.Verify ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et les prenons comme base.</font></font></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La v√©rification comprend deux √©tapes: </font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> former une cha√Æne de certificats jusqu'√† la racine; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> v√©rifier chacun des certificats qu'il contient (r√©vocation, d√©lai, etc.); </font></font></li></ol><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette v√©rification doit √™tre effectu√©e avant la signature et le cryptage √† la date du jour, et au moment de la v√©rification de la signature √† la date de la signature. </font><font style="vertical-align: inherit;">La m√©thode de v√©rification elle-m√™me est petite:</font></font></p><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√©rification du certificat</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_iRevFlag"&gt; &lt;/param&gt; * &lt;param name="_iRevMode"&gt; &lt;/param&gt; * &lt;param name="_hPolicy"&gt;   &lt;/param&gt; * &lt;param name="_hCert"&gt; &lt;/param&gt; * &lt;param name="_iCTLTimeout"&gt;   &lt;/param&gt; * &lt;param name="_rOnDate"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VerifyCertificate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCert, X509RevocationMode _iRevMode, X509RevocationFlag _iRevFlag, DateTime _rOnDate, TimeSpan _iCTLTimeout, IntPtr _hPolicy, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_hCert == IntPtr.Zero) { _sError = UCConsts.S_CRYPTO_CERT_CHECK_ERR; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UConsts.E_NO_CERTIFICATE; } CERT_CHAIN_POLICY_PARA pPolicyParam = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CERT_CHAIN_POLICY_PARA(Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_CHAIN_POLICY_PARA))); CERT_CHAIN_POLICY_STATUS pPolicyStatus = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CERT_CHAIN_POLICY_STATUS(Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_CHAIN_POLICY_STATUS))); <span class="hljs-comment"><span class="hljs-comment">// 1)   IntPtr hChain = IntPtr.Zero; try { int iRes = BuildChain(new IntPtr(UCConsts.HCCE_CURRENT_USER), _hCert, __iRevMode, _iRevFlag, _rOnDate, _iCTLTimeout, ref hChain, ref _sError); if (iRes != UConsts.S_OK) return iRes; // 2)   if (UCryptoAPI.CertVerifyCertificateChainPolicy(_hPolicy, hChain, ref pPolicyParam, ref pPolicyStatus)) { if (pPolicyStatus.dwError != 0) { _sError = UCConsts.S_CRYPTO_CHAIN_CHECK_ERR.Frm(pPolicyStatus.dwError); return UConsts.E_CRYPTO_ERR; } } else{ _sError = UCConsts.S_CRYPTO_CHAIN_CHECK_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_CRYPTO_CERT_VERIFY_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hChain != IntPtr.Zero) UCryptoAPI.CertFreeCertificateChain(hChain); } }</span></span></code> </pre></div></div><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, une cha√Æne est form√©e √† l'aide de la m√©thode BuildChain, puis elle est v√©rifi√©e. </font><font style="vertical-align: inherit;">Lors de la formation de la cha√Æne, la structure des param√®tres, la date de v√©rification et les drapeaux de contr√¥le sont form√©s:</font></font></p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;    &lt;/summary&gt; * &lt;param name="_hChain"&gt;  &lt;/param&gt; * &lt;param name="_iRevFlag"&gt; &lt;/param&gt; * &lt;param name="_iRevMode"&gt; &lt;/param&gt; * &lt;param name="_hChainEngine"&gt; &lt;/param&gt; * &lt;param name="_hCert"&gt; &lt;/param&gt; * &lt;param name="_rCTLTimeOut"&gt;   &lt;/param&gt; * &lt;param name="_rOnDate"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildChain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hChainEngine, IntPtr _hCert, X509RevocationMode _iRevMode, X509RevocationFlag _iRevFlag, DateTime _rOnDate, TimeSpan _rCTLTimeOut, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntPtr _hChain, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)    if (_hCert == IntPtr.Zero) { _sError = UCConsts.S_CRYPTO_CERT_CHAIN_ERR; return UConsts.E_NO_CERTIFICATE; } // 1)  CERT_CHAIN_PARA pChainParams = new CERT_CHAIN_PARA(); pChainParams.cbSize = (uint) Marshal.SizeOf(pChainParams); IntPtr hAppPolicy = IntPtr.Zero; IntPtr hCertPolicy = IntPtr.Zero; try { // 2)    pChainParams.dwUrlRetrievalTimeout = (uint)Math.Floor(_rCTLTimeOut.TotalMilliseconds); // 3)   FILETIME pVerifyTime = new FILETIME(_rOnDate.ToFileTime()); // 4)   uint _iFlags = MapRevocationFlags(_iRevMode, _iRevFlag); // 5)   if (!UCryptoAPI.CertGetCertificateChain(_hChainEngine, _hCert, ref pVerifyTime, IntPtr.Zero, ref pChainParams, _iFlags, IntPtr.Zero, ref _hChain)) { _sError = UCConsts.S_CRYPTO_CHAIN_BUILD_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } } catch(Exception E) { _sError = UCConsts.S_CRYPTO_CHAIN_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { Marshal.FreeHGlobal(hAppPolicy); Marshal.FreeHGlobal(hCertPolicy); } return UConsts.S_OK; }</span></span></code> </pre></div></div><br><p>          ,    Microsoft.  hCertPolicy  hAppPolicy   OID-,    ,     .   ,  ,     . </p><br><p>            (,   ). </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MapRevocationFlags</a> ‚Äî      .Net   ‚Äî   uint    . </p><br><h3>  Conclusion </h3><br><p>               : </p><br><ol><li>  10 ; </li><li>  ; </li><li>  byte[] {1, 2, 3, 4, 5}; </li><li>   ; </li><li>   ; </li><li>  byte[] {1, 2, 3, 4, 5}; </li><li>   ; </li></ol><br><p>      Windows   Linux  1-, 10-  50- ,     Linux    .   Linux     -   -  (   ,    ),   ¬´¬ª .       (deadlock-)   (             ¬´Access Violation¬ª). </p><br><p>           UCryptoAPI    .     fpCPSection  object        : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> fpCPSection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_hCryptMsg"&gt;  &lt;/param&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CryptMsgClose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCryptMsg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (pCPSection) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsLinux) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LCryptoAPI.CryptMsgClose(_hCryptMsg); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WCryptoAPI.CryptMsgClose(_hCryptMsg); } } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;     &lt;/summary&gt;**/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> pCPSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fpCPSection;} }</code> </pre><br><p>   ,         Linux- . </p><br><p>         mono     Issuer  Subject . , ,    mono   X500DistinguishedName    .  , mono      (     ),           (impl.issuerName  impl.subjectName).         (Reflection)      X500DistinguishedName,       CERT_CONTEXT . </p><br><h2>  Les r√©f√©rences </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  CAPILite </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> c      # </li><li>  .Net: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CAPIBase</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">X509Certificate2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SignedCMS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SignerInfo</a> </li></ol><br></li><li>  mono: <br><ol><li>  <a href="">X509Certificate2</a> </li><li>  <a href="">X509CertificateImplBtls</a> </li></ol><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423163/">https://habr.com/ru/post/fr423163/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423153/index.html">Guide Node.js, partie 2: JavaScript, V8, quelques astuces de d√©veloppement</a></li>
<li><a href="../fr423155/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 8: Mod√®le de s√©curit√© r√©seau, partie 2</a></li>
<li><a href="../fr423157/index.html">Utilisation de la fonction connect () de react-redux</a></li>
<li><a href="../fr423159/index.html">Bonne f√™te du programmeur! Aimez vos d√©veloppeurs</a></li>
<li><a href="../fr423161/index.html">Les entreprises veulent des donn√©es personnelles</a></li>
<li><a href="../fr423165/index.html">Dessin de maillage dynamique dans Unreal Engine 4</a></li>
<li><a href="../fr423167/index.html">Ce que Mark Zuckerberg parle des probl√®mes de Facebook. L'essentiel de l'article du New Yorker</a></li>
<li><a href="../fr423169/index.html">D√©marrage de la journ√©e (juillet-ao√ªt 2018)</a></li>
<li><a href="../fr423171/index.html">Comment Discord sert simultan√©ment 2,5 millions de chats vocaux √† l'aide de WebRTC</a></li>
<li><a href="../fr423173/index.html">Temps minimum - douleur maximale</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>