<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüè≠ ü§üüèª üèåÔ∏è Mergulhe profundamente nos namespaces do Linux, parte 2 üóùÔ∏è üìã üîâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na parte anterior, apenas mergulhamos os p√©s nas √°guas do espa√ßo para nome e ao mesmo tempo vimos como era f√°cil iniciar o processo em um espa√ßo para ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mergulhe profundamente nos namespaces do Linux, parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459574/"><p>  Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte anterior,</a> apenas mergulhamos os p√©s nas √°guas do espa√ßo para nome e ao mesmo tempo vimos como era f√°cil iniciar o processo em um espa√ßo para nome UTS isolado.  Nesta postagem, abordaremos o namespace do usu√°rio. </p><br><p>  Entre outros recursos relacionados √† seguran√ßa, os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">namespaces de usu√°rio</a> isolam os identificadores de usu√°rios e grupos no sistema.  Nesta postagem, focaremos apenas os recursos de identifica√ß√£o de usu√°rio e grupo (UID e GID, respectivamente), uma vez que eles desempenham um papel fundamental na realiza√ß√£o de verifica√ß√µes de permiss√µes e outras atividades relacionadas √† seguran√ßa em todo o sistema. </p><br><p>  No Linux, esses IDs s√£o simplesmente n√∫meros inteiros que identificam usu√°rios e grupos no sistema.  E alguns deles s√£o atribu√≠dos a cada processo para definir a quais opera√ß√µes / recursos esse processo pode e n√£o pode ter acesso.  A capacidade de um processo causar danos depende das permiss√µes associadas aos IDs atribu√≠dos. <a name="habracut"></a></p><br><h2 id="user-namespaces">  Namespaces de usu√°rio </h2><br><blockquote>  <em>Ilustraremos os recursos dos namespaces de usu√°rio usando apenas IDs de usu√°rio.</em>  <em>Exatamente as mesmas a√ß√µes se aplicam aos IDs de grupo, que abordaremos mais adiante nesta postagem.</em> </blockquote><p> O espa√ßo para nome do usu√°rio possui sua pr√≥pria c√≥pia dos identificadores de usu√°rio e grupo.  O isolamento permite associar o processo a outro conjunto de IDs, dependendo do espa√ßo de nome do usu√°rio ao qual ele pertence atualmente.  Por exemplo, o processo <code>$pid</code> pode ser executado a partir da <code>root</code> (UID 0) no espa√ßo de nome do usu√°rio <strong>P</strong> e repentinamente continua a ser executado no <code>proxy</code> (UID 13) ap√≥s alternar para outro espa√ßo de nome do usu√°rio <strong>Q.</strong> </p><br><p>  Os espa√ßos do usu√°rio podem ser aninhados!  Isso significa que uma inst√¢ncia de um espa√ßo para nome personalizado (pai) pode ter zero ou mais espa√ßos para nome filho, e cada espa√ßo para nome filho, por sua vez, pode ter seus pr√≥prios espa√ßos filho e assim por diante ... (at√© atingir o limite de 32 n√≠veis de aninhamento).  Quando um novo espa√ßo para nome <strong>C</strong> √© criado, o Linux define o espa√ßo para nome do usu√°rio atual do processo <strong>P,</strong> criando <strong>C</strong> como pai de <strong>C,</strong> e isso n√£o pode ser alterado posteriormente.  Como resultado, todos os espa√ßos de nome de usu√°rio t√™m exatamente um pai, formando uma estrutura de √°rvore de espa√ßos de nome.  E, como no caso de √°rvores, uma exce√ß√£o a essa regra est√° no topo, onde temos o espa√ßo para nome raiz (ou inicial, padr√£o).  Isso, se voc√™ ainda n√£o est√° fazendo algum tipo de m√°gica de cont√™iner, √© provavelmente o espa√ßo para nome do usu√°rio ao qual todos os seus processos pertencem, pois esse √© o √∫nico espa√ßo para nome do usu√°rio desde que o sistema foi iniciado. </p><br><blockquote>  <em>Nesta postagem, usaremos os prompts de comando P $ e C $ para indicar o shell que est√° sendo executado no momento no namespace de usu√°rio pai <strong>P</strong> e filho <strong>C,</strong> respectivamente.</em> </blockquote><br><h2 id="mappingi-user-id">  Mapeamentos de ID do Usu√°rio </h2><br><p>  O espa√ßo para nome do usu√°rio, de fato, cont√©m um conjunto de identificadores e algumas informa√ß√µes que conectam esses IDs com um conjunto de IDs de outro espa√ßo para nome do usu√°rio - esse dueto define uma id√©ia completa dos IDs dos processos dispon√≠veis no sistema.  Vamos ver como isso pode parecer: </p><br><pre> <code class="bash hljs">P$ whoami iffy P$ id uid=1000(iffy) gid=1000(iffy)</code> </pre> <br><p>  Em outra janela do terminal, vamos iniciar o shell usando o <code>unshare</code> (o sinalizador <code>-U</code> cria um processo no novo espa√ßo de nome do usu√°rio): </p><br><pre> <code class="bash hljs">P$ whoami iffy P$ unshare -U bash <span class="hljs-comment"><span class="hljs-comment">#    ,     user namespace C$ whoami nobody C$ id uid=65534(nobody) gid=65534(nogroup) C$ ls -l my_file -rw-r--r-- 1 nobody nogroup 0 May 18 16:00 my_file</span></span></code> </pre> <br><p>  Espere um minuto, quem?  Agora que estamos em um shell aninhado em <strong>C</strong> , o usu√°rio atual se torna ningu√©m?  Podemos adivinhar que, como <strong>C</strong> √© um novo espa√ßo para nome de usu√°rio, o processo pode ter um tipo diferente de ID.  Portanto, provavelmente n√£o esper√°vamos que ele permanecesse <code>iffy</code> , mas <code>nobody</code> √© engra√ßado.  Por outro lado, √© √≥timo porque conseguimos o isolamento que quer√≠amos.  Nosso processo agora tem uma substitui√ß√£o de ID diferente (embora quebrada) no sistema - atualmente v√™ todos como <code>nobody</code> e cada grupo como <code>nogroup</code> . </p><br><p>  As informa√ß√µes que vinculam um UID de um espa√ßo para nome de usu√°rio a outro s√£o chamadas de <strong>mapeamento de ID do usu√°rio</strong> .  √â uma tabela de pesquisa para identifica√ß√µes correspondentes no namespace de usu√°rio atual para identifica√ß√µes em outro namespace e cada namespace de usu√°rio est√° associado a exatamente um mapeamento de UID (al√©m de outro mapeamento de GID para o ID de grupo). </p><br><p>  Esse mapeamento √© o que est√° quebrado em nosso shell de <code>unshare</code> .  Acontece que os novos espa√ßos de nome de usu√°rio come√ßam com o mapeamento vazio e, como resultado, o Linux usa o usu√°rio horr√≠vel <code>nobody</code> por padr√£o.  Precisamos corrigir isso antes de podermos realizar qualquer trabalho √∫til em nosso novo espa√ßo para nome.  Por exemplo, atualmente, as chamadas do sistema (como <code>setuid</code> ) que tentam trabalhar com o UID falhar√£o.  Mas n√£o tenha medo!  Fiel √† tradi√ß√£o de <em>arquivos</em> , o Linux apresenta esse mapeamento usando o sistema de arquivos <code>/proc</code> em <code>/proc/$pid/uid_map</code> (em <code>/proc/$pid/gid_map</code> para o GID), onde <code>$pid</code> √© o ID do processo.  Vamos chamar esses dois arquivos de arquivos de <em>mapeamento.</em> </p><br><h2 id="map-fayly">  Arquivos de mapa </h2><br><p>  Arquivos de mapa s√£o arquivos especiais no sistema.  O que s√£o especiais?  Bem, retornando conte√∫dos diferentes cada vez que voc√™ os l√™, dependendo do que seu processo est√° lendo.  Por exemplo, o arquivo de mapa <code>/proc/$pid/uid_maps</code> retorna o mapeamento de UIDs do espa√ßo de nome do usu√°rio que possui o processo <code>$pid</code> para UIDs no espa√ßo de nome do usu√°rio do processo de leitura.  E, como resultado, o conte√∫do retornado ao processo <strong>X</strong> pode diferir do que retornou ao processo <strong>Y</strong> , mesmo se eles lerem o mesmo arquivo de mapa ao mesmo tempo. </p><br><p>  Em particular, o processo <strong>X</strong> , que l√™ o arquivo de mapa UID <code>/proc/$pid/uid_map</code> , recebe um conjunto de strings.  Cada linha mapeia um intervalo cont√≠nuo de UIDs para o espa√ßo <strong>de</strong> nome do usu√°rio <strong>C do</strong> processo <code>$pid</code> , correspondendo a um intervalo de UIDs em outro espa√ßo de nome. </p><br><p>  Cada linha tem o formato <code>$fromID $toID $length</code> , em que: </p><br><ul><li>  <code>$fromID</code> √© o UID inicial do intervalo para o namespace do usu√°rio do processo <code>$pid</code> </li><li>  <code>$lenght</code> √© o comprimento do intervalo. </li><li>  A tradu√ß√£o de <code>$toID</code> depende do processo de leitura <strong>X.</strong>  Se <strong>X</strong> pertencer a outro espa√ßo de nome de usu√°rio <strong>U</strong> , <code>$toID</code> √© o UID inicial do intervalo em <strong>U</strong> que mapeia a partir de <code>$fromID</code> .  Caso contr√°rio, <code>$toID</code> √© o UID inicial do intervalo em <strong>P</strong> , o namespace do usu√°rio pai do processo <strong>C.</strong> </li></ul><br><p>  Por exemplo, se um processo l√™ o arquivo <code>/proc/1409/uid_map</code> e, entre as linhas recebidas, voc√™ pode ver <code>15 22 5</code> , os UIDs de 15 a 19 no espa√ßo de nome de usu√°rio do processo <code>1409</code> mapeados para os UIDs 22-26 de um espa√ßo de nome de usu√°rio separado do processo de leitura. </p><br><p>  Por outro lado, se um processo l√™ do arquivo <code>/proc/$$/uid_map</code> (ou um arquivo de mapa de qualquer processo pertencente ao mesmo espa√ßo de nome de usu√°rio que o processo de leitura) e recebe <code>15 22 5</code> , ent√£o UIDs de 15 a 19 em o namespace <strong>C do</strong> usu√°rio √© mapeado nos UIDs de 22 a 26 do pai para o namespace do usu√°rio <strong>C.</strong> </p><br><p>  Vamos tentar: </p><br><pre> <code class="bash hljs">P$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ 1442 <span class="hljs-comment"><span class="hljs-comment">#   user namespace... C$ echo $$ 1409 # C      ,     C$ cat /proc/1409/uid_map #  #   namespace P      # UIDs    UID    P$ cat /proc/1442/uid_map 0 0 4294967295 # UIDs  0  4294967294  P  #  4294967295 -  ID no user -  C. C$ cat /proc/1409/uid_map 0 4294967295 4294967295</span></span></code> </pre> <br><p>  Bem, isso n√£o foi muito emocionante, pois foram dois casos extremos, mas isso diz algumas coisas: </p><br><ol><li>  O espa√ßo para nome do usu√°rio rec√©m-criado realmente ter√° arquivos de mapas vazios. </li><li>  O UID 4294967295 n√£o √© mape√°vel e inadequado para uso mesmo no espa√ßo para nome do usu√°rio <code>root</code> .  O Linux usa esse UID especificamente para indicar a <strong>aus√™ncia de um ID do usu√°rio</strong> . </li></ol><br><h2 id="napisanie-uid-map-faylov">  Gravando arquivos de mapa UID </h2><br><p>  Para corrigir nosso rec√©m-criado espa√ßo para nome de usu√°rio <strong>C</strong> , precisamos fornecer nossos mapeamentos necess√°rios, escrevendo seu conte√∫do para mapear arquivos para qualquer processo que perten√ßa a <strong>C</strong> (n√£o podemos atualizar esse arquivo depois de grav√°-lo).  Escrever neste arquivo informa ao Linux duas coisas: </p><br><ol><li>  Quais UIDs est√£o dispon√≠veis para processos relacionados ao espa√ßo de nomes de usu√°rio <strong>C. de</strong> destino </li><li>  Quais UIDs no namespace de usu√°rio atual correspondem aos UIDs em <strong>C.</strong> </li></ol><br><p>  Por exemplo, se escrevermos o seguinte no espa√ßo de nome do usu√°rio pai <strong>P</strong> no arquivo de mapa do espa√ßo de nome filho <strong>C</strong> : </p><br><pre> <code class="plaintext hljs">0 1000 1 3 0 1</code> </pre> <br><p>  essencialmente dizemos ao Linux que: </p><br><ol><li>  Para processos em <strong>C</strong> , os √∫nicos UIDs existentes no sistema s√£o os UIDs <code>0</code> e <code>3</code> .  Por exemplo, a chamada do sistema <code>setuid(9)</code> sempre termina com algo como um <em>ID de usu√°rio inv√°lido</em> . </li><li>  UIDs <code>1000</code> e <code>0</code> em <strong>P</strong> correspondem aos UIDs <code>0</code> e <code>3</code> em <strong>C.</strong>  Por exemplo, se um processo em execu√ß√£o com o UID <code>1000</code> em <strong>P</strong> alternar para <strong>C</strong> , ele descobrir√° que, ap√≥s a troca, seu UID se tornar√° <code>root</code> <code>0</code> . </li></ol><br><h2 id="vladelec-prostranstv-imyon-i-privilegii">  Propriet√°rio de espa√ßo para nome e privil√©gio </h2><br><p>  Em uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">postagem anterior,</a> mencionamos que, ao criar novos espa√ßos para nome, o acesso com n√≠vel de superusu√°rio √© necess√°rio.  Os espa√ßos para nome do usu√°rio n√£o imp√µem esse requisito.  De fato, outro recurso √© que eles podem <em>possuir</em> outros namespaces. </p><br><p>  Sempre que um espa√ßo para nome n√£o-usu√°rio <strong>N √© criado</strong> , o Linux atribui o espa√ßo para nome do usu√°rio atual <strong>P do</strong> processo que cria <strong>N ao</strong> <em>propriet√°rio do</em> espa√ßo <em>para</em> nome <strong>N.</strong>  Se <strong>P for</strong> criado junto com outros espa√ßos para nome na mesma chamada de sistema <code>clone</code> , o Linux garantir√° que <strong>P</strong> seja criado primeiro e se torne o propriet√°rio de outros espa√ßos para nome. </p><br><p>  O propriet√°rio dos espa√ßos para nome √© importante porque um processo que solicita uma a√ß√£o privilegiada em um recurso que n√£o seja um espa√ßo para nome do usu√°rio ter√° seus privil√©gios de UID verificados no propriet√°rio desse espa√ßo para nome do usu√°rio e n√£o no espa√ßo para nome raiz do usu√°rio.  Por exemplo, digamos que <strong>P</strong> √© o namespace do usu√°rio pai do filho <strong>C</strong> , e <strong>P</strong> e <strong>C</strong> possuem seu pr√≥prio namespace de rede <strong>M</strong> e <strong>N,</strong> respectivamente.  Um processo pode n√£o ter privil√©gios para criar os dispositivos de rede inclu√≠dos no <strong>M</strong> , mas pode faz√™-lo para <strong>N.</strong> </p><br><p>  A conseq√º√™ncia de ter um propriet√°rio de namespace para n√≥s √© que podemos descartar o requisito <code>sudo</code> ao executar comandos usando o <code>unshare</code> ou o <code>isolate</code> se solicitarmos tamb√©m a cria√ß√£o de um namespace de usu√°rio.  Por exemplo, <code>unshare -u bash</code> exigir√° <code>sudo</code> , mas a op√ß√£o <code>unshare -Uu bash</code> n√£o ser√° mais: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># UID 1000 --      user namespace P. P$ id uid=1000(iffy) gid=1000(iffy) #           # network namespace. P$ ip link add type veth RTNETLINK answers: Operation not permitted #     ,     #  user  network namespace P$ unshare -nU bash # :  sudo C$ ip link add type veth RTNETLINK answers: Operation not permitted # ,  . ,  # UID 0 (root)    ,  #     nobody.   . C$ echo $$ 13294 #   P,   UID 1000  P  UID 0  C P$ echo "0 1000 1" &gt; /proc/13294/uid_map #   ? C$ id uid=0(root) gid=65534(nogroup) C$ ip link add type veth # !</span></span></code> </pre> <br><blockquote>  <em>Infelizmente, reaplicaremos o requisito de superusu√°rio na pr√≥xima postagem, pois o <code>isolate</code> precisa de privil√©gios de <code>root</code> no espa√ßo para nome do usu√°rio raiz para configurar corretamente o espa√ßo para nome Mount e Network.</em>  <em>Mas, certamente, removeremos os privil√©gios do processo da equipe para garantir que a equipe n√£o tenha permiss√µes desnecess√°rias.</em> </blockquote><br><h2 id="kak-razreshayutsya-id">  Como os IDs s√£o resolvidos </h2><br><p>  Acabamos de ver um processo em execu√ß√£o como um usu√°rio comum <code>1000</code> repente mudado para o <code>root</code> .  N√£o se preocupe, n√£o houve aumento de privil√©gios.  Lembre-se de que este √© apenas um ID de <em>mapeamento</em> : enquanto nosso processo <em>pensa</em> que √© o <code>root</code> no sistema, o Linux sabe que <code>root</code> - no seu caso - significa o UID <code>1000</code> habitual (gra√ßas ao nosso mapeamento).  Portanto, em um momento em que os namespaces pertencentes a seu novo namespace de usu√°rio (como namespace de rede em <strong>C</strong> ) reconhecem seus direitos como <code>root</code> , outros (como namespace de rede em <strong>P</strong> ) n√£o.  Portanto, o processo n√£o pode fazer nada que o usu√°rio <code>1000</code> n√£o consiga. </p><br><p>  Sempre que um processo em um espa√ßo de nome de usu√°rio aninhado executa uma opera√ß√£o que requer verifica√ß√£o de permiss√£o - por exemplo, criando um arquivo - seu UID nesse espa√ßo de nome de usu√°rio √© comparado com o ID do usu√°rio equivalente no espa√ßo de nome do usu√°rio raiz, passando os mapeamentos na √°rvore do espa√ßo de nome para a raiz.  H√° um movimento na dire√ß√£o oposta, por exemplo, quando ele l√™ IDs de usu√°rio, como fazemos com <code>ls -l my_file</code> .  O UID do propriet√°rio <code>my_file</code> mapeado do espa√ßo de nome do usu√°rio raiz para o atual e o ID correspondente final (ou ningu√©m, se o mapeamento estiver ausente em algum lugar da √°rvore inteira) √© fornecido ao processo de leitura. </p><br><h2 id="gruppovye-id">  ID do grupo </h2><br><p>  Mesmo se estiv√©ssemos enraizados em <strong>C</strong> , ainda estamos associados ao terr√≠vel <code>nogroup</code> como nosso ID de grupo.  N√≥s apenas precisamos fazer o mesmo para o correspondente <code>/proc/$pid/gid_map</code> .  Antes de podermos fazer isso, precisamos desativar a chamada do sistema <code>setgroups</code> (isso n√£o √© necess√°rio se nosso usu√°rio j√° tiver um recurso <code>CAP_SETGID</code> em <strong>P</strong> , mas n√£o assumiremos isso, pois isso geralmente vem com privil√©gios de superusu√°rio) escrevendo "deny "para o arquivo <code>proc/$pid/setgroups</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  13294 -- pid  unshared  C$ id uid=0(root) gid=65534(nogroup) P$ echo deny &gt; /proc/13294/setgroups P$ echo "0 1000 1" &gt; /proc/13294/gid_map #  group ID   C$ id uid=0(root) gid=0(root)</span></span></code> </pre> <br><h2 id="realizaciya">  Implementa√ß√£o </h2><br><blockquote>  <em>O c√≥digo fonte desta publica√ß√£o pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .</em> </blockquote><p>  Como voc√™ pode ver, h√° muitas dificuldades associadas ao gerenciamento de namespaces de usu√°rio, mas a implementa√ß√£o √© bastante simples.  Tudo o que precisamos fazer √© escrever um monte de linhas em um arquivo - era triste descobrir o que e onde escrever.  Sem mais delongas, eis nossos objetivos: </p><br><ol><li>  Clone um processo de equipe em seu pr√≥prio espa√ßo para nome de usu√°rio. </li><li>  Escreva nos arquivos de mapa UID e GID do processo de equipe. </li><li>  Redefina todos os privil√©gios de superusu√°rio antes de executar o comando. </li></ol><br><p>  <code>1</code> alcan√ßado simplesmente adicionando o sinalizador <code>CLONE_NEWUSER</code> √† nossa chamada do sistema de <code>clone</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> clone_flags = SIGCHLD | CLONE_NEWUTS | CLONE_NEWUSER;</code> </pre> <br><p>  Para <code>2</code> adicionamos a fun√ß√£o <code>prepare_user_ns</code> , que representa cuidadosamente um usu√°rio comum <code>1000</code> como <code>root</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_userns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> line[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uid = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/uid_map"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"0 %d 1\n"</span></span>, uid); write_file(path, line); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/setgroups"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"deny"</span></span>); write_file(path, line); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/gid_map"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"0 %d 1\n"</span></span>, uid); write_file(path, line); }</code> </pre> <br><p>  E vamos cham√°-lo do processo principal no espa√ßo de nomes do usu√°rio pai antes de sinalizar o processo de comando. </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//      . int pipe = params.fd[1]; //      namespace ... prepare_userns(cmd_pid); //   ,     . ...</span></span></code> </pre> <br><p>  Para a etapa <code>3</code> atualizamos a fun√ß√£o <code>cmd_exec</code> para garantir que o comando seja executado a partir do usu√°rio n√£o privilegiado usual <code>1000</code> que fornecemos no mapeamento (lembre-se de que o usu√°rio raiz <code>0</code> no espa√ßo para nome do usu√°rio do processo da equipe √© o usu√°rio <code>1000</code> ): </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//   ' '   . await_setup(params-&gt;fd[0]); if (setgid(0) == -1) die("Failed to setgid: %m\n"); if (setuid(0) == -1) die("Failed to setuid: %m\n"); ...</span></span></code> </pre> <br><p>  E isso √© tudo!  <code>isolate</code> agora inicia o processo em um namespace de usu√°rio isolado. </p><br><pre> <code class="bash hljs">$ ./isolate sh ===========sh============ $ id uid=0(root) gid=0(root)</code> </pre> <br><p>  Havia alguns detalhes nesta postagem sobre como os espa√ßos de nome de usu√°rio funcionam, mas no final, a configura√ß√£o da inst√¢ncia foi relativamente simples.  Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pr√≥xima postagem,</a> veremos a possibilidade de executar um comando em nosso pr√≥prio espa√ßo para nome Mount usando <code>isolate</code> (revelando o segredo por tr√°s da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instru√ß√£o</a> <code>FROM</code> do <code>Dockerfile</code> ).  L√° precisaremos ajudar um pouco mais o Linux para configurar corretamente a inst√¢ncia. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459574/">https://habr.com/ru/post/pt459574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459560/index.html">Capacidades dos data centers de cont√™ineres: centro de comuta√ß√£o pronto em Mianmar em 50 dias</a></li>
<li><a href="../pt459562/index.html">Programa√ß√£o diferenci√°vel</a></li>
<li><a href="../pt459564/index.html">O que os desenvolvedores precisam saber sobre neg√≥cios</a></li>
<li><a href="../pt459568/index.html">Letra vertical na TI moderna</a></li>
<li><a href="../pt459570/index.html">Beeline mostra an√∫ncios para o bot do Google. Bot infeliz</a></li>
<li><a href="../pt459576/index.html">Extens√µes √∫teis do Google Chrome para o programador</a></li>
<li><a href="../pt459578/index.html">Sistema aberto de gerenciamento de projetos do setor p√∫blico</a></li>
<li><a href="../pt459580/index.html">Sistemas telef√¥nicos virtuais</a></li>
<li><a href="../pt459582/index.html">Vis√£o geral: como comprar a√ß√µes de empresas americanas da R√∫ssia</a></li>
<li><a href="../pt459584/index.html">Encontrei um √≥timo programador chamado Steve Wozniak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>