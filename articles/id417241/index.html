<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤º ğŸ‘¨ğŸ»â€ğŸš€ ğŸ™ŒğŸ¾ S3 metadata di PostgreSQL. Kuliah Yandex ğŸ¤³ğŸ¿ ğŸ‘©ğŸ¿â€ğŸ“ ğŸ§“ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah kuliah kedua dengan J. Subbotnik tentang database - yang pertama kami terbitkan beberapa minggu yang lalu. 

 Kepala kelompok DBMS serba gu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>S3 metadata di PostgreSQL. Kuliah Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/417241/"> Ini adalah kuliah kedua dengan J. Subbotnik tentang database - yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> kami terbitkan beberapa minggu yang lalu. <br><br>  Kepala kelompok DBMS serba guna Dmitry Sarafannikov berbicara tentang evolusi gudang data di Yandex: bagaimana kami memutuskan untuk membuat antarmuka yang kompatibel dengan S3, mengapa kami memilih PostgreSQL, penggaruk seperti apa yang kami injak dan bagaimana menanganinya. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HqPYXZDt3VA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Halo semuanya!  Nama saya Dima, di Yandex saya melakukan database. <a name="habracut"></a>  Saya akan memberi tahu Anda bagaimana kami melakukan S3, bagaimana kami melakukan persis S3, dan penyimpanan seperti apa sebelumnya.  Yang pertama adalah Elliptics, diposting di open source, tersedia di GitHub.  Banyak yang mungkin telah menemukannya. <br><img src="https://habrastorage.org/webt/ji/kg/05/jikg05jprfdg32gcrus0iunyha4.jpeg"><br>  Ini pada dasarnya adalah tabel hash terdistribusi dengan kunci 512-bit, hasil dari SHA-512.  Ini membentuk gantungan kunci yang secara acak dibagi antara mesin.  Jika Anda ingin menambahkan mesin di sana, tombolnya didistribusikan ulang, terjadi penyeimbangan ulang.  Repositori ini memiliki masalah sendiri yang terkait, khususnya, dengan penyeimbangan kembali.  Jika Anda memiliki jumlah kunci yang cukup besar, maka dengan volume yang terus tumbuh Anda perlu terus-menerus membuang mobil di sana, dan pada sejumlah besar kunci penyeimbangan mungkin tidak akan bertemu.  Ini masalah yang cukup besar. <br><br>  Tetapi pada saat yang sama, penyimpanan ini bagus untuk data statis yang kurang lebih, ketika Anda mengunggah sejumlah besar satu kali, dan kemudian menggerakkan beban baca-saja di atasnya.  Untuk keputusan seperti itu, sangat cocok. <br><br>  Kita melangkah lebih jauh.  Masalah dengan penyeimbangan kembali cukup serius, sehingga penyimpanan berikutnya muncul. <br><img src="https://habrastorage.org/webt/s6/p-/0q/s6p-0qu2vq5zqtguekkjpyvljf4.jpeg"><br>  Apa esensinya?  Ini bukan penyimpanan nilai-kunci, ini adalah penyimpanan nilai.  Saat Anda mengunggah beberapa objek atau file di sana, ia menjawab Anda dengan kunci, yang dengannya Anda dapat mengambil file ini.  Apa yang diberikannya?  Secara teoritis, akses tulis seratus persen, jika Anda memiliki ruang kosong dalam penyimpanan.  Jika Anda memiliki satu mesin tik, Anda cukup menulis ke orang lain yang tidak berbohong di mana ada ruang kosong, Anda mendapatkan kunci lain dan dengan tenang mengambil data Anda. <br><br>  Penyimpanan ini sangat mudah diukur, Anda dapat membuangnya dengan besi, ini akan berhasil.  Ini sangat sederhana, dapat diandalkan.  Satu-satunya kelemahan: klien tidak mengelola kunci, dan semua klien harus menyimpan kunci di suatu tempat, menyimpan pemetaan kunci mereka.  Ini tidak nyaman untuk semua orang.  Faktanya, ini adalah tugas yang sangat mirip untuk semua pelanggan, dan masing-masing memecahkannya dengan caranya sendiri dalam metabasisnya, dll. Ini tidak nyaman.  Tetapi pada saat yang sama, saya tidak ingin kehilangan keandalan dan kesederhanaan penyimpanan ini, bahkan berfungsi dengan kecepatan jaringan. <br><br>  Kemudian kami mulai melihat S3.  Ini adalah penyimpanan bernilai-kunci, klien mengelola kunci, seluruh penyimpanan dibagi menjadi apa yang disebut ember.  Di setiap bucket, ruang kuncinya adalah dari minus infinity hingga plus infinity.  Kuncinya adalah semacam string teks.  Dan kami sepakat, pada opsi ini.  Mengapa S3? <br><br>  Semuanya cukup sederhana.  Pada saat ini, banyak klien siap pakai untuk berbagai bahasa pemrograman telah ditulis, banyak alat siap pakai untuk menyimpan sesuatu dalam S3, katakanlah, cadangan basis data, telah ditulis.  Andrew <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara</a> tentang salah satu contoh.  Sudah ada API yang dipikirkan dengan matang yang telah berjalan di klien selama bertahun-tahun, dan Anda tidak perlu menemukan apa pun di sana.  API memiliki banyak fitur yang mudah digunakan seperti daftar, unggahan banyak bagian, dan sebagainya.  Karena itu, kami memutuskan untuk tetap menggunakannya. <br><br>  Bagaimana cara membuat S3 dari penyimpanan kami?  Apa yang terlintas dalam pikiran?  Karena klien sendiri menyimpan pemetaan kunci, kami hanya mengambil, meletakkan basis data di sebelahnya, dan kami akan menyimpan pemetaan kunci-kunci ini di dalamnya.  Saat membaca, kami hanya akan menemukan kunci dan penyimpanan di basis data kami, dan memberikan apa yang diinginkan klien.  Jika Anda membuat sketsa ini secara skematis, bagaimana isinya terjadi? <br><img src="https://habrastorage.org/webt/99/kr/9t/99kr9tmubs8skxzhbl-yrxmq4iq.jpeg"><br>  Ada entitas tertentu, di sini disebut Proxy, yang disebut backend.  Dia menerima file, mengunggahnya ke penyimpanan, mengambil kunci dari sana dan menyimpannya ke database. Semuanya cukup sederhana. <br><img src="https://habrastorage.org/webt/jx/m3/q8/jxm3q8hbv-qzn7qohrpaqw8cgv8.jpeg"><br>  Bagaimana struknya?  Proxy menemukan kunci yang diperlukan dalam database, pergi dengan kunci penyimpanan, mengunduh objek dari sana, memberikannya kepada klien.  Semuanya juga sederhana. <br><img src="https://habrastorage.org/webt/tb/w3/hw/tbw3hwknk1vjapsvw9af7pvquig.jpeg"><br>  Bagaimana pemindahannya?  Ketika menghapus langsung dari penyimpanan, proksi tidak berfungsi, karena sulit untuk mengoordinasikan database dan penyimpanan, sehingga hanya pergi ke database, mengatakan bahwa objek ini dihapus, di sana objek dipindahkan ke antrian penghapusan, dan kemudian di latar belakang seorang profesional terlatih khusus robot mengambil kunci ini, menghapusnya dari penyimpanan dan dari database.  Semuanya di sini juga cukup sederhana. <br><br>  Kami memilih PostgreSQL sebagai basis data untuk metabase ini. <br><br>  Anda sudah tahu bahwa kami sangat mencintainya.  Dengan transfer Yandex.Mail, kami memperoleh keahlian yang memadai dalam PostgreSQL, dan ketika berbagai layanan e-mail pindah, kami mengembangkan beberapa pola yang disebut pola sharding.  Salah satunya jatuh pada S3 dengan sedikit modifikasi, tapi itu berjalan dengan baik di sana. <br><br>  Apa sajakah pilihan sharding?  Ini adalah repositori besar. Pada skala Yandex-lebar, Anda harus segera berpikir bahwa akan ada banyak objek, Anda harus segera berpikir tentang cara membuang semuanya.  Anda dapat shard dengan hash atas nama objek, ini adalah cara yang paling dapat diandalkan, tetapi itu tidak akan bekerja di sini, karena S3 memiliki, misalnya, daftar yang harus menampilkan daftar kunci dalam urutan, ketika Anda cache, semua penyortiran akan hilang, Anda harus menghapus semua objek sehingga output sesuai dengan spesifikasi API. <br><br>  Opsi selanjutnya, Anda dapat shard dengan hash atas nama atau id dari ember.  Satu ember dapat hidup di dalam satu basis data. <br><br>  Pilihan lain adalah untuk beling di rentang kunci.  Di dalam ember, ada ruang dari minus tak terhingga ke plus tak terhingga, kita dapat membaginya menjadi sejumlah rentang, kami menyebutnya rentang sepotong, ia dapat hidup hanya dalam satu beling. <br><img src="https://habrastorage.org/webt/yw/d3/vh/ywd3vh23mont7zoqjcw6xmcmrbi.jpeg"><br>  Kami memilih opsi ketiga, yang dihancurkan dengan potongan-potongan, karena murni secara teoritis akan ada jumlah objek yang tak terbatas dalam satu ember, dan itu bodohnya tidak akan masuk ke dalam sepotong besi.  Akan ada masalah besar, jadi kami akan memotong dan mengatur pecahan sesuka kami.  Itu saja. <br><img src="https://habrastorage.org/webt/yu/l-/cu/yul-cuz5u4eb5w1hrtzfguio9ro.jpeg"><br>  Apa yang terjadi  Seluruh database terdiri dari tiga komponen.  S3 Proxy - sekelompok host, ada juga database.  PL / Proxy berada di bawah balancer, permintaan dari backend fly di sana.  Selanjutnya S3Meta, grup bass seperti itu, yang menyimpan informasi tentang bucket dan bongkahan.  Dan S3DB, pecahan tempat benda disimpan, antrian penghapusan.  Jika digambarkan secara skematis, sepertinya ini. <br><img src="https://habrastorage.org/webt/3y/0n/y9/3y0ny9npaewsndqfusttbvlqczk.jpeg"><br>  Permintaan datang ke S3Proxy, masuk ke S3Meta dan S3DB dan mengeluarkan informasi ke atas. <br><img src="https://habrastorage.org/webt/uw/1s/j1/uw1sj1zph_sjghozg404mmdzhnw.jpeg"><br>  Mari kita pertimbangkan lebih detail.  S3Proxy, fungsi di dalamnya dibuat dalam bahasa prosedural PLProxy, itu adalah bahasa yang memungkinkan Anda untuk menjalankan prosedur atau permintaan yang tersimpan dari jarak jauh.  Ini adalah kode dari fungsi ObjectInfo terlihat, pada dasarnya, permintaan Dapatkan. <br><br>  Cluster LProxy memiliki operator Cluster, dalam hal ini db_ro.  Apa artinya ini? <br><img src="https://habrastorage.org/webt/59/f8/sp/59f8spslkiczmbu6arwngghstoq.jpeg"><br>  Jika konfigurasi database khas beling, ada master dan dua replika.  Master memasuki db_rw cluster, ketiga host masukkan db-ro, ini adalah di mana Anda dapat mengirim hanya membaca permintaan, dan permintaan menulis dikirim ke db_rw.  Cluster db_rw mencakup semua master dari semua pecahan. <br><br>  Pernyataan RUN ON berikutnya, dibutuhkan nilai semua, yang berarti mengeksekusi pada semua pecahan baik array atau semacam pecahan.  Dalam hal ini, ia menerima hasil dari fungsi get_object_shard sebagai input, ini adalah jumlah beling di mana objek yang diberikan terletak. <br><br>  Dan target - yang berfungsi untuk memanggil remote shard.  Dia akan memanggil fungsi ini dan menggantikan argumen yang terbang ke fungsi ini. <br><img src="https://habrastorage.org/webt/kw/y3/ib/kwy3ib0cemkqipnlkceiaf_vny8.jpeg"><br>  Fungsi get_object_shard juga ditulis dalam PLProxy, sudah menjadi cluster meta_ro, permintaan akan terbang ke beling S3Meta, yang akan mengembalikan fungsi ini get_bucket_meta_shard. <br><br>  S3Meta juga bisa di-shard, kami juga meletakkannya, sementara ini tidak relevan, tetapi ada peluang.  Dan itu akan memanggil fungsi get_object_shard di S3Meta. <br><img src="https://habrastorage.org/webt/cx/t2/am/cxt2amhwudlblfjx2l8vrrzsxce.jpeg"><br>  get_bucket_meta_shard hanyalah hash teks atas nama bucket, kami mengocok S3Meta hanya dengan hash atas nama bucket. <br><img src="https://habrastorage.org/webt/sd/r9/1x/sdr91x352qh8xpccft-yay_ozqq.jpeg"><br>  Pertimbangkan S3Meta apa yang terjadi di dalamnya.  Informasi paling penting yaitu ada meja dengan potongan.  Saya memotong beberapa informasi yang tidak perlu sedikit, yang paling penting kiri adalah bucket_id, tombol mulai, tombol putus dan beling di mana potongan ini terletak. <br><img src="https://habrastorage.org/webt/-n/74/zv/-n74zv7ncle8hcvuj7-_utprjta.jpeg"><br>  Seperti apa tampilan kueri pada tabel seperti itu, yang akan mengembalikan kepada kita bongkahan di mana, misalnya, objek uji terletak?  Seperti ini  Minus infinity dalam bentuk teks, kami menyajikannya sebagai nilai nol, ada titik-titik halus sehingga Anda perlu memeriksa start_key dan end_key adalah Null. <br><img src="https://habrastorage.org/webt/ay/1f/cl/ay1fclvy9w-_0xillystohcq8v4.jpeg"><br>  Permintaan tidak terlihat sangat baik, dan rencananya terlihat lebih buruk.  Sebagai salah satu opsi untuk paket permintaan seperti itu, BitmapOr.  Dan 6.000 tulang layak untuk rencana semacam itu. <br><img src="https://habrastorage.org/webt/qn/m6/ze/qnm6zelrf6qh2q1gpf4-eaxgzle.jpeg"><br>  Bagaimana bisa berbeda?  Ada hal yang luar biasa di PostgreSQL sebagai indeks inti, yang dapat mengindeks tipe rentang, kisaran itu pada dasarnya adalah apa yang kita butuhkan.  Kami membuat jenis ini, fungsi s3.to_keyrange kembali kepada kami, pada kenyataannya, kisaran.  Kita dapat memeriksa dengan operator berisi, menemukan potongan di mana kunci kita.  Dan untuk ini, mengecualikan batasan dibangun di sini, yang memastikan non-persimpangan bongkahan ini.  Kita perlu mengizinkan, lebih disukai di tingkat basis data, beberapa kendala untuk memastikan bahwa potongan tidak dapat saling bersilangan, sehingga hanya satu baris yang dikembalikan sebagai tanggapan atas permintaan.  Kalau tidak, itu tidak akan seperti yang kita inginkan.  Ini adalah bagaimana rencana untuk permintaan seperti itu terlihat, index_scan biasa.  Kondisi ini sepenuhnya cocok dengan kondisi indeks, dan rencana seperti itu hanya memiliki 700 tulang, 10 kali lebih sedikit. <br><img src="https://habrastorage.org/webt/fz/ii/el/fziielc9cnipflupcktsoowvmle.jpeg"><br>  Apa itu Pengecualian Pengecualian? <br><img src="https://habrastorage.org/webt/f8/zc/ai/f8zcaicub3p9ob_7n2fkcefww3k.jpeg"><br>  Mari kita buat tabel uji dengan dua kolom, dan tambahkan dua kendala untuk itu, satu unik yang semua orang tahu, dan satu mengecualikan kendala, yang memiliki parameter sama, operator tersebut.  Mari kita atur dengan dua operator yang sama, plat seperti itu dibuat. <br><img src="https://habrastorage.org/webt/2o/gb/jx/2ogbjxuanf1sfqxvsaz2nm81a9o.jpeg"><br>  Kemudian kami mencoba menyisipkan dua baris yang identik, kami mendapatkan kesalahan pelanggaran keunikan kunci pada kendala pertama.  Jika kami menjatuhkannya, maka kami telah melanggar batasan pengecualian.  Ini adalah kasus umum dari kendala unik. <br><img src="https://habrastorage.org/webt/rf/jo/5c/rfjo5cabxypgt7ox6nfrptpccgc.jpeg"><br>  Faktanya, batasan unik sama dengan mengecualikan kendala dengan operator yang sama, tetapi dalam kasus pengecualian kendala, Anda dapat membuat beberapa kasus yang lebih umum. <br><img src="https://habrastorage.org/webt/t4/r5/pw/t4r5pw1rosp_z4hdf72djmkddfy.jpeg"><br>  Kami memiliki indeks seperti itu.  Jika Anda melihat lebih dekat, Anda akan melihat bahwa keduanya adalah indeks inti, dan secara umum keduanya sama.  Anda mungkin bertanya mengapa menduplikasi bisnis ini sama sekali.  Aku akan memberitahumu. <br><img src="https://habrastorage.org/webt/lj/rr/tp/ljrrtplgolj6ipalh4quhrpbqq8.jpeg"><br>  Indeks adalah hal semacam itu, terutama indeks inti, sehingga tabel dapat hidup sendiri, pembaruan terjadi, dibagi, dan seterusnya, indeks memburuk di sana, tidak lagi optimal.  Dan ada praktik seperti itu, khususnya ekstensi pg repack, indeks dibangun kembali secara berkala, sesekali mereka dibangun kembali. <br><br>  Bagaimana cara membangun kembali indeks di bawah batasan unik?  Buat buat indeks saat ini, buat indeks yang sama dengan tenang di sebelahnya tanpa mengunci, dan kemudian ekspresi ubah tabel dari constraint user_index adalah ini dan itu.  Dan semuanya, semuanya jelas dan bagus di sini, itu berfungsi. <br><br>  Dalam kasus pengecualian mengecualikan, Anda dapat membangunnya kembali hanya melalui penguncian ulang indeks, lebih tepatnya, indeks Anda akan diblokir secara eksklusif, dan pada kenyataannya Anda akan memiliki semua pertanyaan yang tersisa.  Ini tidak dapat diterima, indeks inti dapat dibangun cukup lama.  Oleh karena itu, kita tetap di sebelah indeks kedua, yang lebih kecil volumenya, membutuhkan lebih sedikit ruang, glider menggunakannya, dan kita dapat membangun kembali indeks itu secara kompetitif tanpa memblokir. <br><img src="https://habrastorage.org/webt/4t/5i/j_/4t5ij__ami8qcaik9hwlvyku4sk.jpeg"><br>  Berikut ini adalah grafik konsumsi prosesor.  Garis hijau adalah konsumsi prosesor di user_space, itu melonjak dari 50% menjadi 60%.  Pada titik ini, konsumsi turun tajam, ini adalah saat ketika indeks dibangun kembali.  Kami membangun kembali indeks, menghapus yang lama, konsumsi prosesor kami turun tajam.  Ini adalah masalah indeks inti, memang, dan ini adalah contoh yang baik tentang bagaimana hal ini bisa terjadi. <br><br>  Ketika kami melakukan semua ini, kami mulai pada versi 9.5 S3DB, sesuai rencana, kami berencana untuk menumpuk 10 miliar objek di setiap pecahan.  Seperti yang Anda ketahui, lebih dari 1 miliar dan bahkan masalah awal dimulai ketika sebuah tabel memiliki banyak baris, semuanya menjadi jauh lebih buruk.  Ada praktik berpisah.  Pada saat itu ada dua opsi, baik standar melalui pewarisan, tetapi ini tidak berfungsi dengan baik, karena ada kecepatan pemilihan partisi linier.  Dan menilai dari jumlah objek, kita membutuhkan banyak partisi.  Orang-orang dari Postgres Pro kemudian secara aktif menggergaji ekstensi pg_pathman. <br><img src="https://habrastorage.org/webt/hs/vp/ex/hsvpexzv7ox6fs7ajmyctotqlcw.jpeg"><br>  Kami memilih pg_pathman, kami tidak punya pilihan lain.  Bahkan versi 1.4.  Dan seperti yang Anda lihat, kami menggunakan 256 partisi.  Kami memecah seluruh tabel objek menjadi 256 partisi. <br><br>  Apa yang dilakukan pg_pathman?  Menggunakan ungkapan ini, Anda dapat membuat 256 partisi yang dipartisi oleh hash dari kolom tawaran. <br><img src="https://habrastorage.org/webt/5k/5h/x7/5k5hx738e1mzf4f2jcimr7snb9g.jpeg"><br>  Bagaimana cara kerja pg_pathman? <br><img src="https://habrastorage.org/webt/e7/_b/c2/e7_bc24xsopwt5pvme1xw27lhj4.jpeg"><br>  Ini mendaftarkan kaitnya di glider, dan selanjutnya pada permintaan itu menggantikan, pada dasarnya, rencana.  Kita melihat bahwa dia tidak mencari 256 partisi untuk permintaan pencarian reguler untuk suatu objek dengan tes nama, tetapi segera menentukan bahwa perlu naik ke tabel objects_54, tetapi semuanya tidak berjalan dengan lancar di sini, pg_pathman memiliki masalah sendiri.  Pertama, ada beberapa bug di awal, ketika dia menggergaji, tetapi berkat orang-orang dari Postgres Pro, mereka dengan cepat memperbaiki dan memperbaikinya. <br><br>  Masalah pertama adalah sulitnya memperbaruinya.  Masalah kedua adalah pernyataan yang disiapkan. <br><br>  Mari kita pertimbangkan lebih detail.  Secara khusus, pembaruan.  Terdiri dari apa pg_pathman? <br><img src="https://habrastorage.org/webt/zj/fp/on/zjfpond4kxp6jbx23zuuls_xxmc.jpeg"><br>  Ini pada dasarnya terdiri dari kode C, yang dikemas ke perpustakaan.  Dan itu terdiri dari bagian SQL, segala macam fungsi untuk membuat partisi, dan sebagainya.  Plus, antarmuka ke fungsi yang ada di perpustakaan.  Kedua bagian ini tidak dapat diperbarui secara bersamaan. <br><br>  Dari sini kesulitan muncul, sesuatu seperti algoritma ini untuk memperbarui versi pg_pathman, pertama-tama kita menggulung paket baru dengan versi baru, tetapi PostgreSQL memiliki versi lama yang dimuat dalam memori, ia menggunakannya.  Ini segera dalam hal apapun, pangkalan harus dihidupkan ulang. <br><br>  Selanjutnya, kita memanggil fungsi set_enable_parent, ini mengaktifkan fungsi di tabel induk, yang dimatikan secara default.  Selanjutnya, matikan pathman, restart database, katakan ALTER EXTENSION UPDATE, saat ini semuanya jatuh ke tabel induk. <br><br>  Selanjutnya, nyalakan pathman, dan jalankan fungsi, yang ada di ekstensi, yang mentransfer objek dari tabel induk yang menyerang mereka dalam periode waktu yang singkat ini, mentransfernya kembali ke tabel di mana mereka seharusnya berada.  Dan kemudian matikan penggunaan tabel induk, cari di dalamnya. <br><img src="https://habrastorage.org/webt/i0/vi/wp/i0viwpliiv3stsq2vhn2xoid9su.jpeg"><br>  Masalah selanjutnya adalah pernyataan yang disiapkan. <br><img src="https://habrastorage.org/webt/7a/kn/3v/7akn3vmg3-owux9ywqyqocpn1e0.jpeg"><br>  Jika kami memblokir permintaan biasa yang sama, cari berdasarkan tawaran dan kunci, coba jalankan.  Lakukan lima kali - semuanya baik-baik saja.  Kami melakukan yang keenam - kami melihat rencana seperti itu.  Dan dalam hal ini kita melihat semua 256 partisi.  Jika Anda perhatikan dengan cermat kondisi-kondisi ini, kita melihat dolar 1, dolar 2, inilah yang disebut rencana umum, rencana umum.  Lima pertanyaan pertama dibangun secara individual, rencana individual digunakan untuk parameter ini, pg_pathman dapat segera menentukan, karena parameter diketahui sebelumnya, ia dapat langsung menentukan tabel ke mana harus pergi.  Dalam hal ini, dia tidak bisa melakukan ini.  Dengan demikian, rencana harus memiliki semua 256 partisi, dan ketika pelaksana melakukan ini, ia pergi dan mengambil kunci bersama untuk semua 256 partisi, dan kinerja solusi seperti itu tidak segera.  Itu hanya kehilangan semua kelebihannya, dan permintaan apa pun dilakukan sangat lama. <br><img src="https://habrastorage.org/webt/pg/ny/vr/pgnyvrsmxkaizxhi1ifdazcith8.jpeg"><br>  Bagaimana kita bisa keluar dari situasi ini?  Saya harus membungkus semuanya di dalam prosedur yang tersimpan dalam menjalankan, dalam SQL dinamis, sehingga pernyataan yang disiapkan tidak digunakan dan rencana itu dibangun setiap waktu.  Begitulah cara kerjanya. <br><br>  Kelemahannya adalah Anda harus menjejalkan semua kode ke dalam struktur yang menyentuh tabel ini.  Ini sulit dibaca di sini. <br><img src="https://habrastorage.org/webt/rh/6i/p9/rh6ip927nxvaryx5lq7uw80kc_w.jpeg"><br>  Bagaimana distribusi benda?  Di setiap beling S3DB, penghitung potongan disimpan, ada juga informasi tentang potongan mana yang ada di dalam beling ini, dan penghitung disimpan untuknya.  Untuk setiap operasi yang bermutasi pada objek - menambah, menghapus, mengubah, menulis ulang - penghitung ini untuk perubahan chunk.  Agar tidak memperbarui baris yang sama ketika menuangkan aktif dalam bongkahan ini, kami menggunakan teknik yang cukup standar ketika kami memasukkan penghitung delta ke dalam tabel yang terpisah, dan sekali satu menit robot khusus melewati dan mengumpulkan semua ini, memperbarui penghitung di bongkahan . <br><img src="https://habrastorage.org/webt/xe/rn/hv/xernhvrnmssloj0y6mngbtwi9zg.jpeg"><br>  Selanjutnya, penghitung ini dikirim ke S3Meta dengan beberapa penundaan, sudah ada gambaran lengkap tentang berapa banyak penghitung di mana bongkahan, maka Anda dapat melihat distribusi dengan pecahan, berapa banyak objek dalam pecahan apa, dan berdasarkan ini, keputusan dibuat di mana bongkahan baru jatuh.  Ketika Anda membuat sebuah ember, secara default, satu bongkahan dibuat dari minus tak terhingga ke plus tak terhingga, tergantung pada distribusi objek saat ini yang diketahui oleh S3Meta, itu jatuh ke dalam semacam beling. <br><br>  Saat Anda menuangkan data ke dalam ember ini, semua data ini dituangkan ke dalam chunk ini, ketika ukuran tertentu tercapai, sebuah robot khusus datang dan berbagi chunk ini. <br><img src="https://habrastorage.org/webt/6g/9x/jx/6g9xjxmouaqfyz9-lt-d-qnl-fy.jpeg"><br>  Kami membuat bongkahan ini kecil.  Kami melakukan ini sehingga dalam hal ini bongkahan kecil ini dapat diseret ke pecahan lain.  Bagaimana perpecahan potongan terjadi?  Ini adalah robot biasa, ia pergi dan membagi potongan ini dalam S3DB dengan komit dua fase dan memperbarui informasi dalam S3Meta. <br><img src="https://habrastorage.org/webt/9p/ec/pg/9pecpg4ivr6x4fbtp4dwgv6rhie.jpeg"><br>  Chunk transfer adalah operasi yang sedikit lebih rumit, ini adalah komit dua fase atas tiga pangkalan, S3Meta dan dua pecahan, S3DB, diseret dari satu, ke yang lain. <br><img src="https://habrastorage.org/webt/re/1o/so/re1osogppbljsj7camywvynnjg4.jpeg"><br>  S3 memiliki fitur seperti daftar, ini adalah hal yang paling sulit, dan ada masalah dengannya juga.  Bahkan, daftar, Anda mengatakan S3 - tunjukkan benda yang saya miliki.  Parameter yang disorot dalam warna merah sekarang Null.  Parameter ini, delimeter, pemisah, Anda dapat menentukan daftar pemisah mana yang Anda inginkan. <br><img src="https://habrastorage.org/webt/ws/pg/ld/wspgldab_p7mtvwl1p-2rahx48s.jpeg"><br>  Apa artinya ini?  Jika delimeter tidak disetel, kita melihat bahwa kita hanya diberi daftar file.  Jika kita mengatur delimeter, pada intinya, S3 harus menunjukkan folder.  Saya harus mengerti bahwa ada folder seperti itu, dan pada kenyataannya, itu menunjukkan semua folder dan file di folder saat ini.  Folder saat ini diawali, parameter ini kosong.  Kami melihat ada 10 folder. <br><br>  Semua kunci tidak disimpan dalam semacam struktur hierarki pohon, seperti dalam sistem file.  Setiap objek disimpan sebagai string, dan mereka memiliki awalan umum yang sederhana.  S3 sendiri harus mengerti bahwa ini adalah keledai. <br><img src="https://habrastorage.org/webt/pi/3p/dq/pi3pdqgonztctekxsrwxg_go5ra.jpeg"><br>        SQL,      .      ,     PL/pgSQL.       ,   repeatable read.      ,      . ,  -     - ,    . <br><br>        Recursive CTE,       ,   -  ,       execute  PL/pgSQL.   ,      .  , ,  ,    list objects. ,     . <br><img src="https://habrastorage.org/webt/bn/ng/t5/bnngt5vw2so41bmailmlzscffom.jpeg"><br>   ,    . <br><br>      .       ,         . <br><img src="https://habrastorage.org/webt/df/am/2x/dfam2xo8k6ohr6gkv9mo1d5pmsa.jpeg"><br>     Docker,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Behave</a>   Behave   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  .  ,   , ,    . <br><br>      .   ,    ,   CPU  S3Meta. Gist index    CPU,         , . CPU  S3Meta   .   ,      .       PLProxy  ,        S3Meta  S3DB.  ,      .          S3Meta   .  ,    . <br><br>      ,   ,     .   â€”    ,     range  btree.    ,  btree     .   ,       ,      btree.     ,  .    PL/pgSQL-.    ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417241/">https://habr.com/ru/post/id417241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417231/index.html">Corporate Merch dengan Human UI</a></li>
<li><a href="../id417233/index.html">Google Code-in 2017</a></li>
<li><a href="../id417235/index.html">Bagaimana toko online kehilangan uang karena alamat formulir pemesanan</a></li>
<li><a href="../id417237/index.html">Apa yang pengembang dengarkan: dari klasik hingga soundtrack game - kami membahas semua yang paling menarik</a></li>
<li><a href="../id417239/index.html">Intisari materi menarik untuk pengembang seluler # 261 (9 Juli - 15 Juli)</a></li>
<li><a href="../id417243/index.html">Instal 3CX SBC Session Edge Controller di Windows, Raspberry Pi, atau Debian 9</a></li>
<li><a href="../id417245/index.html">Erlang untuk IoT</a></li>
<li><a href="../id417247/index.html">VSCE # 1: Podcast Pengusaha Media</a></li>
<li><a href="../id417249/index.html">Kamar Audit AS memperingatkan: SpaceX dan Boeing sedang menunggu penundaan baru, gangguan AS dalam penerbangan ke ISS dimungkinkan</a></li>
<li><a href="../id417251/index.html">Menggunakan mata Ikan pada Raspberry Pi 3 dengan ROS - Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>