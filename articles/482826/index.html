<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèæ üà∑Ô∏è üèÑ Analizando una demostraci√≥n de 128 bytes del archivo de 1997 üë©üèª‚Äç‚úàÔ∏è üß¢ üõÄüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es muy agradable cumplir mis deseos, especialmente del pasado lejano, tan distante que ya olvid√© que alguna vez lo quise. S√© poco sobre el demoscene y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analizando una demostraci√≥n de 128 bytes del archivo de 1997</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482826/"> Es muy agradable cumplir mis deseos, especialmente del pasado lejano, tan distante que ya olvid√© que alguna vez lo quise.  S√© poco sobre el demoscene y ciertamente nunca segu√≠ a los autores o su trabajo, simplemente me gust√≥ ver lo que sucedi√≥.  A veces quer√≠a resolverlo, pero luego me faltaba conocimiento y experiencia, perseverancia posterior, y luego perd√≠ completamente el inter√©s en esto.  Pero recientemente, mi amigo, con quien estudiamos en ese momento y que nos suministr√≥ todos los productos nuevos, incluidas demostraciones, con BBS y Fidonet, porque casi todos ten√≠an un tel√©fono y un m√≥dem y una computadora al mismo tiempo, visit√≥ <a href="https://cafeparty.org.ru/2019/" rel="nofollow">CAFePARTY</a> con sus obras. eso me hizo abrir el archivo de mi primera computadora, seleccionar una demostraci√≥n y resolverlo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/no/yt/35/noyt35q-swsum-xmzb10a5px1rk.gif" alt="pentagra.com"></div><br>  Evaluando objetivamente mis fortalezas, tom√© una introducci√≥n de 128 bytes que me gust√≥ visualmente.  El archivo <code>pentagra.com</code> est√° firmado por <b>Mcm</b> , 128 bytes, √∫ltima modificaci√≥n 24/09/1996 18:10:14, volcado hexadecimal: <br><br> <code>000000: b0 13 cd 10 68 00 a0 07 06 1f ac ba c8 03 ee 42 <br> 000010: b1 40 ee 40 6e 6e e2 fa b8 3f 3f bb 40 01 bf 40 <br> 000020: 05 57 b1 78 ab 03 fb e2 fb 5f b1 60 88 01 aa 03 <br> 000030: fb 03 fb e2 f7 b1 61 88 01 aa 2b fb 2b fb e2 f7 <br> 000040: bf d1 99 57 b1 78 ab 2b fb e2 fb 5f b1 8f f3 ab <br> 000050: 81 fe 00 fa 73 12 ac 0a c0 74 0d 48 88 44 fe 88 <br> 000060: 04 88 40 ff 88 84 bf fe 03 f2 42 75 e3 e4 60 3c <br> 000070: 01 75 a5 b8 03 00 cd 10 c3 00 00 00 00 4d 63 6d <br></code> <a name="habracut"></a><br>  Del mismo archivo que saqu√©: <br><br><ul><li>  <b>Hiew 6.11</b> ( <a href="http://www.hiew.ru/" rel="nofollow">6.50</a> se puede encontrar en el sitio) - Lo us√© como desensamblador </li><li>  Paquete <b>TASM</b> : con el que recog√≠ el c√≥digo recibido para asegurarme de no estropear nada </li><li>  <b>¬°Ayuda TECH de Flambeaux Software!</b>  <b>6.0</b> - referencia en l√≠nea moderadamente detallada y completa para API de DOS, funciones de BIOS, hardware y ensamblador </li><li>  <b>Mayko G.V.</b>  <b>Ensamblador para PC IBM</b> : una referencia de formato de bolsillo para todos los comandos b√°sicos Intel 8086 y las reglas de formato de texto del programa.  Sin detalles arquitect√≥nicos y con ejemplos elementales, solo las cosas m√°s b√°sicas.  Aqu√≠ hay casi todo lo que necesita, pero no puede escribir en ensamblador aparte del entorno. </li><li>  Por lo tanto, el segundo libro <b>Zubkov S.V.</b>  <b>Ensamblador.</b>  <b>Para DOS, Windows y Unix</b> : una gu√≠a para los rincones de hardware y DOS </li></ul><br>  Desde la implementaci√≥n m√≠nima extrema, uno deber√≠a esperar el uso de trucos y enfoques no est√°ndar, pero aparte de algunas suposiciones en las condiciones iniciales, no vi ning√∫n truco t√©cnico, pero vi un truco algor√≠tmico.  Y aqu√≠ se deben decir algunas palabras sobre la experiencia.  ¬øCu√°l podr√≠a ser la dificultad?  Ya sea en la implementaci√≥n o en el algoritmo.  Por ejemplo, en el comando <code>mov di, 099d1h</code> , puede tener miedo a una constante m√°gica.  Pero si se encuentra en el contexto de uso, queda claro que esta es la direcci√≥n de acceso en las coordenadas de pantalla X e Y, donde X = 17, Y = 123, 320 es la resoluci√≥n horizontal de la pantalla en p√≠xeles.  Juntos, esto nos da 17 + 123 * 320, la conversi√≥n de coordenadas bidimensionales a unidimensionales. <br><br>  Mirando ahora lo que est√° sucediendo en la pantalla, puedo imaginar f√°cilmente c√≥mo podr√≠a implementar esto, aunque no con 128 bytes, aunque no sea 100% similar, pero podr√≠a.  Y hace 20 a√±os, no pod√≠a, aunque saqu√© todas las herramientas que usaba de los estantes polvorientos y no tuve que navegar por Internet para comprender c√≥mo funciona.  Por lo tanto, en primer lugar, este es un contexto, una comprensi√≥n de QU√â est√° sucediendo, por lo que la cuesti√≥n de los trucos y C√ìMO hacer esto est√° en segundo lugar. <br><br>  Que vemos <br><br><ol><li>  5 l√≠neas del pentagrama.  Estas no son necesariamente l√≠neas directas inextricables seg√∫n todos los c√°nones.  Solo vemos la figura general, sin detalles </li><li>  El efecto de la llama, que consta de dos partes importantes: una paleta seleccionada correctamente y un algoritmo para cambiar constantemente el color de los puntos en la pantalla con elementos de incertidumbre, pero manteniendo una secuencia de paleta continua para los puntos vecinos.  Por ejemplo, puede calcular toda la pantalla actual promediando los valores de los p√≠xeles vecinos de la pantalla anterior y agregar m√°s puntos "brillantes" en lugares aleatorios, o no en lugares aleatorios, pero de valor aleatorio, o no por casualidad, simplemente al√©jese del orden lineal.  Una opci√≥n es <a href="https://habr.com/ru/post/435122/">c√≥mo se hace en DOOM</a> .  El resultado debe ser en forma de colores que fluyan entre s√≠, desde √°reas brillantes que emergen constantemente hasta desvanecimiento </li></ol><br>  Queda por entender c√≥mo se hizo esto.  Una descripci√≥n adicional no reemplazar√° el conocimiento sobre la arquitectura de la computadora y las funciones de DOS o ensamblador, pero tener este conocimiento le permitir√° comprender y enfocarse en la esencia de lo que est√° sucediendo.  Despu√©s de comenzar a escribir, me di cuenta de que resulta igual con suficiente detalle, pero no pod√≠a rechazarlo para no perder en el sentido de la historia. <br><br><h3>  DOS y cargando programas .COM </h3><br>  El programa en el archivo <code>.com</code> es un c√≥digo limpio, sin encabezados, solo necesita colocarlo en el lugar correcto.  Esto es lo que hace DOS, o m√°s bien la llamada al sistema 4Bh.  Se est√°n llevando a cabo muchas acciones, deteng√°monos en el resultado: <br><br><ul><li>  Todos los segmentos registran CS, DS, ES, SS cargados con un solo valor </li><li>  65536 bytes est√°n reservados para todo el programa, exactamente un segmento al que indican todos los registros de segmento.  Los primeros 256 bytes est√°n ocupados por el encabezado del sistema: PSP (Prefijo de segmento de programa).  En CS: 0, el primer campo de la PSP, se encuentra el comando INT 20h, para finalizar el programa actual y transferir el control al proceso padre.  El programa en s√≠ mismo comienza con la direcci√≥n CS: 100h y ocupa los siguientes 128 bytes </li><li>  La palabra 0000h se inserta en la pila, el registro SP es FFFEh.  Esto significa que los dos √∫ltimos bytes en este segmento en la direcci√≥n SS: FFFEh se restablecen.  De hecho, esta es la direcci√≥n de retorno m√°s cercana del procedimiento, lo que nos llevar√° al comando de finalizaci√≥n en CS: 0 </li><li>  Los registros AL y AH contienen un indicador de error para determinar las letras de unidad del primer y segundo argumento cuando se llama al programa.  Si no hay errores, entonces son 0, si los hay, entonces FFh </li></ul><br>  Sinceramente cre√≠ que en el caso general el estado de los registros no est√° definido.  Pero en el c√≥digo analizado, en mi opini√≥n, se hace una suposici√≥n muy audaz sobre su estado inicial, en particular sobre los registros CX, SI y la bandera de direcci√≥n DF.  No encontr√© confirmaci√≥n de esto en la lista de fuentes que result√≥ arriba, as√≠ que fui a revisar las fuentes de <a href="" rel="nofollow">MS-DOS 2.0</a> : <br><br><ul><li>  Sobre el DF, podemos suponer que el comando <code>cld</code> lo <code>cld</code> porque este √∫ltimo usa la direcci√≥n hacia adelante antes de transferir el control a los avances de l√≠nea, por lo tanto, el DF se reinicia.  Aunque no hay un uso expl√≠cito de <code>cld</code> en este lugar, el comando para borrar el indicador de direcci√≥n se encuentra con bastante frecuencia antes de muchas otras transferencias </li><li>  SI contiene 100h, porque se usa para determinar el desplazamiento que el contador de comandos IP cargar√° en el registro </li><li>  CX es igual a FFh, porque se usa como un contador con un valor inicial de 80 h para transferir el contenido de toda la l√≠nea de comando y, en consecuencia, despu√©s de transferirlo es 0. Y despu√©s de eso, CL, como variable temporal, carga FFh y se usa para establecer el indicador de error de la letra de unidad en AL y AH </li></ul><br>  No hay fuentes de versiones m√°s nuevas, pero hay <a href="https://sourceforge.net/projects/dosbox/files/dosbox/" rel="nofollow">fuentes de DOSBox</a> : <br><br><pre> <code class="cpp hljs">reg_ax=reg_bx=<span class="hljs-number"><span class="hljs-number">0</span></span>;reg_cx=<span class="hljs-number"><span class="hljs-number">0xff</span></span>; reg_dx=pspseg; reg_si=RealOff(csip); reg_di=RealOff(sssp);</code> </pre><br>  Es decir, coincide con lo que vi en el c√≥digo fuente de MS-DOS (¬°segunda versi√≥n!). Puede ver los valores iniciales de otros registros, aqu√≠ es una inicializaci√≥n expl√≠cita y especial.  Para MS-DOS, los valores de los registros que no sean AX, segmento y pila son rudimentos de su uso para otros fines; esto no es un dogma o est√°ndar, por lo tanto, no se mencionan en ninguna parte.  Pero, por otro lado, el ecosistema que se ha formado y todo el dolor de Microsoft al admitir la compatibilidad con versiones anteriores, obligando a arrastrar todos los valores generados aleatoriamente detr√°s de √©l, se est√° volviendo un poco comprensible, porque los programadores est√°n tan acostumbrados a ellos. <br><br>  Finalmente, para nosotros este conocimiento es suficiente, comenzamos a restaurar el programa desde los encabezados: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">.186</span></span> .model tiny .code .startup</code> </pre><br>  Determinamos el tipo de procesador 80186, porque usamos el comando <code>outsb</code> , que apareci√≥ solo en este modelo.  Un segmento de c√≥digo y un punto de entrada al programa, que, junto con la definici√≥n del modelo de memoria <code>tiny</code> , permitir√° al compilador calcular correctamente todos los desplazamientos de variables y transiciones.  Al construir <code>tlink</code> , se <code>tlink</code> el <code>tlink</code> <code>/t</code> ; en la salida, esto dar√° un archivo <code>.com</code> . <br><br><h3>  Gr√°ficos y paleta </h3><br>  Para cambiar al modo gr√°fico, debe recurrir a la funci√≥n BIOS, para lo cual se llama una interrupci√≥n de 10 h, AH = 0, en AL ponemos el identificador del modo deseado - 13 h: <br><br><pre> <code class="cpp hljs">mov al, <span class="hljs-number"><span class="hljs-number">13</span></span>h ;b0 <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h ;cd <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Tenga en cuenta que no tocamos AH, suponiendo que haya cero, de acuerdo con las condiciones de carga del programa.  El modo seleccionado corresponde a una resoluci√≥n gr√°fica de 320 por 200 p√≠xeles con una paleta de 256 colores.  Para mostrar un punto en la pantalla, debe escribir en el √°rea de memoria, que comienza con la direcci√≥n A000h: 0, el byte correspondiente al color.  Rellene registros de datos de segmento con este valor: <br><br><pre> <code class="cpp hljs">push <span class="hljs-number"><span class="hljs-number">0</span></span>a000h ;<span class="hljs-number"><span class="hljs-number">68</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> a0 pop es ;<span class="hljs-number"><span class="hljs-number">07</span></span> push es ;<span class="hljs-number"><span class="hljs-number">06</span></span> pop ds ;<span class="hljs-number"><span class="hljs-number">1f</span></span></code> </pre><br>  L√≥gicamente, la memoria est√° organizada como una matriz bidimensional en la que se muestran las coordenadas de la pantalla, 0: 0 corresponde a la esquina superior izquierda.  Despu√©s de cambiar el modo, se llena con ceros: negro en la paleta predeterminada.  La f√≥rmula para traducir al desplazamiento lineal es <b>X + Y * L</b> , donde L es la resoluci√≥n horizontal, en nuestro caso 320. En esta forma, escribir√© en aquellos lugares donde se usan las constantes, al traducir el texto del programa se calculan autom√°ticamente. <br><br>  Para cambiar la paleta, accedemos directamente al equipo utilizando los puertos de entrada / salida: <br><br><pre> <code class="cpp hljs">lodsb ;ac mov dx, <span class="hljs-number"><span class="hljs-number">03</span></span>c8h ;ba c8 <span class="hljs-number"><span class="hljs-number">03</span></span> out dx, al ;ee</code> </pre><br>  El primer comando carga en AL el byte de datos ubicado en DS: SI.  En DS, hemos cargado la direcci√≥n del segmento de la memoria de video y sabemos que est√° llena de ceros, en SI, en el caso general, no se sabe que al menos 0. No nos importa donde SI lo indique, casi con certeza ingresamos en la memoria de video que ocupa con esta resoluci√≥n 320 * 200 = 64000 bytes, casi todo el segmento.  Por lo tanto, esperamos que despu√©s de este comando AL = 0.  Se agrega o resta una unidad a SI, depende de la configuraci√≥n del indicador de direcci√≥n DF.  Si bien esto tampoco es particularmente importante para nosotros, no importa d√≥nde se mueva el SI, todav√≠a permanecemos en el √°rea de memoria de video llena de ceros. <br><br>  A continuaci√≥n, cargue el DX con el n√∫mero de puerto 03C8h, cuya salida determina qu√© color de 256 vamos a anular.  En nuestro caso, es 0 de AL. <br><br>  El color est√° codificado en la paleta RGB y para esto debe escribir en el puerto 03C9h (uno m√°s de 3C8h) tres veces seguidas, una vez para cada uno de los componentes.  El brillo m√°ximo del componente es 63, el m√≠nimo es 0. <br><br><pre> <code class="cpp hljs">inc dx ;<span class="hljs-number"><span class="hljs-number">42</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">64</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">40</span></span> PALETTE: out dx, al ;ee inc ax ;<span class="hljs-number"><span class="hljs-number">40</span></span> outsb ;<span class="hljs-number"><span class="hljs-number">6</span></span>e outsb ;<span class="hljs-number"><span class="hljs-number">6</span></span>e loop PALETTE ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-6</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">,    6  </span></span></code> </pre><br>  Aumente DX en uno para que tenga el n√∫mero de puerto deseado.  CL es nuestro contador de ciclos de 64, y suponemos que CH = 0, como se describi√≥ anteriormente en funci√≥n de las condiciones de carga inicial.  Luego, enviamos el primer componente al puerto: el rojo, cuyo brillo se almacenar√° en AL, es lo que cambiaremos, en el primer paso 0. Despu√©s de eso, aumentamos su brillo en uno para mostrarlo en la pr√≥xima iteraci√≥n.  A continuaci√≥n, ejecutamos dos comandos <code>outsb</code> escriben en el puerto, cuyo n√∫mero est√° contenido en DX, el byte del √°rea de memoria DS: SI, recuerde que tenemos ceros all√≠.  SI cada vez cambia por uno. <br><br>  Tan pronto como deducimos los tres componentes, se agrega autom√°ticamente una unidad al n√∫mero de color.  Por lo tanto, no es necesario redefinir el color enviando al puerto 3C8h si los colores est√°n en una fila, seg√∫n sea necesario.  El comando de <code>loop</code> reducir√° CX en uno, si se obtiene un valor distinto de cero, ir√° al comienzo del ciclo, si es 0, luego al siguiente comando despu√©s del ciclo. <br><br>  Un total de 64 repeticiones.  En cada repetici√≥n, determinamos para el color, comenzando de 0 a 63, el componente rojo con brillo que coincide con el n√∫mero de color actual.  Restablecemos los componentes verde y azul para obtener una paleta de brillo rojo m√≠nimo a m√°ximo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/py/jq/lzpyjqjyav0-x3qdl5easmdesvs.png" alt="paleta"></div><br><br><h3>  L√≠neas </h3><br>  Configure el color inicial y los valores de coordenadas: <br><br><pre> <code class="cpp hljs">LINES: mov ax, <span class="hljs-number"><span class="hljs-number">03f</span></span>3fh ;b8 <span class="hljs-number"><span class="hljs-number">3f</span></span> <span class="hljs-number"><span class="hljs-number">3f</span></span> mov bx, <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bb <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> mov di, <span class="hljs-number"><span class="hljs-number">64</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bf <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> push di ;<span class="hljs-number"><span class="hljs-number">57</span></span></code> </pre><br>  En AL y AH cargamos el m√°ximo color posible (m√°s brillante) 63 (3Fh), respectivamente, AX define dos puntos a la vez.  BX: resoluci√≥n horizontal m√°xima.  En el futuro, esto se usar√° para sumar o restar una l√≠nea de las coordenadas actuales.  DI - coordina 64: 4, gu√°rdelos en la pila. <br><br>  <b>Dibuja la primera l√≠nea desde la esquina superior izquierda hasta el extremo derecho</b> : <br><br><pre> <code class="cpp hljs">mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">78</span></span> LINE1: stosw ;ab add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb loop LINE1 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  Configure el contador: este ser√° el n√∫mero de l√≠neas.  A continuaci√≥n, guarde la palabra (dos bytes) de AX en la direcci√≥n ES: DI.  Esta acci√≥n mostrar√° dos puntos en la pantalla con el color m√°ximo de nuestra paleta, porque el ES est√° configurado para la memoria de video y las coordenadas espec√≠ficas se configuran en DI.  Despu√©s de esta acci√≥n, se agregar√°n 2 a la DI, ya que se escribieron dos bytes.  Obviamente no establecemos el indicador de direcci√≥n del DF y confiamos en el hecho de que se restablece, nuevamente recordamos nuestras condiciones iniciales para cargar el programa.  De lo contrario, los dos ser√≠an eliminados, lo que no permitir√≠a dibujar la l√≠nea deseada. <br><br>  A continuaci√≥n, DI = DI + BX, que es equivalente a aumentar la coordenada Y en uno.  Por lo tanto, en el cuerpo del ciclo, se dibujan dos puntos en una l√≠nea, la coordenada X aumenta en 2, y la coordenada Y en 1 y esta acci√≥n se repite 120 veces, la imagen con el resultado es ligeramente inferior. <br><br>  <b>La segunda l√≠nea es de arriba a la izquierda</b> : <br><br><pre> <code class="cpp hljs">pop di ;<span class="hljs-number"><span class="hljs-number">5f</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">96</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">60</span></span> LINE2: mov [bx+di], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> stosb ;aa add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb loop LINE2 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  Restauramos las coordenadas iniciales 64: 4 y configuramos el contador en 96 repeticiones.  Imprimimos un punto, pero una l√≠nea debajo de las coordenadas actuales.  Como antes, esto se logra agregando un valor de BX, solo sin guardar las nuevas coordenadas.  La construcci√≥n <code>[bx+di]</code> o <code>[bx][di]</code> se denomina direccionamiento base con indexaci√≥n y funciona a nivel de procesador, no el traductor.  El registro de segmento predeterminado con BX es DS.  Despu√©s de lo cual mostramos el segundo punto, pero ya en las coordenadas actuales.  DI y, por lo tanto, X aumenta en uno, ya que solo se <code>stosb</code> comando de transferencia de bytes: <code>stosb</code> .  Los dos √∫ltimos comandos del cuerpo del ciclo son un aumento de Y en 2, para lo cual nuevamente usamos BX. <br><br>  Despu√©s de dibujar dos l√≠neas, se obtiene la siguiente imagen cerca de la esquina superior izquierda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/nu/fk/xvnufkuhyvi0gwqomrquixlvti8.png" alt="l√≠nea 1,2"></div><br><br>  Coordenadas izquierda y superior, a la derecha de la direcci√≥n de desplazamiento de l√≠nea en la memoria de video.  El punto 64: 4 se dibujar√° dos veces. <br><br>  <b>La tercera l√≠nea es desde la esquina superior derecha hasta la superior</b> : <br><br><pre> <code class="cpp hljs">mov cl, <span class="hljs-number"><span class="hljs-number">97</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">61</span></span> LINE3: mov [bx+di], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> stosb ;aa sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb loop LINE3 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  DI ya contiene el valor de coordenadas deseado 160: 196, necesitamos dibujar una l√≠nea desde la parte superior donde termin√≥ la l√≠nea anterior, moviendo la pantalla hacia arriba manteniendo el mismo √°ngulo.  En consecuencia, el ciclo es casi id√©ntico.  CX se incrementa en 1, porque la coordenada Y actual es 2 m√°s (m√°s baja) que donde termin√≥ la l√≠nea anterior, ya se calcul√≥ para la siguiente iteraci√≥n.  Por lo tanto, para llegar a la esquina superior, debe dar un paso adicional.  El movimiento a lo largo de X contin√∫a en la misma direcci√≥n, m√°s uno despu√©s de cada iteraci√≥n, y a lo largo de Y, en lugar de sumar, restamos los dos.  Los puntos se muestran en el mismo orden, primero inferior y luego superior. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d8/bw/3f/d8bw3fucavqttjhld9wqrlqsi_s.png" alt="l√≠nea 3"></div><br><br>  <b>La cuarta l√≠nea es desde el extremo izquierdo hasta la esquina superior derecha:</b> <br><br><pre> <code class="cpp hljs">mov di, <span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">123</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bf d1 <span class="hljs-number"><span class="hljs-number">99</span></span> push di ;<span class="hljs-number"><span class="hljs-number">57</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">78</span></span> LINE4: stosw ;ab sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb(<span class="hljs-number"><span class="hljs-number">-5</span></span>) loop LINE4</code> </pre><br>  Estamos nuevamente en las coordenadas necesarias, pero esto no se usa, aparentemente para no cambiar la bandera de direcci√≥n del DF.  Por lo tanto, las nuevas coordenadas se colocan en la DI y se almacenan en la pila. <br><br>  Adem√°s, todo es id√©ntico a la primera l√≠nea, solo la coordenada Y no crece, pero disminuye, subimos. <br><br>  <b>La quinta l√≠nea es horizontal:</b> <br><br><pre> <code class="cpp hljs">pop di ;<span class="hljs-number"><span class="hljs-number">5f</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">143</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">8f</span></span> rep stosw ;f3 ab</code> </pre><br>  Aqu√≠ todo es simple, se utiliza el mecanismo de retransmisi√≥n por microprocesador, ya que la l√≠nea horizontal corresponde a un simple aumento en la direcci√≥n de cada punto siguiente.  En DI, se restaura la direcci√≥n correspondiente a la coordenada de la esquina extrema izquierda, almacenada en el paso anterior.  Se establece el n√∫mero de repeticiones en CX y el prefijo de repetici√≥n se aplica con el comando de transferencia de palabras. <br><br>  Despu√©s de esta acci√≥n, tenemos un pentagrama completamente dibujado en el color m√°s brillante.  80 bytes utilizados y 48 en reserva. <br><br><h3>  Magia de fuego </h3><br>  <b>Establecemos las condiciones de contorno para los c√°lculos:</b> <br><br><pre> <code class="cpp hljs">FLAME: cmp si, <span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span> ;<span class="hljs-number"><span class="hljs-number">81</span></span> fe <span class="hljs-number"><span class="hljs-number">00</span></span> fa jae NEXT_PIXEL ;<span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> lodsb ;ac <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al,al ;<span class="hljs-number"><span class="hljs-number">0</span></span>a c0 jz NEXT_PIXEL ;<span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>d</code> </pre><br>  En SI habr√° la coordenada del punto actual para los c√°lculos, si vamos m√°s all√° de los l√≠mites de la pantalla, entonces no realizamos ning√∫n c√°lculo con este punto, procedemos a calcular el siguiente. <br><br>  <code>lodsb</code> carga un byte desde el √°rea DS: SI en AL, es decir, el color del punto en las coordenadas actuales.  Si es 0, entonces tampoco hacemos nada y pasamos al siguiente punto. <br><br>  <b>Nuevo c√°lculo de color</b> <br><br>  Este es el algoritmo principal para cambiar los valores de color en la pantalla, esto no es una llama, esta es la base para ello.  Calculamos los puntos vecinos y logramos la continuidad del color: <br><br><pre> <code class="cpp hljs">dec ax ;<span class="hljs-number"><span class="hljs-number">48</span></span> mov [si<span class="hljs-number"><span class="hljs-number">-2</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">44</span></span> fe mov [si], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> mov [bx+si<span class="hljs-number"><span class="hljs-number">-1</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> ff mov [si<span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">84</span></span> bf fe</code> </pre><br>  Reste de AX, de hecho de AL, una unidad que contiene un valor de color distinto de cero obtenido de las coordenadas actuales.  A continuaci√≥n, anotamos el valor obtenido en todos los puntos vecinos, en relaci√≥n con la coordenada actual, es decir, un poco de ellos, seg√∫n nuestra paleta. <br><br>  Como despu√©s de <code>lodsb</code> , el valor SI aument√≥ en uno y ya no corresponde al punto cuyo color leemos en AL, esto tiene que ser ajustado.  Tenga en cuenta que los comandos de transferencia de bytes <code>stosb</code> ya no se usan; en su lugar, <code>mov</code> se usa para se√±alar la direcci√≥n donde se colocar√° el valor.  Si aceptamos que las coordenadas actuales son X: Y, para ellas SI-1, entonces: <br><br><ul><li>  <code>mov [si-2], al</code> - graba un nuevo color en el punto X-1: Y, a la izquierda del actual.  2 se resta de SI debido a la raz√≥n descrita anteriormente, ya que ya se le ha agregado una unidad adicional </li><li>  <code>mov [si], al</code> - graba un nuevo color en el punto X + 1: Y, a la derecha del actual.  SI ya tiene X + 1 </li><li>  <code>mov [bx+si-1], al</code> - escribiendo un nuevo color en el punto X: Y + 1, debajo del actual.  Nuevamente use BX para Y + 1 </li><li>  <code>mov [si-1-1*320], al</code> - escribiendo un nuevo color en el punto X: Y-1, arriba del actual.  No podremos usar BX, ya que necesitamos eliminar la coordenada, la arquitectura del procesador no nos permite hacerlo de esta forma, por lo tanto, se usa una constante de acuerdo con la f√≥rmula de reducci√≥n de coordenadas </li></ul><br>  El registro de segmento es DS, que se usa por defecto con SI y BX. <br><br>  En ninguna parte se verifica la situaci√≥n cuando el punto toca el borde de la pantalla.  Esto no puede conducir a una falla, ya que siempre estaremos dentro de los l√≠mites del segmento de video.  Un punto vecino puede caer en un √°rea no reportada con direcciones superiores a 64,000 o en una l√≠nea adyacente, lo que no nos hace da√±o e incluso ayuda un poco, como se ver√° en la descripci√≥n adicional. <br><br>  <b>La misma magia, el c√°lculo de las coordenadas del siguiente punto.</b> <br><br><pre> <code class="cpp hljs">NEXT_PIXEL: add si, dx ;<span class="hljs-number"><span class="hljs-number">03</span></span> f2 inc dx ;<span class="hljs-number"><span class="hljs-number">42</span></span> jnz FLAME ;<span class="hljs-number"><span class="hljs-number">75</span></span> e3(<span class="hljs-number"><span class="hljs-number">-29</span></span>)</code> </pre><br>  Volvamos un poco, no establecimos espec√≠ficamente el valor inicial de SI en ning√∫n lado, y en DX todav√≠a tenemos el n√∫mero del puerto de entrada de salida que usamos para la paleta.  Realizamos solo tres acciones simples SI = SI + DX, obviamente esto establecer√° nuevas coordenadas, ¬øcu√°les?  DX = DX + 1 y si DX no es igual a 0, entonces volviendo al algoritmo b√°sico para obtener y calcular puntos vecinos, es decir, ¬øDX es alg√∫n tipo de contador? <br><br>  Sabemos que debemos recorrer todos los puntos y calcular los cambios de brillo de sus vecinos.  Si hace esto en una fila, probablemente obtendremos un gradiente est√°tico, tal vez no del todo uniforme, pero sin cambios alrededor de nuestras l√≠neas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conocemos el tama√±o de nuestra pantalla y cu√°ntos puntos debemos sortear, pero aqu√≠ casi lo descuidamos, m√°s precisamente, elegimos el valor de cierre 65536 en lugar del 64000 exacto. DX es realmente un contador, solo 65536. Pero por qu√© su valor inicial no es importante y por qu√© tomamos ¬øEs el valor final mayor que el total de puntos en la pantalla? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Porque vamos por puntos no seguidos y no todos. Cada coordenada lineal posterior es mayor que la anterior por el valor de DX. Es decir, en SI la suma de los elementos DX de una progresi√≥n aritm√©tica simple: 0,1,2,3,4,5,6, ..., 362,363, ..., 65535. Esto ya nos da no linealidad, si comienzas con SI = 0 y DX = 0, entonces en SI obtenemos: 0,1,3,4,6,10,15,21, ..., 65341,65703, ..., 2147450880.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero eso no es todo, ya que la dimensi√≥n SI es de 16 bits, no podemos obtener un valor mayor que 65535, se produce un desbordamiento y el resto en SI sigue siendo el m√≥dulo 65536. La f√≥rmula de c√°lculo de coordenadas lineales toma la forma SI = (SI + DX) MOD 65536, que rompe completamente el orden continuo: 0,1,3,4,6,10,15,21, ..., 65341,167,530,894, ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora recordamos que SI no se inicializa de ninguna manera, es decir, la pr√≥xima vez que volvamos a este ciclo entonces comenzaremos desde la coordenada donde la dejamos, y no desde 0 o alguna dada. Esto agregar√° caos a nuestra secuencia: alargue la cantidad de elementos que no se repiten. De lo contrario, el recorrido de los puntos siempre ser√≠a el mismo, aunque no lineal. Un efecto de llama estar√≠a presente, pero no tan claramente. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si hablamos del truco, entonces esto es todo.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DX, siempre, excepto el primer uso, comienza impl√≠citamente en 0 como resultado de un desbordamiento </font></font><code>inc dx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y nuestros valores l√≠mite agregan un poco m√°s de caos, ya que para SI&gt; = 64000 no se dibujar√°n puntos y la secuencia de salida est√° ligeramente confundida. Y omitir todos los puntos con un valor cero conduce al efecto de ignici√≥n en los primeros segundos del programa. Esto se debe a que el ciclo completo termina m√°s r√°pido, ya que la mayor√≠a de los puntos no se procesan. Pero lo m√°s importante, debido a que el brillo para la mayor√≠a de los puntos solo aumentar√°, no pueden ser oscurecidos por las secciones de atenuaci√≥n vecinas: simplemente no existen todav√≠a y no se calculan valores cero. Despu√©s de que desaparezcan las √°reas completamente negras, se establece el equilibrio, algunas √°reas aumentar√°n el brillo y otras disminuir√°n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, ya no podemos hablar de ning√∫n orden o gradiente, los puntos no se distribuyen, cada vez en una nueva secuencia, incluida la repetici√≥n de varias veces o saltar por completo. </font><font style="vertical-align: inherit;">Esto conduce a la formaci√≥n de regiones de diferente brillo mezcladas entre s√≠, que cambian en cada nueva iteraci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero esto no es todo, si no agrega nuevos puntos brillantes, al final todos ser√°n reembolsados. </font><font style="vertical-align: inherit;">Por lo tanto, despu√©s de que el DX alcanza su valor m√°ximo, volvemos a dibujar cinco l√≠neas brillantes una y otra vez contando todos los puntos en la pantalla:</font></font><br><br><pre> <code class="cpp hljs">in al, <span class="hljs-number"><span class="hljs-number">60</span></span>h ;e4 <span class="hljs-number"><span class="hljs-number">60</span></span> cmp al, <span class="hljs-number"><span class="hljs-number">01</span></span>h ;<span class="hljs-number"><span class="hljs-number">3</span></span>c <span class="hljs-number"><span class="hljs-number">01</span></span> jne LINES ;<span class="hljs-number"><span class="hljs-number">75</span></span> a5(<span class="hljs-number"><span class="hljs-number">-91</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero antes de eso, leemos desde el puerto 60h, este es el teclado, el c√≥digo de escaneo de la √∫ltima tecla presionada. </font><font style="vertical-align: inherit;">Para ESC es igual a 1. Si es as√≠, se presion√≥ la tecla ESC, nos movemos hacia la salida.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finalizaci√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale la pena prestar atenci√≥n al actualizar la pantalla actual, que lleva un tiempo, no puede salir del programa, es decir, la reacci√≥n al ESC se retrasar√°. Si durante la espera y despu√©s de ESC se presiona alguna tecla, seguiremos en el programa, solo se puede leer el √∫ltimo c√≥digo de escaneo desde el puerto. Una cosa m√°s, no reemplazamos ni usamos las funciones del sistema DOS y BIOS para esto, independientemente de lo que leamos del puerto, la tecla presionada se coloca en un b√∫fer circular y probablemente el siguiente programa la leer√° desde all√≠ una vez que se complete nuestra introducci√≥n, el archivo m√°s probable gerente o </font></font><code>command.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esto conducir√° a su procesamiento, por ejemplo, Volkov Commander en ESC ocultar√° sus paneles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queda por volver al modo de texto 3:</font></font><br><br><pre> <code class="cpp hljs">mov ax, <span class="hljs-number"><span class="hljs-number">03</span></span>h ;b8 <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h ;cd <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se supone que est√°bamos en este modo antes del lanzamiento del programa, pero en el caso general este puede no ser el caso. </font><font style="vertical-align: inherit;">Aqu√≠ actualizamos todo el AX, porque sabemos con certeza que AH no contiene 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora puede salir:</font></font><br><br><pre> <code class="cpp hljs">retn ;c3</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un comando cercano a la salida de un procedimiento que toma el valor de la palabra colocada all√≠ (dos bytes) de la pila y lo carga en el contador de comandos IP. </font><font style="vertical-align: inherit;">Seg√∫n las condiciones iniciales, tenemos ceros en la pila, esto nos llevar√° a la direcci√≥n CS: 0, donde, como sabemos, se encuentra el c√≥digo de comando </font></font><code>int 20h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: apagado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y 7 bytes para derechos de autor:</font></font><br><br><pre> <code class="cpp hljs">dd <span class="hljs-number"><span class="hljs-number">0</span></span>h ;<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> db <span class="hljs-string"><span class="hljs-string">'Mcm'</span></span> ;<span class="hljs-number"><span class="hljs-number">4</span></span>d <span class="hljs-number"><span class="hljs-number">63</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>d end</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos decir que todav√≠a hay un lugar que gastar√≠a en una inicializaci√≥n m√°s rigurosa, pero como todo funciona en DOSBox moderno, el autor probablemente hizo todo bien. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos una vez m√°s:</font></font><br><br><ol><li>    ,        </li><li>  4    ,           :  X+1  Y+2,  X+2  Y+1.         ,       .    ,          </li><li>       SI=(SI+DX) MOD 65536,     DX ,     ,      ,     SI.         1.   65536 ,    ,     .     ,         ‚Äî <code>add si, dx</code>  <code>inc dx</code> ,            ,       </li><li>     ESC  ,           </li></ol><br><div class="spoiler"> <b class="spoiler_title">  .</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">.186</span></span> .model tiny .code .startup mov al, <span class="hljs-number"><span class="hljs-number">13</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h push <span class="hljs-number"><span class="hljs-number">0</span></span>a000h pop es push es pop ds lodsb mov dx, <span class="hljs-number"><span class="hljs-number">03</span></span>c8h out dx, al inc dx mov cl, <span class="hljs-number"><span class="hljs-number">040</span></span>h PALETTE: out dx, al inc ax outsb outsb loop PALETTE LINES: mov ax, <span class="hljs-number"><span class="hljs-number">03f</span></span>3fh mov bx, <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> mov di, <span class="hljs-number"><span class="hljs-number">64</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> push di mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> LINE1: stosw add di, bx loop LINE1 pop di mov cl, <span class="hljs-number"><span class="hljs-number">96</span></span> LINE2: mov [bx+di], al stosb add di, bx add di, bx loop LINE2 mov cl, <span class="hljs-number"><span class="hljs-number">97</span></span> LINE3: mov [bx+di], al stosb sub di, bx sub di, bx loop LINE3 mov di, <span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">123</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> push di mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> LINE4: stosw sub di, bx loop LINE4 pop di mov cl, <span class="hljs-number"><span class="hljs-number">143</span></span> rep stosw FLAME: cmp si, <span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span> jae NEXT_PIXEL lodsb <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al,al jz NEXT_PIXEL dec ax mov [si<span class="hljs-number"><span class="hljs-number">-2</span></span>], al mov [si], al mov [bx+si<span class="hljs-number"><span class="hljs-number">-1</span></span>], al mov [si<span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span>], al NEXT_PIXEL: add si, dx inc dx jnz FLAME in al, <span class="hljs-number"><span class="hljs-number">60</span></span>h cmp al, <span class="hljs-number"><span class="hljs-number">01</span></span>h jne LINES mov ax, <span class="hljs-number"><span class="hljs-number">03</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h retn dd <span class="hljs-number"><span class="hljs-number">0</span></span>h db <span class="hljs-string"><span class="hljs-string">'Mcm'</span></span> end</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para compilar, debe hacer: </font></font><code>tasm pentagra.asm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>tlink /t pentagra.obj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No s√© si qued√≥ claro qu√© y c√≥mo se implement√≥, pero me parece que se utiliz√≥ un enfoque hermoso e inusual para crear el efecto de llama. </font><font style="vertical-align: inherit;">Aunque no tengo nada con lo que comparar, tal vez todos lo hicieron, y ahora t√∫ puedes hacer lo mismo.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482826/">https://habr.com/ru/post/482826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482812/index.html">Los matem√°ticos han logrado un gran avance en el estudio del problema "peligroso"</a></li>
<li><a href="../482814/index.html">Vista general del √°rbol, implementaci√≥n y no solo</a></li>
<li><a href="../482816/index.html">Arthur Khachuyan: Inteligencia artificial en marketing</a></li>
<li><a href="../482820/index.html">Optimizaci√≥n de carga de imagen</a></li>
<li><a href="../482822/index.html">¬øC√≥mo se realizan las pruebas de arte para juegos?</a></li>
<li><a href="../482834/index.html">La escritura est√°tica no necesariamente requiere ceremonias</a></li>
<li><a href="../482838/index.html">Revisi√≥n de ONYX BOOX Note 2: un lector de pantalla grande con capacidades m√°ximas</a></li>
<li><a href="../482840/index.html">Descarga secuencial de UTorrent en 2 clics</a></li>
<li><a href="../482842/index.html">Mash es un lenguaje de programaci√≥n que se compila</a></li>
<li><a href="../482844/index.html">Live bot, parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>