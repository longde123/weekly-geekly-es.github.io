<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòñ üåà üöê Qt-asynchrone asynchrone Widget-Bibliothek üë©üèª‚Äçü§ù‚Äçüë®üèº ‚ÑπÔ∏è üßî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag an alle. Ich m√∂chte ein wenig √ºber mein qt-async- Projekt sprechen, vielleicht erscheint es jemandem interessant oder sogar n√ºtzlich. 

 Asy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt-asynchrone asynchrone Widget-Bibliothek</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451722/"> Guten Tag an alle.  Ich m√∂chte ein wenig √ºber mein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qt-async-</a> Projekt sprechen, vielleicht erscheint es jemandem interessant oder sogar n√ºtzlich. <br><br>  Asynchronit√§t und Multithreading geh√∂ren seit langem ernsthaft zum Alltag der Entwickler.  Viele moderne Sprachen und Bibliotheken sind f√ºr die asynchrone Verwendung konzipiert.  Die C ++ - Sprache bewegt sich ebenfalls langsam in diese Richtung - std :: thread, std :: Versprechen / Zukunft sind erschienen, sie sind dabei, Coroutinen und Networking einzuf√ºhren.  Die Qt-Bibliothek bleibt auch nicht zur√ºck und bietet ihre Analoga QThread, QRunnable, QThreadPool, QFuture usw. an.  Gleichzeitig habe ich in Qt keine Widgets zum Anzeigen asynchroner Aktionen gefunden (vielleicht habe ich schlecht ausgesehen, richtig, wenn ich mich irre). <br><br>  Deshalb habe ich mich entschlossen, das Manko auszugleichen und zu versuchen, ein solches Widget selbst zu implementieren.  Multithread-Entwicklung ist ein komplexes, aber interessantes Gesch√§ft. <br><a name="habracut"></a><br>  Bevor Sie mit der Implementierung des Widgets fortfahren, m√ºssen Sie das Modell, das dem Benutzer angezeigt wird, in Form eines Fensters beschreiben.  In seiner allgemeinsten Form scheint mir die Operation des Widgets wie folgt zu sein: Irgendwann startet der Benutzer oder das System eine asynchrone Operation.  Zu diesem Zeitpunkt zeigt das Widget den Fortschritt des Vorgangs oder lediglich eine Anzeige des Vorgangs an.  Optional kann der Benutzer den Vorgang abbrechen.  Dar√ºber hinaus wird die asynchrone Operation auf zwei Arten abgeschlossen: Entweder ist ein Fehler aufgetreten und unser Widget zeigt ihn an, oder das Widget zeigt das Ergebnis der erfolgreichen Operation an. <br><br>  Somit kann sich unser Modell in einem von drei Zust√§nden befinden: <br><br><ol><li>  Fortschritt - Eine asynchrone Operation wird ausgef√ºhrt </li><li>  Fehler - asynchroner Vorgang fehlgeschlagen </li><li>  Wert - Asynchrone Operation erfolgreich abgeschlossen </li></ol><br>  In jedem der Zust√§nde muss das Modell die entsprechenden Daten speichern, daher habe ich das AsyncValue-Modell aufgerufen.  Es ist wichtig zu beachten, dass die asynchrone Operation selbst nicht Teil unseres Modells ist, sondern nur ihren Status wechselt.  Es stellt sich heraus, dass AsyncValue mit jeder asynchronen Bibliothek verwendet werden kann, wobei ein einfaches Verwendungsmuster zu beachten ist: <br><br><ol><li>  Setzen Sie zu Beginn des asynchronen Vorgangs AsuncValue auf Progress </li><li>  Am Ende - entweder in Fehler oder in Wert, abh√§ngig vom Erfolg der Operation </li><li>  Optional k√∂nnen Sie w√§hrend des Vorgangs die Fortschrittsdaten aktualisieren und das Stopp-Flag abh√∂ren, wenn der Benutzer die M√∂glichkeit hat, den Vorgang zu stoppen. </li></ol><br>  Hier ist ein schematisches Beispiel mit QRunnable: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyRunnable</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QRunnable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MyRunnable(AsyncValue&amp; value) : m_value(value) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> final </span></span>{ m_value.setProgress(...); <span class="hljs-comment"><span class="hljs-comment">// do calculation if (success) m_value.setValue(...); else m_value.setError(...); } private: AsyncValue&amp; m_value; }</span></span></code> </pre> <br>  Das gleiche Schema f√ºr die Arbeit mit std :: thread: <br><br><pre> <code class="cpp hljs">AsyncValue value; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([&amp;value] () { value.setProgress(...); </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">// do calculation if (success) value.setValue(...); else value.setError(...); });</span></span></span></span></span></span></code> </pre><br>  So k√∂nnte die erste Version unserer Klasse ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ErrorType_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ProgressType_t&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncValue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ValueType = ValueType_t; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ErrorType = ErrorType_t; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ProgressType = ProgressType_t; <span class="hljs-comment"><span class="hljs-comment">// public API private: QReadWriteLock m_lock; std::variant&lt;ValueType, ErrorType, ProgressType&gt; m_value; };</span></span></code> </pre><br>  Jeder, der auf Klassen st√∂√üt, die Multithreading unterst√ºtzen, wei√ü, dass sich die Schnittstelle solcher Klassen von Single-Threaded-Analoga unterscheidet.  Beispielsweise ist die Funktion size () in einem Multithread-Vektor nutzlos und gef√§hrlich.  Das Ergebnis kann sofort ung√ºltig werden, da der Vektor momentan in einem anderen Thread ge√§ndert werden kann. <br><br>  Benutzer der AsyncValue-Klasse sollten auf Klassendaten zugreifen k√∂nnen.  Das Ausstellen einer Kopie der Daten kann teuer sein. Jeder der Typen ValueType / ErrorType / ProgressType kann schwer sein.  Das Herstellen eines Links zu internen Daten ist gef√§hrlich - es kann jederzeit ung√ºltig werden.  Die folgende L√∂sung wird vorgeschlagen: <br><br>  1. Geben Sie √ºber die Funktionen accessValue / accessError / accessProgress Zugriff auf Daten, in die Lambdas empfangen werden, die die entsprechenden Daten empfangen.  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Pred&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accessValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pred valuePred)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">QReadLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">locker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;m_lock)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_value.index() != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; valuePred(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(m_value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Der Zugriff auf den internen Wert erfolgt somit als Referenz und ist zum Lesen unter Verschluss.  Das hei√üt, der Link zum Zeitpunkt des Zugriffs wird nicht ung√ºltig. <br><br>  2. AsyncValue-Benutzer in der accessValue-Funktion k√∂nnen sich den Link zu internen Daten merken, vorausgesetzt, er hat das stateChanged-Signal abonniert und darf diesen Link nach der Verarbeitung des Signals nicht mehr verwenden, weil  sie wird ung√ºltig. <br><br>  Unter solchen Bedingungen ist dem AsyncValue-Verbraucher immer ein g√ºltiger und bequemer Datenzugriff garantiert.  Diese L√∂sung hat mehrere Konsequenzen, die sich auf die Implementierung der AsyncValue-Klasse auswirken. <br><br>  Zuerst sollte unsere Klasse ein Signal senden, wenn sich ein Zustand √§ndert, aber gleichzeitig ist es eine Vorlage.  Wir m√ºssen eine grundlegende Qt-Klasse hinzuf√ºgen, in der wir das Signal bestimmen k√∂nnen, mit dem das Widget seinen Inhalt aktualisiert, und alle Interessenten Links zu internen Daten aktualisieren. <br><br><pre> <code class="cpp hljs">lass AsyncValueBase : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { <span class="hljs-function"><span class="hljs-function">Q_OBJECT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Q_DISABLE_COPY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AsyncValueBase)</span></span></span><span class="hljs-function"> signals: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stateChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre><br>  Zweitens sollte der Moment des Sendens des Signals zum Lesen blockiert werden (so dass AsyncValue nicht ge√§ndert werden kann, bis alle das Signal verarbeitet haben), und <i>vor allem</i> sollte zu diesem Zeitpunkt g√ºltige Links zu neuen und alten Daten vorhanden sein.  Denn beim Senden des Signals verwenden einige AsyncValue-Konsumenten immer noch die alten Links, und diejenigen, die das Signal verarbeitet haben, verwenden die neuen. <br><br>  Es stellt sich heraus, dass std :: variante f√ºr uns nicht geeignet ist und wir Daten im dynamischen Speicher speichern m√ºssen, damit die Adressen neuer und alter Daten unver√§ndert bleiben. <br><br>  Ein kleiner Exkurs. <br><br>  Sie k√∂nnen andere Implementierungen der AsyncValue-Klasse in Betracht ziehen, f√ºr die keine dynamischen Zuordnungen erforderlich sind: <br><br><ol><li>  Geben Sie den Verbrauchern nur Kopien der internen Daten von AsyncValue.  Wie ich bereits geschrieben habe, ist eine solche L√∂sung m√∂glicherweise suboptimaler, wenn die Daten gro√ü sind. </li><li>  Definieren Sie zwei Signale anstelle von einem: stateWillChange / stateDidChange.  Verbraucher zu verpflichten, alte Verbindungen beim ersten Signal loszuwerden und beim zweiten Signal neue Verbindungen zu erhalten.  Dieses Schema erschwert meines Erachtens die Verbraucher von AsyncValue √ºberm√§√üig, weil  Sie haben Zeitintervalle, in denen der Zugriff auf AsyncValue verweigert wird. </li></ol><br>  Die folgende schematische Implementierung der setValue-Funktion wird erhalten: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AsyncValue::setValue(...) {  m_lock            {   m_lock          m_lock   }  stateChanged       m_lock   };</code> </pre><br>  Wie Sie sehen k√∂nnen, m√ºssen wir die Sperre m_lock zum Schreiben erh√∂hen und zum Lesen zur√ºckgeben.  Leider gibt es in der QReadWriteLock-Klasse keine solche Unterst√ºtzung.  Sie k√∂nnen die gew√ºnschte Funktionalit√§t mit einem Paar QMutex / QReadWriteLock erreichen.  Hier ist eine Implementierung der AsyncValue-Klasse, die nahezu real ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   AsyncValue enum class ASYNC_VALUE_STATE { VALUE, ERROR, PROGRESS }; Q_DECLARE_METATYPE(ASYNC_VALUE_STATE); //        class AsyncValueBase : public QObject { Q_OBJECT Q_DISABLE_COPY(AsyncValueBase) signals: void stateChanged(ASYNC_VALUE_STATE state); protected: explicit AsyncValueBase(ASYNC_VALUE_STATE state, QObject* parent = nullptr); //     PromoteToWriteLock/DemoteToReadLock QMutex m_writeLock; QReadWriteLock m_contentLock; //   ASYNC_VALUE_STATE m_state; }; template &lt;typename ValueType_t, typename ErrorType_t, typename ProgressType_t&gt; class AsyncValueTemplate : public AsyncValueBase { //  struct Content { std::unique_ptr&lt;ValueType_t&gt; value; std::unique_ptr&lt;ErrorType_t&gt; error; std::unique_ptr&lt;ProgressType+t&gt; progress; }; Content m_content; public: using ValueType = ValueType_t; using ErrorType = ErrorType_t; using ProgressType = ProgressType_t; //    template &lt;typename... Args&gt; void emplaceValue(Args&amp;&amp; ...arguments) { moveValue(std::make_unique&lt;ValueType&gt;(std::forward&lt;Args&gt;(arguments)...)); } //    void moveValue(std::unique_ptr&lt;ValueType&gt; value) { //       Content oldContent; //   emplaceXXX/moveXXX    QMutexLocker writeLocker(&amp;m_writeLock); { //       QWriteLocker locker(&amp;m_contentLock); //      oldContent = std::move(m_content); //    m_content.value = std::move(value); //    m_state = ASYNC_VALUE_STATE::VALUE; //     } //   emitStateChanged(); //    emplaceXXX/moveXXX  //    } //   value void emplaceError(Args&amp;&amp; ...arguments); void moveError(std::unique_ptr&lt;ErrorType&gt; error); void emplaceProgress(Args&amp;&amp; ...arguments); void moveProgress(std::unique_ptr&lt;ProgressType&gt; progress); template &lt;typename Pred&gt; bool accessValue(Pred valuePred) { //     QReadLocker locker(&amp;m_contentLock); //    if (m_state != ASYNC_VALUE_STATE::VALUE) return false; //      valuePred(*m_content.value); //     return true; } //  accessValue bool accessError(Pred errorPred) bool accessProgress(Pred progressPred) };</span></span></code> </pre><br>  F√ºr diejenigen, die nicht m√ºde und nicht verloren sind, fahren wir fort. <br><br>  Wie Sie sehen k√∂nnen, haben wir accessXXX-Funktionen, die nicht warten, bis AsyncValue in den entsprechenden Status wechselt, sondern einfach false zur√ºckgeben.  Manchmal ist es hilfreich, synchron zu warten, bis in AsyncValue entweder ein Wert oder ein Fehler angezeigt wird.  Im Wesentlichen ben√∂tigen wir ein Analogon von std :: future :: get.  Hier ist die Funktionssignatur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValuePred, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ErrorPred&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValuePred valuePred, ErrorPred errorPred)</span></span></span></span>;</code> </pre><br>  Damit diese Funktion funktioniert, ben√∂tigen wir eine Bedingungsvariable - ein Synchronisationsobjekt, das in einem Thread erwartet und in einem anderen aktiviert werden kann.  In der Wartefunktion sollten wir warten, und wenn wir den Status von AsyncValue von Fortschritt auf Wert oder Fehler √§ndern, sollten wir die Kellner benachrichtigen. <br><br>  Das Hinzuf√ºgen eines weiteren Felds zur AsyncValue-Klasse, das in seltenen F√§llen erforderlich ist, wenn die Wartefunktion verwendet wird, hat mich zu der √úberlegung veranlasst: Kann dieses Feld optional gemacht werden?  Die Antwort liegt auf der Hand. Nat√ºrlich ist es m√∂glich, wenn Sie std :: unique_ptr speichern und bei Bedarf erstellen.  Die zweite Frage stellte sich: Ist es m√∂glich, dieses Feld optional zu machen und keine dynamischen Zuordnungen vorzunehmen?  Wen k√ºmmert es, bitte schauen Sie sich den folgenden Code an.  Die Hauptidee lautet wie folgt: Der erste Warteaufruf erstellt eine QWaitCondition-Struktur auf dem Stapel und schreibt seinen Zeiger auf AsyncValue. Nachfolgende Warteaufrufe pr√ºfen einfach, ob der Zeiger nicht leer ist. Verwenden Sie die Struktur dieses Zeigers. Wenn der Zeiger leer ist, siehe oben f√ºr den ersten Warteaufruf . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncValueBase</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Waiter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//     QWaitCondition waitValue; //   wait quint16 subWaiters = 0; //  wait     QWaitCondition waitSubWaiters; }; //    Waiter* m_waiter = nullptr; }; template &lt;typename ValuePred, typename ErrorPred&gt; void wait(ValuePred valuePred, ErrorPred errorPred) { //   -      if (access(valuePred, errorPred)) return; //  AsyncValue   QMutexLocker writeLocker(&amp;m_writeLock); //     if (access(valuePred, errorPred)) return; //    wait  if (!m_waiter) { //  Waiter   Waiter theWaiter; //       if SCOPE_EXIT { //     wait, //    theWaiter if (m_waiter-&gt;subWaiters &gt; 0) { //    subWaiters   do { m_waiter-&gt;waitSubWaiters.wait(&amp;m_writeLock); } while (m_waiter-&gt;subWaiters != 0); } //   wait  , //       Waiter m_waiter = nullptr; }; //    Waiter  AsyncValue //    wait   m_waiter = &amp;theWaiter; //   AsyncValue     Value  Error //    do { m_waiter-&gt;waitValue.wait(&amp;m_writeLock); } while (!access(valuePred, errorPred)); } //   wait   else { //       else SCOPE_EXIT { //      m_waiter-&gt;subWaiters -= 1; //     -&gt;   wait if (m_waiter-&gt;subWaiters == 0) m_waiter-&gt;waitSubWaiters.wakeAll(); }; //      m_waiter-&gt;subWaiters += 1; //   AsyncValue     Value  Error //    do { m_waiter-&gt;waitValue.wait(&amp;m_writeLock); } while (!access(valuePred, errorPred)); } }</span></span></code> </pre><br>  Wie bereits erw√§hnt, verf√ºgt AsyncValue nicht √ºber eine Methode f√ºr asynchrones Rechnen, um nicht an eine bestimmte Bibliothek gebunden zu sein.  Stattdessen werden freie Funktionen verwendet, die auf die eine oder andere Weise Asynchronit√§t implementieren.  Das folgende Beispiel zeigt die Berechnung von AsyncValue in einem Thread-Pool: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AsyncValueType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... ProgressArgs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncValueRunThreadPool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QThreadPool *pool, AsyncValueType&amp; value, Func&amp;&amp; func, ProgressArgs&amp;&amp; ...progressArgs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    auto progress = std::make_unique&lt;typename AsyncValueType::ProgressType&gt;(std::forward&lt;ProgressArgs&gt;(progressArgs)...); //    auto progressPtr = progress.get(); //    AsyncValue if (!value.startProgress(std::move(progress))) return false; QtConcurrent::run(pool, [&amp;value, progressPtr, func = std::forward&lt;Func&gt;(func)](){ SCOPE_EXIT { //     AsyncValue,    value.completeProgress(progressPtr); }; //  AsyncValue func(*progressPtr, value); }); return true; }</span></span></code> </pre><br>  Die Bibliothek implementiert zwei weitere √§hnliche Funktionen: asyncValueRunNetwork zum Verarbeiten von Netzwerkanforderungen und asyncValueRunThread, das eine Operation f√ºr einen neu erstellten Thread ausf√ºhrt.  Bibliotheksbenutzer k√∂nnen auf einfache Weise ihre eigenen Funktionen erstellen und dort die asynchronen Tools verwenden, die sie an anderen Orten verwenden. <br><br>  Um die Sicherheit zu erh√∂hen, wurde die AsyncValue-Klasse um eine weitere AsyncTrackErrorsPolicy-Vorlagenklasse erweitert, mit der Sie auf den Missbrauch von AsyncValue reagieren k√∂nnen.  Hier ist beispielsweise die Standardimplementierung der Funktion AsyncTrackErrorsPolicy :: inProgressWhileDestruct, die aufgerufen wird, wenn AsyncValue w√§hrend der Ausf√ºhrung des asynchronen Vorgangs zerst√∂rt wird: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inProgressWhileDestruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Q_ASSERT(<span class="hljs-literal"><span class="hljs-literal">false</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Destructing value while it's in progress"</span></span>); }</code> </pre><br>  Die Implementierung von Widgets ist recht einfach und pr√§zise.  AsyncWidget ist ein Container, der ein Widget enth√§lt, um einen Fehler oder Fortschritt oder einen Wert anzuzeigen, je nachdem, in welchem ‚Äã‚ÄãStatus sich AsyncValue derzeit befindet. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createValueWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValueType&amp; value, QWidget* parent)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createErrorWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ErrorType&amp; error, QWidget* parent)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgressWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProgressType&amp; progress, QWidget* parent)</span></span></span></span>;</code> </pre><br>  Der Benutzer ist verpflichtet, nur die erste Funktion neu zu definieren, um den Wert anzuzeigen, die anderen beiden haben Standardimplementierungen. <br><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qt-async-</a> Bibliothek erwies sich als kompakt, aber gleichzeitig sehr n√ºtzlich.  Durch die Verwendung von AsyncValue / AsyncWidget, wo zuvor synchrone Funktionen und eine statische Benutzeroberfl√§che vorhanden waren, k√∂nnen Ihre Anwendungen moderner und reaktionsschneller werden. <br><br>  F√ºr diejenigen, die den Bonus bis zum Ende gelesen haben - ein Video der Demo-Anwendung <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/aTXOpmVRXq0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451722/">https://habr.com/ru/post/de451722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451708/index.html">So bereiten Sie sich auf die √úberpr√ºfung personenbezogener Daten von ILV vor: eine vollst√§ndige Anleitung</a></li>
<li><a href="../de451710/index.html">Internet f√ºr den Sommerbewohner. Wir erreichen die maximale Geschwindigkeit in 4G-Netzen. Teil 2. Auswahl einer externen Antenne</a></li>
<li><a href="../de451716/index.html">Verbesserung der Softwareleistung mit Intel-Tools f√ºr Entwickler. Numerische Modellierung astrophysikalischer Objekte</a></li>
<li><a href="../de451718/index.html">Sprachassistenten erstellen</a></li>
<li><a href="../de451720/index.html">FIAS wird durch improvisierte (SQLXMLBULKLOAD) Mittel in die Datenbank von MSSQLSERVER geladen. Wie es (wahrscheinlich) nicht gemacht werden muss</a></li>
<li><a href="../de451724/index.html">Skyrmion zu Skyrmion Zwietracht: dreidimensionale polare Skyrmionen in Ferroelastik</a></li>
<li><a href="../de451726/index.html">Arbeitssuche im Ausland: 7 einfache Tipps f√ºr IT-Profis</a></li>
<li><a href="../de451728/index.html">RESTinio ist ein asynchroner HTTP-Server. Asynchron</a></li>
<li><a href="../de451738/index.html">Kurzer R√ºckblick auf den Artikel "DeViSE: Ein tiefes visuell-semantisches Einbettungsmodell"</a></li>
<li><a href="../de451742/index.html">Einen Tag vor DotNext 2019 Piter. Kostenlose Broadcast-Ank√ºndigung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>