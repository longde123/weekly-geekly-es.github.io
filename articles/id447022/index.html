<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèø ‚òπÔ∏è üòü Jangan memaksa pendengar untuk berpikir üí≠ ü¶å üè¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 



 Selama proses pengembangan, sering kali perlu membuat instance kelas yang namanya disimpan dalam file konfigurasi XML, atau untuk mem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jangan memaksa pendengar untuk berpikir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/447022/"><h2 id="vvedenie">  Pendahuluan </h2><br><p><img src="https://habrastorage.org/webt/c0/6s/s8/c06ss8od1zjumrcisda44pa5j0q.png"><br>  Selama proses pengembangan, sering kali perlu membuat instance kelas yang namanya disimpan dalam file konfigurasi XML, atau untuk memanggil metode yang namanya ditulis sebagai string sebagai nilai atribut anotasi.  Dalam kasus seperti itu, jawabannya adalah satu: "Gunakan refleksi!". </p><br><p>  Dalam versi baru dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CUBA Platform,</a> salah satu tugas untuk meningkatkan kerangka kerja adalah untuk menyingkirkan penciptaan pengendali acara secara eksplisit di kelas pengontrol layar UI.  Dalam versi sebelumnya, deklarasi handler dalam metode inisialisasi controller sangat berantakan dengan kode, jadi pada versi ketujuh kami memutuskan untuk membersihkan semuanya. </p><a name="habracut"></a><br><p> Seorang pendengar peristiwa hanyalah referensi ke metode yang perlu dipanggil pada waktu yang tepat (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">templat Observer</a> ).  Template seperti itu cukup sederhana untuk diimplementasikan menggunakan kelas <code>java.lang.reflect.Method</code> .  Pada startup, Anda hanya perlu memindai kelas, mengeluarkan metode yang dijelaskan dari mereka, menyimpan referensi ke mereka, dan menggunakan tautan untuk memanggil metode (atau metode) ketika peristiwa terjadi, seperti yang dilakukan dalam sebagian besar kerangka kerja.  Satu-satunya hal yang menghentikan kami adalah bahwa banyak acara secara tradisional dihasilkan di UI, dan saat menggunakan API refleksi, Anda harus membayar sejumlah harga dalam bentuk waktu pemanggilan metode.  Karena itu, kami memutuskan untuk melihat bagaimana lagi Anda bisa membuat penangan acara tanpa menggunakan refleksi. </p><br><p>  Kami sudah menerbitkan materi tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MethodHandles</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LambdaMetafactory di habr</a> , dan materi ini adalah semacam kelanjutan.  Kami akan memeriksa pro dan kontra dari menggunakan API refleksi, serta alternatif - menghasilkan kode dengan kompilasi AOT dan LambdaMetafactory, dan bagaimana itu digunakan dalam kerangka kerja CUBA. </p><br><h2 id="reflection-staryy-dobryy-nadezhnyy">  Refleksi: Lama.  Bagus  Andal </h2><br><p>  <em>Dalam ilmu komputer, refleksi atau refleksi (holonim dari introspeksi, refleksi bahasa Inggris) berarti suatu proses di mana program dapat melacak dan memodifikasi struktur dan perilaku sendiri saat runtime.</em>  (c) Wikipedia. </p><br><p>  Bagi kebanyakan pengembang Java, refleksi bukanlah hal yang baru.  Tampak bagi saya bahwa tanpa mekanisme ini, Java tidak akan menjadi Java, yang sekarang menempati pangsa pasar yang besar dalam pengembangan perangkat lunak aplikasi.  Bayangkan saja: proksi, metode yang mengikat ke acara melalui anotasi, injeksi ketergantungan, aspek, dan bahkan instantiating driver JDBC di versi pertama JDK!  Refleksi di mana-mana, adalah landasan dari semua kerangka kerja modern. </p><br><p>  Apakah ada masalah dengan Refleksi sebagaimana diterapkan pada tugas kita?  Kami telah mengidentifikasi tiga: </p><br><p>  <em>Kecepatan</em> - panggilan metode melalui API Refleksi lebih lambat daripada panggilan langsung.  Di setiap versi baru JVM, pengembang terus-menerus mempercepat panggilan melalui refleksi, kompiler JIT mencoba untuk lebih mengoptimalkan kode, tetapi bagaimanapun, perbedaan dibandingkan dengan pemanggilan metode langsung terlihat. </p><br><p>  <em>Mengetik</em> - jika Anda menggunakan <code>java.lang.reflect.Method</code> dalam kode, maka ini hanya referensi ke beberapa metode.  Dan tidak ada tertulis berapa banyak parameter yang dilewati dan apa jenisnya.  Panggilan dengan parameter yang salah akan menghasilkan kesalahan dalam runtime, dan tidak pada tahap kompilasi atau mengunduh aplikasi. </p><br><p>  <em>Transparansi</em> - jika metode yang dipanggil melalui refleksi gagal, maka kita harus mengarungi beberapa <code>invoke()</code> sebelum kita sampai ke dasar penyebab sebenarnya dari kesalahan. </p><br><p>  Tetapi jika kita melihat kode dari penangan event Spring atau JPA di Hibernate, maka <code>java.lang.reflect.Method</code> akan ada di dalam.  Dan dalam waktu dekat, saya pikir ini tidak mungkin berubah.  Kerangka kerja ini terlalu besar dan terlalu terikat dengan mereka, dan tampaknya kinerja penangan acara di sisi server sudah cukup untuk memikirkan apa yang dapat Anda ganti panggilan melalui refleksi dengan. </p><br><p>  Dan opsi apa lagi yang ada? </p><br><h2 id="aot-kompilyaciya-i-kodogeneraciya---vernem-prilozheniyam-skorost">  Kompilasi AOT dan pembuatan kode - memberikan aplikasi kecepatan kembali! </h2><br><p>  Kandidat pertama yang menggantikan API refleksi adalah pembuatan kode.  Sekarang kerangka kerja seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Micronaut</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quarkus</a> sudah mulai muncul, yang mencoba menyelesaikan dua masalah: mengurangi kecepatan peluncuran aplikasi dan mengurangi konsumsi memori.  Kedua metrik ini sangat penting di zaman kita tentang wadah, layanan microser, dan arsitektur tanpa server, dan kerangka kerja baru mencoba menyelesaikannya dengan kompilasi AOT.  Menggunakan teknik yang berbeda (Anda dapat membaca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , misalnya), kode aplikasi dimodifikasi sedemikian rupa sehingga semua panggilan refleksif ke metode, konstruktor, dll.  diganti dengan panggilan langsung.  Dengan demikian, Anda tidak perlu memindai kelas dan membuat kacang pada saat startup aplikasi, dan JIT mengoptimalkan kode lebih efisien saat runtime, yang memberikan peningkatan signifikan dalam kinerja aplikasi yang dibangun pada kerangka kerja tersebut.  Apakah pendekatan ini memiliki kelemahan?  Jawab: tentu saja ada. </p><br><p>  Pertama, Anda tidak menjalankan kode yang Anda tulis. Kode sumber berubah selama kompilasi, jadi jika ada yang salah, kadang-kadang sulit untuk memahami di mana kesalahannya: dalam kode Anda atau dalam algoritme pembangkitan (biasanya dalam Anda, tentu saja )  Dan dari sini muncul masalah debugging - Anda harus men-debug kode Anda sendiri. </p><br><p>  Yang kedua - untuk menjalankan aplikasi yang ditulis dalam kerangka kerja dengan kompilasi AOT, Anda memerlukan alat khusus.  Anda tidak bisa mendapatkan dan menjalankan aplikasi yang ditulis dalam Quarkus, misalnya.  Kami membutuhkan plugin khusus untuk maven / gradle, yang akan memproses kode Anda lebih dulu.  Dan sekarang, jika ada kesalahan dalam kerangka kerja, Anda perlu memperbarui tidak hanya perpustakaan, tetapi juga plugin. </p><br><p>  Sebenarnya, pembuatan kode juga bukan hal baru di dunia Java, tidak muncul dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Micronaut</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quarkus</a> .  Dalam satu bentuk atau lainnya, beberapa kerangka kerja menggunakannya.  Di sini kita dapat memanggil lombok, aspekj dengan generasi kode pendahuluan untuk aspek atau eclipselink, yang menambahkan kode ke kelas entitas untuk deserialisasi yang lebih efisien.  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CUBA,</a> kami menggunakan pembuatan kode untuk menghasilkan acara tentang perubahan dalam status entitas dan untuk memasukkan pesan validator dalam kode kelas untuk menyederhanakan bekerja dengan entitas di UI. </p><br><p>  Untuk pengembang CUBA, menerapkan pembuatan kode statis untuk penangan acara akan menjadi langkah ekstrem karena banyak perubahan harus dilakukan dalam arsitektur internal dan di plugin untuk pembuatan kode.  Apakah ada sesuatu yang tampak seperti refleksi tetapi lebih cepat? </p><br><h2 id="lambdametafactory---takie-zhe-vyzovy-metodov-no-bystree">  LambdaMetafactory - panggilan metode yang sama, tetapi lebih cepat </h2><br><p>  Java 7 memperkenalkan instruksi baru untuk JVM - <code>invokedynamic</code> .  Tentang dia ada laporan bagus oleh Vladimir Ivanov di jug.ru di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Awalnya dirancang untuk digunakan dalam bahasa dinamis seperti Groovy, instruksi ini adalah kandidat yang bagus untuk menerapkan metode di Jawa tanpa menggunakan refleksi.  Pada saat yang sama dengan instruksi baru, API terkait muncul di JDK: </p><br><ul><li>  Class <code>MethodHandle</code> - muncul kembali di Java 7, tetapi masih belum terlalu sering digunakan </li><li>  <code>LambdaMetafactory</code> - kelas ini sudah dari Java 8, ini menjadi pengembangan lebih lanjut dari API untuk panggilan dinamis, menggunakan <code>MethodHandle</code> di dalamnya. </li></ul><br><p>  Tampaknya <code>MethodHandle</code> , yang pada dasarnya berupa pointer yang diketik ke suatu metode (konstruktor, dll.), Akan dapat memenuhi peran <code>java.lang.reflect.Method</code> .  Dan panggilan akan lebih cepat, karena semua jenis pemeriksaan yang dilakukan di Reflection API dengan setiap panggilan, dalam hal ini, dilakukan hanya sekali, ketika <code>MethodHandle</code> . </p><br><p>  Namun sayang, <code>MethodHandle</code> murni ternyata lebih lambat dari panggilan melalui API refleksi.  Keuntungan kinerja dapat dicapai dengan menjadikan <code>MethodHandle</code> statis, tetapi tidak dalam semua kasus.  Ada diskusi yang sangat baik tentang kecepatan panggilan <code>MethodHandle</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di milis OpenJDK</a> . </p><br><p>  Tetapi ketika kelas <code>LambdaMetafactory</code> , ada peluang nyata untuk mempercepat pemanggilan metode.  <code>LambdaMetafactory</code> memungkinkan <code>LambdaMetafactory</code> untuk membuat objek lambda dan membungkus panggilan metode langsung di dalamnya, yang dapat diperoleh melalui <code>MethodHandle</code> .  Dan kemudian, menggunakan objek yang dihasilkan, Anda dapat memanggil metode yang diinginkan.  Berikut adalah contoh dari generasi yang membungkus metode pengambil diteruskan sebagai parameter ke BiFunction: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BiFunction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGetHandlerLambda</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, Method method)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ MethodHandles.Lookup caller = MethodHandles.lookup(); CallSite site = LambdaMetafactory.metafactory(caller, <span class="hljs-string"><span class="hljs-string">"apply"</span></span>, MethodType.methodType(BiFunction.class), MethodType.methodType(Object.class, Object.class, Object.class), caller.findVirtual(bean.getClass(), method.getName(), MethodType.methodType(method.getReturnType(), method.getParameterTypes()[<span class="hljs-number"><span class="hljs-number">0</span></span>])), MethodType.methodType(method.getReturnType(), bean.getClass(), method.getParameterTypes()[<span class="hljs-number"><span class="hljs-number">0</span></span>])); MethodHandle factory = site.getTarget(); BiFunction listenerMethod = (BiFunction) factory.invoke(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listenerMethod; }</code> </pre> <br><p>  Sebagai hasilnya, kami mendapatkan instance BiFunction alih-alih Metode.  Dan sekarang, bahkan jika kita menggunakan Metode dalam kode kita, maka menggantinya dengan BiFunction tidaklah sulit.  Ambil kode nyata (sedikit disederhanakan, benar) untuk memanggil method handler, yang ditandai <code>@EventListener</code> dari Spring Framework: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerMethodAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericApplicationListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Method method; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ Object bean = getTargetBean(); Object result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method.invoke(bean, event); handleResult(result); } }</code> </pre> <br><p>  Dan ini adalah kode yang sama, tetapi yang menggunakan pemanggilan metode melalui lambda: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerLambdaAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerMethodAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BiFunction funHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ Object bean = getTargetBean(); Object result = funHandler.apply(bean, event); handleResult(result); } }</code> </pre> <br><p>  Perubahan minimal, fungsinya sama, tetapi ada kelebihan: </p><br><p>  <em>Lambda memiliki tipe</em> - itu ditentukan pada penciptaan, sehingga memanggil "hanya metode" akan gagal. </p><br><p>  <em>Jejak tumpukan lebih pendek</em> - saat memanggil metode melalui lambda, hanya satu panggilan tambahan ditambahkan - <code>apply()</code> .  Dan itu saja.  Selanjutnya, metode itu sendiri disebut. </p><br><p>  Tetapi kecepatan harus diukur. </p><br><h3 id="zameryaem-skorost">  Ukur kecepatannya </h3><br><p>  Untuk menguji hipotesis, kami membuat microbenchmark menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JMH</a> untuk membandingkan waktu eksekusi dan throughput saat memanggil metode yang sama dengan cara yang berbeda: melalui API refleksi, melalui LambdaMetafactory, dan juga menambahkan panggilan metode langsung untuk perbandingan.  Tautan ke Metode dan lambda dibuat dan di-cache sebelum tes dimulai. </p><br><p>  Parameter uji: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>({Mode.Throughput, Mode.AverageTime}) <span class="hljs-meta"><span class="hljs-meta">@Warmup</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">5</span></span>, time = <span class="hljs-number"><span class="hljs-number">1000</span></span>, timeUnit = TimeUnit.MILLISECONDS) <span class="hljs-meta"><span class="hljs-meta">@Measurement</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">10</span></span>, time = <span class="hljs-number"><span class="hljs-number">1000</span></span>, timeUnit = TimeUnit.MILLISECONDS)</code> </pre> <br><p>  Tes itu sendiri dapat diunduh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> dan dijalankan sendiri, jika tertarik. </p><br><p>  Hasil tes untuk Oracle JDK 11.0.2 dan JMH 1.21 (jumlahnya mungkin bervariasi, tetapi perbedaannya tetap terlihat dan hampir sama): </p><br><table><thead><tr><th>  <strong>Uji - Dapatkan Nilai</strong> </th><th>  <strong>Throughput (ops / us)</strong> </th><th>  <strong>Waktu Eksekusi (kami / op)</strong> </th></tr></thead><tbody><tr><td>  LambdaGetTest </td><td>  72 </td><td>  0,0118 </td></tr><tr><td>  ReflectionGetTest </td><td>  65 </td><td>  0,0177 </td></tr><tr><td>  DirectMethodGetTest </td><td>  260 </td><td>  0,0048 </td></tr><tr><td>  <strong>Uji - Tetapkan Nilai</strong> </td><td>  <strong>Throughput (ops / us)</strong> </td><td>  <strong>Waktu Eksekusi (kami / op</strong> </td></tr><tr><td>  LambdaSetTest </td><td>  96 </td><td>  0,0092 </td></tr><tr><td>  ReflectionSetTest </td><td>  58 </td><td>  0,0173 </td></tr><tr><td>  DirectMethodSetTest </td><td>  415 </td><td>  0,0031 </td></tr></tbody></table><br><p>  Rata-rata, ternyata memanggil metode melalui lambda sekitar 30% lebih cepat daripada melalui API refleksi.  Ada diskusi besar lainnya tentang kinerja pemanggilan metode di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> jika ada yang tertarik dengan detailnya.  Singkatnya - kenaikan kecepatan diperoleh, antara lain, karena fakta bahwa lambda yang dihasilkan dapat diuraikan dalam kode program, dan pemeriksaan tipe belum dilakukan, tidak seperti refleksi. </p><br><p>  Tentu saja, tolok ukur ini cukup sederhana, tidak termasuk metode pemanggilan dalam hierarki kelas atau pengukuran kecepatan pemanggilan metode final.  Tapi kami membuat pengukuran yang lebih kompleks, dan hasilnya selalu mendukung penggunaan LambdaMetafactory. </p><br><h2 id="ispolzovanie">  Gunakan </h2><br><p>  Dalam kerangka kerja CUBA versi 7, di pengontrol UI, Anda dapat menggunakan anotasi <code>@Subscribe</code> untuk "menandatangani" metode untuk peristiwa antarmuka pengguna tertentu.  Secara internal, ini diterapkan pada <code>LambdaMetafactory</code> , tautan ke metode pendengar dibuat dan di-cache pada panggilan pertama. </p><br><p>  Inovasi ini memungkinkan untuk sangat jelas kode, terutama dalam hal bentuk dengan sejumlah besar elemen, interaksi yang kompleks, dan, dengan demikian, dengan sejumlah besar penangan acara.  Contoh sederhana dari CUBA QuickStart: Bayangkan Anda perlu menghitung ulang jumlah pesanan saat menambahkan atau menghapus item produk.  Anda perlu menulis kode yang menjalankan metode <code>calculateAmount()</code> ketika koleksi berubah dalam entitas.  Seperti apa tampilannya sebelumnya: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderEdit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CollectionDatasource&lt;OrderLine, UUID&gt; linesDs; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Map&lt;String, Object&gt; params)</span></span></span><span class="hljs-function"> </span></span>{ linesDs.addCollectionChangeListener(e -&gt; calculateAmount()); } ... }</code> </pre> <br><p>  Dan di CUBA 7, kode tersebut terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderEdit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StandardEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span>(id = <span class="hljs-string"><span class="hljs-string">"linesDc"</span></span>, target = Target.DATA_CONTAINER) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOrderLinesDcCollectionChange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CollectionChangeEvent&lt;OrderLine&gt; event)</span></span></span><span class="hljs-function"> </span></span>{ calculateAmount(); } ... }</code> </pre> <br><p>  Intinya: kodenya lebih bersih dan tidak ada metode magic <code>init()</code> , yang cenderung tumbuh dan diisi dengan event handler dengan meningkatnya kompleksitas formulir.  Namun - kami bahkan tidak perlu membuat bidang dengan komponen tempat kami berlangganan, CUBA akan menemukan komponen ini dengan ID. </p><br><h3 id="vyvody">  Kesimpulan </h3><br><p>  Meskipun munculnya kerangka kerja generasi baru dengan kompilasi AOT ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Micronaut</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quarkus</a> ), yang memiliki keunggulan yang tak terbantahkan dibandingkan kerangka kerja "tradisional" (terutama, mereka dibandingkan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spring</a> ), masih ada sejumlah besar kode yang ditulis menggunakan API refleksi. (dan terima kasih untuk semua Musim Semi yang sama).  Dan sepertinya Spring Framework saat ini masih menjadi pemimpin di antara kerangka pengembangan aplikasi dan kami akan bekerja dengan kode berbasis refleksi untuk waktu yang lama. </p><br><p>  Dan jika Anda berpikir tentang menggunakan API Refleksi dalam kode Anda - apakah itu aplikasi atau kerangka kerja - pikirkan dua kali.  Pertama, tentang pembuatan kode, dan kemudian tentang MethodHandles / LambdaMetafactory.  Metode kedua dapat berubah menjadi lebih cepat, dan upaya pengembangan akan dihabiskan tidak lebih dari dalam hal menggunakan API Refleksi. </p><br><p>  <em>Beberapa tautan yang lebih bermanfaat:</em> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alternatif yang lebih cepat untuk Java Reflection</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peretasan Ekspresi Lambda di Jawa</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode Menangani di Jawa</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Reflection, tetapi jauh lebih cepat</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa LambdaMetafactory 10% lebih lambat dari MethodHandle statis tetapi 80% lebih cepat dari MethodHandle non-statis?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terlalu Cepat, Terlalu Megamorfik: apa yang memengaruhi kinerja pemanggilan metode di Jawa?</a> <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447022/">https://habr.com/ru/post/id447022/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447010/index.html">Tidak lama musik dimainkan ... atau bagaimana OS Elbrus tidak pernah menjadi gratis</a></li>
<li><a href="../id447014/index.html">Struktur referensi pakai di C # 8.0</a></li>
<li><a href="../id447016/index.html">25 tahun kemudian: sebuah wawancara dengan Linus Torvalds</a></li>
<li><a href="../id447018/index.html">Pengayaan kuantum dalam interpretasi multi-dunia</a></li>
<li><a href="../id447020/index.html">Produktivitas bukan tentang manajemen waktu, tetapi tentang manajemen perhatian</a></li>
<li><a href="../id447024/index.html">Bagaimana cara menggabungkan keunggulan laptop dan komputer desktop? Analisis masalah dan solusi</a></li>
<li><a href="../id447026/index.html">Kami menulis OTA-loader untuk ATmega128RFA1 (sebagai bagian dari perangkat Smart Response XE)</a></li>
<li><a href="../id447028/index.html">Steganografi file terakhir: kami menyembunyikan data secara langsung di sektor</a></li>
<li><a href="../id447034/index.html">Bug baru di Telegram Desktop memungkinkan Anda membaca pesan terakhir</a></li>
<li><a href="../id447036/index.html">Koktail untuk diet sehat - dibuat oleh startup dari akselerator Universitas ITMO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>