<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçà ‚úåÔ∏è ‚ôíÔ∏è Akka Streams f√ºr blo√üe Sterbliche ü§ñ üí¢ ü§æ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie kann ich einen fortlaufenden Strom von Nachrichten von Twitter mit ein paar Codezeilen drucken, indem ich Wetterdaten zu den Orten hinzuf√ºge, an d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Akka Streams f√ºr blo√üe Sterbliche</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/418639/">  Wie kann ich einen fortlaufenden Strom von Nachrichten von Twitter mit ein paar Codezeilen drucken, indem ich Wetterdaten zu den Orten hinzuf√ºge, an denen ihre Autoren leben?  Und wie k√∂nnen Sie die Geschwindigkeit von Anfragen an den Wetteranbieter begrenzen, damit dieser uns nicht auf die schwarze Liste setzt? <br><br>  Heute erkl√§ren wir Ihnen, wie es geht, aber zuerst lernen wir die Akka Streams-Technologie kennen, die das Arbeiten mit Echtzeitdatenstr√∂men so einfach macht wie das Programmieren mit LINQ-Ausdr√ºcken, ohne dass einzelne Akteure oder Reactive Streams-Schnittstellen implementiert werden m√ºssen . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ibpnza_PCr0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Der Artikel basiert auf einer Abschrift des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berichts von Vagif Abilov</a> von unserer Dezember-Konferenz DotNext 2017 in Moskau. <br><a name="habracut"></a><br>  Mein Name ist Vagif, ich arbeite f√ºr die norwegische Firma Miles.  Heute werden wir √ºber die Akka Streams-Bibliothek sprechen. <br><br>  Akka und Reactive Streams sind der Schnittpunkt ziemlich enger Mengen, und man k√∂nnte den Eindruck gewinnen, dass dies eine solche Nische ist, dass man einige gro√üe Kenntnisse haben muss, um einzutreten, aber genau das Gegenteil.  Dieser Artikel soll zeigen, dass Sie durch die Verwendung von Akka-Streams die einfache Programmierung vermeiden k√∂nnen, die bei der Verwendung von Reactive Streams und Akka.NET erforderlich ist.  Mit Blick auf die Zukunft kann ich sofort sagen: Wenn wir zu Beginn unseres Projekts, f√ºr das wir Akka verwenden, von der Existenz von Akka Streams w√ºssten, w√ºrden wir viel anders schreiben, wir w√ºrden sowohl Zeit als auch Code sparen. <br><blockquote> <i>"Vielleicht ist das Schlimmste, was Sie tun k√∂nnen, Menschen, die keine Schmerzen haben, dazu zu bringen, Ihr Aspirin einzunehmen."</i> <br>  Max Kreminski <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Geschlossene T√ºren, Kopfschmerzen und intellektuelle Bed√ºrfnisse"</a> </blockquote>  Bevor wir auf die technischen Details eingehen, ein wenig dar√ºber, wie sich Ihr Weg zu Akka Streams herausstellen k√∂nnte und was Sie dorthin f√ºhren kann.  Eines Tages stie√ü ich auf Max Kreminskis Blog, in dem er Programmierern eine solche philosophische Frage stellte: Wie oder warum ist es f√ºr einen Programmierer unm√∂glich zu erkl√§ren, was Monaden sind.  Er erkl√§rte es so: Sehr oft gehen die Leute sofort zu den technischen Details und erkl√§ren, wie sch√∂n funktionale Programmierung ist und wie viel Sinn in der Monade steckt, ohne sich zu fragen, warum der Programmierer sie √ºberhaupt braucht.  Wenn man eine Analogie zieht, ist es so, als w√ºrde man versuchen, Aspirin zu verkaufen, ohne herauszufinden, ob Ihr Patient Schmerzen hat. <br><br>  Mit dieser Analogie m√∂chte ich die folgende Frage stellen: Wenn Akka Streams Aspirin ist, was sollte dann der Schmerz sein, der Sie dazu f√ºhren wird? <br><br><h1>  Datenstr√∂me </h1><br>  Lassen Sie uns zun√§chst √ºber Datenstr√∂me sprechen.  Die Str√∂mung kann recht einfach und linear sein. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Ihr Browser unterst√ºtzt kein HTML5-Video. <source src="https://media.giphy.com/media/ZNejul2eTftImnVrsY/giphy.mp4" type="video/mp4"></video></div></div></div><br>  Hier haben wir einen bestimmten Datenkonsumenten (ein Kaninchen im Video).  Es verbraucht Daten mit einer Geschwindigkeit, die zu ihm passt.  Dies ist die ideale Interaktion des Verbrauchers mit dem Stream: Sie legt die Bandbreite fest und die Daten flie√üen leise dorthin.  Dieser einfache Datenstrom kann unendlich sein oder enden. <br><br>  Der Fluss kann jedoch komplexer sein.  Wenn Sie mehrere Kaninchen nebeneinander pflanzen, haben wir bereits eine Parallelisierung der Fl√ºsse.  Was Reactive Streams zu l√∂sen versucht, ist genau, wie wir mit Str√∂mungen auf einer konzeptionelleren Ebene kommunizieren k√∂nnen, d. H. Unabh√§ngig davon, ob es sich nur um eine Art Temperatursensormessung handelt, bei der lineare Messungen eingehen oder wir haben kontinuierliche Messungen von Tausenden von Temperatursensoren, die √ºber RabbitMQ-Warteschlangen in das System gelangen und in Systemprotokollen gespeichert werden.  Alle oben genannten k√∂nnen als ein zusammengesetzter Strom betrachtet werden.  Wenn Sie noch weiter gehen, kann das automatisierte Produktionsmanagement (z. B. durch einen Online-Shop) auch auf einen Datenstrom reduziert werden, und es w√§re gro√üartig, wenn wir √ºber die Planung eines solchen Stroms sprechen k√∂nnten, egal wie kompliziert er ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7c/fa0/3af/a7cfa03af65ad4d88c1ce13d316e272e.jpg"><br><br>  F√ºr moderne Projekte ist die Thread-Unterst√ºtzung nicht sehr gut.  Wenn ich mich richtig erinnere, wollte Aaron Stannard, dessen Tweet Sie auf dem Bild sehen, einen Stream einer Multi-Gigabyte-Datei mit CSV erhalten, d. H.  Es stellte sich heraus, dass es nichts gibt, das Sie sofort ausf√ºhren und verwenden k√∂nnen, ohne eine Reihe zus√§tzlicher Aktionen.  Aber er konnte einfach keinen Strom von CSV-Werten bekommen, was ihn traurig machte.  Es gibt nur wenige L√∂sungen (mit Ausnahme einiger spezieller Bereiche), viel wird durch die alten Methoden realisiert. Wenn wir all dies √∂ffnen, mit dem Lesen beginnen und puffern, erhalten wir im schlimmsten Fall so etwas wie einen Notizblock, der besagt, dass die Datei zu gro√ü ist. <br><br>  Auf einer hohen konzeptionellen Ebene besch√§ftigen wir uns alle mit der Verarbeitung von Datenstr√∂men, und Akka Streams hilft Ihnen, wenn: <br><br><ul><li>  Sie sind mit Akka vertraut, m√∂chten sich aber die Details ersparen, die mit dem Schreiben von Schauspielercode und deren Koordination verbunden sind. <br></li><li>  Sie sind mit Reactive Streams vertraut und m√∂chten eine vorgefertigte Implementierung ihrer Spezifikation verwenden. <br></li><li>  Akka Streams-Blockelemente f√ºr Stufen eignen sich zur Modellierung Ihres Prozesses. <br></li><li>  Sie m√∂chten den Gegendruck (Gegendruck) von Akka Streams nutzen, um die Durchsatzstufen Ihres Workflows zu verwalten und dynamisch zu verfeinern. <br></li></ul><br><h1>  Von Schauspielern zu Akka Streams </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/9e2/067/5d1/9e20675d1a251ffc62b578eba2e7167d.jpg"><br><br>  Der erste Weg f√ºhrt von Schauspielern zu Akka Streams, mein Weg. <br><br>  Das Bild zeigt, warum wir das Schauspielermodell verwendet haben.  Wir waren ersch√∂pft von der manuellen Steuerung der Fl√ºsse, dem gemeinsamen Zustand, das ist alles.  Jeder, der mit gro√üen Systemen mit Multithread-Systemen gearbeitet hat, wei√ü, wie viel Zeit dies kostet und wie einfach es ist, Fehler zu machen, die f√ºr den gesamten Prozess fatal sein k√∂nnen.  Dies f√ºhrte uns zum Modell der Schauspieler.  Wir bedauern die getroffene Entscheidung nicht, aber wenn Sie anfangen zu arbeiten und mehr zu programmieren, weicht die anf√§ngliche Begeisterung nat√ºrlich nicht etwas anderem, sondern Sie erkennen, dass etwas noch effektiver gemacht werden kann. <br><blockquote>  <i>‚ÄûStandardm√§√üig werden Empf√§nger ihrer Nachrichten in den Code der Akteure eingetragen.</i>  <i>Wenn ich einen Schauspieler A erstelle, der eine Nachricht an Schauspieler B sendet, und Sie den Empf√§nger durch Schauspieler C ersetzen m√∂chten, funktioniert dies im Allgemeinen nicht f√ºr Sie. ‚Äú</i> <br>  Noel Welch (underscore.io) </blockquote>  Schauspieler kritisiert, weil sie nicht komponiert haben.  Einer der ersten, der in seinem Blog dar√ºber schrieb, war Noel Welch, einer der Entwickler von Underscore.  Er bemerkte, dass das System der Schauspieler ungef√§hr so ‚Äã‚Äãaussieht: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d8f/e3b/3dd/d8fe3b3dd378bb187c4a85de3e982960.jpg"><br><br>  Wenn Sie keine zus√§tzlichen Dinge wie die Abh√§ngigkeitsinjektion verwenden, wird die Adresse des Empf√§ngers in den Akteur eingen√§ht. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3df/62f/78b/3df62f78bf5f64bda875c5f448057427.jpg"><br><br>  Wenn sie anfangen, sich gegenseitig Nachrichten zu senden, programmieren Sie die Akteure im Voraus.  Und ohne zus√§tzliche Tricks wird ein solches starres System erhalten. <br>  Einer der Entwickler von Akka, Roland Kuhn, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erkl√§rte,</a> was im Allgemeinen unter schlechtem Layout zu verstehen ist.  Die Basis f√ºr das Senden von Akteursnachrichten ist die Tell-Methode, dh unidirektionale Nachrichten: Sie ist vom Typ void, dh sie gibt je nach Sprache nichts (oder keine Einheit) zur√ºck.  Daher ist es unm√∂glich, aus einer Kette von Akteuren eine Beschreibung des Prozesses zu erstellen.  Also hast du Tell geschickt, was dann?  H√∂r auf  Wir wurden nichtig.  Sie k√∂nnen es beispielsweise mit LINQ-Ausdr√ºcken vergleichen, bei denen jedes Element des Ausdrucks IQueryable, IEnumerable zur√ºckgibt und all dies einfach kompiliert werden kann.  Schauspieler geben keine solche Gelegenheit.  Gleichzeitig beanstandete Roland Kuhn die Tatsache, dass sie, wie sie sagen, nicht im Prinzip komponieren, sondern dass sie tats√§chlich auf andere Weise zusammengestellt werden, in dem Sinne, in dem sich die menschliche Gesellschaft f√ºr das Layout eignet.  Es klingt wie ein philosophisches Argument, aber wenn Sie dar√ºber nachdenken, macht die Analogie Sinn - ja, die Schauspieler senden sich gegenseitig unidirektionale Botschaften, aber wir kommunizieren auch miteinander und sprechen unidirektionale Botschaften aus, aber gleichzeitig interagieren wir ziemlich effektiv, dh wir schaffen komplexe Systeme.  Trotzdem gibt es eine solche Kritik an den Akteuren. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SampleActor</span></span> : <span class="hljs-title"><span class="hljs-title">ReceiveActor</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleActor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Idle(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PreStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Idle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Receive&lt;Job&gt;(job =&gt; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Working</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Receive&lt;Cancel&gt;(job =&gt; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>); } }</code> </pre> <br>  Dar√ºber hinaus erfordert die Implementierung des Akteurs mindestens das Schreiben einer Klasse, wenn Sie in C # arbeiten, oder Funktionen, wenn Sie in F # arbeiten.  Im obigen Beispiel - Boilerplate-Code, den Sie auf jeden Fall schreiben m√ºssen.  Obwohl es nicht sehr gro√ü ist, ist es eine bestimmte Anzahl von Zeilen, die Sie immer auf dieser niedrigen Ebene schreiben m√ºssen.  Fast der gesamte Code, der hier vorhanden ist, ist eine Art Zeremonie.  Was passiert, wenn ein Schauspieler direkt eine Nachricht empf√§ngt, wird hier √ºberhaupt nicht angezeigt.  Und das alles muss geschrieben werden.  Dies ist nat√ºrlich nicht sehr viel, aber dies ist ein Beweis daf√ºr, dass wir mit Akteuren auf niedriger Ebene zusammenarbeiten und solche nichtigen Methoden entwickeln. <br><br>  Was w√§re, wenn wir auf eine andere, h√∂here Ebene gehen und uns Fragen zur Modellierung unseres Prozesses stellen k√∂nnten, einschlie√ülich der Verarbeitung von Daten aus verschiedenen Quellen, die gemischt, konvertiert und √ºbertragen werden? <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = db.Companies .Join(db.People, c =&gt; c.CompanyID, p =&gt; p.PersonID, (c, p) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { c, p }) .Where(z =&gt; zcCreated &gt;= fromDate) .OrderByDescending(z =&gt; zcCreated) .Select(z =&gt; zp) .ToList();</code> </pre> <br>  Ein Analogon zu diesem Ansatz kann das sein, was wir alle seit zehn Jahren an LINQ gew√∂hnt sind.  Wir wundern uns nicht, wie Join funktioniert.  Wir wissen, dass es einen solchen LINQ-Anbieter gibt, der all dies f√ºr uns erledigt, und wir sind auf einer h√∂heren Ebene daran interessiert, die Anfrage zu erf√ºllen.  Und wir k√∂nnen hier im Allgemeinen Datenbanken mischen, wir k√∂nnen Verteilungsanfragen senden.  Was w√§re, wenn Sie den Prozess so beschreiben k√∂nnten? <br><br><pre> <code class="cs hljs">HttpGet pageUrl |&gt; fun s -&gt; Regex.Replace(s, <span class="hljs-string"><span class="hljs-string">"[^A-Za-z']"</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>) |&gt; fun s -&gt; Regex.Split(s, <span class="hljs-string"><span class="hljs-string">" +"</span></span>) |&gt; Set.ofArray |&gt; Set.filter (fun word -&gt; not (Spellcheck word)) |&gt; Set.iter (fun word -&gt; printfn <span class="hljs-string"><span class="hljs-string">" %s"</span></span> word)</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Quelle)</a> <br><br>  Oder zum Beispiel funktionale Transformationen.  Was viele Leute an der funktionalen Programmierung m√∂gen, ist, dass Sie Daten durch eine Reihe von Transformationen leiten k√∂nnen und einen ziemlich klaren kompakten Code erhalten, unabh√§ngig davon, in welcher Sprache Sie ihn schreiben.  Es ist leicht zu lesen.  Der Code auf dem Bild ist speziell in F # geschrieben, aber im Allgemeinen versteht wahrscheinlich jeder, was hier passiert. <br><br><pre> <code class="cs hljs">val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> = Source(<span class="hljs-number"><span class="hljs-number">1</span></span> to <span class="hljs-number"><span class="hljs-number">10</span></span>) val <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = Sink.ignore val bcast = builder.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Broadcast[Int](<span class="hljs-number"><span class="hljs-number">2</span></span>)) val merge = builder.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Merge[Int](<span class="hljs-number"><span class="hljs-number">2</span></span>)) val f1,f2,f3,f4 = Flow[Int].map(_ + <span class="hljs-number"><span class="hljs-number">10</span></span>) source ~&gt; f1 ~&gt; bcast ~&gt; f2 ~&gt; merge ~&gt; f3 ~&gt; sink bcast ~&gt; f4 ~&gt; merge ~&gt;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Quelle)</a> <br><br>  Wie w√§re es dann damit?  Im obigen Beispiel haben wir eine Quellendatenquelle, die aus Ganzzahlen von 1 bis 10 besteht. Dies ist die sogenannte grafische DSL (dom√§nenspezifische Sprache).  Die Elemente der Dom√§nensprache im obigen Beispiel sind unidirektionale Pfeilsymbole. Dies sind zus√§tzliche Operatoren, die von Sprachwerkzeugen definiert werden, die die Richtung des Streams grafisch anzeigen.  Wir durchlaufen Source durch eine Reihe von Transformationen - zur Vereinfachung der Demonstration addieren alle nur eine Zehn zur Zahl.  Als n√§chstes kommt Broadcast: Wir multiplizieren die Kan√§le, dh jede Zahl gibt zwei Kan√§le ein.  Dann addieren wir erneut 10, mischen unsere Datenstr√∂me, erhalten einen neuen Stream, f√ºgen ebenfalls 10 hinzu, und all dies geht in unseren Datenstrom, in dem nichts passiert.  Dies ist der eigentliche Code, der in Scala, einem Teil von Akka Streams, geschrieben und in dieser Sprache implementiert ist.  Das hei√üt, Sie geben die Phasen der Transformation Ihrer Daten an, geben an, was mit ihnen zu tun ist, geben die Quelle, den Bestand und einige Pr√ºfpunkte an und erstellen dann mithilfe der grafischen DSL ein solches Diagramm.  Dies ist alles Code f√ºr ein einzelnes Programm.  Einige Codezeilen zeigen, was dabei vor sich geht. <br><br>  Vergessen wir, wie der Definitionscode f√ºr einzelne Akteure geschrieben wird, und lernen stattdessen die √ºbergeordneten Layout-Grundelemente, mit denen die erforderlichen Akteure in sich selbst erstellt und verbunden werden.  Wenn wir ein solches Diagramm ausf√ºhren, erstellt das System, das Akka Streams bereitstellt, den erforderlichen Akteur selbst, sendet alle diese Daten dorthin, verarbeitet sie wie gew√ºnscht und gibt sie schlie√ülich an den endg√ºltigen Empf√§nger weiter. <br><br><pre> <code class="hljs pgsql">var runnable = Source .<span class="hljs-keyword"><span class="hljs-keyword">From</span></span>(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)) .Via(Flow.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;().<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span>(x =&gt; x * <span class="hljs-number"><span class="hljs-number">2</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">To</span></span>(Sink.<span class="hljs-keyword"><span class="hljs-keyword">ForEach</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;(x =&gt; Console.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(x.ToString));</code> </pre> <br>  Das obige Beispiel zeigt, wie dies in C # aussehen k√∂nnte.  Der einfachste Weg: Wir haben eine Datenquelle - dies sind Zahlen von 1 bis 1000 (wie Sie sehen k√∂nnen, kann in Akka Streams jede IEnumerable zu einer Quelle des Datenflusses werden, was sehr praktisch ist).  Wir f√ºhren eine einfache Berechnung durch, beispielsweise multiplizieren wir mit zwei, und dann wird im Datenstrom all dies auf dem Bildschirm angezeigt. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(builder =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcast = builder.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = builder.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = Flow.FromFunction(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(x =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = Flow.Create&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Sum((x, y) =&gt; x + y); builder.From(bcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)).To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); builder.From(bcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)).Via(count).Via(sum).To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(bcast.In, merge.Out); });</code> </pre> <br>  Was im obigen Beispiel gezeigt wird, wird als "grafisches DSL in C #" bezeichnet.  Tats√§chlich gibt es hier keine Grafiken, es ist ein Port mit Scala, aber in C # gibt es keine M√∂glichkeit, Operatoren auf diese Weise zu definieren. Daher sieht es etwas umst√§ndlicher aus, ist aber dennoch kompakt genug, um zu verstehen, was hier passiert.  Wir erstellen also ein bestimmtes Diagramm (es gibt verschiedene Arten von Diagrammen, hier wird es FlowShape genannt) aus verschiedenen Komponenten, in denen es eine Datenquelle und einige Transformationen gibt.  Wir senden Daten an einen Kanal, in dem wir die Anzahl generieren, dh die Anzahl der zu √ºbertragenden Datenelemente, und in dem anderen generieren wir die Summe und mischen dann alles.  Als n√§chstes sehen wir interessantere Beispiele als nur die Verarbeitung von ganzen Zahlen. <br>  Dies ist der erste Pfad, der Sie zu Akka Streams f√ºhren kann, wenn Sie Erfahrung mit einem Schauspieler-Modell haben und dar√ºber nachgedacht haben, ob Sie jeden manuell schreiben sollen, selbst den einfachsten Schauspieler.  Der zweite Weg, zu dem Akka Streams kommen, sind reaktive Streams. <br><br><h1>  Von reaktiven Streams zu Akka-Streams </h1><br>  Was sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reaktive Streams</a> ?  Dies ist eine gemeinsame Initiative zur Entwicklung eines Standards f√ºr die asynchrone Verarbeitung von Datenstr√∂men.  Es definiert den Mindestsatz an Schnittstellen, Methoden und Protokollen, die die zur Erreichung des Ziels erforderlichen Vorg√§nge und Entit√§ten beschreiben - die asynchrone Verarbeitung von Daten in Echtzeit mit nicht blockierendem Gegendruck (Gegendruck).  Es erm√∂glicht verschiedene Implementierungen mit verschiedenen Programmiersprachen. <br><br>  Mit Reactive Streams k√∂nnen Sie eine m√∂glicherweise unbegrenzte Anzahl von Elementen in einer Sequenz verarbeiten und Elemente asynchron zwischen Komponenten mit nicht blockierendem Gegendruck √ºbertragen. <br><br>  Die Liste der Initiatoren f√ºr die Erstellung von Reactive Streams ist beeindruckend: Hier sind Netflix, Oracle und Twitter. <br><br>  Die Spezifikation ist sehr einfach, um die Implementierung in verschiedenen Sprachen und Plattformen so zug√§nglich wie m√∂glich zu machen.  Die Hauptkomponenten der Reactive Streams-API: <br><br><ol><li>  Herausgeber <br></li><li>  Abonnent <br></li><li>  Abonnement <br></li><li>  Prozessor <br></li></ol><br>  Im Wesentlichen bedeutet diese Spezifikation nicht, dass Sie manuell mit der Implementierung dieser Schnittstellen beginnen.  Es versteht sich, dass es einige Bibliotheksentwickler gibt, die dies f√ºr Sie tun.  Und Akka Streams ist eine der Implementierungen dieser Spezifikation. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPublisher</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISubscriber&lt;T&gt; subscriber</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISubscriber</span></span>&lt;<span class="hljs-title"><span class="hljs-title">in</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSubscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISubscription subscription</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T element</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception cause</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnComplete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre> <br>  Die Schnittstellen sind, wie Sie dem Beispiel entnehmen k√∂nnen, wirklich sehr einfach: Beispielsweise enth√§lt Publisher nur eine Methode - "Abonnieren".  Der Abonnent Abonnent enth√§lt nur wenige Reaktionen auf das Ereignis. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISubscription</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Request</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cancel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IProcessor</span></span>&lt;<span class="hljs-title"><span class="hljs-title">in</span></span> <span class="hljs-title"><span class="hljs-title">T1</span></span>, <span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T2</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">ISubscriber</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T1</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IPublisher</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T2</span></span>&gt; { }</code> </pre> <br>  Schlie√ülich enth√§lt das Abonnement zwei Methoden - "Start" und "Ablehnen".  Der Prozessor definiert √ºberhaupt keine neuen Methoden, er kombiniert einen Herausgeber und einen Abonnenten. <br><br>  Was unterscheidet Reactive Streams von anderen Stream-Implementierungen?  Reactive Streams kombiniert Push- und Pull-Modelle.  F√ºr den Support ist dies das effizienteste Leistungsszenario.  Angenommen, Sie haben einen langsamen Datenabonnenten.  In diesem Fall kann es fatal sein, auf ihn zu dr√§ngen: Wenn Sie ihm eine gro√üe Datenmenge senden, kann er diese nicht verarbeiten.  Es ist besser, Pull zu verwenden, damit der Abonnent selbst die Daten vom Herausgeber abruft.  Wenn der Herausgeber jedoch langsam ist, stellt sich heraus, dass der Abonnent st√§ndig blockiert ist und st√§ndig wartet.  Eine Zwischenl√∂sung kann die Konfiguration sein: Wir haben eine Konfigurationsdatei, in der wir bestimmen, welche davon schneller ist.  Und wenn sich ihre Geschwindigkeiten √§ndern? <br><br>  Die eleganteste Implementierung ist also eine, bei der wir Push- und Pull-Modelle dynamisch √§ndern k√∂nnen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/971/ab6/298/971ab6298b3f313b90503cf6a860e188.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Quelle (Apache Flink))</a> <br><br>  Das Diagramm zeigt, wie dies geschehen kann.  Diese Demo verwendet Apache Flink.  Yellow ist ein Verlag, Datenproduzent, er wurde auf etwa 50% seiner F√§higkeiten festgelegt.  Der Abonnent versucht, die beste Strategie zu w√§hlen - es stellt sich heraus, dass es sich um einen Push handelt.  Dann setzen wir den Teilnehmer auf eine Geschwindigkeit von ungef√§hr 20% zur√ºck und er schaltet auf Ziehen um.  Dann gehen wir zu 100%, geben wieder 20% zum Pull-Modell usw. zur√ºck. All dies geschieht in der Dynamik. Sie m√ºssen den Dienst nicht beenden, sondern etwas in die Konfiguration eingeben.  Dies ist ein Beispiel daf√ºr, wie der Gegendruck in Akka Streams funktioniert. <br><br><h1>  Akka Streams Prinzipien </h1><br>  Nat√ºrlich w√ºrden Akka Streams nicht an Popularit√§t gewinnen, wenn es keine eingebauten Bl√∂cke g√§be, die sehr einfach zu bedienen sind.  Es gibt viele von ihnen.  Sie sind in drei Hauptgruppen unterteilt: <br><br><ol><li>  Datenquelle (Quelle) - Verarbeitungsstufe mit einer Ausgabe. <br></li><li>  Waschbecken ist ein Verarbeitungsschritt mit einem Eintrag. <br></li><li>  Checkpoint (Flow) - Verarbeitungsstufe mit einem Eingang und einem Ausgang.  Funktionale Transformationen finden hier statt und nicht unbedingt im Speicher: Es kann sich beispielsweise um einen Aufruf eines Webdienstes, einiger Parallelit√§tselemente mit mehreren Threads handeln. <br></li></ol><br>  Von diesen drei Typen k√∂nnen Graphen gebildet werden.  Dies sind bereits komplexere Verarbeitungsstufen, die aus Quellen, Abfl√ºssen und Kontrollpunkten aufgebaut sind.  Es kann jedoch nicht jeder Graph ausgef√ºhrt werden: Wenn darin L√∂cher vorhanden sind, dh offene Ein- und Ausg√§nge, wird dieser Graph nicht ausgef√ºhrt. <br>  Ein Diagramm ist ein ausf√ºhrbares Diagramm. Wenn es geschlossen ist, dh f√ºr jede Eingabe gibt es eine Ausgabe: Wenn die Daten eingegeben wurden, m√ºssen sie irgendwohin gegangen sein. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41f/059/a3c/41f059a3cebba7f1e023c8036a29cc8e.jpg"><br><br>  Akka Streams verf√ºgt √ºber integrierte Quellen: Auf dem Bild sehen Sie, wie viele davon vorhanden sind.  Ihre Namen sind eins zu eins und spiegeln wider, was Scala oder die JVM haben, mit Ausnahme einiger .NET-spezifischer n√ºtzlicher Quellen.  Die ersten beiden (FromEnumerator und From) sind einige der wichtigsten: Jede Nummerierung, jede ienumerable kann in eine Stream-Quelle umgewandelt werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/504/3cb/0e7/5043cb0e7cd9fb15e6b00582b5230103.jpg"><br><br>  Es gibt integrierte Drains: Einige davon √§hneln LINQ-Methoden, z. B. First, Last, FirstOrDefault.  Nat√ºrlich k√∂nnen Sie alles, was Sie erhalten, in Dateien und Streams speichern, nicht in Akka-Streams, sondern in .NET-Streams.  Wenn Sie Akteure in Ihrem System haben, k√∂nnen Sie diese sowohl am Eingang als auch am Ausgang des Systems verwenden, dh, wenn Sie m√∂chten, in Ihr fertiges System einbetten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a6/947/229/0a6947229a7ddbb5577b39634a4b6c11.jpg"><br><br>  Und es gibt eine gro√üe Anzahl integrierter Checkpoints, die vielleicht noch mehr an LINQ erinnern, denn hier gibt es Select, SelectMany und GroupBy, also alles, womit wir in LINQ arbeiten. <br><br>  Zum Beispiel hei√üt Select in Scala SelectAsync: Es ist leistungsf√§hig genug, da es die Parallelit√§t als eines der Argumente verwendet.  Das hei√üt, Sie k√∂nnen angeben, dass beispielsweise Select Daten in zehn Threads parallel an einen Webdienst sendet. Anschlie√üend werden alle Daten gesammelt und weitergeleitet.  Tats√§chlich bestimmen Sie den Skalierungsgrad des Pr√ºfpunkts mit einer Codezeile. <br><br>  Eine Flow-Deklaration ist ihr Ausf√ºhrungsplan, dh ein Graph, auch ein Run-Plan, kann nicht einfach so ausgef√ºhrt werden - er muss materialisiert werden.  Es muss ein instanziiertes System geben, ein Akteursystem, Sie m√ºssen ihm einen Stream geben, diesen Ausf√ºhrungsplan, und dann wird er ausgef√ºhrt.  Dar√ºber hinaus ist es zur Laufzeit stark optimiert, √§hnlich wie beim Senden eines LINQ-Ausdrucks an eine Datenbank: Ein Anbieter kann Ihr SQL f√ºr eine effizientere Datenausgabe optimieren und im Wesentlichen den Abfragebefehl durch einen anderen ersetzen.  Das Gleiche gilt f√ºr Akka Streams: Ab Version 2.0 k√∂nnen Sie eine bestimmte Anzahl von Pr√ºfpunkten festlegen, und das System wird verstehen, dass einige davon kombiniert werden k√∂nnen, sodass sie von einem Akteur ausgef√ºhrt werden (Operator Fusion).  Checkpoints behalten in der Regel die Reihenfolge der Verarbeitungselemente bei. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = db.Companies .Join(db.People, c =&gt; c.CompanyID, p =&gt; p.PersonID, (c, p) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { c, p }) .Where(z =&gt; zcCreated &gt;= fromDate) .OrderByDescending(z =&gt; zcCreated) .Select(z =&gt; zp) .ToList();</code> </pre> <br>  Die Stream-Materialisierung kann mit dem letzten ToList-Element im LINQ-Ausdruck im obigen Beispiel verglichen werden.  Wenn wir keine ToList schreiben, erhalten wir einen nicht materialisierten LINQ-Ausdruck, der nicht dazu f√ºhrt, dass die Daten an den SQL Server oder Oracle √ºbertragen werden, da die meisten LINQ-Anbieter die sogenannte verz√∂gerte Abfrageausf√ºhrung (verz√∂gerte Abfrageausf√ºhrung) unterst√ºtzen, t d.h. die Anforderung wird nur ausgef√ºhrt, wenn ein Befehl gegeben wird, um ein Ergebnis zu liefern.  Je nachdem, was angefordert wird - eine Liste oder das erste Ergebnis - wird das effektivste Team gebildet.  Wenn wir ToList sagen, bitten wir den LINQ-Anbieter, uns das fertige Ergebnis zu geben. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> runnable = Source .From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)) .Via(Flow.Create&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Select(x =&gt; x * <span class="hljs-number"><span class="hljs-number">2</span></span>) .To(Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(x =&gt; Console.Write(x.ToString));</code> </pre> <br>  Akka Streams funktioniert genauso.  Auf dem Bild sehen Sie unser gestartetes Diagramm, das aus einer Quelle von Pr√ºfpunkten und Abfl√ºssen besteht. Wir m√∂chten es jetzt ausf√ºhren. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> runnable = Source .From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)) .Via(Flow.Create&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Select(x =&gt; x * <span class="hljs-number"><span class="hljs-number">2</span></span>) .To(Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(x =&gt; Console.Write(x.ToString)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> system = ActorSystem.Create(<span class="hljs-string"><span class="hljs-string">"MyActorSystem"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> materializer = ActorMaterializer.Create(system)) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> runnable.Run(materializer); }</code> </pre> <br>  Damit dies geschieht, m√ºssen wir ein System von Akteuren erstellen, in dem sich ein Materialisierer befindet, unser Diagramm an ihn weitergeben und er wird es ausf√ºhren.  Wenn wir es neu erstellen, wird es erneut ausgef√ºhrt, und es k√∂nnen andere Ergebnisse erzielt werden. <br><br>  Neben der Materialisierung des Flusses, die √ºber den materiellen Teil von Akka Streams spricht, sind die materialisierten Werte zu erw√§hnen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source1 = Source.From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink1 = Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(output.Add); IRunnableGraph&lt;NotUsed&gt; runnable1 = source1.To(sink1); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source2 = Source.From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink2 = Sink.Sum&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;((x,y) =&gt; x + y); IRunnableGraph&lt;Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; runnable2 = source2.ToMaterialized(sink2, Keep.Right);</code> </pre> <br>  Wenn wir einen Stream haben, der von der Quelle √ºber die Checkpoints zum Drain flie√üt, stehen uns diese nicht zur Verf√ºgung, wenn wir keine Zwischenwerte anfordern, da dieser auf die effizienteste Weise ausgef√ºhrt wird.  Es ist wie eine Black Box.  Es kann jedoch f√ºr uns interessant sein, einige Zwischenwerte herauszuholen, da an jedem Punkt links einige Werte eingehen, andere Werte rechts herauskommen und Sie ein Diagramm angeben k√∂nnen, um anzugeben, woran Sie interessiert sind.  Im obigen Beispiel zeigt uns ein Einlaufdiagramm, in dem NotUsed angegeben ist, dh keine materialisierten Werte.  Im Folgenden erstellen wir es mit dem Hinweis, dass auf der rechten Seite des Abflusses, dh nachdem alle Transformationen abgeschlossen wurden, materialisierte Werte ausgegeben werden m√ºssen.  Wir erhalten die Diagrammaufgabe - eine Aufgabe, nach deren Abschluss wir ein int erhalten, dh was am Ende dieses Diagramms passiert.  Sie k√∂nnen in jedem Absatz angeben, dass Sie eine Art von materialisierten Werten ben√∂tigen. All dies wird nach und nach gesammelt. <br><br>  Um Daten in Akka Streams-Streams zu √ºbertragen oder dort herauszuholen, ist nat√ºrlich eine Art Interaktion mit der Au√üenwelt erforderlich.  Eingebettete Quellstufen enthalten eine Vielzahl reaktiver Datenstr√∂me: <br><br><ul><li>  Mit Source.FromEnumerator und Source.From k√∂nnen Sie Daten von jeder Quelle √ºbertragen, die IEnumerable implementiert. <br></li><li>  Unfold und UnfoldAsync generieren die Ergebnisse von Funktionsberechnungen, sofern sie Werte ungleich Null zur√ºckgeben. <br></li><li>  FromInputStream transformiert einen Stream. <br></li><li>  FromFile analysiert den Inhalt der Datei in den reaktiven Stream. <br></li><li>  ActorPublisher konvertiert Actor-Nachrichten. <br></li></ul><br>  Wie ich bereits sagte, ist es f√ºr .NET-Entwickler sehr produktiv, Enumerator oder IEnumerable zu verwenden, aber manchmal ist es eine zu primitive, zu ineffiziente Art, auf Daten zuzugreifen.  Komplexere Quellen, die eine gro√üe Datenmenge enthalten, erfordern spezielle Konnektoren.  Solche Anschl√ºsse sind geschrieben.  Es gibt ein Open-Source-Projekt Alpakka, das urspr√ºnglich in Scala erschien und jetzt in .NET ist.  Dar√ºber hinaus verf√ºgt Akka √ºber sogenannte persistente Akteure und √ºber eigene Streams, die verwendet werden k√∂nnen (z. B. bildet die Akka-Persistenzabfrage den Inhaltsfluss des Akka-Ereignisjournals). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/109/c40/b29/109c40b2934e0a4a4e280b27d2cd1e8b.jpg"><br><br>  Wenn Sie mit Scala arbeiten, ist der einfachste Weg f√ºr Sie: Es gibt eine gro√üe Anzahl von Anschl√ºssen, und Sie werden sicherlich etwas nach Ihrem Geschmack finden.  Zur Information, Kafka ist das sogenannte Reactive Kafka, nicht Kafka Streams.  Kafka Streams unterst√ºtzt meines Wissens keinen Gegendruck.  Reactive Kafka ist eine Stream-Implementierung von Kafka, die Reactive Streams unterst√ºtzt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f24/160/09d/f2416009d41f26f08e665b2d510aa7db.jpg"><br><br>  Die Liste der Alpakka .NET-Konnektoren ist bescheidener, wird jedoch aufgef√ºllt, und es gibt ein Wettbewerbselement.  Es gibt einen halbj√§hrigen Tweet von David Fowler von Microsoft, der sagte, dass SignalR jetzt Daten mit Reactive Extensions austauschen kann, und einer der Akka-Entwickler antwortete, dass es tats√§chlich seit einiger Zeit in Akka Streams war.  Akka unterst√ºtzt verschiedene Dienste von Microsoft Azure.  CSV ist das Ergebnis von Aaron Stannards Frustration, als er entdeckte, dass es keinen guten Stream f√ºr CSV gibt: Jetzt hat Akka einen eigenen Stream f√ºr CSV XML.  Es gibt AMQP (in Wirklichkeit RabbitMQ), es befindet sich in der Entwicklung, ist aber verf√ºgbar, es funktioniert.  Kafka befindet sich ebenfalls in der Entwicklung.  Diese Liste wird weiter erweitert. <br><br>  Ein paar Worte zu den Alternativen, denn wenn Sie mit Datenstr√∂men arbeiten, ist Akka Streams nat√ºrlich nicht die einzige M√∂glichkeit, mit diesen Streams umzugehen.  In Ihrem Projekt h√§ngt die Wahl der Implementierung von Threads h√∂chstwahrscheinlich von vielen anderen Faktoren ab, die m√∂glicherweise von entscheidender Bedeutung sind.  Wenn Sie beispielsweise viel mit Microsoft Azure arbeiten und Orleans durch die Unterst√ºtzung virtueller Akteure oder, wie sie genannt werden, K√∂rner organisch in die Anforderungen Ihres Projekts integriert ist, verf√ºgen sie √ºber eine eigene Implementierung, die nicht der Spezifikation f√ºr reaktive Streams entspricht - Orleans Streams es wird f√ºr Sie am n√§chsten sein, und es ist sinnvoll, dass Sie darauf achten.  Wenn Sie viel mit TPL arbeiten, gibt es TPL DataFlow - dies ist m√∂glicherweise die engste Analogie zu Akka Streams: Es enth√§lt auch Grundelemente zum Erstellen von Datenstr√∂men sowie Tools zur Pufferung und Bandbreitenbegrenzung (BoundedCapacity, MaxMessagePerTask).  Wenn Ihnen die Ideen des Schauspielermodells nahe stehen, k√∂nnen Sie mit Akka Streams dies beheben und viel Zeit sparen, ohne jeden Schauspieler manuell schreiben zu m√ºssen. <br><br><h1>  Implementierungsbeispiel: Ereignisprotokollstrom </h1><br>  Schauen wir uns einige Implementierungsbeispiele an.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste Beispiel ist nicht die direkte Implementierung eines Streams, sondern die Verwendung eines Streams. Dies war unsere erste Erfahrung mit Akka Streams, als wir entdeckten, dass wir tats√§chlich einen Stream abonnieren k√∂nnen, der uns sehr vereinfacht. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/43e/de0/51f/43ede051f01ec132e11502f9cebaccaf.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir laden verschiedene Mediendateien in die Cloud hoch. Dies war eine fr√ºhe Phase des Projekts: hier in den letzten 15 Minuten 23 Dateien, davon 7 Fehler. Jetzt gibt es praktisch keine Fehler mehr und die Anzahl der Dateien ist viel gr√∂√üer - Hunderte gehen alle paar Minuten durch. All dies ist im Kibana Dashboard enthalten.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kibana liest Daten aus Elasticsearch. Da in Elasticsearch eher sekund√§re als prim√§re Daten gespeichert sind, mussten Sie sie bei der Implementierung dieses Indexers l√∂schen und einen Befehl ausgeben, um sie erneut zu f√ºllen. Da sich das Projekt in der Entwicklung befindet, k√∂nnen wir Datenformate √§ndern und um neue Werte erweitern, d. H. Der Index muss st√§ndig aktualisiert werden. Es wird mit dem Inhalt des Ereignisjournals Akka aufgef√ºllt, das in der Microsoft SQL Server-Datenbank gespeichert ist. Sowohl zuvor gespeicherte Ereignisse als auch Echtzeitereignisse sollten im aktuellen Bedienfeld angezeigt werden.</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> EventJournal ( Ordering <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PersistenceID <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, SequenceNr <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Timestamp</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, IsDeleted <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, Manifest <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">500</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, Payload VARBINARY(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, Tags <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> QU_EventJournal <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> (PersistenceID, SequenceNr) )</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dies zu erreichen, m√ºssen wir einerseits die Daten aus SQL Server neu schreiben, der einige persistente Akteure des Eventstores enth√§lt. Akka, eventJournal. Das Bild zeigt einen typischen Eventstore. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cae/28e/b8e/cae28eb8efd64485e534c63d90550ce2.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andererseits kommen die Daten in Echtzeit. Und es stellt sich heraus, dass wir zum Schreiben eines Index Daten aus der Datenbank lesen m√ºssen und Echtzeitdaten eintreffen, und irgendwann m√ºssen wir verstehen: Hier endeten die Daten von hier, das ist neu. Dieser Grenzmoment erfordert eine zus√§tzliche √úberpr√ºfung, um nichts zu verlieren und nichts zweimal aufzuzeichnen. Das hei√üt, es stellte sich irgendwie ziemlich kompliziert heraus. Mein Kollege und ich waren nicht zufrieden mit dem, was los war. Es ist kein so komplexer Code, nur ziemlich trostlos. Bis wir uns daran erinnerten, dass persistente Akteure in Akka die Persistenzabfrage unterst√ºtzen.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b2/bb9/08b/6b2bb908be095a552de279cbefad7f1b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist nur die M√∂glichkeit, sie in Form eines √ºber der Quelle abstrahierten Datenstroms abzurufen, sie stammen aus der Datenbank oder werden in Echtzeit abgerufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integrierte Abfragen (Persistenzabfragen):</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Allpersistencelds </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CurrentPersistencelds </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EventsByPersistenceld </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CurrentEventsByPersistenceld </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EventsByTag </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CurrentEventsByTag </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und es gibt eine Reihe von Methoden, die wir verwenden k√∂nnen, zum Beispiel die Current-Methode - dies ist eine Momentaufnahme, Daten historisch bis zu einem bestimmten Zeitpunkt. </font><font style="vertical-align: inherit;">Und ohne dieses Pr√§fix zuerst und einschlie√ülich realer. </font><font style="vertical-align: inherit;">Wir brauchten EventsByTag.</font></font><br><br><pre> <code class="hljs kotlin">let system = mailbox.Context.System let queries = PersistenceQuery.Get(system) .ReadJournalFor&lt;SqlReadJournal&gt;(SqlReadJournal.Identifier) let mat = ActorMaterializer.Create(system) let offset = getCurrentOffset client config let ks = KillSwitches.Shared <span class="hljs-string"><span class="hljs-string">"persistence-elastic"</span></span> let task = queries.EventsByTag(PersistenceUtils.anyEventTag, offset) .Select(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> e -&gt; ElasticTypes.EventEnvelope.FromAkka e) .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GroupedWithin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config.BatchSize, config.BatchTimeout)</span></span></span></span> .Via(ks.Flow()) .RunForeach((<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> batch -&gt; processItems client batch), mat) .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContinueWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(handleStreamError mailbox, TaskContinuationOptions.OnlyOnFaulted)</span></span></span></span> |&gt; Async.AwaitTaskVoid</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und es stellte sich heraus, dass wir genug Code hatten. </font><font style="vertical-align: inherit;">Es wurde in F # geschrieben, aber in C # war es ungef√§hr der gleiche Kompakt. </font><font style="vertical-align: inherit;">Wir erhalten EventsByTag, verwenden integrierte Akka Streams-Bl√∂cke und daraus erhalten wir die Daten, die wir in Elasticsearch unterst√ºtzen. </font><font style="vertical-align: inherit;">Das hei√üt, wir haben die Implementierung des Datenstroms durch eine andere Person ausgenutzt, sodass wir vergessen konnten, wo sich unsere Daten befinden, woher sie stammen - aus der Datenbank oder in Echtzeit. </font><font style="vertical-align: inherit;">Diese Implementierung gab uns all dies mit einer einzigen Anfrage.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber hier waren wir Verbraucher dieser Daten. </font><font style="vertical-align: inherit;">Wenn wir solche Daten selbst erstellen m√∂chten, wird das Beispiel interessanter und wir betrachten es anhand realer Daten, da Twitter einer der Initiatoren dieser Spezifikation war und Tweets f√ºr jeden zug√§nglich sind, den wir alle verstehen . </font><font style="vertical-align: inherit;">Dies ist ein Standardbeispiel f√ºr die Funktionsweise von Akka Streams.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implementierungsbeispiel: Jet Tweets </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt ein Beispiel f√ºr Akka f√ºr Scala, f√ºr Akka.NET, aber ich fand diese Beispiele unzureichend, da sie ein spezifisches Beispiel daf√ºr zeigen, wie Daten herausgezogen werden und was damit gemacht wird, aber ich wollte eine allm√§hliche Komplikation betrachten, dh mit einem einfachen Stream beginnen und f√ºgen Sie weiterhin einige neue Designs hinzu. </font><font style="vertical-align: inherit;">Zu diesem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweck verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir die </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Tweetinvi-</font></a><font style="vertical-align: inherit;"> Bibliothek </font><font style="vertical-align: inherit;">- dies ist eine Open-Source-Bibliothek, die Daten von Twitter bereitstellt und lediglich die Ausgabe von Daten in Form eines Streams unterst√ºtzt. </font><font style="vertical-align: inherit;">Dieser Stream entspricht nicht der Spezifikation f√ºr reaktive Streams, das hei√üt, wir k√∂nnen ihn nicht sofort √ºbernehmen, aber er ist sogar gut, da wir damit zeigen k√∂nnen, wie wir mit allgemein primitivem Akka unseren eigenen Stream basierend darauf schreiben k√∂nnen diese Spezifikation erf√ºllt.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/acf/ac1/103/acfac11035eee1b69f2eb4c148f2f7f4.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir eine bestimmte Quelle von Tweets, die wir in zwei Kan√§le parallelisieren, d. H. Dies ist ein Broadcast-Grundelement. </font><font style="vertical-align: inherit;">Im ersten Kanal formatieren wir einfach die Tweets, w√§hlen den Namen des Autors des Tweets aus und mischen sie dann mit den Daten des zweiten Kanals. </font><font style="vertical-align: inherit;">Und im zweiten Kanal werden wir etwas Komplizierteres tun: Wir werden die Bandbreite dieses Streams begrenzen, dann die Tweet-Daten an den Stellen, an denen diese Tweets geschrieben wurden, mit Wetterdaten erweitern, alles mit der Temperatur formatieren, mit dem ersten Kanal mischen und alles auf dem Bildschirm drucken. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All dies befindet sich in meinem GitHub-Konto in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AkkaStreamsDemo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">√ñffnen Sie </font><font style="vertical-align: inherit;">und sehen (oder kann beobachten Post starten Sie </font><font style="vertical-align: inherit;">den Report </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von diesem Moment</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br>  Beginnen wir mit einem einfachen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zun√§chst m√∂chte ich Daten von Twitter direkt lesen: in der Datei Program.cs </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> useCachedTweets = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falls ich von Twitter gebannt werde, habe ich Tweets zwischengespeichert, sie sind schneller. </font><font style="vertical-align: inherit;">Zu Beginn erstellen wir RunnableGraph.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IRunnableGraph&lt;IActorRef&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRunnableGraph</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tweetSource = Source.ActorRef&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, OverflowStrategy.DropHead); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatFlow = Flow.Create&lt;ITweet&gt;().Select(Utils.FormatTweet); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> writeSink = Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(Console.WriteLine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tweetSource.Via(formatFlow).To(writeSink); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben hier eine Quelle f√ºr Tweets, die von einem Schauspieler stammt. </font><font style="vertical-align: inherit;">Ich werde Ihnen zeigen, wie wir diese Tweets dort abrufen, formatieren (das Tweet-Format gibt dem Autor nur einen Tweet) und ihn dann auf den Bildschirm schreiben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StartTweetStream - hier verwenden wir die Tweetinvi-Bibliothek.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartTweetStream</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IActorRef actor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stream = Stream.CreateSampleStream(); stream.TweetReceived += (_, arg) =&gt; { arg.Tweet.Text = arg.Tweet.Text.Replace(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>).Replace(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> json = JsonConvert.SerializeObject(arg.Tweet); File.AppendAllText(<span class="hljs-string"><span class="hljs-string">"tweets.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{json}</span></span></span><span class="hljs-string">\r\n"</span></span>); actor.Tell(arg.Tweet); }; stream.StartStream(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úber CreateSampleStream erhalten wir Beispiel-Tweets, die mit einer nicht sehr hohen Geschwindigkeit ausgegeben werden. Aus all dem w√§hlen wir aus, was wir brauchen, und erstellen einen Schauspieler, der sagt: "Akzeptiere diesen Tweet." Als n√§chstes m√ºssen wir IEnumerable bekommen, damit wir am Ende die Quelle bekommen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TweetEnumerator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sieht sehr einfach aus: Wir haben eine Sammlung von Tweets und m√ºssen Current, MoveNext, Reset und Dispose implementieren, um gute B√ºrger zu sein. Wenn wir dies ausf√ºhren, sehen wir ein Echtzeitbeispiel. Es wird viel nicht gedruckt, da es aus verschiedenen nicht-lateinischen L√§ndern stammt. Dies ist die einfachste Version unseres Programms.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt √§ndern wir den Wert von useCachedTweets in true, und hier beginnen die Komplikationen. CashedTweets ist das gleiche, nur habe ich dort eine Datei mit 50.000 Tweets, die ich bereits ausgew√§hlt, gespeichert habe, wir werden sie verwenden. Ich habe versucht, Tweets auszuw√§hlen, die Daten zu den geografischen Koordinaten ihrer Autoren enthalten, die wir ben√∂tigen werden. Der n√§chste Schritt ist, dass wir die Tweets parallelisieren wollen. Nach der Ausf√ºhrung haben wir zuerst den Besitzer des Tweets in der Liste und dann die Koordinaten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TweetsWithBroadcast:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(b =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> broadcast = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.CreatedBy)) .Via(formatUser) .To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.Coordinates)) .Via(formatCoordinates) .To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;ITweet, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(broadcast.In, merge.Out); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es Scala w√§re, w√ºrde es wirklich wie ein grafisches DSL aussehen. </font><font style="vertical-align: inherit;">Hier erstellen wir Broadcast mit zwei Kan√§len - out (0), out (1) - und in einem Fall drucken wir CreatedBy, in dem anderen drucken wir die Koordinaten, dann mischen wir alles und senden es an den Bestand. </font><font style="vertical-align: inherit;">Auch vorerst einfach genug. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der n√§chste Schritt in unserer Demo besteht darin, die Dinge etwas zu komplizieren. </font><font style="vertical-align: inherit;">Beginnen wir mit der √Ñnderung der Bandbreite.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(b =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> broadcast = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.CreatedBy) .Throttle(<span class="hljs-number"><span class="hljs-number">10</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, ThrottleMode.Shaping)) .Via(formatUser) .To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.Coordinates) .Buffer(<span class="hljs-number"><span class="hljs-number">10</span></span>, OverflowStrategy.DropNew) .Throttle(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>, ThrottleMode.Shaping)) .Via(formatCoordinates) .To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;ITweet, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(broadcast.In, merge.Out); });}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im ersten Kanal haben wir eine Bandbreitenbeschr√§nkung von bis zu 10 Tweets pro Sekunde, im zweiten Kanal haben wir bis zu einem Tweet pro Sekunde mit einem Puffer von 10. Wenn wir den Puffer angeben, m√ºssen wir die Strategie angeben, was zu tun ist, wenn der Puffer voll ist. Dies unterscheidet √ºbrigens Akka Streams und Reactive Streams im Allgemeinen: Die Wahl dieser Strategie ist ein Muss. In vielen F√§llen wissen wir bei der Arbeit mit Threads nicht, was passieren wird, wenn bei uns etwas √ºberl√§uft. Hier k√∂nnen wir zum Beispiel ausw√§hlen, ob dies kritische Daten sind, dann kann der gesamte Stream eine Fehlermeldung geben und enden. Sie k√∂nnen die neuesten Daten entfernen, Sie k√∂nnen beginnen, Daten vom Ende zu entfernen. Dies ist unsere Wahl, aber es ist ein bestimmter Vertrag, den wir hier abschlie√üen. Hier ist es in Buffer (10, OverFlowStrategy.DropHead). Wenn wir dieses Programm jetzt ausf√ºhren,Wir erhalten Tweets dieser Kan√§le mit unterschiedlichen Geschwindigkeiten. Wir haben hier ungef√§hr 10 Tweets mit dem Namen des Besitzers, einen Tweet mit der Koordinate, da wir eine solche Bandbreite eingestellt haben. Nat√ºrlich m√∂chte ich etwas mit den Koordinaten tun, n√§mlich Sie k√∂nnen versuchen, sie auf einen Dienst hochzuladen, der uns beispielsweise Aufschluss dar√ºber gibt, wie das Wetter ist, d. H. In welcher Stimmung der Tweet-Autor je nach Wetter war. Sehen Sie, wie einfach die Implementierung jetzt sein wird.In welcher Stimmung war der Autor des Tweets je nach Wetterlage? Sehen Sie, wie einfach die Implementierung jetzt sein wird.In welcher Stimmung war der Autor des Tweets je nach Wetterlage? Sehen Sie, wie einfach die Implementierung jetzt sein wird.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(b =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> broadcast = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.CreatedBy) .Throttle(<span class="hljs-number"><span class="hljs-number">10</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, ThrottleMode.Shaping)) .Via(formatUser) .To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.Coordinates) .Buffer(<span class="hljs-number"><span class="hljs-number">10</span></span>, OverflowStrategy.DropNew) .Throttle(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>, ThrottleMode.Shaping)) .Via(Flow.Create&lt;ICoordinates&gt;().SelectAsync(<span class="hljs-number"><span class="hljs-number">5</span></span>, Utils.GetWeatherAsync)) .Via(formatTemperature) .To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;ITweet, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(broadcast.In, merge.Out); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier haben wir den zweiten Kanal, SelectAsync, in dem wir das Wetter erhalten. Wir senden dies nicht nur an den Wetterlieferdienst, wir sagen auch, dass dieser Code mit einer Parallelisierungsstufe von 5 ausgef√ºhrt wird: Dies bedeutet, dass 5 parallele Threads erstellt werden, wenn dieser Dienst langsam genug ist, in dem dieser Dienst das Wetter anfordert. Der Dienst selbst ist hier implementiert, es ist auch sinnvoll zu zeigen, wie einfach dieser Code aussieht.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWeatherAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ICoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestUrl = <span class="hljs-string"><span class="hljs-string">$"http://api.met.no/weatherapi/locationforecast/1.9/?lat=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{coordinates.Latitude}</span></span></span><span class="hljs-string">;lon=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{coordinates.Latitude}</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> httpClient.GetStringAsync(requestUrl); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doc = XDocument.Parse(result); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = doc.Root.Descendants(<span class="hljs-string"><span class="hljs-string">"temperature"</span></span>).First().Attribute(<span class="hljs-string"><span class="hljs-string">"value"</span></span>).Value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>.Parse(temp); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) Hier ist </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alles ganz einfach. Ich habe den ersten Webdienst gefunden, der das aktuelle Wetter anhand von Koordinaten anzeigt. Es war eine Art norwegischer Meteo-Anbieter. Es handelt sich lediglich um eine Anfrage, die hier √ºber HttpClient gesendet wurde, und Wetterdaten k√∂nnen aus dem XML extrahiert werden, das ich erhalte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jetzt </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsere Demonstration durchf√ºhren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und dieser Dienst jetzt aktiviert ist, werden die Temperaturdaten zu sp√§t angezeigt. Ungef√§hr einmal in 10 Tweets haben wir 10 Nachrichten mit dem Namen des Besitzers, und sobald wir die Temperatur in Grad Celsius erhalten, wurde der Tweet geschrieben.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist beeindruckend genug, wie einfach es ist, einen solchen Prozess zu beschreiben, einschlie√ülich der Angabe des Parallelit√§tsgrades. </font><font style="vertical-align: inherit;">Dies sind nur einige der Bl√∂cke, die in Akka Streams verwendet werden k√∂nnen. Ich habe bereits gesagt, dass es viele davon gibt. </font><font style="vertical-align: inherit;">Die Chancen, dass Sie viele davon nutzen k√∂nnen, sind sehr hoch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ich das Schauspielermodell verwenden w√ºrde, wahrscheinlich vor einem Jahr, als ich mit Akka Streams nicht vertraut war, w√ºrde ich jeden Schauspieler daf√ºr separat schreiben. </font><font style="vertical-align: inherit;">Wie Sie sehen, m√ºssen Sie nicht f√ºr jeden Pr√ºfpunkt Code schreiben. All dies kann mit Akka Streams-Tools durchgef√ºhrt werden. Insgesamt sind in C # mehrere zehn Codezeilen erforderlich, sodass wir unsere Kontrolle und unsere Aufmerksamkeit auf eine h√∂here Ebene der Prozessorganisation konzentrieren k√∂nnen. und nicht auf den Mikrodetails, den Innenseiten des Datenstroms.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Letzte √úberlegungen </font></font></h1><br><img src="https://habrastorage.org/getpro/habr/post_images/17a/f2f/c2b/17af2fc2bfbacfc95fbe5bc9504a346e.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welche Ideen zu Akka Streams m√∂chte ich, dass Sie sich nach dem Lesen dieses Artikels selbst machen? Auf der DotNext 2017 in Moskau war ich auf einer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√§sentation von Alex Thyssen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informationen zu Azure-Funktionen. In gewissem Sinne ist dies eine √Ñnderung in der Idee, wie Code f√ºr die Bereitstellung geschrieben werden soll. Anstatt uns auf die Konfiguration von Maschinen zu konzentrieren, installieren wir solche Programme auf dieser Maschine, die mit diesen Diensten kommunizieren und diese Daten empfangen. Wir konzentrieren uns direkt auf den Funktionsteil und diesen Funktionshelm in die Cloud. Wir denken nicht genau dar√ºber nach, welche Maschinenknoten diesen Code ausf√ºhren, sondern dar√ºber, wie unsere Funktionen miteinander kooperieren sollen. Eine √§hnliche Analogie kann zwischen einem System gezogen werden, das unter Verwendung von Akteursmodellen, jedoch manuell, und Akka-Streams geschrieben wurde, d. H. Wir vergessen, wie man Schauspieler manuell schreibt und konzentrieren uns stattdessen auf die gesamte Prozessbeschreibung.In einem wesentlichen Teil der Szenarien schaffen wir es, auf einem relativ hohen Niveau zu bleiben und gleichzeitig die Skalierbarkeit und Systemleistung aufrechtzuerhalten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Akka Streams nicht die einzige Alternative f√ºr diesen Ansatz ist, sollten Sie sich √ºberlegen, ob Sie eine Ebene h√∂her gehen k√∂nnen, wenn Sie √ºberlegen, wie Sie Ihren Prozess simulieren k√∂nnen. Bei all den Vorteilen, die Microservices uns gegen√ºber dem monolithischen Ansatz bieten, gibt es gewisse Bedenken, dass wir uns zu sehr auf Microservices konzentrieren, Mikrotasks erhalten und bei alledem nicht den gesamten Wald sehen. Und jetzt ist Akka Streams ein Weg, ohne zur monolithischen Ebene zur√ºckzukehren und dennoch zur Ebene der allgemeinen Idee des Prozesses zur√ºckzukehren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich habe ich f√ºr Sie ein kleines Lied, das √ºber einige der eingebauten Akka Streams-Bl√∂cke spricht und "Akka Stream Rap" hei√üt. Es </font><font style="vertical-align: inherit;">gibt W√∂rter </font><font style="vertical-align: inherit;">unter dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Sie k√∂nnen es einschalten und mitsingen.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1Ct3eIQ0Tgc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><blockquote> <i>This is the Akka Stream. <br><br> This is the Source that feeds the Akka Stream. <br><br> This is the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Streams. <br><br> This is the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is TakeWhile that pulls from the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Throttle that speeds down the TakeWhile that pulls from the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Bidiflow that turns back the Throttle that speeds down the TakeWhile that pulls from the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the source that feeds the Akka Streams. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist die Senke, die aus dem Bidiflow gef√ºllt wird, der die Drossel zur√ºckdreht, die das TakeWhile zur√ºckdreht, das aus dem Drop gezogen wird, der aus dem Zip entfernt wird, der aus dem Gleichgewicht entfernt wird, das den FilterNot teilt, der aus der Zusammenf√ºhrung ausw√§hlt, die aus dem Broadcast gesammelt wird Gabelt den MapAsync, der von der Quelle abgebildet wird, die den Akka-Stream speist.</font></font></i> </blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minute der Werbung. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Ihnen der Bericht gefallen hat und Sie noch etwas √Ñhnliches w√ºnschen, findet vom 22. bis 23. November die n√§chste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Moskau statt </font><font style="vertical-align: inherit;">, die f√ºr Sie dort m√∂glicherweise nicht weniger interessant ist. </font><font style="vertical-align: inherit;">Beeilen Sie sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um Tickets</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zum Juli-Preis zu erhalten (ab dem 1. August steigen die Ticketkosten).</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418639/">https://habr.com/ru/post/de418639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418629/index.html">So √ºberpr√ºfen Sie unabh√§ngig, ob Sie Ihr Produkt patentieren und eine Patentrecherche durchf√ºhren k√∂nnen</a></li>
<li><a href="../de418631/index.html">7 Richtlinien f√ºr Javascript-Code</a></li>
<li><a href="../de418633/index.html">JavaScript-Reaktivit√§t: Ein einfaches und intuitives Beispiel</a></li>
<li><a href="../de418635/index.html">Erstellen eines Emulator-Arcade-Automaten. Teil 1</a></li>
<li><a href="../de418637/index.html">Kubernetes an die Massen: Slurm startet am 3. August</a></li>
<li><a href="../de418641/index.html">Ein Fehler, der einen Designer davon abh√§lt, zu wachsen</a></li>
<li><a href="../de418643/index.html">Sitzen gegen Stehen: Wie kann man besser arbeiten?</a></li>
<li><a href="../de418645/index.html">Beitr√§ge von der Fr√ºhjahrskonferenz C ++ Russia 2018</a></li>
<li><a href="../de418647/index.html">TESS startet die Exoplaneten-Suche</a></li>
<li><a href="../de418649/index.html">Die kontinuierliche Generierung alternativer Versionen von TLS wird das Problem der Ossifikation des alten Protokolls l√∂sen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>