<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏽 🧘 💀 Estamos escribiendo un cliente http de alto rendimiento usando fasthttp como ejemplo. Alexander Valyalkin (VertaMedia) 👨🏽‍🚀 👩🏽‍🔧 🛀🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La biblioteca Fasthttp es una alternativa acelerada a net / http de los paquetes estándar de Golang. 
 ¿Cómo se arregla? ¿Por qué es tan rápida? 


 T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estamos escribiendo un cliente http de alto rendimiento usando fasthttp como ejemplo. Alexander Valyalkin (VertaMedia)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443378/"><p>  La biblioteca Fasthttp es una alternativa acelerada a net / http de los paquetes estándar de Golang. <br>  ¿Cómo se arregla?  ¿Por qué es tan rápida? </p><br><p>  Traigo a su atención una transcripción del informe de los clientes internos de Alexander Valyalkin Fasthttp. <br>  Los patrones Fasthttp se pueden usar para acelerar sus aplicaciones, su código. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/fg3JPUswiek" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  A quién le importa, bienvenido al gato. </p><a name="habracut"></a><br><p>  Soy Alexander Valyalkin  Yo trabajo en VertaMedia.  Desarrollé fasthttp para nuestras necesidades.  Incluye la implementación del cliente http y el servidor http.  Fasthttp es mucho más rápido que net / http de los paquetes Go estándar. </p><br><p><img src="https://habrastorage.org/webt/mw/xn/qb/mwxnqbi-ufmc9agmni-so-gy-ls.png"></p><br><p>  Fasthttp es una implementación rápida del servidor http y el cliente.  Ubicado fasthttp en github.com </p><br><p><img src="https://habrastorage.org/webt/ve/vz/07/vevz07ucp1l6ou4pg8zp2kuhvzu.png"></p><br><p>  Creo que muchos han escuchado sobre el servidor fasthttp, que es muy rápido.  Pero pocos han oído hablar del cliente fasthttp.  El servidor Fasthttp participa en el benchmark de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">techempower</a> , el famoso benchmark en círculos estrechos para servidores http.  El servidor Fasthttp participa en las rondas 12 y 13.  La ronda 13 aún no ha salido (en 2016 - aprox. Ed.). </p><br><p><img src="https://habrastorage.org/webt/ow/t8/hv/owt8hvhbrxpvfxihc1golxlgp-y.png"></p><br><p>  Los resultados de una de las pruebas de la ronda 12, donde fasthttp está casi en la cima.  Los números muestran cuántas consultas hace por segundo en esta prueba.  En esta prueba, se realiza una solicitud para una página que devuelve hello world.  En hello world fasthttp es muy rápido. </p><br><p><img src="https://habrastorage.org/webt/tk/h8/1t/tkh81tfzy0ee5jt0poqw_gxmv-e.png"></p><br><p>  Resultados preliminares de la próxima ronda, que aún no se ha publicado (en 2016 - aprox. Ed.).  4 implementaciones fasthttp ocupan el primer lugar en el punto de referencia, que no solo regala hello world, sino que también se arrastra a la base de datos y forma una página html basada en la plantilla. </p><br><p><img src="https://habrastorage.org/webt/lj/h1/ov/ljh1ovyrxst7hzjjgd16yk4tbmo.png"></p><br><p>  Muy pocas personas saben sobre el cliente fasthttp.  Pero en realidad también es genial.  En este informe, le contaré sobre el dispositivo interno fasthttp client y por qué fue desarrollado. </p><br><p><img src="https://habrastorage.org/webt/z6/rp/az/z6rpazy3l_asbpcbaklgdo8mnkq.png"></p><br><p>  En realidad, hay varios clientes en fasthttp: Client, HostClient y PipelineClient.  Además, te contaré más sobre cada uno de ellos. </p><br><p><img src="https://habrastorage.org/webt/vs/ok/5u/vsok5umamlhuly1-gcfdewuxybu.png"></p><br><p>  Fasthttp.Client es un cliente http de uso general regular.  Con él, puede realizar solicitudes a cualquier sitio de Internet, recibir respuestas.  Sus características: funciona rápidamente, puede limitar la cantidad de conexiones abiertas por host, a diferencia del paquete net / http.  La documentación está en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://godoc.org/github.com/valyala/fast">https://godoc.org/github.com/valyala/fasthttp#Client</a> . </p><br><p><img src="https://habrastorage.org/webt/r0/il/cc/r0ilcc3iwd6acpv1pqbawqxvfc4.png"></p><br><p>  Fasthttp.HostClient es un cliente especializado para comunicarse con un solo servidor.  Por lo general, se utiliza para acceder a la API HTTP: API REST, API JSON.  También se puede usar para proxy del tráfico de Internet a un DataCenter interno en varios servidores.  La documentación está aquí: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://godoc.org/github.com/valyala/fast">https://godoc.org/github.com/valyala/fasthttp#HostClient</a> . </p><br><p>  Al igual que Fasthttp.Client, Fasthttp.HostClient puede limitar el número de conexiones abiertas a cada uno de los servidores Backend.  Esta funcionalidad está ausente en net / http, y también esta función está ausente en nginx gratis.  Esta funcionalidad es solo en nginx pagado, que yo sepa. </p><br><p><img src="https://habrastorage.org/webt/sn/ys/ep/snysephpvj2u3itk5icip242ima.png"></p><br><p>  Fasthttp.PipelineClient es un cliente especializado que le permite administrar solicitudes de canalización a un servidor o a un número limitado de servidores.  Se puede utilizar para acceder a la API, a través del protocolo HTTP, donde necesita realizar muchas solicitudes y lo más rápido posible.  La limitación de Fasthttp.PipelineClient es que puede sufrir el bloqueo de Head of Line.  Esto es cuando enviamos muchas solicitudes al servidor y no esperamos una respuesta a cada solicitud.  El servidor está bloqueado en una de estas solicitudes.  Debido a esto, todas las demás solicitudes que lo siguieron esperarán hasta que este servidor procese una solicitud lenta.  Fasthttp.PipelineClient debe usarse solo si está seguro de que el servidor responderá instantáneamente a sus solicitudes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://godoc.org/github.com/valyala/fast">Documentación</a> </p><br><p><img src="https://habrastorage.org/webt/9b/sa/z2/9bsaz297eqozr0ckcwrlbmefdqk.png"></p><br><p>  Ahora comenzaré a hablar sobre la implementación interna de cada uno de estos clientes.  Comenzaré con Fasthttp.HostClient, porque casi todos los demás clientes se crean sobre la base. </p><br><p><img src="https://habrastorage.org/webt/zm/vq/rt/zmvqrtpi1eogjgjqmlnvxbjh7ca.png"></p><br><p>  Esta es la implementación más simple del cliente HTTP en pseudocódigo en Go.  Estamos conectados, recibimos una respuesta http en esta URL.  Nos estamos conectando a este host.  Tenemos conexión  En este código, para que sea menor que el volumen, faltan todas las comprobaciones de errores.  De hecho, esto no es así.  Siempre debe verificar si hay errores.  Crea una conexión.  Conexión cercana con aplazar.  Enviamos una solicitud de esta conexión por URL.  Recibimos la respuesta, devolvemos esta respuesta.  ¿Qué hay de malo con esta implementación de HTTP Client? </p><br><p><img src="https://habrastorage.org/webt/ev/lq/q4/evlqq4u3y3qbzr_agvrnmknzdee.png"></p><br><p>  El primer problema es que en esta implementación, se establece una conexión para cada solicitud.  Esta implementación no es compatible con HTTP KeepAlive.  ¿Cómo resolver este problema?  Puede usar el Pool de conexiones para cada servidor.  No puede usar el Pool de conexiones para todos los servidores, porque la siguiente solicitud no está clara a qué servidor enviar.  Cada servidor debe tener su propio grupo de conexiones.  Y usamos HTTP KeepAlive.  Esto significa que Connection Header no necesita especificar Connection Close.  En HTTP / 1.1, de forma predeterminada, existe soporte para HTTP KeepAlive y Connection Close debe eliminarse del encabezado.  Aquí está la implementación en pseudocódigo del cliente con soporte de Connection Pool.  Hay un conjunto de varios grupos de conexiones para cada host.  La primera función, connPoolForHost, devuelve el Pool de conexiones para un host determinado desde una URL determinada.  Luego obtenemos la conexión de este Pool de conexiones, planeamos usar Defer para enviar esta conexión de regreso al Pool, enviar una solicitud KeepAlive para esta conexión y devolver una respuesta.  Después de la respuesta, se ejecuta Defer y la conexión vuelve al Pool.  Por lo tanto, habilitamos el soporte HTTP KeepAlive y todo comienza a funcionar más rápido.  Porque no perdemos tiempo creando una conexión para cada solicitud. </p><br><p>  Pero la solución también tiene problemas.  Si observa la firma de la función, puede ver que devuelve un objeto de respuesta para cada solicitud.  Esto significa que para este objeto necesita asignar memoria cada vez, inicializarlo y devolverlo.  Esto es malo para el rendimiento.  Puede ser malo si tiene muchas de esas llamadas para obtener funciones. </p><br><p><img src="https://habrastorage.org/webt/jb/yq/rr/jbyqrrzhu_qusd9j9ocba8m0czk.png"></p><br><p>  Por lo tanto, este problema puede resolverse como se resuelve en Fasthttp colocando el objeto puntero en el objeto de respuesta en los parámetros de esta función.  De esa manera, ese código de llamada puede reutilizar este objeto de respuesta muchas veces.  En la diapositiva está la implementación de esta idea.  Pasamos una referencia al objeto de respuesta a la función Get, y la función llena esta respuesta.  La última línea llena este objeto. </p><br><p><img src="https://habrastorage.org/webt/bm/z7/rq/bmz7rqtnowb5dreyup6c-er_tq0.png"></p><br><p>  Así es como podría verse en su código.  Una función que acepta un canal al que se le pasa una lista de URL para sondear.  Organizaremos un ciclo en este canal.  Creamos un objeto de respuesta una vez y lo reutilizamos en un bucle.  Llame a Get, pase un puntero al objeto, procese esta respuesta.  Después de haberlo procesado, lo restablecemos a su estado original.  De esta manera evitamos la asignación de memoria y aceleramos nuestro código. </p><br><p><img src="https://habrastorage.org/webt/ok/2t/5z/ok2t5zsghgoxj7ruc2z_1hhcagu.png"></p><br><p>  El tercer problema es la conexión cercana.  Conexión cerrada: encabezado HTTP, que se puede encontrar tanto en la solicitud como en la respuesta.  Si tenemos ese encabezado, entonces esta conexión debería cerrarse.  Por lo tanto, en la implementación del cliente, es imprescindible proporcionar un cierre de conexión.  Si envió una solicitud con el encabezado Cerrar conexión, luego de recibir la respuesta, debe cerrar esta conexión.  Si envió una solicitud sin Cerrar conexión y devolvió una respuesta con Cerrar conexión, también debe cerrar esta conexión después de recibir una respuesta. </p><br><p><img src="https://habrastorage.org/webt/bc/ve/up/bcveuplhhdifuc0malg7f7bm2vw.png"></p><br><p>  Aquí está el pseudocódigo para esta implementación.  Después de recibir una respuesta, verificamos si los encabezados de cierre de conexión están instalados allí.  Si está instalado, simplemente cierre la conexión.  Si no está instalado, regrese la conexión al grupo.  Si no se hace esto, entonces si el servidor cierra la conexión después de que devuelve las respuestas, su grupo de conexiones contendrá la conexión interrumpida que cerró el servidor, e intentará escribir algo en ellas y obtendrá errores. </p><br><p><img src="https://habrastorage.org/webt/wi/ms/gh/wimsghjdbpnjilbkgmvw5cryrvg.png"></p><br><p>  El cuarto problema al que están expuestos los clientes HTTP es servidores lentos o una red lenta e inactiva.  Los servidores pueden dejar de responder a sus solicitudes por varias razones.  Por ejemplo, el servidor está roto o la red entre su cliente y el servidor ha dejado de funcionar.  Debido a esto, todas sus rutinas que llaman a la función Obtener que se describió previamente serán bloqueadas, esperando una respuesta del servidor indefinidamente.  Por ejemplo, si implementa un proxy http que acepta una conexión entrante y llama a la función Get en cada conexión, se creará una gran cantidad de goroutines y todos se colgarán en su servidor hasta que el servidor falle, hasta que se agote la memoria. </p><br><p><img src="https://habrastorage.org/webt/cb/mq/1c/cbmq1c_b9ua-0ess-if8dfqkk0a.png"></p><br><p>  ¿Cómo resolver este problema?  Hay una decisión tan ingenua que se me viene a la mente: simplemente envuélvela en una rutina diferente.  Luego, en goroutine, pase un canal vacío, que se cerrará después de ejecutar Get.  Después de comenzar esta rutina, espere un momento en este canal (tiempo de espera).  En este caso, si pasa algún tiempo y este Get no se ejecuta, la salida de esta función se producirá por tiempo de espera.  Si se ejecuta este Get, el canal se cerrará y se producirá la salida.  Pero esta decisión es incorrecta, porque transfiere el problema de una cabeza enferma a una sana.  De todos modos, se crearán gorutinas y se suspenderán independientemente del tiempo de espera que use.  El número de goroutines que causó Get timeout será limitado, pero habrá un número ilimitado de goroutines que se crearán dentro de Get con un tiempo de espera. </p><br><p><img src="https://habrastorage.org/webt/yx/jx/nj/yxjxnjpdobdntdoel9119aqdgyo.png"></p><br><p>  ¿Cómo resolver este problema?  La primera solución es limitar el número de gorutinas bloqueadas en la función Obtener.  Esto se puede hacer usando un patrón tan conocido como el uso de un canal protegido de longitud limitada, que contará el número de goroutines que ejecutan la función Get.  Si esta cantidad de gorutina excede un cierto límite: la capacidad de este canal, saldremos a la rama predeterminada.  Esto significa que tenemos todas las rutinas que se realizan están ocupadas, y en la rama predeterminada solo necesitamos devolver Error, que no hay recursos libres.  Antes de crear goroutine, tratamos de escribir una estructura vacía en este canal.  Si esto no funciona, entonces hemos excedido la cantidad de gorutinas.  Si resultó, creamos este gorutin y después de ejecutar Get, leemos un valor de este canal.  Por lo tanto, limitamos la cantidad de goroutines que se pueden bloquear en Get. </p><br><p><img src="https://habrastorage.org/webt/w4/id/rr/w4idrrvfykc05ahmf_hrbyscwcs.png"></p><br><p>  La segunda solución, que complementa la primera, es establecer tiempos de espera en la conexión al servidor.  Esto desbloqueará la función get si el servidor no responde durante mucho tiempo o si la red está inactiva. </p><br><p>  Si la red no funciona en la Solución n. ° 1, entonces todo se bloqueará.  Después de escribir cuncurrency en un número limitado de goroutines que colgaban aquí, la función getimeout siempre devolverá un error.  Para que comience a funcionar normalmente, necesita una segunda solución (Solución # 2), que establece un tiempo de espera para leer y escribir desde la conexión.  Esto ayuda a desbloquear goroutines bloqueados si la red o el servidor dejan de funcionar. </p><br><p><img src="https://habrastorage.org/webt/yx/jx/nj/yxjxnjpdobdntdoel9119aqdgyo.png"></p><br><p>  La solución # 1 tiene una carrera de datos.  El objeto de respuesta desde el que se pasó el puntero se ocupará si se bloquea.  Pero esta función Obtener tiempo de espera puede expirar.  En este caso, salimos de esta función, una respuesta que se bloqueará y después de un tiempo se reescribirá.  Por lo tanto, se obtiene una carrera de datos.  Como tenemos respuesta después de salir de la función, todavía se usa en algún lugar de la rutina. </p><br><p>  El problema se resuelve creando una copia de respuesta y pasando la copia de respuesta a goroutine.  Después de completar Get, copie la respuesta de esta respuesta en nuestra respuesta original, que se pasa aquí.  Por lo tanto, la carrera de datos está resuelta.  Esta copia de la respuesta dura poco tiempo y regresa al grupo.  Reutilizamos la respuesta.  Es posible que una copia de respuesta no entre en el grupo solo por tiempo de espera.  Por tiempo de espera, hay una pérdida de respuesta del grupo. </p><br><p><img src="https://habrastorage.org/webt/sc/cm/ar/sccmar-ze8kukg1nm5csyxz2riy.png"></p><br><p>  ¿Necesito cerrar la conexión después de que el servidor no haya devuelto una respuesta dentro de un tiempo de espera?  La respuesta es no.  Más bien, sí, si desea hacer una copia de seguridad del servidor.  Porque cuando envía una solicitud al servidor, espere un momento, el servidor no responde durante este tiempo, no responde a las solicitudes.  Por ejemplo, cierra esta conexión, pero esto no significa que el servidor dejará de ejecutar esta solicitud de inmediato.  El servidor continuará ejecutándolo.  El servidor detectará que no es necesario ejecutar esta solicitud después de que intente devolverte una respuesta.  Cerró la conexión, intentó nuevamente crear una nueva solicitud, nuevamente pasó el tiempo de espera, volvió a cerrar, creó una nueva solicitud.  Tendrá una carga en el aumento del servidor.  Como resultado, su servicio depende de sus solicitudes.  Estos son DoS a nivel de solicitudes http.  Si tiene servidores que se ejecutan lentamente y no desea hacer una copia de seguridad de ellos, entonces no necesita cerrar la conexión después de un tiempo de espera.  Debe esperar un momento, dejar la conexión para expiar este servidor.  Deja que intente darte una respuesta.  Mientras tanto, use otras conexiones gratuitas.  Todo lo que se dijo antes de esto son todas las etapas de la implementación de Fasthttp.Client y los problemas que ocurrieron durante la implementación de Fasthttp.Client.  Estos problemas se resuelven en Fasthttp.HostClient. </p><br><p><img src="https://habrastorage.org/webt/ht/yz/uj/htyzujg6gqaycezv_ot4_xucb6w.png">  Ahora tenemos un cliente rápido?  En realidad no  Necesita ver cómo se implementa Connection Pool. </p><br><p><img src="https://habrastorage.org/webt/tk/rs/1u/tkrs1uhjy3nlqecg_j2payseg_i.png"></p><br><p>  La implementación ingenua de Connection Pool se ve así.  Hay algún tipo de dirección de servidor donde necesita instalar la conexión.  Hay una lista de conexiones libres y un bloqueo para sincronizar el acceso a esta lista. </p><br><p><img src="https://habrastorage.org/webt/zb/lk/j5/zblkj5q4hygyxgd9rmrzjx2nxpa.png"></p><br><p>  Aquí está la función para obtener la conexión del grupo de conexiones.  Estamos viendo una lista de nuestra colección.  Si hay algo allí, entonces obtenemos una conexión gratuita y la devolvemos.  Si no hay nada, cree una nueva conexión a este servidor y devuélvala.  ¿Qué está mal aquí? </p><br><p><img src="https://habrastorage.org/webt/lw/xz/7q/lwxz7qmhwkqv3tmu4mc5f0tfumi.png">  La función connPool.Put devuelve una conexión libre. </p><br><p>  En la cuenta de tiempo de espera.  En Fasthttp.Client, puede especificar la vida útil máxima de una conexión abierta no utilizada.  Una vez transcurrido este tiempo, las conexiones no utilizadas se cierran automáticamente y se eliminan de este grupo. </p><br><p>  Las conexiones más antiguas no se utilizan con el tiempo y se cierran y eliminan automáticamente del grupo. </p><br><p>  Cuando la conexión se toma del grupo, y resulta que su servidor estaba cerrado, e intentó escribir algo allí, se realiza un segundo intento: se obtiene una nueva conexión e intenta enviar nuevamente las solicitudes para esta conexión.  Pero esto es solo si esta solicitud es idempotente, es decir, una solicitud que se puede ejecutar muchas veces sin efectos secundarios en el servidor, es una solicitud GET o HEAD.  Por ejemplo, en el estándar net / http, justo ahora, agregamos una verificación para conexiones cerradas.  Allí hicieron un chequeo más complicado.  Comprueban, cuando intentan enviar una nueva solicitud a la conexión desde el grupo, si se envía al menos un byte a esta conexión.  Si se desactiva, entonces devuelve Error.  Si no se fue, tomamos una nueva conexión del grupo. </p><br><p><img src="https://habrastorage.org/webt/h2/ug/yv/h2ugyvjrfzht7gfwx2gemetfazy.png"></p><br><p>  ¿Qué hay de malo en la piscina?  Su tamaño no está limitado.  Misma implementación que en net / http.  Si escribe un cliente que está pasando de millones de gorutinas a un servidor lento, entonces el cliente intentará crear una conexión de millones a este servidor.  No hay límite en el número máximo de conexiones en el paquete estándar net / http.  Para el cliente que se utiliza para acceder a la API a través de HTTP, es aconsejable limitar el tamaño de este grupo de conexiones.  De lo contrario, sus clientes pueden fallar, ya que utilizará todos los recursos: hilos, objetos, conexión, rutinas y memoria.  Además, esto puede conducir a DoS de sus servidores, ya que se establecerá una gran cantidad de conexiones con ellos, que no se usan o se usan de manera ineficiente, porque el servidor no puede mantener tanta conexión. </p><br><p><img src="https://habrastorage.org/webt/km/zk/pn/kmzkpnls98apnqltus4tvoeeb5c.png"></p><br><p>  Limite el grupo de conexiones.  El código no está aquí, porque es demasiado grande para caber en una diapositiva.  Los interesados ​​pueden ver la implementación de esta función en github.com. </p><br><p><img src="https://habrastorage.org/webt/ub/1a/ko/ub1akoqexz4yoqyn3xogkcwveza.png"></p><br><p>  El segundo problema  Muchas solicitudes llegan al cliente en algún momento.  Y después de eso hay una disminución y un retorno al número anterior de solicitudes.  Por ejemplo, 10,000 solicitudes llegaron simultáneamente, luego el número de solicitudes regresó a 1000 por unidad de tiempo.  Después de eso, el grupo de conexiones crecerá a 10000 conexiones.  Estas conexiones colgarán allí sin cesar.  Este problema estaba en el cliente net / http estándar anterior a la versión 1.7.  Por lo tanto, debe resolver este problema. </p><br><p><img src="https://habrastorage.org/webt/dm/o1/w4/dmo1w4jixcnjjjaoznw8r7zz8bw.png"></p><br><p>  Este problema se resuelve limitando la vida de una conexión no utilizada.  Si durante algún tiempo no se envió una sola solicitud a través de la conexión, simplemente se cierra y se descarta del grupo.  No hay implementación porque es demasiado grande. </p><br><p><img src="https://habrastorage.org/webt/hs/wj/wx/hswjwxgrlyawxzj_t-mmdbxhh3m.png"></p><br><p>  ¿Tenemos un cliente que funciona rápido y genial?  Realmente no es así.  Todavía tenemos la función de crear conexión: dialHost. </p><br><p><img src="https://habrastorage.org/webt/cl/bs/jr/clbsjrbour6diwgkjri6jpdhnx8.png"></p><br><p>  Veamos su implementación.  Una implementación ingenua se ve así.  La dirección donde desea conectarse simplemente se transmite.  Llamamos a la función estándar net.Dial.  Ella devuelve la conexión.  ¿Qué hay de malo en esta implementación? </p><br><p><img src="https://habrastorage.org/webt/sm/b_/bc/smb_bcj41taldeo3mvnfl9ek-2g.png"></p><br><p>  Por defecto, net.Dial realiza una solicitud de DNS para cada llamada.  Esto puede conducir a un mayor uso de los recursos de su subsistema DNS.  Si los clientes API se conectan a servidores que no admiten conexiones KeepAlive, cierran las conexiones.  KeepAlive lo respalda y los servidores no.  Después de tal respuesta, el servidor cierra la conexión.  Resulta que se llama a net.Dial en cada solicitud.  Hay alrededor de 10 mil solicitudes de este tipo por segundo.  Tienes 10 mil veces por segundo que se resuelve en dns.  Esto carga el subsistema DNS. </p><br><p><img src="https://habrastorage.org/webt/2j/au/e6/2jaue6kkmfwaob6p9tu-5quhgei.png"></p><br><p>  ¿Cómo resolver este problema?  Cree un caché que mapee el host en IP por un corto tiempo directamente en su código Go, y no llame a dns resolviendo en cada red.  Conéctese a direcciones IP listas para usar. </p><br><p><img src="https://habrastorage.org/webt/eh/n2/j3/ehn2j3tfuse-43qoibyq5oqqcsu.png"></p><br><p>  El segundo problema es la carga desigual en el servidor si tiene varios servidores ocultos detrás del nombre de dominio.  Por ejemplo, como Round Robin DNS.  Si almacena en caché una dirección IP en DNS por un tiempo, durante este tiempo todas sus solicitudes irán a un servidor.  Aunque puede tener varios de ellos allí.  Es necesario resolver este problema.  Se resuelve enumerando todas las IP disponibles que están ocultas detrás de un nombre de dominio dado.  Esto también se hace en Fasthttp.Client. </p><br><p><img src="https://habrastorage.org/webt/wx/hb/6r/wxhb6r3hlt_wofv6o347jyvw_oo.png"></p><br><p>  El tercer problema es que net.Dial también puede colgar indefinidamente debido a problemas con la red o el servidor donde está intentando conectarse.  En este caso, sus gorutinas se colgarán de la función Obtener.  Esto también puede conducir a un mayor uso de los recursos. </p><br><p><img src="https://habrastorage.org/webt/jc/k3/id/jck3idzikb6vyzvsbcuckeg8wae.png">  La solución es agregar un tiempo de espera.   Dial     package net. ,   ,   . ,    ,      ,   . </p><br><p><img src="https://habrastorage.org/webt/cb/mq/1c/cbmq1c_b9ua-0ess-if8dfqkk0a.png"></p><br><p>     .  Get  Dial .    - .  Dial ,  ,   .   ,  ,   .    DialTimeout. ,   . </p><br><p><img src="https://habrastorage.org/webt/jo/tn/t0/jotnt0t9nwul2jx8sym4-kycfvu.png"></p><br><p>   HostClient   . </p><br><p> HostClient      ,   .     LoadBalance. </p><br><p>  HostClient    .          ,  HostClient        .   connection       .     .     . </p><br><p> Fauly host     . </p><br><p>   —        .   Dial.    ,     Dial. Get,  ,   - .   ,           .  ,       ,   . </p><br><p>   —      .   Get   ,   .     ,    ,  ,    . </p><br><p>   Error ,     Round Robin    . </p><br><p>  SSL   ,    Golang   .        . </p><br><p><img src="https://habrastorage.org/webt/py/wf/93/pywf93cfwemlknabq_iejxfgpt4.png"></p><br><p>   fasthttp.Client.           HostClient,   fasthttp.Client    HostClient. </p><br><p><img src="https://habrastorage.org/webt/0s/f8/mz/0sf8mzfxpk1nl5lucgjvwaqkgy8.png"></p><br><p>        Get.     HostClient    .      HostClient      .     HostClient   Get.       HostClient. </p><br><p><img src="https://habrastorage.org/webt/xd/nf/u8/xdnfu88duh8s5ibm0qx_riwe4go.png"></p><br><p>       HostClient  -  ,      URL.    web-crawling (  ),        .        HostClient       .      net/http,      .    ,    HostClient,      .   fasthttp. </p><br><p><img src="https://habrastorage.org/webt/r2/f7/bk/r2f7bkykq6m6oqcd3ylss9rwdr4.png"></p><br><p>    Client  HostClient,  PipelineClient   .  PipelineClient  connection pool.  PipelineClient    connection,     . PipelineClient         connection.     connection pool. PipelineClient   connection       . </p><br><p><img src="https://habrastorage.org/webt/lj/vw/ew/ljvwewxdpm8ag50y-tcfzthrxia.png"></p><br><p>  PipelineClient   connection   . PipelineConnClient.writer —    connection,   . PipelineConnClient.reader —     connection     ,     PipelineConnClient.writer. PipelineConnClient.reader   ,     Get. </p><br><p><img src="https://habrastorage.org/webt/nj/9q/lp/nj9qlpw3mexynplnky52vvhcar4.png"></p><br><p>      PipelineClient.Get  PipelineClient.   pipelineWork  url,    ,    response,  channel done,     response. </p><br><p>     Get. C   .    channel,   PipelineConnClient.writer      connection.   channel w.done,   PipelineConnClient.reader,   response   request. </p><br><p><img src="https://habrastorage.org/webt/s4/vf/oq/s4vfoqg_mmutotfdw66gs4nbxvs.png"></p><br><p>   net/http   fasthttp.Client   2 . </p><br><p><img src="https://habrastorage.org/webt/ah/ra/-o/ahra-oaf0uydcje9yqofoh6l-6k.png"></p><br><p> ,     ,   fasthttp.     , , .    fasthttp. ,      fasthttp,          .    allocation  .         . </p><br><p><img src="https://habrastorage.org/webt/q6/c3/ss/q6c3ss7kpmkwwlxk01o_ffyqhs0.png"></p><br><p>     net/http. ,  allocation    net/nttp.       . </p><br><p><img src="https://habrastorage.org/webt/jm/fh/sg/jmfhsgqsqoiwblgnfsliiytqauw.png"></p><br><p> :  PipelineClient      connection? </p><br><p> :     —  pending ,      .     .    request,      pending ,   Error. </p><br><p> :    API   ,    fasthttp,  net/http? </p><br><p> :  .     net/http     .        .  string -,  string   .  ,     net/http,   .    -     ,    .  fasthttp     ,     .    .   net/http   fasthttp  ,    net/http     POST-,   response,  () .   fasthttp  ,  request  response    .    10 request   10 response .    ,      .    fasthttp   10 request   10 response?         .           —    .            ,     net/http.           . ,  net/http   —    . </p><br><p> PS        . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    </a> . </p><br><p>     —     . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443378/">https://habr.com/ru/post/443378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443360/index.html">Una mirada desde adentro. Escuela de Posgrado en EPFL. Parte 3: del recibo a la protección</a></li>
<li><a href="../443364/index.html">Cómo una empresa de medios puede lanzar 12 startups exitosas al año</a></li>
<li><a href="../443370/index.html">Conectando Google reCAPTCHA a Vue y validando la respuesta en el servidor</a></li>
<li><a href="../443372/index.html">Backend en CodeFest. Tripas ordenadas?</a></li>
<li><a href="../443376/index.html">Logramos encontrar docenas de almacenamientos corporativos de Box.com que revelan datos de Apple, Herbalife, etc.</a></li>
<li><a href="../443380/index.html">UDB Que es esto Parte 6. Módulo de estado y control</a></li>
<li><a href="../443382/index.html">Fintech Digest: Mir Pay para Android, levantando la prohibición de retirar efectivo de billeteras anónimas, las startups de AI no son exactamente AI</a></li>
<li><a href="../443384/index.html">Slurm y MegaSlerm en Moscú a finales de mayo</a></li>
<li><a href="../443386/index.html">Cómo obtener el registro de seguridad con un usuario no administrativo</a></li>
<li><a href="../443388/index.html">Control de iluminación multinivel basado en KTS NPL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>