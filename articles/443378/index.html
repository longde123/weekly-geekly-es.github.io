<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèΩ üßò üíÄ Estamos escribiendo un cliente http de alto rendimiento usando fasthttp como ejemplo. Alexander Valyalkin (VertaMedia) üë®üèΩ‚ÄçüöÄ üë©üèΩ‚Äçüîß üõÄüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La biblioteca Fasthttp es una alternativa acelerada a net / http de los paquetes est√°ndar de Golang. 
 ¬øC√≥mo se arregla? ¬øPor qu√© es tan r√°pida? 


 T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estamos escribiendo un cliente http de alto rendimiento usando fasthttp como ejemplo. Alexander Valyalkin (VertaMedia)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443378/"><p>  La biblioteca Fasthttp es una alternativa acelerada a net / http de los paquetes est√°ndar de Golang. <br>  ¬øC√≥mo se arregla?  ¬øPor qu√© es tan r√°pida? </p><br><p>  Traigo a su atenci√≥n una transcripci√≥n del informe de los clientes internos de Alexander Valyalkin Fasthttp. <br>  Los patrones Fasthttp se pueden usar para acelerar sus aplicaciones, su c√≥digo. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/fg3JPUswiek" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  A qui√©n le importa, bienvenido al gato. </p><a name="habracut"></a><br><p>  Soy Alexander Valyalkin  Yo trabajo en VertaMedia.  Desarroll√© fasthttp para nuestras necesidades.  Incluye la implementaci√≥n del cliente http y el servidor http.  Fasthttp es mucho m√°s r√°pido que net / http de los paquetes Go est√°ndar. </p><br><p><img src="https://habrastorage.org/webt/mw/xn/qb/mwxnqbi-ufmc9agmni-so-gy-ls.png"></p><br><p>  Fasthttp es una implementaci√≥n r√°pida del servidor http y el cliente.  Ubicado fasthttp en github.com </p><br><p><img src="https://habrastorage.org/webt/ve/vz/07/vevz07ucp1l6ou4pg8zp2kuhvzu.png"></p><br><p>  Creo que muchos han escuchado sobre el servidor fasthttp, que es muy r√°pido.  Pero pocos han o√≠do hablar del cliente fasthttp.  El servidor Fasthttp participa en el benchmark de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">techempower</a> , el famoso benchmark en c√≠rculos estrechos para servidores http.  El servidor Fasthttp participa en las rondas 12 y 13.  La ronda 13 a√∫n no ha salido (en 2016 - aprox. Ed.). </p><br><p><img src="https://habrastorage.org/webt/ow/t8/hv/owt8hvhbrxpvfxihc1golxlgp-y.png"></p><br><p>  Los resultados de una de las pruebas de la ronda 12, donde fasthttp est√° casi en la cima.  Los n√∫meros muestran cu√°ntas consultas hace por segundo en esta prueba.  En esta prueba, se realiza una solicitud para una p√°gina que devuelve hello world.  En hello world fasthttp es muy r√°pido. </p><br><p><img src="https://habrastorage.org/webt/tk/h8/1t/tkh81tfzy0ee5jt0poqw_gxmv-e.png"></p><br><p>  Resultados preliminares de la pr√≥xima ronda, que a√∫n no se ha publicado (en 2016 - aprox. Ed.).  4 implementaciones fasthttp ocupan el primer lugar en el punto de referencia, que no solo regala hello world, sino que tambi√©n se arrastra a la base de datos y forma una p√°gina html basada en la plantilla. </p><br><p><img src="https://habrastorage.org/webt/lj/h1/ov/ljh1ovyrxst7hzjjgd16yk4tbmo.png"></p><br><p>  Muy pocas personas saben sobre el cliente fasthttp.  Pero en realidad tambi√©n es genial.  En este informe, le contar√© sobre el dispositivo interno fasthttp client y por qu√© fue desarrollado. </p><br><p><img src="https://habrastorage.org/webt/z6/rp/az/z6rpazy3l_asbpcbaklgdo8mnkq.png"></p><br><p>  En realidad, hay varios clientes en fasthttp: Client, HostClient y PipelineClient.  Adem√°s, te contar√© m√°s sobre cada uno de ellos. </p><br><p><img src="https://habrastorage.org/webt/vs/ok/5u/vsok5umamlhuly1-gcfdewuxybu.png"></p><br><p>  Fasthttp.Client es un cliente http de uso general regular.  Con √©l, puede realizar solicitudes a cualquier sitio de Internet, recibir respuestas.  Sus caracter√≠sticas: funciona r√°pidamente, puede limitar la cantidad de conexiones abiertas por host, a diferencia del paquete net / http.  La documentaci√≥n est√° en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://godoc.org/github.com/valyala/fast">https://godoc.org/github.com/valyala/fasthttp#Client</a> . </p><br><p><img src="https://habrastorage.org/webt/r0/il/cc/r0ilcc3iwd6acpv1pqbawqxvfc4.png"></p><br><p>  Fasthttp.HostClient es un cliente especializado para comunicarse con un solo servidor.  Por lo general, se utiliza para acceder a la API HTTP: API REST, API JSON.  Tambi√©n se puede usar para proxy del tr√°fico de Internet a un DataCenter interno en varios servidores.  La documentaci√≥n est√° aqu√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://godoc.org/github.com/valyala/fast">https://godoc.org/github.com/valyala/fasthttp#HostClient</a> . </p><br><p>  Al igual que Fasthttp.Client, Fasthttp.HostClient puede limitar el n√∫mero de conexiones abiertas a cada uno de los servidores Backend.  Esta funcionalidad est√° ausente en net / http, y tambi√©n esta funci√≥n est√° ausente en nginx gratis.  Esta funcionalidad es solo en nginx pagado, que yo sepa. </p><br><p><img src="https://habrastorage.org/webt/sn/ys/ep/snysephpvj2u3itk5icip242ima.png"></p><br><p>  Fasthttp.PipelineClient es un cliente especializado que le permite administrar solicitudes de canalizaci√≥n a un servidor o a un n√∫mero limitado de servidores.  Se puede utilizar para acceder a la API, a trav√©s del protocolo HTTP, donde necesita realizar muchas solicitudes y lo m√°s r√°pido posible.  La limitaci√≥n de Fasthttp.PipelineClient es que puede sufrir el bloqueo de Head of Line.  Esto es cuando enviamos muchas solicitudes al servidor y no esperamos una respuesta a cada solicitud.  El servidor est√° bloqueado en una de estas solicitudes.  Debido a esto, todas las dem√°s solicitudes que lo siguieron esperar√°n hasta que este servidor procese una solicitud lenta.  Fasthttp.PipelineClient debe usarse solo si est√° seguro de que el servidor responder√° instant√°neamente a sus solicitudes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://godoc.org/github.com/valyala/fast">Documentaci√≥n</a> </p><br><p><img src="https://habrastorage.org/webt/9b/sa/z2/9bsaz297eqozr0ckcwrlbmefdqk.png"></p><br><p>  Ahora comenzar√© a hablar sobre la implementaci√≥n interna de cada uno de estos clientes.  Comenzar√© con Fasthttp.HostClient, porque casi todos los dem√°s clientes se crean sobre la base. </p><br><p><img src="https://habrastorage.org/webt/zm/vq/rt/zmvqrtpi1eogjgjqmlnvxbjh7ca.png"></p><br><p>  Esta es la implementaci√≥n m√°s simple del cliente HTTP en pseudoc√≥digo en Go.  Estamos conectados, recibimos una respuesta http en esta URL.  Nos estamos conectando a este host.  Tenemos conexi√≥n  En este c√≥digo, para que sea menor que el volumen, faltan todas las comprobaciones de errores.  De hecho, esto no es as√≠.  Siempre debe verificar si hay errores.  Crea una conexi√≥n.  Conexi√≥n cercana con aplazar.  Enviamos una solicitud de esta conexi√≥n por URL.  Recibimos la respuesta, devolvemos esta respuesta.  ¬øQu√© hay de malo con esta implementaci√≥n de HTTP Client? </p><br><p><img src="https://habrastorage.org/webt/ev/lq/q4/evlqq4u3y3qbzr_agvrnmknzdee.png"></p><br><p>  El primer problema es que en esta implementaci√≥n, se establece una conexi√≥n para cada solicitud.  Esta implementaci√≥n no es compatible con HTTP KeepAlive.  ¬øC√≥mo resolver este problema?  Puede usar el Pool de conexiones para cada servidor.  No puede usar el Pool de conexiones para todos los servidores, porque la siguiente solicitud no est√° clara a qu√© servidor enviar.  Cada servidor debe tener su propio grupo de conexiones.  Y usamos HTTP KeepAlive.  Esto significa que Connection Header no necesita especificar Connection Close.  En HTTP / 1.1, de forma predeterminada, existe soporte para HTTP KeepAlive y Connection Close debe eliminarse del encabezado.  Aqu√≠ est√° la implementaci√≥n en pseudoc√≥digo del cliente con soporte de Connection Pool.  Hay un conjunto de varios grupos de conexiones para cada host.  La primera funci√≥n, connPoolForHost, devuelve el Pool de conexiones para un host determinado desde una URL determinada.  Luego obtenemos la conexi√≥n de este Pool de conexiones, planeamos usar Defer para enviar esta conexi√≥n de regreso al Pool, enviar una solicitud KeepAlive para esta conexi√≥n y devolver una respuesta.  Despu√©s de la respuesta, se ejecuta Defer y la conexi√≥n vuelve al Pool.  Por lo tanto, habilitamos el soporte HTTP KeepAlive y todo comienza a funcionar m√°s r√°pido.  Porque no perdemos tiempo creando una conexi√≥n para cada solicitud. </p><br><p>  Pero la soluci√≥n tambi√©n tiene problemas.  Si observa la firma de la funci√≥n, puede ver que devuelve un objeto de respuesta para cada solicitud.  Esto significa que para este objeto necesita asignar memoria cada vez, inicializarlo y devolverlo.  Esto es malo para el rendimiento.  Puede ser malo si tiene muchas de esas llamadas para obtener funciones. </p><br><p><img src="https://habrastorage.org/webt/jb/yq/rr/jbyqrrzhu_qusd9j9ocba8m0czk.png"></p><br><p>  Por lo tanto, este problema puede resolverse como se resuelve en Fasthttp colocando el objeto puntero en el objeto de respuesta en los par√°metros de esta funci√≥n.  De esa manera, ese c√≥digo de llamada puede reutilizar este objeto de respuesta muchas veces.  En la diapositiva est√° la implementaci√≥n de esta idea.  Pasamos una referencia al objeto de respuesta a la funci√≥n Get, y la funci√≥n llena esta respuesta.  La √∫ltima l√≠nea llena este objeto. </p><br><p><img src="https://habrastorage.org/webt/bm/z7/rq/bmz7rqtnowb5dreyup6c-er_tq0.png"></p><br><p>  As√≠ es como podr√≠a verse en su c√≥digo.  Una funci√≥n que acepta un canal al que se le pasa una lista de URL para sondear.  Organizaremos un ciclo en este canal.  Creamos un objeto de respuesta una vez y lo reutilizamos en un bucle.  Llame a Get, pase un puntero al objeto, procese esta respuesta.  Despu√©s de haberlo procesado, lo restablecemos a su estado original.  De esta manera evitamos la asignaci√≥n de memoria y aceleramos nuestro c√≥digo. </p><br><p><img src="https://habrastorage.org/webt/ok/2t/5z/ok2t5zsghgoxj7ruc2z_1hhcagu.png"></p><br><p>  El tercer problema es la conexi√≥n cercana.  Conexi√≥n cerrada: encabezado HTTP, que se puede encontrar tanto en la solicitud como en la respuesta.  Si tenemos ese encabezado, entonces esta conexi√≥n deber√≠a cerrarse.  Por lo tanto, en la implementaci√≥n del cliente, es imprescindible proporcionar un cierre de conexi√≥n.  Si envi√≥ una solicitud con el encabezado Cerrar conexi√≥n, luego de recibir la respuesta, debe cerrar esta conexi√≥n.  Si envi√≥ una solicitud sin Cerrar conexi√≥n y devolvi√≥ una respuesta con Cerrar conexi√≥n, tambi√©n debe cerrar esta conexi√≥n despu√©s de recibir una respuesta. </p><br><p><img src="https://habrastorage.org/webt/bc/ve/up/bcveuplhhdifuc0malg7f7bm2vw.png"></p><br><p>  Aqu√≠ est√° el pseudoc√≥digo para esta implementaci√≥n.  Despu√©s de recibir una respuesta, verificamos si los encabezados de cierre de conexi√≥n est√°n instalados all√≠.  Si est√° instalado, simplemente cierre la conexi√≥n.  Si no est√° instalado, regrese la conexi√≥n al grupo.  Si no se hace esto, entonces si el servidor cierra la conexi√≥n despu√©s de que devuelve las respuestas, su grupo de conexiones contendr√° la conexi√≥n interrumpida que cerr√≥ el servidor, e intentar√° escribir algo en ellas y obtendr√° errores. </p><br><p><img src="https://habrastorage.org/webt/wi/ms/gh/wimsghjdbpnjilbkgmvw5cryrvg.png"></p><br><p>  El cuarto problema al que est√°n expuestos los clientes HTTP es servidores lentos o una red lenta e inactiva.  Los servidores pueden dejar de responder a sus solicitudes por varias razones.  Por ejemplo, el servidor est√° roto o la red entre su cliente y el servidor ha dejado de funcionar.  Debido a esto, todas sus rutinas que llaman a la funci√≥n Obtener que se describi√≥ previamente ser√°n bloqueadas, esperando una respuesta del servidor indefinidamente.  Por ejemplo, si implementa un proxy http que acepta una conexi√≥n entrante y llama a la funci√≥n Get en cada conexi√≥n, se crear√° una gran cantidad de goroutines y todos se colgar√°n en su servidor hasta que el servidor falle, hasta que se agote la memoria. </p><br><p><img src="https://habrastorage.org/webt/cb/mq/1c/cbmq1c_b9ua-0ess-if8dfqkk0a.png"></p><br><p>  ¬øC√≥mo resolver este problema?  Hay una decisi√≥n tan ingenua que se me viene a la mente: simplemente envu√©lvela en una rutina diferente.  Luego, en goroutine, pase un canal vac√≠o, que se cerrar√° despu√©s de ejecutar Get.  Despu√©s de comenzar esta rutina, espere un momento en este canal (tiempo de espera).  En este caso, si pasa alg√∫n tiempo y este Get no se ejecuta, la salida de esta funci√≥n se producir√° por tiempo de espera.  Si se ejecuta este Get, el canal se cerrar√° y se producir√° la salida.  Pero esta decisi√≥n es incorrecta, porque transfiere el problema de una cabeza enferma a una sana.  De todos modos, se crear√°n gorutinas y se suspender√°n independientemente del tiempo de espera que use.  El n√∫mero de goroutines que caus√≥ Get timeout ser√° limitado, pero habr√° un n√∫mero ilimitado de goroutines que se crear√°n dentro de Get con un tiempo de espera. </p><br><p><img src="https://habrastorage.org/webt/yx/jx/nj/yxjxnjpdobdntdoel9119aqdgyo.png"></p><br><p>  ¬øC√≥mo resolver este problema?  La primera soluci√≥n es limitar el n√∫mero de gorutinas bloqueadas en la funci√≥n Obtener.  Esto se puede hacer usando un patr√≥n tan conocido como el uso de un canal protegido de longitud limitada, que contar√° el n√∫mero de goroutines que ejecutan la funci√≥n Get.  Si esta cantidad de gorutina excede un cierto l√≠mite: la capacidad de este canal, saldremos a la rama predeterminada.  Esto significa que tenemos todas las rutinas que se realizan est√°n ocupadas, y en la rama predeterminada solo necesitamos devolver Error, que no hay recursos libres.  Antes de crear goroutine, tratamos de escribir una estructura vac√≠a en este canal.  Si esto no funciona, entonces hemos excedido la cantidad de gorutinas.  Si result√≥, creamos este gorutin y despu√©s de ejecutar Get, leemos un valor de este canal.  Por lo tanto, limitamos la cantidad de goroutines que se pueden bloquear en Get. </p><br><p><img src="https://habrastorage.org/webt/w4/id/rr/w4idrrvfykc05ahmf_hrbyscwcs.png"></p><br><p>  La segunda soluci√≥n, que complementa la primera, es establecer tiempos de espera en la conexi√≥n al servidor.  Esto desbloquear√° la funci√≥n get si el servidor no responde durante mucho tiempo o si la red est√° inactiva. </p><br><p>  Si la red no funciona en la Soluci√≥n n. ¬∞ 1, entonces todo se bloquear√°.  Despu√©s de escribir cuncurrency en un n√∫mero limitado de goroutines que colgaban aqu√≠, la funci√≥n getimeout siempre devolver√° un error.  Para que comience a funcionar normalmente, necesita una segunda soluci√≥n (Soluci√≥n # 2), que establece un tiempo de espera para leer y escribir desde la conexi√≥n.  Esto ayuda a desbloquear goroutines bloqueados si la red o el servidor dejan de funcionar. </p><br><p><img src="https://habrastorage.org/webt/yx/jx/nj/yxjxnjpdobdntdoel9119aqdgyo.png"></p><br><p>  La soluci√≥n # 1 tiene una carrera de datos.  El objeto de respuesta desde el que se pas√≥ el puntero se ocupar√° si se bloquea.  Pero esta funci√≥n Obtener tiempo de espera puede expirar.  En este caso, salimos de esta funci√≥n, una respuesta que se bloquear√° y despu√©s de un tiempo se reescribir√°.  Por lo tanto, se obtiene una carrera de datos.  Como tenemos respuesta despu√©s de salir de la funci√≥n, todav√≠a se usa en alg√∫n lugar de la rutina. </p><br><p>  El problema se resuelve creando una copia de respuesta y pasando la copia de respuesta a goroutine.  Despu√©s de completar Get, copie la respuesta de esta respuesta en nuestra respuesta original, que se pasa aqu√≠.  Por lo tanto, la carrera de datos est√° resuelta.  Esta copia de la respuesta dura poco tiempo y regresa al grupo.  Reutilizamos la respuesta.  Es posible que una copia de respuesta no entre en el grupo solo por tiempo de espera.  Por tiempo de espera, hay una p√©rdida de respuesta del grupo. </p><br><p><img src="https://habrastorage.org/webt/sc/cm/ar/sccmar-ze8kukg1nm5csyxz2riy.png"></p><br><p>  ¬øNecesito cerrar la conexi√≥n despu√©s de que el servidor no haya devuelto una respuesta dentro de un tiempo de espera?  La respuesta es no.  M√°s bien, s√≠, si desea hacer una copia de seguridad del servidor.  Porque cuando env√≠a una solicitud al servidor, espere un momento, el servidor no responde durante este tiempo, no responde a las solicitudes.  Por ejemplo, cierra esta conexi√≥n, pero esto no significa que el servidor dejar√° de ejecutar esta solicitud de inmediato.  El servidor continuar√° ejecut√°ndolo.  El servidor detectar√° que no es necesario ejecutar esta solicitud despu√©s de que intente devolverte una respuesta.  Cerr√≥ la conexi√≥n, intent√≥ nuevamente crear una nueva solicitud, nuevamente pas√≥ el tiempo de espera, volvi√≥ a cerrar, cre√≥ una nueva solicitud.  Tendr√° una carga en el aumento del servidor.  Como resultado, su servicio depende de sus solicitudes.  Estos son DoS a nivel de solicitudes http.  Si tiene servidores que se ejecutan lentamente y no desea hacer una copia de seguridad de ellos, entonces no necesita cerrar la conexi√≥n despu√©s de un tiempo de espera.  Debe esperar un momento, dejar la conexi√≥n para expiar este servidor.  Deja que intente darte una respuesta.  Mientras tanto, use otras conexiones gratuitas.  Todo lo que se dijo antes de esto son todas las etapas de la implementaci√≥n de Fasthttp.Client y los problemas que ocurrieron durante la implementaci√≥n de Fasthttp.Client.  Estos problemas se resuelven en Fasthttp.HostClient. </p><br><p><img src="https://habrastorage.org/webt/ht/yz/uj/htyzujg6gqaycezv_ot4_xucb6w.png">  Ahora tenemos un cliente r√°pido?  En realidad no  Necesita ver c√≥mo se implementa Connection Pool. </p><br><p><img src="https://habrastorage.org/webt/tk/rs/1u/tkrs1uhjy3nlqecg_j2payseg_i.png"></p><br><p>  La implementaci√≥n ingenua de Connection Pool se ve as√≠.  Hay alg√∫n tipo de direcci√≥n de servidor donde necesita instalar la conexi√≥n.  Hay una lista de conexiones libres y un bloqueo para sincronizar el acceso a esta lista. </p><br><p><img src="https://habrastorage.org/webt/zb/lk/j5/zblkj5q4hygyxgd9rmrzjx2nxpa.png"></p><br><p>  Aqu√≠ est√° la funci√≥n para obtener la conexi√≥n del grupo de conexiones.  Estamos viendo una lista de nuestra colecci√≥n.  Si hay algo all√≠, entonces obtenemos una conexi√≥n gratuita y la devolvemos.  Si no hay nada, cree una nueva conexi√≥n a este servidor y devu√©lvala.  ¬øQu√© est√° mal aqu√≠? </p><br><p><img src="https://habrastorage.org/webt/lw/xz/7q/lwxz7qmhwkqv3tmu4mc5f0tfumi.png">  La funci√≥n connPool.Put devuelve una conexi√≥n libre. </p><br><p>  En la cuenta de tiempo de espera.  En Fasthttp.Client, puede especificar la vida √∫til m√°xima de una conexi√≥n abierta no utilizada.  Una vez transcurrido este tiempo, las conexiones no utilizadas se cierran autom√°ticamente y se eliminan de este grupo. </p><br><p>  Las conexiones m√°s antiguas no se utilizan con el tiempo y se cierran y eliminan autom√°ticamente del grupo. </p><br><p>  Cuando la conexi√≥n se toma del grupo, y resulta que su servidor estaba cerrado, e intent√≥ escribir algo all√≠, se realiza un segundo intento: se obtiene una nueva conexi√≥n e intenta enviar nuevamente las solicitudes para esta conexi√≥n.  Pero esto es solo si esta solicitud es idempotente, es decir, una solicitud que se puede ejecutar muchas veces sin efectos secundarios en el servidor, es una solicitud GET o HEAD.  Por ejemplo, en el est√°ndar net / http, justo ahora, agregamos una verificaci√≥n para conexiones cerradas.  All√≠ hicieron un chequeo m√°s complicado.  Comprueban, cuando intentan enviar una nueva solicitud a la conexi√≥n desde el grupo, si se env√≠a al menos un byte a esta conexi√≥n.  Si se desactiva, entonces devuelve Error.  Si no se fue, tomamos una nueva conexi√≥n del grupo. </p><br><p><img src="https://habrastorage.org/webt/h2/ug/yv/h2ugyvjrfzht7gfwx2gemetfazy.png"></p><br><p>  ¬øQu√© hay de malo en la piscina?  Su tama√±o no est√° limitado.  Misma implementaci√≥n que en net / http.  Si escribe un cliente que est√° pasando de millones de gorutinas a un servidor lento, entonces el cliente intentar√° crear una conexi√≥n de millones a este servidor.  No hay l√≠mite en el n√∫mero m√°ximo de conexiones en el paquete est√°ndar net / http.  Para el cliente que se utiliza para acceder a la API a trav√©s de HTTP, es aconsejable limitar el tama√±o de este grupo de conexiones.  De lo contrario, sus clientes pueden fallar, ya que utilizar√° todos los recursos: hilos, objetos, conexi√≥n, rutinas y memoria.  Adem√°s, esto puede conducir a DoS de sus servidores, ya que se establecer√° una gran cantidad de conexiones con ellos, que no se usan o se usan de manera ineficiente, porque el servidor no puede mantener tanta conexi√≥n. </p><br><p><img src="https://habrastorage.org/webt/km/zk/pn/kmzkpnls98apnqltus4tvoeeb5c.png"></p><br><p>  Limite el grupo de conexiones.  El c√≥digo no est√° aqu√≠, porque es demasiado grande para caber en una diapositiva.  Los interesados ‚Äã‚Äãpueden ver la implementaci√≥n de esta funci√≥n en github.com. </p><br><p><img src="https://habrastorage.org/webt/ub/1a/ko/ub1akoqexz4yoqyn3xogkcwveza.png"></p><br><p>  El segundo problema  Muchas solicitudes llegan al cliente en alg√∫n momento.  Y despu√©s de eso hay una disminuci√≥n y un retorno al n√∫mero anterior de solicitudes.  Por ejemplo, 10,000 solicitudes llegaron simult√°neamente, luego el n√∫mero de solicitudes regres√≥ a 1000 por unidad de tiempo.  Despu√©s de eso, el grupo de conexiones crecer√° a 10000 conexiones.  Estas conexiones colgar√°n all√≠ sin cesar.  Este problema estaba en el cliente net / http est√°ndar anterior a la versi√≥n 1.7.  Por lo tanto, debe resolver este problema. </p><br><p><img src="https://habrastorage.org/webt/dm/o1/w4/dmo1w4jixcnjjjaoznw8r7zz8bw.png"></p><br><p>  Este problema se resuelve limitando la vida de una conexi√≥n no utilizada.  Si durante alg√∫n tiempo no se envi√≥ una sola solicitud a trav√©s de la conexi√≥n, simplemente se cierra y se descarta del grupo.  No hay implementaci√≥n porque es demasiado grande. </p><br><p><img src="https://habrastorage.org/webt/hs/wj/wx/hswjwxgrlyawxzj_t-mmdbxhh3m.png"></p><br><p>  ¬øTenemos un cliente que funciona r√°pido y genial?  Realmente no es as√≠.  Todav√≠a tenemos la funci√≥n de crear conexi√≥n: dialHost. </p><br><p><img src="https://habrastorage.org/webt/cl/bs/jr/clbsjrbour6diwgkjri6jpdhnx8.png"></p><br><p>  Veamos su implementaci√≥n.  Una implementaci√≥n ingenua se ve as√≠.  La direcci√≥n donde desea conectarse simplemente se transmite.  Llamamos a la funci√≥n est√°ndar net.Dial.  Ella devuelve la conexi√≥n.  ¬øQu√© hay de malo en esta implementaci√≥n? </p><br><p><img src="https://habrastorage.org/webt/sm/b_/bc/smb_bcj41taldeo3mvnfl9ek-2g.png"></p><br><p>  Por defecto, net.Dial realiza una solicitud de DNS para cada llamada.  Esto puede conducir a un mayor uso de los recursos de su subsistema DNS.  Si los clientes API se conectan a servidores que no admiten conexiones KeepAlive, cierran las conexiones.  KeepAlive lo respalda y los servidores no.  Despu√©s de tal respuesta, el servidor cierra la conexi√≥n.  Resulta que se llama a net.Dial en cada solicitud.  Hay alrededor de 10 mil solicitudes de este tipo por segundo.  Tienes 10 mil veces por segundo que se resuelve en dns.  Esto carga el subsistema DNS. </p><br><p><img src="https://habrastorage.org/webt/2j/au/e6/2jaue6kkmfwaob6p9tu-5quhgei.png"></p><br><p>  ¬øC√≥mo resolver este problema?  Cree un cach√© que mapee el host en IP por un corto tiempo directamente en su c√≥digo Go, y no llame a dns resolviendo en cada red.  Con√©ctese a direcciones IP listas para usar. </p><br><p><img src="https://habrastorage.org/webt/eh/n2/j3/ehn2j3tfuse-43qoibyq5oqqcsu.png"></p><br><p>  El segundo problema es la carga desigual en el servidor si tiene varios servidores ocultos detr√°s del nombre de dominio.  Por ejemplo, como Round Robin DNS.  Si almacena en cach√© una direcci√≥n IP en DNS por un tiempo, durante este tiempo todas sus solicitudes ir√°n a un servidor.  Aunque puede tener varios de ellos all√≠.  Es necesario resolver este problema.  Se resuelve enumerando todas las IP disponibles que est√°n ocultas detr√°s de un nombre de dominio dado.  Esto tambi√©n se hace en Fasthttp.Client. </p><br><p><img src="https://habrastorage.org/webt/wx/hb/6r/wxhb6r3hlt_wofv6o347jyvw_oo.png"></p><br><p>  El tercer problema es que net.Dial tambi√©n puede colgar indefinidamente debido a problemas con la red o el servidor donde est√° intentando conectarse.  En este caso, sus gorutinas se colgar√°n de la funci√≥n Obtener.  Esto tambi√©n puede conducir a un mayor uso de los recursos. </p><br><p><img src="https://habrastorage.org/webt/jc/k3/id/jck3idzikb6vyzvsbcuckeg8wae.png">  La soluci√≥n es agregar un tiempo de espera.   Dial     package net. ,   ,   . ,    ,      ,   . </p><br><p><img src="https://habrastorage.org/webt/cb/mq/1c/cbmq1c_b9ua-0ess-if8dfqkk0a.png"></p><br><p>     .  Get  Dial .    - .  Dial ,  ,   .   ,  ,   .    DialTimeout. ,   . </p><br><p><img src="https://habrastorage.org/webt/jo/tn/t0/jotnt0t9nwul2jx8sym4-kycfvu.png"></p><br><p>   HostClient   . </p><br><p> HostClient      ,   .     LoadBalance. </p><br><p>  HostClient    .          ,  HostClient        .   connection       .     .     . </p><br><p> Fauly host     . </p><br><p>   ‚Äî        .   Dial.    ,     Dial. Get,  ,   - .   ,           .  ,       ,   . </p><br><p>   ‚Äî      .   Get   ,   .     ,    ,  ,    . </p><br><p>   Error ,     Round Robin    . </p><br><p>  SSL   ,    Golang   .        . </p><br><p><img src="https://habrastorage.org/webt/py/wf/93/pywf93cfwemlknabq_iejxfgpt4.png"></p><br><p>   fasthttp.Client.           HostClient,   fasthttp.Client    HostClient. </p><br><p><img src="https://habrastorage.org/webt/0s/f8/mz/0sf8mzfxpk1nl5lucgjvwaqkgy8.png"></p><br><p>        Get.     HostClient    .      HostClient      .     HostClient   Get.       HostClient. </p><br><p><img src="https://habrastorage.org/webt/xd/nf/u8/xdnfu88duh8s5ibm0qx_riwe4go.png"></p><br><p>       HostClient  -  ,      URL.    web-crawling (  ),        .        HostClient       .      net/http,      .    ,    HostClient,      .   fasthttp. </p><br><p><img src="https://habrastorage.org/webt/r2/f7/bk/r2f7bkykq6m6oqcd3ylss9rwdr4.png"></p><br><p>    Client  HostClient,  PipelineClient   .  PipelineClient  connection pool.  PipelineClient    connection,     . PipelineClient         connection.     connection pool. PipelineClient   connection       . </p><br><p><img src="https://habrastorage.org/webt/lj/vw/ew/ljvwewxdpm8ag50y-tcfzthrxia.png"></p><br><p>  PipelineClient   connection   . PipelineConnClient.writer ‚Äî    connection,   . PipelineConnClient.reader ‚Äî     connection     ,     PipelineConnClient.writer. PipelineConnClient.reader   ,     Get. </p><br><p><img src="https://habrastorage.org/webt/nj/9q/lp/nj9qlpw3mexynplnky52vvhcar4.png"></p><br><p>      PipelineClient.Get  PipelineClient.   pipelineWork  url,    ,    response,  channel done,     response. </p><br><p>     Get. C   .    channel,   PipelineConnClient.writer      connection.   channel w.done,   PipelineConnClient.reader,   response   request. </p><br><p><img src="https://habrastorage.org/webt/s4/vf/oq/s4vfoqg_mmutotfdw66gs4nbxvs.png"></p><br><p>   net/http   fasthttp.Client   2 . </p><br><p><img src="https://habrastorage.org/webt/ah/ra/-o/ahra-oaf0uydcje9yqofoh6l-6k.png"></p><br><p> ,     ,   fasthttp.     , , .    fasthttp. ,      fasthttp,          .    allocation  .         . </p><br><p><img src="https://habrastorage.org/webt/q6/c3/ss/q6c3ss7kpmkwwlxk01o_ffyqhs0.png"></p><br><p>     net/http. ,  allocation    net/nttp.       . </p><br><p><img src="https://habrastorage.org/webt/jm/fh/sg/jmfhsgqsqoiwblgnfsliiytqauw.png"></p><br><p> :  PipelineClient      connection? </p><br><p> :     ‚Äî  pending ,      .     .    request,      pending ,   Error. </p><br><p> :    API   ,    fasthttp,  net/http? </p><br><p> :  .     net/http     .        .  string -,  string   .  ,     net/http,   .    -     ,    .  fasthttp     ,     .    .   net/http   fasthttp  ,    net/http     POST-,   response,  () .   fasthttp  ,  request  response    .    10 request   10 response .    ,      .    fasthttp   10 request   10 response?         .           ‚Äî    .            ,     net/http.           . ,  net/http   ‚Äî    . </p><br><p> PS        . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    </a> . </p><br><p>     ‚Äî     . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443378/">https://habr.com/ru/post/443378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443360/index.html">Una mirada desde adentro. Escuela de Posgrado en EPFL. Parte 3: del recibo a la protecci√≥n</a></li>
<li><a href="../443364/index.html">C√≥mo una empresa de medios puede lanzar 12 startups exitosas al a√±o</a></li>
<li><a href="../443370/index.html">Conectando Google reCAPTCHA a Vue y validando la respuesta en el servidor</a></li>
<li><a href="../443372/index.html">Backend en CodeFest. Tripas ordenadas?</a></li>
<li><a href="../443376/index.html">Logramos encontrar docenas de almacenamientos corporativos de Box.com que revelan datos de Apple, Herbalife, etc.</a></li>
<li><a href="../443380/index.html">UDB Que es esto Parte 6. M√≥dulo de estado y control</a></li>
<li><a href="../443382/index.html">Fintech Digest: Mir Pay para Android, levantando la prohibici√≥n de retirar efectivo de billeteras an√≥nimas, las startups de AI no son exactamente AI</a></li>
<li><a href="../443384/index.html">Slurm y MegaSlerm en Mosc√∫ a finales de mayo</a></li>
<li><a href="../443386/index.html">C√≥mo obtener el registro de seguridad con un usuario no administrativo</a></li>
<li><a href="../443388/index.html">Control de iluminaci√≥n multinivel basado en KTS NPL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>