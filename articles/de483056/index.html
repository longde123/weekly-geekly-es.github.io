<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèø üìù ‚õ¥Ô∏è Logische Felder in Datenbanken, gibt es ein Gegenmittel? üíå üòß üòÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oft enthalten Tabellen eine gro√üe Anzahl logischer Felder, es gibt keine M√∂glichkeit, alle zu indizieren, und die Effektivit√§t einer solchen Indizieru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Logische Felder in Datenbanken, gibt es ein Gegenmittel?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483056/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gv/ls/ke/gvlskeckr84dlji3r0xb3pmnk1k.jpeg" width="500"></div><br>  Oft enthalten Tabellen eine gro√üe Anzahl logischer Felder, es gibt keine M√∂glichkeit, alle zu indizieren, und die Effektivit√§t einer solchen Indizierung ist gering.  F√ºr die Arbeit mit beliebigen logischen Ausdr√ºcken in SQL ist jedoch ein mehrdimensionaler Indexierungsmechanismus geeignet, der unter cat erl√§utert wird. <br><a name="habracut"></a><br>  In SQL werden logische Felder haupts√§chlich in zwei F√§llen verwendet.  Erstens, wenn Sie wirklich ein bin√§res Attribut ben√∂tigen, z. B. 'buy / sell' in der Transaktionstabelle.  Solche Attribute √§ndern sich selten im Laufe der Zeit. <br><br>  Zweitens, um den Status der <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">Zustandsmaschine</a> aufzuzeichnen, die den Datensatz beschreibt.  Es versteht sich, dass ein logisches Objekt, das einem Tabelleneintrag entspricht, eine Reihe von Zust√§nden durchl√§uft, deren Anzahl und die √úberg√§nge zwischen ihnen durch angewandte Logik bestimmt werden.  Ein einfaches Beispiel ist die ‚ÄûSoft-Delete‚Äú -Technik, bei der ein Datensatz nicht physisch zerst√∂rt, sondern nur als gel√∂scht markiert wird. <br><br>  Wenn die Maschine komplex ist, kann es eine ganze Menge solcher Felder geben, in einer <a href="https://arqatech.com/ru/products/qort/">unserer</a> Tabellen gibt es 58 (+14 veraltete) solche Felder (einschlie√ülich Flaggens√§tze) und dies ist nicht ungew√∂hnlich.  Dies war urspr√ºnglich nicht beabsichtigt, aber wenn sich das Produkt entwickelt und die externen Anforderungen √§ndern, entwickeln sich die entsprechenden Maschinen, Entwickler kommen und gehen, Analysten √§ndern sich ... Irgendwann ist es sicherer, eine neue Flagge zu bekommen, als alle Feinheiten zu verstehen.  Dar√ºber hinaus haben sich historische Daten angesammelt, und ihre Bedingungen m√ºssen angemessen bleiben. <br><br><div class="spoiler">  <b class="spoiler_title">offtopic</b> <div class="spoiler_text">  In gewisser Hinsicht √§hnelt dies dem Evolutionsprozess, in dem eine Vielzahl von Informationen / Mechanismen im Genom gespeichert sind, die auf den ersten Blick √ºberhaupt nicht ben√∂tigt werden, aber nicht entfernt werden k√∂nnen.  Andererseits lohnt es sich, diese Mechanismen zu respektieren, weil sie es den evolution√§ren Vorg√§ngern erm√∂glichten, zu √ºberleben (auch w√§hrend des <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2581%25D1%2581%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B5_%25D0%25B2%25D1%258B%25D0%25BC%25D0%25B8%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">gro√üen Aussterbens</a> ) und die evolution√§re Rasse zu gewinnen.  Wer wei√ü schon, wohin uns die Evolution f√ºhren wird und was sich in Zukunft als n√ºtzlich erweisen wird? <br></div></div><br>  Ein Flag zu setzen bedeutet nicht nur, ein Feld des entsprechenden Typs hinzuzuf√ºgen, sondern es auch bei der Operation des Automaten zu ber√ºcksichtigen, welche Zust√§nde es beeinflusst und an welchen √úberg√§ngen es beteiligt ist.  In der Praxis sieht es so aus: <br><br><ul><li>  Ein Prozess oder eine Reihe von Prozessen, nennen wir sie "Schreiber", erstellen neue Datens√§tze im Anfangszustand (m√∂glicherweise in einem der Anfangszust√§nde). </li><li>  Bei einigen Prozessen, nennen wir sie "Leser", lesen sie von Zeit zu Zeit Objekte, die sich in den von ihnen ben√∂tigten Zust√§nden befinden </li><li>  Bei einer Reihe von Prozessen nennen wir sie "Handler", √ºberwachen bestimmte Zust√§nde und √§ndern diese Zust√§nde auf der Grundlage der angewandten Logik.  Das hei√üt  Betreiben Sie eine Zustandsmaschine. </li></ul><br>  Um Datens√§tze auszuw√§hlen, die sich in einem bestimmten Zustand befinden, ist es selten, dass das Filtern nach einem der Booleschen Felder ausreichend ist.  Normalerweise ist dies ein ganzer Ausdruck, manchmal nicht trivial.  Es scheint, dass Sie diese Felder indizieren m√ºssen, und der SQL-Prozessor wird es herausfinden.  Aber nicht so einfach. <br><br>  Erstens kann es viele Boolesche Felder geben, deren Indizierung zu verschwenderisch w√§re. <br><br>  Zweitens k√∂nnte es sich seitdem als unbrauchbar herausstellen  Die Selektivit√§t f√ºr jedes der Felder ist gering, und die gemeinsame Wahrscheinlichkeit wird von den Statistiken des SQL-Prozessors nicht abgedeckt. <br><br>  Angenommen, in Tabelle T1 gibt es zwei Boolesche Felder: F1 und F2 sowie die Abfrage <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> F1, F2, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> F1, F2</code> </pre> <br>  gibt aus <br><div class="scrollable-table"><table><tbody><tr><th>  F1 </th><th>  F2 </th><th>  COUNT </th></tr><tr><td>  falsch </td><td>  falsch </td><td align="center">  499 </td></tr><tr><td>  falsch </td><td>  wahr </td><td align="center">  1 </td></tr><tr><td>  wahr </td><td>  falsch </td><td align="center">  1 </td></tr><tr><td>  wahr </td><td>  wahr </td><td align="center">  499 </td></tr></tbody></table></div><br>  Das hei√üt  Obwohl nach F1 &amp; F2 wahr und falsch gleich wahrscheinlich sind, f√§llt die Kombination (wahr, falsch) nur einmal aus tausend heraus.  Wenn wir F1 und F2 separat indizieren <u>und erzwingen, dass sie in der Abfrage verwendet werden</u> , m√ºsste der SQL-Prozessor folglich die H√§lfte beider Indizes lesen und die Ergebnisse kreuzen.  Es kann billiger sein, die gesamte Tabelle zu lesen und den Ausdruck f√ºr jede Zeile zu berechnen. <br><br>  Und selbst wenn Sie Statistiken √ºber abgeschlossene Anforderungen erfassen, ist dies nicht von gro√üem Nutzen.  Statistiken speziell f√ºr die Felder, die f√ºr den Zustand der Maschine verantwortlich sind, schweben sehr stark.  In der Tat kann jederzeit ein "Handler" kommen und die H√§lfte der Leitungen von Zustand S1 nach S2 √ºbertragen. <br><br>  Um mit solchen Ausdr√ºcken arbeiten zu k√∂nnen, bietet sich ein mehrdimensionaler Index an, dessen Algorithmus <a href="https://habr.com/post/464057/">zuvor vorgestellt wurde</a> und sich als recht gut erwiesen hat. <br><br>  Aber zuerst m√ºssen Sie herausfinden, wie aus einem beliebigen logischen Ausdruck eine Abfrage f√ºr den Index wird. <br><br><h4>  Disjunktive Normalform </h4><br>  Eine einzelne Abfrage f√ºr einen mehrdimensionalen Index ist ein mehrdimensionales Rechteck, das den Abfragebereich begrenzt.  Wenn das Feld an der Anforderung teilnimmt, wird eine Einschr√§nkung daf√ºr festgelegt.  Wenn nicht, wird das Rechteck in dieser Koordinate nur durch die Breite dieser Koordinate begrenzt.  Logische Koordinaten haben eine Kapazit√§t von 1. <br><br>  Eine Suchabfrage in einem solchen Index ist eine Kette von &amp; (Konjunktion), zum Beispiel der Ausdruck: v1 &amp; v2 &amp; v3 &amp; (! V4), √§quivalent zu v1: [1,1], v2: [1,1], v3: [1, 1], v4: [0,0].  Und alle anderen Felder haben einen Bereich: [0,1]. <br><br>  Angesichts dessen wendet sich unser Blick sofort der <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25B7%25D1%258A%25D1%258E%25D0%25BD%25D0%25BA%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0">DNF zu</a> - einer der kanonischen Formen logischer Ausdr√ºcke.  Es wird argumentiert, dass jeder Ausdruck als Disjunktion literarischer Konjunktionen dargestellt werden kann.  Ein Literal bezieht sich hier auf ein logisches Feld oder dessen Negation. <br><br>  Mit anderen Worten, durch einfache Manipulationen kann jeder logische Ausdruck als Disjunktion mehrerer Abfragen zu einem mehrdimensionalen logischen Index dargestellt werden. <br><br>  Es gibt einen ABER.  Eine solche Transformation kann in einigen F√§llen zu einer exponentiellen Vergr√∂√üerung des Ausdrucks f√ºhren.  Zum Beispiel Konvertierung von <br><br><img src="https://habrastorage.org/webt/sn/fg/gd/snfggdwldqn3fggm4ymvhrfa_xa.png"><br><br>  f√ºhrt zu einem Ausdruck von 2 ** n Termen.  In solchen F√§llen sollte der Anwendungsentwickler √ºber die physikalische Bedeutung seiner T√§tigkeit nachdenken. Auf Seiten des SQL-Prozessors k√∂nnen Sie die Verwendung des logischen Index immer dann ablehnen, wenn die Anzahl der Konjunktionen die angemessenen Grenzwerte √ºberschreitet. <br><br><h4>  Mehrdimensionaler Indexierungsalgorithmus </h4><br>  F√ºr die mehrdimensionale Indizierung werden die Eigenschaften einer selbst√§hnlichen Nummerierungskurve verwendet, die auf hyperkubischen Simplexen mit Seite 2 basiert. Wie <a href="https://habr.com/post/464057/">sich herausstellte</a> , sind zwei Versionen solcher Kurven von praktischer Bedeutung - die Z-Kurve und die Hilbert-Kurve. <br><br><img src="https://habrastorage.org/webt/ij/pk/p2/ijpkp2sneivmayqaie38y91mylc.png" alt="Bild"><br>  <i>Abbildung 1 zweidimensionale Z-Kurve, 3 und 6 Iterationen</i> <br><br><img src="https://habrastorage.org/webt/bo/ar/oq/boaroq7scpwqyvargccwvv6i7li.png" alt="Bild"><br>  <i>Abbildung 2 zweidimensionale Hilbert-Kurve, Iterationen 3 und 6</i> <br><br><ul><li>  Ein N-dimensionaler Simplex mit Seite 2 hat 2 ** n Eckpunkte und (2 ** n-1) √úberg√§nge zwischen diesen. </li><li>  Eine elementare Iteration eines Simplex verwandelt jeden Scheitelpunkt eines Simplex in einen Simplex einer niedrigeren Ebene. </li><li>  Wenn wir die erforderliche Anzahl von Iterationen durchgef√ºhrt haben, k√∂nnen wir ein hyperkubisches Gitter beliebiger Gr√∂√üe konstruieren. </li><li>  Au√üerdem hat jeder Knoten dieses Gitters eine eigene eindeutige Nummer - den Pfad, der von Beginn an entlang der Nummerierungskurve verl√§uft.  Dar√ºber hinaus hat jeder Knoten dieses Gitters einen Wert in jeder der Koordinaten.  Tats√§chlich <u>√ºbersetzt</u> die <u>Nummerierungskurve den mehrdimensionalen Punkt in einen eindimensionalen Wert, der zum Indizieren mit einem regul√§ren B-Baum geeignet ist</u> . </li><li>  Alle Knoten, die sich in einem Simplex einer beliebigen Ebene befinden, befinden sich in demselben Intervall, und dieses Intervall schneidet sich nicht mit einem Simplex derselben Ebene. </li><li>  Daher kann jedes Suchrechteck (K√§stchen) in eine kleine Anzahl von hyperkubischen Unterabfragen unterteilt werden, in denen der Index jeweils von einer Suche / Traverse gelesen werden kann. <br></li><li>  Dazu f√ºgen wir die Magie der Low-Level-Arbeit mit dem B-Tree hinzu, um keine unn√∂tigen Anfragen zu stellen, und ... der Algorithmus ist fertig. </li></ul><br>  So funktioniert es in der Praxis: <br><br><img src="https://habrastorage.org/webt/to/hc/pq/tohcpqixfqjdnwh_hhnqlx8lgio.png"><br>  <i>Abbildung 3 Beispielsuche im zweidimensionalen Index (Z-Kurve)</i> <br><br>  Abbildung 3 zeigt die Aufteilung des urspr√ºnglichen Suchbereichs in Unterabfragen und die gefundenen Punkte.  Es wurde ein zweidimensionaler Index verwendet, der auf einer zuf√§lligen, gleichm√§√üig verteilten Menge von 100.000.000 Punkten im Umfang aufgebaut war [1.000.000, 1.000.000]. <br><br><h4>  Logischer mehrdimensionaler Index </h4><br>  Da es sich um eine mehrdimensionale Indizierung handelt, ist es an der Zeit, dar√ºber nachzudenken, wie viel mehrdimensional es sein kann.  Gibt es objektive Einschr√§nkungen? <br><br>  Da der B-Baum eine Seitenorganisation hat und ein Baum sein soll, muss sichergestellt sein, dass mindestens zwei Elemente auf die Seite passen.  Wenn Sie die Seite f√ºr 8 KB verwenden, kann das Speichern eines Elements nicht mehr als 4 KB umfassen.  In 4K passen ohne Komprimierung etwa 1000 32-Bit-Werte.  Dies ist eine Menge, √ºber die Grenzen einer vern√ºnftigen Anwendung hinaus k√∂nnen wir sagen, dass die physikalischen Grenzen praktisch nicht verf√ºgbar sind. <br><br>  Es gibt eine andere Seite, jede zus√§tzliche Dimension ist keineswegs frei, sie beansprucht Speicherplatz und verlangsamt die Arbeit.  Aus Sicht der ‚Äûphysikalischen Bedeutung‚Äú sollten Felder, die sich gleichzeitig √§ndern, in den gleichen Index aufgenommen werden, und die Suche nach ihnen geht auch zusammen.  Es hat keinen Sinn, alles in einer Reihe zu indizieren. <br><br>  Logische Felder sind unterschiedlich.  Wie wir gesehen haben, k√∂nnen Dutzende von logischen Feldern an denselben Mechanismen beteiligt sein.  Und die Speicher- / Lesekosten sind recht gering.  Es ist eine Versuchung, alle logischen Felder in einem Index zu sammeln und zu sehen, was passiert. <br><br>  Es stimmt, es gibt Nuancen: <br><br><ul><li>  Bisher wurden im indizierten Wert die Ziffern verschiedener Koordinaten gemischt, in den niedrigstwertigen Ziffern des Schl√ºssels die niedrigstwertigen Bits der Koordinaten ... Daher war die Reihenfolge der Felder w√§hrend der Indizierung unerheblich. </li><li>  Jetzt wird ein Bit zum Speichern des Wertes eines logischen Feldes ausgegeben.  Das hei√üt  Einige logische Felder werden an das Ende des Schl√ºssels und einige an den Anfang gehen.  Dies bedeutet, dass das Filtern nach einem Teil der Felder sehr effektiv und nach einigen sehr ineffizient ist.  Wenn wir in der niedrigsten Reihenfolge suchen, m√ºssen wir den gesamten Index lesen, um eine Antwort zu erhalten.  Dies ist jedoch (h√∂chstwahrscheinlich) besser, als die gesamte Tabelle zu lesen, um dieselbe Frage zu beantworten. </li><li>  Es gibt ein Problem der Wahl - alle logischen Felder sind gleich, aber einige sind gleich wie andere.  Aus allgemeinen √úberlegungen ist es notwendig, die Verzerrungen der Statistik zu betrachten. Je st√§rker das Verh√§ltnis von wahr zu falsch f√ºr ein bestimmtes Feld ist, desto √§lter ist die Entladung, in der sein Wert sein wird. </li><li>  Die Unterteilung nach der Art der Nummerierungskurve verschwindet, wenn fr√ºher zwischen der Z-Kurve und der Hilbert-Kurve gew√§hlt werden musste, gibt es bei Einzelbitdaten keinen praktischen Unterschied. </li><li>  NULLs.  Aufgrund der Tatsache, dass NULL kein unbekannter Wert ist, jedoch kein Wert vorhanden ist, sollten solche Datens√§tze nicht in den Index aufgenommen werden.  In eindimensionalen Indizes ist dies der Fall.  In unserem Fall kann sich jedoch herausstellen, dass einige der logischen Felder Werte enthalten und andere nicht.  Aus diesem Grund k√∂nnen wir dies seitdem nicht mehr in den Index aufnehmen  Der Suchalgorithmus kann nicht mit tern√§rer Logik arbeiten.  Und deshalb sollten solche Datens√§tze nicht in die Tabelle eingef√ºgt werden k√∂nnen (wenn es einen mehrdimensionalen Index gibt, √ºbrigens nicht unbedingt einen logischen). </li></ul><br>  Es wird erwartet, dass ein logischer mehrdimensionaler Index in einigen F√§llen nicht sehr effizient arbeitet.  Streng genommen kann jeder Index ineffizient arbeiten, wenn zu viele Daten in den Suchbereich fallen.  Bei einem logischen mehrdimensionalen Index wird dies jedoch durch die Abh√§ngigkeit von der oben beschriebenen Halbbildreihenfolge verst√§rkt, wenn Sie f√ºr ein kleines Ergebnis den gesamten Index lesen m√ºssen.  Soweit dies in der Praxis ein Problem darstellt, kann nur das Experiment zeigen. <br><br><h4>  Numerisches Experiment </h4><br>  Einen Index erstellen: <br><br><ul><li>  der Index wird 128-Bit sein, d.h.  Auf 128 logischen Feldern aufgebaut </li><li>  und enth√§lt 2 ** 30 Elemente </li><li>  Der Wert des Indexelements ist eine Zahl von 0 bis 2 ** 30 </li><li>  der Schl√ºssel des Indexelements wird dieselbe Zahl sein, die 48 Bits nach links verschoben ist, d.h.  Die logischen Felder 48 bis 78 werden in derselben Reihenfolge mit den Ziffern der Nummer gef√ºllt </li><li>  Als Ergebnis erhalten wir 30 signifikante logische Felder in der Mitte des Schl√ºssels, die verbleibenden Bits werden mit 0 gef√ºllt <br></li><li>  Jedes der Booleschen Felder hat die gleiche Statistik true / false </li><li>  Alle sind statistisch unabh√§ngig. </li></ul><br>  Suche: <br><br><ul><li>  Jedes Experiment entspricht der Auswahl mehrerer aufeinanderfolgender logischer Felder und der Zuweisung von Suchwerten f√ºr diese.  Nicht weil der Algorithmus nur in Streifen suchen kann, sondern weil es m√∂glich ist, die Ergebnisse des Experiments klarer darzustellen, haben wir nur zwei Dimensionen - die Breite des Streifens und seine Position </li><li>  Insgesamt 24 Versuchsreihen.  In jeder Reihe werden wir nach Werten suchen, bei denen der Streifen der logischen Felder der entsprechenden Breite N (von 1 bis 24 Bit) den Wert true annimmt. </li><li>  In jeder Reihe wird es eine Unterreihe von Experimenten geben, in denen sich ein Streifen von logischen Feldern einer ausgew√§hlten Breite mit unterschiedlichen Verschiebungen S vom Anfang des Streifens in 30 signifikante logische Felder befindet.  Insgesamt (30-N) Experimente in den Unterserien. </li><li>  In jedem Experiment wird nach allen Elementen des Index gesucht, die die Bedingung erf√ºllen, d.h.  Felder mit Zahlen im Intervall [48 + S, 48 + S + N -1] werden im Intervall [1,1] gesucht, der Rest im Intervall [0,1] <br></li><li>  Die Suche erfolgt von einem Kaltstart aus </li><li>  Das Ergebnis ist die Anzahl der gelesenen Plattenseiten, einschlie√ülich Caching (4096 Seiten-Cache). </li><li>  Die Kontrolle der korrekten Operation erfolgt auf zwei Arten: Die Anzahl der gefundenen Elemente muss 2 ** (30-N) betragen, und in den gefundenen Werten k√∂nnen Sie die entsprechenden Ziffern √ºberpr√ºfen <br></li></ul><br>  Also <br><br><img src="https://habrastorage.org/webt/1p/5a/bn/1p5abn4kb0b6myjlusbnoen308w.png"><br>  <i>Abbildung 4 Ergebnisse, die Anzahl der gelesenen Seiten in verschiedenen Serien</i> <br><br>  Mit Y - die Anzahl der gelesenen Seiten wird verschoben. <br>  Auf X - Verschiebung von Streifen von der j√ºngsten (48) Kategorie zum Senior.  Streifen unterschiedlicher Breite sind farblich signiert und gekennzeichnet. <br><br><img src="https://habrastorage.org/webt/lf/t0/7x/lft07xucczbi19oxdskdrvzb-ia.png"><br>  <i>Abbildung 5 Die gleichen Daten wie in Abbildung 4, eine andere Ansicht</i> <br><br>  X - Bandverschiebung <br>  Y - Bandbreite <br><br>  Was ist zu beachten: <br><br><ul><li>  Obwohl dies in den Bildern nicht direkt sichtbar ist, funktioniert der Index ordnungsgem√§√ü. Er ist sowohl in der Anzahl der gefundenen Elemente als auch im Inhalt der Elemente selbst sichtbar </li><li>  Alle Streifen mit einer Breite von nicht mehr als 10 mit einer Verschiebung von 0 erfordern ein kontinuierliches Lesen des Index </li><li>  Streifen mit einer Breite von 1 bis 18 mit einer Zunahme der Verschiebung erreichen die Asymptote 2 ** (- N) der Gr√∂√üe des gesamten Index, was logisch ist </li><li>  F√ºr breitere Bereiche der Asymptote - die H√∂he des Baumes - kann es nicht weniger Messwerte geben </li><li>  Etwas mehr als 1000 Elemente sind auf der Blattseite des Index platziert. Dies ist in einem Streifen mit der Breite 10 zu sehen. Wenn beim Verschieben von 0 nicht mehr der gesamte Index gelesen werden muss, k√∂nnen einige Seiten √ºbersprungen werden </li><li>  Low-Level-Filterung funktioniert √ºberraschend gut.  Stellen Sie sich einen Streifen mit einer Breite von 10 vor. Eine ideale Suchoption ist eine Verschiebung von 20 (insgesamt 30 signifikante Felder). Wenn das Pr√§fix keine undefinierten Felder enth√§lt, k√∂nnen die Daten mit einem einzelnen Strahl gefunden werden.  In dieser Situation wird ungef√§hr 1/1000 des Index w√§hrend der Suche gelesen - 779 Seiten. <br>  Der Zwischenfall ist eine Verschiebung von 10, wir haben ein Pr√§fix und ein Suffix von 10 unbekannten Feldern.  Die Seitenzahl betr√§gt 2484, nur dreimal so viel wie im Idealfall. <br>  Und selbst im schlimmsten Fall k√∂nnen Sie mit einer Verschiebung von 0 (einem Pr√§fix von 20 unbekannten Feldern) einige Seiten √ºberspringen. </li></ul><br>  Insgesamt kann der mehrdimensionale Indexierungsalgorithmus auch in einem solchen absurden Fall als effizient angesehen werden.  <u>Die aus Sicht des logischen Index erfolgloseste Option wird jedoch in Betracht gezogen - gleichwahrscheinliche Zust√§nde in allen unabh√§ngigen logischen Feldern.</u> <br><br><h4>  Experimentieren Sie mit realen Daten </h4><br>  Handelstabelle, insgesamt 278.479.918 Zeilen, Daten aus einer der Testschleifen. <br>  Die Ergebnisse einiger Abfragen in der folgenden Tabelle: <br><br><div class="scrollable-table"><table><tbody><tr><th>  N </th><th>  Anfrage </th><th>  Die Anzahl der Zeilen als Ergebnis </th><th>  Seiten lesen </th></tr><tr><td>  1 </td><td align="right">  IsProcessed == 0 &amp;&amp; NullStatus == 0 </td><td align="right">  6,273 </td><td align="right">  9 </td></tr><tr><td>  2 </td><td align="right">  IsProcessed == 0 &amp;&amp; NullStatus == 0 &amp;&amp; IsCoverage == 0 </td><td align="right">  6,273 </td><td align="right">  9 </td></tr><tr><td>  3 </td><td align="right">  IsCoverage == 1 &amp;&amp; QF_ICEBERG == 1 </td><td align="right">  1 388 128 </td><td align="right">  386 </td></tr><tr><td>  4 </td><td align="right">  PutStatus == 1 &amp;&amp; PayStatus == 0 </td><td align="right">  61 788 376 </td><td align="right">  16.486 </td></tr><tr><td>  5 </td><td align="right">  IsProcessed == 1 &amp;&amp; NullStatus == 0 &amp;&amp; <br>  QF_CURR_PFI == 0 &amp;&amp; QF_TERMINATION == 0 </td><td align="right">  278 473 645 </td><td align="right">  74,285 </td></tr><tr><td>  6 </td><td align="right">  IsProcessed == 1 &amp;&amp; PutStatus == 0 &amp;&amp; <br>  IsCoverage == 1 <br></td><td align="right">  1 650 240 </td><td align="right">  447 </td></tr><tr><td>  7 </td><td align="right">  QF_UNK3 == 0 &amp;&amp; QF_UNK4 == 0 </td><td align="right">  23,392 </td><td align="right">  19 </td></tr></tbody></table></div><br>  Das Lesen / Verarbeiten einer einzelnen Seite dauert durchschnittlich 0,8 ms. <br><br>  Es ist nicht erforderlich, die Bedeutung bestimmter Abfragen zu beschreiben. Sie dienen lediglich der Veranschaulichung der Bedienbarkeit.  Was √ºbrigens best√§tigt wird. <br><br>  Aber bevor diese Technik von praktischem Nutzen sein kann, bleibt noch viel zu tun.  Also, weiter so. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483056/">https://habr.com/ru/post/de483056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483042/index.html">9 Tipps zur Vue-Leistung</a></li>
<li><a href="../de483048/index.html">Terminal Fun: 10 klassische Konsolenwitze</a></li>
<li><a href="../de483050/index.html">Top 5 ReactJS Entwicklungsunternehmen</a></li>
<li><a href="../de483052/index.html">Pyramide statt Kugel: Nichtstandardisierte Anh√§ufung von Goldatomen</a></li>
<li><a href="../de483054/index.html">"Es wird kein Massaker geben" - die Geschichte der √úbersetzung von The Worm</a></li>
<li><a href="../de483058/index.html">Ergebnisse der Urlaubsumfrage</a></li>
<li><a href="../de483064/index.html">Vue f√ºr den kleinsten aka kleinen Blog auf allen Kanonen</a></li>
<li><a href="../de483066/index.html">Die traditionellen 5 B√ºcher von Bill Gates</a></li>
<li><a href="../de483068/index.html">Reverse Engineering des beliebten Anti-Cheat BattlEye</a></li>
<li><a href="../de483074/index.html">TensorRT 6.xxx - Hochleistungsinferenz f√ºr Deep-Learning-Modelle (Objekterkennung und -segmentierung)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>