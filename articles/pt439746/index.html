<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôçüèΩ üôèüèΩ üëî Compreendendo as promessas de JavaScript üë∂üèº üî© üìá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bom dia, Habr! Apresento a voc√™ a tradu√ß√£o do artigo ‚ÄúEntendendo promessas em JavaScript‚Äù, de Sukhjinder Arora. 



 Do autor da tradu√ß√£o: Assim como ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compreendendo as promessas de JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439746/">  Bom dia, Habr!  Apresento a voc√™ a tradu√ß√£o do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúEntendendo promessas em JavaScript‚Äù,</a> de Sukhjinder Arora. <br><br><img src="https://habrastorage.org/webt/ox/6m/oa/ox6moan9gwhmc2oouqbhyfzumtm.png"><br><a name="habracut"></a><br>  <i>Do autor da tradu√ß√£o: Assim como o pr√≥prio autor, espero que o artigo tenha sido √∫til para voc√™.</i>  <i>Por favor, se ela realmente ajudou voc√™ a aprender algo novo para si mesmo, n√£o tenha pregui√ßa de ir ao artigo original e agrade√ßa ao autor!</i>  <i>Ficarei feliz em seu feedback!</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link para a tradu√ß√£o do artigo sobre JavaScript ass√≠ncrono do mesmo autor</a> .</i> <br><br>  JavaScript √© uma linguagem de programa√ß√£o de thread √∫nico, o que significa que uma coisa pode ser feita por vez.  Antes do ES6, usamos retornos de chamada para gerenciar tarefas ass√≠ncronas, como solicita√ß√£o de rede. <br><br>  Usando promessas, podemos evitar o "inferno de retorno de chamada" e tornar nosso c√≥digo mais limpo, mais leg√≠vel e mais f√°cil de entender. <br><br>  Suponha que desejemos obter alguns dados do servidor de forma ass√≠ncrona, usando retornos de chamada, far√≠amos algo assim: <br><br><pre><code class="javascript hljs">getData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); getMoreData(x, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); getSomeMoreData(y, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); }); }); });</code> </pre> <br>  Aqui, solicito alguns dados do servidor usando a fun√ß√£o <i>getData ()</i> , que recebe dados dentro da fun√ß√£o de retorno de chamada.  Dentro da fun√ß√£o de retorno de chamada, solicito dados adicionais chamando a fun√ß√£o <i>getMoreData ()</i> , passando os dados anteriores como argumento e assim por diante. <br><br>  √â o que chamamos de "inferno de retorno de chamada", onde cada retorno de chamada √© aninhado dentro do outro, e cada retorno de chamada interno depende de seu pai. <br><br>  Podemos reescrever o snippet acima usando promessas: <br><br><pre> <code class="javascript hljs">getData() .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMoreData(x); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getSomeMoreData(y); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); });</code> </pre> <br>  Voc√™ pode ver o que ficou mais leg√≠vel do que no primeiro exemplo de retorno de chamada. <br><br><h2>  O que s√£o promessas? </h2><br>  Uma promessa (promessa) √© um objeto que cont√©m o valor futuro de uma opera√ß√£o ass√≠ncrona.  Por exemplo, se voc√™ solicitar alguns dados do servidor, a Promis promete que receberemos esses dados, que poderemos usar no futuro. <br><br>  Antes de mergulhar em todas essas coisas t√©cnicas, vejamos a terminologia das promessas. <br><br><h3>  Estados da promessa </h3><br>  Uma promessa em JavaScript, como uma promessa na vida real, tem tr√™s estados.  Isso pode ser 1) n√£o resolvido (pendente), 2) resolvido / resolvido (conclu√≠do) ou 3) rejeitado / rejeitado. <br><br><img src="https://habrastorage.org/webt/pk/hr/zz/pkhrzzgtdsgqvtptwn26gmtbjhk.png"><br><br>  <b>N√£o resolvido ou pendente</b> - Promis aguarda se o resultado n√£o estiver pronto.  Ou seja, espera a conclus√£o de algo (por exemplo, a conclus√£o de uma opera√ß√£o ass√≠ncrona). <br>  <b>Resolvido ou conclu√≠do</b> - Promis resolvido se o resultado estiver dispon√≠vel.  Ou seja, algo concluiu sua execu√ß√£o (por exemplo, uma opera√ß√£o ass√≠ncrona) e tudo correu bem. <br>  <b>Rejeitado</b> - Promis rejeitado se ocorrer um erro durante a execu√ß√£o. <br><br>  Agora que sabemos o que √© Promis e sua terminologia, voltemos √† parte pr√°tica das promessas. <br><br><h3>  Criar Promis </h3><br>  Na maioria dos casos, voc√™ simplesmente usa promessas, n√£o as cria, mas ainda √© importante saber como elas s√£o criadas. <br><br>  Sintaxe: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... });</code> </pre> <br>  Criamos uma nova promessa usando o construtor Promises, √© necess√°rio um argumento, um retorno de chamada, tamb√©m conhecido como fun√ß√£o executiva, que recebe 2 retornos de chamada, <i>resolve</i> e <i>rejeita</i> . <br><br>  A fun√ß√£o executiva √© executada imediatamente ap√≥s a cria√ß√£o da promessa.  Uma promessa √© feita chamando <i>resolve ()</i> e rejeitada por <i>rejeitar ()</i> .  Por exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(allWentWell) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>); } });</code> </pre> <br>  <i>resolve ()</i> e <i>rejeita ()</i> usam um argumento, que pode ser uma sequ√™ncia, um n√∫mero, uma express√£o l√≥gica, uma matriz ou um objeto. <br><br>  Vamos dar uma olhada em outro exemplo para entender completamente como as promessas s√£o criadas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.6</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>); } }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); });</code> </pre> <br>  Aqui, criei uma nova promessa usando o construtor Promis.  Uma promessa √© executada ou rejeitada 2 segundos ap√≥s a sua cria√ß√£o.  Uma promessa √© executada se <i>randomNumber for</i> menor que 0,6 e rejeitada em outros casos. <br><br>  Quando uma promessa for criada, ela ficar√° pendente e seu valor ser√° <i>indefinido</i> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/wr/c2/cswrc2jdrixhaguff2w9oijiyf4.png"></div><br>  Ap√≥s 2 segundos, o cron√¥metro termina, a promessa √© executada ou rejeitada aleatoriamente e seu valor ser√° aquele passado para a fun√ß√£o de <i>resolu√ß√£o</i> ou <i>rejei√ß√£o</i> .  Abaixo est√° um exemplo de dois casos: <br><br>  Conclus√£o bem sucedida: <br><br><img src="https://habrastorage.org/webt/eq/3y/ss/eq3ysskatvuvjnvpoaz9k7zdmvi.png"><br><br>  Promessa de rejei√ß√£o: <br><br><img src="https://habrastorage.org/webt/qn/7v/ee/qn7vee1ebi19qgo4zzv72tgpfjg.png"><br><br>  <b>Nota: A</b> promessa pode ser executada ou rejeitada apenas uma vez.  Outras chamadas para <i>resolver ()</i> ou <i>rejeitar ()</i> n√£o afetar√£o o estado da promessa de forma alguma.  Um exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise resolved'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   reject('Promise rejected'); //       });</span></span></code> </pre> <br>  Desde que <i>resolve ()</i> foi chamado primeiro, a promessa agora tem o status "conclu√≠do".  A chamada subsequente para <i>rejeitar ()</i> n√£o afetar√° o estado da promessa de forma alguma. <br><br><h3>  Usando Promis </h3><br>  Agora sabemos como criar promessas, agora vamos descobrir como aplicar a promessa j√° criada.  Usamos promessas usando os m√©todos <i>then ()</i> e <i>catch ()</i> . <br><br>  Por exemplo, consultar dados de uma API usando <i>busca</i> , o que retorna uma promessa. <br><br>  <b>Sintaxe</b> <i>.then</i> <i>()</i> <b>:</b> <i>promessa.then (successCallback, failCallback)</i> <br><br>  <i>successCallback</i> √© chamado se a promessa foi executada com sucesso.  √â preciso um argumento, que √© o valor passado para <i>resolver ()</i> . <br><br>  <i>failCallback</i> √© chamado se a promessa foi rejeitada.  √â preciso um argumento, que √© o valor dado para <i>rejeitar ()</i> . <br><br>  Um exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.7</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>)); } }); promise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">//  '  !' }, (error) =&gt; { console.log(error); //   } );</span></span></code> </pre> <br>  Se a promessa foi executada, <i>successCallback</i> √© <i>chamado</i> com o valor passado para <i>resolve ()</i> .  E se a promessa foi rejeitada, <i>failCallback</i> √© <i>chamado</i> com o valor passado para rejeitar (). <br><br>  <i>Sintaxe .catch ()</i> <b>:</b> <i>promessa.catch (failCallback)</i> <br><br>  Usamos <i>catch ()</i> para lidar com erros.  Isso √© mais leg√≠vel do que o tratamento de erros dentro de <i>failCallback</i> dentro do retorno de chamada do m√©todo <i>then ()</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>)); }); promise .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); }) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); <span class="hljs-comment"><span class="hljs-comment">//   });</span></span></code> </pre> <br><h3>  Promise Chain </h3><br>  Os m√©todos <i>then ()</i> e <i>catch ()</i> tamb√©m podem retornar uma nova promessa, que pode ser processada por uma cadeia de outros then () no final do m√©todo then () anterior. <br><br>  Usamos uma cadeia de promessas quando queremos concluir uma sequ√™ncia de promessas. <br><br>  Por exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise3 '</span></span>); }); promise1 .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// Promise1  return promise2; }) .then((data) =&gt; { console.log(data); // Promise2  return promise3; }) .then((data) =&gt; { console.log(data); }) .catch((error) =&gt; { console.log(error); // Promise3  });</span></span></code> </pre> <br><h4>  Ent√£o, o que est√° acontecendo aqui? </h4><br>  Quando a <i>promessa1 √©</i> cumprida, o m√©todo <i>then ()</i> √© chamado <i>,</i> que retorna a promessa2. <br>  Em seguida, quando a <i>promessa2</i> √© <i>cumprida</i> , <i>()</i> √© chamada novamente e retorna a <i>promessa3</i> . <br><br>  Como promessa3 √© rejeitada, em vez do pr√≥ximo <i>()</i> , <i>catch ()</i> √© chamado, que lida com a rejei√ß√£o da <i>promessa3</i> . <br><br>  <b>Nota:</b> Como regra, um m√©todo <i>catch ()</i> √© suficiente para lidar com a rejei√ß√£o de qualquer uma das promessas da cadeia, se esse m√©todo estiver no final dele. <br><br><h4>  Erro comum </h4><br>  Muitos iniciantes cometem um erro investindo algumas promessas dentro de outras.  Por exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise3 '</span></span>); }); promise1.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// Promise1  promise2.then((data) =&gt; { console.log(data); // Promise2  promise3.then((data) =&gt; { console.log(data); }).catch((error) =&gt; { console.log(error); // Promise3  }); }).catch((error) =&gt; { console.log(error); }) }).catch((error) =&gt; { console.log(error); });</span></span></code> </pre> <br>  Embora isso funcione bem, √© considerado um estilo ruim e torna o c√≥digo menos leg√≠vel.  Se voc√™ tiver uma sequ√™ncia de promessas a executar, ser√° melhor coloc√°-las uma ap√≥s a outra do que colocar uma dentro da outra. <br><br><h3>  Promise.all () </h3><br>  Esse m√©todo aceita uma matriz de promessas e retorna uma nova promessa que ser√° executada quando todas as promessas dentro da matriz forem executadas ou rejeitadas assim que uma promessa rejeitada for encontrada.  Por exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error));</code> </pre> <br>  Aqui, o argumento dentro de <i>then ()</i> √© uma matriz que cont√©m os valores das promessas na mesma ordem em que foram passadas para <i>Promise.all ()</i> . (Somente se todas as promessas forem executadas) <br><br>  A promessa √© rejeitada com a causa da rejei√ß√£o da primeira promessa na matriz transferida.  Por exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)); <span class="hljs-comment"><span class="hljs-comment">// Promise2 </span></span></code> </pre> <br>  Aqui temos duas promessas, onde uma √© executada ap√≥s 2 segundos e a outra se desvia ap√≥s 1,5 segundos.  Assim que a segunda promessa √© rejeitada, a <i>promessa</i> retornada de <i>Promise.all ()</i> √© rejeitada sem aguardar a primeira. <br><br>  Esse m√©todo pode ser √∫til quando voc√™ possui mais de uma promessa e deseja saber quando todas as promessas foram conclu√≠das.  Por exemplo, se voc√™ solicitar dados de uma API de terceiros e desejar fazer algo com esses dados somente quando todas as solicita√ß√µes forem bem-sucedidas. <br><br>  Como resultado, temos <i>Promise.all ()</i> , que aguarda a execu√ß√£o bem-sucedida de todas as promessas, ou conclui sua execu√ß√£o quando detecta a primeira falha na matriz de promessas. <br><br><h3>  Promise.race () </h3><br>  Esse m√©todo aceita uma matriz de promessas e retorna uma nova promessa que ser√° executada assim que a promessa cumprida na matriz for atendida ou rejeitada se a promessa rejeitada ocorrer anteriormente.  Por exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data)) <span class="hljs-comment"><span class="hljs-comment">// Promise1  .catch((error) =&gt; console.log(error));</span></span></code> </pre> <br>  Aqui temos duas promessas, onde uma √© executada ap√≥s 1 segundo e a outra se desvia ap√≥s 1,5 segundos.  Assim que a primeira promessa for cumprida, a promessa retornada de Promise.race () ter√° o status cumprido sem aguardar o status da segunda promessa. <br><br>  Aqui, os <i>dados</i> que s√£o passados ‚Äã‚Äãpara <i>then ()</i> s√£o o valor da primeira promessa executada. <br><br>  Como resultado, <i>Promise.race ()</i> aguarda a primeira promessa e assume seu status como o status da promessa retornada. <br><br>  <i>Coment√°rio do autor da tradu√ß√£o: Da√≠ o pr√≥prio nome.</i>  <i>Corrida - Corrida</i> <br><br><h2>  Conclus√£o </h2><br>  Aprendemos o que s√£o promessas e o que elas comem em JavaScript.  As promessas consistem em duas partes: 1) Crie uma promessa e 2) Use uma promessa.  Na maioria das vezes, voc√™ usar√° promessas em vez de cri√°-las, mas √© importante saber como elas s√£o criadas. <br><br>  S√≥ isso, espero que este artigo tenha sido √∫til para voc√™! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439746/">https://habr.com/ru/post/pt439746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439734/index.html">Implantando o Kubernetes na √°rea de trabalho em minutos com o MicroK8s</a></li>
<li><a href="../pt439736/index.html">Conex√£o VPN IPSec entre MikroTik e Kerio Control</a></li>
<li><a href="../pt439738/index.html">Em busca do bot√£o "Fa√ßa bem". Zyxel na rede de pequenas e m√©dias empresas</a></li>
<li><a href="../pt439742/index.html">Admiss√£o ao programa de mestrado JetBrains na Universidade ITMO</a></li>
<li><a href="../pt439744/index.html">Pesquisadores do MIT projetaram ‚Äúretenas‚Äù que convertem sinais Wi-Fi em eletricidade</a></li>
<li><a href="../pt439748/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel 285 (de 4 a 10 de fevereiro)</a></li>
<li><a href="../pt439750/index.html">Aprenda gerenciamento de produtos - onde?</a></li>
<li><a href="../pt439752/index.html">RM multicore</a></li>
<li><a href="../pt439754/index.html">Google vai come√ßar a desenvolver rel√≥gios inteligentes</a></li>
<li><a href="../pt439756/index.html">Por que preciso de um gerador termoac√∫stico?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>