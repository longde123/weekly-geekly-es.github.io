<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ≥Ô∏è üôÖüèª ‚õ∞Ô∏è Retiramos o software do microcontrolador protegido por senha Renesas M16C üòü üë©üèΩ‚Äçüç≥ üëµüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu tenho um amigo que est√° envolvido na repara√ß√£o de ferro automotivo. De alguma forma, ele me trouxe um microcontrolador soldado de uma unidade de co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Retiramos o software do microcontrolador protegido por senha Renesas M16C</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469085/"><img src="https://habrastorage.org/webt/-f/lc/co/-flcco15l02rsp0smi3ha4ov224.jpeg"><br><br>  Eu tenho um amigo que est√° envolvido na repara√ß√£o de ferro automotivo.  De alguma forma, ele me trouxe um microcontrolador soldado de uma unidade de controle de aquecedor aut√¥nomo.  Ele disse que seu programador n√£o aceita e gostaria de poder transferir o firmware para frente e para tr√°s, porque  existem muitos blocos; no ferro, eles geralmente s√£o os mesmos, mas as unidades que controlam s√£o diferentes.  E parece que existe um bloco em vez de um com defeito, mas o software √© diferente e voc√™ simplesmente n√£o pode substitu√≠-lo.  Como a tarefa era interessante, decidi vasculhar.  Se o t√≥pico √© interessante para voc√™, por favor, sob o gato ... <a name="habracut"></a><br><br>  O sujeito era M306N5FCTFP.  Este √© um microcontrolador do grupo M16C / 6N5.  O n√∫cleo M16C / 60 foi desenvolvido pela Mitsubishi e, como  Desde 2003, o sucessor desta empresa em termos de MK √© Renesas, agora esses microcontroladores s√£o conhecidos sob esta marca. <br><br><h4>  Um pouco sobre o pr√≥prio microcontrolador </h4><br>  O seixo √© um microcontrolador de 16 bits em um pacote QFP de 100 pinos.  O kernel possui 1 MB de espa√ßo de endere√ßo, uma frequ√™ncia de clock de 20 MHz para desempenho automotivo.  O conjunto de perif√©ricos tamb√©m √© muito extenso: dois temporizadores de 16 bits e a possibilidade de gerar um PWM trif√°sico para controle do motor, todos os tipos de UART, SPI, I2C naturalmente, 2 canais DMA, existe um controlador CAN2.0B integrado e um PLL.  Na minha opini√£o, √© muito bom para o velho.  Aqui est√° um gr√°fico de vis√£o geral da documenta√ß√£o: <br><br><img src="https://habrastorage.org/webt/mb/we/0z/mbwe0zgfqxwxd2ihcirztjtepqg.png"><br><br>  Como minha tarefa √© extrair o software, ele tamb√©m est√° muito interessado em mem√≥ria.  Este MK foi produzido em duas vers√µes: mascarado e Flash.  Consegui, como mencionado acima, o M306N5FCTFP.  Sobre ele, a descri√ß√£o diz o seguinte: <br><br><ul><li>  Vers√£o em mem√≥ria flash </li><li>  128 KBytes + 4K (4K adicional - o chamado bloco A como um presente para o usu√°rio armazenar dados, mas tamb√©m pode armazenar o programa) </li><li>  V-ver.  (vers√£o automotiva com faixa de + 125 ¬∞ C) </li></ul><br><h4>  Como retirar do dispositivo o que os desenvolvedores arrastaram </h4><br>  √â natural que voc√™ comece a tentar obter algo do microcontrolador estudando os mecanismos integrados pelo desenvolvedor do chip para tarefas de programa√ß√£o de mem√≥ria.  O manual declara que o fabricante gentilmente colocou um gerenciador de inicializa√ß√£o na mem√≥ria para as necessidades de programa√ß√£o em circuito do dispositivo. <br><br><img src="https://habrastorage.org/webt/q6/yq/ol/q6yqolkgde-5fd6fdcwm_y6skc8.png"><br><br>  Como voc√™ pode ver na figura acima, a mem√≥ria √© dividida em 2 partes: a √°rea do usu√°rio e a √°rea do carregador de inicializa√ß√£o.  No segundo, um carregador de inicializa√ß√£o padr√£o √© carregado de f√°brica, que pode gravar, ler, apagar a mem√≥ria do usu√°rio e se comunicar por meio de uma interface ass√≠ncrona, s√≠ncrona ou CAN.  √â indicado que ele pode ser reescrito por conta pr√≥pria ou n√£o pode ser reescrito.  No final, isso √© facilmente verificado tentando bater no carregador de inicializa√ß√£o padr√£o pelo menos atrav√©s do UART ... Olhando para o futuro: o fabricante do aquecedor n√£o se incomodou com o carregador de inicializa√ß√£o, para que voc√™ possa ir mais longe nessa dire√ß√£o.  Fa√ßa imediatamente a reserva de que ainda existe um m√©todo de programa√ß√£o paralelo, mas desde  Eu n√£o tinha um programador para isso, n√£o considerei essa op√ß√£o. <br><br>  A entrada no modo de opera√ß√£o do carregador de inicializa√ß√£o √© fornecida por uma certa combina√ß√£o nas entradas CNVSS, P5_0, P5_5 durante uma redefini√ß√£o de hardware.  Em seguida, escreva seu pr√≥prio utilit√°rio para copiar o conte√∫do da mem√≥ria ou use o finalizado.  A Renesas fornece seu pr√≥prio utilit√°rio, chamado "M16C Flash Starter", mas possui uma fun√ß√£o de leitura reduzida.  Ele n√£o salva o que l√™ no disco, mas o compara com um arquivo do disco.  I.e.  de fato, isso n√£o √© leitura, mas verifica√ß√£o.  No entanto, existe um utilit√°rio gratuito alem√£o chamado M16C-Flasher, que pode ler o firmware.  Em geral, o kit de ferramentas inicial foi escolhido. <br><br><h4>  Sobre a prote√ß√£o de leitura </h4><br><img src="https://habrastorage.org/webt/oe/zd/-l/oezd-l9m2zan5js3uwr0obomgta.png"><br><br>  Tudo seria bem simples se o gerenciador de inicializa√ß√£o n√£o fornecesse prote√ß√£o contra acesso n√£o autorizado.  Vou apenas dar uma tradu√ß√£o muito livre do manual. <br><br>  <i>Fun√ß√£o de verifica√ß√£o de ID</i> <i><br><br></i>  <i>Usado nos modos de troca serial e CAN.</i>  <i>O identificador transmitido pelo programador √© comparado com o identificador gravado na mem√≥ria flash.</i>  <i>Se os identificadores n√£o corresponderem, os comandos enviados pelo programador n√£o ser√£o aceitos.</i>  <i>No entanto, se 4 bytes do vetor de redefini√ß√£o forem FFFFFFFFh, os identificadores n√£o ser√£o comparados, permitindo que todos os comandos sejam executados.</i>  <i>O identificador √© de 7 bytes armazenados sequencialmente, iniciando no primeiro byte, nos endere√ßos 0FFFDFh, 0FFFE3h, 0FFFEBh, 0FFFEFh, 0FFFF3h, 0FFFF7h e 0FFFFBh.</i> <br><br>  Assim, para acessar o programa, voc√™ precisa conhecer os 7 bytes estimados.  Mais uma vez, olhando para o futuro, conectei ao MK usando o mesmo ‚ÄúM16C Flash Starter‚Äù e certifiquei-me de que combina√ß√µes de zeros e FF n√£o funcionassem, e esse problema teria que ser resolvido de alguma forma.  Uma ideia com um ataque atrav√©s de canais de terceiros veio √† tona imediatamente aqui.  J√° comecei a fingir ser um len√ßo na cabe√ßa, o que me permite medir a corrente no circuito el√©trico, mas decidi que a Internet √© grande e a maioria das bicicletas j√° foi inventada.  Ap√≥s algumas pesquisas, rapidamente encontrei no hackaday.io o projeto Serge 'q3k' Bazanski, intitulado ‚ÄúEngenharia reversa Toshiba R100 BIOS‚Äù.  E dentro da estrutura deste projeto, o autor resolveu essencialmente exatamente o mesmo problema: extra√ß√£o de firmware do MK M306K9FCLR.  Al√©m disso - naquela √©poca a tarefa j√° havia sido resolvida com sucesso por ele.  Por um lado, fiquei um pouco chateado - um enigma interessante n√£o foi resolvido por mim.  Por outro lado, a tarefa passou de uma busca por vulnerabilidade para sua explora√ß√£o, que prometeu uma solu√ß√£o muito mais r√°pida. <br><br>  Em poucas palavras, q3k, exatamente pela mesma l√≥gica, iniciou o estudo com uma an√°lise do consumo atual; nesse sentido, estava em condi√ß√µes muito mais favor√°veis, porque  ele tinha ChipWhisperer, eu ainda n√£o tenho essa coisa.  Mas desde  sua primeira sonda para remover a corrente de consumo se mostrou inadequada e ele n√£o conseguiu isolar algo √∫til do barulho, decidiu tentar um ataque simples ao tempo de resposta.  O fato √© que o carregador de inicializa√ß√£o extrai a sa√≠da OCUPADA durante a execu√ß√£o do comando para informar ao host que est√° ocupado ou est√° pronto para executar o pr√≥ximo comando.  De acordo com a suposi√ß√£o de q3k, medir o tempo entre a transmiss√£o do √∫ltimo bit do identificador e a remo√ß√£o do sinalizador ocupado pode servir como fonte de informa√ß√µes durante a enumera√ß√£o.  Ao verificar essa suposi√ß√£o enumerando o primeiro byte da chave, um desvio de tempo foi realmente encontrado em apenas um caso - quando o primeiro byte era igual a FFh.  Para a conveni√™ncia do tempo de medi√ß√£o, o autor at√© diminuiu a velocidade do MK, desligando o ressonador de quartzo e aplicando uma onda quadrada de 666 kHz √† entrada do rel√≥gio para simplificar o procedimento de medi√ß√£o.  Depois disso, o identificador foi selecionado com sucesso e o software foi recuperado. <br><br><h4>  A primeira panqueca - um ancinho </h4><br>  Ha!  Eu pensei ... Agora, rapidamente rebitei o programa para o meu STM32VLDiscovery c STM32F100 a bordo, que enviar√° o c√≥digo e medir√° o tempo de resposta, e cuspir os resultados da medi√ß√£o no terminal.  Porque  A placa de ensaio com o controlador de destino foi conectada anteriormente ao PC atrav√©s do adaptador USB-UART. Para n√£o alterar nada na placa de ensaio, trabalharemos no modo ass√≠ncrono. <br><br><img src="https://habrastorage.org/webt/4h/j0/ex/4hj0ext4dvwval--yospml-loso.png"><br><br>  Quando, no in√≠cio do carregador de inicializa√ß√£o, a entrada CLK1 √© puxada para o ch√£o, ele percebe que eles querem comunica√ß√£o ass√≠ncrona dele.  Foi por isso que o usei - o suspender j√° estava soldado e eu apenas conectei as duas placas com os fios: Discovery e a placa de ensaio com o alvo M306. <br><br>  <i>Nota sobre a harmoniza√ß√£o de n√≠veis:</i> <i><br><br></i>  <i>Porque</i>  <i>Como o M16 possui n√≠veis de TTL nos terminais e o STM32 possui LVTTL (simplificado, consulte a folha de dados para obter detalhes), a correspond√™ncia de n√≠veis √© necess√°ria.</i>  <i>Porque</i>  <i>este n√£o √© um dispositivo que, como uma bateria conhecida, funcione, funcione e funcione, mas, na verdade, ele se conecta uma vez na mesa, ent√£o eu n√£o me incomodei com tradutores de n√≠vel: os n√≠veis de sa√≠da digeridos de cinco volts do STM32, no sentido de 3 volts, percebidos como "1" , as sa√≠das do M16 s√£o alimentadas nas entradas tolerantes a 5V do STM32, para que n√£o pare√ßam ruins, e n√£o esquecemos de colocar a perna que puxa o RESET M16 no modo de dreno aberto.</i>  <i>Eu esqueci, e isso √© + 2 horas para o cofrinho do tempo perdido.</i> <i><br></i>  <i>Esse m√≠nimo √© suficiente para entender as gl√¢ndulas um do outro.</i> <br><br>  A l√≥gica do software atacante √© a seguinte: <br><br><ol><li>  Estabelecemos uma conex√£o com o controlador.  Para fazer isso, voc√™ deve esperar at√© que a redefini√ß√£o seja conclu√≠da e transmitir 16 caracteres zero com um intervalo de mais de 20 ms.  Isso √© para elaborar o algoritmo para determinar automaticamente a taxa de c√¢mbio, porque  a interface √© ass√≠ncrona e o MK n√£o sabe nada sobre sua frequ√™ncia.  A velocidade inicial do transmissor deve ser 9600 baud, √© nessa velocidade que o carregador calcula.  Depois disso, se desejar, voc√™ pode solicitar uma taxa de c√¢mbio diferente de cinco dispon√≠vel no intervalo 9600-115200 (embora, no meu caso, o carregador tenha se recusado a trabalhar no 115200).  Como n√£o preciso alterar a velocidade, solicitei apenas a vers√£o do gerenciador de inicializa√ß√£o para controlar a sincroniza√ß√£o.  Passamos FBh, o carregador responde com uma linha como "VER.1.01". <br></li><li>  Enviamos o comando ‚Äúunlock‚Äù, que cont√©m a itera√ß√£o atual da chave, e medimos o tempo at√© que o sinalizador de ocupado seja apagado. <br><img src="https://habrastorage.org/webt/wg/qh/ne/wgqhnehwy7ycyxmwenvyx0n2lwk.png"><br>  O comando consiste no c√≥digo F5h, tr√™s bytes do endere√ßo onde a √°rea do identificador come√ßa (no meu caso, para o kernel M16C, √© 0FFFDFh), comprimento (07h) e o pr√≥prio identificador. <br></li><li>  Medimos o tempo entre a transmiss√£o do √∫ltimo bit do identificador e a remo√ß√£o do sinalizador de ocupado. <br></li><li>  Aumentamos o byte de chave que est√° sendo classificado (KEY1 no est√°gio inicial), retornamos √† etapa 2 at√© classificarmos todos os 255 valores do byte atual. <br></li><li>  Redefinimos as estat√≠sticas para o terminal (bem, ou realizamos a an√°lise "a bordo"). <br></li></ol><br>  Para se comunicar com o MK de destino, usei o USART no STM32, para medir o tempo - um temporizador no modo de captura de entrada.  A √∫nica coisa, por simplicidade, n√£o medi o tempo entre o √∫ltimo bit da chave e a remo√ß√£o da bandeira, mas entre o in√≠cio da transmiss√£o e a bandeira.  O motivo foi que o √∫ltimo bit p√¥de mudar e, no modo ass√≠ncrono, n√£o havia nada a ser anexado √† entrada de captura.  Ao mesmo tempo, o UART √© hardware e o tempo de transmiss√£o √© basicamente id√™ntico e n√£o deve haver erros tang√≠veis. <br><br>  Como resultado, para todos os valores, os resultados foram id√™nticos.  Completamente id√™ntico.  A frequ√™ncia do rel√≥gio do temporizador foi de 24 MHz, respectivamente, a resolu√ß√£o de tempo √© de 41,6 ns.  Bem, ok, tentei desacelerar o alvo MK.  Nada mudou.  Aqui surgiu a pergunta na minha cabe√ßa: o que estou fazendo de errado, como o q3k fez?  Ap√≥s a compara√ß√£o, a diferen√ßa foi encontrada: ele usa uma interface de troca s√≠ncrona (SPI) e eu sou ass√≠ncrono (UART).  E em algum lugar aqui, chamei a aten√ß√£o para o momento que perdi no in√≠cio.  Mesmo nos diagramas de fia√ß√£o para modos de carregador de inicializa√ß√£o s√≠ncrono e ass√≠ncrono, a sa√≠da pronta √© nomeada de forma diferente: <br><br><img src="https://habrastorage.org/webt/d0/js/gb/d0jsgbifm7vo1jgbypc70elfoqu.png"><br><br>  Em s√≠ncrono √© "OCUPADO", em ass√≠ncrono √© "Monitor".  Examinamos a tabela "Fun√ß√µes de sa√≠da no modo de E / S serial padr√£o": <br><br><img src="https://habrastorage.org/webt/ja/qk/zh/jaqkzhx4dielaovn5d3n9gykcxo.png"><br>  <i>"Semyon Semenych ..."</i> <br><br>  A ninharia, que foi esquecida a princ√≠pio, trouxe o lugar errado.  Na verdade, se no modo s√≠ncrono, esse √© exatamente o sinalizador ocupado do carregador de inicializa√ß√£o, no modo ass√≠ncrono (aquele que o modo de E / S serial 2) √© apenas um "pisca-pisca" para indicar a opera√ß√£o.  Talvez, em geral, o sinal de hardware esteja pronto para o transceptor e, portanto, a incr√≠vel precis√£o de sua eleva√ß√£o. <br><br>  Em geral, soldamos o resistor no pino SCLK do ch√£o ao VCC, soldamos o fio, conectamos tudo ao SPI e come√ßamos novamente ... <br><br><h4>  Sucesso! </h4><br><img src="https://habrastorage.org/webt/qh/ce/l1/qhcel11fibxpkxoa8zibgerddgc.png"><br><br>  No modo s√≠ncrono, tudo √© quase o mesmo, apenas nenhum procedimento preliminar para estabelecer uma conex√£o √© necess√°rio, a sincroniza√ß√£o √© simplificada e a captura de tempo pode ser realizada com mais precis√£o.  Se eu escolhesse imediatamente esse modo, economizaria tempo ... Mais uma vez, n√£o compliquei e medi o tempo desde o √∫ltimo bit, mas iniciei o timer antes de iniciar a transfer√™ncia do √∫ltimo byte da chave, ou seja,  ligamos o timer e enviamos para o transmissor KEY7 (na captura de tela acima, no analisador l√≥gico, √© poss√≠vel ver a dist√¢ncia entre os cursores. Esse √© o intervalo de tempo medido). <br><br>  Isso foi mais do que suficiente para uma identifica√ß√£o bem-sucedida.  Aqui est√° a enumera√ß√£o de um byte: <br><br><img src="https://habrastorage.org/webt/dz/zx/l_/dzzxl_-wct4qfyr0gqpmuaqlos8.png"><br><br>  No eixo x, temos o n√∫mero de contagens discretas, no eixo y, respectivamente, o valor da chave transmitida.  A rela√ß√£o sinal / ru√≠do √© tal que mesmo nenhum filtro √© necess√°rio, assim como na escola em uma aula de inform√°tica: encontramos o m√°ximo na matriz e vamos para a sele√ß√£o do pr√≥ximo byte.  Os primeiros 6 bytes s√£o selecionados com facilidade e rapidez, um pouco mais dif√≠cil com o √∫ltimo: a√≠ √© apenas um descaramento descarado que n√£o funciona, voc√™ precisa redefinir a "v√≠tima" antes de cada tentativa.  Como resultado, s√£o necess√°rios cerca de 400 ms para cada tentativa e a pesquisa √©, na pior das hip√≥teses, na regi√£o de um minuto e meio.  Mas isso √© o pior.  Ap√≥s cada tentativa, solicitamos um status e, assim que adivinhamos, paramos.  No come√ßo, geralmente eu rapidamente examinava o identificador com canetas, inserindo a sa√≠da do console no Excel e plotando o gr√°fico, tanto mais que era uma tarefa √∫nica, mas no artigo eu decidi adicionar itera√ß√£o autom√°tica, em prol de um console bonito ... <br><br><img src="https://habrastorage.org/webt/pd/dj/en/pddjenvq4joplvadcxy3lpd9gu0.png"><br><br>  Obviamente, se o desenvolvedor apagasse o gerenciador de inicializa√ß√£o (substitu√≠do pelo pr√≥prio), n√£o seria t√£o f√°cil sair, mas na eletr√¥nica automotiva, os MKs geralmente n√£o s√£o fechados.  Em particular, na unidade de controle de outro aquecedor, no qual o V850 da mesma Renesas foi instalado, tudo foi decidido soldando um par de fios e copiando o firmware com um utilit√°rio padr√£o.  Este √© todo o mecanismo de criptomoeda no mundo da ECU.  Aparentemente, os fabricantes n√£o gostam do fen√¥meno de ajuste de chips e outros tipos de interfer√™ncia ... Embora isso seja como uma corrida de armaduras e proj√©teis - as gl√¢ndulas s√£o mais √≠ngremes, mais caras, mas n√£o h√° vencedor ... <br><br>  Refer√™ncias: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.dataman.com/media/datasheet/Renesas/M16C6N5Group.pdf</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://hackaday.io/project/723-reverse-engineering-toshiba-r100-bios/log/51302-ec-firmware-dumped</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://q3k.org/slides-recon-2018.pdf</a> <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469085/">https://habr.com/ru/post/pt469085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469071/index.html">Intelig√™ncia Artificial Microsoft domina mahjong</a></li>
<li><a href="../pt469073/index.html">Derivada discreta ou resumo de como somar s√©ries</a></li>
<li><a href="../pt469075/index.html">Grokay DLR</a></li>
<li><a href="../pt469077/index.html">Novo curso de Python da Microsoft [em ingl√™s]</a></li>
<li><a href="../pt469079/index.html">Python no c√≥digo do Visual Studio: atualiza√ß√£o de extens√£o de setembro</a></li>
<li><a href="../pt469087/index.html">MVCC no PostgreSQL-2. Garfos, arquivos, p√°ginas</a></li>
<li><a href="../pt469093/index.html">Compara√ß√£o de bibliotecas menos populares e n√£o muito CLI: cliff, plac, plumbum e outras (parte 2)</a></li>
<li><a href="../pt469095/index.html">Lan√ßadas atualiza√ß√µes do ML.NET e do Model Builder: O que h√° de novo</a></li>
<li><a href="../pt469097/index.html">Servidor web CentOS 8 com php7, node.js e redis</a></li>
<li><a href="../pt469099/index.html">Tarefas de teste na entrevista do desenvolvedor - isso faz sentido?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>