<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèº üìó üßëüèæ Portas de conclus√£o do epoll e do Windows IO: a diferen√ßa pr√°tica üë©üèΩ‚Äçüéì üë©‚Äçüëß üòÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Neste artigo, tentaremos entender como o mecanismo de epoll difere das portas de conclus√£o na pr√°tica (porta de conclus√£o de E / S do ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Portas de conclus√£o do epoll e do Windows IO: a diferen√ßa pr√°tica</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/415403/"><h3>  1. Introdu√ß√£o </h3><br>  Neste artigo, tentaremos entender como o mecanismo de epoll difere das portas de conclus√£o na pr√°tica (porta de conclus√£o de E / S do Windows ou IOCP).  Isso pode ser interessante para arquitetos de sistemas que projetam servi√ßos de rede de alto desempenho ou programadores que portam c√≥digos de rede do Windows para o Linux ou vice-versa. <br><br>  Ambas as tecnologias s√£o muito eficazes para lidar com um grande n√∫mero de conex√µes de rede. <br><br>  Eles diferem de outros m√©todos nos seguintes pontos: <br><br><ul><li>  N√£o h√° restri√ß√µes (exceto o total de recursos do sistema) no n√∫mero total de descritores e tipos de eventos observados </li><li>  O dimensionamento funciona muito bem - se voc√™ j√° est√° monitorando N descritores, a mudan√ßa para o monitoramento N + 1 levar√° muito pouco tempo e recursos </li><li>  √â f√°cil o suficiente usar um pool de threads para processar eventos em paralelo </li><li>  N√£o faz sentido usar conex√µes de rede √∫nicas.  Todos os benef√≠cios come√ßam a aparecer com mais de 1000 conex√µes </li></ul><br>  Parafraseando tudo isso, essas duas tecnologias foram projetadas para desenvolver servi√ßos de rede que processam muitas conex√µes de entrada de clientes.  Mas, ao mesmo tempo, h√° uma diferen√ßa significativa entre eles e, ao desenvolver os mesmos servi√ßos, √© importante conhec√™-lo. <br><br>  (Upd: este artigo √© uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradu√ß√£o</a> ) <br><br><a name="habracut"></a><br><h3>  Tipo de notifica√ß√µes </h3><br>  A primeira e mais importante diferen√ßa entre epoll e IOCP √© como voc√™ √© notificado de um evento. <br><br><ul><li>  epoll informa quando o descritor est√° pronto para poder fazer algo com ele - " <b>agora voc√™ pode come√ßar a ler os dados</b> " </li><li>  O IOCP informa quando a opera√ß√£o solicitada √© conclu√≠da - " <b>voc√™ solicitou a leitura dos dados e aqui est√° a leitura</b> " </li></ul><br>  Ao usar o aplicativo epoll: <br><br><ul><li>  Decide qual opera√ß√£o ele deseja executar com algum descritor (leitura, grava√ß√£o ou ambos) </li><li>  Define a m√°scara apropriada usando epoll_ctl </li><li>  Chama epoll_wait, que bloqueia o encadeamento atual at√© que pelo menos um evento esperado ocorra (ou o tempo limite expire) </li><li>  Repete os eventos recebidos, leva um ponteiro para o contexto (no campo data.ptr) </li><li>  Inicia o processamento de eventos de acordo com seu tipo (leitura, grava√ß√£o ou ambas as opera√ß√µes) </li><li>  Ap√≥s a conclus√£o da opera√ß√£o (o que deve acontecer imediatamente), ela continua aguardando o recebimento / envio dos dados. </li></ul><br>  Ao usar o aplicativo IOCP: <br><br><ul><li>  Inicia alguma opera√ß√£o (ReadFile ou WriteFile) para algum descritor, usando o argumento OVERLAPPED n√£o vazio.  O sistema operacional adiciona o requisito para executar esta opera√ß√£o na fila e a fun√ß√£o chamada imediatamente (sem aguardar a conclus√£o da opera√ß√£o) retorna. </li><li>  Chama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GetQueuedCompletionStatus ()</a> , que bloqueia o thread atual at√© que exatamente uma das solicita√ß√µes adicionadas anteriormente seja conclu√≠da.  Se v√°rios foram conclu√≠dos, apenas um deles ser√° selecionado. </li><li>  Ele processa a notifica√ß√£o recebida da conclus√£o da opera√ß√£o usando a chave de conclus√£o e um ponteiro para OVERLAPPED. </li><li>  Continua a aguardar que os dados sejam recebidos / enviados </li></ul><br>  A diferen√ßa no tipo de notifica√ß√£o torna poss√≠vel (e bastante trivial) emular o IOCP usando epoll.  Por exemplo, o projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wine</a> faz exatamente isso.  No entanto, fazer o oposto n√£o √© t√£o simples.  Mesmo se voc√™ tiver sucesso, √© prov√°vel que resulte em perda de desempenho. <br><br><h3>  Disponibilidade de dados </h3><br>  Se voc√™ planeja ler dados, seu c√≥digo deve ter algum tipo de buffer no qual planeja l√™-los.  Se voc√™ planeja enviar dados, deve haver um buffer com os dados prontos para serem enviados. <br><br><ul><li>  O epoll n√£o est√° preocupado com a presen√ßa desses buffers e n√£o os usa de forma alguma </li><li>  IOCP esses buffers s√£o necess√°rios.  O objetivo principal do uso do IOCP √© o trabalho no estilo de "leia-me 256 bytes deste soquete neste buffer".  Formamos uma solicita√ß√£o, entregamos ao sistema operacional, aguardamos a notifica√ß√£o da conclus√£o da opera√ß√£o (e n√£o toque no buffer no momento!) </li></ul><br>  Um servi√ßo de rede t√≠pico opera com objetos de conex√£o, que incluem descritores e buffers associados para leitura / grava√ß√£o de dados.  Normalmente, esses objetos s√£o destru√≠dos quando o soquete correspondente √© fechado.  E isso imp√µe algumas limita√ß√µes ao usar o IOCP. <br><br>  O IOCP funciona adicionando √†s solicita√ß√µes da fila para ler e gravar dados, essas solicita√ß√µes s√£o executadas na ordem da fila (ou seja, algum tempo depois).  Nos dois casos, os buffers transferidos devem continuar existindo at√© a conclus√£o das opera√ß√µes necess√°rias.  Al√©m disso, n√£o √© poss√≠vel modificar dados nesses buffers enquanto aguarda.  Isso imp√µe importantes limita√ß√µes: <br><br><ul><li>  Voc√™ n√£o pode usar vari√°veis ‚Äã‚Äãlocais (colocadas na pilha) como um buffer.  O buffer deve ser validado antes que a opera√ß√£o de leitura / grava√ß√£o seja conclu√≠da e a pilha √© destru√≠da quando a fun√ß√£o atual sai </li><li>  Voc√™ n√£o pode realocar o buffer em tempo real (por exemplo, descobriu-se que voc√™ precisa enviar mais dados e deseja aumentar o buffer).  Voc√™ s√≥ pode criar um novo buffer e uma nova solicita√ß√£o de envio </li><li>  Se voc√™ escrever algo como um proxy, quando os mesmos dados ser√£o lidos e enviados, voc√™ precisar√° usar dois buffers separados para eles.  Voc√™ n√£o pode pedir ao sistema operacional para ler dados em um buffer em uma solicita√ß√£o e em outra solicita√ß√£o enviar esses dados ali </li><li>  Voc√™ precisa pensar cuidadosamente sobre como sua classe do gerenciador de conex√µes destruir√° cada conex√£o espec√≠fica.  Voc√™ deve ter uma garantia total de que, no momento da destrui√ß√£o da conex√£o, n√£o h√° uma √∫nica solicita√ß√£o para ler / gravar dados usando os buffers dessa conex√£o. </li></ul><br>  As opera√ß√µes IOCP tamb√©m exigem a passagem de um ponteiro para uma estrutura OVERLAPPED, que tamb√©m deve continuar a existir (e n√£o ser reutilizada) at√© a conclus√£o da opera√ß√£o esperada.  Isso significa que, se voc√™ precisar ler e gravar dados ao mesmo tempo, n√£o poder√° herdar da estrutura OVERLAPPED (uma ideia que geralmente vem √† mente).  Em vez disso, voc√™ precisa armazenar as duas estruturas OVERLAPPED em sua pr√≥pria classe separada, passando uma delas para solicita√ß√µes de leitura e a outra para solicita√ß√µes de grava√ß√£o. <br><br>  O epoll n√£o usa nenhum buffer passado a partir do c√≥digo do usu√°rio, portanto, todos esses problemas n√£o t√™m nada a ver com isso. <br><br><h3>  Alterar condi√ß√µes de espera </h3><br>  Adicionar um novo tipo de eventos esperados (por exemplo, est√°vamos aguardando a oportunidade de ler dados do soquete e agora tamb√©m quer√≠amos poder envi√°-los) √© poss√≠vel e bastante simples para epoll e IOCP.  O epoll permite alterar a m√°scara dos eventos esperados (a qualquer momento, mesmo de outro encadeamento), e o IOCP permite iniciar outra opera√ß√£o para aguardar um novo tipo de evento. <br><br>  Alterar ou excluir eventos esperados, no entanto, √© diferente.  O epoll ainda permite modificar a condi√ß√£o chamando epoll_ctl (inclusive de outros threads).  O IOCP est√° ficando mais dif√≠cil.  Se uma opera√ß√£o de E / S foi planejada, ela pode ser cancelada chamando a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CancelIo ()</a> .  Pior, apenas o mesmo encadeamento que iniciou a opera√ß√£o inicial pode chamar essa fun√ß√£o.  Todas as id√©ias de organizar um fluxo de controle separado s√£o quebradas sobre essa limita√ß√£o.  Al√©m disso, mesmo depois de chamar CancelIo (), n√£o podemos ter certeza de que a opera√ß√£o ser√° cancelada imediatamente (j√° pode estar em andamento, ela usa a estrutura OVERLAPPED e o buffer passado para leitura / grava√ß√£o).  Ainda temos que esperar at√© que a opera√ß√£o seja conclu√≠da (seu resultado ser√° retornado pela fun√ß√£o GetOverlappedResult ()) e somente depois disso podemos liberar o buffer. <br><br>  Outro problema com o IOCP √© que, uma vez que uma opera√ß√£o foi agendada para execu√ß√£o, ela n√£o pode mais ser alterada.  Por exemplo, voc√™ n√£o pode alterar a solicita√ß√£o ReadFile agendada e dizer que deseja ler apenas 10 bytes, e n√£o 8192. Voc√™ precisa cancelar a opera√ß√£o atual e iniciar uma nova.  Isso n√£o √© um problema para o epoll, que quando voc√™ come√ßa a esperar, n√£o tem id√©ia da quantidade de dados que deseja ler no momento em que chega a notifica√ß√£o sobre a capacidade de ler dados. <br><br><h3>  Conex√£o sem bloqueio </h3><br>  Algumas implementa√ß√µes de servi√ßos de rede (servi√ßos relacionados, FTP, p2p) requerem conex√µes de sa√≠da.  O epoll e o IOCP suportam uma solicita√ß√£o de conex√£o sem bloqueio, mas de maneiras diferentes. <br><br>  Ao usar epoll, o c√≥digo geralmente √© o mesmo que para sele√ß√£o ou pesquisa.  Voc√™ cria um soquete sem bloqueio, chama connect () e aguarda uma notifica√ß√£o sobre sua disponibilidade para grava√ß√£o. <br><br>  Ao usar o IOCP, voc√™ precisa usar a fun√ß√£o ConnectEx separada, pois a chamada para connect () n√£o aceita a estrutura OVERLAPPED, o que significa que ela n√£o pode gerar uma notifica√ß√£o sobre a altera√ß√£o do estado do soquete posteriormente.  Portanto, o c√≥digo de inicia√ß√£o da conex√£o n√£o ser√° apenas diferente do c√≥digo usando epoll, mas tamb√©m do c√≥digo do Windows usando select ou poll.  No entanto, as altera√ß√µes podem ser consideradas m√≠nimas. <br><br>  Curiosamente, accept () trabalha com o IOCP como de costume.  Existe uma fun√ß√£o AcceptEx, mas sua fun√ß√£o n√£o tem nenhuma rela√ß√£o com uma conex√£o sem bloqueio.  Esta n√£o √© uma "aceita√ß√£o sem bloqueio", como voc√™ pode pensar por analogia com o connect / ConnectEx. <br><br><h3>  Monitoramento de eventos </h3><br>  Muitas vezes, ap√≥s o acionamento de um evento, dados adicionais chegam muito rapidamente.  Por exemplo, esper√°vamos que a entrada do soquete chegasse usando epoll ou IOCP, obtivemos um evento sobre os primeiros bytes de dados e, ali mesmo, enquanto os lemos, outras centenas de bytes chegaram.  Posso l√™-los sem reiniciar o monitoramento de eventos? <br><br>  √â poss√≠vel usar o epoll.  Voc√™ obt√©m o evento "algo agora pode ser lido" - e voc√™ l√™ tudo o que pode ser lido no soquete (at√© obter o erro EAGAIN).  O mesmo ocorre com o envio de dados - quando voc√™ recebe um sinal de que o soquete est√° pronto para enviar dados, voc√™ pode escrever algo nele at√© que a fun√ß√£o de grava√ß√£o retorne EAGAIN. <br><br>  Com o IOCP, isso n√£o funcionar√°.  Se voc√™ pediu ao soquete para ler ou enviar 10 bytes de dados - √© o quanto ser√° lido / enviado (mesmo que mais j√° possa ser feito).  Para cada bloco subseq√ºente, voc√™ precisa fazer uma solicita√ß√£o separada usando ReadFile ou WriteFile e aguarde at√© que seja executada.  Isso pode criar um n√≠vel adicional de complexidade.  Considere o seguinte exemplo: <br><br><ol><li>  A classe de soquete criou uma solicita√ß√£o para ler dados chamando ReadFile.  Os segmentos A e B aguardam o resultado chamando GetOverlappedResult () </li><li>  A opera√ß√£o de leitura conclu√≠da, o segmento A recebeu uma notifica√ß√£o e chamou um m√©todo de classe de soquete para processar os dados recebidos </li><li>  A classe de soquete decidiu que esses dados n√£o s√£o suficientes, devemos esperar o seguinte.  Ele coloca outra solicita√ß√£o de leitura. </li><li>  Essa solicita√ß√£o √© executada imediatamente (os dados j√° chegaram, o sistema operacional pode envi√°-los imediatamente).  O fluxo B recebe uma notifica√ß√£o, l√™ os dados e os passa para a classe de soquete. </li><li>  No momento, a fun√ß√£o de ler dados na classe de soquete √© chamada dos fluxos A e B, o que leva ao risco de corrup√ß√£o de dados (sem o uso de objetos de sincroniza√ß√£o) ou a pausas adicionais (ao usar objetos de sincroniza√ß√£o) </li></ol><br>  Com objetos de sincroniza√ß√£o, nesse caso, geralmente √© dif√≠cil.  Bem, se ele estiver sozinho.  Mas se tivermos 100.000 conex√µes e cada uma delas tiver algum tipo de objeto de sincroniza√ß√£o, isso poder√° afetar seriamente os recursos do sistema.  E se voc√™ ainda mantiver 2 (em caso de separa√ß√£o dos pedidos de processamento para leitura e grava√ß√£o)?  Pior ainda. <br><br>  A solu√ß√£o usual aqui √© criar uma classe de gerenciador de conex√µes que ser√° respons√°vel por chamar ReadFile ou WriteFile para a classe de conex√£o.  Isso funciona melhor, mas torna o c√≥digo mais complexo. <br><br><h3>  Conclus√µes </h3><br>  O epoll e o IOCP s√£o adequados (e usados ‚Äã‚Äãna pr√°tica) para a cria√ß√£o de servi√ßos de rede de alto desempenho que podem lidar com um grande n√∫mero de conex√µes.  As pr√≥prias tecnologias diferem na maneira como lidam com os eventos.  Essas diferen√ßas s√£o t√£o significativas que dificilmente vale a pena tentar escrev√™-las em alguma base comum (a quantidade do mesmo c√≥digo ser√° m√≠nima).  V√°rias vezes trabalhei tentando trazer ambas as abordagens para algum tipo de solu√ß√£o universal - e cada vez o resultado era pior em termos de complexidade, legibilidade e suporte em compara√ß√£o com duas implementa√ß√µes independentes.  O resultado universal obtido teve que ser abandonado de cada vez. <br><br>  Ao portar c√≥digo de uma plataforma para outra, geralmente √© mais f√°cil portar o c√≥digo IOCP para usar epoll do que vice-versa. <br><br>  Dicas: <br><br><ul><li>  Se sua tarefa √© desenvolver um servi√ßo de rede de plataforma cruzada, inicie com uma implementa√ß√£o do Windows usando o IOCP.  Quando tudo estiver pronto e depurado - adicione um backend epoll trivial. </li><li>  Voc√™ n√£o deve tentar escrever as classes gerais Connection e ConnectionMgr que implementam a l√≥gica epoll e IOCP ao mesmo tempo.  Parece ruim do ponto de vista da arquitetura de c√≥digo e leva a v√°rios tipos de #ifdef com l√≥gicas diferentes.  Melhor criar classes base e herdar implementa√ß√µes separadas delas.  Nas classes base, voc√™ pode manter alguns m√©todos ou dados gerais, se houver. </li><li>  Monitore de perto o tempo de vida dos objetos da classe Connection (ou o que voc√™ chama de classe em que os buffers dos dados recebidos / enviados ser√£o armazenados).  Ele n√£o deve ser destru√≠do at√© que as opera√ß√µes agendadas de leitura / grava√ß√£o usando seus buffers sejam conclu√≠das. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt415403/">https://habr.com/ru/post/pt415403/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt415393/index.html">Kubernetes: a vida de uma lareira</a></li>
<li><a href="../pt415395/index.html">Ripple TVs</a></li>
<li><a href="../pt415397/index.html">PICASO 3D no Top 3D Expo 2018 - nova impressora 3D, novos materiais</a></li>
<li><a href="../pt415399/index.html">Por que os pre√ßos de DVD gratuitos do Fortnite chegam a US $ 450</a></li>
<li><a href="../pt415401/index.html">Resolvemos o problema de um milh√£o de abas abertas ou "ajudamos o hardware a sobreviver"</a></li>
<li><a href="../pt415405/index.html">Fujitsu PRIMERGY RX2540 M4 Revis√£o e teste do servidor</a></li>
<li><a href="../pt415407/index.html">Godville - exceto piadas</a></li>
<li><a href="../pt415409/index.html">Revis√£o da impressora 3D 3Dtool Raise3D PRO2</a></li>
<li><a href="../pt415411/index.html">De levitar discos ao som de uma caixa de papel√£o - 6 gadgets interessantes para vinil</a></li>
<li><a href="../pt415413/index.html">Funcionalidade cruzada, gerenciador de depend√™ncias, monitoramento nos testes iOS e UI. Como foi o Avito iOS Summer Edition</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>