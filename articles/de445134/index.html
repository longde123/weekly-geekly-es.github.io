<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏻 👨🏻‍🏭 🤨 Dies ist Ihr Haskell (nicht) nur faktoriell und gut für 👨‍🎓 📶 👲🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn es um Lieblingssprachen geht, sage ich normalerweise, dass ich bei gleichen Bedingungen C ++ für Zahlenbrecher und Haskell für alles andere bevor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dies ist Ihr Haskell (nicht) nur faktoriell und gut für</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445134/"><p> Wenn es um Lieblingssprachen geht, sage ich normalerweise, dass ich bei gleichen Bedingungen C ++ für Zahlenbrecher und Haskell für alles andere bevorzuge.  Es ist nützlich, regelmäßig zu überprüfen, ob diese Unterteilung gerechtfertigt ist, und erst kürzlich stellte sich eine müßige und sehr einfache Frage: Wie wird sich die Summe aller Teiler einer Zahl mit dem Wachstum dieser Zahl beispielsweise für die ersten Milliarden Zahlen verhalten?  Es ist leicht, diese Aufgabe einzuschüchtern (es ist eine Schande, sie als den resultierenden Zahlenschleifer zu bezeichnen), daher scheint sie eine großartige Option für eine solche Prüfung zu sein. </p><br><p>  Außerdem kann ich die Leistung des Haskell-Codes immer noch nicht genau vorhersagen. Daher ist es hilfreich, wissentlich schlechte Ansätze zu versuchen, um festzustellen, wie sich die Leistung verschlechtert. </p><br><p>  Außerdem können Sie auf einfache Weise einen effizienteren Algorithmus als die frontale Suche nach Teilern für jede Zahl von vorführen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mn" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhhJsCJmi_11LWz8Q7WyPKd3SmJc7w#MJMAIN-31" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> 1 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhhJsCJmi_11LWz8Q7WyPKd3SmJc7w#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> n </script>  . </p><a name="habracut"></a><br><h3>  Algorithmus </h3><br><p>  Beginnen wir also mit dem Algorithmus. </p><br><p>  So finden Sie die Summe aller Teiler einer Zahl <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhhJsCJmi_11LWz8Q7WyPKd3SmJc7w#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> n </script>  ?  Sie können alles durchgehen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="noError" id="MJXp-Span-8" style="display: inline-block;">k_1&nbsp;\&nbsp;in&nbsp;\&nbsp;{1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;sqrt&nbsp;n&nbsp;\&nbsp;rfloor&nbsp;\}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><span class="noError" style="display: inline-block;">k_1&nbsp;\&nbsp;in&nbsp;\&nbsp;{1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;sqrt&nbsp;n&nbsp;\&nbsp;rfloor&nbsp;\}</span></span><script type="math/tex" id="MathJax-Element-4"> k_1 \ in \ {1 \ dots \ lfloor \ sqrt n \ rfloor \} </script>  und für jeden solchen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-msubsup" id="MJXp-Span-10"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-12" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.265ex" height="2.298ex" viewBox="0 -780.1 975.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhhJsCJmi_11LWz8Q7WyPKd3SmJc7w#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhhJsCJmi_11LWz8Q7WyPKd3SmJc7w#MJMAIN-31" x="737" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> k_1 </script>  Überprüfen Sie den Rest der Abteilung <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhhJsCJmi_11LWz8Q7WyPKd3SmJc7w#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> n </script>  auf <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-15"><span class="MJXp-msubsup" id="MJXp-Span-16"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-18" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.265ex" height="2.298ex" viewBox="0 -780.1 975.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhhJsCJmi_11LWz8Q7WyPKd3SmJc7w#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhhJsCJmi_11LWz8Q7WyPKd3SmJc7w#MJMAIN-31" x="737" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> k_1 </script>  .  Wenn der Rest ist <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-19"><span class="MJXp-mn" id="MJXp-Span-20">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> 0 </script>  , dann zur Batterie hinzufügen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-21"><span class="MJXp-msubsup" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-24" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-25" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-msubsup" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-28" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> k_1 + k_2 </script>  wo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-29"><span class="MJXp-msubsup" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-32" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mtext" id="MJXp-Span-34">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">c</span><span class="MJXp-mrow" id="MJXp-Span-39"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">n</span></span><span class="MJXp-mrow" id="MJXp-Span-41"><span class="MJXp-msubsup" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-44" style="vertical-align: -0.4em;">1</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> k_2 = \ frac {n} {k_1} </script>  wenn <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-45"><span class="MJXp-msubsup" id="MJXp-Span-46"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-48" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mtext" id="MJXp-Span-49">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">q</span><span class="MJXp-msubsup" id="MJXp-Span-53"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-55" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> k_1 \ neq k_2 </script>  und nur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-56"><span class="MJXp-msubsup" id="MJXp-Span-57"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-59" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> k_1 </script>  sonst. </p><br><p>  Kann dieser Algorithmus angewendet werden? <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> n </script>  mal für jede nummer von <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mn" id="MJXp-Span-63">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> 1 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> n </script>  ?  Das kannst du natürlich.  Was wird die Schwierigkeit sein?  Diese Reihenfolge ist leicht zu erkennen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">O</span><span class="MJXp-mo" id="MJXp-Span-68" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70" style="margin-right: 0.05em;">n</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-71" style="vertical-align: 0.5em;">&nbsp;</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-73">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">c</span><span class="MJXp-mrow" id="MJXp-Span-76"><span class="MJXp-mn" id="MJXp-Span-77">3</span></span><span class="MJXp-mrow" id="MJXp-Span-78"><span class="MJXp-mn" id="MJXp-Span-79">2</span></span><span class="MJXp-mo" id="MJXp-Span-80" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> O (n ^ \ frac {3} {2}) </script>  Divisionen - für jede Zahl machen wir genau die Wurzel der Divisionen, und wir haben Zahlen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-81"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> n </script>  .  Können wir es besser machen?  Es stellt sich heraus, dass ja. </p><br><p>  Eines der Probleme bei dieser Methode ist, dass wir zu viel Aufwand verschwenden.  Zu viele Abteilungen führen uns nicht zum Erfolg und geben einen Rest ungleich Null.  Es ist natürlich zu versuchen, etwas fauler zu sein und sich der Aufgabe von der anderen Seite zu nähern: Lassen Sie uns einfach alle Arten von Kandidaten für Teiler generieren und sehen, welche Zahlen sie erfüllen? </p><br><p>  Also, jetzt brauchen wir einen Sturzflug für jede Nummer von <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mn" id="MJXp-Span-84">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> 1 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-85"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> n </script>  Berechnen Sie die Summe aller Teiler.  Gehen Sie dazu alles durch <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-87"><span class="noError" id="MJXp-Span-88" style="display: inline-block;">k_1&nbsp;\&nbsp;in&nbsp;\&nbsp;{1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;sqrt&nbsp;n&nbsp;\&nbsp;rfloor&nbsp;\}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> k_1 \ in \ {1 \ dots \ lfloor \ sqrt n \ rfloor \} </script>  und für jeden solchen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-89"><span class="MJXp-msubsup" id="MJXp-Span-90"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-92" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> k_1 </script>  Lass uns alles durchgehen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="noError" id="MJXp-Span-94" style="display: inline-block;">k_2&nbsp;\&nbsp;in&nbsp;\&nbsp;{k_1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;frac&nbsp;{n}&nbsp;{k}&nbsp;\&nbsp;rfloor&nbsp;\}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> k_2 \ in \ {k_1 \ dots \ lfloor \ frac {n} {k} \ rfloor \} </script>  .  Für jedes Paar <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mo" id="MJXp-Span-96" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-97"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-99" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-100" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-101"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-102" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-103" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-104" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-23"> (k_1, k_2) </script>  zur Zelle mit dem Index hinzufügen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-105"><span class="MJXp-msubsup" id="MJXp-Span-106"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-108" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mtext" id="MJXp-Span-109">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-110">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-111">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-112">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-113">t</span><span class="MJXp-msubsup" id="MJXp-Span-114"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-115" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-116" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> k_1 \ cdot k_2 </script>  Wert <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-117"><span class="MJXp-msubsup" id="MJXp-Span-118"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-120" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-121" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-msubsup" id="MJXp-Span-122"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-123" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-124" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-25"> k_1 + k_2 </script>  wenn <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-125"><span class="MJXp-msubsup" id="MJXp-Span-126"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-127" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-128" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mtext" id="MJXp-Span-129">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132">q</span><span class="MJXp-msubsup" id="MJXp-Span-133"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-135" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-26"> k_1 \ neq k_2 </script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-136"><span class="MJXp-msubsup" id="MJXp-Span-137"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-138" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-139" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-27"> k_1 </script>  sonst. </p><br><p>  Dieser Algorithmus macht genau <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-140"><span class="MJXp-msubsup" id="MJXp-Span-141"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142" style="margin-right: 0.05em;">n</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-143" style="vertical-align: 0.5em;">&nbsp;</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-144">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-145">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-146">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-147">c</span><span class="MJXp-mrow" id="MJXp-Span-148"><span class="MJXp-mn" id="MJXp-Span-149">1</span></span><span class="MJXp-mrow" id="MJXp-Span-150"><span class="MJXp-mn" id="MJXp-Span-151">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> n ^ \ frac {1} {2} </script>  Divisionen und jede Multiplikation (die billiger als Division ist) führt uns zum Erfolg: Bei jeder Iteration erhöhen wir etwas.  Dies ist viel effektiver als der frontale Ansatz. </p><br><p>  Darüber hinaus können Sie mit demselben Frontalansatz beide Implementierungen vergleichen und sicherstellen, dass sie für relativ kleine Zahlen dieselben Ergebnisse liefern, was ein wenig Vertrauen schaffen sollte. </p><br><h3>  Erste Implementierung </h3><br><p>  Übrigens ist dies direkt fast ein Pseudocode der ersten Implementierung in Haskell: </p><br><pre><code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Divisors.Multi(<span class="hljs-title"><span class="hljs-title">divisorSums</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.IntMap.Strict <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IM divisorSums :: Int -&gt; Int divisorSums n = IM.fromListWith (+) premap IM.! n where premap = [ (<span class="hljs-title"><span class="hljs-title">k1</span></span> * <span class="hljs-title"><span class="hljs-title">k2</span></span>, <span class="hljs-title"><span class="hljs-title">if</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> /= <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">then</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> + <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">else</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span>) | k1 &lt;- [ 1 .. floor $ sqrt $ fromIntegral n ] , k2 &lt;- [ k1 .. n `quot` k1 ] ]</code> </pre> <br><p>  <code>Main</code> Modul ist einfach und ich bringe es nicht mit. </p><br><p>  Außerdem zeigen wir hier den Betrag nur für die meisten <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-152"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-153">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> n </script>  zum leichteren Vergleich mit anderen Implementierungen.  Trotz der Tatsache, dass Haskell eine faule Sprache ist, werden in diesem Fall alle Beträge berechnet (obwohl die vollständige Rechtfertigung dafür den Rahmen dieses Artikels sprengt), sodass es nicht funktioniert, dass wir nichts versehentlich zählen. </p><br><p>  Wie schnell geht es?  Auf meinem i7 3930k werden in einem Stream 100.000 Elemente in 0,4 s ausgearbeitet.  In diesem Fall werden 0,15 s für Berechnungen und 0,25 s für GC aufgewendet.  Und wir belegen ungefähr 8 Megabyte Speicher, obwohl wir, da die Größe des int 8 Bytes beträgt, idealerweise 800 Kilobyte haben sollten. </p><br><p>  Gut (nicht wirklich).  Wie werden diese Zahlen mit steigenden Zahlen wachsen?  Für 1'000'000 Elemente hat es ungefähr 7,5 Sekunden gearbeitet, drei Sekunden für das Rechnen und 4,5 Sekunden für das GC aufgewendet und 80 Megabyte (10-mal mehr als nötig) belegt.  Und selbst wenn wir uns für eine Sekunde als Senior Java Software Developers ausgeben und mit der Optimierung von GC beginnen, werden wir das Bild nicht wesentlich ändern.  Schade.  Es scheint, dass wir niemals eine Milliarde Nummern warten werden und auch nicht in den Speicher gelangen werden: Auf meinem Computer befinden sich nur 64 Gigabyte RAM, und es werden ungefähr 80 benötigt, wenn sich der Trend fortsetzt. </p><br><p>  Es scheint Zeit zu tun </p><br><h3>  C ++ Option </h3><br><p>  Lassen Sie uns versuchen, eine Vorstellung davon zu bekommen, was es sinnvoll ist, danach zu streben, und dafür werden wir den Code auf die Pluspunkte schreiben. </p><br><p>  Nun, da wir bereits einen debuggten Algorithmus haben, ist alles einfach: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;string&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; int main(int argc, char **argv) { if (argc != 2) { std::cerr &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " maxN" &lt;&lt; std::endl; return 1; } int64_t n = std::stoi(argv[1]); std::vector&lt;int64_t&gt; arr; arr.resize(n + 1); for (int64_t k1 = 1; k1 &lt;= static_cast&lt;int64_t&gt;(std::sqrt(n)); ++k1) { for (int64_t k2 = k1; k2 &lt;= n / k1; ++k2) { auto val = k1 != k2 ? k1 + k2 : k1; arr[k1 * k2] += val; } } std::cout &lt;&lt; arr.back() &lt;&lt; std::endl; }</span></span></span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wenn Sie plötzlich etwas über diesen Code schreiben möchten</b> <div class="spoiler_text"><p>  Der Compiler führt in diesem Fall eine große schleifeninvariante Codebewegung aus, berechnet die Wurzel einmal im Leben des Programms und berechnet <code>n / k1</code> einmal pro Iteration der äußeren Schleife. <br></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Und ein Spoiler über Einfachheit</b> <div class="spoiler_text"><p>  Dieser Code hat beim ersten Mal nicht funktioniert, obwohl ich einen vorhandenen Algorithmus kopiert habe.  Ich habe ein paar sehr dumme Fehler gemacht, die anscheinend nicht direkt mit Typen zusammenhängen, aber dennoch gemacht wurden.  Aber es ist laut Gedanken. </p></div></div><br><p>  <code>-O3 -march=native</code> , clang 8, eine Million Elemente werden in 0,024 s verarbeitet und belegen die zugewiesenen 8 Megabyte Speicher.  Milliarden - 155 Sekunden, 8 Gigabyte Speicher, wie erwartet.  Autsch.  Haskell ist nicht gut.  Haskell muss rausgeworfen werden.  Nur Fakultäten und Präpromorphismen drauf und schreiben!  Oder nicht? </p><br><h3>  Zweite Option </h3><br><p>  Es ist offensichtlich nicht die klügste Entscheidung, alle generierten Daten über <code>IntMap</code> , das heißt in der Tat eine relativ gewöhnliche Karte - gelinde gesagt, dies ist dieselbe offensichtlich miese Option, die zu Beginn erwähnt wurde).  Warum verwenden wir kein Array wie im C ++ - Code? </p><br><p>  Versuchen wir mal: </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Divisors.Multi(<span class="hljs-title"><span class="hljs-title">divisorSums</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.IArray <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A divisorSums :: Int -&gt; Int divisorSums n = arr A.! n where arr = A.accumArray (+) 0 (1, <span class="hljs-title"><span class="hljs-title">n</span></span>) premap :: A.UArray Int Int premap = [ (<span class="hljs-title"><span class="hljs-title">k1</span></span> * <span class="hljs-title"><span class="hljs-title">k2</span></span>, <span class="hljs-title"><span class="hljs-title">if</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> /= <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">then</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> + <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">else</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span>) | k1 &lt;- [ 1 .. floor bound ] , k2 &lt;- [ k1 .. n `quot` k1 ] ] bound = sqrt $ fromIntegral n :: Double</code> </pre> <br><p>  Hier verwenden wir sofort die Unboxed-Version des Arrays, da <code>Int</code> recht einfach ist und wir keine Faulheit darin brauchen.  Die Box-Version würde sich nur im <code>arr</code> Typ unterscheiden, sodass wir auch nicht an Redewendungen verlieren.  Außerdem wird die Bindung für <code>bound</code> hier separat vorgenommen, jedoch nicht, weil der Compiler dumm ist und kein LICM ausführt, sondern weil Sie dann seinen Typ explizit angeben und eine Warnung des Compilers über die Standardeinstellung des <code>floor</code> Arguments vermeiden können. </p><br><p>  0,045 s für eine Million Elemente (nur zweimal schlechter als die Pluspunkte!).  8 Megabyte Speicher, null Millisekunden in GC (!).  Bei größeren Größen bleibt der Trend bestehen - etwa doppelt so langsam wie bei C ++ und bei gleichem Speicherplatz.  Tolles Ergebnis!  Aber können wir es besser machen? </p><br><p>  Es stellt sich heraus, dass ja.  <code>accumArray</code> überprüft die Indizes, was in diesem Fall nicht erforderlich ist - die Indizes sind korrekt aufgebaut.  Versuchen wir, den Aufruf von <code>accumArray</code> durch <code>unsafeAccumArray</code> zu <code>unsafeAccumArray</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Divisors.Multi(<span class="hljs-title"><span class="hljs-title">divisorSums</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.Base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.IArray <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A divisorSums :: Int -&gt; Int divisorSums n = arr A.! (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) where arr = A.unsafeAccumArray (+) 0 (0, <span class="hljs-title"><span class="hljs-title">n</span></span> - 1) premap :: A.UArray Int Int premap = [ (<span class="hljs-title"><span class="hljs-title">k1</span></span> * <span class="hljs-title"><span class="hljs-title">k2</span></span> - 1, <span class="hljs-title"><span class="hljs-title">if</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> /= <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">then</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> + <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">else</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span>) | k1 &lt;- [ 1 .. floor bound ] , k2 &lt;- [ k1 .. n `quot` k1 ] ] bound = sqrt $ fromIntegral n :: Double</code> </pre> <br><p>  Wie Sie sehen können, sind die Änderungen minimal, mit Ausnahme der Notwendigkeit, von Grund auf neu indiziert zu werden (was meiner Meinung nach ein Fehler in der Bibliotheks-API ist, aber dies ist eine andere Frage).  Was ist die Leistung? </p><br><p>  Eine Million Elemente - 0,021 s (wow, innerhalb der Fehlergrenze, aber schneller als die Profis!).  Natürlich die gleichen 8 Megabyte Speicher, die gleichen 0 ms im GC. </p><br><p>  Milliarden Elemente - 152 s (es sieht so aus, als wäre es wirklich schneller als die Pluspunkte!).  Etwas weniger als 8 Gigabyte.  0 ms in GC.  Der Code ist immer noch idiomatisch.  Ich denke, wir können sagen, dass dies ein Sieg ist. </p><br><h3>  Abschließend </h3><br><p>  Erstens war ich überrascht, dass das Ersetzen von <code>accumArray</code> durch eine <code>unsafe</code> Version zu einer solchen Steigerung führen wird.  Es wäre vernünftiger, 10 bis 20 Prozent zu erwarten (schließlich führt das Ersetzen von <code>operator[]</code> durch <code>at()</code> nicht zu einer signifikanten Leistungsminderung), aber nicht um die Hälfte! </p><br><p>  Zweitens ist es meiner Meinung nach wirklich cool, dass ein ziemlich idiomatischer sauberer Code ohne veränderliches Herausragen dieses Leistungsniveau erreicht. </p><br><p>  Drittens sind natürlich weitere Optimierungen auf allen Ebenen möglich.  Ich bin mir zum Beispiel sicher, dass Sie etwas mehr aus dem Code auf den Pluspunkten herausholen können.  Meiner Meinung nach ist jedoch bei all diesen Benchmarks das Gleichgewicht zwischen dem Aufwand (und der Menge an Code) und dem daraus resultierenden Auspuff wichtig.  Ansonsten konvergiert letztendlich alles mit der Herausforderung von LLVM JIT oder ähnlichem.  Darüber hinaus gibt es sicherlich effizientere Algorithmen zur Lösung dieses Problems, aber das Ergebnis eines hier vorgestellten kurzen Gedankens wird auch für dieses kleine Sonntagsabenteuer funktionieren. </p><br><p>  Viertens mein Favorit: Typsysteme müssen entwickelt werden.  <code>unsafe</code> wird hier nicht benötigt, als Programmierer kann ich beweisen, dass <code>k_1 * k_2 &lt;= n</code> für alle <code>k_1, k_2</code> in der Schleife angetroffen wird.  In einer idealen Welt von abhängig typisierten Sprachen würde ich diesen Beweis statisch konstruieren und an die entsprechende Funktion übergeben, wodurch die Notwendigkeit von Überprüfungen zur Laufzeit entfällt.  Aber leider gibt es in Haskell kein vollwertiges Zavtipov, und in Sprachen, in denen Zavtipy ist (und die ich kenne), gibt es kein <code>array</code> und keine Analoga. </p><br><p>  Fünftens kenne ich andere Programmiersprachen nicht genug, um mich für Benchmarks in diesen Sprachen zu qualifizieren, aber einer meiner Freunde hat ein Analogon in Python geschrieben.  Fast genau hundertmal langsamer und schlimmer aus dem Gedächtnis.  Und der Algorithmus selbst ist extrem einfach. Wenn also jemand mit Kenntnissen ein Analogon in Go, Rust, Julia, D, Java, Malbolge in die Kommentare schreibt oder einen Vergleich beispielsweise mit C ++ - Code auf seinem Computer teilt, ist er wahrscheinlich großartig . </p><br><p>  PS: Entschuldigung für den leicht Clickbait-Header.  Ich könnte mir nichts Besseres einfallen lassen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445134/">https://habr.com/ru/post/de445134/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445122/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 357 (18.-24. März 2019)</a></li>
<li><a href="../de445124/index.html">Mäßige Härtung für Firefox</a></li>
<li><a href="../de445126/index.html">Reverse Engineering-Anwendungen nach Verschleierung (Teil 2)</a></li>
<li><a href="../de445128/index.html">Oracle Application Express-Lernprogramm IDE-Übersicht</a></li>
<li><a href="../de445130/index.html">Das Innenministerium hat PCs für 180 Millionen Rubel gekauft - das ganze Geld ging an ausländische Hersteller</a></li>
<li><a href="../de445136/index.html">Sei nicht nervös, beeile dich nicht, unterbreche nicht: die Geschichte einer Tragödie</a></li>
<li><a href="../de445138/index.html">IBM Integration Bus und was es isst</a></li>
<li><a href="../de445140/index.html">PHP Digest Nr. 152 (11. - 25. März 2019)</a></li>
<li><a href="../de445146/index.html">Die Geschichte des Slonik-Elefanten, das PostgreSQL-Logo</a></li>
<li><a href="../de445150/index.html">Upwork ist in der Russischen Föderation registriert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>