<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìì üôÖüèª üéüÔ∏è Programaci√≥n heterog√©nea y oneAPI Toolkit. Conferencia improvisada experta de Intel responde sus preguntas üôçüèΩ üõ†Ô∏è üí∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como parte de la columna "Haga una pregunta a un experto de Intel", le pedimos al especialista l√≠der de Intel, Konstantin Vladimirov, que respondiera ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programaci√≥n heterog√©nea y oneAPI Toolkit. Conferencia improvisada experta de Intel responde sus preguntas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/479486/"><img src="https://habrastorage.org/webt/tz/b5/gv/tzb5gvt-1m1z3yvd4tjzot84ao4.jpeg"><br><br>  Como parte de la columna "Haga una pregunta a un experto de Intel", le pedimos al especialista l√≠der de Intel, Konstantin Vladimirov, que respondiera preguntas relacionadas con la programaci√≥n heterog√©nea, el <a href="https//software.intel.com/en-us/oneapi">kit de herramientas oneAPI</a> y cosas interesantes relacionadas.  El resultado super√≥ todas nuestras expectativas.  Konstantin no perdi√≥ tiempo y dio respuestas detalladas y fundamentadas, sin temor a ser pol√©mico.  De hecho, obtuvimos una peque√±a conferencia sobre programaci√≥n de arquitectura cruzada en todas sus formas: matices de descarga, optimizaciones, est√°ndares, etc. <br>  Transferimos el micr√≥fono al experto.  Bueno, los comentarios se dan a la audiencia. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagen">  Pregunta <a href="https://habr.com/ru/users/soarex16/" class="user_link">Soarex16</a> <br><blockquote>  ¬øQu√© tan laboriosa ser√° la transici√≥n de OpenCL a oneAPI y qu√© beneficios se pueden obtener de esto? </blockquote><br>  <b>La respuesta</b>  Cambiar a DPC ++ puede ser complicado, pero en mi opini√≥n, vale la pena.  Hay dos etapas principales. <br><br>  En primer lugar, esta es una transici√≥n desde su lenguaje de programaci√≥n heterog√©neo (OpenCL, Vulkan compute), que, muy probablemente, se basa en la API.  Aqu√≠ tiene una ventaja en el hecho de que ya conoce el √°rea tem√°tica, y la dificultad est√° en cambiar el pensamiento del control directo a trav√©s de la API a construcciones de lenguaje ligeramente m√°s impl√≠citas. <br>  En segundo lugar, esta es una transici√≥n desde su idioma de host.  Si ha estado descargando toda su vida de C puro, entonces el umbral de entrada es igual al umbral para cambiar de C a C ++, que es bastante alto. <br><br>  ¬øPor qu√© intentarlo? <br><br>  En primer lugar, DPC ++ hace un gran trabajo para un programador.  Muy r√°pidamente olvidar√°, como una pesadilla, todas estas llamadas expl√≠citas a clXXXYYY, y lo que significa el sexto argumento, y si olvid√≥ el c√≥digo de retorno.  Muchos contenedores orientados a objetos ocultan la rutina no peor, pero generalmente a costa de cambiar de la API est√°ndar de OpenCL a la API de contenedor no tan est√°ndar (tambi√©n vi esas bicicletas).  En el caso de DPC ++, simplemente escriba el SYCL est√°ndar con extensiones Intel (que pronto tambi√©n se convertir√° en el SYCL est√°ndar). <br><br>  En segundo lugar, DPC ++ proporciona una compilaci√≥n conjunta, es decir, puede estar seguro de los tipos y no tendr√° problemas en los bordes de la API con dimensiones, relleno, alineaci√≥n.  Escribe el n√∫cleo y el c√≥digo de host en un archivo, y este es el mismo c√≥digo.  Con USM, tambi√©n puede trabajar con estructuras de datos complejas mucho m√°s f√°cil. <br><br>  En tercer lugar, DPC ++ es C ++ real, es decir, permite una programaci√≥n generalizada.  Por ejemplo, el n√∫cleo m√°s simple para agregar dos vectores: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> kern = [A, B, C](cl::sycl::id&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; wiID) { C[wiID] = A[wiID] + B[wiID]; <span class="hljs-comment"><span class="hljs-comment">//   A, B  C?  ! };</span></span></code> </pre> <br>  Lo mismo en OpenCL: <br><br><pre> <code class="cpp hljs">_<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *A, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *B, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *C)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>); C[i] = A[i] + B[i]; }</code> </pre> <br>  Ver√°, me vi obligado a se√±alar un tipo OpenCL int.  Si necesito un flotante, tendr√© que escribir otro kernel o usar un preprocesador o generaci√≥n de c√≥digo externo.  Tener casi todas las caracter√≠sticas de C ++ a su disposici√≥n puede ser un poco aterrador si no ha tenido experiencia con C ++.  Pero esto es algo com√∫n cuando se trata de un cambio tecnol√≥gico importante. <br><br>  Y todos los beneficios no se limitan a esto.  Mencionar√© algo m√°s en las siguientes respuestas. <br><br>  As√≠ que habr√≠a descargado el compilador en su lugar y lo hab√≠a probado, ya que no es dif√≠cil hacer esto con el paquete <a href="https://software.intel.com/en-us/oneapi">OneAPI</a> . <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagen">  Pregunta <a href="https://habr.com/ru/users/juster/" class="user_link">Juster</a> <br><blockquote>  ¬øOpenVINO y oneAPI estar√°n relacionados de alguna manera? </blockquote><br>  <b>La respuesta</b>  La distribuci√≥n OpenVINO ahora es parte de la distribuci√≥n OneAPI.  Aprender y usar redes neuronales es una tarea computacionalmente dif√≠cil que se beneficia enormemente de la programaci√≥n heterog√©nea.  Creo que tarde o temprano todos los componentes de OneAPI permitir√°n utilizar todos los recursos inform√°ticos disponibles: aceleradores gr√°ficos y aceleradores especiales como Nervana y FPGA.  Y todo esto sin abandonar el paradigma del lenguaje y el sistema de tipos de su programa C ++. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagen">  Preguntas por correo <br><blockquote>  Estoy tratando de entender c√≥mo se ver√° el acelerador de hardware de IA en 3 a√±os, por favor ayuda con esto.  Hay una compa√±√≠a interesante Graphcore y su IPU: este dispositivo no es menos eficiente que FPGA, pero es mucho m√°s f√°cil de programar: Python con soporte para TensorFlow y otros marcos.  Resulta que si se cumplen las promesas de Graphcore, no habr√° necesidad de FPGA en el mercado de aprendizaje autom√°tico.  Python es mucho m√°s conveniente para los cient√≠ficos de datos que C ++. <br>  ¬øAcepta que FPGA no es adecuado para el mercado de aprendizaje autom√°tico en comparaci√≥n con las soluciones programables de Python?  Si se pierde el mercado de ML, ¬øqu√© otras aplicaciones FPGA generalizadas ves? <br>  ¬øEn qu√© aplicaciones ve la necesidad inevitable de una programaci√≥n heterog√©nea, en la que no puede pasar con herramientas m√°s convenientes como Python? </blockquote><br>  <b>La respuesta</b>  Mir√© brevemente qu√© tipo de UIP.  Una pieza m√°s de hierro en la que todos descargar√°n.  Estos muchachos compiten con la GPU y con aceleradores especiales, y no con la FPGA. <br><br>  En tareas para las que se afila una pieza de hardware especializada, siempre vencer√° a FPGA, por ejemplo, renderizar video es mejor en una tarjeta de video, etc.  Pero en el mundo (incluso en el mundo de ML) hay muchas tareas para las cuales no se ha inventado ni lanzado nada especial, y aqu√≠ FPGA siempre ser√° indispensable.  Por ejemplo, porque hay una cuesti√≥n de precio y, para ser barato, una pieza de hardware especializada debe ser masiva. <br><br>  Supongamos ahora que la IPU especificada es realmente genial.  Esto no cancelar√° la programaci√≥n heterog√©nea, por el contrario, la presencia de un acelerador tan excelente lo estimular√°.  Y tambi√©n le dar√° una ventaja enorme a OneAPI y DPC ++, porque tarde o temprano alguien dir√° "Quiero usar tanto su IPU como mi GPU desde un programa".  M√°s bien temprano porque la programaci√≥n heterog√©nea se trata de eso.  Su significado es la descarga de una tarea adecuada a un dispositivo adecuado.  Una tarea puede venir de cualquier parte.  Y este dispositivo puede ser cualquier cosa, incluso puede ser el mismo dispositivo en el que se ejecuta el programa.  Por ejemplo, si descarga el n√∫cleo escrito en ISPC y utiliza las caracter√≠sticas vectoriales de Xeon al m√°ximo, puede descargarlo usted mismo y seguir siendo una ganancia significativa.  El criterio principal aqu√≠ es el rendimiento.  Bueno, nunca habr√° demasiada productividad en este mundo.  Incluso con los mejores aceleradores del mundo. <br><br>  En cuanto a Python y su conveniencia ... Tengo que admitir de inmediato que no me gustan los lenguajes escritos din√°micamente: son lentos y, en lugar de un error de compilaci√≥n normal, debe esperar dos horas antes de caer en el tiempo de ejecuci√≥n debido al tipo incorrecto.  Pero no veo lo malo que es hacer las mismas descargas de Python.  Por cierto, OneAPI ya incluye Intel Distribution para Python, lo cual es extremadamente conveniente para varias revisiones. <br><br>  Es decir, en el mundo de los sue√±os de los amantes de Python, usted escribe un programa en √©l y lo descarga a todos los aceleradores que puede encontrar usando OneAPI, y no a un mont√≥n de bibliotecas espec√≠ficas del proveedor.  Otra cosa es que con este enfoque, se pierde la escritura de extremo a extremo y se regresa al mundo extremadamente precario de la programaci√≥n basada en API.  Quiz√°s el desarrollo de DPC ++ alentar√° a la comunidad a usar m√°s activamente herramientas m√°s apropiadas, como C ++. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagen">  Pregunta del correo <br><blockquote>  Rendimiento versus OpenCL.  Debe haber impuestos sobre el lujo, es decir  gastos generales  ¬øHay alguna medida? </blockquote><br>  <b>La respuesta</b>  En Internet puede encontrar muchas mediciones con una variedad de resultados, dependiendo del compilador, la tarea y la calidad de la implementaci√≥n.  Como investigaci√≥n personal, med√≠ tareas simples (SGEMM, DGEMM) en mi computadora port√°til (gr√°ficos integrados de Skylake), y vi que hasta ahora hay una reducci√≥n (dentro del porcentaje).  Pero me parece que esto es una consecuencia del hecho de que todo esto es beta hasta ahora. <br><br>  En teor√≠a, el resultado deber√≠a ser la aceleraci√≥n, no la desaceleraci√≥n, es decir, en principio, todo este lujo deber√≠a tener un valor negativo.  Se trata del compilador.  Cuando su programa consta de una sola fuente y se procesa como un solo programa, el compilador obtiene oportunidades fant√°sticas e incre√≠bles para la optimizaci√≥n: dise√±o de c√≥digo com√∫n, inversi√≥n de bucles, reorganizaci√≥n de secciones de c√≥digo y todo lo dem√°s que el compilador simplemente no puede hacer en el enfoque basado en API, pero tarde o temprano, definitivamente aprender√° con un modelo de fuente √∫nica. <br><br>  Adem√°s, DPC ++ tendr√° un costo negativo en t√©rminos de tiempo de desarrollo.  Un ejemplo simple son los accesos SYCL, que el compilador ya est√° utilizando para organizar eventos y administrar colas as√≠ncronas. <br><br><pre> <code class="cpp hljs">deviceQueue.submit([&amp;](cl::sycl::handler &amp;cgh) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> A = bufferA.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> B = bufferB.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> C = bufferC.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_write&gt;(cgh); .... deviceQueue.submit([&amp;](cl::sycl::handler &amp;cgh) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> A = bufferA.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> B = bufferB.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> D = bufferD.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_write&gt;(cgh);</code> </pre><br>  Aqu√≠, el compilador ve que ambos paquetes solo leen A y B y escriben buffers independientes C y D, como resultado, √©l ve la capacidad de enviarlos en paralelo si hay suficientes tama√±os globales. <br><br>  Por supuesto, un programa OpenCL escrito pedag√≥gicamente puede hacerlo igual de bien, pero el tiempo de desarrollo empleado con un n√∫cleo no trivial no ser√° comparable. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagen">  Pregunta del correo <br><blockquote>  ¬øSon relevantes todas las formas de optimizar las aplicaciones OpenCL para DPC ++?  ¬øQu√© novedades hay que agregarles? </blockquote><br>  <b>La respuesta</b>  Dir√≠a que la mayor parte de la sutil optimizaci√≥n manual que realizan los escritores de kernel puede y debe realizarla el compilador.  De la misma manera, por ejemplo, considero una pr√°ctica perjudicial instalar manualmente un ensamblador en l√≠nea en programas C ++, porque incluso si proporciona beneficios t√°cticos, interfiere con las optimizaciones y act√∫a como un factor negativo en el desarrollo y la transferencia de un producto.  Bueno, OpenCL ahora tambi√©n es ensamblador. <br><br>  En cuanto a la respuesta m√°s detallada, tengo miedo del abismo aqu√≠.  Por ejemplo, hay un conocido documento de Intel "OpenCL Developer Guide for Intel Processor Graphics".  Y hay una <a href="https://software.intel.com/en-us/iocl-opg-avoiding-needless-synchronization">secci√≥n</a> sobre c√≥mo intentarlo, para no poner donde est√° el exceso de sincronizaci√≥n. <br><br>  Entonces, desde mi punto de vista, esta es una tarea no humana en principio.  Las personas son extremadamente pobres en razonamiento sobre la sincronizaci√≥n de subprocesos m√∫ltiples y tienden a esculpir la sincronizaci√≥n de forma conservadora o incorrecta, o ambas a la vez: pongo comas como esta ( <i>pero lo arreglamos: nota editorial</i> ). <br><br>  Por otro lado, en DPC ++, en lugar de escribir c√≥digo con barreras expl√≠citas, as√≠: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (t = <span class="hljs-number"><span class="hljs-number">0</span></span>; t &lt; numTiles; t++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tiledRow = TS * t + row; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tiledCol = TS * t + col; Asub[col][row] = A[globalRow * AY + tiledCol]; Bsub[col][row] = B[tiledRow * BY + globalCol]; <span class="hljs-comment"><span class="hljs-comment">// Synchronise to make sure the tile is loaded barrier(CLK_LOCAL_MEM_FENCE); // .... etc ....</span></span></code> </pre> <br>  Lo m√°s probable es que escriba una iteraci√≥n expl√≠cita de <i>parallel_for_work_group</i> , dentro de la cual <i>group.parallel_for_work_item</i> <br><br><pre> <code class="cpp hljs">cgh.parallel_for_work_group&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mxm_kernel</span></span></span><span class="hljs-class">&gt;( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cl</span></span></span><span class="hljs-class">:</span></span>:sycl::range&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;{BIG_AX / TS, BIG_BY / TS}, cl::sycl::range&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;{TS, TS}, [=](cl::sycl::group&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; group) { <span class="hljs-comment"><span class="hljs-comment">// .... etc .... for (int t = 0; t &lt; numTiles; t++) { group.parallel_for_work_item([&amp;](cl::sycl::h_item&lt;2&gt; it) { // .... etc .... Asub[col][row] = A[globalRow][tiledCol]; Bsub[col][row] = B[tiledRow][globalCol]; }); //      ,   </span></span></code> </pre> <br>  Como resultado, no tiene que configurar la sincronizaci√≥n a mano en absoluto, y se puede descartar toda la secci√≥n. <br><br>  Y as√≠ puedes caminar en todas las secciones.  Algo sobrevivir√°, algo se ir√°.  Preveo la aparici√≥n de un nuevo documento "Optimizaci√≥n para DPC ++", pero el tiempo deber√≠a pasar, ya que todas las t√©cnicas que funcionan realmente se desarrollan solo m√°s tarde y con sangre <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagen">  Pregunta del correo <br><blockquote>  Hay una limitaci√≥n en OpenCL: no puede usar "datos distantes" en el n√∫cleo, es decir, implementar un "filtro ancho" que use datos de entrada de un gran grupo de p√≠xeles m√°s grande que el grupo de trabajo OpenCL en un c√°lculo.  ¬øQu√© ofrece DPC ++ a este respecto? </blockquote><br>  <b>La respuesta</b>  Bueno, eso es imposible.  Por supuesto, no escribo n√∫cleos en particular ... Pero es absolutamente seguro que puede usar toda la memoria global tal como est√°, solo necesita asegurarse de trabajar con operaciones at√≥micas (o sincronizar n√∫cleos jer√°rquicos externamente).  Y tambi√©n puede conectar System SVM (bueno, o hay USM en DPC ++). <br><br>  Por desgracia, todo esto es extremadamente ineficiente, y no me gustan todos estos trucos.  Adem√°s, son dif√≠ciles de optimizar por el compilador. <br><br>  Y as√≠, si hablamos de soluciones directas y efectivas, entonces, por supuesto, no hay magia en DPC ++.  Al final, su programa todav√≠a se divide en partes: el c√≥digo de host y el c√≥digo del dispositivo, y todas las restricciones del dispositivo afectan el c√≥digo del dispositivo.  El tama√±o m√°ximo del grupo de trabajo es ese paralelismo real que su hardware es capaz de hacer.  Todo lo que est√° encima de esto son solo formas de salir, afectando dram√°ticamente negativamente el rendimiento.  Es por eso que DPC ++ brinda la oportunidad de hacer esto: <i>device.get_info &lt;sycl :: info :: device :: max_work_group_size&gt; ()</i> y luego decidir c√≥mo vivir con el n√∫mero resultante. <br><br>  Ser√≠a tentador, por supuesto, hacer un modelo en DPC ++, cuando el programador trabaja como desee con bucles de cualquier longitud, y el compilador analiza qu√© hacer a continuaci√≥n, pero ser√≠a mortal, porque ocultar√≠a constantes e incluso asint√≥ticos de complejidad adicional. inform√°tica que aparece de la nada.  Por otra raz√≥n, Alexandrescu escribi√≥ que "encapsular la complejidad deber√≠a considerarse un delito", y esto tambi√©n se aplica. <br><br>  A veces es √∫til revisar el algoritmo en s√≠.  Aqu√≠ DPC ++ facilita las cosas porque un c√≥digo m√°s estructurado es m√°s f√°cil de refactorizar.  Pero esto es m√°s o menos un consuelo. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagen">  Pregunta del correo <br><blockquote>  DPC ++ se basa en SYCL.  Pero qu√© pasa si profundiza bajo el cap√≥, cu√°les son las diferencias con OpenCL en la implementaci√≥n del back-end, si corresponde.  Por ejemplo, ¬øel mecanismo de distribuci√≥n entre dispositivos heterog√©neos es el mismo que OpenCL? </blockquote><br>  <b>La respuesta</b>  Si te pones bajo el cap√≥, entonces esto es OpenCL.  Todas las ventajas y fortalezas de SYCL son las ventajas y fortalezas del lenguaje, es decir, la interfaz.  Desde el extremo frontal viene el viejo SPIRV que va al back-end y all√≠ est√° optimizado (a menudo ya en tiempo de ejecuci√≥n, es decir, es JIT) ya para una tarjeta de video espec√≠fica de la misma manera que OpenCL estar√≠a optimizado para ello. <br><br>  Otra cosa es que el mecanismo para distribuir el trabajo entre dispositivos heterog√©neos es m√°s front-end que back-end, porque es el c√≥digo de host el que decide qu√© enviar y d√≥nde.  Y el c√≥digo de host se obtiene de DPC ++.  Ya he mostrado un ejemplo un poco m√°s alto de c√≥mo el compilador puede, en base a los accesores, tomar una decisi√≥n sobre la paralelizaci√≥n de paquetes.  Y esto es solo la punta del iceberg. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagen">  Pregunta del correo <br><blockquote>  Bibliotecas  S√≠, no estamos hablando de CUDA.  Pero sabemos que para los desarrolladores de CUDA hay bibliotecas muy √∫tiles que funcionan con alto rendimiento en la GPU.  OneAPI tambi√©n contiene algunas bibliotecas, pero, por ejemplo, <a href="https://software.intel.com/en-us/ipp">IPP</a> : no hay ning√∫n archivo √∫til para trabajar con im√°genes en oneAPI / OpenCL.  ¬øHabr√° algo y c√≥mo, en este caso, cambiar de CUDA a oneAPI? </blockquote><br>  <b>La respuesta</b>  La transici√≥n de CUDA a un √∫nico est√°ndar abierto ser√° dif√≠cil, pero inevitable.  Por supuesto, CUDA ahora tiene una infraestructura m√°s madura.  Pero las caracter√≠sticas de su licencia son un inconveniente de bloqueo, porque cada vez aparecen m√°s jugadores en el mercado de sistemas heterog√©neos, m√°s y m√°s tarjetas interesantes y aceleradores de diferentes fabricantes. <br><br>  La diversidad de las API existentes dificulta el uso de este mundo de posibilidades para los programadores con experiencia en la CPU cl√°sica.  Lo que lleva a OneAPI o algo as√≠.  Aqu√≠ la magia no est√° en el avance de Intel en los gr√°ficos, sino en el hecho de que Intel abre la puerta a DPC ++ para todos.  Ni siquiera poseemos el est√°ndar SYCL, pertenece al grupo Khronos y todas las extensiones de Intel son extensiones en Khronos donde cualquiera puede comprometerse (y hay representantes de todos los principales jugadores all√≠).  Y eso significa que aparecer√°n (bibliotecas) y la comunidad (ya est√°n apareciendo), y un mont√≥n de vacantes en esta direcci√≥n. <br><br>  Y, por supuesto, IPP se reescribir√° para nuevas realidades.  No tengo nada que ver con IPP, pero usar DPC ++ es de sentido com√∫n, y hay personas sensatas sentadas all√≠. <br><br>  Pero lo m√°s importante, ahora es el momento en la historia en el que puede escribir su propia biblioteca, que superar√° el IPP y que todo el mundo usar√°.  Porque los est√°ndares abiertos siempre ganan. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagen">  Pregunta del correo <br><blockquote>  Si comparamos el lanzamiento de algoritmos de entrenamiento y de inferencia de redes neuronales en Nervana y FPGA, ¬øcu√°les son las diferencias en la programaci√≥n y la eficiencia resultante? </blockquote><br>  <b>La respuesta</b>  No s√© nada sobre los detalles de programaci√≥n de FPGA, escribo compiladores.  Pero tengo una contrapregunta.  ¬øY c√≥mo vamos a comparar?  En los puntos de referencia est√°ndar es antideportivo, Nervana lami√≥ debajo de ellos.  Pero en caso de que tenga algo interesante, entonces el FPGA le desatar√° las manos, y poner esto en Nervana puede ser largo y costoso, eso es todo. <br><br>  Resulta que la pregunta en s√≠ es, por as√≠ decirlo, de la serie "qui√©n es m√°s fuerte que un elefante o una ballena".  Pero esta no es una pregunta real.  La verdadera pregunta es: ¬øc√≥mo aprovechar un elefante y una ballena en un solo carro?  Bueno, o al menos distribuir, digamos, para que un elefante lo arrastre por tierra y una ballena por mar. <br><br>  En el caso de OneAPI, tendr√° el mismo programa, en general, en C ++ est√°ndar.  Y puede escribirlo usted mismo y ejecutarlo con descarga de un lado a otro.  Esta ser√° la tarea que le interesa, en la que usted mismo puede medir y optimizar el rendimiento.  Un √∫nico est√°ndar y una √∫nica interfaz para dispositivos heterog√©neos ser√° un paso hacia la comparaci√≥n de manzanas con manzanas en tales asuntos. <br><br>  Por ejemplo: "¬øQu√© es mejor para el% de mi tarea% desde el punto de vista de la facilidad de programaci√≥n y la eficiencia: poner esta parte en FPGA, dejar esta en Nervana o dividir esta parte en dos y reescribir esta parte para la GPU?" <br><br>  Y toda la historia con OneAPI: es solo para que usted diga: "por qu√© pensarlo durante mucho tiempo, lo intentar√© ahora r√°pidamente, ES SENCILLO". <br><br>  Todav√≠a no, no es f√°cil.  Pero lo habr√°. <br><br><hr><br>  <b>Ep√≠logo del experto</b> <br><br>  Gracias a todos por sus preguntas.  Es posible e incluso probable que me haya equivocado, sea inexacto y haya cometido errores.  Sucede, en Internet constantemente alguien est√° equivocado. <br><br>  Espero haber podido interesar a alguien en programaci√≥n heterog√©nea y DPC ++.  Quiero recomendar a todos el sitio <a href="https://sycl.tech/">sycl.tech</a> , donde se encuentran toneladas de informes, incluso de expertos de renombre mundial (se requiere ingl√©s) <br><br>  Bueno para todos! <br><br>  <i>PD del editor.</i>  <i>Esta vez, por decisi√≥n un√°nime del consejo editorial, se decidi√≥ otorgar el premio a la mejor pregunta ... al autor de las respuestas.</i>  <i>Creo que estar√° de acuerdo en que esto es justo.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/479486/">https://habr.com/ru/post/479486/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479468/index.html">Edge of Honesty and John Doe</a></li>
<li><a href="../479474/index.html">Why is self-organization of teams so important in Scrum and why there cannot be managers in it</a></li>
<li><a href="../479478/index.html">Complemento Java sin dolor</a></li>
<li><a href="../479480/index.html">SDK de SARIF y sus errores</a></li>
<li><a href="../479482/index.html">SDK de SARIF y sus errores</a></li>
<li><a href="../479488/index.html">Desde una computadora port√°til: un servidor dom√©stico con alimentaci√≥n redundante al enrutador Mikrotik</a></li>
<li><a href="../479492/index.html">Computaci√≥n sin servidor basada en OpenWhisk, parte 3</a></li>
<li><a href="../479496/index.html">An√°lisis de tareas de WTF en JavaScript</a></li>
<li><a href="../479498/index.html">C√≥mo el tiempo lineal se convierte en Windows en O (n¬≤)</a></li>
<li><a href="../479502/index.html">¬øC√≥mo sobrevivir a la edad de hielo m√°s severa en la historia de la Tierra?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>