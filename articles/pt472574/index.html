<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåö üëéüèº üöû Crie seu Minecraft: gere n√≠veis 3D a partir de cubos üëàüèº üë¥üèæ üßõüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em parte devido √† popularidade do Minecraft , recentemente houve um interesse crescente na id√©ia de um jogo que ocorre em um mundo em cubos, constru√≠d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crie seu Minecraft: gere n√≠veis 3D a partir de cubos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472574/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/jj/va/ccjjvazyarduee258az9-bbggkq.png"></div><br>  Em parte devido √† popularidade do <b>Minecraft</b> , recentemente houve um interesse crescente na id√©ia de um jogo que ocorre em um mundo em cubos, constru√≠do em relevo 3D e repleto de elementos como cavernas, penhascos etc.  Esse mundo √© um aplicativo ideal para o ru√≠do gerado no estilo da minha biblioteca <b>ANL</b> .  Este artigo surgiu das discuss√µes das minhas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tentativas</a> anteriores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de</a> implementar essa t√©cnica.  Desde ent√£o, pequenas altera√ß√µes apareceram na estrutura da biblioteca. <br><br>  Nos posts anteriores, falei sobre o uso de recursos de ru√≠do 3D para implementar terrenos no estilo Minecraft.  Depois disso, a biblioteca evoluiu um pouco, ent√£o decidi voltar a esse t√≥pico.  Como tive que responder muitas perguntas sobre esse sistema, tentarei falar mais sobre os conceitos envolvidos.  Para tornar os conceitos b√°sicos mais claros, come√ßarei com a id√©ia de gerar um terreno 2D usado em jogos como Terraria e King Arthur's Gold e depois expandir o sistema para exemplos 3D como Minecraft.  Isso me permitir√° demonstrar conceitos de maneira mais eficaz usando imagens como exemplo. <br><br>  Este sistema foi desenvolvido levando em considera√ß√£o o seguinte objetivo abstrato: poderemos passar a coordenada de um determinado ponto ou c√©lula para o sistema e determinar que tipo de bloco deve estar nesse local.  Queremos que o sistema seja uma ‚Äúcaixa preta‚Äù: passamos um ponto, retornamos o tipo de bloco.  Obviamente, isso se aplica apenas √† gera√ß√£o inicial do mundo.  Blocos nesses jogos podem ser alterados pelas a√ß√µes do jogador, e ser√° inconveniente tentar descrever essas altera√ß√µes usando o mesmo sistema.  Tais mudan√ßas devem ser rastreadas de alguma outra maneira.  Este sistema gera o mundo original, intocado e intocado pelas m√£os do jogador e de outros personagens. <br><a name="habracut"></a><br>  Talvez essa t√©cnica n√£o seja adequada para modelar sistemas como grama ou outras entidades biol√≥gicas, dado que esses sistemas s√£o entidades complexas que n√£o s√£o t√£o f√°ceis de modelar implicitamente.  O mesmo se aplica a sistemas como queda de neve, forma√ß√£o de gelo, etc. ... A t√©cnica descrita no artigo √© um <i>m√©todo impl√≠cito</i> , ou seja,  aquele que pode ser estimado em um ponto e cujo valor em um determinado ponto n√£o depende dos valores circundantes.  Os tipos de sistemas biol√≥gicos e outros para realizar simula√ß√µes precisas geralmente precisam considerar valores ambientais.  Por exemplo: quanta luz solar cai em um bloco?  Existe √°gua por perto?  Essas e outras perguntas precisam ser respondidas para simular o crescimento e a dissemina√ß√£o de sistemas biol√≥gicos, bem como, em menor grau, outros tipos de sistemas relacionados ao clima.  Al√©m disso, essa t√©cnica n√£o √© adequada para modelagem de √°gua.  Nesse sistema, n√£o h√° conceito de fluxo, conhecimento de mec√¢nica dos fluidos ou gravidade.  A √°gua √© um t√≥pico complexo que requer muitos c√°lculos complexos. <br><br>  Ent√£o, estamos apenas modelando a terra e as pedras.  Precisamos de uma fun√ß√£o que diga qual deve ser o local: terra, areia, ar, ouro, ferro, carv√£o, etc. ... Mas come√ßaremos do mais simples.  Precisamos de uma fun√ß√£o que diga se o bloco √© s√≥lido ou oco (cheio de ar).  Esta fun√ß√£o deve simular a terra que nos rodeia.  Ou seja, o c√©u est√° acima, a terra est√° abaixo.  Ent√£o, vamos assumir a tarefa b√≠blica e separar o c√©u da terra.  Para fazer isso, estudamos a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gradiente</a> .  A fun√ß√£o Gradiente recebe um segmento de linha em um espa√ßo N-dimensional (ou seja, em qualquer espa√ßo de coordenadas, seja 2D, 3D ou superior), e calcula o campo de gradiente ao longo desse segmento.  As coordenadas de entrada s√£o projetadas nesse segmento e seu valor de gradiente √© calculado dependendo de onde elas se encontram em rela√ß√£o aos pontos finais do segmento.  Os pontos projetados recebem valores atribu√≠dos no intervalo (-1,1).  E este ser√° um bom come√ßo para n√≥s.  Podemos definir a fun√ß√£o Gradiente ao longo do eixo Y. No topo do intervalo, comparamos o campo de gradiente com -1 (ar) e na parte inferior com 1 (terra). <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", tipo = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1}
 } </pre><br>  (Vou explicar o registro brevemente. O c√≥digo para os exemplos est√° escrito na tabela de declara√ß√£o Lua. Para obter mais informa√ß√µes sobre o formato, consulte a se√ß√£o sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">integra√ß√£o Lua</a> . Em ess√™ncia, o formato foi projetado para ser analisado por uma classe especial que l√™ an√∫ncios e os transforma em √°rvores de inst√¢ncia de m√≥dulo de ru√≠do. o formato √© mais detalhado no formato C ++, porque √© mais compacto e limpo. Na minha opini√£o, o c√≥digo fonte √© mais leg√≠vel e compactado que o c√≥digo C ++. Na maioria das vezes, as declara√ß√µes s√£o f√°ceis de ler e entender. Os m√≥dulos t√™m nomes, as fontes s√£o especificadas  nome ou valor. O c√≥digo Lua usado para analisar as declara√ß√µes da tabela est√° inclu√≠do no c√≥digo-fonte, caso voc√™ queira us√°-las diretamente.) <br><br>  No caso de 2D, a fun√ß√£o Gradiente recebe o segmento de linha no formato (x1, x2, y1, y2) e, no caso de 3D, o formato √© expandido para (x1, x2, y1, y2, z1, z2).  O ponto formado por (x1, y1) denota o in√≠cio do segmento de linha associado a 0. O ponto formado (x2, y2) √© o final do segmento associado a 1. Ou seja, aqui mapeamos o segmento de linha (0,1) -&gt; ( 0,0) com um gradiente.  Portanto, o gradiente estar√° entre as regi√µes da fun√ß√£o Y = 1 e Y = 0.  Ou seja, essa faixa forma as dimens√µes do mundo em Y. Qualquer parte do mundo estar√° nessa faixa.  Podemos ajustar qualquer regi√£o ao longo de X (quase ad infinitum, mas aqui a precis√£o <code>double</code> nos limita), mas tudo √© interessante, ou seja,  a superf√≠cie da terra estar√° dentro dessa faixa.  Esse comportamento pode ser alterado, mas dentro dele temos um grande grau de flexibilidade.  Apenas n√£o esque√ßa que quaisquer valores que est√£o acima ou abaixo dessa faixa provavelmente n√£o ser√£o interessantes, porque os valores acima provavelmente ser√£o do ar e os valores abaixo do solo.  (Como voc√™ ver√° em breve, essa afirma√ß√£o pode se mostrar errada.) Para a maioria das imagens desta s√©rie, corresponderei √† regi√£o quadrada dada pelo quadrado (0,1) -&gt; (1,0) no espa√ßo 2D.  Portanto, no come√ßo, nosso mundo se parece com isso: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f6/09d/543/5f609d54326fa4c746b5b391b1f75c6a.jpg"></div><br>  Nada interessante at√© agora;  Al√©m disso, esta imagem n√£o responde √† pergunta ‚Äúo ponto dado √© s√≥lido ou oco?‚Äù.  Para responder a essa pergunta, precisamos aplicar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fun√ß√£o Step</a> (fun√ß√£o definida por partes).  Em vez de um gradiente suave, precisamos de uma separa√ß√£o clara, na qual todos os locais de um lado s√£o ocos e todos os locais do outro lado s√£o s√≥lidos.  No <b>ANL,</b> isso pode ser implementado usando a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Selecionar</a> .  A fun√ß√£o Selecionar recebe duas fun√ß√µes ou valores recebidos (nesse caso, eles ser√£o iguais a "s√≥lido" e "Oco" (Aberto)) e os seleciona com base no valor da fun√ß√£o de controle (neste caso, Gradiente).  O m√≥dulo Select possui dois par√¢metros adicionais, <b>threshold</b> e <b>falloff</b> , que afetam esse processo.  Nesse est√°gio, o <b>falloff √©</b> indesej√°vel, portanto o tornamos igual a 0. O par√¢metro <b>threshold</b> decide para onde a linha divis√≥ria entre Solid e Open ir√°.  Tudo o que for maior que esse valor na fun√ß√£o Gradiente se tornar√° S√≥lido e tudo que for menor que o limite ficar√° Aberto.  Como Gradiente compara o intervalo com valores de 0 e 1, seria l√≥gico colocar o limite em 0,5.  Ent√£o, dividimos o espa√ßo exatamente ao meio.  O valor 1 ser√° um local s√≥lido e o valor 0 ser√° oco.  Ou seja, definimos a fun√ß√£o do plano terrestre da seguinte maneira: <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", digite = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_select", digite = "select", baixo = 0, alto = 1, limite = 0,5, control = "ground_gradient"}
 }
</pre><br>  Comparando a mesma √°rea da fun√ß√£o como antes, obtemos algo semelhante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35a/d9c/4b5/35ad9c4b583840222252f7c136ba983a.jpg"></div><br>  Esta figura responde claramente √† quest√£o de saber se o ponto dado √© s√≥lido ou oco.  Podemos chamar a fun√ß√£o com qualquer coordenada poss√≠vel do espa√ßo 2D, e seu resultado ser√° 1 ou 0, dependendo de onde o ponto √© relativo √† superf√≠cie da Terra.  No entanto, essa fun√ß√£o n√£o √© particularmente interessante, √© apenas uma linha plana que se estende at√© o infinito.  Para reviver a imagem, usamos uma t√©cnica chamada "turbul√™ncia". <br><br>  "Turbul√™ncia" √© uma designa√ß√£o complexa do conceito de adi√ß√£o de valores √†s coordenadas recebidas de uma fun√ß√£o.  Imagine que chamamos a fun√ß√£o da Terra acima com a coordenada (0,1).  Est√° acima do plano do solo, porque em Y = 1 o gradiente tem um valor de 0, que √© menor que o limite = 0,5.  Ou seja, esse ponto ser√° calculado como Aberto.  Mas e se, antes de invocar a fun√ß√£o da Terra, de alguma forma transformarmos esse ponto?  Suponha que subtra√≠mos um valor aleat√≥rio da coordenada Y, por exemplo, 3. Subtra√≠mos 3 e obtemos a coordenada (0, -2).  Se agora chamarmos a fun√ß√£o ground para esse ponto, o ponto ser√° considerado s√≥lido, porque Y = -2 fica abaixo do segmento Gradiente correspondente a 1. De repente, o ponto oco (0,1) se transforma em s√≥lido.  Teremos um bloco de pedra s√≥lida pendurado no ar.  Isso pode ser feito com qualquer ponto da fun√ß√£o adicionando ou subtraindo um n√∫mero aleat√≥rio da coordenada Y do ponto de entrada antes de chamar a fun√ß√£o ground_select.  Aqui est√° uma imagem da fun√ß√£o ground_select mostrando isso.  Antes de chamar a fun√ß√£o ground_select, o valor no intervalo (-0,25, 0,25) √© adicionado √† coordenada Y de cada ponto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f28/273/32e/f2827332ed068acf376b4b6cfbf0853d.jpg"></div><br>  Isso √© mais interessante do que uma linha plana, mas n√£o muito semelhante √† Terra, porque cada ponto se move para um valor completamente aleat√≥rio, o que cria um padr√£o ca√≥tico.  No entanto, se usarmos uma fun√ß√£o aleat√≥ria cont√≠nua, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fractal</a> da biblioteca <b>ANL</b> , em vez de um padr√£o aleat√≥rio, obteremos algo mais control√°vel.  Portanto, vamos conectar um fractal ao plano da Terra e ver o que acontece. <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", digite = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", tipo = "fractal", fractaltype = anl.FBM, tipo de base = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 6, frequ√™ncia = 2},
	 {name = "ground_scale", tipo = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_perturb", tipo = "translatoromain", fonte = "ground_gradient", ty = "ground_scale"},<font></font>
	<font></font>
	 {name = "ground_select", digite = "select", baixo = 0, alto = 1, limite = 0,5, control = "ground_perturb"}
 }
</pre><br>  H√° alguns aspectos que vale a pena notar.  Primeiro, definimos o m√≥dulo Fractal e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">associamos ao</a> m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ScaleOffset</a> .  O m√≥dulo ScaleOffset dimensiona os valores fractais de sa√≠da para um n√≠vel mais conveniente.  Parte do relevo pode ser montanhosa e requer uma escala maior, e outra parte - mais plana e com uma escala menor.  Falaremos sobre diferentes tipos de terreno mais tarde, mas por enquanto vamos us√°-los para demonstra√ß√£o.  Os valores de sa√≠da da fun√ß√£o agora fornecer√£o a seguinte imagem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/56e/b55/8ca56eb55e7febec86f3dd80fcea2d0e.jpg"></div><br>  Isso √© mais interessante do que apenas ru√≠do aleat√≥rio, certo?  Pelo menos, parece mais terra, embora parte da paisagem pare√ßa incomum e as ilhas voadoras sejam completamente estranhas.  A raz√£o para isso foi que cada ponto individual do mapa de sa√≠da √© aleatoriamente alterado por um valor diferente determinado pelo fractal.  Para ilustrar isso, mostre a sa√≠da fractal que executa a distor√ß√£o: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbd/67d/b62/fbd67db6235a14fdf6d734d2ac73f560.jpg"></div><br>  Na imagem acima, todos os pontos pretos t√™m um valor de -0,25 e todos os pontos brancos t√™m um valor de 0,25.  Ou seja, onde o fractal √© preto, o ponto correspondente da fun√ß√£o da Terra ser√° deslocado "para baixo" em 0,25.  (0,25 significa 1/4 da tela.) Como um ponto pode ser deslocado levemente e o outro ponto acima no espa√ßo pode ser deslocado mais, existe a possibilidade de sali√™ncias de rochas e ilhas voadoras.  As sali√™ncias na natureza s√£o bastante naturais, em contraste com as ilhas voadoras.  (A menos que estejamos no filme "Avatar".) Se o seu jogo precisa de um cen√°rio t√£o fant√°stico, √© √≥timo, mas se voc√™ precisar de um modelo mais realista, precisamos ajustar um pouco a fun√ß√£o fractal.  Felizmente, a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ScaleDomain</a> pode fazer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">isso</a> . <br><br>  Queremos que a fun√ß√£o se comporte como uma fun√ß√£o de mapa de altura.  Imagine um mapa de altura 2D em que cada ponto no mapa represente a altura de um ponto na grade de pontos da grade que s√£o elevados para cima ou para baixo.  Os valores em branco do mapa indicam colinas altas, vales negros - baixos.  Precisamos de um comportamento semelhante, mas, para alcan√ß√°-lo, precisamos nos livrar essencialmente de uma das dimens√µes.  No caso de um mapa de altura, criamos uma eleva√ß√£o 3D a partir de um mapa de altura 2D.  Da mesma forma, no caso de terrenos 2D, precisamos de um mapa de altura 1D.  Tendo feito para que todos os pontos de um fractal com a mesma coordenada Y tenham o mesmo valor, podemos mudar todos os pontos com a mesma coordenada X pela mesma quantidade, para que as ilhas voadoras desapare√ßam.  Para fazer isso, voc√™ pode usar o ScaleDomain, redefinindo o coeficiente de escala.  Ou seja, antes de chamar a fun√ß√£o ground_shape_fractal, chamamos ground_scale_y para definir a coordenada y como 0. Isso garante que o valor Y n√£o afete a sa√≠da do fractal, transformando-o essencialmente em uma fun√ß√£o de ru√≠do 1D.  Para fazer isso, faremos as seguintes altera√ß√µes: <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", digite = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", tipo = "fractal", fractaltype = anl.FBM, tipo de base = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 6, frequ√™ncia = 2},
	 {name = "ground_scale", tipo = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_scale_y", tipo = "scaledomain", fonte = "ground_scale", scaley = 0},
	 {name = "ground_perturb", tipo = "translatoromain", fonte = "ground_gradient", ty = "ground_scale_y"},<font></font>
	<font></font>
	 {name = "ground_select", digite = "select", baixo = 0, alto = 1, limite = 0,5, control = "ground_perturb"}
 }
</pre><br>  Iremos encadear a fun√ß√£o ScaleDomain com ground_scale e, em seguida, modificaremos os dados ground_perturb originais para serem uma fun√ß√£o ScaleDomain.  Isso mudar√° o fractal que desloca a Terra e o transforma em algo assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca7/e79/4dc/ca7e794dc19c6922c6278cfdf3437caf.jpg"></div><br>  Agora, se dermos uma olhada na sa√≠da, obtemos o resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb2/31a/5d6/bb231a5d6c2e0cfb1f8181ba6de1dc61.jpg"></div><br>  Muito melhor  As ilhas voadoras desapareceram completamente, e o relevo √© mais como montanhas e colinas.  Infelizmente, perdemos sali√™ncias e fal√©sias.  Agora a terra inteira √© cont√≠nua e inclinada.  Se desejar, voc√™ pode corrigir isso de v√°rias maneiras. <br><br>  Primeiro, voc√™ pode usar outra fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TranslateDomain</a> , juntamente com outra fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fractal</a> .  Se aplicarmos uma pequena quantidade de turbul√™ncia fractal na dire√ß√£o X, podemos distorcer levemente as bordas e superf√≠cies das montanhas, e isso provavelmente ser√° suficiente para formar precip√≠cios e bordas.  Vamos ver isso em a√ß√£o. <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", digite = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", tipo = "fractal", fractaltype = anl.FBM, tipo de base = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 6, frequ√™ncia = 2},
	 {name = "ground_scale", tipo = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_scale_y", tipo = "scaledomain", fonte = "ground_scale", scaley = 0},
	 {name = "ground_perturb", tipo = "translatoromain", fonte = "ground_gradient", ty = "ground_scale_y"},
	 {name = "ground_overhang_fractal", tipo = "fractal", tipo de fractal = anl.FBM, tipo de base = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 6, frequ√™ncia = 2},
	 {name = "ground_overhang_scale", tipo = "scaleoffset", fonte = "ground_overhang_fractal", scale = 0,2, offset = 0},
	 {name = "ground_overhang_perturb", tipo = "translatoromain", fonte = "ground_perturb", tx = "ground_overhang_scale"},<font></font>
	<font></font>
	 {name = "ground_select", digite = "select", baixo = 0, alto = 1, limite = 0,5, control = "ground_overhang_perturb"}
 }
</pre><br>  E aqui est√° o resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c3/09f/c4e/4c309fc4e22125fa2083d5bf33e4dc20.jpg"></div><br>  A segunda maneira: voc√™ pode simplesmente definir o par√¢metro <b>scaley</b> da fun√ß√£o <b>ground_scale_y</b> <b>para um</b> valor maior que 0. Se voc√™ deixar uma pequena escala em Y, obteremos uma fra√ß√£o da variabilidade; no entanto, quanto maior a escala, mais forte o relevo ser√° semelhante √† vers√£o anterior sem redimensionar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/f3f/746/225f3f7462f1c78bb48a3603363643aa.jpg"></div><br>  Os resultados parecem muito mais interessantes do que montanhas inclinadas comuns.  No entanto, por mais interessantes que sejam, o jogador ainda ficar√° entediado em explorar o relevo com o mesmo padr√£o, estendendo-se por muitos quil√¥metros.  Al√©m disso, esse al√≠vio seria muito irrealista.  No mundo real, h√° muita varia√ß√£o que aumenta o interesse do al√≠vio.  Vamos ver o que pode ser feito para tornar o mundo mais diversificado. <br><br>  Observando o exemplo de c√≥digo anterior, voc√™ pode ver um padr√£o espec√≠fico nele.  Temos uma fun√ß√£o de gradiente, que √© controlada por fun√ß√µes que d√£o forma √† Terra, ap√≥s a qual uma fun√ß√£o definida por partes √© aplicada e a Terra fica cheia.  Ou seja, ser√° mais l√≥gico complicar o al√≠vio na fase de moldar a terra.  Em vez de um fractal se deslocar ao longo de Y e outro se deslocar ao longo de X, podemos alcan√ßar o grau de complexidade necess√°rio (levando em conta o desempenho: cada fractal requer custos computacionais adicionais, portanto, devemos tentar ser conservadores.) Podemos especificar as formas da Terra, que s√£o montanhas, sop√© , plan√≠cies planas, terrenos baldios, etc ... e use a sa√≠da das v√°rias fun√ß√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Select</a> encadeadas com fractais de baixa frequ√™ncia para delinear √°reas de cada tipo.  Ent√£o, vamos ver como voc√™ pode implementar diferentes tipos de terreno. <br><br>  Para ilustrar o princ√≠pio, distinguimos tr√™s tipos de relevo: planaltos (colinas lisas e inclinadas), montanhas e plan√≠cies (principalmente planas).  Para alternar entre eles, usamos um sistema baseado em sele√ß√£o e os combinamos em uma tela complexa.  Ent√£o aqui vamos n√≥s ... <br><br>  <b>Contrafortes:</b> <br><br>  Com eles, tudo √© simples.  Podemos usar o esquema usado acima, reduzir um pouco a amplitude das colinas, talvez at√© torn√°-las mais subtrativas do que aditivas.  para diminuir as alturas m√©dias.  Tamb√©m podemos reduzir a contagem de oitavas para suaviz√°-las. <br><br><pre> {name = "lowland_shape_fractal", tipo = "fractal", fractaltype = anl.FBM, tipo de base = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 2, frequ√™ncia = 1},
 {name = "lowland_autocorrect", tipo = "autocorrect", fonte = "lowland_shape_fractal", low = 0, high = 1},
 {name = "lowland_scale", tipo = "scaleoffset", fonte = "lowland_autocorrect", scale = 0,2, offset = -0,25},
 {name = "lowland_y_scale", tipo = "scaledomain", fonte = "lowland_scale", scaley = 0},
 {name = "lowland_terrain", tipo = "translatoromain", fonte = "ground_gradient", ty = "lowland_y_scale"},
</pre><br>  <b>Terras Altas:</b> <br><br>  Com eles tamb√©m tudo √© simples.  (De fato, nenhum desses tipos de terreno √© dif√≠cil.) No entanto, usamos uma base diferente para fazer as colinas parecerem dunas. <br><br><pre> {name = "highland_shape_fractal", tipo = "fractal", fractaltype = anl.RIDGEDMULTI, tipo de base = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 2, frequ√™ncia = 2},
 {name = "highland_autocorrect", tipo = "autocorrect", fonte = "highland_shape_fractal", baixo = 0, alto = 1},
 {name = "highland_scale", tipo = "scaleoffset", fonte = "highland_autocorrect", scale = 0,45, offset = 0},
 {name = "highland_y_scale", tipo = "scaledomain", fonte = "highland_scale", scaley = 0},
 {name = "highland_terrain", tipo = "translateomain", fonte = "ground_gradient", ty = "highland_y_scale"},
</pre><br>  <b>Montanhas:</b> <br><br><pre> {name = "mountain_shape_fractal", tipo = "fractal", fractaltype = anl.BILLOW, basistype = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 4, frequ√™ncia = 1},
 {name = "mountain_autocorrect", tipo = "autocorrect", fonte = "mountain_shape_fractal", baixo = 0, alto = 1},
 {name = "mountain_scale", tipo = "scaleoffset", fonte = "mountain_autocorrect", scale = 0,75, deslocamento = 0,25},
 {name = "mountain_y_scale", tipo = "scaledomain", fonte = "mountain_scale", scaley = 0.1},
 {name = "mountain_terrain", tipo = "translatoromain", fonte = "ground_gradient", ty = "mountain_y_scale"},
</pre><br>  Claro, voc√™ pode abordar esse processo ainda mais criativamente, mas, em geral, o padr√£o ser√° assim.  Destacamos as caracter√≠sticas do tipo de relevo e selecionamos as fun√ß√µes de ru√≠do para elas.  Por tudo isso, os mesmos princ√≠pios se aplicam;  As principais diferen√ßas s√£o de escala.  Agora, para conect√°-los, prepararemos fractais adicionais que controlar√£o a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Selecionar</a> .  Em seguida, encadeamos os m√≥dulos Select para gerar todo o terreno. <br><br><pre> {name = "terrain_type_fractal", tipo = "fractal", fractaltype = anl.FBM, tipo b√°sico = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 3, frequ√™ncia = 0,5},
 {name = "terrain_autocorrect", tipo = "autocorrect", fonte = "terrain_type_fractal", baixo = 0, alto = 1},
 {name = "terrain_type_cache", digite = "cache", origem = "terrain_autocorrect"},
 {name = "highland_mountain_select", digite = "select", low = "highland_terrain", high = "mountain_terrain", control = "terrain_type_cache", limite = 0,55, falloff = 0,15},
 {name = "highland_lowland_select", digite = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "terreno_type_cache", limite = 0,25, queda = 0,15},
</pre><br>  Ent√£o, aqui definimos tr√™s tipos principais de terreno: terras baixas, terras altas e montanhas.  Usamos um fractal para selecionar um deles, para que haja transi√ß√µes naturais (terras baixas-&gt; terras altas-&gt; montanhas).  Em seguida, usamos outro fractal para inserir aleatoriamente ermos no mapa.  Veja como √© a cadeia de m√≥dulos finalizada: <br><br><pre> terraintree =
 {
	 {name = "lowland_shape_fractal", tipo = "fractal", fractaltype = anl.FBM, tipo de base = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 2, frequ√™ncia = 1},
	 {name = "lowland_autocorrect", tipo = "autocorrect", fonte = "lowland_shape_fractal", low = 0, high = 1},
	 {name = "lowland_scale", tipo = "scaleoffset", fonte = "lowland_autocorrect", scale = 0,2, offset = -0,25},
	 {name = "lowland_y_scale", tipo = "scaledomain", fonte = "lowland_scale", scaley = 0},
	 {name = "lowland_terrain", tipo = "translatoromain", fonte = "ground_gradient", ty = "lowland_y_scale"},
	 {name = "ground_gradient", digite = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "highland_shape_fractal", tipo = "fractal", fractaltype = anl.RIDGEDMULTI, tipo de base = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 2, frequ√™ncia = 2},
	 {name = "highland_autocorrect", tipo = "autocorrect", fonte = "highland_shape_fractal", baixo = 0, alto = 1},
	 {name = "highland_scale", tipo = "scaleoffset", fonte = "highland_autocorrect", scale = 0,45, offset = 0},
	 {name = "highland_y_scale", tipo = "scaledomain", fonte = "highland_scale", scaley = 0},
	 {name = "highland_terrain", tipo = "translateomain", fonte = "ground_gradient", ty = "highland_y_scale"},<font></font>
<font></font>
	 {name = "mountain_shape_fractal", tipo = "fractal", fractaltype = anl.BILLOW, basistype = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 4, frequ√™ncia = 1},
	 {name = "mountain_autocorrect", tipo = "autocorrect", fonte = "mountain_shape_fractal", baixo = 0, alto = 1},
	 {name = "mountain_scale", tipo = "scaleoffset", fonte = "mountain_autocorrect", scale = 0,75, deslocamento = 0,25},
	 {name = "mountain_y_scale", tipo = "scaledomain", fonte = "mountain_scale", scaley = 0.1},
	 {name = "mountain_terrain", tipo = "translatoromain", fonte = "ground_gradient", ty = "mountain_y_scale"},<font></font>
<font></font>
	 {name = "terrain_type_fractal", tipo = "fractal", fractaltype = anl.FBM, tipo b√°sico = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 3, frequ√™ncia = 0,5},
	 {name = "terrain_autocorrect", tipo = "autocorrect", fonte = "terrain_type_fractal", baixo = 0, alto = 1},
	 {name = "terrain_type_cache", digite = "cache", origem = "terrain_autocorrect"},
	 {name = "highland_mountain_select", digite = "select", low = "highland_terrain", high = "mountain_terrain", control = "terrain_type_cache", limite = 0,55, falloff = 0,15},
	 {name = "highland_lowland_select", digite = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "terreno_type_cache", limite = 0,25, queda = 0,15},
	 {name = "ground_select", digite = "select", baixo = 0, alto = 1, limite = 0,5, control = "highland_lowland_select"}
 }
</pre><br>  Aqui est√£o alguns exemplos dos relevos resultantes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/60f/afe/4c460fafe39eec4680ac6eb3c341beef.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/241/869/9c8241869337938b628d0b9a53a3e756.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/538/67a/f3a/53867af3a00abb26d5b0f32f5f728694.jpg"></div><br>  Voc√™ pode perceber que √© obtida uma variabilidade bastante alta.  Em alguns lugares, montanhas altas e quebradas aparecem; em outros, plan√≠cies inclinadas e lisas.  Agora precisamos adicionar cavernas para que possamos explorar as maravilhas do submundo. <br><br>  Para cavernas, eu uso o sistema multiplicativo aplicado ao <b>ground_select</b> .  Ou seja, eu crio uma fun√ß√£o que gera 1 ou 0 e multiplico-as pela sa√≠da de <b>ground_select</b> .  Gra√ßas a isso, qualquer ponto da fun√ß√£o se torna oco, para o qual o valor da fun√ß√£o das cavernas √© 0. Ou seja, onde eu quero obter a caverna, a fun√ß√£o das cavernas deve retornar 0 e, onde a caverna n√£o deve estar, a fun√ß√£o deve ser 1. Quanto √† forma cavernas, quero estabelecer um sistema de cavernas baseado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Multifractal Ridged de</a> 1 oitava. <br><br><pre> {name = "cave_shape", tipo = "fractal", tipo fractal = anl.RIDGEDMULTI, tipo b√°sico = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 1, frequ√™ncia = 2},
</pre><br>  O resultado √© algo como isto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/bf0/297/31cbf02975f1852907bb3a0f24ffd43a.jpg"></div><br>  Se aplicarmos a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Selecionar</a> como uma fun√ß√£o definida por partes, como fizemos com o gradiente da Terra, implementando-a para que a parte inferior do limite de sele√ß√£o seja 1 (n√£o h√° caverna) e a parte superior seja 0 (h√° uma caverna), o resultado ser√° algo como isto : <br><br><pre> {name = "cave_shape", tipo = "fractal", tipo fractal = anl.RIDGEDMULTI, tipo b√°sico = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 1, frequ√™ncia = 2},
 {name = "cave_select", tipo = "select", baixo = 1, alto = 0, controle = "cave_shape", limite = 0,8, falloff = 0},
</pre><br>  Resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d8/55a/c47/1d855ac477dd48ba59d20ed30d89bde6.jpg"></div><br>  Obviamente, parece bastante suave, ent√£o adicione algum ru√≠do fractal para distorcer a √°rea. <br><br><pre> {name = "cave_shape", tipo = "fractal", tipo fractal = anl.RIDGEDMULTI, tipo b√°sico = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 1, frequ√™ncia = 2},
 {name = "cave_select", tipo = "select", baixo = 1, alto = 0, controle = "cave_shape", limite = 0,8, falloff = 0},
 {name = "cave_perturb_fractal", tipo = "fractal", tipo de fractal = anl.FBM, tipo de base = anl.GRADIENT, interptype = anl.QUINTIC, oitavas = 6, frequ√™ncia = 3},
 {name = "cave_perturb_scale", tipo = "scaleoffset", fonte = "cave_perturb_fractal", escala = 0,25, deslocamento = 0},<font></font>
{name="cave_perturb", type="translatedomain", source="cave_select", tx="cave_perturb_scale"},<font></font>
</pre><br> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ec/deb/4fa/0ecdeb4faf32eea11c05a7a76b7c6225.jpg"></div><br>          .   ,  ,     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d34/974/278/d34974278435e239ad7eb9193adc9672.jpg"></div><br>    <b>threshold</b>  <b>cave_select</b> ,       .  ,     ‚Äî  ,         .       <b>highland_lowland_select</b> , ,   ,    ,   .     ,      ,       .        ,       .    ,          <b>highland_lowland_select</b>    <b>cave_shape</b> ,       .       ‚Äî   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cache</a> .         ,         ,    ,      .     ,     ( <b>highland_lowland_select</b> )      .           .   ,      : <br><br><pre>{name="highland_lowland_select", type="select", low="lowland_terrain", high="highland_mountain_select", control="terrain_type_cache", threshold=0.25, falloff=0.15},<font></font>
{name="highland_lowland_select_cache", type="cache", source="highland_lowland_select"},<font></font>
{name="ground_select", type="select", low=0, high=1, threshold=0.5, control="highland_lowland_select_cache"},<font></font>
</pre><br>    Cache,      <b>ground_select</b> ,     ,     .      ,   : <br><br><pre>{name="cave_shape", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape", source_1="cave_attenuate_bias"},<font></font>
{name="cave_perturb_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=6, frequency=3},<font></font>
{name="cave_perturb_scale", type="scaleoffset", source="cave_perturb_fractal", scale=0.5, offset=0},<font></font>
{name="cave_perturb", type="translatedomain", source="cave_shape_attenuate", tx="cave_perturb_scale"},<font></font>
{name="cave_select", type="select", low=1, high=0, control="cave_perturb", threshold=0.48, falloff=0},<font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, adicionamos a fun√ß√£o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vi√©s</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Isso √© por conveni√™ncia, porque permite ajustar o intervalo da fun√ß√£o de atenua√ß√£o do gradiente. Em seguida, a fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape_attenuate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© </font><b><font style="vertical-align: inherit;">adicionada</font></b><font style="vertical-align: inherit;"> , que √© um </font><b><font style="vertical-align: inherit;">combinador </font></b></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tipo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anl :: MULT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ela multiplica o gradiente por </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Em seguida, o resultado dessa opera√ß√£o √© passado para a fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_perturb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O resultado √© algo como isto:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f8/55d/fd3/8f855dfd376c5d8049a075d28066f72c.jpg"></div><br>  ,       . (     ,      ,      .     ‚Äî ,       - ,        (0,1).)   ,       ,        ,  ,  .    ,    . <br><br><pre>terraintree=
 {<font></font>
	{name="ground_gradient", type="gradient", x1=0, x2=0, y1=0, y2=1},<font></font>
	<font></font>
	{name="lowland_shape_fractal", type="fractal", fractaltype=anl.BILLOW, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=2, frequency=0.25},<font></font>
	{name="lowland_autocorrect", type="autocorrect", source="lowland_shape_fractal", low=0, high=1},<font></font>
	{name="lowland_scale", type="scaleoffset", source="lowland_autocorrect", scale=0.125, offset=-0.45},<font></font>
	{name="lowland_y_scale", type="scaledomain", source="lowland_scale", scaley=0},<font></font>
	{name="lowland_terrain", type="translatedomain", source="ground_gradient", ty="lowland_y_scale"},<font></font>
	<font></font>
	{name="highland_shape_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=4, frequency=2},<font></font>
	{name="highland_autocorrect", type="autocorrect", source="highland_shape_fractal", low=-1, high=1},<font></font>
	{name="highland_scale", type="scaleoffset", source="highland_autocorrect", scale=0.25, offset=0},<font></font>
	{name="highland_y_scale", type="scaledomain", source="highland_scale", scaley=0},<font></font>
	{name="highland_terrain", type="translatedomain", source="ground_gradient", ty="highland_y_scale"},<font></font>
<font></font>
	{name="mountain_shape_fractal", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=8, frequency=1},<font></font>
	{name="mountain_autocorrect", type="autocorrect", source="mountain_shape_fractal", low=-1, high=1},<font></font>
	{name="mountain_scale", type="scaleoffset", source="mountain_autocorrect", scale=0.45, offset=0.15},<font></font>
	{name="mountain_y_scale", type="scaledomain", source="mountain_scale", scaley=0.25},<font></font>
	{name="mountain_terrain", type="translatedomain", source="ground_gradient", ty="mountain_y_scale"},<font></font>
<font></font>
	{name="terrain_type_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=3, frequency=0.125},<font></font>
	{name="terrain_autocorrect", type="autocorrect", source="terrain_type_fractal", low=0, high=1},<font></font>
	{name="terrain_type_y_scale", type="scaledomain", source="terrain_autocorrect", scaley=0},<font></font>
	{name="terrain_type_cache", type="cache", source="terrain_type_y_scale"},<font></font>
	{name="highland_mountain_select", type="select", low="highland_terrain", high="mountain_terrain", control="terrain_type_cache", threshold=0.55, falloff=0.2},<font></font>
	{name="highland_lowland_select", type="select", low="lowland_terrain", high="highland_mountain_select", control="terrain_type_cache", threshold=0.25, falloff=0.15},<font></font>
	{name="highland_lowland_select_cache", type="cache", source="highland_lowland_select"},<font></font>
	{name="ground_select", type="select", low=0, high=1, threshold=0.5, control="highland_lowland_select_cache"},<font></font>
	<font></font>
	{name="cave_shape", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
	{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape", source_1="cave_attenuate_bias"},<font></font>
	{name="cave_perturb_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=6, frequency=3},<font></font>
	{name="cave_perturb_scale", type="scaleoffset", source="cave_perturb_fractal", scale=0.5, offset=0},<font></font>
	{name="cave_perturb", type="translatedomain", source="cave_shape_attenuate", tx="cave_perturb_scale"},<font></font>
	{name="cave_select", type="select", low=1, high=0, control="cave_perturb", threshold=0.48, falloff=0},<font></font>
	<font></font>
	{name="ground_cave_multiply", type="combiner", operation=anl.MULT, source_0="cave_select", source_1="ground_select"}<font></font>
 }
</pre><br>    ,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f8/1a5/ca8/9f81a5ca8f1b739c03721b6a5ba280a5.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c86/5ec/b69/c865ecb69a1701a1b757535f289c6c0a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a82/332/1e3/a823321e389de00947e695424497f2e9.jpg"></div><br>     .          ,          .     .  ,      .   ?   ?     ,       ,     ,    .  , .    . <br><br>       ,   .     threshold  <b>cave_select</b>    <b>cave_attenuate_bias</b> ,   <b>cave_attenuate_bias</b>   ,       ,    .      ,      Y,          X ( ,       X).         ,     <b>cave_shape_attenuate</b> ,     ,        (,  ),       .   select     <b>terrain_type_fractal</b> ,  ,    .     ,  ,   ,   ,         ,    ,     .    ,         . <br><br><h2>  </h2><br>       .       .      ,    ,   ,    .        ,    .        ,         .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ScaleOffset</a>            ,      .  2D    ,      3D     ,    . <br><br><h1>   3D </h1><br>   ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Terraria</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">King Arthur's Gold</a> ,  ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Minecraft</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Infiniminer</a> ?         ?   ,    .          3D-.     3D-,  3D- ,     Y    ,   2D-.  -   ,  ,   .   , Ridged Multifractal    2D- ,   3D     ,   ,     .    3D      ,   1-  Ridged Multifractal,    seed.   Select    1  0,   .  ,      ,     ,       ,     . <br><br><pre>terraintree3d=
 {<font></font>
	{name="ground_gradient", type="gradient", x1=0, x2=0, y1=0, y2=1},<font></font>
	<font></font>
	{name="lowland_shape_fractal", type="fractal", fractaltype=anl.BILLOW, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=2, frequency=0.25},<font></font>
	{name="lowland_autocorrect", type="autocorrect", source="lowland_shape_fractal", low=0, high=1},<font></font>
	{name="lowland_scale", type="scaleoffset", source="lowland_autocorrect", scale=0.125, offset=-0.45},<font></font>
	{name="lowland_y_scale", type="scaledomain", source="lowland_scale", scaley=0},<font></font>
	{name="lowland_terrain", type="translatedomain", source="ground_gradient", ty="lowland_y_scale"},<font></font>
	<font></font>
	{name="highland_shape_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=4, frequency=2},<font></font>
	{name="highland_autocorrect", type="autocorrect", source="highland_shape_fractal", low=-1, high=1},<font></font>
	{name="highland_scale", type="scaleoffset", source="highland_autocorrect", scale=0.25, offset=0},<font></font>
	{name="highland_y_scale", type="scaledomain", source="highland_scale", scaley=0},<font></font>
	{name="highland_terrain", type="translatedomain", source="ground_gradient", ty="highland_y_scale"},<font></font>
<font></font>
	{name="mountain_shape_fractal", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=8, frequency=1},<font></font>
	{name="mountain_autocorrect", type="autocorrect", source="mountain_shape_fractal", low=-1, high=1},<font></font>
	{name="mountain_scale", type="scaleoffset", source="mountain_autocorrect", scale=0.45, offset=0.15},<font></font>
	{name="mountain_y_scale", type="scaledomain", source="mountain_scale", scaley=0.25},<font></font>
	{name="mountain_terrain", type="translatedomain", source="ground_gradient", ty="mountain_y_scale"},<font></font>
<font></font>
	{name="terrain_type_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=3, frequency=0.125},<font></font>
	{name="terrain_autocorrect", type="autocorrect", source="terrain_type_fractal", low=0, high=1},<font></font>
	{name="terrain_type_y_scale", type="scaledomain", source="terrain_autocorrect", scaley=0},<font></font>
	{name="terrain_type_cache", type="cache", source="terrain_type_y_scale"},<font></font>
	{name="highland_mountain_select", type="select", low="highland_terrain", high="mountain_terrain", control="terrain_type_cache", threshold=0.55, falloff=0.2},<font></font>
	{name="highland_lowland_select", type="select", low="lowland_terrain", high="highland_mountain_select", control="terrain_type_cache", threshold=0.25, falloff=0.15},<font></font>
	{name="highland_lowland_select_cache", type="cache", source="highland_lowland_select"},<font></font>
	{name="ground_select", type="select", low=0, high=1, threshold=0.5, control="highland_lowland_select_cache"},<font></font>
	<font></font>
	{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
	{name="cave_shape1", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_shape2", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape1", source_1="cave_attenuate_bias", source_2="cave_shape2"},             <font></font>
	{name="cave_perturb_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=6, frequency=3},<font></font>
	{name="cave_perturb_scale", type="scaleoffset", source="cave_perturb_fractal", scale=0.5, offset=0},<font></font>
	{name="cave_perturb", type="translatedomain", source="cave_shape_attenuate", tx="cave_perturb_scale"},<font></font>
	{name="cave_select", type="select", low=1, high=0, control="cave_perturb", threshold=0.48, falloff=0},<font></font>
	<font></font>
	{name="ground_cave_multiply", type="combiner", operation=anl.MULT, source_0="cave_select", source_1="ground_select"}<font></font>
 }
</pre><br>  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/484/3fa/8e9/4843fa8e95e46162345f36edcf767fbe.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b91/671/848/b91671848dac9a42f371d549adf07181.jpg"></div><br> ,      . ,        ,      ,    ,  .‚Ä¶ ,    ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472574/">https://habr.com/ru/post/pt472574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472562/index.html">Tend√™ncias financeiras: grandes empresas precisam de mais e mais profissionais de TI</a></li>
<li><a href="../pt472566/index.html">O inferno pessoal do escritor Fraerman, ou o Conto do Primeiro Amor</a></li>
<li><a href="../pt472568/index.html">Apache Ignite Zero Deployment: exatamente zero?</a></li>
<li><a href="../pt472570/index.html">Grande atualiza√ß√£o do Intel Xeon W</a></li>
<li><a href="../pt472572/index.html">DevOps and Chaos: entrega de software em um mundo descentralizado</a></li>
<li><a href="../pt472576/index.html">XVI confer√™ncia de desenvolvedores de software livre ou onde obter colaboradores gratuitos</a></li>
<li><a href="../pt472580/index.html">Gerenciamento de servi√ßos corporativos: por que estender o gerenciamento de servi√ßos al√©m da TI</a></li>
<li><a href="../pt472582/index.html">Hist√≥rico da Internet: Computador como dispositivo de comunica√ß√£o</a></li>
<li><a href="../pt472586/index.html">An√°lise do viva-voz: o que h√° dentro e como funciona</a></li>
<li><a href="../pt472588/index.html">Tudo o que voc√™ queria saber sobre o p√™ndulo reverso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>