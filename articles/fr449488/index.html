<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏕️ 🧑🏼 👩🏿‍🏭 Cataclysm Dark Days Ahead: analyse statique et jeux Roguelike ⛓️ 💵 🛸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vous devez avoir deviné à partir du titre que l'article d'aujourd'hui se concentrera sur les bogues dans le code source du logiciel. Mais pas seulemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cataclysm Dark Days Ahead: analyse statique et jeux Roguelike</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/449488/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f8/70b/ef1/2f870bef158597577eac654a524b00ac.png" alt="Image 5"></div><br>  Vous devez avoir deviné à partir du titre que l'article d'aujourd'hui se concentrera sur les bogues dans le code source du logiciel.  Mais pas seulement ça.  Si vous êtes non seulement intéressé par le C ++ et par la lecture de bogues dans le code d'autres développeurs, mais aussi que vous creusez des jeux vidéo inhabituels et que vous vous demandez ce que sont les "roguelikes" et comment vous les jouez, alors n'hésitez pas à lire! <br><a name="habracut"></a><br>  En recherchant des jeux insolites, je suis tombé sur <i>Cataclysm Dark Days Ahead</i> , qui se démarque parmi d'autres jeux grâce à ses graphismes basés sur des caractères ASCII de différentes couleurs disposés sur le fond noir. <br><br>  Une chose qui vous étonne à propos de ce jeu et d'autres jeux similaires est la quantité de fonctionnalités qui y sont intégrées.  En particulier dans <i>Cataclysm</i> , par exemple, vous ne pouvez même pas créer un personnage sans ressentir le besoin de rechercher des guides sur Google en raison des dizaines de paramètres, de traits et de scénarios initiaux disponibles, sans parler des multiples variations d'événements qui se produisent tout au long du jeu. <br><br>  Puisqu'il s'agit d'un jeu avec du code open-source, et un écrit en C ++, nous ne pouvions pas passer sans le vérifier avec notre analyseur de code statique PVS-Studio, au développement duquel je participe activement.  Le code du projet est étonnamment de haute qualité, mais il a encore quelques défauts mineurs, dont je parlerai dans cet article. <br><br>  Beaucoup de jeux ont déjà été vérifiés avec PVS-Studio.  Vous pouvez trouver quelques exemples dans notre article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyse statique dans le développement de jeux vidéo: Top 10 des bugs logiciels</a> ". <br><br><h2>  La logique </h2><br>  <b>Exemple 1:</b> <br><br>  Cet exemple montre une erreur de copier-coller classique. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V501</a> Il existe des sous-expressions identiques à gauche et à droite de '||'  opérateur: rng (2, 7) &lt;abs (z) ||  rng (2, 7) &lt;abs (z) overmap.cpp 1503 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> overmap::generate_sub( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z ) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( rng( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( z ) || rng( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( z ) ) { .... } .... }</code> </pre> <br>  La même condition est vérifiée deux fois.  Le programmeur a copié l'expression mais a oublié de modifier la copie.  Je ne sais pas s'il s'agit d'un bogue critique, mais le fait est que la vérification ne fonctionne pas comme prévu. <br><br>  Une autre erreur similaire: <br><br><ul><li>  V501 Il existe des sous-expressions identiques «one_in (100000 / to_turns &lt;int&gt; (dur))» à gauche et à droite de l'opérateur «&amp;&amp;».  player_hardcoded_effects.cpp 547 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/a93/7ac/d92a937ac860e5f2fb5ded04b8e05683.png" alt="Image 11"></div><br>  <b>Exemple 2:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V728</a> Un contrôle excessif peut être simplifié.  Le '(A &amp;&amp; B) ||  (! A &amp;&amp;! B) 'est équivalente à l'expression' bool (A) == bool (B) '.  inventaire_ui.cpp 199 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inventory_selector_preset::sort_compare( .... ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> left_fav = g-&gt;u.inv.assigned.count( lhs.location-&gt;invlet ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> right_fav = g-&gt;u.inv.assigned.count( rhs.location-&gt;invlet ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( left_fav &amp;&amp; right_fav ) || ( !left_fav &amp;&amp; !right_fav ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .... } .... }</code> </pre> <br>  Cette condition est logiquement correcte, mais elle est trop compliquée.  Celui qui a écrit ce code aurait dû avoir pitié de leurs collègues programmeurs qui le maintiendront.  Il pourrait être réécrit sous une forme plus simple: <i>if (left_fav == right_fav)</i> . <br><br>  Une autre erreur similaire: <br><br><ul><li>  V728 Un contrôle excessif peut être simplifié.  Le '(A &amp;&amp;! B) ||  (! A &amp;&amp; B) 'est équivalente à l'expression' bool (A)! = Bool (B) '.  iuse_actor.cpp 2653 </li></ul><br><h2>  Digression i </h2><br>  J'ai été surpris de découvrir que les jeux portant le nom de "roguelikes" ne sont aujourd'hui que des représentants plus modérés de l'ancien genre des jeux roguelike.  Tout a commencé avec le jeu culte <i>Rogue</i> de 1980, qui a inspiré de nombreux étudiants et programmeurs à créer leurs propres jeux avec des éléments similaires.  Je suppose que beaucoup d'influence est également venue de la communauté du jeu de table <i>DnD</i> et de ses variantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/d85/de3/4dcd85de3509609962cab730653f7ed1.png" alt="Image 8"></div><br><h2>  Micro-optimisations </h2><br>  <b>Exemple 3:</b> <br><br>  Les avertissements de ce groupe pointent vers des spots qui pourraient potentiellement être optimisés plutôt que des bugs. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V801</a> Diminution des performances.  Il est préférable de redéfinir le deuxième argument de fonction comme référence.  Pensez à remplacer "const ... type" par "const ... &amp; type".  map.cpp 4644 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Stack&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;item&gt; use_amount_stack( Stack <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itype_id type ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;item&gt; ret; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.begin(); a != <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.end() &amp;&amp; quantity &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a-&gt;use_amount( type, ret ) ) { a = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.erase( a ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++a; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  Dans ce code, <i>itype_id</i> est en fait une <i>chaîne std ::</i> déguisée.  Comme l'argument est de toute façon passé comme une constante, ce qui signifie qu'il est immuable, le simple fait de passer une référence à la variable aiderait à améliorer les performances et à économiser les ressources de calcul en évitant l'opération de copie.  Et même s'il est peu probable que la chaîne soit longue, la copier à chaque fois sans bonne raison est une mauvaise idée - d'autant plus que cette fonction est appelée par divers appelants, qui, à leur tour, obtiennent également un <i>type</i> de l'extérieur et ont pour le copier. <br><br>  Problèmes similaires: <br><br><ul><li>  V801 Diminution des performances.  Il est préférable de redéfinir le troisième argument de fonction comme référence.  Pensez à remplacer 'const ... evt_filter' par 'const ... &amp; evt_filter'.  input.cpp 691 </li><li>  V801 Diminution des performances.  Il est préférable de redéfinir le cinquième argument de fonction comme référence.  Pensez à remplacer «const ... color» par «const ... &amp; color».  output.h 207 </li><li>  L'analyseur a émis un total de 32 avertissements de ce type. </li></ul><br>  <b>Exemple 4:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V813</a> Performances <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réduites</a> .  L'argument 'str' devrait probablement être rendu comme une référence constante.  catacharset.cpp 256 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base64_encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( str.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; str[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'#'</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> input_length = str.length(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encoded_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( output_length, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'\0'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; input_length; ) { .... } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mod_table[input_length % <span class="hljs-number"><span class="hljs-number">3</span></span>]; i++ ) { encoded_data[output_length - <span class="hljs-number"><span class="hljs-number">1</span></span> - i] = <span class="hljs-string"><span class="hljs-string">'='</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"#"</span></span> + encoded_data; }</code> </pre> <br>  Bien que l'argument ne soit pas constant, il ne change en aucune façon dans le corps de la fonction.  Par conséquent, dans un souci d'optimisation, une meilleure solution serait de le passer par référence constante plutôt que de forcer le compilateur à créer des copies locales. <br><br>  Cet avertissement n'est pas venu seul non plus;  le nombre total d'avertissements de ce type est de 26. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/557/9b3/4ff5579b36733a7bd46f4c3df6f30d90.png" alt="Image 7"></div><br>  Problèmes similaires: <br><br><ul><li>  V813 Performances réduites.  L'argument 'message' devrait probablement être restitué comme une référence constante.  json.cpp 1452 </li><li>  V813 Performances réduites.  L'argument 's' devrait probablement être rendu comme une référence constante.  catacharset.cpp 218 </li><li>  Et ainsi de suite ... </li></ul><br><h2>  Digression ii </h2><br>  Certains des jeux roguelike classiques sont toujours en développement actif.  Si vous vérifiez les référentiels GitHub de <i>Cataclysm DDA</i> ou <i>NetHack</i> , vous verrez que les modifications sont soumises tous les jours.  <i>NetHack</i> est en fait le plus ancien jeu en cours de développement: il est sorti en juillet 1987 et la dernière version remonte à 2018. <br><br>  <i>Dwarf Fortress</i> est l'un des jeux les plus populaires - bien que plus jeunes - du genre.  Le développement a commencé en 2002 et la première version est sortie en 2006. Sa devise "Losing is fun" reflète le fait qu'il est impossible de gagner dans ce jeu.  En 2007, <i>Dwarf Fortress</i> a reçu le prix du meilleur jeu Roguelike de l'année en votant chaque année sur le site ASCII GAMES. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e39/7fb/efa/e397fbefa4204777cc74d97e2b8e52e9.png" alt="Image 6"></div><br>  Soit dit en passant, les fans pourraient être heureux de savoir que <i>Dwarf Fortress</i> arrive sur Steam avec des graphiques 32 bits améliorés ajoutés par deux modders expérimentés.  La version premium bénéficiera également de morceaux de musique supplémentaires et de la prise en charge de Steam Workshop.  Les propriétaires de copies payantes pourront passer aux anciens graphiques ASCII s'ils le souhaitent.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">En savoir plus</a> <br><br><h2>  Substitution de l'opérateur d'affectation </h2><br>  <b>Exemples 5, 6:</b> <br><br>  Voici quelques avertissements intéressants. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V690</a> La classe 'JsonObject' implémente un constructeur de copie, mais il manque l'opérateur '='.  Il est dangereux d'utiliser une telle classe.  json.h 647 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonObject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: .... JsonIn *jsin; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: JsonObject( JsonIn &amp;jsin ); JsonObject( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> JsonObject &amp;jsobj ); JsonObject() : positions(), start( <span class="hljs-number"><span class="hljs-number">0</span></span> ), end( <span class="hljs-number"><span class="hljs-number">0</span></span> ), jsin( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) {} ~JsonObject() { finish(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// moves the stream to the end of the object .... void JsonObject::finish() { .... } .... }</span></span></code> </pre> <br>  Cette classe a un constructeur de copie et un destructeur mais ne remplace pas l'opérateur d'affectation.  Le problème est qu'un opérateur d'affectation généré automatiquement ne peut affecter le pointeur qu'à <i>JsonIn</i> .  Par conséquent, les deux objets de la classe <i>JsonObject</i> pointeraient vers le même <i>JsonIn</i> .  Je ne peux pas dire avec certitude si une telle situation pourrait se produire dans la version actuelle, mais quelqu'un tombera sûrement dans ce piège un jour. <br><br>  La classe suivante a un problème similaire. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V690</a> La classe 'JsonArray' implémente un constructeur de copie, mais il manque l'opérateur '='.  Il est dangereux d'utiliser une telle classe.  json.h 820 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonArray</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: .... JsonIn *jsin; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: JsonArray( JsonIn &amp;jsin ); JsonArray( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> JsonArray &amp;jsarr ); JsonArray() : positions(), ...., jsin( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) {}; ~JsonArray() { finish(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// move the stream position to the end of the array void JsonArray::finish() { .... } }</span></span></code> </pre> <br>  Le danger de ne pas remplacer l'opérateur d'affectation dans une classe complexe est expliqué en détail dans l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La loi des deux grands</a> ". <br><br>  <b>Exemples 7, 8:</b> <br><br>  Ces deux éléments traitent également de la priorité des opérateurs d'affectation, mais cette fois-ci des implémentations spécifiques. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V794</a> L'opérateur d'affectation doit être protégé contre le cas de 'this == &amp; other'.  mattack_common.h 49 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringRef</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringRefTestAccess</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* m_start; size_type m_size; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* m_data = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = ( StringRef <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;other ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> -&gt; StringRef&amp; { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] m_data; m_data = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; m_start = other.m_start; m_size = other.m_size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  Cette implémentation n'a aucune protection contre une auto-affectation potentielle, ce qui est une pratique dangereuse.  Autrement dit, le fait de passer une <i>* cette</i> référence à cet opérateur peut provoquer une fuite de mémoire. <br><br>  Voici un exemple similaire d'un opérateur d'affectation incorrectement remplacé avec un effet secondaire particulier: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V794</a> L'opérateur d'affectation doit être protégé contre le cas de 'this == &amp; rhs'.  player_activity.cpp 38 <br><br><pre> <code class="cpp hljs">player_activity &amp;player_activity::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> player_activity &amp;rhs ) { type = rhs.type; .... targets.clear(); targets.reserve( rhs.targets.size() ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform( rhs.targets.begin(), rhs.targets.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter( targets ), []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> item_location &amp; e ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.clone(); } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  Ce code n'a aucune vérification contre l'auto-affectation non plus, et en plus, il a un vecteur à remplir.  Avec cette implémentation de l'opérateur d'affectation, l'attribution d'un objet à lui-même se traduira par un doublement du vecteur dans le champ <i>cibles</i> , avec certains éléments corrompus.  Cependant, la <i>transformation</i> est précédée de <i>clear</i> , qui effacera le vecteur de l'objet, entraînant ainsi une perte de données. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/618/b4e/dd8/618b4edd868317d8e9e6a0e5d82cb5d0.png" alt="Image 3"></div><br><h2>  Digression iii </h2><br>  En 2008, les roguelikes ont même obtenu une définition formelle connue sous le titre épique "Interprétation de Berlin".  Selon lui, tous ces jeux partagent les éléments suivants: <br><br><ul><li>  Monde généré aléatoirement, ce qui augmente la rejouabilité; </li><li>  Permadeath: si votre personnage meurt, il meurt pour de bon et tous ses objets sont perdus; </li><li>  Gameplay au tour par tour: tout changement ne se produit qu'avec les actions du joueur;  l'écoulement du temps est suspendu jusqu'à ce que le joueur effectue une action; </li><li>  Survie: les ressources sont rares. </li></ul><br>  Enfin, la caractéristique la plus importante des roguelikes se concentre principalement sur l'exploration du monde, la recherche de nouvelles utilisations pour les objets et l'exploration de donjons. <br><br>  C'est une situation courante dans <i>Cataclysm DDA</i> pour que votre personnage se retrouve gelé jusqu'à l'os, affamé, assoiffé et, pour couronner le tout, avoir ses deux jambes remplacées par six tentacules. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fe/f8e/b69/8fef8eb69a48050011726fe47ec1da35.png" alt="Image 15"></div><br><h2>  Des détails qui comptent </h2><br>  <b>Exemple 9:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V1028 Débordement</a> possible.  Envisagez de transposer des opérandes de l'opérateur 'start + large' en type 'size_t', pas le résultat.  worldfactory.cpp 638 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> worldfactory::draw_mod_list( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;start, .... ) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> larger = ....; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iNum = ....; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( .... ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( iNum &gt;= <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;( start ) &amp;&amp; iNum &lt; <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;( start + larger ) ) { .... } .... } .... }</code> </pre> <br>  Il semble que le programmeur ait voulu prendre des précautions contre un débordement.  Cependant, la promotion du type de la somme ne fera aucune différence car le débordement se produira avant cela, à l'étape d'ajout des valeurs, et la promotion se fera sur une valeur vide de sens.  Pour éviter cela, un seul des arguments doit être <i>converti</i> en un type plus large: <i>(static_cast &lt;size_t&gt; (start) + large)</i> . <br><br>  <b>Exemple 10:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V530</a> La valeur de retour de la fonction 'taille' doit être utilisée.  worldfactory.cpp 1340 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> worldfactory::world_need_lua_build( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> world_name ) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> LUA .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Prevent unused var error when LUA and RELEASE enabled. world_name.size(); return false; }</span></span></span></span></code> </pre> <br>  Il y a une astuce pour des cas comme celui-ci.  Si vous vous retrouvez avec une variable inutilisée et que vous souhaitez supprimer l'avertissement du compilateur, écrivez simplement <i>(void) world_name</i> au lieu d'appeler des méthodes sur cette variable. <br><br>  <b>Exemple 11:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V812</a> Performances <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réduites</a> .  Utilisation inefficace de la fonction «comptage».  Il peut éventuellement être remplacé par l'appel à la fonction 'find'.  player.cpp 9600 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> player::read( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> inventory_position, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> continuous ) { .... player_activity activity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !continuous || !<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::all_of( learners.begin(), learners.end(), [&amp;]( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;npc *, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; elem ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::count( activity.values.begin(), activity.values.end(), elem.first-&gt;getID() ) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } ) { .... } .... }</code> </pre> <br>  Le fait que le <i>nombre</i> soit comparé à zéro suggère que le programmeur voulait savoir si l' <i>activité</i> contenait au moins un élément requis.  Mais <i>count</i> doit parcourir tout le conteneur car il compte toutes les occurrences de l'élément.  Le travail pourrait être effectué plus rapidement en utilisant <i>find</i> , qui s'arrête une fois que la première occurrence a été trouvée. <br><br>  <b>Exemple 12:</b> <br><br>  Ce bug est facile à trouver si vous connaissez un détail délicat sur le type de caractère. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V739</a> EOF ne doit pas être comparé à une valeur de type 'char'.  Le «ch» doit être de type «int».  json.cpp 762 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> JsonIn::skip_separator() { <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == <span class="hljs-string"><span class="hljs-string">','</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ate_separator ) { .... } .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == EOF) { .... }</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76e/830/467/76e830467157aab1aad9e710c195b03d.png" alt="Image 13"></div><br>  C'est l'une des erreurs que vous ne repérerez pas facilement, sauf si vous savez que <i>EOF</i> est défini comme -1.  Par conséquent, lors de la comparaison avec une variable de type <i>signé char</i> , la condition est évaluée à <i>false</i> dans presque tous les cas.  La seule exception concerne le caractère dont le code est 0xFF (255).  Lorsqu'il est utilisé dans une comparaison, il passe à -1, ce qui rend la condition vraie. <br><br>  <b>Exemple 13:</b> <br><br>  Ce petit bug peut devenir critique un jour.  Il y a de bonnes raisons, après tout, qu'il se trouve sur la liste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CWE en</a> tant que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CWE-834</a> .  Notez que le projet a déclenché cet avertissement cinq fois. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La</a> boucle infinie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V663</a> est possible.  La condition «cin.eof ()» est insuffisante pour rompre la boucle.  Pensez à ajouter l'appel de fonction 'cin.fail ()' à l'expression conditionnelle.  action.cpp 46 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_keymap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;keymap_txt, .... )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt.eof() ) { .... } }</code> </pre> <br>  Comme le dit l'avertissement, il ne suffit pas de vérifier EOF lors de la lecture du fichier - vous devez également vérifier un échec d'entrée en appelant <i>cin.fail ()</i> .  Corrigeons le code pour le rendre plus sûr: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt.eof() ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(keymap_txt.fail()) { keymap_txt.clear(); keymap_txt.ignore(numeric_limits&lt;streamsize&gt;::max(),<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  Le but de <i>keymap_txt.clear ()</i> est d'effacer l'état d'erreur (indicateur) sur le flux après qu'une erreur de lecture se soit <i>produite</i> afin que vous puissiez lire le reste du texte.  L'appel de <i>keymap_txt.ignore</i> avec les paramètres <i>numeric_limits &lt;streamsize&gt; :: max ()</i> et le caractère de nouvelle ligne vous permet d'ignorer la partie restante de la chaîne. <br><br>  Il existe un moyen beaucoup plus simple d'arrêter la lecture: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt ) { .... }</code> </pre> <br>  Lorsqu'il est placé dans un contexte logique, le flux se convertira en une valeur équivalente à <i>true</i> jusqu'à ce que <i>EOF</i> soit atteint. <br><br><h2>  Digression iv </h2><br>  Les jeux liés aux roguelikes les plus populaires de notre temps combinent les éléments des roguelikes originaux et d'autres genres tels que les jeux de plateforme, les stratégies, etc.  Ces jeux sont devenus connus sous le nom de "roguelike-like" ou "roguelite".  Parmi ceux-ci figurent des titres célèbres tels que <i>Don't Starve</i> , <i>The Binding of Isaac</i> , <i>FTL: Faster Than Light</i> , <i>Darkest Dungeon</i> et même <i>Diablo</i> . <br><br>  Cependant, la distinction entre roguelike et roguelite peut parfois être si minuscule que vous ne pouvez pas savoir avec certitude dans quelle catégorie le jeu appartient.  Certains soutiennent que <i>Dwarf Fortress</i> n'est pas un roguelike au sens strict, tandis que d'autres pensent que <i>Diablo</i> est un jeu roguelike classique. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/330/a83/895/330a838954a71a90e8bd65764a9169a8.png" alt="Image 1"></div><br><h2>  Conclusion </h2><br>  Même si le projet s'est avéré généralement de haute qualité, avec seulement quelques défauts graves, cela ne signifie pas qu'il peut se passer d'une analyse statique.  La puissance de l'analyse statique est utilisée régulièrement plutôt que des contrôles ponctuels comme ceux que nous faisons pour la vulgarisation.  Lorsqu'ils sont utilisés régulièrement, les analyseurs statiques vous aident à détecter les bogues dès les premiers stades de développement et, par conséquent, les rendent moins coûteux à corriger.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemples de calculs</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18d/90c/4b5/18d90c4b57268f6f55e2721a68fc017c.png" alt="Image 2"></div><br>  Le jeu est toujours en cours de développement intensif, avec une communauté active de moddeurs qui y travaillent.  Soit dit en passant, il a été porté sur plusieurs plates-formes, y compris iOS et Android.  Donc, si vous êtes intéressé, essayez-le! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449488/">https://habr.com/ru/post/fr449488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449476/index.html">Un nouveau type de stockage SSD réduira la consommation d'énergie dans le centre de données - comment cela fonctionne</a></li>
<li><a href="../fr449478/index.html">Ajouter UICollectionViews à un UITableViewCell personnalisé qui se fait via Xib</a></li>
<li><a href="../fr449480/index.html">Choisissez le suivi de bogue approprié</a></li>
<li><a href="../fr449484/index.html">Nous créons un capteur de contrôle de la qualité de l'air sur InfluxDB, Grafana, Docker et Raspberry Pi</a></li>
<li><a href="../fr449486/index.html">Exode massif des jeux par navigateur</a></li>
<li><a href="../fr449490/index.html">Slurm: Intense par Kubernetes. Programme et bonus</a></li>
<li><a href="../fr449494/index.html">Interfaces IA et où elles vivent</a></li>
<li><a href="../fr449496/index.html">Hackathon DevDays'19 (partie 2): analyseur de messages sonores pour la vérification des télégrammes et de la grammaire dans IntelliJ IDEA</a></li>
<li><a href="../fr449498/index.html">Analystes: l'estimation de Microsoft dépassera bientôt le billion de dollars</a></li>
<li><a href="../fr449500/index.html">Comment ne pas paniquer si beaucoup de programmeurs venaient visiter?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>