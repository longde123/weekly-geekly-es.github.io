<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐤 👩‍🎓 ⚓️ Alles, was Sie über CSS Margin wissen müssen 🛫 🚖 👨‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eines der ersten Dinge, die viele von uns beim Erlernen von CSS gelernt haben, waren die Merkmale der verschiedenen Elemente eines Blocks in CSS, die ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Alles, was Sie über CSS Margin wissen müssen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465839/"> Eines der ersten Dinge, die viele von uns beim Erlernen von CSS gelernt haben, waren die Merkmale der verschiedenen Elemente eines Blocks in CSS, die als „CSS-Blockmodell“ bezeichnet werden.  Eines der Elemente im Blockmodell ist der Rand (äußerer Rand), ein transparenter Bereich um den Block, der andere Elemente vom Inhalt dieses Blocks abstößt.  Die Eigenschaften für <code>margin-top</code> , <code>margin-right</code> , <code>margin-bottom</code> und <code>margin-left</code> wurden bereits in CSS1 beschrieben, zusammen mit der abgekürzten Randeigenschaft für die gleichzeitige Einstellung in allen vier Eigenschaften. <br><br>  Der Rand scheint jedoch ziemlich einfach zu sein. In diesem Artikel werden wir jedoch einige Punkte betrachten, auf die die Leute bei der Verwendung stoßen.  Insbesondere, wie Ränder miteinander interagieren und wie das Zusammenfallen der äußeren Ränder tatsächlich funktioniert. <br><a name="habracut"></a><br><hr><br><h2>  CSS-Blockmodell </h2><br>  Wie bei allen Artikeln über die Komponenten des CSS-CSS-Blockmodells müssen wir bestimmen, was wir damit meinen und wie das Modell in verschiedene Versionen von CSS klassifiziert wurde.  Das Blockmodell bezieht sich darauf, wie die verschiedenen Komponenten des Blocks - Inhalt (Pad), Auffüllen (Auffüllen), Rand (Rahmen) und Rand (Auffüllen) - lokalisiert sind und miteinander interagieren.  In CSS1 wurde das Blockmodell anhand des in der folgenden Abbildung gezeigten ASCII-Diagramms dargestellt. <br><img src="https://habrastorage.org/webt/kz/y0/gy/kzy0gyiegyv8r-cjmfcxnksats8.jpeg"><br>  Alle vier Eigenschaften für jede Seite des Blocks und die abgekürzte Randeigenschaft wurden in CSS1 definiert. <br><br>  Die CSS2.1-Spezifikation enthält eine Illustration zur Veranschaulichung des Blockmodells und definiert auch Begriffe, die wir weiterhin zur Beschreibung verschiedener Blöcke verwenden.  Die Spezifikation beschreibt Inhaltsfeld, Auffüllfeld, Rahmenfeld und Randfeld, die jeweils durch die Grenzen von Inhalt, Auffüllen, Rand bzw. Rand definiert sind. <br><br><img src="https://habrastorage.org/webt/ay/gd/-d/aygd-dqsahkl-ctmivtbuajno_e.jpeg"><br><br>  Derzeit gibt es eine Spezifikation für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Block Model 3-</a> Version als Arbeitsentwurf.  Wenn Sie das Blockmodell und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ränder definieren</a> , kehren wir zu CSS2 zurück, sodass wir im gesamten Artikel die Definition von CSS2 verwenden. <br><br><h2>  Rand reduzieren </h2><br>  Die CSS1-Spezifikation definierte nicht nur die Ränder, sondern auch deren Zusammenbruch.  Dieses Verhalten hat zu vielen Enttäuschungen geführt.  Das Reduzieren des Randes ist sinnvoll, wenn man bedenkt, dass CSS damals als Auszeichnungssprache für Textdokumente verwendet wurde.  Reduzierter Rand bedeutet, dass, wenn auf eine Überschrift mit einem niedrigeren Rand ein Absatz mit einem oberen Rand folgt, diese beiden Einrückungen nicht addiert werden, wodurch eine große Lücke zwischen den Elementen entsteht. <br><br>  Wenn zwei Ränder zusammenfallen, wird der Abstand zwischen den Elementen gleich dem größeren der beiden Einzüge.  Die kleinere Einkerbung endet tatsächlich innerhalb der größeren <br><br>  Randkollaps in folgenden Situationen: <br><br><ul><li>  Benachbarte Geschwister (Alleinerziehende) </li><li>  Leere Blöcke </li><li>  Elternteil und erstes / letztes Kind </li></ul><br><h3>  Benachbarte Pflegeelemente </h3><br>  Ich werde die Beschreibung mit einer Demonstration beginnen, wie die Ränder zwischen benachbarten Geschwistern zusammenbrechen.  Wenn im normalen Stream zwei Elemente nacheinander angezeigt werden, wird der untere Rand des ersten Elements mit dem oberen Rand des nachfolgenden Elements reduziert, sofern nachstehend nichts anderes angegeben ist. <br><br>  Im folgenden CodePen-Beispiel gibt es drei <code>div</code> Elemente.  Für das erste Element betragen der obere und untere Rand 50px, für das zweite - 20px, für das dritte - 3em.  Der Rand zwischen den ersten beiden Elementen beträgt 50px, da der untere Rand des unteren Elements vom oberen Rand des oberen Elements absorbiert wird.  Der Abstand zwischen den beiden zweiten Elementen beträgt 3em, da 3em am unteren Rand des zweiten Elements größer als 20 Pixel ist. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/OevMPo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Leere Blöcke </h3><br>  Wenn der Block leer ist, können sein oberer und unterer Rand miteinander kollabieren.  Im folgenden CodePen-Beispiel hat das zweite Element mit der <code>empty</code> Klasse (nicht sichtbar, da es leer ist) einen oberen und unteren Rand von 50 Pixel. Der Abstand zwischen dem ersten und dritten Element beträgt jedoch nicht 100 Pixel, sondern 50. Dies ist ein Ergebnis des Zusammenbruchs zweier Ränder. <br><br>  Wenn Sie dem Block etwas hinzufügen (sogar Polsterung), werden der obere und der untere Rand verwendet und nicht reduziert. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/JQLGMr" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Elternteil und erstes / letztes Kind </h3><br>  Dieses Szenario des Randkollapses verwirrt Menschen häufiger als andere, da es nicht intuitiv ist.  Im nächsten CodePen haben wir ein <code>div</code> mit dem Klassen- <code>wrapper</code> (Wrapper), und ich habe dieses <code>div</code> <code>outline</code> Rot gesetzt, damit seine Ränder sichtbar sind.  Alle drei Kinder haben einen Rand von 50 Pixel.  Das erste und das letzte Element befinden sich jedoch neben den Rändern des Wrapper-Elements.  Es gibt keine Einrückung von 50 Pixeln zwischen dem Element und dem Wrapper. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/BgrKGp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dies liegt daran, dass der Rand des Kindes mit jedem Rand des Elternteils so zusammenfällt, dass er außerhalb des Elternteils endet.  Sie können dies sehen, wenn Sie das Kind über das Entwickler-Browserfenster testen.  Der gelb hervorgehobene Bereich ist der Rand. <br><br><img src="https://habrastorage.org/webt/_5/tz/-t/_5tz-tnvcus6rog4a6uhqatlw7m.jpeg"><br><br><h2>  Nur Rand reduzieren </h2><br>  Das letzte Beispiel zeigt auch etwas über das Reduzieren des Randes.  In CSS2 wurden nur die vertikalen (oberen und unteren) Ränder zum Kollabieren entworfen.  Daher kollabieren im obigen Beispiel die Ränder links und rechts nicht und enden im Wrapper. <br><br>  Hinweis: Beachten Sie, dass der Rand nur in Richtung des Blocks kollabiert, z. B. zwischen Absätzen. <br><br><h2>  Kollapsverhütung </h2><br>  Der Rand wird nicht reduziert, wenn das Element auf absolute Positionierung oder die Eigenschaft <code>float</code> .  Wie kann dies jedoch verhindert werden, wenn Sie sich in einer Situation befinden, in der die Marge zusammenbricht? <br><br>  Ein reduzierter Rand tritt nicht in einer Situation auf, in der sich etwas dazwischen befindet. <br><br>  Beispielsweise werden der obere und der untere Rand eines leeren Blocks nicht reduziert, wenn der Block auf einen Rand oder eine Auffüllung eingestellt ist.  Im folgenden Beispiel habe ich einen 1px-Auffüllblock hinzugefügt.  Jetzt gibt es oben und unten im Block einen Rand von 50px. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/gNeMpg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dies ist die Logik: Wenn ein leerer Block keinen Rand oder Abstand hat, wird er praktisch unsichtbar.  Beispielsweise könnte es sich um einen leeren Absatz handeln, der im Markup Ihres CMS platziert wird.  Wenn Ihr CMS redundante Absatzelemente hinzufügt, möchten Sie wahrscheinlich nicht, dass sie große Einrückungen zwischen anderen Absätzen verursachen, da deren Ränder berücksichtigt werden.  Fügen Sie dem Block etwas hinzu und erhalten Sie diese Einrückungen. <br><br>  Ein ähnliches Verhalten ist am Rand des ersten oder letzten Kindes zu beobachten, dessen Rand über den Elternteil hinausgeht.  Wenn wir dem Elternteil einen Rahmen hinzufügen, bleibt der Rand des Kindes im Inneren. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/vqRKKX" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Und wieder ist dieses Verhalten logisch.  Wenn Sie Wrapper-Elemente für semantische Zwecke haben, die nicht visuell angezeigt werden, möchten Sie wahrscheinlich nicht, dass sie bei der Anzeige große Einrückungen erzeugen.  Dies war nützlicher, wenn das Web hauptsächlich aus Text bestand.  Und dieses Verhalten ist weniger nützlich, wenn wir Layoutelemente verwenden. <br><br><h3>  Erstellen eines "Blockformatierungskontexts" </h3><br>  Der neue „Block Formatierungskontext“ (BFC) verhindert, dass Ränder aus dem übergeordneten Element herausfallen.  Wenn wir uns das Beispiel mit dem ersten und dem letzten untergeordneten Element noch einmal ansehen, dessen Ränder außerhalb der Grenzen des Wrapper-Elements liegen, und den Wrapper so einstellen, dass Folgendes <code>display: flow-root</code> , wodurch BFC erstellt wird, bleibt der Rand der untergeordneten Elemente innerhalb. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/VJXjEp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Weitere Informationen zur <code>display: flow-root</code> finden Sie in meinem Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zum CSS-Layout und zum Kontext der Blockformatierung</a> ".  Das Ändern des Werts der <code>overflow</code> in " <code>auto</code> " hat den gleichen Effekt, da auch ein neuer BFC erstellt wird, obwohl dies zu Bildlaufleisten führen kann, die in bestimmten Fällen nicht benötigt werden <br><br><h3>  Flex- und Grid-Container </h3><br>  Flex- und Grid-Container legen den Flex- und Grid-Formatierungskontext für untergeordnete Elemente fest, sodass sie ein unterschiedliches Blocklayoutverhalten aufweisen.  Einer dieser Unterschiede ist, dass die Ränder nicht zusammenbrechen: <br><blockquote>  Ein Flex-Container legt einen neuen Flex-Formatierungskontext für Inhalte fest.  Dies entspricht dem Festlegen eines Blockformatierungskontexts, außer dass das Flex-Markup anstelle des Block-Markups verwendet wird.  Floats funktionieren beispielsweise nicht in einem Flex-Container, und der Rand eines Flex-Containers fällt nicht mit dem Rand der untergeordneten Elemente zusammen. <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flexbox Level 1</a> <br></blockquote>  Wenn wir das obige Beispiel nehmen und es mit einem Flex-Container umwickeln, der die Richtung der Hauptachse der Spalte Flex-Richtung: angibt, wird klar, dass der Rand der Kinder jetzt nicht über den Umbruch hinausgeht.  Außerdem werden die Ränder zwischen benachbarten Flex-Elementen nicht reduziert, sodass zwischen den Flex-Elementen ein Abstand von 100 Pixel entsteht. Dies ist die Summe der oberen und unteren Ränder, die jeweils 50 Pixel groß sind. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/mZxreL" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Margin-Strategien für Ihre Website </h2><br>  Aufgrund des Zusammenbruchs besteht eine gute Lösung darin, eine konsistente Methode zum Arbeiten mit Margen auf Ihrer Website anzubieten.  Am einfachsten ist es, wenn Sie festlegen, dass der Rand nur oben oder unten auf den Elementen festgelegt wird.  In diesem Fall sollten Sie nicht zu oft auf Kollapsprobleme stoßen, da die Seite, auf der der Rand festgelegt ist, immer an die Seite des anderen Elements ohne Rand angrenzt. <br><br>  <b>Hinweis</b> : Harry Roberts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hat eine ausgezeichnete Veröffentlichung,</a> in der die Gründe aufgeführt sind, warum es eine gute Idee ist, den Rand nur in eine Richtung zu setzen, und nicht nur, um Kollapsprobleme zu lösen. <br><br>  Dieser Ansatz löst nicht das Problem, dass der Rand aus untergeordneten Elementen über die Grenzen des Elternteils hinaus fällt, auf die Sie möglicherweise stoßen.  Dieses spezielle Problem tritt normalerweise seltener auf. Wenn Sie verstehen, warum dies geschieht, können Sie eine Lösung finden.  Die ideale Lösung besteht darin, die Komponenten festzulegen, für deren <code>display: flow-root</code> Folgendes erforderlich ist <code>display: flow-root</code> . Mit einem Fallback (Fallback) für ältere Browser können Sie einen <code>overflow</code> , um einen BFC (Blockformatierungskontext) zu erstellen.  Verwandeln Sie die Eltern in einen Flex-Container.  oder stellen Sie die Polsterung sogar auf 1px ein.  Beachten Sie, dass Sie mithilfe der Browserunterstützungsanforderung für Eigenschaften feststellen können, ob die Eigenschaft <code>display: flow-root</code> unterstützt wird, sodass nur ältere Browser eine weniger optimale Lösung erhalten. <br><br>  Ich glaube, dass in den meisten Fällen das Verständnis, warum Margen zusammenbrechen (oder nicht), der Schlüssel ist.  Auf diese Weise können Sie bestimmen, wie Sie jeweils damit umgehen sollen.  Unabhängig von der gewählten Methode teilen Sie diese Informationen Ihrem Team mit.  Sehr oft ist der Zusammenbruch des Randes ein wenig mysteriös, so dass die Art und Weise, wie man damit umgeht, nicht immer offensichtlich ist.  Ein Kommentar in Ihrem Code kann angemessen sein. Sie können sogar einen Link zu diesem Artikel einfügen und dabei helfen, Wissen über das Reduzieren von Rändern auszutauschen. <br><br>  Ich habe beschlossen, diesen Artikel mit einigen zusätzlichen Daten zum Rand zu ergänzen. <br><br><h2>  Zinsmarge </h2><br>  Wenn Sie Prozentsätze in CSS verwenden, sollten es Prozentsätze von etwas sein.  Als Prozentsatz festgelegte Ränder (sowie Auffüllungen) werden immer relativ zur Breite des übergeordneten Elements berechnet.  Dies bedeutet, dass Sie bei Verwendung von Prozentsätzen von allen Seiten des Elements immer den gleichen Spielraum haben. <br><br>  Im folgenden CodePen-Beispiel habe ich einen Wrapper mit einer Breite von 200 Pixel, in dem sich ein Block mit einem Rand von 10% befindet.  Von allen Seiten beträgt der Rand 20px, was 10% von 200px entspricht. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/orqzrP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Margin in einer flussabhängigen Welt </h2><br>  In diesem Artikel haben wir über vertikale Ränder gesprochen. Modernes CSS denkt jedoch in der Regel mehr über die Position von Elementen relativ zum Stream als relativ zu den physischen Seiten nach.  Wenn wir also über vertikale Ränder sprechen, sprechen wir tatsächlich über Ränder in der Blockdimension.  Diese Ränder können im horizontalen Schreibmodus oben oder unten oder im vertikalen Modus rechts oder links sein. <br><br>  Nachdem Sie mit logischen Richtungen in Bezug auf den Fluss gearbeitet haben, wird es einfacher, über den Anfang und das Ende des Blocks zu sprechen als über den oberen und unteren Rand.  Um dies zu vereinfachen, wurde in CSS eine Spezifikation der booleschen Eigenschaften und Werte eingeführt.  Es ersetzt physikalische Eigenschaften durch flussbezogene Eigenschaften. <br><br>  Wenn wir über den Rand sprechen, erhalten wir die folgenden Alternativen (wenn wir mit Englisch oder einem anderen horizontal aufgezeichneten Modus mit der Richtung des Textes von links nach rechts arbeiten). <br><br><ul><li>  margin-top = margin-block-start </li><li>  Rand-rechts = Rand-Inline-Ende </li><li>  Rand-unten = Rand-Block-Ende </li><li>  margin-left = margin-inline-start </li></ul><br>  Wir haben auch zwei neue abgekürzte Eigenschaften: <br><br><ul><li>  Randblock </li><li>  Margin-Inline </li></ul><br>  Im folgenden CodePen-Beispiel habe ich Stream-bezogene Schlüsselwörter verwendet und dann den Blockschreibmodus geändert.  Sie können sehen, wie Ränder dem Textstrom folgen, anstatt an die physischen Seiten gebunden zu sein. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/BgrQRj" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Weitere Informationen zu logischen Eigenschaften und Werten finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MDN</a> oder in meinem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zu logischen Eigenschaften und Werten</a> im Smashing Magazine. <br><br><h2>  Abschließend </h2><br>  Jetzt wissen Sie das meiste, was Sie über die Marge wissen sollten.  Kurz: <br><br><ul><li>  Der Rand kann zusammenbrechen.  Wenn Sie wissen, wann dies geschieht und wann nicht, können Sie eventuelle Probleme lösen. </li><li>  Das Installieren des Randes in nur einer Richtung löst viele damit verbundene Probleme. </li><li>  Teilen Sie wie in jeder CSS-Situation die Entscheidungen, die Sie treffen, mit Ihrem Team und kommentieren Sie Ihren Code </li><li>  Die Berücksichtigung von Block- und Linienmessungen anstelle der physischen Seiten oben, rechts, unten und links hilft Ihnen dabei, da das Web immer unabhängiger vom Schreibmodus wird </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465839/">https://habr.com/ru/post/de465839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465823/index.html">Tarantool kubernetes Betreiber</a></li>
<li><a href="../de465825/index.html">Asterisk FreePBX-Telefonverzeichnis aus SQL-Tabellen (webbasiertes Verzeichnis, Hochladen in XML-Datei für Grandstream-Telefone)</a></li>
<li><a href="../de465829/index.html">[Tutorial] So erstellen Sie Ihr erstes inkrementelles IDLE-JavaScript-Spiel</a></li>
<li><a href="../de465833/index.html">TOKEN2 Molto-1, das weltweit erste TOTP-Hardware-Token mit mehreren Profilen</a></li>
<li><a href="../de465835/index.html">Abstrakte Fabrik an den Fingern</a></li>
<li><a href="../de465841/index.html">GPS-Tracker BOXY</a></li>
<li><a href="../de465843/index.html">Nickel für Öl</a></li>
<li><a href="../de465845/index.html">Über die strukturelle Modellierung des organisatorischen Wandels</a></li>
<li><a href="../de465849/index.html">Meine Entwicklungserfahrung auf Playcanvas</a></li>
<li><a href="../de465853/index.html">Nützlicher Hilfelink für die Arbeit mit Daten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>