<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíë ‚èØÔ∏è üò≥ Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teil 3 üì® ü¶î üìé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute schauen wir uns zwei weitere Orte an, an denen pbrt viel Zeit damit verbringt, Szenen aus dem Disney-Cartoon "Moana" zu analysieren. Mal sehen, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417913/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/025/729/0d7025729325723a1c454f795c17af39.jpg" alt="Bild"></div><br>  Heute schauen wir uns zwei weitere Orte an, an denen pbrt viel Zeit damit verbringt, Szenen aus dem Disney-Cartoon <em>"Moana" zu</em> analysieren.  Mal sehen, ob es hier m√∂glich ist, die Produktivit√§t zu verbessern.  Dies schlie√üt mit dem, was in pbrt-v3 ratsam ist.  In einem anderen Beitrag werde ich darauf eingehen, wie weit wir gehen k√∂nnen, wenn wir das Verbot von √Ñnderungen aufgeben.  In diesem Fall unterscheidet sich der Quellcode zu stark von dem im Buch <em>Physically Based Rendering</em> beschriebenen System. <br><br><h2>  Parser-Optimierung </h2><br>  Nach den im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel</a> eingef√ºhrten Leistungsverbesserungen stieg der Anteil der Zeit, die im pbrt-Parser verbracht wurde und von Anfang an so bedeutend war, nat√ºrlich noch mehr an.  Derzeit wird der Parser beim Start die meiste Zeit verwendet. <br><br>  Endlich habe ich meine Kr√§fte gesammelt und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen manuell geschriebenen Tokenizer und Parser</a> f√ºr pbrt-Szenen implementiert.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Format der pbrt-Szenendateien ist</a> ziemlich einfach zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">analysieren</a> : Wenn Sie nicht in Anf√ºhrungszeichen gesetzte Zeilen ber√ºcksichtigen, werden Token durch Leerzeichen getrennt und die Grammatik ist sehr einfach (es ist nie erforderlich, mehr als ein Token nach vorne zu schauen), aber Ihr eigener Parser besteht immer noch aus tausend Codezeilen, die Sie ben√∂tigen schreiben und debuggen.  Es hat mir geholfen, dass es in vielen Szenen getestet werden konnte;  Nachdem ich offensichtliche St√∂rungen behoben hatte, arbeitete ich weiter, bis ich genau die gleichen Bilder wie zuvor rendern konnte: Es sollte keine Pixelunterschiede geben, da der Parser ersetzt wurde.  Zu diesem Zeitpunkt war ich mir absolut sicher, dass alles richtig gemacht wurde. <br><a name="habracut"></a><br>  Ich habe versucht, die neue Version so effizient wie m√∂glich zu gestalten, indem ich die Eingabedateien so weit wie m√∂glich <code>mmap()</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>std::string_view</code></a> und die neue Implementierung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>std::string_view</code></a> aus C ++ 17 verwendet habe, um die Erstellung von Kopien von Zeichenfolgen aus dem Inhalt der Datei zu minimieren.  Da <code>strtod()</code> in fr√ºheren Traces viel Zeit in <a href=""><code> parseNumber()</code></a> , habe ich <a href=""><code> parseNumber()</code></a> mit besonderer Sorgfalt geschrieben: <a href=""><code> parseNumber()</code></a> Ganzzahlen und regul√§re Ganzzahlen werden separat verarbeitet, und im Standardfall, wenn pbrt f√ºr die Verwendung von 32-Bit-Floats kompiliert wird , verwendet <code>strtof()</code> anstelle von <code>strtod()</code> <sup>1</sup> . <br><br>  Bei der Erstellung einer Implementierung des neuen Parsers hatte ich ein wenig Angst, dass der alte Parser schneller sein k√∂nnte: Am Ende wurden Flex und Bison seit vielen Jahren entwickelt und optimiert.  Ich konnte nicht im Voraus herausfinden, ob das Schreiben einer neuen Version die ganze Zeit verschwendet w√ºrde, bis ich sie fertiggestellt und zum Laufen gebracht habe. <br><br>  Zu meiner Freude stellte sich heraus, dass unser eigener Parser ein gro√üer Sieg war: Die Verallgemeinerung von Flex und Bison reduzierte die Leistung so sehr, dass die neue Version sie leicht √ºberholte.  Dank des neuen Parsers verringerte sich die Startzeit auf 13 Minuten und 21 Sekunden, dh sie beschleunigte sich um das 1,5-fache!  Ein zus√§tzlicher Bonus war, dass es nun m√∂glich war, alle Flex- und Bison-Unterst√ºtzung aus dem pbrt-Build-System zu entfernen.  Es war schon immer ein Problem, besonders unter Windows, wo die meisten Leute es nicht standardm√§√üig installiert haben. <br><br><h2>  Grafikstatusverwaltung </h2><br>  Nachdem der Parser erheblich beschleunigt worden war, tauchte ein neues nerviges Detail auf: Zu diesem Zeitpunkt wurden ungef√§hr 10% der Einrichtungszeit f√ºr die Funktionen <code>pbrtAttributeBegin()</code> und <code>pbrtAttributeEnd()</code> , und der gr√∂√üte Teil dieser Zeit wurde zugewiesen und dynamischer Speicher freigegeben.  W√§hrend des ersten Laufs, der 35 Minuten dauerte, dauerten diese Funktionen nur etwa 3% der Ausf√ºhrungszeit, sodass sie ignoriert werden konnten.  Bei der Optimierung ist dies jedoch immer so: Wenn Sie gro√üe Probleme beseitigen, werden kleine Probleme wichtiger. <br><br>  Die Beschreibung der pbrt-Szene basiert auf dem hierarchischen Status der Grafik, der die aktuelle Transformation, das aktuelle Material usw. angibt.  Darin k√∂nnen Sie Snapshots des aktuellen Status ( <code>pbrtAttributeBegin()</code> ) <code>pbrtAttributeBegin()</code> , √Ñnderungen daran vornehmen, bevor Sie der Szene eine neue Geometrie hinzuf√ºgen, und dann zum urspr√ºnglichen Status zur√ºckkehren ( <code>pbrtAttributeEnd()</code> ). <br><br>  Der Grafikstatus wird in einer Struktur mit einem unerwarteten Namen gespeichert ... <code>GraphicsState</code> .  Zum Speichern von Kopien von <code>GraphicsState</code> Objekten im Stapel gespeicherter Grafikzust√§nde wird <code>std::vector</code> .  Wenn wir uns die <code>GraphicsState</code> Mitglieder ansehen, k√∂nnen wir die Ursache der Probleme annehmen - drei <code>std::map</code> , von Namen bis zu Instanzen von Texturen und Materialien: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GraphicsState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... std::map&lt;std::string, std::shared_ptr&lt;Texture&lt;Float&gt;&gt;&gt; floatTextures; std::map&lt;std::string, std::shared_ptr&lt;Texture&lt;Spectrum&gt;&gt;&gt; spectrumTextures; std::map&lt;std::string, std::shared_ptr&lt;MaterialInstance&gt;&gt; namedMaterials; };</span></span></code> </pre> <br>  Bei der Untersuchung dieser Szenendateien stellte ich fest, dass die meisten F√§lle des Speicherns und Wiederherstellens des Grafikstatus in den folgenden Zeilen ausgef√ºhrt werden: <br><br><pre> <code class="cpp hljs">AttributeBegin ConcatTransform [<span class="hljs-number"><span class="hljs-number">0.981262</span></span> <span class="hljs-number"><span class="hljs-number">0.133695</span></span> <span class="hljs-number"><span class="hljs-number">-0.138749</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">-0.067901</span></span> <span class="hljs-number"><span class="hljs-number">0.913846</span></span> <span class="hljs-number"><span class="hljs-number">0.400343</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">0.180319</span></span> <span class="hljs-number"><span class="hljs-number">-0.383420</span></span> <span class="hljs-number"><span class="hljs-number">0.905800</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">11.095301</span></span> <span class="hljs-number"><span class="hljs-number">18.852249</span></span> <span class="hljs-number"><span class="hljs-number">9.481399</span></span> <span class="hljs-number"><span class="hljs-number">1.000000</span></span>] ObjectInstance <span class="hljs-string"><span class="hljs-string">"archivebaycedar0001_mod"</span></span> AttributeEnd</code> </pre> <br>  Mit anderen Worten, es aktualisiert die aktuelle Transformation und instanziiert das Objekt.  <code>std::map</code> Inhalt dieser <code>std::map</code> keine √Ñnderungen vorgenommen.  Das Erstellen einer vollst√§ndigen Kopie davon - Zuweisen von rot-schwarzen Baumknoten, Erh√∂hen der Referenzanzahl f√ºr allgemeine Zeiger, Zuweisen von Speicherplatz und Kopieren von Zeichenfolgen - ist fast immer Zeitverschwendung.  All dies wird freigegeben, wenn der vorherige Status der Grafik wiederhergestellt wird. <br><br>  Ich habe jede dieser Karten durch den Zeiger <code>std::shared_ptr</code> um sie zuzuordnen, und den Copy-on-Write-Ansatz implementiert, bei dem das Kopieren innerhalb des Anfangs- / Endblocks eines Attributs nur erfolgt, wenn dessen Inhalt ge√§ndert werden muss.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die √Ñnderung</a> war nicht besonders schwierig, reduzierte jedoch die Startzeit um mehr als eine Minute, was uns 12 Minuten und 20 Sekunden Verarbeitung vor dem Beginn des Renderns erm√∂glichte - wiederum eine Beschleunigung von 1,08. <br><br><h2>  Was ist mit der Renderzeit? </h2><br>  Ein aufmerksamer Leser wird feststellen, dass ich bisher nichts √ºber die Renderzeit gesagt habe.  Zu meiner √úberraschung stellte sich heraus, dass es selbst nach dem Auspacken ziemlich ertr√§glich war: pbrt kann Bilder von Szenen in Filmqualit√§t mit mehreren hundert Samples pro Pixel auf zw√∂lf Prozessorkernen f√ºr einen Zeitraum von zwei bis drei Stunden rendern.  Zum Beispiel wird dieses Bild, eines der langsamsten, in 2 Stunden 51 Minuten 36 Sekunden gerendert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/025/729/0d7025729325723a1c454f795c17af39.jpg"></div><br>  <i>Von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pbrt-v3</a> gerenderte D√ºnen aus Moana mit einer Aufl√∂sung von 2048 x 858 bei 256 Abtastungen pro Pixel.</i>  <i>Die gesamte Renderzeit auf einer Google Compute Engine-Instanz mit 12 Kernen / 24 Threads mit einer Frequenz von 2 GHz und der neuesten Version von pbrt-v3 betrug 2 Stunden 51 Minuten 36 Sekunden.</i> <br><br>  Meiner Meinung nach scheint dies ein √ºberraschend vern√ºnftiger Indikator zu sein.  Ich bin sicher, dass Verbesserungen noch m√∂glich sind, und eine sorgf√§ltige Untersuchung der Orte, an denen die meiste Zeit verbracht wird, wird viele ‚Äûinteressante‚Äú Dinge aufdecken, aber bisher gibt es keine besonderen Gr√ºnde daf√ºr. <br><br>  Bei der Profilerstellung stellte sich heraus, dass ungef√§hr 60% der Renderzeit am Schnittpunkt von Strahlen mit Objekten verbracht wurden (die meisten Operationen wurden unter Umgehung von BVH durchgef√ºhrt), und 25% wurden f√ºr die Suche nach ptex-Texturen aufgewendet.  Diese Verh√§ltnisse √§hneln Indikatoren f√ºr einfachere Szenen, so dass hier auf den ersten Blick nichts offensichtlich problematisch ist.  (Ich bin jedoch sicher, dass Embree diese Strahlen in etwas k√ºrzerer Zeit verfolgen kann.) <br><br>  Leider ist die parallele Skalierbarkeit nicht so gut.  Normalerweise werden 1400% der CPU-Ressourcen f√ºr das Rendern ausgegeben, verglichen mit dem Ideal von 2400% (f√ºr 24 virtuelle CPUs in der Google Compute Engine).  Es scheint, dass das Problem mit Konflikten w√§hrend Sperren in ptex zusammenh√§ngt, aber ich habe es noch nicht genauer untersucht.  Es ist sehr wahrscheinlich, dass pbrt-v3 die Strahlendifferenz f√ºr indirekte Strahlen im Raytracer nicht berechnet.  Im Gegenzug erhalten solche Strahlen immer Zugriff auf die detaillierteste MIP-Ebene von Texturen, was f√ºr das Zwischenspeichern von Texturen nicht sehr n√ºtzlich ist. <br><br><h2>  Schlussfolgerung (f√ºr pbrt-v3) </h2><br>  Nachdem ich die Verwaltung des Grafikstatus korrigiert hatte, stie√ü ich auf eine Grenze, nach der weitere Fortschritte, ohne wesentliche √Ñnderungen am System vorzunehmen, nicht mehr offensichtlich waren.  Der Rest nahm viel Zeit in Anspruch und hatte wenig mit Optimierung zu tun.  Daher werde ich zumindest in Bezug auf pbrt-v3 darauf eingehen. <br><br>  Im Allgemeinen war der Fortschritt ernst: Die Startzeit vor dem Rendern verringerte sich von 35 Minuten auf 12 Minuten und 20 Sekunden, dh die Gesamtbeschleunigung betrug das 2,83-fache.  Dank der cleveren Arbeit mit dem Konvertierungscache ist die Speichernutzung von 80 GB auf 69 GB gesunken.  Alle diese √Ñnderungen sind jetzt verf√ºgbar, wenn Sie mit der neuesten Version von pbrt-v3 synchronisieren (oder wenn Sie dies in den letzten Monaten getan haben). Und wir werden verstehen, wie viel M√ºll der <code>Primitive</code> Speicher f√ºr diese Szene ist.  Wir haben herausgefunden, wie weitere 18 GB Speicherplatz gespart werden k√∂nnen, haben ihn jedoch nicht in pbrt-v3 implementiert. <br><br>  Nach all unseren Optimierungen werden diese 12 Minuten und 20 Sekunden f√ºr Folgendes verwendet: <br><br><table><thead><tr><th>  Funktion / Bedienung </th><th>  Prozentsatz der Laufzeit </th></tr></thead><tbody><tr><td>  BVH bauen </td><td>  34% </td></tr><tr><td>  Parsing (au√üer <code>strtof()</code> ) </td><td>  21% </td></tr><tr><td> <code>strtof()</code> </td> <td>  20% </td></tr><tr><td>  Konvertierungscache </td><td>  7% </td></tr><tr><td>  PLY-Dateien lesen </td><td>  6% </td></tr><tr><td>  Dynamische Speicherzuordnung </td><td>  5% </td></tr><tr><td>  Konvertierungsinversion </td><td>  2% </td></tr><tr><td>  Grafikstatusverwaltung </td><td>  2% </td></tr><tr><td>  Andere </td><td>  3% </td></tr></tbody></table><br>  In Zukunft wird die beste Option zur Verbesserung der Leistung ein noch gr√∂√üeres Multithreading der Startphase sein: Fast alles w√§hrend des Parsens der Szene ist Single-Threaded;  Unser nat√ºrlichstes erstes Ziel ist der Bau eines BVH.  Es wird auch interessant sein, Dinge wie das Lesen von PLY-Dateien und das Generieren von BVH f√ºr einzelne Instanzen von Objekten zu analysieren und diese asynchron im Hintergrund auszuf√ºhren, w√§hrend das Parsen im Hauptthread durchgef√ºhrt wird. <br><br>  Irgendwann werde ich sehen, ob es schnellere Implementierungen von <code>strtof()</code> ;  pbrt verwendet nur das, was das System bietet.  Sie sollten jedoch bei der Auswahl von Ersatzteilen, die nicht sehr gr√ºndlich getestet wurden, vorsichtig sein: Das Parsen von Float-Werten ist einer der Aspekte, bei denen sich der Programmierer absolut sicher sein muss. <br><br>  Es sieht auch attraktiv aus, die Belastung des Parsers weiter zu reduzieren: Wir haben noch 17 GB Texteingabedateien zum Parsen.  Wir k√∂nnen die Unterst√ºtzung f√ºr die bin√§re Codierung f√ºr pbrt-Eingabedateien hinzuf√ºgen (m√∂glicherweise √§hnlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem RenderMan-Ansatz</a> ), aber ich habe gemischte Gef√ºhle in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bezug auf</a> diese Idee.  Die M√∂glichkeit, Szenenbeschreibungsdateien in einem Texteditor zu √∂ffnen und zu √§ndern, ist sehr n√ºtzlich, und ich mache mir Sorgen, dass die bin√§re Codierung manchmal die Sch√ºler verwirrt, die pbrt im Lernprozess verwenden.  Dies ist einer der F√§lle, in denen sich die richtige L√∂sung f√ºr pbrt von L√∂sungen f√ºr einen kommerziellen Render eines Produktionsniveaus unterscheiden kann. <br><br>  Es war sehr interessant, all diese Optimierungen im Auge zu behalten und verschiedene L√∂sungen besser zu verstehen.  Es stellte sich heraus, dass pbrt unerwartete Annahmen hat, die die Szene dieser Komplexit√§tsstufe st√∂ren.  All dies ist ein gro√üartiges Beispiel daf√ºr, wie wichtig es f√ºr eine breite Community von Rendering-Forschern ist, Zugang zu realen Produktionsszenen mit einem hohen Grad an Komplexit√§t zu haben.  Ich bedanke mich nochmals bei Disney f√ºr die Zeit, die f√ºr die Bearbeitung und Ver√∂ffentlichung dieser Szene aufgewendet wurde. <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n√§chsten Artikel</a> werden wir uns mit Aspekten befassen, die die Leistung weiter verbessern k√∂nnen, wenn wir pbrt erlauben, radikalere √Ñnderungen vorzunehmen. <br><br><h2>  Hinweis </h2><br><ol><li>  Auf dem Linux-System, auf dem ich getestet habe, ist <code>strtof()</code> nicht schneller als <code>strtod()</code> .  Es ist bemerkenswert, dass <code>strtod()</code> OS X etwa zweimal schneller ist, was v√∂llig unlogisch ist.  Aus praktischen Gr√ºnden habe ich weiterhin <code>strtof()</code> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417913/">https://habr.com/ru/post/de417913/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417901/index.html">Wie wir anfingen, gro√üartige lange Treffen zu machen, und warum dies kein universelles √úbel mehr ist</a></li>
<li><a href="../de417903/index.html">Code Review Fall 1</a></li>
<li><a href="../de417905/index.html">11 M√∂glichkeiten (nicht), Opfer von Hacking in Kubernetes zu werden</a></li>
<li><a href="../de417909/index.html">Warum brauchst du Splunk? Anwendungsanalyse</a></li>
<li><a href="../de417911/index.html">Kontinuierliches Design in der Entwicklung: Methodik und Prinzip</a></li>
<li><a href="../de417915/index.html">Wie man einen Mitbewohner spielt</a></li>
<li><a href="../de417917/index.html">ASC'18: Ausdauer und regelm√§√üiges Training als Weg, um das Ziel zu erreichen</a></li>
<li><a href="../de417919/index.html">Modellierung von Vibrationen und Ger√§uschen in einem Auto-Getriebe</a></li>
<li><a href="../de417927/index.html">Cyber ‚Äã‚ÄãBattle an PHDays oder wie man st√§dtische Infrastruktur in 30 Stunden hackt</a></li>
<li><a href="../de417929/index.html">Auszug aus dem Buch ‚ÄûEin Tag im Leben des Gehirns. Neurobiologie des Bewusstseins von morgens bis abends ‚Äú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>