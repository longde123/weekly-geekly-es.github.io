<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚ÄçüöÄ ‚òùüèº ‚≠êÔ∏è "Algebraische Effekte" in der menschlichen Sprache üóùÔ∏è ‚ö´Ô∏è ‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kommentar des √úbersetzers: Dies ist eine √úbersetzung eines gro√üartigen Artikels von Dan Abramov, einem React-Mitarbeiter. Seine Beispiele sind f√ºr JS ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Algebraische Effekte" in der menschlichen Sprache</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470718/">  Kommentar des √úbersetzers: Dies ist eine √úbersetzung eines gro√üartigen Artikels von Dan Abramov, einem React-Mitarbeiter.  Seine Beispiele sind f√ºr JS geschrieben, aber sie werden Entwicklern in jeder Sprache gleicherma√üen klar sein.  Die Idee ist allen gemeinsam. <br><br><h3>  Haben Sie von algebraischen Effekten geh√∂rt? </h3><br><p>  Meine ersten Versuche herauszufinden, wer sie sind und warum sie mich aufregen sollten, waren erfolglos.  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehrere</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PDFs gefunden</a> , aber sie haben mich noch mehr verwirrt.  (Aus irgendeinem Grund schlafe ich beim Lesen von wissenschaftlichen Artikeln ein.) </p><br><p>  Aber mein Kollege Sebastian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nannte</a> sie weiterhin das mentale Modell einiger Dinge, die wir in React tun.  (Sebastian arbeitet im React-Team und hat viele Ideen eingebracht, einschlie√ülich Hooks und Suspense.) Irgendwann wurde es ein lokales Mem im React-Team, und viele unserer Gespr√§che endeten mit den folgenden: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xb/xm/oi/xbxmoi1bn7whmzill63sq1yz1tw.jpeg"></div><br><p>  Es stellte sich heraus, dass algebraische Effekte ein cooles Konzept sind und es nicht so be√§ngstigend ist, wie es mir nach dem Lesen dieser PDFs zun√§chst erschien.  Wenn Sie nur React verwenden, m√ºssen Sie nichts dar√ºber wissen, aber wenn Sie wie ich interessiert sind, lesen Sie weiter. </p><a name="habracut"></a><br><p>  (Haftungsausschluss: Ich bin kein Forscher auf dem Gebiet der Programmiersprachen und habe m√∂glicherweise etwas in meiner Erkl√§rung durcheinander gebracht. Lassen Sie mich wissen, wenn ich falsch liege!) </p><br><h3>  Es ist noch fr√ºh in der Produktion </h3><br><p> Algebraische Effekte sind derzeit ein experimentelles Konzept aus dem Bereich des Studiums von Programmiersprachen.  Dies bedeutet, dass Sie im Gegensatz zu <code>async/await</code> <code>for</code> <code>async/await</code> oder sogar <code>async/await</code> Ausdr√ºcken diese derzeit h√∂chstwahrscheinlich nicht in der Produktion verwenden k√∂nnen.  Sie werden nur von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wenigen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sprachen unterst√ºtzt</a> , die speziell f√ºr das Studium dieser Idee entwickelt wurden.  Es gibt Fortschritte bei der Implementierung in OCaml, die ... noch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andauert</a> .  Mit anderen Worten, beobachten Sie, aber ber√ºhren Sie nicht mit Ihren H√§nden. </p><br><h3>  Warum sollte es mich st√∂ren? </h3><br><p>  Stellen Sie sich vor, Sie schreiben Code mit <code>goto</code> und jemand erz√§hlt Ihnen von der Existenz von <code>if</code> und <code>for</code> Konstrukten.  Oder vielleicht stecken Sie in einer R√ºckruf-H√∂lle und jemand zeigt Ihnen <code>async/await</code> .  Ziemlich cool, nicht wahr? </p><br><p>  Wenn Sie der Typ sind, der Programmierinnovationen ein paar Jahre bevor sie in Mode kommen, lernen m√∂chte, ist es m√∂glicherweise an der Zeit, sich f√ºr algebraische Effekte zu interessieren.  Obwohl nicht notwendig.  So spricht man √ºber <code>async/await</code> im Jahr 1999. </p><br><h3>  Was f√ºr Effekte sind das? </h3><br><p>  Der Name mag etwas verwirrend sein, aber die Idee ist einfach.  Wenn Sie mit <code>try/catch</code> Bl√∂cken vertraut sind, werden Sie die algebraischen Effekte schnell verstehen. </p><br><p>  Erinnern wir uns zuerst an <code>try/catch</code> .  Angenommen, Sie haben eine Funktion, die Ausnahmen ausl√∂st.  M√∂glicherweise gibt es mehrere verschachtelte Aufrufe zwischen ihm und dem <code>catch</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'  '</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">",   : "</span></span>, err); }</code> </pre> <br><p>  Wir werfen eine Ausnahme in <code>getName</code> , die jedoch √ºber <code>makeFriends</code> zum n√§chsten <code>catch</code> "auftaucht".  Dies ist die Haupteigenschaft von <code>try/catch</code> .  <strong>F√ºr die Fehlerbehandlung ist kein Zwischencode erforderlich.</strong> </p><br><p>  Im Gegensatz zu Fehlercodes in Sprachen wie C m√ºssen Sie bei Verwendung von <code>try/catch</code> keine Fehler manuell durch jede Zwischenebene leiten, um den Fehler auf der obersten Ebene zu behandeln.  Ausnahmen werden automatisch angezeigt. </p><br><p>  Was hat das mit algebraischen Effekten zu tun? </p><br><p>  Im obigen Beispiel k√∂nnen wir das Programm nicht mehr ausf√ºhren, sobald ein Fehler auftritt.  Wenn wir uns in einem <code>catch</code> , wird die normale Programmausf√ºhrung gestoppt. </p><br><p>  Es ist alles vorbei.  Es ist zu sp√§t.  Das Beste, was wir tun k√∂nnen, ist, uns von einem Fehler zu erholen und vielleicht irgendwie zu wiederholen, was wir getan haben, aber wir k√∂nnen nicht auf magische Weise dorthin zur√ºckkehren, wo wir waren, und etwas anderes tun.  Und mit algebraischen Effekten k√∂nnen wir. </p><br><p>  Dies ist ein Beispiel, das in einem hypothetischen JavaScript-Dialekt geschrieben wurde (nennen wir es zum Spa√ü ES2025), mit dem wir nach dem fehlenden <code>user.name</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p>  (Ich entschuldige mich bei allen Lesern aus dem Jahr 2025, die im Internet nach ‚ÄûES2025‚Äú suchen und in diesen Artikel fallen. Wenn bis dahin algebraische Effekte Teil von JavaScript werden, werde ich den Artikel gerne aktualisieren!) </p><br><p>  Anstelle von <code>throw</code> wir das hypothetische Schl√ºsselwort <code>perform</code> .  In √§hnlicher Weise verwenden wir anstelle von <code>try/catch</code> das hypothetische <code>try/handle</code> .  Die genaue <strong>Syntax spielt hier keine Rolle</strong> - ich habe mir gerade etwas ausgedacht, um die Idee zu veranschaulichen. </p><br><p>  Also, was ist hier los?  Schauen wir uns das genauer an. </p><br><p>  Anstatt einen Fehler zu werfen, f√ºhren wir <em>den Effekt aus</em> .  So wie wir jedes Objekt <em>werfen</em> k√∂nnen, k√∂nnen wir hier einen Wert f√ºr die <em>Verarbeitung √ºbergeben</em> .  In diesem Beispiel √ºbergebe ich eine Zeichenfolge, es kann sich jedoch um ein Objekt oder einen anderen Datentyp handeln: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; }</code> </pre> <br><p>  Wenn wir eine Ausnahme ausl√∂sen, sucht die Engine nach dem n√§chstgelegenen <code>try/catch</code> Handler im Aufrufstapel.  Wenn wir einen <em>Effekt</em> ausf√ºhren, sucht die Engine auf der Suche nach dem n√§chstgelegenen <code>try/handle</code> Effekt-Handler oben auf dem Stapel: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br><p>  Dieser Effekt erm√∂glicht es uns zu entscheiden, wie mit der Situation umgegangen werden soll, wenn der Name nicht angegeben ist.  Neu hier (im Vergleich zu Ausnahmen) ist der hypothetische <code>resume with</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p>  Dies ist etwas, was Sie mit <code>try/catch</code> nicht tun k√∂nnen.  Es erm√∂glicht uns <strong>, dorthin zur√ºckzukehren, wo wir den Effekt ausgef√ºhrt haben, und etwas vom Handler zur√ºckzugeben</strong> .  : -O </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// 1.     name = perform 'ask_name'; // 4. ...     (name   ' ') } return name; } // ... try { makeFriends(arya, gendry); } handle(effect) { // 2.    ( try/catch)  (effect === 'ask_name') { // 3. ,      (    try/catch!) resume with ' '; } }</span></span></code> </pre><br><p>  Es dauert ein wenig, bis man es sich bequem gemacht hat, aber konzeptionell unterscheidet sich dies nicht wesentlich von <code>try/catch</code> mit einer R√ºckkehr. </p><br><p>  Beachten Sie jedoch, dass algebraische Effekte ein viel leistungsf√§higeres Werkzeug sind als nur <code>try/catch</code> .  Die Fehlerbehebung ist nur einer von vielen m√∂glichen Anwendungsf√§llen.  Ich habe nur mit diesem Beispiel begonnen, weil es f√ºr mich am einfachsten zu verstehen war. </p><br><br><h3>  Funktion hat keine Farbe </h3><br><p>  Algebraische Effekte haben interessante Auswirkungen auf asynchronen Code. </p><br><p>  In Sprachen mit <code>async/await</code> Funktionen normalerweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine ‚ÄûFarbe‚Äú</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Russisch</a> ).  In JavaScript k√∂nnen wir beispielsweise <code>getName</code> nicht einfach asynchron machen, ohne <code>makeFriends</code> und seine aufrufenden Funktionen mit asynchron zu infizieren.  Dies kann sehr schmerzhaft sein, wenn ein Teil des Codes manchmal synchron und manchmal asynchron sein muss. </p><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       ... async getName(user) { // ... } //       ... async function makeFriends(user1, user2) { user1.friendNames.add(await getName(user2)); user2.friendNames.add(await getName(user1)); } //   ... async getName(user) { // ... }</span></span></code> </pre><br><p>  JavaScript-Generatoren funktionieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√§hnlich</a> : Wenn Sie mit Generatoren arbeiten, sollte der gesamte Zwischencode auch √ºber Generatoren Bescheid wissen. </p><br><p>  Was hat das damit zu tun? </p><br><p>  Vergessen wir f√ºr einen Moment async / await und kehren zu unserem Beispiel zur√ºck: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p>  Was ist, wenn unser Effekt-Handler den "Ersatznamen" nicht synchron zur√ºckgeben kann?  Was ist, wenn wir es aus der Datenbank erhalten m√∂chten? </p><br><p>  Es stellt sich heraus, dass wir <code>resume with</code> asynchron von unserem Effekthandler aus aufrufen k√∂nnen, ohne √Ñnderungen an <code>getName</code> oder <code>makeFriends</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); } }</code> </pre><br><p>  In diesem Beispiel rufen wir den <code>resume with</code> nur eine Sekunde sp√§ter auf.  Sie k√∂nnen einen <code>resume with</code> R√ºckruf in Betracht ziehen, den Sie nur einmal aufrufen k√∂nnen.  (Sie k√∂nnen sich auch Freunden zeigen, indem Sie dieses Ding "eine einmalig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">begrenzte Fortsetzung</a> " nennen (der Begriff " <i>begrenzte Trennung"</i> hat noch keine stabile √úbersetzung ins Russische erhalten - ca. √úbersetzung).) </p><br><p>  Jetzt sollte die Mechanik algebraischer Effekte etwas klarer sein.  Wenn wir einen Fehler ausl√∂sen, dreht die JavaScript-Engine den Stapel, indem sie dabei lokale Variablen zerst√∂rt.  Wenn wir jedoch <em>den</em> Effekt <em>ausf√ºhren</em> , erstellt unsere hypothetische Engine einen R√ºckruf (tats√§chlich ein ‚ÄûFortsetzungsrahmen‚Äú, ca. Transl.) Mit dem Rest unserer Funktion und setzt ihn mit fort. </p><br><p>  Nochmals eine Erinnerung: Die spezifische Syntax und die spezifischen Schl√ºsselw√∂rter werden nur f√ºr diesen Artikel vollst√§ndig erfunden.  Es geht nicht darum, sondern um die Mechanik. </p><br><br><h3>  Hinweis zur Sauberkeit </h3><br><p>  Es ist erw√§hnenswert, dass algebraische Effekte als Ergebnis der Untersuchung der funktionalen Programmierung entstanden sind.  Einige der Probleme, die sie l√∂sen, gelten nur f√ºr die funktionale Programmierung.  In Sprachen, die keine willk√ºrlichen Nebenwirkungen zulassen (wie Haskell), sollten Sie beispielsweise Konzepte wie Monaden verwenden, um Effekte durch Ihr Programm zu ziehen.  Wenn Sie jemals das Monaden-Tutorial gelesen haben, wissen Sie, dass es schwierig sein kann, es zu verstehen.  Algebraische Effekte helfen dabei, etwas √Ñhnliches mit etwas weniger Aufwand zu erreichen. </p><br><p>  Deshalb sind die meisten Diskussionen √ºber algebraische Effekte f√ºr mich v√∂llig unverst√§ndlich.  (Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kenne Haskell</a> und seine "Freunde" nicht.) Ich denke jedoch, dass algebraische Effekte selbst in einer unreinen Sprache wie JavaScript ein sehr leistungsf√§higes Werkzeug sein k√∂nnen, um das "Was" vom "Wie" in Ihrem Code zu trennen. </p><br><p>  Mit ihnen k√∂nnen Sie Code schreiben, der beschreibt, <em>was</em> Sie tun: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumerateFiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dir</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> contents = perform OpenDirectory(dir); perform Log(<span class="hljs-string"><span class="hljs-string">'Enumerating files in '</span></span>, dir); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> contents.files) { perform HandleFile(file); } perform Log(<span class="hljs-string"><span class="hljs-string">'Enumerating subdirectories in '</span></span>, dir); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> directory <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> contents.dir) { <span class="hljs-comment"><span class="hljs-comment">//           enumerateFiles(directory); } perform Log('Done'); }</span></span></code> </pre> <br><p>  Und wickeln Sie es sp√§ter mit etwas ein, das beschreibt, wie Sie es tun: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> files = []; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { enumerateFiles(<span class="hljs-string"><span class="hljs-string">'C:\\'</span></span>); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Log) { myLoggingLibrary.log(effect.message); resume; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> OpenDirectory) { myFileSystemImpl.openDir(effect.dirName, (contents) =&gt; { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> contents; }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HandleFile) { files.push(effect.fileName); resume; } } <span class="hljs-comment"><span class="hljs-comment">//  `files`    </span></span></code> </pre><br><p>  Was bedeutet, dass diese Teile eine Bibliothek werden k√∂nnen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withMyLoggingLibrary } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'my-log'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withMyFileSystem } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'my-fs'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ourProgram</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ enumerateFiles(<span class="hljs-string"><span class="hljs-string">'C:\\'</span></span>); } withMyLoggingLibrary(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { withMyFileSystem(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ourProgram(); }); });</code> </pre><br><p>  Im Gegensatz zu Async / Warten oder Generatoren erfordern algebraische Effekte keine Komplikation von ‚ÄûZwischenfunktionen‚Äú.  Unser Aufruf von <code>enumerateFiles</code> sich zwar tief in unserem Programm, aber solange es einen Effekt-Handler f√ºr jeden der Effekte gibt, die irgendwo oben ausgef√ºhrt werden k√∂nnen, funktioniert unser Code weiterhin. </p><br><p>  Effekt-Handler erm√∂glichen es uns, die Programmlogik von bestimmten Implementierungen ihrer Effekte zu trennen, ohne unn√∂tige T√§nze und Boilerplate-Code.  Zum Beispiel k√∂nnten wir das Verhalten in den Tests komplett neu definieren, um das gef√§lschte Dateisystem zu verwenden und Schnappsch√ºsse von Protokollen zu erstellen, anstatt sie auf der Konsole anzuzeigen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withFakeFileSystem } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'fake-fs'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withLogSnapshot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logs = []; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fn(); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Log) { logs.push(effect.message); resume; } } <span class="hljs-comment"><span class="hljs-comment">// Snapshot  . expect(logs).toMatchSnapshot(); } test('my program', () =&gt; { const fakeFiles = [ /* ... */ ]; withFakeFileSystem(fakeFiles, () =&gt; { withLogSnapshot(() =&gt; { ourProgram(); }); }); });</span></span></code> </pre><br><p>  Da Funktionen keine ‚ÄûFarbe‚Äú haben (der Zwischencode muss nichts √ºber Effekte wissen) und Effekthandler zusammengestellt werden k√∂nnen (sie k√∂nnen verschachtelt sein), k√∂nnen Sie mit ihnen sehr ausdrucksstarke Abstraktionen erstellen. </p><br><br><h3>  Typen Hinweis </h3><br><p>  Da algebraische Effekte aus statisch typisierten Sprachen stammen, konzentriert sich der gr√∂√üte Teil der Debatte dar√ºber darauf, wie sie in Typen ausgedr√ºckt werden k√∂nnen.  Dies ist zweifellos wichtig, kann aber auch das Verst√§ndnis des Konzepts erschweren.  Deshalb geht es in diesem Artikel √ºberhaupt nicht um Typen.  Ich sollte jedoch beachten, dass normalerweise die Tatsache, dass eine Funktion einen Effekt ausf√ºhren kann, in einer Signatur ihres Typs codiert wird.  Auf diese Weise sind Sie vor einer Situation gesch√ºtzt, in der unvorhersehbare Effekte auftreten oder Sie nicht nachverfolgen k√∂nnen, woher sie stammen. </p><br><p>  Hier kann man sagen, dass technisch algebraische Effekte Funktionen in statisch typisierten Sprachen ‚ÄûFarbe verleihen‚Äú, da Effekte Teil einer Typensignatur sind.  Das ist tats√§chlich so.  Das Festlegen der Typanmerkung f√ºr eine Zwischenfunktion, um einen neuen Effekt einzuschlie√üen, ist an sich keine semantische √Ñnderung - im Gegensatz zum Hinzuf√ºgen von Async oder dem Verwandeln der Funktion in einen Generator.  Typinferenz kann auch dazu beitragen, die Notwendigkeit kaskadierender √Ñnderungen zu vermeiden.  Ein wichtiger Unterschied besteht darin, dass Sie Effekte ‚Äûunterdr√ºcken‚Äú k√∂nnen, indem Sie einen leeren Stub oder eine tempor√§re Implementierung einf√ºgen (z. B. einen Synchronisationsaufruf f√ºr einen asynchronen Effekt), wodurch Sie bei Bedarf die Auswirkungen auf externen Code verhindern oder in einen anderen Effekt umwandeln k√∂nnen. </p><br><br><h3>  Ben√∂tige ich algebraische Effekte in JavaScript? </h3><br><p>  Ehrlich gesagt wei√ü ich es nicht.  Sie sind sehr m√§chtig, und es kann argumentiert werden, dass sie f√ºr eine Sprache wie JavaScript zu m√§chtig sind. </p><br><p>  Ich denke, dass sie f√ºr Sprachen sehr n√ºtzlich sein k√∂nnten, in denen Mutabilit√§t selten ist und in denen die Standardbibliothek Effekte vollst√§ndig unterst√ºtzt.  Wenn Sie zuerst <code>perform Timeout(1000), perform Fetch('http://google.com')</code> und <code>perform ReadFile('file.txt')</code> und Ihre Sprache dann √ºber "Pattern Matching" und statische Typisierung f√ºr Effekte verf√ºgt Dies kann eine sehr sch√∂ne Programmierumgebung sein. </p><br><p>  Vielleicht wird diese Sprache sogar in JavaScript kompiliert! </p><br><br><h3>  Was hat das mit React zu tun? </h3><br><p>  Nicht sehr gro√ü.  Man kann sogar sagen, dass ich eine Eule auf einen Globus ziehe. </p><br><p>  Wenn Sie meinen Vortrag √ºber Time Slicing und Suspense gesehen haben, enth√§lt der zweite Teil Komponenten, die Daten aus dem Cache lesen: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MovieDetails</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ id }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         ? const movie = movieCache.read(id); }</span></span></code> </pre><br><p>  (Der Bericht verwendet eine etwas andere API, aber das ist nicht der Punkt.) </p><br><p>  Dieser Code basiert auf der React-Funktion f√ºr Datenproben namens ‚Äû <code>Suspense</code> ‚Äú, die derzeit aktiv entwickelt wird.  Das Interessante dabei ist nat√ºrlich, dass sich die Daten m√∂glicherweise noch nicht im movieCache befinden. In diesem Fall m√ºssen wir zuerst etwas tun, da wir die Ausf√ºhrung nicht fortsetzen k√∂nnen.  Technisch gesehen l√∂st in diesem Fall der Aufruf von read () Promise aus (ja, Promise werfen - Sie m√ºssen diese Tatsache schlucken).  Dies unterbricht die Ausf√ºhrung.  React f√§ngt dieses Versprechen ab und erinnert sich, dass das Rendern des Komponentenbaums wiederholt werden muss, nachdem das ausgel√∂ste Versprechen erf√ºllt wurde. </p><br><p>  Dies ist an sich kein algebraischer Effekt, obwohl die Erstellung dieses Tricks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von</a> ihnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">inspiriert wurde</a> .  Mit diesem Trick wird das gleiche Ziel erreicht: Ein Teil des folgenden Codes im Aufrufstapel ist vor√ºbergehend einem h√∂heren Wert im Aufrufstapel unterlegen (in diesem Fall Reagieren), w√§hrend nicht alle Zwischenfunktionen davon wissen oder durch Asynchronit√§t oder Generatoren ‚Äûvergiftet‚Äú werden m√ºssen.  Nat√ºrlich k√∂nnen wir die Ausf√ºhrung in JavaScript nicht "tats√§chlich" fortsetzen, aber aus Sicht von React ist die erneute Anzeige des Komponentenbaums nach der Promise-Berechtigung fast identisch.  Sie k√∂nnen betr√ºgen, wenn Ihr Programmiermodell Idempotenz annimmt! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hooks</a> sind ein weiteres Beispiel, das Sie an algebraische Effekte erinnern kann.  Eine der ersten Fragen ist: Woher wei√ü der useState-Aufruf, auf welche Komponente er sich bezieht? </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LikeButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  useState ,    ? const [isLiked, setIsLiked] = useState(false); }</span></span></code> </pre><br><p>  Ich habe dies bereits am Ende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Artikels erkl√§rt</a> : Im React-Objekt befindet sich ein ver√§nderbarer Status "Current Dispatcher", der die Implementierung angibt, die Sie derzeit verwenden (z. B. in React <code>react-dom</code> ).  Ebenso gibt es eine aktuelle Komponenteneigenschaft, die auf die interne Datenstruktur von LikeButton verweist.  So findet useState heraus, was zu tun ist. </p><br><p>  Bevor man sich daran gew√∂hnt, denken die Leute oft, dass es aus einem offensichtlichen Grund wie ein schmutziger Hack aussieht.  Es ist falsch, sich auf einen allgemeinen ver√§nderlichen Zustand zu verlassen.  (Hinweis: Wie wird try / catch Ihrer Meinung nach in der JavaScript-Engine implementiert?) </p><br><p>  Konzeptionell k√∂nnen Sie useState () jedoch als Effekt der Ausf√ºhrung von State () betrachten, das von React verarbeitet wird, wenn Ihre Komponente ausgef√ºhrt wird.  Dies ‚Äûerkl√§rt‚Äú, warum React (was Ihre Komponente aufruft) den Status bereitstellen kann (er ist h√∂her im Aufrufstapel, sodass er einen Effekthandler bereitstellen kann).  In der Tat ist die explizite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zustandsimplementierung</a> eines der h√§ufigsten Beispiele in Lehrb√ºchern √ºber algebraische Effekte, auf die ich gesto√üen bin. </p><br><p>  Auch hier funktioniert React nat√ºrlich nicht so, da wir in JavaScript keine algebraischen Effekte haben.  Stattdessen gibt es ein verstecktes Feld, in dem wir die aktuelle Komponente speichern, sowie ein Feld, das auf den aktuellen "Dispatcher" mit der useState-Implementierung verweist.  Zur Leistungsoptimierung gibt es sogar separate useState-Implementierungen f√ºr Bereitstellungen <a href="">und Aktualisierungen</a> .  Wenn Sie jetzt von diesem Code sehr verdreht sind, k√∂nnen Sie sie als normale Effekt-Handler betrachten. </p><br><p>  Zusammenfassend k√∂nnen wir sagen, dass <code>throw</code> in JavaScript als erste Ann√§herung f√ºr E / A-Effekte dienen kann (vorausgesetzt, der Code kann sp√§ter sicher erneut ausgef√ºhrt werden und solange er nicht an die CPU gebunden ist), und das Variablenfeld ‚Äû Der in try / finally wiederhergestellte Dispatcher kann als grobe Ann√§herung f√ºr Synchroneffekt-Handler dienen. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit Generatoren</a> k√∂nnen Sie eine viel qualitativ hochwertigere Implementierung von Effekten erzielen. Dies bedeutet jedoch, dass Sie die "transparente" Natur von JavaScript-Funktionen aufgeben und alles mit Generatoren tun m√ºssen.  Und das ist "gut, das ..." </p><br><h3>  Wo kann man mehr erfahren? </h3><br><p>  Pers√∂nlich war ich √ºberrascht, wie viel Sinn algebraische Effekte f√ºr mich erlangt haben.  Ich habe immer mein Bestes versucht, um abstrakte Konzepte wie Monaden zu verstehen, aber algebraische Effekte wurden einfach im Kopf aufgenommen und ‚Äûeingeschaltet‚Äú.  Ich hoffe, dass dieser Artikel ihnen hilft, mit Ihnen ‚Äûmitzumachen‚Äú. </p><br><p>  Ich wei√ü nicht, ob sie jemals in gro√üen Mengen verwendet werden.  Ich denke, dass ich entt√§uscht sein werde, wenn sie bis 2025 in keiner der Hauptsprachen Wurzeln schlagen.  Erinnern Sie mich daran, in f√ºnf Jahren einzuchecken! </p><br><p>  Ich bin sicher, dass Sie mit ihnen viel interessanter werden k√∂nnen, aber es ist wirklich schwierig, ihre St√§rke zu sp√ºren, bis Sie anfangen, Code zu schreiben und sie zu verwenden.  Wenn dieser Beitrag Ihre Neugier geweckt hat, finden Sie hier einige weitere Ressourcen, die Sie ausf√ºhrlicher lesen k√∂nnen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/ocamllabs/ocaml-effects-tutorial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.janestreet.com/tech-talks/effective-programming</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.youtube.com/watch?v=hrBq8R_kxI0</a> </li></ul><br><p>  Viele Leute haben auch darauf hingewiesen, dass, wenn Sie den Tippaspekt weglassen (wie ich es in diesem Artikel getan habe), Sie eine fr√ºhere Verwendung einer solchen Technik in einem Bedingungssystem in Common Lisp finden k√∂nnen.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a>  ,   ,   call/cc          . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470718/">https://habr.com/ru/post/de470718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470696/index.html">Warum ist Kaldi gut f√ºr die Spracherkennung? (aktualisiert am 25.12.2019)</a></li>
<li><a href="../de470700/index.html">Tischplatte. Metallic Lautlos Ihre</a></li>
<li><a href="../de470706/index.html">Python + Keras + LSTM: Erstellen Sie in einer halben Stunde einen Text√ºbersetzer</a></li>
<li><a href="../de470710/index.html">Maschinelles Lernen f√ºr Ihre Wohnungssuche. Teil 2</a></li>
<li><a href="../de470714/index.html">Wie ich zum Digital Breakthrough Finale kam</a></li>
<li><a href="../de470720/index.html">Wie schreibe ich einen intelligenten Vertrag mit Python √ºber Ontologie? Teil 2: Speicher-API</a></li>
<li><a href="../de470722/index.html">Wie schreibe ich einen intelligenten Vertrag mit Python √ºber Ontologie? Teil 3: Laufzeit-API</a></li>
<li><a href="../de470726/index.html">Wie man nicht routinem√§√üig ertrinkt oder unsere Erfahrung beim Vergleich von AWR-Dumps w√§hrend Stresstests</a></li>
<li><a href="../de470728/index.html">Azure PowerShell: Meist harmlos</a></li>
<li><a href="../de470730/index.html">Azure PowerShell: "Meist harmlos"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>