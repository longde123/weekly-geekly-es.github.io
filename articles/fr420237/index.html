<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå∏ üßíüèæ üò≠ Enveloppe Qt autour du framework gRPC en C ++ üë©üèæ‚Äçü§ù‚Äçüë©üèª ‚õ©Ô∏è üï∂Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous. Aujourd'hui, nous allons voir comment vous pouvez lier le framework gRPC en C ++ et la biblioth√®que Qt. L'article fournit un code r√©su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enveloppe Qt autour du framework gRPC en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420237/"><p>  Bonjour √† tous.  Aujourd'hui, nous allons voir comment vous pouvez lier le framework gRPC en C ++ et la biblioth√®que Qt.  L'article fournit un code r√©sumant l'utilisation des quatre modes d'interaction dans gRPC.  De plus, un code est fourni qui permet l'utilisation de gRPC via des signaux Qt et des slots.  L'article peut int√©resser principalement les d√©veloppeurs Qt int√©ress√©s par l'utilisation de gRPC.  N√©anmoins, une g√©n√©ralisation des quatre modes de fonctionnement de gRPC est √©crite en C ++ sans utiliser Qt, ce qui permettra aux d√©veloppeurs qui ne sont pas li√©s √† Qt d'adapter le code.  Je demande √† tout le monde int√©ress√© par cat. </p><a name="habracut"></a><br><h2>  Contexte </h2><br><p>  Il y a environ six mois, deux projets m'ont accroch√©, utilisant les parties client et serveur de gRPC.  Les deux projets ont chut√© en production.  Ces projets ont √©t√© √©crits par des d√©veloppeurs qui ont d√©j√† quitt√©.  La seule bonne nouvelle est que j'ai pris une part active √† l'√©criture du code serveur et client gRPC.  Mais c'√©tait il y a environ un an.  Par cons√©quent, comme d'habitude, j'ai d√ª tout g√©rer √† partir de z√©ro. </p><br><p>  Le code du serveur gRPC a √©t√© √©crit dans l'espoir qu'il sera g√©n√©r√© davantage par le fichier .proto.  Le code a √©t√© bien √©crit.  Cependant, le serveur avait un gros inconv√©nient: un seul client pouvait s'y connecter. </p><br><p>  Le client gRPC a √©t√© √©crit juste horrible. </p><br><p>  J'ai d√©couvert le code client et serveur gRPC quelques jours plus tard.  Et j'ai r√©alis√© que si je prenais un projet pendant quelques semaines, je devrais √† nouveau traiter avec le serveur et le client gRPC. </p><br><p>  C'est alors que j'ai d√©cid√© qu'il √©tait temps d'√©crire et de d√©boguer le client et le serveur gRPC afin que: </p><br><ul><li><p>  Vous pouvez dormir paisiblement la nuit; </p></li><li><p>  Il n'√©tait pas n√©cessaire de se rappeler comment cela fonctionne √† chaque fois que vous devez √©crire un client ou un serveur gRPC; </p></li><li><p>  Vous pouvez utiliser le client et le serveur gRPC √©crits dans d'autres projets. </p></li></ul><br><p>  Lors de l'√©criture de code, j'ai √©t√© guid√© par les exigences suivantes: </p><br><ul><li><p>  Le client et le serveur gRPC peuvent fonctionner de mani√®re naturelle en utilisant les signaux et les emplacements de la biblioth√®que Qt; </p></li><li><p>  Le code client et serveur gRPC n'a pas besoin d'√™tre corrig√© lors de la modification du fichier .proto; </p></li><li><p>  Le client gRPC doit pouvoir indiquer au code client l'√©tat de la connexion au serveur. </p></li></ul><br><p>  La structure de l'article est la suivante.  Tout d'abord, il y aura un bref aper√ßu des r√©sultats de l'utilisation du code client et quelques explications.  √Ä la fin de l'examen, un lien vers le r√©f√©rentiel.  De plus, il y aura des choses g√©n√©rales sur l'architecture.  Ensuite, une description du serveur et du code client (ce qui est sous le capot) et une conclusion. </p><br><h2>  Br√®ve revue </h2><br><p>  Le fichier pingproto.proto le plus simple a √©t√© utilis√© comme fichier .proto, dans lequel des RPC de tous les types d'interaction ont √©t√© d√©finis: </p><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> pingpong; <span class="hljs-attribute"><span class="hljs-attribute">service</span></span> ping { <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> SayHello (PingRequest) returns (PingReply) {} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GladToSeeMe(PingRequest) returns (stream PingReply){} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GladToSeeYou(stream PingRequest) returns (PingReply){} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> BothGladToSee(stream PingRequest) returns (stream PingReply){} } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PingRequest { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> name = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> message = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PingReply { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> message = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  Le fichier pingpong.proto r√©p√®te le fichier helloworld.proto de l'article sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les modes gRPC asynchrones en C ++</a> jusqu'au nom exact. </p><br><p>  En cons√©quence, un serveur √©crit peut √™tre utilis√© comme ceci: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT; QpingServerService pingservice; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: A() { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_ok; is_ok = connect(&amp;pingservice, SIGNAL(SayHelloRequest(SayHelloCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onSayHello(SayHelloCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(GladToSeeMeRequest(GladToSeeMeCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onGladToSeeMe(GladToSeeMeCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(GladToSeeYouRequest(GladToSeeYouCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onGladToSeeYou(GladToSeeYouCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(BothGladToSeeRequest(BothGladToSeeCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onBothGladToSee(BothGladToSeeCallData*))); assert(is_ok); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSayHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SayHelloCallData* cd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"["</span></span> &lt;&lt; cd-&gt;peer() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"][11]: request: "</span></span> &lt;&lt; cd-&gt;request.name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; cd-&gt;reply.set_message(<span class="hljs-string"><span class="hljs-string">"hello "</span></span> + cd-&gt;request.name()); cd-&gt;Finish(); } <span class="hljs-comment"><span class="hljs-comment">//etc. };</span></span></code> </pre><br><p>  Lorsqu'un client appelle RPC, le serveur gRPC notifie le code client (dans ce cas, la classe A) avec le signal appropri√©. </p><br><p>  Le client gRPC peut √™tre utilis√© comme ceci: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> B : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> QObject { Q_OBJECT QpingClientService pingPongSrv; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: B() { <span class="hljs-type"><span class="hljs-type">bool</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(SayHelloResponse(SayHelloCallData*)), this, SLOT(onSayHelloResponse(SayHelloCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(GladToSeeMeResponse(GladToSeeMeCallData*)), this, SLOT(onGladToSeeMeResponse(GladToSeeMeCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(GladToSeeYouResponse(GladToSeeYouCallData*)), this, SLOT(onGladToSeeYouResponse(GladToSeeYouCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(BothGladToSeeResponse(BothGladToSeeCallData*)), this, SLOT(onBothGladToSeeResponse(BothGladToSeeCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(channelStateChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>)), this, SLOT(onPingPongStateChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); } <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">usage</span></span>() { //Unary PingRequest request; request.set_name("user"); request.set_message("user"); pingPongSrv.SayHello(request); //<span class="hljs-keyword"><span class="hljs-keyword">Server</span></span> streaming PingRequest request2; request2.set_name("user"); pingPongSrv.GladToSeeMe(request2); //etc. } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> slots: <span class="hljs-type"><span class="hljs-type">void</span></span> SayHelloResponse(SayHelloCallData* response) { std::cout &lt;&lt; "[11]: reply: " &lt;&lt; response-&gt;reply.message() &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response-&gt;CouldBeDeleted()) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> response; } //etc. };</code> </pre><br><p>  Le client gRPC vous permet d'appeler directement RPC et de vous abonner √† la r√©ponse du serveur en utilisant les signaux appropri√©s. </p><br><p>  Le client gRPC a √©galement un signal: <br><br></p><pre> <code class="hljs objectivec">channelStateChanged(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>);</code> </pre><br>  qui rend compte des √©tats de connexion pass√©s et actuels du serveur.  Tous les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemples de</a> code se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trouvent</a> dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le r√©f√©rentiel qgrpc</a> . <br><br><h2>  Comment √ßa marche </h2><br><p>  Le principe de l'inclusion du client et du serveur gRPC dans le projet est illustr√© dans la figure. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i3/h9/ad/i3h9ad3c3joddotb7akq1iagpnc.jpeg"></div><br><p>  Dans le fichier de projet .pro, les fichiers .proto sont sp√©cifi√©s, sur la base desquels gRPC fonctionnera.  Le fichier grpc.pri contient des commandes pour g√©n√©rer des fichiers gRPC et QgRPC.  Le compilateur de protocole g√©n√®re des fichiers gRPC [protofile] .grpc.pb.h et [protofile] .grpc.pb.cc.  [protofile] est le nom du fichier .proto pass√© √† l'entr√©e du compilateur. </p><br><p>  La g√©n√©ration des fichiers QgRPC [protofile] .qgrpc. [Config] .h est g√©r√©e par le script genQGrpc.py.  [config] est soit ¬´serveur¬ª soit ¬´client¬ª. <br><br>  Les fichiers QgRPC g√©n√©r√©s contiennent un wrapper Qt autour des classes gRPC et des appels avec les signaux correspondants.  Dans les exemples pr√©c√©dents, les classes QpingServerService et QpingClientService sont d√©clar√©es respectivement dans les fichiers g√©n√©r√©s pingpong.qgrpc.server.h et pingpong.qgrpc.client.h.  Les fichiers QgRPC g√©n√©r√©s sont ajout√©s au traitement moc. </p><br><p>  Dans les fichiers QgRPC g√©n√©r√©s, les fichiers QGrpc [config] .h sont inclus, dans lesquels tout le travail principal a lieu.  En savoir plus √† ce sujet ci-dessous. </p><br><p>  Pour connecter toute cette construction au projet, vous devez inclure le fichier grpc.pri dans le fichier .pro du projet et sp√©cifier trois variables.  La variable GRPC d√©finit les fichiers .proto qui seront transf√©r√©s aux entr√©es du compilateur de protocole et du script genQGrpc.py.  La variable QGRPC_CONFIG d√©finit la valeur de configuration des fichiers QgRPC g√©n√©r√©s et peut contenir les valeurs ¬´serveur¬ª ou ¬´client¬ª.  Vous pouvez √©galement d√©finir la variable facultative GRPC_VERSION pour indiquer la version de gRPC. </p><br><p>  Pour plus d'informations sur tout ce qui est dit, lisez le fichier grpc.pri et les fichiers d'exemple .pro. </p><br><h2>  Architecture de serveur </h2><br><p>  Le diagramme de classe du serveur est illustr√© dans la figure. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nd/ec/ae/ndecaezqpvmh1kn9iviw6yuic9i.jpeg"></div><br><p>  Les fl√®ches √©paisses indiquent la hi√©rarchie de l'h√©ritage de classe et les fl√®ches fines indiquent l'appartenance des membres et des m√©thodes aux classes.  En g√©n√©ral, la classe Q [servicename] ServerService est g√©n√©r√©e pour le service, o√π servicename est le nom du service d√©clar√© dans le fichier .proto.  RPCCallData sont des structures de contr√¥le g√©n√©r√©es pour chaque RPC du service.  Dans le constructeur de la classe QpingServerService, la classe de base QGrpcServerService est initialis√©e avec le service asynchrone gRPC pingpong :: ping :: AsyncService.  Pour d√©marrer le service, vous devez appeler la m√©thode Start () avec l'adresse et le port sur lesquels le service s'ex√©cutera.  La fonction Start () impl√©mente la proc√©dure standard pour d√©marrer un service. </p><br><p>  √Ä la fin de la fonction Start (), la fonction virtuelle pure makeRequests () est appel√©e, qui est impl√©ment√©e dans la classe QpingServerService g√©n√©r√©e: </p><br><pre> <code class="hljs xml">void makeRequests() { needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SayHello_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SayHelloCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeMe_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeMeCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeYou_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeYouCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BothGladToSee_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BothGladToSeeCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); }</code> </pre><br><p>  Le deuxi√®me param√®tre de mod√®le de la fonction needAnotherCallData est les structures RPCCallData g√©n√©r√©es.  Les m√™mes structures sont les param√®tres des signaux dans la classe Qt g√©n√©r√©e du service. </p><br><p>  Les structures RPCCallData g√©n√©r√©es h√©ritent de la classe ServerCallData.  √Ä son tour, la classe ServerCallData est h√©rit√©e du r√©pondeur ServerResponder.  Ainsi, la cr√©ation d'un objet de structures coh√©rentes conduit √† la cr√©ation d'un objet r√©pondeur. </p><br><p>  Le constructeur de la classe ServerCallData prend deux param√®tres: signal_func et request_func.  signal_func est un signal g√©n√©r√© qui est appel√© apr√®s avoir re√ßu une balise de la file d'attente.  request_func est une fonction qui doit √™tre appel√©e lors de la cr√©ation d'un nouveau r√©pondeur.  Par exemple, dans ce cas, il peut s'agir de la fonction RequestSayHello ().  L'appel request_func se produit dans la fonction needAnotherCallData ().  Ceci est fait pour que la gestion des r√©pondants (cr√©ation et suppression) se fasse dans le service. </p><br><p>  Le code de la fonction needAnotherCallData () consiste √† cr√©er un objet r√©pondeur et √† appeler une fonction qui connecte le r√©pondeur √† un appel RPC: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCCallData</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCTypes</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">needAnotherCallData</span></span></span><span class="hljs-class">() {</span></span> RPCCallData* cd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RPCCallData(); <span class="hljs-comment"><span class="hljs-comment">//... RequestRPC&lt;RPCTypes::kind, ...&gt; (service_, cd-&gt;request_func_, cd-&gt;responder, ..., (void*)cd); }</span></span></code> </pre><br><p>  Les fonctions RequestRPC () sont des fonctions de mod√®le pour quatre types d'interaction.  Par cons√©quent, l'appel de RequestRPC () se r√©sume √† un appel: </p><br><pre> <code class="hljs lisp">service_-&gt;(<span class="hljs-name"><span class="hljs-name">cd-&gt;request_func_</span></span>)(...,cd-&gt;responder, (<span class="hljs-name"><span class="hljs-name">void*</span></span>)cd)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p>  o√π service_ est le service gRPC.  Dans ce cas, il s'agit de pingpong :: ping :: AsyncService. </p><br><p>  Pour v√©rifier de mani√®re synchrone ou asynchrone la file d'attente d'√©v√©nements, vous devez appeler les fonctions CheckCQ () ou AsyncCheckCQ (), respectivement.  Le code de la fonction CheckCQ () se r√©sume aux appels √† la balise synchrone de la file d'attente et au traitement de cette balise: </p><br><pre> <code class="hljs pgsql">virtual <span class="hljs-type"><span class="hljs-type">void</span></span> CheckCQ() override { <span class="hljs-type"><span class="hljs-type">void</span></span>* tag; <span class="hljs-type"><span class="hljs-type">bool</span></span> ok; server_cq_-&gt;Next(&amp;tag, &amp;ok); //tagActions_ <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tag) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; AbstractCallData* cd = (AbstractCallData*)tag; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!started_.<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>()) { destroyCallData(cd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } cd-&gt;cqReaction(this, ok); }</code> </pre><br><p>  Apr√®s avoir re√ßu la balise de la file d'attente, la validit√© de la balise et le d√©marrage du serveur sont v√©rifi√©s.  Si le serveur est √©teint, la balise n'est plus n√©cessaire - elle peut √™tre supprim√©e.  Apr√®s cela, la fonction cqReaction () d√©finie dans la classe ServerCallData est appel√©e: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cqReaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QGrpcServerService* service_, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!first_time_reaction_) { first_time_reaction_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; service_-&gt;needAnotherCallData&lt;RPC, RPCCallData&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> genRpcCallData = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;RPCCallData*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* tag = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(genRpcCallData); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;CouldBeDeleted()) { service_-&gt;destroyCallData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;processEvent(tag, ok)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//call generated service signal with generated call data argument service_-&gt;(*signal_func_)(genRpcCallData); }</span></span></code> </pre><br><p>  L'indicateur first_time_reaction_ indique que vous devez cr√©er un nouveau r√©pondeur pour le RPC appel√©.  Les fonctions CouldBeDeleted () et ProcessEvent () sont h√©rit√©es de la classe de r√©pondeur ServerResponder correspondante.  La fonction Can'tBeDeleted () renvoie un signe que l'objet r√©pondeur peut √™tre supprim√©.  La fonction processEvent () traite la balise et le drapeau ok.  Ainsi, par exemple, pour un r√©pondeur de type Client Streaming, la fonction ressemble √† ceci: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tag, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;tag_ = tag; read_mode_ = ok; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  La fonction ProcessEvent (), quel que soit le type de r√©pondeur, renvoie toujours true.  La valeur de retour de cette fonction est laiss√©e pour une √©ventuelle extension de fonctionnalit√© et, th√©oriquement, pour √©liminer les erreurs. </p><br><p>  Apr√®s avoir trait√© l'√©v√©nement, l'appel suit: <br><br></p><pre> <code class="hljs lisp">service_-&gt;(<span class="hljs-name"><span class="hljs-name">*signal_func_</span></span>)(<span class="hljs-name"><span class="hljs-name">genRpcCallData</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p>  La variable service_ est une instance du service g√©n√©r√©, dans notre cas QpingServerService.  La variable signal_func_ est un signal de service correspondant √† un RPC sp√©cifique.  Par exemple, SayHelloRequest ().  La variable genRpcCallData est un objet r√©pondeur du type correspondant.  Du point de vue du code appelant, la variable genRpcCallData est un objet de l'une des structures RPCCallData g√©n√©r√©es. <br></p><br><h2>  Architecture client </h2><br><p>  Dans la mesure du possible, les noms des classes et fonctions du client correspondent aux noms des classes et fonctions du serveur.  Le diagramme de classe client est illustr√© dans la figure. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4u/ak/xe/4uakxee1iettn1zm_7fooerdosc.jpeg"></div><br><p>  Les fl√®ches √©paisses indiquent la hi√©rarchie de l'h√©ritage de classe et les fl√®ches fines indiquent l'appartenance des membres et des m√©thodes aux classes.  En g√©n√©ral, pour le service, la classe Q [nom_service] ClientService est g√©n√©r√©e, o√π nom_service est le nom du service d√©clar√© dans le fichier .proto.  RPCCallData sont des structures de contr√¥le g√©n√©r√©es pour chaque RPC du service.  Pour appeler un RPC, la classe g√©n√©r√©e fournit des fonctions dont les noms correspondent exactement au RPC d√©clar√© dans le fichier .proto.  Dans notre exemple, dans le fichier RPC .proto, SayHello () est d√©clar√© comme: <br><br></p><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">rpc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SayHello</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PingRequest</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PingReply</span></span></span><span class="hljs-function">)</span></span> {}</code> </pre><br><p>  Dans la classe QpingClientService g√©n√©r√©e, la fonction RPC correspondante ressemble √† ceci: </p><br><pre> <code class="hljs vbscript">void SayHello(PingRequest <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!connected()) return; SayHelloCallData* <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SayHelloCallData; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;<span class="hljs-built_in"><span class="hljs-built_in">request</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;responder = stub_-&gt;AsyncSayHello(&amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;context, <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>, &amp;cq_); <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;responder-&gt;Finish(&amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;reply, &amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;status, (void*)<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>); }</code> </pre><br><p>  Les structures RPCCallData g√©n√©r√©es, comme dans le cas du serveur, sont finalement h√©rit√©es de la classe ClientResponder.  Par cons√©quent, la cr√©ation d'un objet de la structure g√©n√©r√©e conduit √† la cr√©ation d'un r√©pondeur.  Apr√®s avoir cr√©√© le r√©pondeur, le RPC est appel√© et le r√©pondeur est associ√© √† l'√©v√©nement de r√©ception d'une r√©ponse du serveur.  En termes de code client, un appel RPC ressemble √† ceci: </p><br><pre> <code class="hljs vbscript">void ToSayHello() { PingRequest <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.set_name(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.set_message(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); pingPongSrv.SayHello(<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>); }</code> </pre><br><p>  Contrairement √† la classe de serveur QpingServerService g√©n√©r√©e, la classe QpingClientService h√©rite de deux classes de mod√®le: ConnectivityFeatures et MonitorFeatures. </p><br><p>  La classe ConnectivityFeatures est responsable de l'√©tat de la connexion client-serveur et fournit trois fonctions √† utiliser: grpc_connect (), grpc_disconnect (), grpc_reconnect ().  La fonction grpc_disconnect () supprime simplement toutes les structures de donn√©es responsables de l'interaction avec le serveur.  L'appel √† grpc_connect est r√©duit aux appels √† la fonction grpc_connect_ (), qui cr√©e des structures de donn√©es de contr√¥le: </p><br><pre> <code class="hljs php">void grpc_connect_() { channel_ = grpc::CreateChannel(target_, creds_); stub_ = GRPCService::NewStub(channel_); channelFeatures_ = std::make_unique&lt;ChannelFeatures&gt;(channel_); channelFeatures_-&gt;checkChannelState(); }</code> </pre><br><p>  La classe ChannelFeatures surveille l'√©tat de la communication <em>channel_</em> channel avec le serveur.  La classe ConnectivityFeatures encapsule un objet de la classe ChannelFeatures et impl√©mente les fonctions abstraites channelState (), checkChannelState () et connected () √† l'aide de cet objet.  La fonction channelState () renvoie le dernier √©tat observ√© du canal de communication avec le serveur.  En fait, la fonction checkChannelState () renvoie l'√©tat actuel du canal.  La fonction connected () renvoie le signe du client se connectant au serveur. <br></p><br><p>  La classe MonitorFeatures est responsable de la r√©ception et du traitement des √©v√©nements du serveur et fournit la fonction CheckCQ () √† utiliser: </p><br><pre> <code class="hljs ruby">bool CheckCQ() { auto service<span class="hljs-number"><span class="hljs-number">_</span></span> = dynamic_cast&lt; SERVICE* &gt;(this); <span class="hljs-regexp"><span class="hljs-regexp">//connection</span></span> state auto old_state = conn<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;channelState(); auto new_state = conn<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;checkChannelState(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (old_state != new_state) service-&gt;*channelStateChangedSignal<span class="hljs-number"><span class="hljs-number">_</span></span>(old_state, new_state); <span class="hljs-regexp"><span class="hljs-regexp">//end</span></span> of connection state void* tag; bool ok = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; grpc::CompletionQueue::NextStatus st; st = cq<span class="hljs-number"><span class="hljs-number">_</span></span>.AsyncNext(&amp;tag, &amp;ok, deadlineFromMSec(<span class="hljs-number"><span class="hljs-number">100</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((st == grpc::CompletionQueue::SHUTDOWN) <span class="hljs-params"><span class="hljs-params">||</span></span> (st == grpc::CompletionQueue::TIMEOUT)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; (AbstractCallData&lt; SERVICE &gt;*)(tag)-&gt;cqActions(service<span class="hljs-number"><span class="hljs-number">_</span></span>, ok); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  La structure du code est la m√™me que dans le cas du serveur.  Contrairement au serveur, un bloc de code responsable du traitement de l'√©tat actuel est ajout√© au client.  Si l'√©tat du canal de communication a chang√©, le signal channelStateChangedSignal_ () est appel√©.  Dans tous les services g√©n√©r√©s, c'est un signal: <br><br></p><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelStateChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  De plus, contrairement au serveur, la fonction AsyncNext () est utilis√©e ici au lieu de Next ().  Cela a √©t√© fait pour plusieurs raisons.  Premi√®rement, lors de l'utilisation d'AsyncNext (), le code client a la possibilit√© de conna√Ætre le changement d'√©tat du canal de communication.  Deuxi√®mement, lorsque vous utilisez AsyncNext (), il est possible d'appeler divers RPC dans le code client autant de fois que n√©cessaire.  L'utilisation de la fonction Next () dans ce cas bloquera le thread jusqu'√† ce qu'un √©v√©nement soit re√ßu de la file d'attente et, par cons√©quent, perdra les deux fonctionnalit√©s d√©crites. <br><br><p>  Apr√®s avoir re√ßu l'√©v√©nement de la file d'attente, comme dans le cas du serveur, la fonction cqReaction (), d√©finie dans la classe ClientCallData, est appel√©e: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cqActions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RPC::Service* service, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;RPCCallData*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* tag = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(response); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;processEvent(tag, ok)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; service-&gt;*func_( response ); }</code> </pre><br><p>  Comme avec le serveur, la fonction processEvent () traite la balise et le drapeau ok et renvoie toujours true.  Comme dans le cas du serveur, apr√®s traitement de l'√©v√©nement, le signal du service g√©n√©r√© doit √™tre appel√©.  Cependant, il existe deux diff√©rences importantes par rapport √† la fonction serveur du m√™me nom.  La premi√®re diff√©rence est que les r√©pondeurs ne sont pas cr√©√©s dans cette fonction.  La cr√©ation de r√©pondeurs, comme indiqu√© ci-dessus, se produit lorsque le RPC est appel√©.  La deuxi√®me diff√©rence est que les r√©pondeurs ne sont pas supprim√©s dans cette fonction.  L'absence de destitution des intervenants se fait pour deux raisons.  Tout d'abord, le code client peut utiliser des pointeurs pour g√©n√©rer des structures RPCCallData √† leurs propres fins.  La suppression de contenu par ce pointeur, cach√© du code client, peut entra√Æner des cons√©quences d√©sagr√©ables.  Deuxi√®mement, la suppression du r√©pondeur entra√Ænera le fait qu'aucun signal contenant des donn√©es ne sera g√©n√©r√©.  Par cons√©quent, le code client ne recevra pas le dernier message du serveur.  Parmi plusieurs alternatives pour r√©soudre les probl√®mes indiqu√©s, la d√©cision a √©t√© prise de d√©placer la suppression du r√©pondeur (structures g√©n√©r√©es) vers le code client.  Ainsi, les fonctions de gestionnaire de signaux (slots) doivent contenir le code suivant: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResponseHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RPCCallData* response)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response-&gt;CouldBeDeleted()) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> response; <span class="hljs-comment"><span class="hljs-comment">//process response }</span></span></code> </pre><br><p>  L'absence de suppression du r√©pondeur dans le code client entra√Ænera non seulement une fuite de m√©moire, mais √©galement des probl√®mes √©ventuels avec le canal de communication.  Les gestionnaires de signaux de toutes sortes d'interactions RPC sont impl√©ment√©s dans l'exemple de code. </p><br><h2>  Conclusion </h2><br><p>  En conclusion, nous attirons l'attention sur deux points.  Le premier point est li√© √† l'appel des fonctions CheckCQ () du client et du serveur.  Ils fonctionnent, comme illustr√© ci-dessus, selon un principe: s'il y a un √©v√©nement dans la file d'attente, un signal avec la structure RPCCallData g√©n√©r√©e correspondante est ¬´√©mis¬ª.  Vous pouvez appeler cette fonction manuellement et rechercher (dans le cas d'un client) un √©v√©nement.  Mais au d√©part, l'id√©e √©tait de transf√©rer la totalit√© de la partie r√©seau associ√©e √† gRPC vers un autre thread.  √Ä ces fins, les classes auxiliaires QGrpcSrvMonitor pour le serveur gRPC et QGrpcCliServer pour le client gRPC ont √©t√© √©crites.  Les deux classes fonctionnent sur le m√™me principe: elles cr√©ent un flux s√©par√©, placent le service g√©n√©r√© dans ce flux et appellent p√©riodiquement la fonction CheckCQ () de ce service.  Ainsi, lors de l'utilisation des deux classes auxiliaires, il n'est pas n√©cessaire d'appeler les fonctions CheckCQ () dans le code client.  Les signaux du service g√©n√©r√©, dans ce cas, ¬´proviennent¬ª d'un autre flux.  Des exemples de clients et de serveurs sont impl√©ment√©s √† l'aide de ces classes d'assistance. </p><br><p>  Le deuxi√®me point concerne la majorit√© des d√©veloppeurs qui n'utilisent pas la biblioth√®que Qt dans leur travail.  Les classes et macros Qt dans QgRPC ne sont utilis√©es qu'√† deux endroits: dans les fichiers de service g√©n√©r√©s et dans les fichiers contenant des classes auxiliaires: QGrpcServerMonitor.h et QGrpcClientMonitor.h.  Les fichiers restants avec la biblioth√®que Qt ne sont en aucun cas associ√©s.  Il √©tait pr√©vu d'ajouter un assemblage √† l'aide de cmake et de bloquer certaines directives Qt.  En particulier, la classe QObject et la macro Q_OBJECT.  Mais les mains n‚Äôy sont pas parvenues.  Par cons√©quent, toute suggestion est la bienvenue. </p><br><p>  C‚Äôest tout.  Merci √† tous! </p><br><h2>  Les r√©f√©rences </h2><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©f√©rentiel avec code QgRPC</a> </p></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GRPC asynchrone en C ++</a> </p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420237/">https://habr.com/ru/post/fr420237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420225/index.html">M√©lodie algorithmique infinie bas√©e sur des nombres premiers</a></li>
<li><a href="../fr420227/index.html">Le pr√©sident turc annonce l'interdiction d'importer de l'√©lectronique aux √âtats-Unis</a></li>
<li><a href="../fr420229/index.html">Les enfants des villages peuvent-ils devenir des programmeurs s'ils se trouvent √† proximit√©, ils n'enseignent qu'aux cheminots. Conversation avec le "Cercle"</a></li>
<li><a href="../fr420233/index.html">UE4 | √âquipement pour multijoueur # 5 | Transfert d'informations entre le serveur et le client</a></li>
<li><a href="../fr420235/index.html">Zenject: comment un conteneur IoC peut tuer l'injection de d√©pendance sur votre projet</a></li>
<li><a href="../fr420239/index.html">D√©veloppement mobile. Swift: le myst√®re des protocoles</a></li>
<li><a href="../fr420243/index.html">Philanthropie r√©volutionnaire: projets de perc√©e humanitaire</a></li>
<li><a href="../fr420245/index.html">Comment emp√™cher le d√©passement de m√©moire lors de l'utilisation de collections Java</a></li>
<li><a href="../fr420251/index.html">Apple affirme que le complexe du si√®ge social de l'entreprise ne co√ªte que 200 $</a></li>
<li><a href="../fr420253/index.html">Comment les API bancaires ouvertes changent le monde financier</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>