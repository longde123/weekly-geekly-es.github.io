<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚥 🕺 🌬️ Kami menulis strategi kami untuk pengguliran virtual dari Angular CDK 🚨 👦🏾 🈁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai 


 Di CDK Angular, gulir virtual muncul di versi ketujuh. 


 Ini berfungsi dengan baik ketika ukuran setiap elemen adalah sama - dan tepat di lu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menulis strategi kami untuk pengguliran virtual dari Angular CDK</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/484168/"><p>  Hai </p><br><p>  Di CDK Angular, <a href="https://material.angular.io/cdk/scrolling/overview">gulir virtual muncul</a> di versi ketujuh. </p><br><p> Ini berfungsi dengan baik ketika ukuran setiap elemen adalah sama - dan tepat di luar kotak.  Kami cukup mengatur ukuran dalam piksel dan menunjukkan elemen wadah yang harus digulir, apakah akan melakukannya dengan lancar, dan kami juga dapat berlangganan indeks elemen saat ini.  Namun, bagaimana jika ukuran elemen berubah?  Untuk ini, antarmuka <a href=""><code>VirtualScrollStrategy</code></a> disediakan dalam CDK, dengan mengimplementasikan yang akan kami ajarkan gulir untuk bekerja dengan daftar kami. </p><br><p>  Dalam kasus saya, perlu membuat kalender untuk presentasi seluler, yang dapat digulir terus menerus, dan jumlah minggu dalam sebulan selalu berbeda.  Mari kita coba mencari tahu apa strategi gulir virtual dan menulis sendiri. </p><br><p><img src="https://habrastorage.org/webt/g9/7b/yo/g97byoqd51-wu9jd8o27awx0-bk.png" alt="gambar"></p><a name="habracut"></a><br><h2 id="raschet-razmerov">  Perhitungan ukuran </h2><br><p>  Seperti yang Anda tahu, kalender diulang setiap 28 tahun. </p><br><p>  Hal ini dilakukan jika Anda tidak memperhitungkan bahwa tahun itu bukan tahun kabisat jika dibagi dengan 100, tetapi tidak oleh 400. Dalam kasus kami, kami tidak perlu bertahun-tahun sebelum 1900 dan setelah 2100. Untuk Januari jatuh pada hari Senin, kami akan mulai dari tahun 1900 untuk akun yang rata dan kami akan menarik 196 tahun.  Dengan demikian, dalam kalender kita akan ada 7 siklus berulang.  Tidak adanya tanggal 29 Februari 1900 tidak akan merugikan, karena itu akan menjadi hari Kamis. </p><br><div style="text-align:center;"><img width="300" src="https://habrastorage.org/webt/ss/rr/oq/ssrroq2ub8w57ihutm6vjo1agou.gif"></div><br><p>  Perhitungan akan dilakukan selama gulir, sehingga semakin sederhana perhitungan, semakin tinggi kinerjanya.  Untuk melakukan ini, kami akan membuat loop konstan, yang akan terdiri dari 28 array dari 12 angka, yang bertanggung jawab atas ketinggian setiap bulan: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCycle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">label: number, week: number</span></span></span><span class="hljs-function">): ReadonlyArray&lt;ReadonlyArray&lt;number&gt;&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Array.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>({length: <span class="hljs-number"><span class="hljs-number">28</span></span>}, (_, i) =&gt; Array.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>( {length: <span class="hljs-number"><span class="hljs-number">12</span></span>}, (_, month) =&gt; label + weekCount(i, month) * week, ), ); }</code> </pre> <br><p>  Pada input, fungsi ini menerima ketinggian judul bulan dan tinggi satu minggu (masing-masing 64 dan 48 piksel, untuk gif di atas).  Jumlah minggu dalam sebulan akan membantu kami menghitung fungsi sederhana seperti itu: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">weekCount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">year: number, month: number</span></span></span><span class="hljs-function">): number</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> firstOfMonth = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(year + STARTING_YEAR, month, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lastOfMonth = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(year + STARTING_YEAR, month + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> days = lastOfMonth.getDate() + (firstOfMonth.getDay() || <span class="hljs-number"><span class="hljs-number">7</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.ceil(days / <span class="hljs-number"><span class="hljs-number">7</span></span>); }</code> </pre> <br><p>  Hasilnya disimpan dalam konstanta konstan <code>const CYCLE = getCycle(64, 48);</code>  . </p><br><p>  Kami akan menulis fungsi yang memungkinkan Anda menghitung ketinggian berdasarkan tahun dan bulan di dalam siklus: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceCycle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lastYear: number = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">28</span></span></span></span><span class="hljs-function"><span class="hljs-params">, lastMonth: number = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">12</span></span></span></span></span><span class="hljs-function">): number</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CYCLE.reduce( (total, year, yearIndex) =&gt; yearIndex &lt;= lastYear ? total + year.reduce( (sum, month, monthIndex) =&gt; yearIndex &lt; lastYear || (yearIndex === lastYear &amp;&amp; monthIndex &lt; lastMonth) ? sum + month : sum, <span class="hljs-number"><span class="hljs-number">0</span></span>, ) : total, <span class="hljs-number"><span class="hljs-number">0</span></span>, ); }</code> </pre> <br><p>  Dengan memanggil fungsi ini tanpa argumen, kita mendapatkan ukuran satu siklus, dan di masa depan kita dapat menemukan indentasi dari atas wadah untuk setiap bulan atau tahun apa pun dari jangkauan kita. </p><br><h2 id="virtualscrollstrategy">  Strategi VirtualScroll </h2><br><p>  Anda dapat mengirimkan strategi Anda ke gulir virtual menggunakan token <br>  <code>VIRTUAL_SCROLL_STRATEGY</code> : </p><br><pre> <code class="cs hljs">{ provide: VIRTUAL_SCROLL_STRATEGY, useClass: MobileCalendarStrategy, },</code> </pre> <br><p>  Kelas kami harus mengimplementasikan antarmuka <code>VirtualScrollStrategy</code> : </p><br><pre> <code class="cs hljs">export <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">VirtualScrollStrategy</span></span> { scrolledIndexChange: Observable&lt;number&gt;; attach(viewport: CdkVirtualScrollViewport): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; detach(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; onContentScrolled(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; onDataLengthChanged(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; onContentRendered(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; onRenderedOffsetChanged(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; scrollToIndex(index: number, behavior: ScrollBehavior): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; }</code> </pre> <br><p>  Fungsi <code>attach</code> dan <code>detach</code> bertanggung jawab untuk menginisialisasi dan mematikan.  Metode <code>onContentScrolled</code> paling penting bagi kami dipanggil setiap kali pengguna menggulir wadah (debounce melalui <code>requestAnimationFrame</code> digunakan secara internal untuk menghindari panggilan yang tidak perlu). </p><br><p>  <code>onDataLengthChanged</code> dipanggil ketika jumlah elemen dalam <code>onDataLengthChanged</code> telah berubah - dalam kasus kami ini tidak akan pernah terjadi.  Sebagai aturan, dalam situasi seperti itu, perlu untuk menghitung tinggi total dan elemen yang saat ini ditampilkan, kira-kira sama dengan apa yang perlu dilakukan pada fungsi <code>attach</code> . </p><br><p>  <code>onContentRendered</code> dan <code>onRenderedOffsetChanged</code> dipanggil saat bagian yang ditampilkan dari elemen berubah dan lekukan ke perubahan elemen pertama.  <code>CdkVirtualScrollViewport</code> mengakses metode ini ketika diberikan serangkaian item yang ditampilkan dan diindentasikan ke yang pertama, secara berurutan.  Kami tidak memerlukan ini, karena tidak perlu memanggil metode <code>CdkVirtualScrollViewport</code> tangan.  Jika Anda membutuhkannya, maka di dalam <code>onContentRendered</code> Anda dapat menghitung indentasi baru, dan di <code>onRenderedOffsetChanged</code> - sebaliknya, rentang elemen yang terlihat untuk indentasi yang dihasilkan. </p><br><p>  Metode penting kedua bagi kami - <code>scrollToIndex</code> - memungkinkan Anda untuk menggulir wadah ke elemen yang diinginkan, dan sebaliknya - <code>scrolledIndexChange</code> - akan memungkinkan untuk melacak elemen yang terlihat saat ini. </p><br><p>  Untuk memulainya, kita akan membuat semua metode sederhana, dan kemudian mempertimbangkan kode utama: </p><br><pre> <code class="cs hljs">export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MobileCalendarStrategy</span></span> <span class="hljs-title"><span class="hljs-title">implements</span></span> <span class="hljs-title"><span class="hljs-title">VirtualScrollStrategy</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> index$ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject&lt;number&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> viewport: CdkVirtualScrollViewport | <span class="hljs-literal"><span class="hljs-literal">null</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; scrolledIndexChange = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.index$.pipe(distinctUntilChanged()); attach(viewport: CdkVirtualScrollViewport) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport = viewport; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport.setTotalContentSize(CYCLE_HEIGHT * <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateRenderedRange(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport); } detach() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.index$.complete(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } onContentScrolled() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateRenderedRange(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport); } } scrollToIndex(index: number, behavior: ScrollBehavior): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport.scrollToOffset(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getOffsetForIndex(index), behavior); } } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Untuk bekerja dengan scroll, kita harus bisa mendapatkan indeks suatu elemen dengan indentasi dan sebaliknya indentasi dengan index.  Fungsi <code>reduceCycle</code> kami tulis cocok untuk tugas pertama: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOffsetForIndex</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index: number</span></span></span><span class="hljs-function">): number</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> month = index % <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> year = (index - month) / <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.computeHeight(year, month); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeHeight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">year: number, month: number</span></span></span><span class="hljs-function">): number</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remainder = year % <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remainderHeight = reduceCycle(remainder, month); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fullCycles = (year - remainder) / <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fullCyclesHeight = fullCycles * CYCLE_HEIGHT; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fullCyclesHeight + remainderHeight; }</code> </pre> <br><p>  Artinya, untuk mendapatkan ketinggian berdasarkan indeks, kami menemukan berapa banyak siklus 28 tahun penuh yang sesuai dengan tanggal saat ini, dan kemudian kami menjumlahkan array kami hingga bulan yang ditentukan.  Operasi sebaliknya agak lebih rumit: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIndexForOffset</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">offset: number</span></span></span><span class="hljs-function">): number</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remainder = offset % CYCLE_HEIGHT; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> years = ((offset - remainder) / CYCLE_HEIGHT) * <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> year = <span class="hljs-number"><span class="hljs-number">0</span></span>; year &lt; CYCLE.length; year++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> month = <span class="hljs-number"><span class="hljs-number">0</span></span>; month &lt; CYCLE[year].length; month++) { accumulator += CYCLE[year][month]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (accumulator - CYCLE[year][month] / <span class="hljs-number"><span class="hljs-number">2</span></span> &gt; remainder) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.max((years + year) * MONTHS_IN_YEAR + month, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">196</span></span>; }</code> </pre> <br><p>  Saat kami mendapatkan tinggi total dari siklus 28 tahun penuh, kami akan mengulangi susunan, mengumpulkan tinggi total semua bulan hingga melebihi indent yang diinginkan.  Pada saat yang sama, kami akan memeriksa untuk melebihi setengah tinggi setiap bulan ( <code>CYCLE[year][month] / 2</code> ) untuk menemukan bukan hanya bulan yang terlihat tertinggi, tetapi yang paling dekat dengan batas atas.  Ini akan diperlukan di masa depan untuk memuntir yang lancar di awal bulan setelah selesainya gulungan. </p><br><p>  Tetap menulis fungsi paling penting yang bertanggung jawab untuk merender elemen-elemen wilayah yang terlihat: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateRenderedRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">viewport: CdkVirtualScrollViewport</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset = viewport.measureScrollOffset(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> viewportSize = viewport.getViewportSize(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {start, end} = viewport.getRenderedRange(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataLength = viewport.getDataLength(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newRange = {start, end}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> firstVisibleIndex = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getIndexForOffset(offset); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> startBuffer = offset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getOffsetForIndex(start); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startBuffer &lt; BUFFER &amp;&amp; start !== <span class="hljs-number"><span class="hljs-number">0</span></span>) { newRange.start = Math.max(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getIndexForOffset(offset - BUFFER * <span class="hljs-number"><span class="hljs-number">2</span></span>)); newRange.end = Math.min( dataLength, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getIndexForOffset(offset + viewportSize + BUFFER), ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> endBuffer = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getOffsetForIndex(end) - offset - viewportSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endBuffer &lt; BUFFER &amp;&amp; end !== dataLength) { newRange.start = Math.max(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getIndexForOffset(offset - BUFFER)); newRange.end = Math.min( dataLength, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getIndexForOffset(offset + viewportSize + BUFFER * <span class="hljs-number"><span class="hljs-number">2</span></span>), ); } } viewport.setRenderedRange(newRange); viewport.setRenderedContentOffset(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getOffsetForIndex(newRange.start)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.index$.next(firstVisibleIndex); }</code> </pre> <br><p>  Mari kita pertimbangkan segalanya secara berurutan. </p><br><p>  Kami meminta <code>CdkVirtualScrollViewport</code> indentasi saat ini, ukuran wadah, kisaran saat ini ditampilkan, dan jumlah item.  Kemudian kita menemukan elemen yang terlihat pertama dan indentasi pada elemen yang diberikan pertama kali. </p><br><p>  Setelah itu, kita perlu memahami cara mengubah rentang elemen saat ini dan membuat inden ke yang pertama, sehingga gulir virtual memuat elemen dengan lancar dan tidak bergerak ketika menghitung ulang ketinggian.  Untuk melakukan ini, kita memiliki konstanta <code>BUFFER</code> , yang <code>BUFFER</code> berapa banyak piksel naik dan turun dari area yang terlihat kita terus menggambar elemen.  Dalam kasus saya, saya menggunakan 500px.  Jika indentasi atas lebih kecil dari buffer dan ada lebih banyak elemen di atas, kami akan mengubah rentang dengan menambahkan elemen yang cukup di atas untuk menggandakan buffer.  Kami juga menyesuaikan akhir kisaran.  Karena kita gulir ke atas - satu buffer sudah cukup di bagian bawah.  Hal yang sama, tetapi dalam arah yang berlawanan kami lakukan saat menggulir ke bawah. </p><br><p>  Kemudian kami menetapkan <code>CdkVirtualScrollViewport</code> rentang baru dan mempertimbangkan indentasi untuk elemen pertama.  Bagikan indeks yang terlihat saat ini. </p><br><h2 id="ispolzovanie">  Gunakan </h2><br><p>  Strategi kami siap.  Tambahkan ke penyedia komponen, seperti yang ditunjukkan di atas, dan gunakan <code>CdkVirtualScrollViewport</code> dalam templat: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cdk-virtual-scroll-viewport</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">scrolledIndexChange</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"activeMonth = $event"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">section</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cdkVirtualFor</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"let month of months; templateCacheSize: 10"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>{{month.name}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">our-calendar</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">month</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"month"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">our-calendar</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">section</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cdk-virtual-scroll-viewport</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Tetap menyadari perputaran yang lancar ke bulan berikutnya di akhir gulungan.  Ada nuansa. </p><br><p>  Faktanya adalah bahwa bergulir di perangkat seluler berlanjut setelah jari melepaskan permukaan.  Oleh karena itu, akan sulit bagi kita untuk memahami saat ketika perlu untuk menyelaraskan bulan saat ini.  Untuk ini kami menggunakan RxJs.  <code>touchstart</code> acara <code>touchstart</code> dan menunggu <code>touchend</code> berikutnya.  Setelah onsetnya, kami menggunakan operator balapan untuk mengetahui apakah gulir berlanjut, atau jika jari dilepaskan tanpa akselerasi.  Jika tidak ada peristiwa gulir yang terjadi selama periode <code>SCROLL_DEBOUNCE_TIME</code> , maka kami menyelaraskan bulan ini.  Kalau tidak, kita tunggu sampai sisa gulir berhenti.  Dalam hal ini, Anda perlu menambahkan <code>takeUntil(touchstart$)</code> , karena gulir inersia dapat dihentikan dengan sentuhan baru dan kemudian seluruh aliran akan kembali ke awal: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> touchstart$ = touchStartFrom(monthsScrollRef.elementRef.nativeElement); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> touchend$ = touchEndFrom(monthsScrollRef.elementRef.nativeElement); <span class="hljs-comment"><span class="hljs-comment">// Smooth scroll to closest month after scrolling is done touchstart$ .pipe( switchMap(() =&gt; touchend$), switchMap(() =&gt; race( monthsScrollRef.elementScrolled(), timer(SCROLL_DEBOUNCE_TIME), ).pipe( debounceTime(SCROLL_DEBOUNCE_TIME * 2), take(1), takeUntil(touchstart$), ), ), takeUntil(this.destroy$), ) .subscribe(() =&gt; { monthsScrollRef.scrollToIndex(this.activeMonth, 'smooth'); });</span></span></code> </pre> <br><p>  Di sini perlu dicatat bahwa untuk menggulir dengan mulus <code>scrollToIndex</code> di CDK Angular implementasi asli digunakan, dan itu tidak berfungsi di Safari.  Anda dapat memperbaikinya dengan menulis gulir halus Anda melalui <code>requestAnimationFrame</code> di dalam strategi yang kami tulis dalam metode <code>scrollToIndex</code> . </p><br><h2 id="vyvod">  Kesimpulan </h2><br><p>  Berkat DI dan kehati-hatian dari tim Angular, kami dapat secara fleksibel mengkonfigurasi gulir virtual untuk diri kami sendiri.  Pada pandangan pertama, menerapkan scroll virtual untuk elemen dengan ketinggian yang bervariasi sepertinya tugas yang menakutkan. </p><br><p>  Namun, ketika dimungkinkan untuk menghitung ketinggian setiap elemen, menulis strategi Anda ternyata cukup sederhana.  Yang terpenting adalah perhitungan ini dilakukan dengan cepat, karena akan sering dipanggil.  Jika Anda perlu menampilkan sejumlah besar kartu, yang mungkin ada atau tidaknya elemen yang memengaruhi ketinggiannya, pertimbangkan algoritma yang efektif untuk mendapatkan tinggi dan jangan takut untuk menulis strategi Anda. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484168/">https://habr.com/ru/post/id484168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484152/index.html">Kontroler PAC Kecepatan Tinggi WISE-5580</a></li>
<li><a href="../id484154/index.html">Metode untuk memecahkan sistem persamaan diophantine</a></li>
<li><a href="../id484160/index.html">Bakat Elusif: Rusia Kehilangan Profesional TI Terbaik</a></li>
<li><a href="../id484164/index.html">Sejarah buku dan masa depan perpustakaan</a></li>
<li><a href="../id484166/index.html">VVVVVV ??? VVVVVV !!! :)</a></li>
<li><a href="../id484170/index.html">Perbarui Titik Periksa dari R77.30 hingga 80.20</a></li>
<li><a href="../id484172/index.html">Integrasi berkelanjutan di Unity: cara mengurangi waktu perakitan dan menghemat sumber daya + payline sebagai hadiah</a></li>
<li><a href="../id484174/index.html">Castle minum dalam kondisi "ekstrim" atau bagaimana kami mengambil bagian dalam acara "DOZOR"</a></li>
<li><a href="../id484176/index.html">Menerapkan Template Status dalam Persatuan</a></li>
<li><a href="../id484178/index.html">Saklar Ethernet Cerdas untuk Planet Bumi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>