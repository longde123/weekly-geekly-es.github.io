<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏏 👩🏻‍🤝‍👨🏾 🌆 Registro de eventos com Kafka 🚣🏻 🕹️ 🏹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! 

 Descobrimos as últimas reservas do livro " Apache Kafka. Processamento de fluxo e análise de dados " e o enviamos à pré-impressão. Além d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Registro de eventos com Kafka</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/424739/"> Olá Habr! <br><br>  Descobrimos as últimas reservas do livro " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apache Kafka. Processamento de fluxo e análise de dados</a> " e o enviamos à pré-impressão.  Além disso, recebemos um contrato para o livro " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kafka Streams in Action</a> " e começamos a traduzi-lo literalmente na próxima semana. <br><br><img src="https://habrastorage.org/webt/re/29/51/re2951jsut-yre1r79xmmt4ibdy.jpeg"><br><br>  Para mostrar o caso interessante do uso da biblioteca Kafka Streams, decidimos traduzir o artigo sobre o paradigma Event Sourcing em Kafka do próprio Adam Worski, cujo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> sobre o idioma Scala foi publicado há duas semanas.  É ainda mais interessante que a opinião de Adam Worski não seja inegável: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , por exemplo, argumenta-se que esse paradigma definitivamente não é adequado para Kafka.  Ainda mais memorável, esperamos, temos a impressão do artigo. <br><br>  O termo "Event Sourcing" é traduzido como "Event Logging", tanto em nossa publicação de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arquitetura Limpa, de</a> Robert Martin, quanto neste artigo.  Se alguém estiver impressionado com a tradução de "eventos de bombeamento", informe-me. <br><a name="habracut"></a><br>  Criando um sistema que fornece registro de eventos (fonte de eventos), mais cedo ou mais tarde nos deparamos com o problema de persistência (persistência) - e aqui temos algumas opções.  Em primeiro lugar, existe o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">EventStore</a> , uma implementação madura endurecida em batalha.  Como alternativa, você pode usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">akka-persistence</a> para aproveitar ao máximo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a</a> escalabilidade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do Cassandra</a> , além de confiar no desempenho do modelo de ator.  Outra opção é o bom e antigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">banco de dados relacional</a> , em que a abordagem <code>CRUD</code> é combinada com o uso de eventos e o benefício máximo é extraído das transações. <br><br>  Além dessas (e talvez de muitas outras) oportunidades que surgiram graças a várias coisas implementadas recentemente, hoje ficou bastante simples organizar o registro de eventos em cima de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kafka</a> .  Vamos ver como. <br><br>  <b>O que é log de eventos?</b> <br><br>  Existem vários <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">excelentes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">introdutórios</a> sobre esse assunto, portanto vou me limitar à introdução mais concisa.  Ao registrar eventos, não salvamos o estado “atual” das entidades usadas em nosso sistema, mas o fluxo de eventos relacionados a essas entidades.  Cada <i>evento</i> é um <b>fato</b> que descreve uma mudança de estado (já!) Que <b>ocorreu</b> com o objeto.  Como você sabe, os fatos não são discutidos e <b>inalterados</b> . <br><br>  Quando temos um fluxo de tais eventos, o estado atual de uma entidade pode ser esclarecido, minimizando todos os eventos relacionados a ela;  no entanto, lembre-se de que o oposto não é possível - preservando apenas o estado "atual", descartamos muitas informações cronológicas valiosas. <br><br>  O registro de eventos pode <b>coexistir</b> pacificamente com formas mais tradicionais de armazenamento de estado.  Como regra, o sistema processa vários tipos de entidades (por exemplo: usuários, pedidos, mercadorias, ...) e é bem possível que o registro de eventos seja útil apenas para algumas dessas categorias.  É importante notar que aqui não somos confrontados com a escolha de "tudo ou nada";  trata-se apenas do recurso adicional de gerenciamento de estado em nosso aplicativo. <br><br>  <b>Armazenamento de eventos em Kafka</b> <br><br>  O primeiro problema a ser resolvido: como armazenar eventos em Kafka?  Existem três estratégias possíveis: <br><br><ul><li>  Armazene todos os eventos para todos os tipos de entidades em um <b>único tópico</b> (com muitos segmentos) </li><li>  Por tópico por tipo de entidade, ou seja, retiramos todos os eventos relacionados ao usuário em um tópico separado, em um separado - todos relacionados ao produto, etc. </li><li>  Por tópico por essência, ou seja, por um tópico separado para cada usuário específico e nome de cada produto </li></ul><br>  A terceira estratégia (tópico por essência) é praticamente impraticável.  Se, quando cada novo usuário aparecesse no sistema, ele precisasse iniciar um tópico separado, logo o número de tópicos se tornaria ilimitado.  Qualquer agregação nesse caso seria muito difícil, por exemplo, seria difícil indexar todos os usuários em um mecanismo de pesquisa;  você não apenas teria que consumir um grande número de tópicos - mas ainda nem todos eles eram conhecidos antecipadamente. <br><br>  Portanto, resta escolher entre 1 e 2. Ambas as opções têm suas vantagens e desvantagens.  Ter um único tópico facilita a <b>visualização global</b> de todos os eventos.  Por outro lado, destacando o tópico para cada tipo de entidade, você pode dimensionar e segmentar o fluxo de cada entidade individualmente.  A escolha de uma das duas estratégias depende do caso de uso específico. <br><br>  Além disso, você pode implementar as duas estratégias ao mesmo tempo, se tiver espaço de armazenamento adicional: produza tópicos por tipo de entidade a partir de um tópico abrangente. <br><br><img src="https://habrastorage.org/webt/1i/lg/v4/1ilgv4fs1_uoaw6uximo7fy9e7k.png"><br><br>  No restante do artigo, trabalharemos com apenas um tipo de entidade e com um único tópico, embora o material apresentado possa ser facilmente extrapolado e aplicado para trabalhar com muitos tópicos ou tipos de entidade. <br><br>  (EDIT: como observou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Chris Hunt</a> , há <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um excelente artigo de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Martin Kleppman</a> , que examinou em detalhes como distribuir eventos por tópico e segmento). <br><br>  <b>As operações mais simples de armazenamento no paradigma de log de eventos</b> <br><br>  A operação mais simples, que é lógica esperar de um armazenamento que ofereça suporte ao log de eventos, é ler o estado "atual" (minimizado) de uma entidade específica.  Como regra, cada entidade tem um ou outro <code>id</code> .  Conseqüentemente, conhecendo esse <code>id</code> , nosso sistema de armazenamento deve retornar o estado atual do objeto. <br><br>  A verdade, em último recurso, será o log de eventos: o estado atual sempre pode ser deduzido do fluxo de eventos associado a uma entidade específica.  Para isso, o mecanismo de banco de dados precisará de uma função pura (sem efeitos colaterais) que aceite o evento e o estado inicial e retorne o estado alterado: <code>Event = &amp;gt State =&amp;gt State</code> .  Na presença de tal função e do <b>valor do estado inicial, o</b> estado atual é uma <b>convolução do</b> fluxo de eventos (a função de mudança de estado deve estar <b>limpa</b> para que possa ser aplicada livremente repetidamente aos mesmos eventos). <br><br>  Uma implementação simplificada da operação “ler estado atual” no Kafka coleta um fluxo de <b>todos os</b> eventos do tópico, os filtra, deixando apenas eventos com o <code>id</code> fornecido e recolhe usando a função especificada.  Se houver muitos eventos (e com o tempo o número de eventos aumentar apenas), essa operação poderá ficar lenta e consumir muitos recursos.  Mesmo que seu resultado seja armazenado em cache na memória e armazenado no nó de serviço, essas informações ainda precisarão ser recriadas periodicamente, por exemplo, devido a falhas no nó ou devido ao bloqueio dos dados do cache. <br><br><img src="https://habrastorage.org/webt/r5/te/aa/r5teaa64otzjedcvs0g1snt9lj8.png"><br><br>  Portanto, é necessária uma maneira mais racional.  É aqui que os kafka-streams e os repositórios de estados são úteis.  Os aplicativos Kafka-streams são executados em um cluster inteiro de nós que consomem certos tópicos juntos.  Cada nó recebe uma série de segmentos de tópicos consumidos, assim como o consumidor Kafka comum.  No entanto, o kafka-streams fornece operações de dados de nível superior que facilitam a criação de fluxos derivados. <br><br>  Uma dessas operações em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">kafka-streams</a> é a convolução de um fluxo no armazenamento local.  Cada armazenamento local contém dados apenas dos segmentos que são consumidos por um determinado nó.  Fora da caixa, duas implementações de armazenamento local estão disponíveis: <i>na RAM</i> e com base no <i>RocksDB</i> . <br><br>  Voltando ao tópico do registro de eventos, observamos que é possível reduzir o fluxo de eventos no <b>armazenamento de estado</b> mantendo no nó local o "estado atual" de cada entidade dos segmentos designados ao nó.  Se usarmos a implementação do armazenamento de estado com base no RocksDB, quantas entidades podemos rastrear em um único nó depende apenas da quantidade de espaço em disco. <br><br>  Veja como é a convolução de eventos no armazenamento local ao usar a API Java (serde significa "serializador / desserializador"): <br><br><pre> <code class="java hljs">KStreamBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KStreamBuilder(); builder.stream(keySerde, valueSerde, <span class="hljs-string"><span class="hljs-string">"my_entity_events"</span></span>) .groupByKey(keySerde, valueSerde) <span class="hljs-comment"><span class="hljs-comment">//  :     .reduce((currentState, event) -&gt; ..., "my_entity_store"); .toStream(); //     return builder;</span></span></code> </pre> <br>  Um exemplo completo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de processamento de pedidos com base em microsserviços</a> está disponível no site da Confluent. <br><br>  (EDIT: como observado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sergei Egorov</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nikita Salnikov</a> no Twitter, para um sistema com log de eventos, você provavelmente precisará alterar as configurações padrão de armazenamento de dados em Kafka para que nenhum tempo ou tamanho limite funcione e, opcionalmente, opcionalmente , habilite a compactação de dados.) <br><br>  <b>Exibir status atual</b> <br><br>  Criamos um repositório de estados no qual estão localizados os estados atuais de todas as entidades provenientes de segmentos atribuídos ao nó, mas como solicitar esse repositório agora?  Se a solicitação é local (ou seja, vem do mesmo nó em que o repositório está localizado), tudo é bem simples: <br><br><pre> <code class="java hljs">streams .store(<span class="hljs-string"><span class="hljs-string">"my_entity_store"</span></span>, QueryableStoreTypes.keyValueStore()); .get(entityId);</code> </pre> <br>  Mas e se quisermos solicitar dados localizados em outro nó?  E como descobrir o que é esse nó?  Aqui, outro recurso recentemente introduzido no Kafka é útil: <b>consultas interativas</b> .  Com a ajuda deles, você pode acessar os metadados Kafka e descobrir qual nó processa o segmento de tópico com o <code>id</code> fornecido (nesse caso, a ferramenta para segmentação de tópicos é usada implicitamente): <br><br><pre> <code class="java hljs">metadataService .streamsMetadataForStoreAndKey(<span class="hljs-string"><span class="hljs-string">"my_entity_store"</span></span>, entityId, keySerde)</code> </pre> <br>  Em seguida, você precisa redirecionar de alguma forma a solicitação para o nó correto.  Observe: a maneira específica pela qual a comunicação entre sites é implementada e gerenciada - seja REST, akka-remote ou qualquer outra - não pertence à área de responsabilidade da kafka-streams.  O Kafka simplesmente fornece acesso ao armazenamento de estado e fornece informações em qual nó o armazenamento de estado está localizado para o <code>id</code> fornecido. <br><br>  <b>Recuperação de desastre</b> <br><br>  As lojas de estado têm uma boa aparência, mas o que acontece quando um nó falha?  Reconstruir um armazenamento local do estado para um determinado segmento também pode ser uma operação cara.  Isso pode provocar atrasos aumentados ou perda de solicitações por um longo tempo, pois os kafka-streams precisarão ser reequilibrados (após adicionar ou remover um nó). <br><br>  É por isso que, por padrão, os armazenamentos de estado de longo prazo são registrados: ou seja, todas as alterações feitas no repositório são gravadas adicionalmente no tópico do registro de alterações.  Este tópico está compactado (porque para cada <code>id</code> , estamos interessados ​​apenas no último registro, sem um histórico de alterações, pois o histórico é armazenado nos próprios eventos) - portanto, é o menor possível.  É por isso que a recriação do armazenamento em outro nó pode ocorrer muito mais rapidamente. <br><br>  No entanto, com o reequilíbrio nesse caso, atrasos ainda são possíveis.  Para reduzi-los ainda mais, o kafka-streams oferece a capacidade de armazenar várias <b>réplicas de backup</b> ( <code>num.standby.replicas</code> ) para cada repositório.  Essas réplicas aplicam todas as atualizações recuperadas dos tópicos com os logs de alterações à medida que ficam disponíveis e estão prontas para alternar para o modo principal de armazenamento de estado para um determinado segmento assim que o armazenamento principal atual falhar. <br><br>  <b>Coerência</b> <br><br>  Com as configurações padrão, o Kafka fornece pelo menos uma entrega única.  Ou seja, no caso de uma falha no nó, algumas mensagens podem ser entregues várias vezes.  Por exemplo, é possível que um evento específico seja aplicado duas vezes ao armazenamento de estado se o sistema travar após o armazenamento de estado mudar para o log, mas antes que o deslocamento desse evento específico seja executado.  Talvez isso não cause dificuldades: nossa função de atualização de estado ( <code>Event = &amp;gt State =&amp;gt State</code> ) normalmente pode lidar com essas situações.  No entanto, pode não ser capaz de lidar: nesse caso, as garantias de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">entrega estritamente única</a> fornecidas pela Kafka podem ser usadas.  Essas garantias se aplicam apenas ao ler e escrever tópicos Kafka, mas é o que estamos fazendo aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em segundo plano, todas as entradas nos tópicos Kafka são reduzidas à atualização do log de alterações do armazenamento de estados</a> e à execução de compensações.  Tudo isso pode ser feito <b>na forma de transações</b> . <br><br>  Portanto, se nossa função de atualizar o estado exigir isso, podemos ativar a semântica do processamento de fluxos “entrega estritamente única” usando uma única opção de configuração: <code>processing.guarantee</code> .  Por esse motivo, o desempenho cai, mas nada é em vão. <br><br>  <b>Escuta de evento</b> <br><br>  Agora que abordamos o básico - consultar o "estado atual" e atualizá-lo para cada entidade - e quanto a desencadear <b>efeitos colaterais</b> ?  Em algum momento, isso será necessário, por exemplo, para: <br><br><ul><li>  Enviando e-mails de notificação </li><li>  Indexação de entidade do mecanismo de pesquisa </li><li>  Chamando serviços externos via REST (ou SOAP, CORBA, etc.) </li></ul><br>  Todas essas tarefas são, em um grau ou outro, bloqueadas e relacionadas a operações de E / S (isso é natural para efeitos colaterais), portanto, provavelmente não é uma boa ideia executá-las dentro da estrutura da lógica de atualização de estado: como resultado, a frequência de falhas no loop principal pode aumentar eventos e, em termos de desempenho, haverá um gargalo. <br><br>  Além disso, uma função com lógica de atualização de estado (E <code>Event = &amp;gt State =&amp;gt State</code> ) pode ser executada várias vezes (no caso de falhas ou reinicializações), e na maioria das vezes queremos minimizar o número de casos em que os efeitos colaterais de um evento específico são executados várias vezes. <br><br>  Felizmente, como trabalhamos com tópicos de Kafka, temos uma boa flexibilidade.  No estágio de fluxos, onde o armazenamento de estado é atualizado, os eventos podem ser emitidos inalterados (ou, se necessário, também em uma forma modificada), e o fluxo / tópico resultante (no Kafka esses conceitos são equivalentes) pode ser consumido como você desejar.  Além disso, ele pode ser consumido antes ou depois do estágio de atualização do estado.  Finalmente, podemos controlar como lançamos efeitos colaterais: pelo menos uma vez ou no máximo uma vez.  A primeira opção é fornecida se você executar o deslocamento do evento-tópico consumido somente depois que todos os efeitos colaterais forem concluídos com êxito.  Por outro lado, com o máximo de uma corrida, realizamos mudanças até o início dos efeitos colaterais. <br><br>  Existem várias opções para desencadear efeitos colaterais, eles dependem da situação prática específica.  Antes de tudo, você pode definir o estágio Kafka-streams em que os efeitos colaterais de cada evento são acionados como parte da função de processamento de fluxo. <br>  A configuração de um mecanismo desse tipo é bastante simples, mas essa solução não é flexível quando você precisa lidar com novas tentativas, controlar compensações e compensar compensações por muitos eventos ao mesmo tempo.  Nesses casos mais complexos, pode ser mais apropriado determinar o processamento usando, digamos, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">kafka reativo</a> ou outro mecanismo que consome os tópicos Kafka "diretamente". <br><br>  Também é possível que um evento <b>ative outros eventos</b> - por exemplo, o evento "pedido" pode acionar os eventos "preparação para expedição" e "notificação ao cliente".  Isso também pode ser implementado no estágio kafka-streams. <br><br>  Por fim, se quisermos armazenar eventos ou alguns dados extraídos de eventos em um banco de dados ou mecanismo de pesquisa, digamos, no ElasticSearch ou no PostgreSQL, poderíamos usar o conector <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kafka Connect</a> , que processará para nós todos os detalhes relacionados ao consumo de tópicos. <br><br>  <b>Criando vistas e projeções</b> <br><br>  Normalmente, os requisitos do sistema não se limitam a consultar e processar apenas fluxos de entidade única.  Agregação, combinação de vários fluxos de eventos também deve ser suportada.  Esses fluxos combinados são geralmente chamados de <b>projeções</b> e, quando recolhidos, podem ser usados ​​para criar <b>representações de dados</b> .  É possível implementá-los com o Kafka? <br><br><img src="https://habrastorage.org/webt/yc/r2/jt/ycr2jtvibrdg7wy0lhin1ehwu1y.png"><br><br>  Mais uma vez sim!  Lembre-se de que, em princípio, estamos lidando simplesmente com o tópico Kafka, onde nossos eventos são armazenados;  portanto, temos todo o poder do Kafka Consumer / Producer bruto, do combinador kafka-streams e até do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">KSQL</a> - tudo isso é útil para definir projeções.  Por exemplo, usando kafka-streams, você pode filtrar um fluxo, exibir, agrupar por chave, agregar em janelas temporárias ou de sessão, etc.  no nível do código ou usando o KSQL semelhante ao SQL. <br><br>  Esses fluxos podem ser armazenados e fornecidos para consultas por um longo tempo usando armazenamentos de estado e consultas interativas, assim como fizemos com os fluxos de entidades individuais. <br><br>  <b>O que vem a seguir</b> <br><br>  Para impedir o fluxo infinito de eventos à medida que o sistema se desenvolve, uma opção de compactação, como salvar <b>instantâneos do</b> "estado atual", pode ser útil.  Assim, podemos nos limitar a armazenar apenas alguns instantâneos recentes e os eventos que ocorreram após a sua criação. <br><br>  Embora o Kafka não tenha suporte direto para snapshots (e em alguns outros sistemas operando com o princípio de registrar eventos), você pode definitivamente adicionar esse tipo de funcionalidade, usando alguns dos mecanismos acima, como fluxos, consumidores, lojas de estado, etc. d. <br><br>  <b>Sumário</b> <br><br>  Embora, inicialmente, o Kafka não tenha sido projetado com um olho no paradigma de registro de eventos, na verdade, é um mecanismo de dados de streaming com suporte para <b>replicação de tópicos</b> , segmentação, <b>repositórios de estados</b> e <b>APIs de streaming</b> , e é muito flexível ao mesmo tempo.  Portanto, além do Kafka, você pode implementar facilmente um sistema de registro de eventos.  Além disso, como no contexto de tudo o que acontece, sempre teremos um tópico Kafka, ganharemos flexibilidade adicional, pois podemos trabalhar com APIs de streaming de alto nível ou com consumidores de baixo nível. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt424739/">https://habr.com/ru/post/pt424739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt424729/index.html">Por que o compilador transformou meu loop condicional em um infinito?</a></li>
<li><a href="../pt424731/index.html">Histórico de suporte técnico quente ou Por que o AutoCAD exclui objetos proxy?</a></li>
<li><a href="../pt424733/index.html">Pílula azul STM32F103 como PLC</a></li>
<li><a href="../pt424735/index.html">Como isso funciona, e a psicoterapia conversacional funciona de todo</a></li>
<li><a href="../pt424737/index.html">42º protocolo da vida, o universo e tudo isso: "discurso de despedida"</a></li>
<li><a href="../pt424741/index.html">Pessoal, vamos viver em paz ou sobre o campo Senha ao registrar</a></li>
<li><a href="../pt424745/index.html">A atividade de GosSOPKI aumentou</a></li>
<li><a href="../pt424747/index.html">O lugar onde o som vive</a></li>
<li><a href="../pt424751/index.html">Como o sistema biométrico unificado funciona</a></li>
<li><a href="../pt424753/index.html">O que há de novo no YouTrack 2018.3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>