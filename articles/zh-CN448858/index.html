<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏻 🚁 💩 停止为此使用Ngrx /特效 ⛱️ 👩🏽‍🎨 👧🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="有时，最简单的功能实现最终会带来弊大于利的问题，只会增加其他地方的复杂性。 最终结果是一个没人希望接触的锯齿状架构。 

 翻译笔记 

 这篇文章写于2017年，但与今天有关。 它面向有RxJS和Ngrx经验的人员，或者想在Angular中尝试Redux的人员。 
 这些代码片段是根据当前的RxJ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>停止为此使用Ngrx /特效</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448858/"><img src="https://habrastorage.org/webt/73/82/fl/7382flctc9zmk_xd-mox_6ahrru.jpeg" alt="半身像"><br><br> 有时，最简单的功能实现最终会带来弊大于利的问题，只会增加其他地方的复杂性。 最终结果是一个没人希望接触的锯齿状架构。 <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">翻译笔记</b> <div class="spoiler_text"><p> 这篇文章写于2017年，但与今天有关。 它面向有RxJS和Ngrx经验的人员，或者想在Angular中尝试Redux的人员。 </p><br> 这些代码片段是根据当前的RxJS语法进行更新的，并进行了少许修改以提高可读性和易懂性。 <br></div></div><br><p> Ngrx / store是一个Angular库，有助于包含单个函数的复杂性。 原因之一是ngrx / store包含函数式编程，这限制了可以在函数内部执行的操作，以在函数外部实现更多的合理性。 在ngrx / store中，诸如reducers（以下称为reducers），选择器（以下称为Selector）和RxJS运算符之类的东西都是纯函数。 </p><br><p> 纯函数更易于测试，调试，分析，并行化和组合。 在以下情况下，函数是干净的： </p><br><ul><li> 使用相同的输入，它总是返回相同的输出； </li><li> 没有副作用。 </li></ul><br><p> 副作用是无法避免的，但是它们被隔离在ngrx / store中，因此应用程序的其余部分可能由纯函数组成。 </p><br><h3> 副作用 </h3><br><p> 当用户提交表单时，我们需要在服务器上进行更改。 更改服务器并响应客户端是一个副作用。 可以在组件中处理： </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SAVE_DATA'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data, }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveData(data) <span class="hljs-comment"><span class="hljs-comment">// POST    .pipe(map(res =&gt; this.store.dispatch({ type: 'DATA_SAVED' }))) .subscribe();</span></span></code> </pre> <br><p> 如果我们可以在用户提交表单并在其他地方处理副作用时，就可以在组件内部分派动作（以下简称为动作），那就太好了。 </p><br><p>  Ngrx / effect是用于处理ngrx / store中的副作用的中间件。 它在可观察线程中侦听提交的操作，执行副作用，并立即或异步返回新操作。 返回的动作将传递给减速器。 </p><br><p> 以RxJS方式处理副作用的能力使代码更整洁。 从组件发送初始动作<code>SAVE_DATA</code>之后，您将创建一个效果类来处理其余的动作： </p><br><pre> <code class="javascript hljs">@Effect() saveData$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'SAVE_DATA'</span></span>), pluck(<span class="hljs-string"><span class="hljs-string">'payload'</span></span>), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveData(data)), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'DATA_SAVED'</span></span> })), );</code> </pre><br><p> 这简化了组件的操作，仅在发送操作和订阅可观察的操作之前。 </p><br><h2> 易于滥用Ngrx /效果 </h2><br><p>  Ngrx / effects是一个非常强大的解决方案，因此很容易滥用。 这是Ngrx / effect简化的一些常见ngrx / store反模式： </p><br><h3>  1.重复状态 </h3><br><p> 假设您正在某种多媒体应用程序上工作，并且在状态树中具有以下属性： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface State { <span class="hljs-attr"><span class="hljs-attr">mediaPlaying</span></span>: boolean; audioPlaying: boolean; videoPlaying: boolean; }</code> </pre><br><p> 由于音频是一种媒体，因此只要<code>audioPlaying</code>为true， <code>mediaPlaying</code>也应为true。 所以这是一个问题：“如何在audioPlaying更新时确保mediaPlaying更新？” </p><br><p>  <b>无效答案</b> ：使用Ngrx /特效！ </p><br><pre> <code class="javascript hljs">@Effect() playMediaWithAudio$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'PLAY_AUDIO'</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'PLAY_MEDIA'</span></span> })), );</code> </pre><br><p>  <b>正确的答案是</b> ：如果<code>mediaPlaying</code>的状态完全由状态树的另一部分预测，则这不是真实状态。 这是一个派生状态。 它属于选择器，而不是商店。 </p><br><pre> <code class="javascript hljs">audioPlaying$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-string"><span class="hljs-string">'audioPlaying'</span></span>); videoPlaying$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-string"><span class="hljs-string">'videoPlaying'</span></span>); mediaPlaying$ = combineLatest(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.audioPlaying$, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.videoPlaying$).pipe( map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[audioPlaying, videoPlaying]</span></span></span><span class="hljs-function">) =&gt;</span></span> audioPlaying || videoPlaying), );</code> </pre><br><p> 现在我们的病情可以保持清洁和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">正常化</a> ，并且我们不会将Ngrx /特效用于非副作用。 </p><br><h3>  2.与减速器的连锁动作 </h3><br><p> 想象一下，您在状态树中具有以下属性： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface State { <span class="hljs-attr"><span class="hljs-attr">items</span></span>: { [index: number]: Item }; favoriteItems: number[]; }</code> </pre><br><p> 然后，用户删除该项目。 返回删除请求后，将发送<code>DELETE_ITEM_SUCCESS</code>操作以更新应用程序的状态。 在<code>items</code>缩减器中，单个<code>Item</code>从<code>items</code>对象中删除。 但是，如果此元素标识符位于<code>favoriteItems</code>数组中，则它所引用的元素将不存在。 所以问题是，在发送<code>DELETE_ITEM_SUCCESS</code>操作时，如何确保从<code>favoriteItems</code>删除标识符？ </p><br><p>  <b>无效答案</b> ：使用Ngrx /特效！ </p><br><pre> <code class="javascript hljs">@Effect() removeFavoriteItemId$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'DELETE_ITEM_SUCCESS'</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'REMOVE_FAVORITE_ITEM_ID'</span></span> })), );</code> </pre><br><p> 因此，现在我们将有两个动作一个接一个地发送，两个减速器一个接一个地返回新状态。 </p><br><p>  <b>正确答案</b> ： <code>DELETE_ITEM_SUCCESS</code>可以由<code>items</code> reducer和<code>favoriteItems</code> reducer进行处理。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">favoriteItemsReducer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = initialState, action: Action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'REMOVE_FAVORITE_ITEM'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'DELETE_ITEM_SUCCESS'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemId = action.payload; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> id !== itemId); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre><br><p> 该行动的目标是将发生的情况与状态应如何变化分开。 发生了什么事<code>DELETE_ITEM_SUCCESS</code> 。 减速器的任务是引起状态的相应变化。 </p><br><p> 从<code>favoriteItems</code> <code>Item</code>中删除标识符并不是删除<code>Item</code>副作用。 整个过程是完全同步的，可以由减速器处理。 不需要Ngrx /特效。 </p><br><h3>  3.请求组件数据 </h3><br><p> 您的组件需要从存储中获取数据，但是首先您需要从服务器获取数据。 问题是，如何将数据放入存储中，以便组件可以接收数据？ </p><br><p>  <b>痛苦的方式</b> ：使用Ngrx /特效！ </p><br><p> 在组件中，我们通过发送操作来发起请求： </p><br><pre> <code class="javascript hljs">ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> }); }</code> </pre><br><p> 在效果类中，我们听<code>GET_USERS</code> ： </p><br><pre> <code class="javascript hljs">@Effect getUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span>), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userSelectors.needUsers$), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> needUsers), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), );</code> </pre><br><p> 现在，假设用户认为某条路线的加载时间太长，那么他将从一条路线切换到另一条路线。 为了提高效率并避免加载不必要的数据，我们希望取消此请求。 当组件被销毁时，我们将通过发送操作退订请求： </p><br><pre> <code class="javascript hljs">ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> }); }</code> </pre><br><p> 现在，在effects类中，我们听两种动作： </p><br><pre> <code class="javascript hljs">@Effect getUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span>, <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span>), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userSelectors.needUsers$), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> needUsers), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> action), switchMap( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> action.type === <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>() : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers().pipe(map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users }))), ), );</code> </pre><br><p> 好啊 现在，另一个开发人员添加了一个需要相同HTTP请求的组件（我们不会对其他组件做任何假设）。 组件在相同的位置发送相同的动作。 如果两个组件同时处于活动状态，则第一个组件将发起HTTP请求以对其进行初始化。 当第二个组件初始化时，不会发生任何多余的事情，因为<code>needUsers</code>将为<code>false</code> 。 太好了！ </p><br><p> 然后，当第一个组件被破坏时，它将发送<code>CANCEL_GET_USERS</code> 。 但是第二个组件仍然需要此数据。 我们如何防止请求被取消？ 也许我们将启动所有订阅者的计数器？ 我不会实现这一点，但是我想您理解这一点。 我们开始怀疑有更好的方法来管理这些数据依赖项。 </p><br><p> 现在假设出现了另一个组件，它取决于在<code>users</code>数据出现在存储中之前无法检索的数据。 这可能是用于聊天的Web套接字的连接，有关某些用户的其他信息或其他内容。 我们不知道在向<code>users</code>订阅其他两个组件之前或之后将初始化此组件。 </p><br><p> 对于这种特殊情况，我发现的最佳帮助就是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这篇很棒的文章</a> 。 在他的示例中， <code>callApiY</code>要求<code>callApiX</code>已经完成。 我删除了评论以使其看起来不那么吓人，但请随时阅读原始文章以了解更多信息： </p><br><pre> <code class="javascript hljs">@Effect() actionX$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_X'</span></span>), map(toPayload), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">payload</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api.callApiX(payload).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X_SUCCESS'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data })), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: err })), ), ), ); @Effect() actionY$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_Y'</span></span>), map(toPayload), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> state.someBoolean)), switchMap(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[payload, someBoolean]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callHttpY = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api.callApiY(v).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_SUCCESS'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data, })), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: err, }), ), ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (someBoolean) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callHttpY(payload); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X'</span></span>, payload }).merge( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_X_SUCCESS'</span></span>, <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>), first(), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action.type === <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: <span class="hljs-string"><span class="hljs-string">'Because ACTION_X failed.'</span></span>, }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callHttpY(payload); }), ), ); }), );</code> </pre><br><p> 现在添加一个要求，即当组件不再需要HTTP请求时，应将其取消，这将变得更加复杂。 </p><br><h3><pre>  。  。  。 </pre></h3><br><p> 那么，当RxJS真正使它变得简单时，为什么数据依赖管理存在这么多问题？ </p><br><p> 尽管从技术上来说，来自服务器的数据是一个副作用，但在我看来，Ngrx /效果并不是处理此问题的最佳方法。 </p><br><p> 组件是用户输入/输出接口。 它们显示数据并发送他执行的动作。 加载组件时，它不会发送该用户执行的任何操作。 他想显示数据。 这更像是订阅，而不是副作用。 </p><br><p> 很多时候，您会看到使用动作来启动数据请求的应用程序。 这些应用程序实现了一个特殊的界面，可以通过副作用进行观察。 而且，正如我们所看到的，此界面可能会变得非常不便和麻烦。 订阅，退订和连接可观察的对象要容易得多。 </p><br><h3><pre>  。  。  。 </pre></h3><br><p>  <b>减轻痛苦的方式</b> ：组件将通过可观察的方式订阅数据，从而对数据感兴趣。 </p><br><p> 我们将创建可观察的对象，其中包含必要的HTTP请求。 我们将看到使用纯RxJS而不是通过效果来管理彼此依赖的多个订阅和查询链要容易得多。 </p><br><p> 在服务中创建以下可观察到的内容： </p><br><pre> <code class="javascript hljs">requireUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe( select(selectNeedUser), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">needUsers</span></span></span><span class="hljs-function"> =&gt;</span></span> needUsers), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), finalize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> })), share(), ); users$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsers$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsers)), );</code> </pre><br><p> 对<code>users$</code>订阅将同时发送到<code>requireUsers$</code>和<code>this.store.pipe(select(selectUsers))</code> ，但是仅从<code>this.store.pipe(select(selectUsers))</code>接收数据（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>muteFirst</code></a>实现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>muteFirst</code></a>和固定<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>muteFirst</code></a>经过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">她的测试</a> 。） </p><br><p> 在组件中： </p><br><pre> <code class="javascript hljs">ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.users$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userService.users$; }</code> </pre><br><p> 由于现在可以轻松观察到这种数据依赖关系，因此我们可以使用<code>async</code>管道在模板中进行订阅和退订，并且不再需要发送操作。 如果应用程序留下了最后一个为数据签名的组件的路由，则会取消HTTP请求或关闭Web套接字。 </p><br><p> 数据依赖链可以这样处理： </p><br><pre> <code class="javascript hljs">requireUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe( select(selectNeedUser), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">needUsers</span></span></span><span class="hljs-function"> =&gt;</span></span> needUsers), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), share(), ); users$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsers$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsers)), ); requireUsersExtraData$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.users$.pipe( withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectNeedUsersExtraData))), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[users, needData]</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>(users.length) &amp;&amp; needData), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS_EXTRA_DATA'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS_EXTRA_DATA'</span></span>, users, }), ), share(), ); public usersExtraData$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsersExtraData$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsersExtraData)), );</code> </pre><br><p> 这是上述方法与此方法的平行比较： </p><br><img src="https://habrastorage.org/webt/xd/cb/ho/xdcbhozsjus5vu64eqp9x8nsnuy.png" alt="平行比较"><br><br><p> 使用纯可观察的代码需要更少的代码行，并且自动取消了整个链中对数据的依赖。  （为了使比较更容易理解，我跳过了最初包含的<code>finalize</code>语句，但是即使没有它们，查询也将相应地被取消。） </p><br><img src="https://habrastorage.org/webt/mj/2m/pc/mj2mpclzeric84dwrap4c5fpkqm.jpeg" alt="像鸡尾酒中的樱桃一样的效果"><br><br><h2> 结论 </h2><br><p>  Ngrx /特效是一个很棒的工具！ 但是在使用它之前，请考虑以下问题： </p><br><ul><li> 这真的是副作用吗？ </li><li>  Ngrx / effects是执行此操作的最佳方法吗？ </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN448858/">https://habr.com/ru/post/zh-CN448858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN448842/index.html">霍尼韦尔HAQ空气质量监测仪</a></li>
<li><a href="../zh-CN448846/index.html">在大型公司中实施敏捷时，不要忘记重要的一点</a></li>
<li><a href="../zh-CN448848/index.html">关于从实验数据中删除趋势</a></li>
<li><a href="../zh-CN448854/index.html">船员龙爆炸</a></li>
<li><a href="../zh-CN448856/index.html">Torfon-匿名电话的移动应用程序</a></li>
<li><a href="../zh-CN448860/index.html">Android Studio 3.4发行说明（2019年4月）</a></li>
<li><a href="../zh-CN448866/index.html">从成对（相对）汇率到绝对汇率的转换的详细信息。 错误处理</a></li>
<li><a href="../zh-CN448868/index.html">＃295移动开发人员的有趣材料摘要（4月15日至21日）</a></li>
<li><a href="../zh-CN448870/index.html">Optlib 遗传优化算法在Rust中的实现</a></li>
<li><a href="../zh-CN448872/index.html">对讲产品翻译书</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>