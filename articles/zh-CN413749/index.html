<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏿 👌🏾 👨‍⚖️ 真实项目中的B +树 🎎 ⛹🏼 🤞🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我们将详细研究如何在分布式Apache Ignite数据库中制作B +树。 




 在B树上的H树上已经有几篇文章（ 一本 ， 两本 ），但是它们更可能是理论上的，即使它们包含实现，也无法投入生产 。 因此，有兴趣了解生活中使用的实现。 


 在继续阅读本文之前，建议您先观看Maxi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>真实项目中的B +树</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/413749/"><p> 在本文中，我们将详细研究如何在分布式<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apache Ignite</a>数据库中制作B +树。 <br></p><br><img src="https://habrastorage.org/webt/mv/_t/zg/mv_tzg1o-c96a2ib19cf9umv67u.jpeg"><a name="habracut"></a><br><p> 在B树上的H树上已经有几篇文章（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一本</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两本</a> ），但是它们更可能是理论上的，即使它们包含实现，也无法<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">投入生产</a> 。 因此，有兴趣了解生活中使用的实现。 </p><br><p> 在继续阅读本文之前，建议您先观看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Maxim Babenko</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演讲</a> ，如果您仍然不了解B树的理论含义。 但是我不需要深入了解Java或Apache Ignite项目-我将明确编写细节或将其隐藏在破坏者的下面。 </p><br><p> 阅读Ignite源代码时，我建议您在脑海中跳过方法的参数（方法的含义不是很清楚）并阅读函数的名称-如果事先知道函数的作用，那么阅读函数的主体会容易得多。 </p><br><p> 请注意，我不是Apache Ignite的首席开发人员，可能对代码有误解。 因此，我提出了“据我所知”一词，应该在每句肯定的句子之前在脑海中加上该词。 </p><br><h1 id="zachem-b-derevo-v-apache-ignite"> 为什么在Apache Ignite中使用B +树 </h1><br><p> Apache Ignite是一个内存数据库，但是从2.1版开始，它具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">持久数据存储</a> -一种将数据保存到磁盘的功能<em>（与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">持久数据结构</a>无关）</em> 。 因此，很清楚为什么外部存储器需要一种结构，仍然有必要了解为什么他们不选择其他结构。 </p><br><p> 首先，B +树是B树的优化，其中的值仅存储在叶子中。 在此优化中，更多的关键字适合一个节点，这增加了分支的程度。 因此，没有太多理由使用经典B树。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">B *</a>和B + *-在磁盘上密度更高，但是它们的性能较差，因为 我们从RAM存储数据，性能对我们来说更重要。 </p><br><p> 从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基准</a>来看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LSM树的</a>写入速度较快，但读取速度较慢。 此外，阅读上的损失大于写作上的损失，因此对于一个假设的一般情况，我也会采用B +树。 </p><br><p> 还有一些奇怪的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分形树</a> ，但是，显然，它们仅在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TokuDB</a>中获得专利并实现。 </p><br><p> 就我个人而言，我对为何不可能像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LevelDB</a>这样的现成磁盘后端感兴趣？ 部分答案是PDS支持第三方存储。 </p><br><h1 id="realizaciya-v-krupnuyu-kletku"> 大单元实施 </h1><br><p>最初，GridGain开发了Apache Ignite，但是在放弃开源之前，它以公司的名字命名，因此某些组件名称以<code>Grid</code>开头，而其他组件名称以<code>Ignite</code>开头。 因此<code>GridCursor</code>而是<code>IgniteTree</code> 。 这里没有其他逻辑。 </p><br><p>  Apache Ignite代码是用Java最佳实践模式编写的，每个类都继承一个接口（如果没有）。 从<code>IgniteTree</code>界面开始跳舞。 简而言之，我给出的代码没有javadoc。 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IgniteTree</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">L</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T val)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IgniteCheckedException</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L key, Object x, InvokeClosure&lt;T&gt; c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IgniteCheckedException</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findOne</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L key)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IgniteCheckedException</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GridCursor&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L lower, L upper)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IgniteCheckedException</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GridCursor&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L lower, L upper, Object x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IgniteCheckedException</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IgniteCheckedException</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findLast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IgniteCheckedException</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L key)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IgniteCheckedException</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IgniteCheckedException</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvokeClosure</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable T row)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IgniteCheckedException</span></span>; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newRow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">OperationType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operationType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> OperationType { NOOP, REMOVE, PUT } }</code> </pre> <br><p>  <code>IgniteTree</code>接口描述了一组标准操作。 请注意，进行范围搜索需要您编织列表中的叶子。 奖金支持任意记录操作<code>invoke</code> 。 </p><br><p>  <code>put</code>操作仅接受<code>T</code>类型的一个参数而没有键。 您不会在<code>IgniteTree</code>找到对此的解释，但是答案被隐藏在<code>BPlusTree</code>标头中。 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BPlusTree</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">L</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">L</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataStructure</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IgniteTree</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">L</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre> <br><p> 如您所见，该值继承了键，因此，在放置操作中，键是从该值计算得出的。 这并不限制树的功能。 我的假设是存储集更紧凑。 </p><br><p> 通常，他们通过将垃圾常量附加到值上来使它们脱离地图。 但是，在B +树中， <em>只有键</em>存储在节点中；如果值也存储键，则在叶中<em>仅存</em>储值就足够<em>了</em> 。 如果树是一个集合，那么它会自动证明叶子中只有键，没有垃圾值。 </p><br><p><img src="https://habrastorage.org/webt/gk/5a/mj/gk5amjeohtkej5assnsgyy791p4.png"></p><br><p> 现在让我们看一下元素搜索代码。 </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> g Get. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> IgniteCheckedException If failed. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doFind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Get g)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IgniteCheckedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-comment"><span class="hljs-comment">// Go down with retries. g.init(); switch (findDown(g, g.rootId, 0L, g.rootLvl)) { case RETRY: case RETRY_ROOT: checkInterrupted(); continue; default: return; } } } /** * @param g Get. * @param pageId Page ID. * @param fwdId Expected forward page ID. * @param lvl Level. * @return Result code. * @throws IgniteCheckedException If failed. */ private Result findDown(final Get g, final long pageId, final long fwdId, final int lvl) throws IgniteCheckedException { long page = acquirePage(pageId); try { for (;;) { // Init args. g.pageId = pageId; g.fwdId = fwdId; Result res = read(pageId, page, search, g, lvl, RETRY); switch (res) { case GO_DOWN: case GO_DOWN_X: assert g.pageId != pageId; assert g.fwdId != fwdId || fwdId == 0; // Go down recursively. res = findDown(g, g.pageId, g.fwdId, lvl - 1); switch (res) { case RETRY: checkInterrupted(); continue; // The child page got split, need to reread our page. default: return res; } case NOT_FOUND: assert lvl == 0 : lvl; g.row = null; // Mark not found result. return res; default: return res; } } } finally { if (g.canRelease(pageId, lvl)) releasePage(pageId, page); } }</span></span></code> </pre> <br><p>  B树遍历算法的基础保持不变：它沿树递归地下降到所需的叶子：如果存在该值，则返回结果；如果不存在，则返回<code>null</code> 。 显然，递归是为了方便起见，无论如何，B树并不深。 </p><br><p><img src="https://habrastorage.org/webt/tc/g3/0t/tcg30to_z-6fcrfegjfulubh0gq.jpeg"></p><br><p> 我很惊讶，因为我脑子里有个清晰的安装：递归总是在真实的项目中删除（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java中没有尾递归优化，</a>在其他语言的项目中也可以接受递归）。 但是实际上，B树的高度是以单位为单位的，因为订单块的大小 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>10</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMAIN-31"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMAIN-30" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>10</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ {10} </script>  ，以及订单的数据数 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>40</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMAIN-34"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMAIN-30" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>40</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-2"> 2 ^ {40} </script> 高度将是 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>l</mi><mi>o</mi><mi>g</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>40</mn></mrow></msup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>l</mi><mi>o</mi><mi>g</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>10</mn></mrow></msup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></mrow><mo>=</mo><mn>4</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="29.067ex" height="2.78ex" viewBox="0 -935.7 12515.1 1197.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMATHI-66" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMATHI-72" x="800" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMATHI-61" x="1252" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMATHI-63" x="1781" y="0"></use><g transform="translate(2215,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMATHI-6C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMATHI-6F" x="298" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMATHI-67" x="784" y="0"></use><g transform="translate(1264,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><g transform="translate(2094,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMAIN-34"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMAIN-30" x="500" y="0"></use></g></g><g transform="translate(3402,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g><g transform="translate(6447,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMATHI-6C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMATHI-6F" x="298" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMATHI-67" x="784" y="0"></use><g transform="translate(1264,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><g transform="translate(2094,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMAIN-31"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMAIN-30" x="500" y="0"></use></g></g><g transform="translate(3402,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMAIN-3D" x="10958" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/sberbank/blog/413749/&amp;usg=ALkJrhjjG34wRqPF39djBDUJzWPJMbGtXg#MJMAIN-34" x="12014" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>l</mi><mi>o</mi><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>40</mn></mrow></msup><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></mrow><mrow class="MJX-TeXAtom-ORD"><mi>l</mi><mi>o</mi><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>10</mn></mrow></msup><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></mrow><mo>=</mo><mn>4</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> \ frac {log（2 ^ {40}）} {log（2 ^ {10}）} = 4 </script>  。 </p><br><p>  Apache Ignite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">喜欢并发</a> 。 因此，树支持竞争性修改。 在操作时，一个页面被阻止，但是另一个线程可能会修改树的其余部分，因此需要进行第二次读取。 这样程序就可以到达根源。 </p><br><p> 刚开始，我不了解此类功能的含义，因为磁盘速度很慢，并且一个线程将平静地处理所有I / O操作。 显然，从磁盘加载的节点中的搜索花费很少，在此期间，您可以用其他操作加载磁盘，但是反复尝试会吃光增益。 但是，后来我想到，在此实现中，节点在修改后并没有立即刷新到磁盘，而是在内存中挂了一段时间，以便立即应用许多修改。 由于预先写入日志，没有数据丢失。 关于它的更多信息将在文章的结尾。 </p><br><p> 现在，让我们看一下添加项目的代码。 </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doPut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T row, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> needOld)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IgniteCheckedException </span></span>{ checkDestroyed(); Put p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Put(row, needOld); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-comment"><span class="hljs-comment">// Go down with retries. p.init(); Result res = putDown(p, p.rootId, 0L, p.rootLvl); switch (res) { case RETRY: case RETRY_ROOT: checkInterrupted(); continue; case FOUND: // We may need to insert split key into upper level here. if (!p.isFinished()) { // It must be impossible to have an insert higher than the current root, // because we are making decision about creating new root while keeping // write lock on current root, so it can't concurrently change. assert p.btmLvl &lt;= getRootLevel(); checkInterrupted(); continue; } return p.oldRow; default: throw new IllegalStateException("Result: " + res); } } } catch (IgniteCheckedException e) { throw new IgniteCheckedException("Runtime failure on row: " + row, e); } catch (RuntimeException e) { throw new IgniteException("Runtime failure on row: " + row, e); } catch (AssertionError e) { throw new AssertionError("Assertion error on row: " + row, e); } finally { checkDestroyed(); } } /** * @param p Put. * @param pageId Page ID. * @param fwdId Expected forward page ID. * @param lvl Level. * @return Result code. * @throws IgniteCheckedException If failed. */ private Result putDown(final Put p, final long pageId, final long fwdId, final int lvl) throws IgniteCheckedException { assert lvl &gt;= 0 : lvl; final long page = acquirePage(pageId); try { for (;;) { // Init args. p.pageId = pageId; p.fwdId = fwdId; Result res = read(pageId, page, search, p, lvl, RETRY); switch (res) { case GO_DOWN: case GO_DOWN_X: assert lvl &gt; 0 : lvl; assert p.pageId != pageId; assert p.fwdId != fwdId || fwdId == 0; res = p.tryReplaceInner(pageId, page, fwdId, lvl); if (res != RETRY) // Go down recursively. res = putDown(p, p.pageId, p.fwdId, lvl - 1); if (res == RETRY_ROOT || p.isFinished()) return res; if (res == RETRY) checkInterrupted(); continue; // We have to insert split row to this level or it is a retry. case FOUND: // Do replace. assert lvl == 0 : "This replace can happen only at the bottom level."; return p.tryReplace(pageId, page, fwdId, lvl); case NOT_FOUND: // Do insert. assert lvl == p.btmLvl : "must insert at the bottom level"; assert p.needReplaceInner == FALSE : p.needReplaceInner + " " + lvl; return p.tryInsert(pageId, page, fwdId, lvl); default: return res; } } } finally { if (p.canRelease(pageId, lvl)) releasePage(pageId, page); } }</span></span></code> </pre> <br><p> 唯一的区别是，在检测到位置后，代码将分支到<code>replace</code>和<code>insert</code> 。  <code>remove</code>代码无法再观看。 基本机制是，根据操作： <code>Get</code> ， <code>Put</code>或<code>Remove</code> ，反复尝试遍历树和一个特殊对象。 </p><br><p>  <code>Invoke</code>以相同的方式进行，只有操作是在记录的副本中进行的，然后确定其类型：用于读取的<code>NOOP</code> ，用于删除的<code>REMOVE</code>和用于更新或添加的<code>PUT</code> ，然后生成相应的<code>Put</code>或<code>Remove</code>对象，并将其应用于树中的记录。 </p><br><h1 id="ispolzovanie"> 使用方法 </h1><br><p> 下面，我将仔细研究两个<code>BPlusTree</code> ： <code>CacheDataTree</code>和<code>PendingEntriesTree</code> 。 过度是索引的实现-这是一个单独讨论的主题，我还没有准备好进行讨论。 </p><br><p> 在继续之前，我将澄清一下，本地分布式地图具有<code>IgniteCache</code>功能，称为<code>IgniteCache</code>以下简称为缓存。 </p><br><h2 id="cachedatatree"> <code>CacheDataTree</code> </h2> <br><p>  <code>CacheDataTree</code>是多个<code>IgniteCache</code>到磁盘的映射。 排序是多级的：首先按缓存ID排序以将一个缓存中的键分组，然后按哈希排序。 </p><br><p>  <code>CacheDataTree</code>不会在该范围内进行迭代，因为索引是在<code>H2Tree extends BPlusTree</code>的继承人中实现的， <code>H2Tree extends BPlusTree</code> ，因此排序的特定类型并不重要：任何<code>put</code>和<code>get</code>操作就足够了。 比较哈希比对象快。 但更重要的是，统一的哈希将更密集地填充树。 </p><br><p> 树木保持平衡，因此它们不会退化为列表。 但是，如果将均匀分布的关键字添加到搜索树中，它将自动保持平衡。 由于B树在出现问题时开始平衡，并且哈希均匀混合密钥，因此按哈希排序会降低平衡的频率。 </p><br><p> 在搜索树中使用哈希似乎并不是一个奇怪的想法，它的逻辑发展将导致<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hash数组映射的trie</a> 。 </p><br><h2 id="pendingentriestree"> <code>PendingEntriesTree</code> </h2> <br><p>  <code>PendingEntriesTree</code>存储用于随时间推移的数据的键，并按设置使用。 排序是多级的：首先按缓存ID排序以将一个缓存中的组键排序，然后按生存期排序。 接下来是另一轮比较-显然是纯技术的，以区分元素。 从排序可以很容易地猜出该类是用于搜索范围的。 该树复制用于抢占的缓存条目键。 </p><br><p> 了解这种单独的冒险是如何工作的。 </p><br><div class="spoiler">  <b class="spoiler_title">历险记</b> <div class="spoiler_text"><p> 在<code>IgniteCacheOffheapManagerImpl.expire()</code>获取光标并从<code>PendingEntriesTree</code>删除条目。  <code>CacheDataTree</code>中的条目在闭包<code>c</code>中删除，闭包<code>c</code>在参数中传递。 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( GridCacheContext cctx, IgniteInClosure2X&lt;GridCacheEntryEx, GridCacheVersion&gt; c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount )</span></span></span></span></code> </pre> <br><p>  Apache Ignite直到最近才停止支持Java 7，因此通过匿名类创建了闭包。 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IgniteInClosure2X&lt;GridCacheEntryEx, GridCacheVersion&gt; expireC = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IgniteInClosure2X&lt;GridCacheEntryEx, GridCacheVersion&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GridCacheEntryEx entry, GridCacheVersion obsoleteVer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> touch = !entry.isNear(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (log.isTraceEnabled()) log.trace(<span class="hljs-string"><span class="hljs-string">"Trying to remove expired entry from cache: "</span></span> + entry); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entry.onTtlExpired(obsoleteVer)) touch = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (GridCacheEntryRemovedException ignore) { entry = entry.context().cache().entryEx(entry.key()); touch = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (touch) entry.context().evicts().touch(entry, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } };</code> </pre><br><p> 我们正在寻找的是<code>GridCacheMapEntry.onTtlExpired()</code>方法，其中的宝藏线位于<code>finally</code>块中。 </p><br><pre> <code class="java hljs">cctx.cache().removeEntry(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre> </div></div><br><h1 id="detali-realizacii"> 实施细节 </h1><br><h2 id="rabota-so-stranicami-v-offheap"> 在Offheap中处理页面 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Offheap</a>是一种使用垃圾回收器以某种语言优化手动内存管理的技术。 </p><br><p> 荒谬的是，由于垃圾收集器的出现，一切都变慢了，通常垃圾收集器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的性能</a>损失<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">惨重</a> 。 即使是大堆本身也不是问题，因为 收集器竞争激烈（例如Java中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CMS和G1</a> ），并且服务器具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数十个内核</a> 。 当然，收集器会向应用程序添加意外的暂停，这对于游戏来说很重要，但对于数据库来说是可以容忍的。 </p><br><p> 但是真正的问题是在大堆上违反了世代假设。 </p><br><div class="spoiler">  <b class="spoiler_title">世代假设</b> <div class="spoiler_text"><p>  GC优化使用世代假设。 该假设存在两个版本：强和弱。 </p><br><p>  <strong>世代假说薄弱：</strong>大多数物体都死于年轻。 </p><br><p>  <strong>关于世代的一个强有力的假设：</strong>物体越老，它的寿命就越长。 </p><br><p> 强有力的假设意味着较弱的假设，反之则不然。 理想情况下，GC应该满足于满足弱假设，但实际上并非如此。 </p><br><p> 如果您想更好地理解以下主题，请查看Alexey Shipilev关于Java中新GC的讨论： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2</a> 。 </p></div></div><br><p> 事情就是这样，在PDS出现之前，Apache Ignite主要被定位为服务和磁盘数据库（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hadoop</a> ）之间的缓存。 因此，Ignite中的地图称为<code>IgniteCache</code>并具有相应的拉伸功能。 缓存只是违反了世代假设-在其中，对象被删除的可能性随时间而增加。 因此，在这种情况下，用于存储用户数据的Offheap可以提高性能。 </p><br><p> 更多奖金： </p><br><ul><li> 通过Offheap，可以更轻松地实现包含多个<code>Integer.MAX_VALUE</code>元素的结构。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如果您的存储空间少于32GB，则链接将重4个字节</a> ，从而节省了几GB的空间。 </li><li> 由于收集器建立了对象图，因此消耗的内存与对象的数量成比例。 对象的数量与堆成正比。 收集器还消耗CPU，例如，最好将其用于数据压缩。 </li><li> 在非常大的堆中，即使从整体上不违反世代假设，仍然会有很多绝对价值的旧对象违反它。 </li></ul><br><p> 由于数据随后被发送到磁盘，因此对象通过<code>unsafe</code>直接被序列化到内存中，然后该内存区域用于I / O缓冲区。 </p><br><h2 id="write-ahead-log"> 提前写日志 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“预写日志”</a>是具有线性结构的操作的日志，与树不同，添加该日志的成本为常数。 该树的更新频率较低，如果由于倒塌而导致数据丢失，则可以通过应用从上次保存状态开始的操作从日志中恢复数据。 结果是在不损害可靠性的情况下提高了性能。 我建议您看一下<code>IgniteWriteAheadLogManager</code>界面-有详细的文档。 </p><br><h2 id="obhod-uzla"> 节点旁路 </h2><br><p> 由于B树中的节点不小，因此二进制搜索会绕过它们。 为此， <code>BPlusTree.GetPageHandler</code>类的后代，并且对于不同的操作，它们是不同的。 </p><br><div class="spoiler">  <b class="spoiler_title">二进制搜索实现</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findInsertionPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lvl, BPlusIO&lt;L&gt; io, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> low, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cnt, L row, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shift)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IgniteCheckedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> row != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> high = cnt - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (low &lt;= high) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cmp = compare(lvl, io, buf, mid, row); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cmp == <span class="hljs-number"><span class="hljs-number">0</span></span>) cmp = -shift; <span class="hljs-comment"><span class="hljs-comment">// We need to fix the case when search row matches multiple data rows. //noinspection Duplicates if (cmp &lt; 0) low = mid + 1; else if (cmp &gt; 0) high = mid - 1; else return mid; // Found. } return -(low + 1); // Not found. }</span></span></code> </pre> <br><p>  <code>BPlusTree</code>不同后代的<code>compare</code>方法不同。 负索引编码不存在的元素的位置。 标准库中的<code>Collections.binarySearch</code>会执行相同的操作。 </p><br><p> 请注意以下几行。 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cmp == <span class="hljs-number"><span class="hljs-number">0</span></span>) cmp = -shift;</code> </pre> <br><p> 对于<code>findOne</code>操作，此代码不执行任何操作，因为  <code>shift</code>设置为零，即 如果树中有相同的键，则它们将找到其中的任意一个。 </p><br><p> 但是，如果以这种方式寻找范围，则元素将丢失，因此<code>shift</code>设置为<code>1</code> 。 结果， <em>即使元素存在</em> ，搜索<em>也找不到它</em> ，但是搜索范围并不重要。 </p></div></div><br><h2 id="spisok-listov"> 床单清单 </h2><br><p> 为了有效地绕过范围，将工作表绑定到一个列表。 返回工作表之间的<code>BPlusTree.ForwardCursor</code>作为搜索结果。 显然，光标通过并不与树中的其他操作隔离，因为 传递时，仅在一页上进行锁定。 我没有找到保护访问游标方法的同步机制。 </p><br><h1 id="zaklyuchenie"> 结论 </h1><br><p> 由于与其他关系数据库相比，Apache Ignite中的B +树还很年轻，因此我们获得了可用于生产的B +树的必要集合： </p><br><ul><li>  <strong>WAL</strong>提供廉价的安全性，因此，很少在磁盘上更新树。 </li><li> 序列化形式的数据<strong>分拆</strong> 。 </li><li>  <strong>并发性</strong> -用于将树的一部分加载到内存中。 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413749/">https://habr.com/ru/post/zh-CN413749/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413739/index.html">我们如何扫描整个互联网以及我们学到了什么</a></li>
<li><a href="../zh-CN413741/index.html">它是什么以及如何：WWDC Redmadrobot团队印象</a></li>
<li><a href="../zh-CN413743/index.html">只需单击几下即可启动LAMP和其他数百种Web应用程序</a></li>
<li><a href="../zh-CN413745/index.html">一次为人体所有电子设备开发了无线电源系统</a></li>
<li><a href="../zh-CN413747/index.html">通过NULL</a></li>
<li><a href="../zh-CN413751/index.html">Ruslan Cheremin和Maxim Gramin-在jug.msk.ru上与环境合作</a></li>
<li><a href="../zh-CN413753/index.html">天上的眼睛：巡逻无人机，可识别人群和公共场所的暴力行为</a></li>
<li><a href="../zh-CN413757/index.html">商业项目中的数据库：怎么办？</a></li>
<li><a href="../zh-CN413759/index.html">好奇心在数十亿年前的火星上发现了有机物</a></li>
<li><a href="../zh-CN413761/index.html">如何防止Windows 10更新后重新启动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>