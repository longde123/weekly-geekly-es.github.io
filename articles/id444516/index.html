<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒ‚ ğŸ¤ ğŸ‘¨ğŸ»â€ğŸ“ Wolfenstein 3D: ray tracing dengan WebGL1 ğŸ‘ª ğŸ§’ğŸ» ğŸ‘¨ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setelah kemunculan kartu grafis Nvidia RTX musim panas lalu, ray tracing mendapatkan kembali popularitasnya. Selama beberapa bulan terakhir, umpan Twi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wolfenstein 3D: ray tracing dengan WebGL1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444516/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/885/df3/33c/885df333c0da45fcbb909c01c5da9648.png" alt="gambar"></div><br>  Setelah kemunculan kartu grafis Nvidia RTX musim panas lalu, ray tracing mendapatkan kembali popularitasnya.  Selama beberapa bulan terakhir, umpan Twitter saya telah diisi dengan aliran perbandingan grafis tanpa akhir dengan RTX yang diaktifkan dan dinonaktifkan. <br><br>  Setelah mengagumi begitu banyak gambar yang indah, saya ingin mencoba menggabungkan renderer maju klasik dengan pelacak sinar sendiri. <br><br>  Menderita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sindrom penolakan terhadap perkembangan orang lain</a> , sebagai hasilnya, saya membuat mesin rendering hybrid saya sendiri yang berbasis WebGL1.  Anda dapat bermain dengan rendering tingkat demo dari Wolfenstein 3D dengan bola (yang saya gunakan karena ray tracing) di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><a name="habracut"></a><br><h3>  Prototipe </h3><br>  Saya memulai proyek ini dengan membuat prototipe, mencoba menciptakan kembali <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencahayaan global dengan ray tracing dari Metro Exodus</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/61a/447/26261a447cd19758715a3cbde356eeb7.png"></div><br>  <i>Prototipe pertama yang menunjukkan pencahayaan global difus (Diffuse GI)</i> <br><br>  Prototipe didasarkan pada renderer maju, yang menjadikan seluruh geometri adegan.  Shader yang digunakan untuk meraster geometri tidak hanya menghitung iluminasi langsung, tetapi juga memancarkan sinar acak dari permukaan geometri yang diberikan untuk terakumulasi menggunakan pantulan sinar tidak langsung pantulan cahaya yang timbul dari permukaan yang tidak mengkilap (Diffuse GI). <br><br>  Pada gambar di atas, Anda dapat melihat bagaimana semua bola diterangi dengan benar hanya oleh pencahayaan tidak langsung (sinar cahaya dipantulkan dari dinding di belakang kamera).  Sumber cahaya itu sendiri ditutupi oleh dinding cokelat di sisi kiri gambar. <br><br><h3>  Wolfenstein 3D </h3><br>  Prototipe menggunakan adegan yang sangat sederhana.  Ini hanya memiliki satu sumber cahaya dan hanya beberapa bola dan kubus yang diberikan.  Berkat ini, kode pelacakan sinar di shader sangat sederhana.  Siklus memeriksa brute-force di mana balok diuji untuk persimpangan dengan semua kubus dan bola di tempat kejadian masih cukup cepat untuk program untuk mengeksekusinya secara real time. <br><br>  Setelah membuat prototipe ini, saya ingin melakukan sesuatu yang lebih kompleks dengan menambahkan lebih banyak geometri dan banyak sumber cahaya ke TKP. <br><br>  Masalah dengan lingkungan yang lebih kompleks adalah bahwa saya masih harus dapat melacak sinar di TKP secara real time.  Biasanya, struktur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hierarki volume pembatas</a> (BVH) akan digunakan untuk mempercepat proses pelacakan ray, tetapi keputusan saya untuk membuat proyek ini di WebGL1 tidak memungkinkan ini: tidak mungkin memuat data 16-bit ke dalam tekstur di WebGL1 dan operasi biner tidak dapat digunakan dalam shader.  Ini mempersulit perhitungan awal dan aplikasi BVH di shader WebGL1. <br><br>  Itulah mengapa saya memutuskan untuk menggunakan level demo 3D Wolfenstein untuk ini.  Pada 2013, saya membuat satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shader WebGL terfragmentasi</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shadertoy</a> yang tidak hanya membuat tingkat seperti Wolfenstein, tetapi juga secara prosedural menciptakan semua tekstur yang diperlukan.  Dari pengalaman saya bekerja pada shader ini, saya tahu bahwa desain level berbasis grid dari Wolfenstein juga dapat digunakan sebagai struktur akselerasi yang cepat dan mudah, dan ray tracing pada struktur ini akan sangat cepat. <br><br>  Di bawah ini adalah tangkapan layar demo, dan dalam mode layar penuh Anda dapat memainkannya di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://reindernijhoff.net/wolfrt</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eu/gl/fp/euglfpjgl9503fy-_hjdwmr5hdi.png"></div><br><h3>  Deskripsi singkat </h3><br>  Demo ini menggunakan mesin rendering hybrid.  Untuk membuat semua poligon dalam bingkai, ia menggunakan rasterisasi tradisional, dan kemudian menggabungkan hasilnya dengan bayangan, GI difus, dan refleksi yang dibuat oleh ray tracing. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f7/fd8/bb9/8f7fd8bb9324905edf5200fedb28bb7a.png"></div><br>  <i>Bayangan</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/5b5/6ba/5245b56ba3a1feb02a9401857d625514.png"></div><br>  <i>Gi difus</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/885/df3/33c/885df333c0da45fcbb909c01c5da9648.png"></div><br>  <i>Refleksi</i> <br><br><h3>  Render proaktif </h3><br>  Kartu Wolfenstein dapat dikodekan sepenuhnya menjadi kisi dua dimensi 64 Ã— 64.  Peta yang digunakan dalam demo didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">level pertama episode 1 dari</a> Wolfenstein 3D. <br><br>  Saat start-up, semua geometri yang diperlukan untuk lulus rendering proaktif dibuat.  Jala dinding dihasilkan dari data peta.  Ini juga menciptakan bidang lantai dan langit-langit, jerat terpisah untuk lampu, pintu, dan bola acak. <br><br>  Semua tekstur yang digunakan untuk dinding dan pintu dikemas dalam satu atlas tekstur tunggal, sehingga semua dinding dapat ditarik dalam satu panggilan draw. <br><br><h4>  Bayangan dan Pencahayaan </h4><br>  Penerangan langsung dihitung dalam shader yang digunakan untuk umpan render maju.  Setiap fragmen dapat diterangi (maksimum) oleh empat sumber berbeda.  Untuk mengetahui sumber mana yang dapat memengaruhi fragmen dalam shader, saat demo dimulai, tekstur pencarian sudah dihitung sebelumnya.  Tekstur pencarian ini memiliki ukuran 64 x 128 dan mengkodekan posisi 4 sumber cahaya terdekat untuk setiap posisi dalam kisi peta. <br><br><pre><code class="cpp hljs">varying vec3 vWorldPos; varying vec3 vNormal; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ vec3 ro = vWorldPos; vec3 normal = normalize(vNormal); vec3 light = vec3(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;LIGHTS_ENCODED_IN_MAP; i++) { light += sampleLight(i, ro, normal); }</code> </pre> <br>  Untuk mendapatkan bayangan lembut untuk setiap fragmen dan sumber cahaya, posisi acak dalam sumber cahaya disampel.  Menggunakan kode pelacakan sinar di shader (lihat bagian Ray Tracing di bawah), bayangan bayangan dipancarkan ke titik pengambilan sampel untuk menentukan visibilitas sumber cahaya. <br><br>  Setelah menambahkan refleksi (tambahan) (lihat bagian Refleksi di bawah), difusi GI ditambahkan ke warna yang dihitung dari fragmen dengan melakukan pencarian di Target Render GI Render (lihat di bawah). <br><br><h3>  Ray tracing </h3><br>  Meskipun prototipe ray tracing code untuk difuse GI dikombinasikan dengan preemptive shader, dalam demo saya memutuskan untuk memisahkan mereka. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58b/8fd/3ab/58b8fd3abd38a86da42e1454df7109de.png"></div><br>  Saya memisahkan mereka dengan melakukan rendering kedua dari semua geometri menjadi target render yang terpisah (Diffuse GI Render Target) menggunakan shader lain yang hanya memancarkan sinar acak untuk mengumpulkan GI difus (lihat bagian â€œDiffuse GIâ€ di bawah).  Pencahayaan yang dikumpulkan dalam target render ini ditambahkan ke pencahayaan langsung yang dihitung dalam bagian render maju. <br><br>  Dengan memisahkan lintasan proaktif dan difusi GI, kita dapat memancarkan kurang dari satu sinar GI per piksel layar.  Ini dapat dilakukan dengan mengurangi Skala Buffer (dengan menggerakkan slider pada opsi di sudut kanan atas layar). <br><br>  Misalnya, jika Skala Penyangga adalah 0,5, maka hanya satu sinar yang akan dipancarkan untuk setiap empat piksel layar.  Ini memberikan peningkatan besar dalam produktivitas.  Menggunakan UI yang sama di sudut kanan atas layar, Anda juga dapat mengubah jumlah sampel per piksel dalam target render (SPP) dan jumlah pantulan sinar. <br><br><h4>  Dipancarkan sinar </h4><br>  Agar dapat memancarkan sinar ke tempat kejadian, semua geometri level harus memiliki format yang dapat digunakan pelacak sinar dalam shader.  Lapisan Wolfenstein mengkodekan kisi 64 Ã— 64, sehingga cukup mudah untuk menyandikan semua data menjadi satu tekstur 64 Ã— 64: <br><br><ul><li>  Dalam saluran merah warna tekstur, semua objek yang terletak di sel yang sesuai <em>x, y dari</em> kisi peta dikodekan.  Jika nilai saluran merah adalah nol, maka tidak ada benda di dalam sel, jika tidak, itu ditempati oleh dinding (nilai 1 hingga 64), pintu, sumber cahaya atau bola yang perlu diperiksa untuk persimpangan. </li><li>  Jika sebuah bola menempati sel grid level, maka saluran hijau, biru dan alfa digunakan untuk mengkodekan radius dan koordinat relatif <em>x</em> dan <em>y</em> dari bola di dalam sel grid. </li></ul><br>  Sinar dipancarkan dalam sebuah adegan dengan melintasi tekstur menggunakan kode berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worldHit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n vec3 ro,in vec3 rd,in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t_min, in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t_max, inout vec3 recPos, inout vec3 recNormal, inout vec3 recColor)</span></span></span><span class="hljs-function"> </span></span>{ vec3 pos = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(ro); vec3 ri = <span class="hljs-number"><span class="hljs-number">1.0</span></span>/rd; vec3 rs = sign(rd); vec3 dis = (pos-ro + <span class="hljs-number"><span class="hljs-number">0.5</span></span> + rs*<span class="hljs-number"><span class="hljs-number">0.5</span></span>) * ri; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;MAXSTEPS; i++ ) { vec3 mm = step(dis.xyz, dis.zyx); dis += mm * rs * ri; pos += mm * rs; vec4 mapType = texture2D(_MapTexture, pos.xz * (<span class="hljs-number"><span class="hljs-number">1.</span></span> / <span class="hljs-number"><span class="hljs-number">64.</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWall(mapType)) { ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Kode penelusuran mesh mesh yang serupa dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shader Wolfenstein</a> di Shadertoy ini. <br><br>  Setelah menghitung titik persimpangan dengan dinding atau pintu (menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tes persimpangan dengan jajar genjang</a> ), mencari di atlas tekstur yang sama yang digunakan untuk melewati rendering proaktif memberi kita titik persimpangan Albedo.  Spheres memiliki warna yang ditentukan secara prosedural berdasarkan koordinat <em>x, y</em> dalam kisi dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi gradien warna</a> . <br><br>  Pintu sedikit lebih rumit karena mereka bergerak.  Agar representasi adegan dalam CPU (digunakan untuk membuat jerat pada pass rendering maju) harus sama dengan representasi adegan dalam GPU (digunakan untuk penelusuran sinar), semua pintu bergerak secara otomatis dan deterministik, berdasarkan jarak dari kamera ke pintu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d7/ded/058/3d7ded058d2f62fcf298c9b68b568a69.png"></div><br><br><h4>  Gi difus </h4><br>  Pencahayaan Global Tersebar (GI difus) dihitung dengan memancarkan sinar dalam shader, yang digunakan untuk menggambar semua geometri di Target Diffuser GI Render.  Arah sinar-sinar ini tergantung pada normal ke permukaan, ditentukan dengan mengambil sampel belahan yang berbobot kosinus. <br><br>  Memiliki arah sinar <em>rd</em> dan titik awal <em>ro</em> , iluminasi yang dipantulkan dapat dihitung dengan menggunakan siklus berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBounceCol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(in vec3 ro, in vec3 rd, in vec3 col)</span></span></span><span class="hljs-function"> </span></span>{ vec3 emitted = vec3(<span class="hljs-number"><span class="hljs-number">0</span></span>); vec3 recPos, recNormal, recColor; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;MAX_RECURSION; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worldHit(ro, rd, <span class="hljs-number"><span class="hljs-number">0.001</span></span>, <span class="hljs-number"><span class="hljs-number">20.</span></span>, recPos, recNormal, recColor)) { <span class="hljs-comment"><span class="hljs-comment">// if (isLightHit) { // direct light sampling code // return vec3(0); // } col *= recColor; for (int i=0; i&lt;2; i++) { emitted += col * sampleLight(i, recPos, recNormal); } } else { return emitted; } rd = cosWeightedRandomHemisphereDirection(recNormal); ro = recPos; } return emitted; }</span></span></code> </pre> <br>  Untuk mengurangi kebisingan, pengambilan sampel cahaya langsung ditambahkan ke loop.  Ini mirip dengan teknik yang digunakan dalam shader <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cornell Box</a> saya yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lain</a> di Shadertoy. <br><br><h4>  Refleksi </h4><br>  Berkat kemampuan untuk melacak adegan dengan sinar di shader, sangat mudah untuk menambahkan pantulan.  Dalam demo saya, refleksi ditambahkan dengan memanggil metode <em>getBounceCol yang</em> sama <em>seperti</em> yang ditunjukkan di atas menggunakan berkas pantulan kamera: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> REFLECTION col = mix(col, getReflectionCol(ro, reflect(normalize(vWorldPos - _CamPos), normal), albedo), .15); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Refleksi ditambahkan dalam lintasan render maju, oleh karena itu, satu sinar pantulan akan selalu memancarkan satu sinar pantulan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a88/e84/d6a/a88e84d6a2d0209234d6edaf02fcc441.png"></div><br><h3>  Anti-aliasing sementara </h3><br>  Karena kedua bayangan lembut di lintasan render maju dan pendekatan GI difus menggunakan kira-kira satu sampel per piksel, hasil akhirnya sangat bising.  Untuk mengurangi jumlah kebisingan, temporal anti-aliasing (TAA) digunakan berdasarkan TAA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Playdead</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Temporal Reprojection Anti-Aliasing di INSIDE</a> . <br><br><h4>  Proyeksi ulang </h4><br>  Gagasan di balik TAA cukup sederhana: TAA menghitung satu subpixel per frame, dan kemudian rata-rata nilainya dengan pixel yang berkorelasi dari frame sebelumnya. <br><br>  Untuk mengetahui di mana piksel saat ini berada dalam bingkai sebelumnya, posisi fragmen diproyeksikan kembali menggunakan matriks model-view-proyeksi dari frame sebelumnya. <br><br><h4>  Jatuhkan sampel dan batasi lingkungan </h4><br>  Dalam beberapa kasus, sampel yang disimpan dari masa lalu tidak valid, misalnya, ketika kamera bergerak sedemikian rupa sehingga sebuah fragmen dari frame saat ini di frame sebelumnya ditutup oleh geometri.  Untuk membuang sampel yang tidak valid tersebut, pembatasan lingkungan digunakan.  Saya memilih jenis pembatasan paling sederhana: <br><br><pre> <code class="cpp hljs">vec3 history = texture2D(_History, uvOld ).rgb; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = <span class="hljs-number"><span class="hljs-number">-1.</span></span>; x &lt;= <span class="hljs-number"><span class="hljs-number">1.</span></span>; x+=<span class="hljs-number"><span class="hljs-number">1.</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = <span class="hljs-number"><span class="hljs-number">-1.</span></span>; y &lt;= <span class="hljs-number"><span class="hljs-number">1.</span></span>; y+=<span class="hljs-number"><span class="hljs-number">1.</span></span>) { vec3 n = texture2D(_New, vUV + vec2(x,y) / _Resolution).rgb; mx = max(n, mx); mn = min(n, mn); } } vec3 history_clamped = clamp(history, mn, mx);</code> </pre> <br>  Saya juga mencoba menggunakan metode pembatasan berdasarkan pada jajar genjang, tetapi tidak melihat banyak perbedaan dengan solusi saya.  Ini mungkin terjadi karena dalam adegan dari demo ada banyak warna gelap yang identik dan hampir tidak ada benda bergerak. <br><br><h4>  Getaran kamera </h4><br>  Untuk mendapatkan anti-aliasing, kamera di setiap frame berosilasi karena penggunaan pergeseran subpiksel acak (semu).  Ini diimplementasikan dengan mengubah matriks proyeksi: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._projectionMatrix[<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>] += (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getHaltonSequence(frame % <span class="hljs-number"><span class="hljs-number">51</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) - <span class="hljs-number"><span class="hljs-number">.5</span></span>) / renderWidth; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._projectionMatrix[<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] += (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getHaltonSequence(frame % <span class="hljs-number"><span class="hljs-number">41</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) - <span class="hljs-number"><span class="hljs-number">.5</span></span>) / renderHeight;</code> </pre> <br><h3>  Kebisingan </h3><br>  Noise adalah dasar dari algoritma yang digunakan untuk menghitung difusi GI dan bayangan halus.  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">noise yang baik</a> sangat memengaruhi kualitas gambar, sementara noise yang buruk menciptakan artefak atau memperlambat konvergensi gambar. <br><br>  Saya takut white noise yang digunakan dalam demo ini tidak terlalu bagus. <br><br>  Menggunakan noise yang baik mungkin merupakan aspek terpenting untuk meningkatkan kualitas gambar dalam demo ini.  Misalnya, Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">noise biru</a> . <br><br>  Saya melakukan eksperimen dengan noise berdasarkan rasio emas, tetapi mereka tidak berhasil.  Sejauh ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hash</a> terkenal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tanpa Sine of</a> Dave Hoskins digunakan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 p3 = fract(vec3(g_seed += <span class="hljs-number"><span class="hljs-number">0.1</span></span>) * HASHSCALE3); p3 += dot(p3, p3.yzx + <span class="hljs-number"><span class="hljs-number">19.19</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract((p3.xx+p3.yz)*p3.zy); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a81/338/42a/a8133842a43266dad1b4e9ee50c59228.png"></div><br><h3>  Pengurangan kebisingan </h3><br>  Bahkan dengan TAA diaktifkan, demo masih menunjukkan banyak kebisingan.  Terutama sulit untuk membuat langit-langit, karena hanya diterangi oleh pencahayaan tidak langsung.  Fakta bahwa langit-langit adalah permukaan datar besar yang diisi dengan warna solid tidak menyederhanakan situasi: jika memiliki detail tekstur atau geometris, kebisingan akan menjadi kurang terlihat. <br><br>  Saya tidak ingin menghabiskan banyak waktu di bagian demo ini, jadi saya mencoba menerapkan hanya satu filter pengurangan kebisingan: Median3x3 dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Morgan McGuire dan Kyle Witson</a> .  Sayangnya, filter ini tidak bekerja dengan baik dengan grafik "pixel art" dari tekstur dinding: filter ini menghilangkan semua detail di kejauhan dan memutari sudut-sudut piksel dinding di dekatnya. <br><br>  Dalam percobaan lain, saya menerapkan filter yang sama ke Target Render GI Render.  Meskipun ia sedikit mengurangi kebisingan, pada saat yang sama hampir tanpa mengubah detail tekstur dinding, saya memutuskan bahwa peningkatan ini tidak sebanding dengan milidetik tambahan yang dihabiskan. <br><br><h3>  Demo </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda dapat memainkan demo di sini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444516/">https://habr.com/ru/post/id444516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444502/index.html">Apakah kriptografi kuantum benar-benar dapat diandalkan?</a></li>
<li><a href="../id444504/index.html">Menggunakan direktori paket lokal di Python sekarang</a></li>
<li><a href="../id444508/index.html">Bagaimana kami membuat PHP 7 dua kali lebih cepat dari PHP 5. Bagian 1: mengoptimalkan struktur data</a></li>
<li><a href="../id444512/index.html">Membuat aplikasi grafis untuk menyelesaikan masalah jalannya kuda</a></li>
<li><a href="../id444514/index.html">Webinar "Keamanan Pembelajaran Mesin: Masalah Alami Kecerdasan Buatan"</a></li>
<li><a href="../id444518/index.html">Menuju teori kesadaran mendasar</a></li>
<li><a href="../id444520/index.html">2. Periksa Titik Memulai R80.20. Arsitektur Solusi</a></li>
<li><a href="../id444522/index.html">Kiamat dibatalkan</a></li>
<li><a href="../id444524/index.html">Lambdas: dari C ++ 11 ke C ++ 20. Bagian 1</a></li>
<li><a href="../id444526/index.html">Stack DOTS: C ++ & C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>