<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚ÄçüöÄ üëêüèΩ üè∑Ô∏è Asynchrone Gesch√§ftslogik heutzutage ü¶í üçÅ üíà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kurzum: 


- Der Proof ist bereits in C ++ , JS und PHP implementiert, geeignet f√ºr Java . 
- Schneller als Coroutine und Promise, mehr Funktionen. 
-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchrone Gesch√§ftslogik heutzutage</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424311/"><p>  Kurzum: </p><br><blockquote><ul><li>  Der Proof ist bereits in <strong>C ++</strong> , <strong>JS</strong> und <strong>PHP</strong> implementiert, geeignet f√ºr <strong>Java</strong> . </li><li> <strong>Schneller</strong> als Coroutine und Promise, mehr Funktionen. </li><li>  Es ist kein separater Software-Stack erforderlich. </li><li>  Befreundet alle Sicherheits- und Debugging-Tools. </li><li>  Es funktioniert auf jeder Architektur und erfordert keine speziellen Compiler-Flags. </li></ul><br></blockquote><a name="habracut"></a><br><hr><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schau zur√ºck</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FutoIn AsyncSteps - eine Alternative zu Coroutinen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zu den Zahlen</a> </li></ul><br><h2 id="vzglyad-nazad">  Schau zur√ºck </h2><br><p>  Zu Beginn des Computers gab es einen einzigen Kontrollfluss mit Blockierung der Eingabe / Ausgabe.  Dann wurden Eisenunterbrechungen hinzugef√ºgt.  Jetzt k√∂nnen Sie langsame und unvorhersehbare Ger√§te effektiv verwenden. </p><br><p>  Mit dem Wachstum der Eisenkapazit√§ten und seiner geringen Verf√ºgbarkeit wurde es notwendig, mehrere Aufgaben gleichzeitig auszuf√ºhren, was Hardware-Unterst√ºtzung bot.  Es gab also isolierte Prozesse mit Unterbrechungen, die in Form von Signalen vom Eisen abstrahiert wurden. </p><br><p>  Die n√§chste Evolutionsstufe war Multithreading, das auf der Grundlage derselben Prozesse implementiert wurde, jedoch mit gemeinsamem Zugriff auf Speicher und andere Ressourcen.  Dieser Ansatz hat seine Grenzen und einen erheblichen Aufwand f√ºr den Wechsel zu einem sicheren Betriebssystem. </p><br><p>  F√ºr die Kommunikation zwischen Prozessen und sogar verschiedenen Maschinen wurde vor mehr als 40 Jahren die Abstraktion Promise / Future vorgeschlagen. </p><br><p>  Die Benutzeroberfl√§chen und das derzeit l√§cherliche 10K-Client-Problem haben zur Bl√ºtezeit der Event Loop-, Reactor- und Proactor-Ans√§tze gef√ºhrt, die eher ereignisorientiert sind als eine klare, konsistente Gesch√§ftslogik. </p><br><p>  Schlie√ülich kamen wir zur modernen Coroutine (Coroutine), die im Wesentlichen eine Emulation von Fl√ºssen √ºber den oben beschriebenen Abstraktionen mit den entsprechenden technischen Einschr√§nkungen und dem deterministischen Kontrolltransfer ist. </p><br><p>  Um Ereignisse, Ergebnisse und Ausnahmen zu vermitteln, kehrten alle zum gleichen Konzept von Versprechen / Zukunft zur√ºck.  Einige B√ºros haben beschlossen, etwas anders zu benennen - "Aufgabe". </p><br><p> Am Ende versteckten sie alles in einem wundersch√∂nen <code>async/await</code> Paket, das je nach Technologie Unterst√ºtzung durch Compiler oder √úbersetzer erfordert. </p><br><h3 id="problemy-s-tekuschiy-situaciy-asinhronnoy-biznes-logiki">  Probleme mit aktuellen asynchronen Gesch√§ftslogiksituationen </h3><br><p>  Betrachten Sie nur Coroutinen und Promise, dekoriert mit <code>async/await</code> , as  Das Vorhandensein von Problemen in √§lteren Ans√§tzen best√§tigt den Evolutionsprozess selbst. </p><br><p>  Diese beiden Begriffe sind nicht identisch.  Zum Beispiel gibt es in ECMAScript keine Coroutinen, aber es gibt eine syntaktische Erleichterung f√ºr die Verwendung von <code>Promise</code> , die wiederum nur die Arbeit mit der Callback-H√∂lle organisiert.  In der Tat gehen Scripting-Engines wie V8 noch weiter und nehmen spezielle Optimierungen f√ºr reine <code>async/await</code> Funktionen und Aufrufe vor. </p><br><p>  Experten <code>co_async/co_await</code> , das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier auf der Ressource</a> nicht in C ++ 17 <code>co_async/co_await</code> , aber der Druck der Software-Riesen-Coroutinen kann im Standard genau in ihrer Form erscheinen.  In der Zwischenzeit ist die traditionell anerkannte L√∂sung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boost.Context</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boost.Fiber</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boost.Coroutine2</a> . </p><br><p>  In Java gibt es auf Sprachebene immer noch kein <code>async/await</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warten</a> , aber es gibt L√∂sungen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EA Async</a> , die wie Boost.Context f√ºr jede Version der JVM und des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codebytes</a> angepasst werden m√ºssen. </p><br><p>  Go hat seine eigenen Coroutinen, aber wenn man sich die Artikel und Fehlerberichte offener Projekte genau ansieht, stellt sich heraus, dass hier nicht alles so reibungslos ist.  Vielleicht ist es keine gute Idee, die Coroutine-Schnittstelle als verwaltete Entit√§t zu verlieren. </p><br><h4 id="mnenie-avtora-soprogrammy-na-golom-zheleze-opasny">  Meinung des Autors: Bare-Metal-Coroutinen sind gef√§hrlich </h4><br><p>  Pers√∂nlich hat der Autor wenig gegen Coroutinen in dynamischen Sprachen, aber er ist √§u√üerst vorsichtig, wenn er auf der Ebene des Maschinencodes mit dem Stapel flirtet. </p><br><p>  Ein paar Punkte: </p><br><ol><li>  Stapel erforderlich: <br><ul><li>  Der Stapel auf dem Haufen hat eine Reihe von Nachteilen: Probleme bei der rechtzeitigen Bestimmung des √úberlaufs, Sch√§den durch Nachbarn und andere Zuverl√§ssigkeits- / Sicherheitsprobleme, </li><li>  Ein gesch√ºtzter Stapel erfordert mindestens eine Seite physischen Speichers, eine bedingte Seite und zus√§tzlichen Overhead f√ºr jeden Aufruf von <code>async</code> Funktionen: 4 + KB (Minimum) + erh√∂hte Systemlimits, </li><li>  Letztendlich kann es sein, dass ein erheblicher Teil des f√ºr die Stapel zugewiesenen Speichers w√§hrend der Ausfallzeit der Coroutine nicht verwendet wird. </li></ul></li><li>  Es ist notwendig, eine komplexe Logik zum Speichern, Wiederherstellen und L√∂schen des Status von Coroutinen zu implementieren: <br><ul><li>  f√ºr jeden Fall von Prozessorarchitektur (auch Modelle) und bin√§rer Schnittstelle (ABI): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> : </li><li>  Neue oder optionale Architekturfunktionen f√ºhren zu potenziell latenten Problemen (z. B. Intel TSX, ARM-Co-Prozessoren oder MIPS). </li><li>  andere potenzielle Probleme aufgrund der geschlossenen Dokumentation propriet√§rer Systeme (Boost-Dokumentation bezieht sich darauf). </li></ul></li><li>  M√∂gliche Probleme mit dynamischen Analysetools und mit der Sicherheit im Allgemeinen: <br><ul><li>  Zum Beispiel ist die Integration mit Valgrind aufgrund der gleichen Sprungstapel erforderlich. </li><li>  Es ist schwer, f√ºr Virostatika zu sprechen, aber wahrscheinlich gef√§llt es ihnen am Beispiel von Problemen mit JVM in der Vergangenheit nicht wirklich. </li><li>  Ich bin sicher, dass neue Arten von Angriffen auftreten und Schwachstellen im Zusammenhang mit der Implementierung von Coroutinen aufgedeckt werden. </li></ul></li></ol><br><h4 id="mnenie-avtora-generatory-i-yield-principialnoe-zlo">  Meinung des Autors: Generatoren und <code>yield</code> grundlegendes √úbel </h4><br><p>  Dieses scheinbar von Dritten stammende Thema steht in direktem Zusammenhang mit dem Konzept der Coroutinen und der Eigenschaft "Fortfahren". </p><br><p>  Kurz gesagt, f√ºr jede Sammlung muss ein vollst√§ndiger Iterator vorhanden sein.  Warum ein zugeschnittenes Iterator-Generator-Problem erstellt wird, ist nicht klar.  Zum Beispiel ist ein Fall mit <code>range()</code> in Python eher eine exklusive Demonstration als eine Entschuldigung f√ºr technische Komplikationen. </p><br><p>  Wenn der Fall ein unendlicher Generator ist, ist die Logik seiner Implementierung elementar.  Warum zus√§tzliche technische Schwierigkeiten verursachen, um einen endlosen Zyklus fortzusetzen? </p><br><p>  Die einzige vern√ºnftige Rechtfertigung, die sp√§ter von Bef√ºrwortern von Coroutinen gegeben wurde, sind alle Arten von Stream-Parsern mit umgekehrter Kontrolle.  Tats√§chlich handelt es sich hierbei um einen engen Spezialfall zur L√∂sung einzelner Probleme auf Bibliotheksebene, nicht um die Gesch√§ftslogik von Anwendungen.  Gleichzeitig gibt es eine elegante, einfache und aussagekr√§ftigere L√∂sung durch endliche Zustandsmaschinen.  Der Bereich dieser technischen Probleme ist viel kleiner als der Bereich der allt√§glichen Gesch√§ftslogik. </p><br><p>  Tats√§chlich wird das zu l√∂sende Problem von einem Finger aus gel√∂st und erfordert relativ ernsthafte Anstrengungen f√ºr die anf√§ngliche Implementierung und langfristige Unterst√ºtzung.  So sehr, dass einige Projekte m√∂glicherweise ein Verbot der Verwendung von Coroutinen auf Maschinencode-Ebene einf√ºhren, das dem Beispiel eines Verbots von <code>goto</code> oder der Verwendung der dynamischen Speicherzuweisung in einzelnen Branchen folgt. </p><br><h4 id="mnenie-avtora-model-asyncawait-na-promise-iz-ecmascript-bolee-nadyozhna-no-trebuet-adaptacii">  Meinung der Autoren: Das <code>async/await</code> Promise-Modell von ECMAScript ist zuverl√§ssiger, muss jedoch angepasst werden </h4><br><p>  Im Gegensatz zu fortlaufenden Coroutinen werden in diesem Modell die Codeteile heimlich in nicht unterbrechbare Bl√∂cke unterteilt, die als anonyme Funktionen ausgelegt sind.  In C ++ ist dies aufgrund der Besonderheiten der Speicherverwaltung nicht ganz geeignet. Ein Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeObject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Value = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;; <span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcPromise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolved(value_); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">()&gt; &amp;&amp;cb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value&amp; val)</span></span></span><span class="hljs-function"> </span></span>{ somehow_call_later(cb); } Value value_; }; <span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SomeObject some_obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> some_obj.funcPromise() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception &amp;e){ <span class="hljs-comment"><span class="hljs-comment">// ... }) .then([&amp;](SomeObject::value &amp;&amp;val){ return Promise([&amp;](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ some_obj.funcCallback(resolve, val); }); }); }</span></span></code> </pre> <br><p>  Erstens wird <code>some_obj</code> beim Beenden von <code>example()</code> und vor dem Aufrufen von Lambda-Funktionen zerst√∂rt. </p><br><p>  Zweitens sind Lambda-Funktionen mit Erfassungsvariablen oder Referenzen Objekte und f√ºgen heimlich Kopieren / Verschieben hinzu, was sich negativ auf die Leistung bei einer gro√üen Anzahl von Erfassungen und die Notwendigkeit auswirken kann, w√§hrend der Typl√∂schung in der √ºblichen <code>std::function</code> Speicher auf dem Heap zuzuweisen. </p><br><p>  Drittens wurde die <code>Promise</code> Schnittstelle selbst eher nach dem Konzept des "Versprechens" des Ergebnisses als nach der konsequenten Ausf√ºhrung der Gesch√§ftslogik konzipiert. </p><br><p>  Eine schematische, NICHT optimale L√∂sung k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalContext</span></span></span><span class="hljs-class"> {</span></span> SomeObject some_obj; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ctx = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;LocalContext&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> some_obj.funcPromise() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception &amp;e){ <span class="hljs-comment"><span class="hljs-comment">// ... }) .then([ctx](SomeObject::Value &amp;&amp;val){ struct LocalContext2 { LocalContext2(std::shared_ptr&lt;LocalContext&gt; &amp;&amp;ctx, SomeObject::Value &amp;&amp;val) : ctx(ctx), val(val) {} std::shared_ptr&lt;LocalContext&gt; ctx; SomeObject::Value val; }; auto ctx2 = std::make_shared&lt;LocalContext2&gt;( std::move(ctx), std::forward&lt;SomeObject::Value&gt;(val) ); return Promise([ctx2](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ ctx2-&gt;ctx-&gt;some_obj.funcCallback([ctx2, resolve](){ resolve(); }, val); }); }); }</span></span></code> </pre> <br><p>  <em>Hinweis: <code>std::move</code> anstelle von <code>std::shared_ptr</code> nicht geeignet, da nicht mehrere Lambdas gleichzeitig √ºbertragen werden k√∂nnen und ihre Gr√∂√üe zunimmt.</em> </p><br><p>  Mit der Hinzuf√ºgung von <code>async/await</code> asynchrone Schrecken in einen verdaulichen Zustand: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">async </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SomeObject some_obj; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { SomeObject::Value val = await some_obj.func(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) ( <span class="hljs-comment"><span class="hljs-comment">// ... } // Capture "async context" return Promise([async](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ some_obj.funcCallback([async](){ resolve(); }, val); }); }</span></span></code> </pre> <br><h4 id="mnenie-avtora-planirovschik-soprogramm---eto-perebor">  Meinung des Autors: Coroutine Planer ist eine Pleite </h4><br><p>  Einige Kritiker bezeichnen das Fehlen eines Schedulers und den "unehrlichen" Einsatz von Prozessorressourcen als Problem.  Ein m√∂glicherweise schwerwiegenderes Problem ist die Datenlokalit√§t und die effiziente Nutzung des Prozessor-Cache. </p><br><p>  Zum ersten Problem: Die Priorisierung auf der Ebene einzelner Coroutinen sieht nach einem gro√üen Aufwand aus.  Stattdessen k√∂nnen sie gemeinsam f√ºr eine bestimmte einheitliche Aufgabe bearbeitet werden.  Dies ist, was Verkehrsstr√∂me tun. </p><br><p>  Dies ist m√∂glich, indem separate Instanzen der Ereignisschleife mit eigenen "Eisen" -Threads erstellt und auf Betriebssystemebene geplant werden.  Die zweite M√∂glichkeit besteht darin, Coroutinen mit einem relativ primitiven (Mutex, Throttle) Primitiv in Bezug auf Wettbewerb und / oder Leistung zu synchronisieren. </p><br><p>  Die asynchrone Programmierung macht die Prozessorressourcen nicht gummiartig und erfordert absolut normale Einschr√§nkungen hinsichtlich der Anzahl gleichzeitig verarbeiteter Aufgaben und Einschr√§nkungen der Gesamtausf√ºhrungszeit. </p><br><p>  Der Schutz gegen langes Blockieren auf einer Coroutine erfordert die gleichen Ma√ünahmen wie bei R√ºckrufen - um das Blockieren von Systemaufrufen und lange Datenverarbeitungszyklen zu vermeiden. </p><br><p>  Das zweite Problem erfordert Nachforschungen, aber zumindest die Coroutine-Stapel selbst und die Details der Future / Promise-Implementierung verletzen bereits die Lokalit√§t der Daten.  Es besteht die M√∂glichkeit, die Ausf√ºhrung derselben Coroutine fortzusetzen, wenn Future bereits eine Rolle spielt.  Ein bestimmter Mechanismus ist erforderlich, um die Ausf√ºhrungszeit oder die Anzahl solcher Fortsetzungen zu berechnen, um zu verhindern, dass eine Coroutine die gesamte Prozessorzeit erfasst.  Abh√§ngig von der Gr√∂√üe des Prozessor-Cache und der Anzahl der Threads kann dies entweder kein oder nur ein sehr zweifaches Ergebnis liefern. </p><br><p>  Es gibt noch einen dritten Punkt: Viele Implementierungen von Coroutine-Schedulern erm√∂glichen die Ausf√ºhrung auf verschiedenen Prozessorkernen, was im Gegenteil zu Problemen aufgrund der obligatorischen Synchronisierung beim Zugriff auf gemeinsam genutzte Ressourcen f√ºhrt.  Im Fall eines einzelnen Ereignisschleifenstroms ist eine solche Synchronisation nur auf logischer Ebene erforderlich, da  Jeder synchrone R√ºckrufblock funktioniert garantiert ohne Rennen mit anderen. </p><br><h4 id="mnenie-avtora-vsyo-horosho-v-meru">  Meinung des Autors: Alles ist gut in Ma√üen </h4><br><p>  Das Vorhandensein von Threads in modernen Betriebssystemen negiert nicht die Verwendung einzelner Prozesse.  Durch die Verarbeitung einer gro√üen Anzahl von Clients in der Ereignisschleife wird die Verwendung isolierter "Eisen" -Threads f√ºr andere Anforderungen nicht negiert. </p><br><p>  In jedem Fall erschweren Coroutinen und verschiedene Varianten von Ereignisschleifen den Debugging-Prozess ohne die erforderliche Unterst√ºtzung in den Tools, und mit lokalen Variablen auf dem Coroutine-Stapel wird alles noch schwieriger - es gibt praktisch keine M√∂glichkeit, an sie heranzukommen. </p><br><hr><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2p/pp/lb/2ppplbzrvm8c0yvbasdwrojknss.png" width="326" height="326"></div><br><h2 id="futoin-asyncsteps---alternativa-soprogrammam">  FutoIn AsyncSteps - eine Alternative zu Coroutinen </h2><br><p>  Wir st√ºtzen uns auf das bereits etablierte Event-Loop-Muster und die Organisation von R√ºckrufschemata nach dem Promise-Typ ECMAScript (JavaScript). </p><br><p>  In Bezug auf die Ausf√ºhrungsplanung interessieren uns folgende Aktivit√§ten aus Event Loop: </p><br><ol><li>  <code>Handle immediate(callack)</code> die einen sauberen Aufrufstapel erfordern. </li><li>  Zur√ºckgestellter R√ºckruf <code>Handle deferred(delay, callback)</code> R√ºckruf <code>Handle deferred(delay, callback)</code> . </li><li>  <code>handle.cancel()</code> das R√ºckruf- <code>handle.cancel()</code> . </li></ol><br><p>  So erhalten wir eine Schnittstelle namens <code>AsyncTool</code> , die auf viele Arten implementiert werden kann, auch zus√§tzlich zu bestehenden bew√§hrten Entwicklungen.  Er hat keine direkte Beziehung zum Schreiben von Gesch√§ftslogik, daher werden wir nicht auf weitere Details eingehen. </p><br><h3 id="derevo-shagov">  Baum der Schritte: </h3><br><p>  Im AsyncSteps-Konzept wird ein abstrakter Baum synchroner Schritte aufgereiht und ausgef√ºhrt, indem tief in die Erstellungssequenz hineingegangen wird.  Die Schritte jeder tieferen Ebene werden dynamisch festgelegt, wenn eine solche Passage abgeschlossen ist. </p><br><p>  Die gesamte Interaktion erfolgt √ºber eine einzige <code>AsyncSteps</code> Schnittstelle, die <code>AsyncSteps</code> Konvention als erster Parameter an jeden Schritt √ºbergeben wird.  Konventionell ist der Parametername <code>asi</code> oder veraltet <code>as</code> .  Mit diesem Ansatz k√∂nnen Sie die Verbindung zwischen einer bestimmten Implementierung und dem Schreiben von Gesch√§ftslogik in Plugins und Bibliotheken fast vollst√§ndig trennen. </p><br><p>  In kanonischen Implementierungen erh√§lt jeder Schritt eine eigene Instanz eines Objekts, das <code>AsyncSteps</code> implementiert, wodurch logische Fehler bei der Verwendung der Schnittstelle rechtzeitig verfolgt werden k√∂nnen. </p><br><p>  Abstraktes Beispiel: </p><br><pre> <code class="hljs lua"> asi.add( // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> func( asi ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func"</span></span> ) asi.add( // Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> func( asi ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 func"</span></span> ) asi.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"MyError"</span></span> ) }, onerror( asi, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ){ // Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> catch <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 onerror: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) asi.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) } ) }, onerror( asi, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ){ // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> catch <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 onerror: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> strequal <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) { asi.success( <span class="hljs-string"><span class="hljs-string">"Prm"</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } } ) asi.add( // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">2</span></span> func( asi, str_param, int_param, array_param ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func2: "</span></span> + param ) } )</code> </pre> <br><p>  Ausf√ºhrungsergebnis: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> func <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> func <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> onerror <span class="hljs-number"><span class="hljs-number">1</span></span>: MyError <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> onerror <span class="hljs-number"><span class="hljs-number">1</span></span>: NewError <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> func <span class="hljs-number"><span class="hljs-number">2</span></span>: Prm</code> </pre> <br><p>  Synchron w√ºrde es so aussehen: </p><br><pre> <code class="hljs coffeescript"> str_res, int_res, array_res, bool_res <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func 1"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 func 1"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"MyError"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 onerror 1: "</span></span> + error ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 onerror 1: "</span></span> + error ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( error strequal <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) { str_res = <span class="hljs-string"><span class="hljs-string">"Prm"</span></span> int_res = <span class="hljs-number"><span class="hljs-number">123</span></span> array_res = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] bool_res = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { re-<span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> } } { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func 2: "</span></span> + str_res ) }</code> </pre> <br><p>  Die maximale Nachahmung des herk√∂mmlichen synchronen Codes ist sofort sichtbar, was die Lesbarkeit verbessern soll. </p><br><p>  Aus Sicht der Gesch√§ftslogik w√§chst mit der Zeit ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gro√üer Teil der Anforderungen</a> , aber wir k√∂nnen ihn in leicht verst√§ndliche Teile unterteilen.  Im Folgenden wird das Ergebnis eines vierj√§hrigen Laufens in der Praxis beschrieben. </p><br><h3 id="bazovye-api-vremeni-vypolneniya">  Kernlaufzeit-APIs: </h3><br><ol><li>  <code>add(func[, onerror])</code> - Nachahmung des <code>try-catch</code> . </li><li>  <code>success([args...])</code> - ein expliziter Hinweis auf den erfolgreichen Abschluss: <br><ul><li>  standardm√§√üig impliziert </li><li>  kann die Ergebnisse an den n√§chsten Schritt √ºbergeben. </li></ul></li><li>  <code>error(code[, reason)</code> - Unterbrechung der Ausf√ºhrung mit einem Fehler: <br><ul><li>  <code>code</code> - hat einen Zeichenfolgentyp zur besseren Integration in Netzwerkprotokolle in der Microservice-Architektur. </li><li>  <code>reason</code> - eine willk√ºrliche Erkl√§rung f√ºr eine Person. </li></ul></li><li>  <code>state()</code> - ein Analogon zu Thread Local Storage.  Vordefinierte assoziative Schl√ºssel: <br><ul><li>  <code>error_info</code> - Erkl√§rung des letzten Fehlers f√ºr eine Person, </li><li>  <code>last_exception</code> - Zeiger auf das Objekt der letzten Ausnahme, </li><li>  <code>async_stack</code> - ein Stapel asynchroner Aufrufe, <code>async_stack</code> die Technologie dies zul√§sst, </li><li>  Der Rest wird vom Benutzer festgelegt. </li></ul></li></ol><br><p>  Das vorherige Beispiel enth√§lt bereits echten C ++ - Code und einige zus√§tzliche Funktionen: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/iasyncsteps.hpp&gt; using namespace futoin; void some_api(IAsyncSteps&amp; asi) { asi.add( [](IAsyncSteps&amp; asi) { std::cout &lt;&lt; "Level 0 func 1" &lt;&lt; std::endl; asi.add( [](IAsyncSteps&amp; asi) { std::cout &lt;&lt; "Level 1 func 1" &lt;&lt; std::endl; asi.error("MyError"); }, [](IAsyncSteps&amp; asi, ErrorCode code) { std::cout &lt;&lt; "Level 1 onerror 1: " &lt;&lt; code &lt;&lt; std::endl; asi.error("NewError", "Human-readable description"); } ); }, [](IAsyncSteps&amp; asi, ErrorCode code) { std::cout &lt;&lt; "Level 0 onerror 1: " &lt;&lt; code &lt;&lt; std::endl; if (code == "NewError") { // Human-readable error info assert(asi.state().error_info == "Human-readable description"); // Last exception thrown is also available in state std::exception_ptr e = asi.state().last_exception; // NOTE: smart conversion of "const char*" asi.success("Prm", 123, std::vector&lt;int&gt;({1, 2, 3}, true)); } } ); asi.add( [](IAsyncSteps&amp; asi, const futoin::string&amp; str_res, int int_res, std::vector&lt;int&gt;&amp;&amp; arr_res) { std::cout &lt;&lt; "Level 0 func 2: " &lt;&lt; str_res &lt;&lt; std::endl; } ); }</span></span></span></span></code> </pre> <br><h3 id="api-dlya-sozdaniya-ciklov">  API zum Erstellen von Schleifen: </h3><br><ol><li>  <code>loop( func, [, label] )</code> - Schritt mit einem unendlich wiederholbaren K√∂rper. </li><li>  <code>forEach( map|list, func [, label] )</code> - Schritt-Iteration des Auflistungsobjekts. </li><li>  <code>repeat( count, func [, label] )</code> - Schritt-Iteration angegeben. </li><li>  <code>break( [label] )</code> ist ein Analogon zum herk√∂mmlichen Loop-Interrupt. </li><li>  <code>continue( [label] )</code> ist ein Analogon zur traditionellen Schleifenfortsetzung mit einer neuen Iteration. </li></ol><br><p>  <em>Die Spezifikation bietet alternative Namen <code>breakLoop</code> , <code>continueLoop</code> und andere im Falle eines Konflikts mit reservierten W√∂rtern.</em> </p><br><p>  C ++ Beispiel: </p><br><pre> <code class="cpp hljs"> asi.loop([](IAsyncSteps&amp; asi) { <span class="hljs-comment"><span class="hljs-comment">// infinite loop asi.breakLoop(); }); asi.repeat(10, [](IAsyncSteps&amp; asi, size_t i) { // range loop from i=0 till i=9 (inclusive) asi.continueLoop(); }); asi.forEach( std::vector&lt;int&gt;{1, 2, 3}, [](IAsyncSteps&amp; asi, size_t i, int v) { // Iteration of vector-like and list-like objects }); asi.forEach( std::list&lt;futoin::string&gt;{"1", "2", "3"}, [](IAsyncSteps&amp; asi, size_t i, const futoin::string&amp; v) { // Iteration of vector-like and list-like objects }); asi.forEach( std::map&lt;futoin::string, futoin::string&gt;(), [](IAsyncSteps&amp; asi, const futoin::string&amp; key, const futoin::string&amp; v) { // Iteration of map-like objects }); std::map&lt;std::string, futoin::string&gt; non_const_map; asi.forEach( non_const_map, [](IAsyncSteps&amp; asi, const std::string&amp; key, futoin::string&amp; v) { // Iteration of map-like objects, note the value reference type });</span></span></code> </pre> <br><h3 id="api-integracii-s-vneshnimi-sobytiyami">  API zur Integration mit externen Ereignissen: </h3><br><ol><li>  <code>setTimeout( timeout_ms )</code> - <code>setTimeout( timeout_ms )</code> nach einem Timeout einen <code>Timeout</code> Fehler aus, wenn der Schritt und sein Teilbaum die Ausf√ºhrung nicht abgeschlossen haben. </li><li>  <code>setCancel( handler )</code> - <code>setCancel( handler )</code> , der aufgerufen wird, wenn der Thread vollst√§ndig abgebrochen wird und wenn der Stapel asynchroner Schritte w√§hrend der Fehlerverarbeitung erweitert wird. </li><li>  <code>waitExternal()</code> - ein einfaches Warten auf ein externes Ereignis. <br><ul><li>  <em>Hinweis: Die Verwendung ist nur in Technologien mit einem Garbage Collector sicher.</em> </li></ul></li></ol><br><p>  Ein Aufruf einer dieser Funktionen macht einen expliziten Aufruf von <code>success()</code> erforderlich. </p><br><p>  C ++ Beispiel: </p><br><pre> <code class="cpp hljs"> asi.add([](IAsyncSteps&amp; asi) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> handle = schedule_external_callback([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> err) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { asi.error(<span class="hljs-string"><span class="hljs-string">"ExternalError"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (...) { <span class="hljs-comment"><span class="hljs-comment">// pass } } else { asi.success(); } }); asi.setCancel([=](IAsyncSteps&amp; asi) { external_cancel(handle); }); }); asi.add( [](IAsyncSteps&amp; asi) { // Raises Timeout error after specified period asi.setTimeout(std::chrono::seconds{10}); asi.loop([](IAsyncSteps&amp; asi) { // infinite loop }); }, [](IAsyncSteps&amp; asi, ErrorCode code) { if (code == futoin::errors::Timeout) { asi(); } });</span></span></code> </pre> <br><p>  ECMAScript-Beispiel: </p><br><pre> <code class="javascript hljs">asi.add( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">asi</span></span></span><span class="hljs-function">) =&gt;</span></span> { asi.waitExternal(); <span class="hljs-comment"><span class="hljs-comment">// disable implicit success() some_obj.read( (err, data) =&gt; { if (!asi.state) { // ignore as AsyncSteps execution got canceled } else if (err) { try { asi.error( 'IOError', err ); } catch (_) { // ignore error thrown as there are no // AsyncSteps frames on stack. } } else { asi.success( data ); } } ); } );</span></span></code> </pre> <br><h3 id="api-integracii-s-futurepromise">  Future / Promise Integration API: </h3><br><ol><li>  <code>await(promise_future[, on_error])</code> - Warten auf Zukunft / Versprechen als Schritt. </li><li>  <code>promise()</code> - verwandelt den gesamten Ausf√ºhrungsfluss in Future / Promise, das anstelle von <code>execute()</code> . </li></ol><br><p>  C ++ Beispiel: </p><br><pre> <code class="hljs pgsql"> [](IAsyncSteps&amp; asi) { // Proper way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> AsyncSteps instances // <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> hard dependency <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> implementation. auto new_steps = asi.newInstance(); new_steps-&gt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([](IAsyncSteps&amp; asi) {}); // Can be <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> outside <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AsyncSteps event <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> // new_steps.promise().wait(); // <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> // new_steps.promise&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(); // Proper way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> standard std::future asi.await(new_steps-&gt;promise()); // Ensure instance lifetime asi.state()["some_obj"] = std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(new_steps); };</code> </pre> <br><h3 id="api-kontrolya-potoka-vypolneniya-biznes-logiki">  API zur Steuerung des Gesch√§ftslogikflusses: </h3><br><ol><li>  <code>AsyncSteps(AsyncTool&amp;)</code> ist ein Konstruktor, der einen Ausf√ºhrungsthread an eine bestimmte Ereignisschleife bindet. </li><li>  <code>execute()</code> - Startet den Ausf√ºhrungsthread. </li><li>  <code>cancel()</code> - Bricht den Ausf√ºhrungsthread ab. </li></ol><br><p>  Hier ist bereits eine spezifische Schnittstellenimplementierung erforderlich. </p><br><p>  C ++ Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/ri/asyncsteps.hpp&gt; #include &lt;futoin/ri/asynctool.hpp&gt; void example() { futoin::ri::AsyncTool at; futoin::ri::AsyncSteps asi{at}; asi.loop([&amp;](futoin::IAsyncSteps &amp;asi){ // Some infinite loop logic }); asi.execute(); std::this_thread::sleep_for(std::chrono::seconds{10}); asi.cancel(); // called in d-tor by fact }</span></span></span></span></code> </pre> <br><h3 id="prochie-api">  andere APIs: </h3><br><ol><li>  <code>newInstance()</code> - Erm√∂glicht das Erstellen eines neuen Ausf√ºhrungsthreads ohne direkte Abh√§ngigkeit von der Implementierung. </li><li>  <code>sync(object, func, onerror)</code> - das gleiche, jedoch mit Synchronisation relativ zu einem Objekt, das die entsprechende Schnittstelle implementiert. </li><li>  <code>parallel([on_error])</code> - spezielles <code>add()</code> , dessen Teilschritte separate AsyncSteps-Streams sind: <br><ul><li>  Alle Threads haben den gemeinsamen <code>state()</code> . </li><li>  Der √ºbergeordnete Thread setzt die Ausf√ºhrung nach Abschluss aller untergeordneten Threads fort </li><li>  Ein nicht erfasster Fehler in einem untergeordneten Element l√∂scht sofort alle anderen untergeordneten Threads. </li></ul></li></ol><br><p>  C ++ - Beispiele: </p><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/ri/mutex.hpp&gt; using namespace futoin; ri::Mutex mtx_a; void sync_example(IAsyncSteps&amp; asi) { asi.sync(mtx_a, [](IAsyncSteps&amp; asi) { // synchronized section asi.add([](IAsyncSteps&amp; asi) { // inner step in the section // This synchronization is NOOP for already // acquired Mutex. asi.sync(mtx_a, [](IAsyncSteps&amp; asi) { }); }); }); } void parallel_example(IAsyncSteps&amp; asi) { using OrderVector = std::vector&lt;int&gt;; asi.state("order", OrderVector{}); auto&amp; p = asi.parallel([](IAsyncSteps&amp; asi, ErrorCode) { // Overall error handler asi.success(); }); p.add([](IAsyncSteps&amp; asi) { // regular flow asi.state&lt;OrderVector&gt;("order").push_back(1); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(4); }); }); p.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(2); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(5); asi.error("SomeError"); }); }); p.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(3); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(6); }); }); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order"); // 1, 2, 3, 4, 5 }); };</span></span></span></span></code> </pre> <br><h3 id="standartnye-primitivy-dlya-sinhronizacii">  Standardprimitive f√ºr die Synchronisation </h3><br><ol><li>  <code>Mutex</code> - schr√§nkt die gleichzeitige Ausf√ºhrung von <code>N</code> Threads mit einer Warteschlange in <code>Q</code> , standardm√§√üig <code>N=1, Q=unlimited</code> . </li><li>  <code>Throttle</code> - begrenzt die Anzahl der Eing√§nge <code>N</code> in Periode <code>P</code> mit einer Warteschlange in <code>Q</code> , standardm√§√üig <code>N=1, P=1s, Q=0</code> . </li><li>  <code>Limiter</code> ist eine Kombination aus <code>Mutex</code> und <code>Throttle</code> , die normalerweise bei der Eingabe der Verarbeitung externer Anforderungen und beim Aufrufen externer Systeme zum Zwecke eines stabilen Betriebs unter Last verwendet wird. </li></ol><br><p>  Bei <code>DefenseRejected</code> Warteschlangenlimits wird ein <code>DefenseRejected</code> Fehler <code>DefenseRejected</code> , dessen Bedeutung aus der <code>Limiter</code> Beschreibung hervorgeht. </p><br><h3 id="klyuchevye-preimuschestva">  Hauptvorteile </h3><br><p>  Das Konzept von AsyncSteps war kein Selbstzweck, sondern entstand aus der Notwendigkeit einer kontrollierten asynchronen Ausf√ºhrung von Programmen hinsichtlich Zeitlimit, Abbruch und Gesamtkonnektivit√§t einzelner R√ºckrufe.  Keine der universellen L√∂sungen zu dieser Zeit und bietet jetzt die gleiche Funktionalit√§t.  Deshalb: </p><br><p> <strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> FTN12</a>   </strong> ‚Äî           . </p><br><p> <strong>  <code>setCancel()</code></strong> ‚Äî                    .       ,     .   RAII  <code>atexit()</code>   . </p><br><p> <strong>   <code>cancel()</code></strong> ‚Äî     ,         .   <code>SIGTERM</code>  <code>pthread_cancel()</code> ,       . </p><br><p> <strong>   <code>setTimeout()</code></strong> ‚Äî                 .    ,    "Timeout". </p><br><p> <strong>     </strong> ‚Äî  FutoIn AsyncSteps             . </p><br><p> <strong>      </strong> ‚Äî          ABI     ,    .    Embedded     MMU. </p><br><hr><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yj/8x/wv/yj8xwvibm7tjsj30qhojwbleige.jpeg"></div><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em> </em></a> </p><br><h2 id="k-cifram">   </h2><br><p>    Intel Xeon E3-1245v2/DDR1333  Debian Stretch    . </p><br><p>   : </p><br><ol><li> Boost.Fiber  <code>protected_fixedsize_stack</code> . </li><li> Boost.Fiber  <code>pooled_fixedsize_stack</code>     . </li><li> FutoIn AsyncSteps   . </li><li> FutoIn AsyncSteps      ( <code>FUTOIN_USE_MEMPOOL=false</code> ). <br><ul><li>      <code>futoin::IMemPool</code> . </li></ul></li><li> FutoIn NitroSteps&lt;&gt; ‚Äî           . <br><ul><li>         . </li></ul></li></ol><br><p>    Boost.Fiber    : </p><br><ol><li>     1 . . </li><li>       30 .   1 . . <br><ul><li>   30 .     <code>mmap()/mprotect()</code>  <code>boost::fiber::protected_fixedsize_stack</code> . </li><li>          . </li></ul></li><li>   30 .   10 .     . <br><ul><li>    ""          . </li></ul></li></ol><br><p>      "" , ..     ,       .        .   . </p><br><p>    GCC 6.3.0.   lang  tcmalloc  ,     . </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitLab</a> . </p><br><h3 id="1-posledovatelnoe-sozdanie"> 1.   </h3><br><table><thead><tr><th>  </th><th>  Zeit </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 4.8s </td><td> 208333.333Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 0.23s </td><td> 4347826.086Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>0.21s</strong> </td><td> <strong>4761904.761Hz</strong> </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 0.31s </td><td> 3225806.451Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> 0.255s </td><td> 3921568.627Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qm/ur/y6/qmury65-mbkth_om8smkfi7vamq.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>     Boost.Fiber -      ,     <code>pooled_fixedsize_stack</code>   ,    AsyncSteps. </p><br><h3 id="2-parallelnoe-sozdanie-i-ispolnenie"> 2.     </h3><br><table><thead><tr><th>  </th><th>  Zeit </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 6.31s </td><td> 158478.605Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 1.558s </td><td> 641848.523Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>1.13s</strong> </td><td> <strong>884955.752Hz</strong> </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 1.353s </td><td> 739098.300Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> 1.43s </td><td> 699300.699Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0s/gz/lu/0sgzlur2xsrlf-wo4mrcynvzhxi.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>    ,          .    ,        ‚Äî            . </p><br><h3 id="3-parallelnye-cikly"> 3.   </h3><br><table><thead><tr><th>  </th><th>  Zeit </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 5.096s </td><td> 1962323.390Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 5.077s </td><td> 1969667.126Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> 5.361s </td><td> 1865323.633Hz </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 8.288s </td><td> 1206563.706Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> <strong>3.68s</strong> </td><td> <strong>2717391.304Hz</strong> </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/c1/17/pbc117djqds0d4twh5fzcklsmfc.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>   ,        Boost.Fiber      AsyncSteps,    NitroSteps. </p><br><h3 id="ispolzovanie-pamyati-po-rss">   ( RSS) </h3><br><table><thead><tr><th>  </th><th>  Die Erinnerung </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 124M </td></tr><tr><td> Boost.Fiber pooled </td><td> 505M </td></tr><tr><td> FutoIn AsyncSteps </td><td> 124M </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> <strong>84M</strong> </td></tr><tr><td> FutoIn NitroSteps </td><td> 115M </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/w0/6n/olw06nef5wj3ah1lo9u-pby9sfg.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>  , Boost.Fiber  . </p><br><h3 id="bonus-testy-na-nodejs"> :   Node.js </h3><br><p>      -  <code>Promise</code> : +    10 . .   10 .          JIT  <code>NODE_ENV=production</code> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>@futoin/optihelp</code></a> . </p><br><p>      <a href="">GitHub</a>  <a href="">GitLab</a> .   Node.js v8.12.0  v10.11.0,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FutoIn CID</a> . </p><br><table><thead><tr><th> Tech </th><th> Simple </th><th> Loop </th></tr></thead><tbody><tr><td> <strong>Node.js v10</strong> </td><td></td><td></td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>1342899.520Hz</strong> </td><td> 587.777Hz </td></tr><tr><td> async/await </td><td> 524983.234Hz </td><td> <strong>630.863Hz</strong> </td></tr><tr><td> <strong>Node.js v8</strong> </td><td></td><td></td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>682420.735Hz</strong> </td><td> <strong>588.336Hz</strong> </td></tr><tr><td> async/await </td><td> 365050.395Hz </td><td> 400.575Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/x7/-n/b5/x7-nb5v9dfkwn1lttyg67w2b_tk.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gh/yj/9p/ghyj9pczw0smbfksq-aad_tltay.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>   <code>async/await</code> ? ,   V8  Node.js v10       . </p><br><p>  ,   Promise  <code>async/await</code> <strong></strong> Node.js Event Loop.          ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ),   FutoIn AsyncSteps   . </p><br><p> <em>   AsyncSteps  Node.js Event Loop      <code>async/await</code>  -  Node.js v10.</em> </p><br><p> <em>,      ++   ‚Äî    .  ,    Node.js    10 .</em> </p><br><h3 id="vyvody">  Schlussfolgerungen </h3><br><p>   C++, FutoIn AsyncSteps  Boost.Fiber       ,     Boost.Fiber         <code>mmap()/mprotect</code> . </p><br><p>       ,      -      ,   .     . </p><br><p> FutoIn AsyncSteps  JavaScript  <code>async/await</code>       Node.js v10. </p><br><p>   ,       -,       .        . </p><br><p>   -                        ""  .     ‚Äî   API. </p><br><hr><br><h2 id="zaklyuchenie">  Fazit </h2><br><p> ,  FutoIn AsyncSteps ,          "" <code>async/await</code> . ,         .      <code>Promise</code>  ECMAScript, AsyncSteps    ""           . </p><br><p>               .        AsyncSteps  NitroSteps   . </p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,    - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br><p>       Java/JVM         ‚Äî    .    . </p><br><p>      ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitLab</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424311/">https://habr.com/ru/post/de424311/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424297/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 9: Sicherheit von Webanwendungen, Teil 3</a></li>
<li><a href="../de424301/index.html">Adaptiver neuronaler Netzwerkbildfilteralgorithmus</a></li>
<li><a href="../de424305/index.html">Plattform√ºbergreifende RIBs f√ºr die mobile Architektur von Uber</a></li>
<li><a href="../de424307/index.html">GitLab 11.3 wurde mit Maven-Repository und sicheren Umgebungen ver√∂ffentlicht</a></li>
<li><a href="../de424309/index.html">DevCore: Software-Teil des DevBoy-Projekts</a></li>
<li><a href="../de424313/index.html">EveryLang ist ein Programm, das fast alles kann</a></li>
<li><a href="../de424315/index.html">Eine neue Runde der Importsubstitution. Wo laufen und was tun?</a></li>
<li><a href="../de424319/index.html">Die Struktur des Online-Shops. Teil 2</a></li>
<li><a href="../de424321/index.html">NetFlow billig und w√ºtend machen</a></li>
<li><a href="../de424323/index.html">Ein Beispiel f√ºr die Arbeit mit der ICE-Methode aus dem Produktmanager von Google und Microsoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>