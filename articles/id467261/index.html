<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🔧 🌋 🧝🏽 Threading yang tepat dalam Qt 🍶 😚 🤳🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt adalah kerangka kerja yang sangat kuat dan nyaman untuk C ++. Tetapi kemudahan ini memiliki kerugian: cukup banyak hal di Qt terjadi tersembunyi da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Threading yang tepat dalam Qt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467261/">  Qt adalah kerangka kerja yang sangat kuat dan nyaman untuk C ++.  Tetapi kemudahan ini memiliki kerugian: cukup banyak hal di Qt terjadi tersembunyi dari pengguna.  Dalam kebanyakan kasus, fungsionalitas yang sesuai di Qt bekerja “secara ajaib” dan itu mengajarkan pengguna untuk hanya menerima keajaiban ini begitu saja.  Namun, ketika sihir tetap rusak, sangat sulit untuk mengenali dan memecahkan masalah yang tiba-tiba muncul pada tingkat yang tampaknya datar. <br><br>  Artikel ini adalah upaya untuk mensistematisasikan bagaimana Qt "di bawah tenda" mengimplementasikan bekerja dengan aliran dan tentang sejumlah perangkap tersembunyi yang terkait dengan keterbatasan model ini. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dasar-dasarnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Afinitas utas, inisialisasi, dan batasannya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Utas utama, QCoreApplication, dan GUI</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rendering thread</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> <br><br><a name="habracut"></a><a name="part1"></a><h3>  Dasar-dasarnya </h3><br>  Mari kita mulai dengan dasar-dasarnya.  Dalam Qt, objek apa pun yang mampu menangani sinyal dan slot adalah turunan dari kelas QObject.  Objek-objek ini dengan desain tidak dapat disalin dan secara logis mewakili beberapa entitas individu yang “berbicara” satu sama lain - bereaksi terhadap peristiwa tertentu dan dapat dengan sendirinya menghasilkan peristiwa.  Dengan kata lain, QObject di Qt mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pola Aktor</a> .  Jika diimplementasikan dengan benar, setiap program Qt pada dasarnya tidak lebih dari jaringan QObjects yang saling berinteraksi di mana semua logika program "hidup". <br><br>  Selain satu set QObjects, program Qt dapat menyertakan objek data.  Objek-objek ini tidak dapat menghasilkan dan menerima sinyal, tetapi dapat disalin.  Misalnya, Anda dapat membandingkan QStringList dan QStringListModel di antara mereka.  Salah satunya adalah QObject dan tidak dapat disalin, tetapi dapat langsung berinteraksi dengan objek UI, yang lainnya adalah wadah yang dapat disalin secara teratur untuk data.  Pada gilirannya, objek dengan data dibagi menjadi "Qt Meta-types" dan yang lainnya.  Sebagai contoh, QStringList adalah tipe-Qt Meta, tetapi std :: list &lt;std :: string&gt; (tanpa gerakan tambahan) tidak.  Yang pertama dapat digunakan dalam konteks Qt-shnom apa saja (ditransmisikan melalui sinyal, berbaring di QVariant, dll.), Tetapi memerlukan prosedur pendaftaran khusus dan kelas harus memiliki destruktor publik, copy constructor, dan konstruktor default.  Yang kedua adalah tipe C ++ sewenang-wenang. <br><br><a name="part2"></a><h3>  Pindah mulus ke utas sebenarnya </h3><br>  Jadi, kami memiliki "data" bersyarat dan ada "kode" bersyarat yang bekerja dengannya.  Tetapi siapa yang benar-benar akan menjalankan kode ini?  Dalam model Qt, jawaban untuk pertanyaan ini ditetapkan secara eksplisit: setiap QObject secara ketat terikat pada beberapa utas QThread yang, pada kenyataannya, terlibat dalam slot servis dan peristiwa lain dari objek ini.  Satu utas dapat melayani banyak QObject sekaligus, atau tidak sama sekali, tetapi QObject selalu memiliki utas induk dan selalu tepat satu.  Faktanya, kita dapat mengasumsikan bahwa setiap QThread "memiliki" beberapa set QObject.  Dalam terminologi Qt, ini disebut Thread Affinity.  Mari kita coba visualisasikan untuk kejelasan: <br><br><img src="https://habrastorage.org/webt/zs/py/t2/zspyt2yti1t8-mr6k708rer0rao.png"><br><br>  Di dalam setiap QThread adalah antrian pesan yang ditujukan ke objek yang dimiliki oleh QThread ini.  Model Qt mengasumsikan bahwa jika kita ingin QObject mengambil tindakan, maka kita akan "mengirim" pesan QEvent ke QObject ini: <br><br><pre><code class="cpp hljs">QCoreApplication::postEvent(QObject *receiver, QEvent *event, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority);</code> </pre> <br>  Dalam panggilan aman thread ini, Qt menemukan QThread yang menjadi objek penerima, menulis QEvent ke antrian pesan utas ini, dan membangunkan utas ini jika perlu.  Diharapkan kode yang berjalan di QThread ini di beberapa titik setelah itu akan membaca pesan dari antrian dan melakukan tindakan yang sesuai.  Agar hal ini benar-benar terjadi, kode di QThread harus masuk ke loop acara QEventLoop, membuat objek yang sesuai dan memanggilnya dengan metode exec () atau metode processEvents ().  Opsi pertama memasuki loop pemrosesan pesan tanpa akhir (sebelum QEventLoop menerima acara berhenti ()), yang kedua terbatas untuk memproses pesan yang sebelumnya terakumulasi dalam antrian. <br><br><img src="https://habrastorage.org/webt/8x/ia/6o/8xia6o7i8wf0q5hoxkvzdjsl9xq.png"><br><br>  Sangat mudah untuk melihat bahwa peristiwa untuk semua objek milik satu utas diproses secara berurutan.  Jika pemrosesan suatu peristiwa oleh utas membutuhkan waktu yang lama, maka semua objek lain akan "dibekukan" - acara mereka akan terakumulasi dalam antrian aliran, tetapi tidak akan diproses.  Untuk mencegah hal ini terjadi, Qt menyediakan kemungkinan multitasking kooperatif - event handler di mana saja dapat "sementara menginterupsi" dengan membuat QEventLoop baru dan memberikan kontrol padanya.  Karena event handler sebelumnya juga dipanggil dari QEventLoop di stream, dengan pendekatan ini, rantai loop acara "bersarang" di satu sama lain terbentuk. <br><br><div class="spoiler">  <b class="spoiler_title">Beberapa kata tentang Event Dispatcher</b> <div class="spoiler_text">  Sebenarnya, QEventLoop tidak lebih dari pembungkus ramah-pengguna atas primitif yang bergantung pada sistem tingkat rendah yang disebut Event Dispatcher dan mengimplementasikan antarmuka QAbstractEventDispatcher.  Dialah yang melakukan pengumpulan aktual dan pengolahan acara.  Utas hanya dapat memiliki satu QAbstractEventDispatcher dan hanya dipasang sekali.  Antara lain, dimulai dengan Qt5, ini memungkinkan Anda untuk dengan mudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengganti dispatcher dengan yang lebih cocok</a> jika perlu dengan menambahkan hanya 1 baris ke inisialisasi aliran dan tanpa menyentuh banyak tempat yang berpotensi banyak tempat QEventLoop digunakan. </div></div><br>  Apa yang termasuk dalam konsep "peristiwa" yang diproses dalam siklus semacam itu?  Terkenal bagi semua karyawan Qt, "sinyal" hanyalah satu contoh khusus, QEvent :: MetaCall.  QEvent seperti menyimpan pointer ke informasi yang diperlukan untuk mengidentifikasi fungsi (slot) yang perlu dipanggil dan argumennya.  Namun, selain sinyal di Qt, ada sekitar seratus (!) Peristiwa lainnya, di mana selusin dicadangkan untuk acara Qt khusus (ChildAdded, DeferredDelete, ParentChange) dan sisanya sesuai dengan berbagai pesan dari sistem operasi. <br><br><div class="spoiler">  <b class="spoiler_title">Mengapa ada begitu banyak dari mereka dan mengapa itu tidak mungkin dilakukan tanpa sinyal?</b> <div class="spoiler_text">  Pembaca mungkin bertanya: mengapa ada begitu banyak peristiwa dan mengapa tidak mungkin bertahan hanya dengan satu mekanisme sinyal yang nyaman dan universal?  Faktanya adalah bahwa sinyal yang berbeda dapat diproses dengan sangat berbeda.  Misalnya, beberapa sinyal dapat dikompresi - jika antrian sudah memiliki satu pesan mentah dari jenis ini (katakanlah QEvent :: Paint), maka pesan berikutnya cukup memodifikasinya.  Sinyal lain dapat disaring.  Kehadiran sejumlah kecil QEvents standar dan mudah diidentifikasi secara signifikan menyederhanakan pemrosesan yang sesuai.  Selain itu, pemrosesan QEvent karena perangkat yang terasa lebih sederhana biasanya dilakukan agak lebih cepat daripada pemrosesan sinyal yang sama. </div></div><br>  Salah satu perangkap tersembunyi di sini adalah bahwa di Qt, streaming, secara umum, bahkan mungkin tidak memiliki Dispatcher, dan karena itu bukan EventLoop tunggal.  Objek yang termasuk dalam aliran ini tidak akan menanggapi acara yang dikirimkan kepadanya.  Karena QThread :: run () oleh panggilan default QThread :: exec () di mana EventLoop standar baru saja dilaksanakan, mereka yang sering mencoba untuk menentukan versi run () mereka sendiri yang diwarisi dari QThread sering menghadapi masalah ini.  Kasus penggunaan yang serupa untuk QThread pada prinsipnya cukup valid dan bahkan direkomendasikan dalam dokumentasi, tetapi bertentangan dengan ide umum mengatur kode dalam Qt yang dijelaskan di atas dan seringkali tidak berfungsi seperti yang <i>diharapkan</i> pengguna.  Kesalahan umum dalam kasus ini adalah upaya untuk menghentikan QThread kustom dengan memanggil QThread :: exit () atau exit ().  Kedua fungsi ini mengirim pesan ke QEventLoop, tetapi jika tidak ada QEventLoop di stream, maka secara alami tidak ada yang memprosesnya.  Akibatnya, pengguna yang tidak berpengalaman mencoba untuk "memperbaiki kelas yang rusak" mulai mencoba untuk menggunakan "bekerja" QThread :: terminate, yang sama sekali tidak mungkin.  Ingat - jika Anda mendefinisikan ulang run () dan tidak menggunakan loop acara standar, maka Anda harus menyediakan mekanisme untuk keluar dari utas sendiri - misalnya, menggunakan fungsi QThread :: requestInterrupt () yang ditambahkan secara khusus untuk ini.  Akan tetapi, lebih tepat untuk tidak mewarisi dari QThread jika Anda tidak benar-benar akan mengimplementasikan beberapa jenis utas baru dan menggunakan QtConcurrent yang dibuat khusus untuk skrip tersebut, atau menempatkan logika dalam Obyek Pekerja khusus yang diwarisi dari QObject, letakkan yang terakhir dalam QThbread standar dan kelola Pekerja menggunakan sinyal. <br><br><a name="part3"></a><h3>  Afinitas utas, inisialisasi, dan batasannya </h3><br>  Jadi, seperti yang telah kita ketahui, setiap objek di Qt "milik" ke aliran tertentu.  Pada saat yang sama, muncul pertanyaan logis: yang sebenarnya?  Kebaktian berikut diterima di Qt: <br><br>  <b>1. Semua "anak-anak" dari setiap "orang tua" selalu hidup dalam aliran yang sama dengan orang tua</b> <br><br>  Ini mungkin batasan paling kuat dari model aliran Qt, dan upaya untuk memutusnya sering memberikan hasil yang sangat aneh bagi pengguna.  Misalnya, upaya membuat setParent pada objek yang hidup di utas lain di Qt gagal diam-diam (peringatan ditulis ke konsol).  Tampaknya, kompromi ini tercapai karena fakta bahwa penghapusan “anak-anak” yang aman dari benang dalam kasus kematian orang tua yang tinggal di utas lain adalah sangat tidak sepele dan cenderung sulit untuk menangkap serangga.  Jika Anda ingin menerapkan hierarki objek yang berinteraksi yang hidup dalam aliran yang berbeda, Anda harus mengatur penghapusan sendiri. <br><br>  <b>2. Objek yang orang tuanya tidak ditentukan selama pembuatan tinggal di aliran yang membuatnya</b> <br><br>  Semua yang ada di sini pada saat yang sama dan sederhana dan pada saat yang sama tidak selalu jelas.  Misalnya, berdasarkan aturan ini, QThread (sebagai objek) hidup di utas berbeda dari utas yang dikontrol sendiri (dan berdasarkan aturan 1, ia tidak dapat memiliki objek apa pun yang dibuat dalam utas ini).  Atau, katakanlah, jika Anda mendefinisikan ulang QThread :: menjalankan dan membuat turunan QObject di dalamnya, maka tanpa mengambil tindakan khusus (seperti yang dibahas pada bab sebelumnya), objek yang dibuat tidak akan menanggapi sinyal. <br><br>  Afinitas utas dapat diubah jika perlu dengan memanggil QObject :: moveToThread.  Berdasarkan aturan 1, hanya "orang tua" tingkat atas (yang orang tuanya == null) dapat dipindahkan, upaya untuk memindahkan "anak" mana pun akan diabaikan dalam hati.  Ketika "orang tua" tingkat atas bergerak, semua "anak-anaknya" juga akan pindah ke aliran baru.  Anehnya, panggilan untuk memindahkanToThread (nullptr) juga sah dan merupakan cara untuk membuat objek dengan afinitas utas “nol”;  objek semacam itu tidak dapat menerima pesan apa pun. <br><br>  Anda bisa mendapatkan utas eksekusi "saat ini" melalui panggilan ke fungsi QThread :: currentThread (), utas yang terkait dengan objek - melalui panggilan ke QObject :: utas () <br><br><div class="spoiler">  <b class="spoiler_title">Sebuah pertanyaan menarik tentang perhatian</b> <div class="spoiler_text">  Perhatikan bahwa implementasi fungsional kepemilikan objek dan penyimpanan QEvents yang ditujukan kepada mereka, jelas, membutuhkan aliran untuk menyimpan data terkait di suatu tempat.  Dalam kasus Qt, kelas dasar QThread biasanya terlibat dalam ekstraksi dan pengelolaan data tersebut.  Tetapi apa yang terjadi jika Anda membuat QObject di beberapa std :: thread atau memanggil fungsi QThread :: currentThread () dari utas ini?  Ternyata dalam hal ini Qt secara implisit "di belakang layar" akan membuat objek pembungkus khusus yang tidak memiliki QAdoptedThread.  Pada saat yang sama, adalah kewajiban pengguna untuk secara independen memastikan bahwa semua objek dalam aliran tersebut dihapus sebelum aliran yang dihasilkannya dihentikan. <br></div></div><br><a name="part4"></a><h3>  Utas utama, QCoreApplication, dan GUI </h3><br>  Di antara semua utas, Qt pasti akan memilih satu "utas utama", yang dalam hal aplikasi UI juga menjadi utas GUI.  Dalam utas ini tinggal objek QApplication (QCoreApplication / QGuiApplication) yang melayani loop peristiwa utama yang berorientasi untuk bekerja dengan pesan dari sistem operasi.  Berdasarkan aturan No. 2 dari bagian sebelumnya, dalam praktiknya, utas “utama” akan menjadi yang benar-benar membuat objek QApplication, dan karena dalam banyak sistem operasi “utas utama” memiliki makna khusus, dokumentasi sangat menyarankan untuk membuat Aplikasi Q dengan objek pertama di keseluruhan Qt memprogram dan melakukannya segera setelah memulai aplikasi (== di dalam utas pertama dalam proses).  Untuk mendapatkan pointer ke utas utama aplikasi, masing-masing, Anda dapat menggunakan konstruksi formulir QCoreApplication :: instance () -&gt; utas ().  Namun, murni secara teknis, aplikasi QApplication <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">juga dapat digantung di non-main ()</a> , misalnya, jika antarmuka Qt dibuat di dalam semacam plug-in dan dalam banyak kasus ini akan berfungsi dengan baik. <br><br>  Karena aturan "objek yang dibuat mewarisi utas saat ini", Anda selalu dapat bekerja dengan tenang tanpa melampaui batas satu utas.  Semua objek yang dibuat akan secara otomatis pergi ke utas “utama” untuk diservis, di mana akan selalu ada loop peristiwa dan (karena tidak ada utas lainnya) tidak akan pernah ada masalah dengan sinkronisasi.  Bahkan jika Anda bekerja dengan sistem yang lebih kompleks yang membutuhkan multithreading, sebagian besar objek kemungkinan besar akan jatuh ke aliran utama, dengan pengecualian beberapa yang akan secara eksplisit ditempatkan di tempat lain.  Mungkin justru keadaan inilah yang memunculkan "keajaiban" di mana benda-benda tampak bekerja secara mandiri tanpa usaha (karena multitasking kooperatif diterapkan dalam aliran) dan pada saat yang sama tidak memerlukan sinkronisasi, pemblokiran, atau sejenisnya (karena semuanya terjadi dalam satu utas ) <br><br>  Selain fakta bahwa utas "utama" adalah utas "pertama" dan berisi loop pemrosesan acara QCoreApplication utama, karakteristik batasan lain dari Qt adalah bahwa semua objek yang terhubung dengan GUI harus "hidup" di utas ini.  Ini sebagian merupakan konsekuensi dari Legacy: karena fakta bahwa dalam sejumlah sistem operasi, operasi dengan GUI hanya dapat terjadi di utas utama, Qt membagi semua objek menjadi "widget" dan "non-widget".  Objek tipe widget hanya dapat hidup di utas utama, upaya untuk "lebih besar" dari objek lain yang secara otomatis akan menyala.  Berdasarkan hal ini, bahkan ada metode QObject :: isWidgetType () khusus yang mencerminkan perbedaan internal yang agak dalam dalam mekanisme kerja dengan objek tersebut.  Tetapi menarik bahwa di QtQuick yang jauh lebih baru, di mana mereka mencoba melepaskan diri dari kruk dengan isWidgetType, masalah yang sama tetap ada <br><br>  Ada apa?  Di Qt5, objek QML bukan lagi widget dan dapat dirender di utas terpisah.  Tapi ini menyebabkan masalah lain - kesulitan sinkronisasi.  Rendering objek UI adalah "pembacaan" dari keadaannya dan harus konsisten: jika kita mencoba mengubah keadaan suatu objek pada saat bersamaan dengan renderingnya, hasil dari "balapan" yang dihasilkan mungkin tidak menyenangkan kita.  Selain itu, OpenGL di mana Qt grafis "baru" dibangun sangat "dipertajam" dengan fakta bahwa pembentukan perintah menggambar dilakukan oleh satu utas yang bekerja dengan beberapa negara global - "konteks grafis" yang hanya dapat berubah sebagai serangkaian operasi berurutan.  Kita tidak bisa secara bersamaan menggambar dua objek grafik yang berbeda di layar - mereka akan selalu digambar berurutan.  Sebagai hasilnya, kami kembali ke solusi yang sama - rendering UI ditugaskan ke satu utas.  Namun, pembaca yang penuh perhatian akan melihat bahwa utas ini tidak harus menjadi utas utama - dan pada Qt5 kerangka kerja akan benar-benar mencoba menggunakan utas Rendering terpisah untuk ini. <br><br><a name="part5"></a><h3>  Rendering thread </h3><br>  Dalam kerangka model Qt5 baru, semua rendering objek terjadi di utas yang dialokasikan khusus untuk ini, utas rendering.  Selain itu, agar masuk akal dan tidak terbatas hanya beralih dari satu "utama" aliran ke yang lain, objek secara implisit dibagi menjadi "front-end" yang programmer lihat dan biasanya "back-end" tersembunyi darinya yang benar-benar melakukan rendering yang sebenarnya.  Ujung belakang hidup di utas render, sedangkan ujung depan, secara teoritis, dapat hidup di utas lainnya.  Diasumsikan bahwa front-end melakukan pekerjaan yang berguna (jika ada) dalam bentuk pemrosesan peristiwa, sedangkan fungsi back-end hanya dibatasi oleh rendering.  Secara teori, ternyata win-win: punggung secara berkala "polling" keadaan saat ini dari objek dan menarik mereka di layar, sementara itu tidak dapat "dihentikan" oleh fakta bahwa beberapa objek "berpikir" terlalu banyak saat memproses acara karena fakta bahwa ini pemrosesan lambat terjadi di utas lain.  Pada gilirannya, aliran objek tidak perlu menunggu "jawaban" dari driver grafis yang mengkonfirmasi penyelesaian render, dan objek yang berbeda dapat bekerja dalam aliran yang berbeda. <br><br>  Tetapi seperti yang telah saya sebutkan di bab sebelumnya, karena kita memiliki aliran yang membuat data (depan) dan aliran yang membacanya (belakang), kita perlu menyinkronkannya.  Sinkronisasi di Qt ini dilakukan dengan kunci.  Aliran tempat bagian depan ditangguhkan sementara, diikuti oleh pemanggilan fungsi khusus (QQuickItem :: updatePaintNode (), QQuickFramebufferObject :: Renderer :: sinkronisasi ()) yang tugasnya hanya menyalin objek yang relevan untuk memvisualisasikan keadaan dari depan ke belakang. ".  Dalam kasus ini, pemanggilan fungsi semacam itu terjadi <i>di dalam utas render</i> , tetapi karena fakta bahwa utas tempat objek saat ini dihentikan, pengguna dapat dengan bebas bekerja dengan data objek seolah-olah itu terjadi "seperti biasa", di dalam aliran tempat benda tersebut berada. <br><br>  Apakah semuanya baik-baik saja, semuanya baik-baik saja?  Sayangnya, tidak, dan saat-saat yang sangat tidak jelas mulai di sini.  Jika kita mengambil kunci secara terpisah untuk masing-masing objek, itu akan agak lambat karena thread rendering akan dipaksa untuk menunggu sampai objek ini selesai memproses acara mereka.  Aliran "hang" di mana objek tinggal adalah "hang" dan rendering.  Selain itu, "desync" akan menjadi mungkin ketika, ketika dua objek diubah secara bersamaan, satu akan digambar dalam frame N dan yang lainnya akan digambar hanya dalam frame N +1.  Akan lebih baik untuk mengambil kunci hanya sekali dan untuk semua objek sekaligus dan hanya ketika kami yakin bahwa kunci ini akan berhasil. <br><br>  Apa yang diterapkan untuk mengatasi masalah ini di Qt?  Pertama, diputuskan bahwa semua objek "grafik" dari satu jendela akan hidup dalam satu aliran.  Jadi, untuk menggambar jendela dan mengambil kunci pada semua objek yang terkandung di dalamnya, itu menjadi cukup untuk menghentikan aliran ini sendirian.  Kedua, utas dengan objek UI memulai kunci untuk memperbarui back-end, mengirim pesan ke render utas tentang perlunya menyinkronkan dan menghentikan dirinya sendiri (QSGThreadedRenderLoop :: polishAndSync jika ada yang tertarik).  Ini memastikan bahwa utas render tidak akan pernah "menunggu" untuk aliran front-end.  Jika tiba-tiba "hang", utas render hanya akan terus menggambar keadaan "lama" dari objek tanpa menerima pesan tentang perlunya memperbarui.  Ini benar-benar menimbulkan bug yang cukup lucu dari bentuk "jika karena alasan tertentu rendering tidak dapat langsung menggambar jendela, utas utama membeku", tetapi secara umum itu adalah kompromi yang masuk akal.  Dimulai dengan QtQuick 2.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sejumlah objek "animasi"</a> bahkan dapat "diisi" di render thread sehingga animasi juga dapat terus bekerja jika utas utama "dipikirkan". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc0/250/3da/bc02503da9d76ff4b66ae038ce3cf81f.png"><br><br>  Namun, konsekuensi praktis dari solusi ini adalah bahwa semua objek UI harus hidup di utas yang sama.  Dalam kasus widget lama, di utas "utama", dalam kasus objek Qt Quick baru, di utas objek QQuickWindow yang memilikinya.  Aturan terakhir cukup dipukuli secara elegan - untuk menggambar QQuickItem, ia perlu membuat setParent ke QQuickWindow yang sesuai, seperti yang sudah dibahas, menjamin bahwa objek bergerak ke aliran yang sesuai atau panggilan setParent gagal. <br><br>  Dan sekarang, sayangnya, lalat di salep: meskipun QQuickWindow yang berbeda secara teoritis dapat hidup di aliran yang berbeda, dalam praktiknya ini membutuhkan pengiriman pesan yang akurat dari sistem operasi kepada mereka dan di Qt hari ini tidak diterapkan.  Pada Qt 5.13, misalnya, QCoreApplication mencoba berkomunikasi dengan QQuickWindow melalui sendEvent yang mengharuskan penerima dan pihak pengirim berada di utas yang sama (bukan postEvent yang memungkinkan utas berbeda).  Oleh karena itu, dalam praktiknya, QQuickWindow hanya berfungsi dengan benar di utas GUI, dan sebagai hasilnya, semua objek QtQuick hidup di tempat yang sama.  Akibatnya, meskipun ada utas render, hampir semua objek terkait GUI yang tersedia untuk pengguna masih hidup di utas GUI yang sama.  Mungkin ini akan berubah di Qt 6. <br><br>  Selain hal di atas, perlu juga diingat bahwa karena Qt bekerja pada banyak platform yang berbeda (termasuk yang tidak mendukung multithreading), framework ini menyediakan sejumlah fallback yang layak dan dalam beberapa kasus fungsionalitas rendering thread sebenarnya dilakukan oleh gui thread yang sama. .  Dalam hal ini, seluruh UI, termasuk rendering, hidup dalam satu utas dan masalah sinkronisasi secara otomatis menghilang.  Situasinya mirip dengan UI berbasis widget Qt4 gaya lama.      Qt    «»       QSG_RENDER_LOOP   . <br><br><a name="part6"></a><h3>  Kesimpulan </h3><br> Qt —              .     ,   ,           Qt      . <br><br>     ; <br><br><ul><li>    «»         ,   queued signals </li><li>  «»     Qt Event Loop                   exit() </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orang tua dan keturunan selalu hidup dalam aliran yang sama. </font><font style="vertical-align: inherit;">Hanya orang tua tingkat atas yang dapat ditransfer dari streaming ke streaming. </font><font style="vertical-align: inherit;">Pelanggaran aturan ini dapat mengakibatkan kegagalan diam dari operasi setParent atau moveToThread</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objek yang orang tuanya tidak ditentukan menjadi properti utas yang dibuat objek ini. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Semua objek GUI kecuali untuk rendering back-end harus hidup dalam aliran GUI </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utas GUI adalah yang di mana objek QApplication dibuat </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya harap ini akan membantu Anda menggunakan Qt lebih efisien dan tidak membuat kesalahan yang terkait dengan model multi-utasnya. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467261/">https://habr.com/ru/post/id467261/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467251/index.html">Sandera COBOL dan Matematika. Bagian 1</a></li>
<li><a href="../id467253/index.html">Sandera COBOL dan Matematika. Bagian 2</a></li>
<li><a href="../id467255/index.html">Tiga Kesalahan Umum tentang Keamanan Yang Harus Diketahui Setiap Pengembang Tentang</a></li>
<li><a href="../id467257/index.html">Jangan menyimpan semua telur Anda dalam satu keranjang sekaligus</a></li>
<li><a href="../id467259/index.html">DPI (inspeksi SSL) bertentangan dengan makna kriptografi, tetapi perusahaan menerapkannya</a></li>
<li><a href="../id467263/index.html">Kami menghasilkan energi surya atau pendapatan pasif sebesar 25% per tahun, pengalaman praktis. Bagian 2</a></li>
<li><a href="../id467269/index.html">Model dalam Keamanan Informasi</a></li>
<li><a href="../id467271/index.html">Pemrogram panggilan, ahli kimia berdasarkan profesi</a></li>
<li><a href="../id467275/index.html">Sampai Hari programmer. Programmer pada tahun 2019</a></li>
<li><a href="../id467277/index.html">pg_stat_statements + pg_stat_activity + loq_query = pg_ash?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>