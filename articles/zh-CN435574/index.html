<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❎ 👩🏼‍🔧 🦗 Zig如何工作？ 🤦 💪🏾 ⏺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="来自翻译者：这篇文章于2018年3月15日发布在作者的博客上。 随着语言的发展，目前其语法可能有所不同。 所描述的所有内容均与Zig 0.2.0有关，该语言的当前版本为Zig 0.3.0。 

 我联系了帖子的作者，他在Zig 0.3.0上提供了到项目源的最新版本的资源库链接。 
 
 你好 让我们...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zig如何工作？</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435574/">  <i>来自翻译者：这篇文章于2018年3月15日发布在作者的博客上。</i>  <i>随着语言的发展，目前其语法可能有所不同。</i>  <i>所描述的所有内容均与Zig 0.2.0有关，该语言的当前版本为Zig 0.3.0。</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我联系了帖子的作者，他在Zig 0.3.0上提供了到项目源的最新版本的资源库链接。</a></i> <i><br></i> <br> 你好 让我们写一个Brainfuck解释器！  “为什么？”  “您可能会问，但在这里找不到答案。” <br><br> 我将在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Zig</a>上执行此操作。 <br><img src="https://habrastorage.org/webt/p2/l1/zs/p2l1zsmnlu7j_yqwm6fczu4ycay.jpeg"><br><h3>  Zig是... </h3><br>  ...一种新的编程语言。 它仍处于测试阶段，并且正在迅速发展。 如果您之前看过Zig代码，那么本篇文章中的代码似乎对您而言就有些不同了。 他真的不一样！  Zig 0.2.0刚刚发布，与几周前发布的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LLVM 6</a>一致，它包括许多语法更改和常规语言改进。 通常，许多“咒语”已被关键字替换。 有关所有更改的更详细说明，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> ！ <br><br> 对于熟悉C和C ++等某些编译和类型化语言（在某些情况下还包括Rust）的人来说，Zig的设计<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">具有可读性</a>和相对直观性。 <br><br> 该代码已使用Zig 0.2.0进行编译和测试，如果您在OSX上，则可<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过各种渠道</a> （包括自制软件）使用Zig 0.2.0：brew install zig。 <br><a name="habracut"></a><br><h3> 让我们开始吧 </h3><br> 要了解Brainfuck的工作原理，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> 。 那里几乎没有什么可学的，但这是一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图灵完备的</a>语言，这意味着您可以在上面写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任何东西</a> 。 <br><br> 我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>发布了代码，以防您想查看最终产品或早期提交。 <br><br>  Zig是一种编译语言。 编译程序时，生成的二进制文件（如果正在编译可执行二进制文件，而不是库）应具有标记入口点的主函数。 <br><br> 所以... <br><br><pre><code class="plaintext hljs">// main.zig fn main() void { }</code> </pre> <br>  ...然后开始... <br><br><pre> <code class="bash hljs">$ zig build-exe main.zig</code> </pre> <br>  ...发出... <br><br><pre> <code class="bash hljs">/zig/std/special/bootstrap.zig:70:33: error: <span class="hljs-string"><span class="hljs-string">'main'</span></span> is private /zigfuck/main.zig:2:1: note: declared here</code> </pre> <br>  main必须声明为public以便在模块外部可见... <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { }</code> </pre> <br> 让Brainfuck程序使用30,000字节的数组作为内存，我将制作这样的数组。 <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8; }</code> </pre> <br> 我可以声明一个常量（const）或一个变量（var）。 在这里，我将mem声明为30,000个无符号（u）字节（8位）的数组。 <br><br> 这不会编译。 <br><br><pre> <code class="bash hljs">/main.zig:3:5: error: variables must be initialized</code> </pre> <br> 等效的C程序将正常编译：我可以在不初始化的情况下声明变量，但是Zig迫使我在声明变量时立即做出决定。 我可能不在乎会写什么，但是我必须明确指出。 我将通过使用未定义的值（未定义）初始化变量来完成此操作。 <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8 = undefined; }</code> </pre> <br> 用未定义的值初始化变量并不能保证该变量在内存中的值。 这与C中的未初始化变量声明相同，除了需要明确指出。 <br><br> 但也许我不在乎如何初始化此内存。 也许我想保证在其中写入零或一些任意值。 在这种情况下，我还应该明确声明： <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem = []u8{0} ** 30000; }</code> </pre> <br> 看起来很奇怪，但是**是用于扩展数组的运算符。 我声明一个0字节的数组，然后将其扩展为30,000，并获得30,000个零字节的最终初始化值。 该操作<i>在编译时</i>发生一次。  comptime是Zig的出色创意之一，我将在以下几篇文章中再次谈到。 <br><br> 现在让我们在Brainfuck上编写一个程序，该程序除了将第一个内存插槽增加五倍之外什么也不做！ <br><br><pre> <code class="plaintext hljs">pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; }</code> </pre> <br> 在Zig中，字符串是字节数组。 我不应该将src声明为字节数组，因为编译器暗含了这一点。 这是可选的，但是如果您愿意，则可以： <br><br><pre> <code class="plaintext hljs">const src: [5]u8 = "+++++";</code> </pre> <br> 这样可以编译良好。 但是，这： <br><br><pre> <code class="plaintext hljs">const src: [6]u8= "+++++";</code> </pre> <br> 不会。 <br><br><pre> <code class="bash hljs">main.zig:5:22: error: expected <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'[6]u8'</span></span>, found <span class="hljs-string"><span class="hljs-string">'[5]u8'</span></span></code> </pre> <br> 还有一点需要注意：由于字符串只是数组，所以它们不以零结尾。 但是，您可以声明一个以空值终止的字符串C。作为文字，它看起来像这样： <br><br><pre> <code class="plaintext hljs">c"Hello I am a null terminated string";</code> </pre> <br><h3> 为了共同的利益... </h3><br> 我想对字符串中的每个字符进行处理。 我做得到！ 在main.zig的开头，我从标准库中导入了一些函数： <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn;</code> </pre> <br> 就像几乎所有以@符号开头的内容一样， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">import</a>都是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内置的编译器函数</a> 。 这些功能始终在全球范围内可用。 此处的导入与javascript相似-您可以通过深入名称空间并从中提取任何公开可用的函数或变量来导入任何内容。 在上面的示例中，我直接导入了警告函数，并突然将其分配给警告常量。 现在可以打电话给她了。 这是一种常见的模式：我们直接从std名称空间导入，然后调用std.debug.warn（）或将其分配给warn变量。 看起来像这样： <br><br><pre> <code class="plaintext hljs">const std = @import("std"); const warn = std.debug.warn;</code> </pre> <br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; // main.zig pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { warn("{}", c); } }</code> </pre> <br> 在调试，初始开发和测试过程中，我只想在屏幕上打印一些内容。  Zig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">容易出错</a> ，stdout也容易出错。 我现在不想这样做，我可以使用从标准库导入的warn直接打印到stderr。 <br><br> 警告使用格式化的字符串，例如C语言中的printf！ 上面的代码将打印： <br><br><pre> <code class="plaintext hljs">4343434343</code> </pre> <br>  43是ASCII字符代码+。 我也可以写： <br><br><pre> <code class="plaintext hljs">warn("{c}", c);</code> </pre> <br> 并获得： <br><br><pre> <code class="plaintext hljs">+++++</code> </pre> <br> 因此，我们初始化了内存空间，并编写了程序。 现在我们正在意识到语言本身。 我将从+开始，并用switch替换for循环的主体： <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1 } }</code> </pre> <br> 我得到两个错误： <br><br><pre> <code class="plaintext hljs">/main.zig:10:7: error: switch must handle all possibilities switch(c) { ^ /main.zig:11:25: error: cannot assign to constant '+' =&gt; mem[0] += 1 ^</code> </pre> <br> 当然，我不能将新值赋给一个常量变量！ 记忆需要成为一个变量... <br><br><pre> <code class="plaintext hljs">var mem = []u8{0} ** 30000;</code> </pre> <br> 与其他错误一样，即使不需要执行任何操作，我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">switch</a>构造也应该知道如果字符不是+怎么办。 就我而言，这正是我想要的。 我用一个空块填充这种情况： <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } }</code> </pre> <br> 现在，我可以编译程序了。 最后致电警告并运行： <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } } warn("{}", mem[0]); }</code> </pre> <br> 如我所料，我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">stderr中</a>得到了数字5。 <br><br><h3> 让我们继续... </h3><br> 同样，我们也提供支持。 <br><br><pre> <code class="plaintext hljs">switch(c) { '+' =&gt; mem[0] += 1, '-' =&gt; mem[0] -= 1, else =&gt; {} }</code> </pre> <br> 要使用&gt;和&lt;，您需要使用一个附加变量，该变量在我分配给用户Brainfuck程序的内存中用作“指针”。 <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0;</code> </pre> <br> 由于无符号的16位最大为65535，因此索引30,000字节的地址空间绰绰有余。 <br><br><blockquote>  <i>实际上，对于我们来说15位就足够了，这使我们可以寻址32767个字节。</i>  <i>Zig允许使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不同宽度的</a>类型，但尚未允许u15。</i> <i><br><br></i>  <i>您实际上可以通过以下方式执行u15：</i> <i><br><br></i> <pre> <code class="plaintext hljs">const u15 = @IntType(false, 15):</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">建议</a>任何[iu] \ d +类型都可以作为整数类型有效。 </blockquote><br> 现在，我可以不使用mem [0]，而可以使用此变量。 <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1,</code> </pre> <br>  &lt;and&gt;只需递增和递减此指针。 <br><br><pre> <code class="plaintext hljs">'&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1,</code> </pre> <br> 太好了 我们现在可以编写一个真实的程序！ <br><br><h3> 检查1,2,3 </h3><br>  Zig具有内置的测试引擎。 在任何文件中的任何地方，我都可以编写一个测试块： <br><br><pre> <code class="plaintext hljs">test "Name of Test" { // test code }</code> </pre> <br> 并从命令行运行测试：zig test $ FILENAME。 其余测试块与常规代码相同。 <br><br> 让我们来看一下： <br><br><pre> <code class="plaintext hljs">// test.zig test "testing tests" {} zig test test.zig Test 1/1 testing tests...OK</code> </pre> <br> 当然，空测试是没有用的。 我可以使用assert来确认测试的执行。 <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "test true" { assert(true); } test "test false" { assert(false); }</code> </pre> <br><pre> <code class="bash hljs">zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test.zig <span class="hljs-string"><span class="hljs-string">"thing.zig"</span></span> 10L, 127C written :!zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> thing.zig Test 1/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> true...OK Test 2/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> false...assertion failure [37;1m_panic.7 [0m: [2m0x0000000105260f34 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_panic [0m: [2m0x0000000105260d6b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_assert [0m: [2m0x0000000105260619 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_test <span class="hljs-literal"><span class="hljs-literal">false</span></span> [0m: [2m0x0000000105260cfb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main.0 [0m: [2m0x00000001052695ea <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMain [0m: [2m0x0000000105269379 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMainWithArgs [0m: [2m0x00000001052692f9 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main [0m: [2m0x0000000105269184 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x00007fff5c75c115 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x0000000000000001 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m</code> </pre> <br> 测试失败了。 使用以下命令来重现该错误： <br><br><pre> <code class="plaintext hljs">./zig-cache/test</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">罂粟上的堆栈跟踪仍在开发中。</a> <br><br> 为了有效地进行测试，我需要将其分解。 让我们从这个开始： <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: [30000]u8) void { var memptr: u16 = 0; for (src) |c| { switch(c) { '+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, else =&gt; {} } } } pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; bf(src, mem); }</code> </pre> <br> 它似乎应该起作用，对吗？ <br><br> 但是... <br><br><pre> <code class="plaintext hljs">/main.zig:1:29: error: type '[30000]u8' is not copyable; cannot pass by value</code> </pre> <br><blockquote> 这在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/zig-lang/zig/issues/733中进行了</a>描述。 </blockquote><br> 齐格对此很严格。 复杂类型以及所有可以调整大小的对象都不能按值传递。 这使堆栈分配可预测且合乎逻辑，并避免了不必要的复制。 如果要在程序中使用按值传递的语义，则可以使用分配策略自己实现它，但是在通常情况下，语言本身不支持此操作。 <br><br> 解决此限制的自然方法是传递指针而不是值（按引用传递）。  Zig使用不同的策略，切片。 切片是一个指针，其长度与其相连，并带有检查是否落入边界的指示。 函数签名中的语法如下所示： <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: []u8) void { ... }</code> </pre> <br> 并在调用该函数时如下所示： <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..mem.len]);</code> </pre> <br> 请注意，我只是通过引用数组的长度来定义上限。 对于这种情况，有一种缩写形式： <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..]);</code> </pre> <br> 现在，我可以开始编写直接测试bf（）函数的测试。 我现在将测试功能添加到文件的末尾... <br><br><pre> <code class="plaintext hljs">test "+" { var mem = []u8{0}; const src = "+++"; bf(src, mem[0..]); assert(mem[0] == 3); }</code> </pre> <br> 我从一个字节中取出内存数组，然后检查会发生什么（该字节增加3次）。 有效！ <br><br><pre> <code class="plaintext hljs">Test 1/1 +...OK</code> </pre> <br> 以相同的方式检查“-”： <br><br><pre> <code class="plaintext hljs">test "-" { var mem = []u8{0}; const src = "---"; bf(src, mem[0..]); assert(mem[0] == 253); }</code> </pre> <br> 不起作用！ 当我尝试从0中减去1时，我得到... <br><br><pre> <code class="bash hljs">Test 2/2 -...<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> overflow</code> </pre> <br>  mem是无符号字节的数组，从0减去1会导致溢出。 同样，Zig让我明确声明自己想要的东西。 在这种情况下，我不必担心溢出，实际上，我希望它发生，因为我们正在按照<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Brainfuck</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">规范</a>处理<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模块化算术</a> 。 这意味着递减一个数字为0的单元格将得到255，而递增255将给我0。 <br><br>  Zig具有几种辅助算术运算，这些运算提供了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">保证“包装”</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">语义</a> 。 <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] +%= 1, '-' =&gt; mem[memptr] -%= 1,</code> </pre> <br> 这解决了整个溢出问题，并达到了我的预期。 <br><br> 为了测试&lt;and&gt;，我浏览了一个小数组并检查了递增单元格的值： <br><br><pre> <code class="plaintext hljs">test "&gt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++"; bf(src, mem[0..]); assert(mem[3] == 3); }</code> </pre> <br> 还有... <br><br><pre> <code class="plaintext hljs">test "&lt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, mem[0..]); assert(mem[3] == 3); assert(mem[2] == 2); assert(mem[1] == 1); }</code> </pre> <br> 在后一种情况下，我可以使用...直接将结果与静态数组进行比较。 <br><br><pre> <code class="plaintext hljs">const mem = std.mem;</code> </pre> <br> 回想一下我已经导入了std。 在下面的示例中，我在此命名空间中使用mem.eql： <br><br><pre> <code class="plaintext hljs">test "&lt;" { var storage = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, storage[0..]); assert(mem.eql(u8, storage, []u8{ 0, 1, 2, 3, 0 })); }</code> </pre> <br>  ...记住字符串字面量，它们只是zig中的u8数组，我可以在其中放入十六进制字面量，即 以下代码将以相同的方式工作！ <br><br><pre> <code class="plaintext hljs">assert(mem.eql(u8, storage, "\x00\x01\x02\x03\x00"));</code> </pre> <br> 添加“。”！ 它只是将指针所指向的单元格中的字节值打印为字符。 我现在使用警告，但是稍后我将其替换为stdout。 从概念上讲，这很容易做到，但在实现上却有些困惑。 我稍后再做！ <br><br><pre> <code class="plaintext hljs">'.' =&gt; warn("{c}", storage[memptr]),</code> </pre> <br> 周期数 <br>  [和]-魔术从这里开始。 <br><br>  [-如果当前单元格的值为零，则不执行代码就跳至右括号。 <br>  ]-如果当前单元格的值不为零，请返回左括号并再次执行代码。 <br><br> 这次，我将从测试开始，将它们一起测试（显然，单独测试它们没有意义）。 第一个测试用例-存储[2]单元应该为空，尽管循环在开始时应将其递增： <br><br><pre> <code class="plaintext hljs">test "[] skips execution and exits" { var storage = []u8{0} ** 3; const src = "+++++&gt;[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 5); assert(storage[1] == 0); assert(storage[2] == 0); }</code> </pre> <br> 我将为switch语句创建空白： <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { }, ']' =&gt; if (storage[memptr] == 0) { },</code> </pre> <br> 现在该怎么办？ 您可以使用幼稚的方法。 我只是增加src指针，直到找到它为止。 但是我不能在zig中使用for循环，它是为遍历集合而创建的，而不会丢失它们的元素。 这里是一个合适的构造： <br><br> 原为： <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; for (src) |c| { switch(c) { ... } }</code> </pre> <br> 成为... <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { ... } srcptr += 1; }</code> </pre> <br> 现在，我可以在块中间重新分配srcptr指针，我将这样做： <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { while (src[srcptr] != ']') srcptr += 1; },</code> </pre> <br> 这满足测试“ []跳过代码执行并退出” <br> 正如我们将看到的那样，它满足测试“ []跳过执行并退出”，尽管并不完全可靠。 <br><br> 右括号呢？ 我相信可以简单地用类推来写： <br><br><pre> <code class="plaintext hljs">test "[] executes and exits" { var storage = []u8{0} ** 2; const src = "+++++[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 25); } ']' =&gt; if (storage[memptr] != 0) { while (src[srcptr] != '[') srcptr -= 1; },</code> </pre> <br> 您可以看到发生了什么...两个括号的幼稚解决方案具有致命缺陷，并且在嵌套循环中完全中断。 考虑以下内容： <br><br><pre> <code class="plaintext hljs">++&gt;[&gt;++[-]++&lt;-]</code> </pre> <br> 结果应该是{2，0}，但是第一个左括号简单地愚蠢地移到了第一个右括号，并且一切都变得混乱了。 您需要跳到相同嵌套级别的下一个右括号。 沿直线前进时，添加深度计数器并对其进行跟踪很容易。 我们在两个方向上都这样做： <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { var depth:u16 = 1; srcptr += 1; while (depth &gt; 0) { srcptr += 1; switch(src[srcptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } }, ']' =&gt; if (storage[memptr] != 0) { var depth:u16 = 1; srcptr -= 1; while (depth &gt; 0) { srcptr -= 1; switch(src[srcptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } },</code> </pre> <br> 和相关测试：请注意，两个测试中的src都包含一个内部循环。 <br><br><pre> <code class="plaintext hljs">test "[] skips execution with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++&gt;[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 2); assert(storage[1] == 0); } test "[] executes with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 2); }</code> </pre> <br><blockquote> 另外，请注意[-]-Brainfuck的成语，意思是“将此单元归零”。 您会看到，单元格开始时具有什么值都没有关系，它将递减直到达到0，然后继续执行。 </blockquote><br><h3> 倒霉的路 </h3><br> 我没有指望bf上的程序被破坏的可能性。 如果我向口译员提交了错误的输入程序，该怎么办？ 例如，简单地[没有右括号或&lt;，它立即超出了内存阵列？  （我可以包装内存指针，但是最好将此视为错误）。 <br><br> 我将向前看一些，并解释代码中的所有差异。 我将把bf解释器功能放到一个单独的文件中，还将seekBack和seekForward功能放到我自己的小功能中。 <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; const sub = @import("std").math.sub; fn seekBack(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr = sub(u16, ptr, 1) catch return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } return ptr; } fn seekForward(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr += 1; if (ptr &gt;= src.len) return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } return ptr; } pub fn bf(src: []const u8, storage: []u8) !void { var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { '+' =&gt; storage[memptr] +%= 1, '-' =&gt; storage[memptr] -%= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, '[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr), '.' =&gt; warn("{c}", storage[memptr]), else =&gt; {} } srcptr += 1; } }</code> </pre> <br> 在我看来，这使开关更易于阅读，seekForward和seekBack的工作和外观非常相似，我很想将它们重构为更智能，更紧凑的东西，但最终它们会做不同的事情并处理错误也以不同的方式。 易于复制和调整，因此更加清晰。 我还将稍后在某个时候（可能在后续帖子中）调整seekForward。 <br><br> 我添加了一些重要的东西！ 请注意，这三个函数现在都返回一个类型！..这是用于％T（错误并集）类型的新语法。 这意味着该函数可以返回某些特定类型或错误。 当我尝试调用此类函数时，必须在调用该函数之前使用try，如果发生错误，则该错误会将错误抛出到调用堆栈中，或者使用catch： <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch {}</code> </pre> <br> 我在catch块中处理错误的地方。 如所写，catch可以吞下任何错误。 这是不好的做法，但是Zig在这里让我们明确地做到了。 如果我在一个空块中捕获到错误，则说明我不认为会发生错误，或者不需要处理它。 实际上，它可能类似于TODO，实际上也很容易使其明确！ <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch { @panic("TODO") }</code> </pre> <br> 回想一下，这种情况永远不会在生产代码中发生。 我通知编译器我知道自己在做什么。 如果可能发生错误，我将不得不添加错误处理。 <br><br> 那么我应该从seekBack或seekForward返回什么错误？ <br><br> 在seekBack中： <br><br><pre> <code class="plaintext hljs">ptr = sub(u16, ptr, 1) catch return error.OutOfBounds;</code> </pre> <br> 我替换了减量指针以使用std lib的子函数，如果发生溢出，它将引发溢出错误。 我想捕获此错误并返回OutOfBounds错误，而我只是在使用它创建的。 <br><br><blockquote>  <i>错误Zig基本上是错误代码的数组，当您使用error时，编译器会生成这些错误代码。</i>  <i>它们保证是唯一的，并且可以用作开关块中的值。</i> </blockquote><br> 我想在这里使用OutOfBounds，因为从语义上讲，如果内存指针小于零，我会要求运行时超出我分配的内存空间。 <br><br> 在seekForward函数中类似： <br><br><pre> <code class="plaintext hljs">if (ptr &gt;= src.len) return error.OutOfBounds;</code> </pre> <br> 在这种情况下，如果指针大于src.len，我会在这里捕获错误并返回相同的错误。 <br><br> 致电时： <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr),</code> </pre> <br> 我尝试调用这些函数。 如果成功调用了它们，则它们将正确执行，并尝试返回srcptr。 如果它们不成功，请尝试终止该函数，并将错误返回到整个函数bf的调用位置。 <br><br> 呼叫可能来自主要！ <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; // yes, hello const hello_world = "++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;."; pub fn main() void { storage = []u8{0} ** 30000; bf(hello_world, storage[0..]) catch {}; }</code> </pre> <br> 我在这里吞并了这个错误，不应该这样做，但是我们要注意一个重要的问题，即zig可以很容易地将错误传递到调用堆栈中。 检查每种错误情况都不是调用函数的责任，但是编译器会强制尝试尝试失败的每个函数。 即使忽略错误，也必须始终这样做！ <br><br><blockquote>  <i>新的try / catch语法消除了人们非常讨厌的许多咒语，例如%%和％。</i> </blockquote><br> 现在，我已经实现了8个脑残角色中的7个，这足以运行一个“有意义的”程序。 <br><br><h3> 一个有意义的程序 </h3><br> 这是程序： <br><br><pre> <code class="plaintext hljs">//   ,   const fib = "++++++++++++++++++++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++++++&gt;++++++++++++++++&gt;&gt;+&lt;&lt;[&gt;&gt;&gt;&gt;++++++++++&lt;&lt;[-&gt;+&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;&lt;]&gt;[&lt;+&gt;-]&gt;[-]&gt;&gt;&gt;++++++++++&lt;[-&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;]&gt;[-]&gt;&gt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;&lt;&lt;++++++++++++++++++++++++++++++++++++++++++++++++.[-]&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&gt;.&gt;&gt;[&gt;&gt;+&lt;&lt;-]&gt;[&gt;+&lt;&lt;+&gt;-]&gt;[&lt;+&gt;-]&lt;&lt;&lt;-]&lt;&lt;++...";</code> </pre> <br> 让我们开始... <br><br><pre> <code class="plaintext hljs">pub fn main() void { storage = []u8{0} ** 30000; bf(fib, storage[0..]) catch {}; }</code> </pre> <br> 瞧！ <br><br><pre> <code class="plaintext hljs">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 121, 98, 219,</code> </pre> <br><blockquote>  <i>每当我想到斐波那契（Fibonacci）系列电影时，我都会回想起……我是从80年代的PBS（公共广播服务，美国的非商业电视广播服务）计划中发现的，我一直都记得。</i>  <i>我以为会被遗忘，但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Youtube是一件很棒的事</a> 。</i> </blockquote><br><h3> 我该如何改善？ </h3><br> 我已经暗示了一些待办事项。 我不应该使用stderr进行输出。 我想使用标准输出。 <br><br> 每次打开解释器时，我都会在stdout中打开流并打印到其中： <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br> 这是怎么回事<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我调用io.getStdOut（），它会生成错误（同样，我明确地吞下了一个可能的错误，并且catch无法到达-如果此函数返回错误，程序将崩溃！）。我初始化流，获取它的指针，然后将其初始化为可通过调用print写入的输出流。就像警告一样，print接受格式化的字符串，因此替换直接进行。打印也会产生错误，我也吞下了这些错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在正确编写的程序中，我必须考虑打开stdout的潜在错误以及尝试写入stdout的可能错误。只要您知道自己忽略了Zig，就可以很容易地忽略这些错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我决定将原型转变为发行版，会发生什么情况？</font><font style="vertical-align: inherit;">我是否会坐着喝咖啡，对错误的处理工作做得很忘恩负义，依靠数十年的经验和知识列出每种可能的错误案例，我该如何处理？</font><font style="vertical-align: inherit;">但是，如果我没有几十年的经验和知识怎么办？</font><font style="vertical-align: inherit;">没关系，Zig会做的！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我想展示一个强大的东西，错误输出！</font></font><br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch unreachable; }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我知道bf会因为返回而产生错误！</font><font style="vertical-align: inherit;">我在主函数的调用端吞下了此错误。</font><font style="vertical-align: inherit;">当我准备好接受命运并做正确的事时，我会发现以下可能的错误：</font></font><br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 编译器现在是我的朋友！ </font></font><br><br><pre> <code class="bash hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> switch shell returned 1</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于bf和辅助功能引发了该错误，因此您应该熟悉该错误！</font><font style="vertical-align: inherit;">但是，让我们想象一下，我看到了我在bf中吞下的stdout生成的错误。</font><font style="vertical-align: inherit;">与其吞下它们，不如尝试使用它们将它们推上链。</font><font style="vertical-align: inherit;">回想一下，使用对产生错误而不捕获的函数的调用，我们使用了try，它在发生错误时终止函数，为调用函数提供任何潜在错误的处理。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，代替：</font></font><br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们做： </font></font><br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(try io.getStdOut())).stream); ... '.' =&gt; try stdout.print("{c}", storage[memptr]), ...</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们编译： </font></font><br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 并获得通过调用该函数可以获得的所有可能错误的列表！ </font></font><br><br><pre> <code class="plaintext hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.SystemResources not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OperationAborted not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.IoPending not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.BrokenPipe not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.Unexpected not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.WouldBlock not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileClosed not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DestinationAddressRequired not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DiskQuota not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileTooBig not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.InputOutput not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoSpaceLeft not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.AccessDenied not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoStdHandles not handled in switch shell returned 1</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zig让我有机会认真地处理这些错误，如果我愿意或可以做到！</font><font style="vertical-align: inherit;">我根据错误值进行切换，如果需要，可以处理大小写，如果要跳过它们，则可以跳过。</font></font><br><br><pre> <code class="plaintext hljs">pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { error.OutOfBounds =&gt; @panic("Out Of Bounds!"), else =&gt; @panic("IO error") }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">严格来说，这仍然不是正确的错误处理，但是我只想通过向调用函数报告各种错误情况来演示Zig的智能程度！</font><font style="vertical-align: inherit;">当发生错误时，您将获得</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跟踪而不是堆栈跟踪！</font><font style="vertical-align: inherit;">很酷的东西！</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 待办 </font></font></h3><br>    ,     !         , ,     ",",   brainfuck-    getc,        .            ,      bf.    ,     ,      Zig.  ,       ,           ,       . <br><br><h3> 结论 </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我希望这个完成了一半的微型项目可以使您对Zig代码的外观以及它的用途有所了解。 Zig不是一把瑞士刀，它也不是所有工具的完美工具，它专注于某些事情，是一种实用的系统语言，可以一起使用，也可以代替C和C ++使用。这使我仔细地处理了内存使用，内存管理和错误处理。在资源有限的环境中，这是一个有用的功能，而不是错误。 Zig是确定性的，没有歧义，并且试图在传统上难以做到的环境中促进可靠代码的编写。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我仅描述了Zig语法和功能的一小部分，在0.2.0版及更高版本中对该语言进行了许多有趣的更改！我编写的所有代码都是在调试模式下编译的，这对于安全检查和减少编译时间以使迭代速度更快而言是最佳选择！有--release-fast和--release-safe模式，将来</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还会有更多</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。您可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">详细了解它们的区别以及对这些模式的解释</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我一直对Zig开发的速度和方向感到惊讶。仍然有很多工作要做，直到1.0.0版发行为止。如果您决定尝试Zig，请记住，这里有很多好主意，我期待着实现它们！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如有疑问，请随时尝试并在freenode中加入#zig。 </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN435574/">https://habr.com/ru/post/zh-CN435574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN435560/index.html">第一台商用量子计算机-IBM</a></li>
<li><a href="../zh-CN435562/index.html">吸烟者的道路：如果您是人文主义者，如何进入程序员的职业</a></li>
<li><a href="../zh-CN435564/index.html">使用GtkApplication。 Librsvg渲染功能</a></li>
<li><a href="../zh-CN435568/index.html">VyOS开源路由器</a></li>
<li><a href="../zh-CN435572/index.html">Anycubic i3 Mega：Prusa i3的高品质翻拍</a></li>
<li><a href="../zh-CN435576/index.html">1C，无痛苦</a></li>
<li><a href="../zh-CN435578/index.html">圣诞节太空漫步</a></li>
<li><a href="../zh-CN435580/index.html">Java，Spring，Kurento和媒体服务</a></li>
<li><a href="../zh-CN435582/index.html">如何在不停机的情况下在已加载系统24/7上添加索引？</a></li>
<li><a href="../zh-CN435584/index.html">Slush2018。第一天，第二天</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>