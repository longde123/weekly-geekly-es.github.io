<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèæ üò± üë∏üèΩ Generische und Metaprogrammiermodelle: Go, Rust, Swift, D und andere üïé ü¶è üìö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einigen Bereichen der Programmierung ist es normal, eine Datenstruktur oder einen Algorithmus schreiben zu wollen, der mit Elementen unterschiedlic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generische und Metaprogrammiermodelle: Go, Rust, Swift, D und andere</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/461321/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/o5/zc/cso5zcp78nxxi31mspfvdat89w4.jpeg"></div><br>  In einigen Bereichen der Programmierung ist es normal, eine Datenstruktur oder einen Algorithmus schreiben zu wollen, der mit Elementen unterschiedlicher Typen arbeiten kann.  Zum Beispiel eine Liste von Generika oder ein Sortieralgorithmus, der nur eine Vergleichsfunktion ben√∂tigt.  In verschiedenen Sprachen werden verschiedene M√∂glichkeiten zur L√∂sung dieses Problems vorgeschlagen: vom einfachen Aufzeigen der entsprechenden gemeinsamen Funktionen (C, Go) √ºber Programmierer bis hin zu so leistungsf√§higen generischen Systemen, dass sie vollst√§ndig werden ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++</a> ).  In diesem Artikel werde ich √ºber generische Systeme aus verschiedenen Sprachen und deren Implementierung sprechen.  Ich werde zun√§chst das Problem in Sprachen ohne ein √§hnliches System (wie C) l√∂sen und dann zeigen, wie das schrittweise Hinzuf√ºgen von Erweiterungen zu Systemen aus anderen Sprachen f√ºhrt. <br><a name="habracut"></a><br>  Ich finde Generika eine interessante Option, da sie ein einfacher Spezialfall des allgemeinen Metaprogrammierungsproblems sind: Schreiben von Programmen, die Klassen anderer Programme generieren k√∂nnen.  Als Beweis werde ich zeigen, wie drei verschiedene und vollst√§ndig allgemeine Metaprogrammierungsmethoden als multidirektionale Erweiterungen im Bereich generischer Systeme betrachtet werden k√∂nnen: dynamische Sprachen wie Python, prozedurale Makrosysteme wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Template Haskel</a> und schrittweise Kompilierung wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zig</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Terra</a> . <br><br><h2>  R√ºckblick </h2><br>  Ich habe ein Blockdiagramm aller im Artikel beschriebenen Systeme gezeichnet, damit Sie deren Inhalt und die Art und Weise, wie diese Systeme miteinander verbunden sind, darstellen k√∂nnen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/259/577/5fa259577cd99685d90ab7912710e348.png"><br><br><h2>  Hauptideen </h2><br>  Angenommen, wir schreiben in einer Sprache ohne generische Systeme und m√∂chten eine generische Stapeldatenstruktur erstellen, die mit Daten eines beliebigen Typs funktioniert.  Das Problem ist, dass jede Funktions- und Typdefinition nur mit Daten derselben Gr√∂√üe funktioniert und auf eine Weise kopiert wird und im Allgemeinen √§hnlich funktioniert. <br><br>  Es gibt zwei M√∂glichkeiten, dies zu umgehen: Stellen Sie entweder sicher, dass alle Datentypen in unserer Struktur gleich funktionieren, oder erstellen Sie viele Kopien der Datenstruktur mit geringf√ºgigen √Ñnderungen, damit sie mit jedem Datentyp ordnungsgem√§√ü funktionieren.  Diese Ideen bildeten die Grundlage f√ºr zwei gro√üe Gruppen von L√∂sungen mit Generika: Boxen und Monomorphisierung. <br><br>  Verpacken bedeutet, alles in einer Reihe in einheitliche ‚ÄûKisten‚Äú zu packen, die auf die gleiche Weise funktionieren.  Dies geschieht normalerweise so: Die Daten werden in einen Heap gestellt und die Zeiger darauf werden in die Datenstruktur gestellt.  Sie k√∂nnen Zeiger auf alle Typen erstellen, die auf die gleiche Weise funktionieren, sodass derselbe Code mit Daten aller Art funktioniert!  Dies f√ºhrt jedoch zu einem erh√∂hten Speicherverbrauch, dynamischer Suche und Cache-Fehlern.  In C bedeutet dies, dass Ihre Datenstruktur <code>void*</code> -Zeiger speichert und Daten einfach in und aus <code>void*</code> (wenn sich die Daten nicht auf dem Heap befinden, werden sie dort abgelegt). <br><br>  Monomorphisierung bedeutet, wiederholt Code f√ºr die verschiedenen Datentypen zu kopieren, die wir speichern m√∂chten.  Dann kann jede Codeinstanz direkt die Gr√∂√üen- und Datenmethoden verwenden, mit denen sie ohne dynamische Suche arbeitet.  Bei diesem Ansatz wird der Code am schnellsten ausgef√ºhrt, aber seine Gr√∂√üe und Kompilierungszeit erh√∂hen sich, da wir denselben Code wiederholt mit geringf√ºgigen √Ñnderungen kompilieren.  In C entspricht dies der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Definition der gesamten Datenstruktur als Makro</a> , gefolgt von ihrem Aufruf f√ºr jeden Datentyp. <br><br>  Im Allgemeinen wird der Code w√§hrend der Kompilierung schneller kompiliert, aber seine Leistung kann sich w√§hrend der Ausf√ºhrung verschlechtern, w√§hrend wir w√§hrend der Monomorphisierung schnellen Code generieren, aber es dauert l√§nger, alle Instanzen des Codes zu kompilieren und zu optimieren.  Ein weiterer Unterschied besteht darin, dass Sie beim Packen von Erweiterungen ein dynamischeres Verhalten des ausf√ºhrbaren Codes und durch Monomorphisierung verschiedene Instanzen des generischen Codes flexibler trennen k√∂nnen.  Es ist auch erw√§hnenswert, dass in einigen gro√üen Programmen die Vorteile der Monomorphisierung durch Fehler im Cache zus√§tzlicher Anweisungen aus dem generierten Code ausgeglichen werden k√∂nnen. <br><br>  Jedes der beschriebenen Schemata f√ºr die Arbeit mit Generika kann in verschiedene Richtungen erweitert werden, wenn Sie mehr Funktionen oder Sicherheit ben√∂tigen, und die Autoren verschiedener Sprachen haben sehr interessante L√∂sungen gefunden.  Zum Beispiel k√∂nnen beide Ans√§tze in Rust und C # verwendet werden! <br><br><h2>  Verpackung </h2><br>  Beginnen wir mit einem Beispiel f√ºr eine Basisverpackung in Go: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Stack <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { values []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { this.values = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(this.values, value) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { x := this.values[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] this.values = this.values[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x }</code> </pre> <br>  Au√üerdem wird das Packen in C ( <code>void*</code> ), Go ( <code>interface{}</code> ), vorgenerischem Java ( <code>Object</code> ) und vorgenerischem Objective-C ( <code>id</code> ) verwendet. <br><br><h2>  Gepackte Generika mit Maischetypen </h2><br>  Die Hauptverpackungsmethode hat Nachteile: <br><br><ul><li>  Abh√§ngig von der Sprache m√ºssen wir h√§ufig bei jedem Lesen oder Schreiben in die Datenstruktur Werte in oder aus dem richtigen Typ umwandeln. <br></li><li>  Nichts hindert uns daran, Elemente unterschiedlichen Typs in die Struktur einzuf√ºgen, was zu Fehlern f√ºhren kann, die w√§hrend der Codeausf√ºhrung wie Abst√ºrze aussehen. <br></li></ul><br>  Beide Probleme k√∂nnen gel√∂st werden, indem dem System von Funktionalit√§tstypen Generika hinzugef√ºgt werden, w√§hrend die Hauptverpackungsmethode auf die gleiche Weise wie zuvor w√§hrend der Codeausf√ºhrung verwendet wird.  Dieser Ansatz wird h√§ufig als Typl√∂schung bezeichnet, da Typen im generischen System √ºberschrieben werden und zu einem Typ unter der Haube werden (wie <code>Object</code> ). <br><br>  Java und Objective-C begannen mit der √ºblichen Verpackung und erwarben sp√§ter aus Kompatibilit√§tsgr√ºnden Sprachtools f√ºr Generika mit Typ-Mashing, wobei dieselben Sammlungstypen wie zuvor verwendet wurden, jedoch mit den optionalen Parametern generischer Typen.  Betrachten Sie ein Beispiel aus einem Wikipedia-Artikel √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Generika in Java</a> : <br><br><pre> <code class="java hljs">List v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); v.add(<span class="hljs-string"><span class="hljs-string">"test"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// A String that cannot be cast to an Integer Integer i = (Integer)v.get(0); // Run time error List&lt;String&gt; v = new ArrayList&lt;String&gt;(); v.add("test"); Integer i = v.get(0); // (type error) compilation-time error</span></span></code> </pre><br><h3>  Abgeleitete verpackte Generika mit einheitlicher Leistung </h3><br>  OCaml entwickelt die Idee einer einheitlichen Sichtweise weiter.  Es gibt keine primitiven Typen, die eine zus√§tzliche Paketplatzierung ben√∂tigen (da ein <code>int</code> in eine <code>Integer</code> , um in eine <code>ArrayList</code> in Java zu gelangen), da alles bereits gepackt oder durch einen ganzzahligen Wert von der Gr√∂√üe eines Zeigers dargestellt ist, dh alles passt in ein Maschinenwort.  Wenn der Garbage Collector jedoch die in generischen Strukturen gespeicherten Daten betrachtet, muss er Zeiger von Zahlen unterscheiden. Daher werden Zahlen mit einem einzelnen Bit markiert, das dort platziert wird, wo korrekt ausgerichtete Zeiger kein Bit haben, sodass nur Bereiche von 31 oder 63 Bit √ºbrig bleiben. <br><br>  OCaml verf√ºgt auch √ºber ein Typinferenzsystem, sodass Sie eine Funktion schreiben k√∂nnen und der Compiler den am besten geeigneten generischen Typ ausgibt, wenn Sie ihn nicht mit Anmerkungen versehen. Die Funktionen sehen also wie eine dynamisch typisierte Sprache aus: <br><br><pre> <code class="plaintext hljs">let first (head :: tail) = head (* inferred type: 'a list -&gt; 'a *)</code> </pre> <br>  Der angegebene Typ kann als "eine Funktion aus der Liste der Elemente vom Typ <code>'a</code> in etwas mit dem Typ <code>'a</code> " bezeichnet werden.  Dies bedeutet, dass der R√ºckgabetyp mit dem Listentyp identisch ist und ein beliebiger Typ sein kann. <br><br><h2>  Schnittstellen </h2><br>  Eine weitere Einschr√§nkung herk√∂mmlicher Verpackungen besteht darin, dass verpackte Typen <i>vollst√§ndig</i> undurchsichtig sind.  Dies ist kein Problem f√ºr Datenstrukturen wie einen Stapel, aber Tools wie das Sortieren generischer Funktionen ben√∂tigen zus√§tzliche Funktionen, wie z. B. typspezifische Vergleichsfunktionen.  Es gibt viele M√∂glichkeiten, dies zur Laufzeit zu implementieren und in der Sprache wiederzugeben. Technisch gesehen sind dies unterschiedliche Richtungen, und Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieselbe Sprache mit mehreren √§hnlichen Ans√§tzen implementieren</a> .  Die Funktionen verschiedener Sprachen wirken sich jedoch auf ihre Implementierung aus, und erst dann verbessern Erweiterungen die St√§rken der ausgew√§hlten Implementierungen.  Dies bedeutet, dass es zwei Sprachfamilien gibt, die auf unterschiedlichen Laufzeitans√§tzen basieren: virtuelle Methodentabellen (vtables) und W√∂rterbuch√ºbertragung. <br><br><h3>  Tabellen f√ºr Schnittstellenmethoden </h3><br>  Wenn wir typspezifische Funktionen bereitstellen m√∂chten, die sich an die Verpackungsstrategie halten, um eine einheitliche Arbeit mit allem zu erm√∂glichen, reicht es aus, eine einheitliche Methode zu haben, um √§hnliche Funktionen zu finden, die wir vom Objekt erhalten m√ºssen.  Dieser Ansatz wird als "virtuelle Methodentabellen" (vtables, virtuelle Methodentabellen) bezeichnet, obwohl niemand den vollst√§ndigen Namen verwendet.  Es wird wie folgt implementiert: Bei einem Nullpunktversatz in jedem generischen Strukturobjekt gibt es einen Zeiger auf eine Tabelle von Funktionszeigern mit einer konsistenten Schaltung.  In diesen Tabellen sucht der generische Code nach Zeigern auf typspezifische Funktionen, indem bestimmte Zeiger mit festen Offsets indiziert werden. <br><br>  Auf diese Weise werden <code>interface</code> in Go- und <code>dyn trait</code> Objekten in Rust implementiert.  Wenn Sie einen Typ in einen Schnittstellentyp der Implementierung umwandeln, wird ein Wrapper f√ºr die Schnittstelle erstellt, der einen Zeiger auf das Quellobjekt und einen Zeiger auf die vtable typspezifischer Funktionen enth√§lt.  Dies erfordert jedoch eine zus√§tzliche Ebene der indirekten Adressierung von Zeigern und ein anderes Schema.  Daher verwendet das Sortieren in Go die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstelle f√ºr den Container mit der Swap-Methode</a> und verwendet nicht das Slice der Comparable-Schnittstelle, da hierf√ºr ein v√∂llig neues Slice von Schnittstellentypen im Speicher abgelegt werden m√ºsste, das anstelle des urspr√ºnglichen Slice sortiert w√ºrde! <br><br><h3>  Objektorientierte Programmierung </h3><br>  OOP ist eine Spracheigenschaft, die die Funktionen virtueller Typentabellen optimal nutzt.  Anstelle von separaten Schnittstellenobjekten mit vtables f√ºgen OOP-Sprachen wie Java einfach einen Zeiger auf eine Tabelle virtueller Typen am Anfang jedes Objekts ein.  Java-√§hnliche Sprachen verf√ºgen √ºber ein Vererbungssystem und Schnittstellen, die mithilfe dieser Objekttabellen vom virtuellen Typ vollst√§ndig implementiert werden k√∂nnen. <br><br>  Durch das Einbetten von vtable in jedes Objekt werden nicht nur zus√§tzliche Funktionen bereitgestellt, sondern auch das Problem gel√∂st, dass neue Schnittstellentypen mit indirekter Adressierung (Indirektion) erstellt werden m√ºssen.  Im Gegensatz zu Go kann die <code>Comparable</code> in Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Schnittstelle <code>Comparable</code> auf die von ihr implementierten Typen anwenden. <br><br><h3>  Reflexion </h3><br>  Wenn Sie Tabellen mit virtuellen Typen haben, ist es f√ºr Sie nicht schwierig, den Compiler zu zwingen, Tabellen mit anderen Informationstypen zu generieren, z. B. Namen von Feldern, Typen und Speicherorten.  Dies erm√∂glicht den Zugriff auf alle Daten dieses Typs mithilfe von Code, mit dem alle Daten anderer Typen angezeigt werden k√∂nnen.  Dieses Verhalten kann verwendet werden, um der Sprache ‚ÄûReflexion‚Äú hinzuzuf√ºgen, was eine Serialisierung und eine sch√∂ne Anzeige beliebiger Typen erm√∂glicht.  Reflexion als Erweiterung des Verpackungsparadigmas hat einen Nachteil: Daf√ºr reicht nur eine Kopie des Codes aus, aber Sie m√ºssen viele dynamische Suchvorg√§nge durchf√ºhren, wodurch die Serialisierungsgeschwindigkeit verringert wird. <br><br>  Sprachen, die Reflection f√ºr die Serialisierung und andere Funktionen verwenden: Java, C # und Go. <br><br><h3>  Dynamisch getippte Sprachen </h3><br>  Reflection ist ein sehr leistungsf√§higes Tool, mit dem Sie eine Reihe verschiedener Metaprogrammieraufgaben l√∂sen k√∂nnen.  Sie k√∂nnen jedoch keine neuen Typen erstellen oder Informationen zu den Typen vorhandener Werte bearbeiten.  Wenn wir diese Funktion hinzuf√ºgen und Datenzugriffs- und √Ñnderungssyntaxen standardm√§√üig Reflektion verwenden, erhalten wir dynamisch typisierte Sprachen!  Die unglaubliche Flexibilit√§t der Metaprogrammierung in Sprachen wie Python und Ruby ist dank der effektiven, leistungsstarken Reflexionssysteme entstanden, mit denen Probleme gel√∂st werden k√∂nnen. <br><br>  Sie k√∂nnen sagen: "Aber dynamische Sprachen funktionieren nicht so, sie implementieren einfach alles mithilfe von Hash-Tabellen!"  Hash-Tabellen sind nur eine gute Datenstruktur zum Erstellen bearbeitbarer Tabellen mit Typinformationen.  Dar√ºber hinaus arbeiten einige Interpreter wie CPython auf diese Weise.  In einer Hochleistungs-JIT, beispielsweise V8, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt es viele virtuelle Typentabellen und</a> Reflexionsinformationen.  In V8 √§hneln versteckte Klassen (vtables und Reflection-Informationen) und die Struktur von Objekten denen in Java VM, wobei Objekte zur Laufzeit durch neue virtuelle Typentabellen ersetzt werden k√∂nnen.  Dies ist kein Zufall, da es keine Zuf√§lle gibt: Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwickler</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von V8 arbeitete</a> fr√ºher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">an Hochleistungs-Java-VMs</a> . <br><br><h3>  W√∂rterbuch√ºbertragung </h3><br>  Eine andere M√∂glichkeit, dynamische Schnittstellen zu implementieren, besteht darin, eine Tabelle mit den erforderlichen Funktionszeigern auf die generische Funktion zu √ºbertragen, die sie ben√∂tigt.  Dies √§hnelt in gewisser Weise der Erstellung von Go-f√∂rmigen Schnittstellenobjekten am Aufrufort. In unserem Fall wird die Tabelle jedoch als verstecktes Argument √ºbergeben und nicht als eines der vorhandenen Argumente in ein Bundle gepackt. <br><br>  Dieser Ansatz wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typklassen in Haskell verwendet</a> , obwohl Sie mit GHC eine Art Monomorphisierung mithilfe von Inlining und Spezialisierung durchf√ºhren k√∂nnen.  OCaml verwendet die W√∂rterbuch√ºbertragung mit einem expliziten Argument in Form <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstklassiger Module. Es</a> wurde jedoch bereits vorgeschlagen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die M√∂glichkeit hinzuzuf√ºgen, den Parameter implizit zu machen</a> . <br><br><h3>  Zeugen-Tische in Swift </h3><br>  Die Swift-Autoren verwendeten eine interessante L√∂sung: Durch das √úbertragen des W√∂rterbuchs sowie das Einf√ºgen von Daten zu den Schriftgr√∂√üen und zum Verschieben, Kopieren und Freigeben in die Tabelle k√∂nnen Sie alle erforderlichen Informationen f√ºr eine einheitliche Arbeit mit beliebigen Typen bereitstellen, ohne sie zu verpacken.  Somit kann Swift Generika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ohne Monomorphisierung und Platzierung im Speicher in einer einheitlichen Darstellung</a> aller Entit√§ten implementieren!  Ja, Sie m√ºssen f√ºr dynamische Suchvorg√§nge bezahlen, wie es f√ºr die gesamte Familie charakteristisch ist, die Verpackungen verwendet, aber es spart Ressourcen f√ºr die Speicherung, den Verbrauch und die Cache-Inkonsistenz.  Mit den <a href="">als @inlinable gekennzeichneten</a> Funktionen kann der Swift-Compiler auch Generika innerhalb des Moduls oder zwischen Modulen spezialisieren (monomorphisieren) und inline <a href="">generieren</a> , um die genannten Kosten zu vermeiden.  Wahrscheinlich wird eine heuristische Bewertung der Auswirkung auf die Codegr√∂√üe verwendet. <br><br>  Dies erkl√§rt auch, wie Swift <a href="">die ABI-Stabilit√§t implementieren</a> kann, w√§hrend Sie weiterhin Felder in der Struktur hinzuf√ºgen und neu verteilen k√∂nnen, obwohl die Autoren das Attribut <code>@frozen</code> , um dynamische Suchen f√ºr eine bessere Leistung abzulehnen. <br><br><h3>  Intensive Typanalyse </h3><br>  Es gibt eine andere M√∂glichkeit, Schnittstellen f√ºr verpackte Typen zu implementieren.  Wir f√ºgen die Typkennung nach dem Beispiel des vtable-Zeigers einem bestimmten Teil des Objekts hinzu und generieren dann Funktionen f√ºr jede Schnittstellenmethode, die einen gro√üen <code>switch</code> f√ºr alle Typen hat, die diese Methode implementieren, und √ºbergeben sie an die richtige typspezifische Methode. <br><br>  Ich warne nicht davor, Sprachen zu verwenden, die diesen Ansatz verwenden, aber C ++ - Compiler und virtuelle Java-Maschinen verhalten sich √§hnlich, wenn sie bei der Optimierung anhand von Profilen feststellen, dass ein bestimmter Ort zum Aufrufen von Generika haupts√§chlich mit Objekten bestimmter Typen funktioniert.  Compiler und VMs ersetzen Anrufpunkte durch Pr√ºfungen f√ºr jeden normalen Typ und versenden diese Typen dann statisch als Fallback unter Verwendung des herk√∂mmlichen dynamischen Versands.  Daher kann der Verzweigungsvorhersagealgorithmus vorhersagen, auf welcher Verzweigung der Code weitergehen wird, und weiterhin Anweisungen unter Verwendung statischer Aufrufe senden. <br><br><h2>  Monomorphisierung </h2><br>  Dies ist eine Alternative zur Verpackung.  Bei der Monomorphisierung m√ºssen wir einen Weg finden, um f√ºr jeden Typ, den wir verwenden m√∂chten, mehrere Versionen des Codes zu generieren.  Compiler haben mehrere Pr√§sentationsphasen, die der Code durchl√§uft, und k√∂nnen theoretisch in jede dieser Phasen kopiert werden. <br><br><h3>  Quellcode-Generierung </h3><br>  Der einfachste Weg zur Monomorphisierung ist das Kopieren in der ersten Pr√§sentationsphase: Kopieren Sie den Quellcode!  Dann muss der Compiler nicht einmal Generika unterst√ºtzen, und dies wird manchmal von Benutzern der Sprachen C und Go durchgef√ºhrt, deren Compiler diese Unterst√ºtzung nicht haben. <br><br>  In C k√∂nnen Sie einen Pr√§prozessor verwenden und die Datenstruktur in einem Makro oder Header definieren, indem Sie sie wiederholt mit einem anderen <code>#define</code> einf√ºgen.  Go hat Skripte wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Genny</a> , die es einfach machen, Code zu generieren. <br><br>  Der Nachteil des Duplizierens des Quellcodes besteht darin, dass es je nach Sprache erforderlich sein kann, sich mit zahlreichen Problemen und Randf√§llen zu befassen. Dar√ºber hinaus analysiert und pr√ºft der Compiler viele Male nach Typen, die tats√§chlich denselben Code enthalten.  Abh√§ngig von der Sprache und den Werkzeugen kann es wiederum schwierig sein, diese generischen Methoden zu schreiben und zu verwenden, da in einem C-Makro jede Zeile mit einem Backslash endet und alle Arten und Namen von Funktionen manuell in ihre Bezeichner eingeklebt werden m√ºssen, um Kollisionen zu vermeiden. <br><br><h3>  String-Mixins in D. </h3><br>  Die Codegenerierung hat jedoch ihre Vorteile, z. B. die Tatsache, dass Sie Code mit einer vollwertigen Programmiersprache generieren und eine den Benutzern vertraute Ansicht verwenden k√∂nnen. <br><br>  In einigen Sprachen, in denen Generika unterschiedlich implementiert sind, k√∂nnen Sie auch Code f√ºr allgemeinere Metaprogrammierungsf√§lle generieren, die in ihren generischen Systemen nicht ber√ºcksichtigt werden, z. B. f√ºr die Serialisierung.  Das verst√§ndlichste Beispiel sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">String-Mixins in D</a> , mit denen D-Code in Form von String-Werten w√§hrend der Kompilierung unter Verwendung aller Funktionen der Sprache kompiliert werden kann. <br><br><h3>  Rust-Verfahrensmakros </h3><br>  Ein √§hnliches Beispiel, nur mit einer Darstellung im Compiler in nur einer Phase.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust-Prozedurmakros</a> verwenden Token-Streams als Eingabe und Ausgabe und bieten Dienstprogramme zum Konvertieren dieser Streams in Zeichenfolgen und umgekehrt.  Der Vorteil dieses Ansatzes besteht darin, dass Token-Streams Standortinformationen aus dem Quellcode speichern k√∂nnen.  Der vom Benutzer geschriebene Code, das Makro, kann als Token direkt von der Eingabe bis zum Wochenende eingef√ºgt werden.  Und wenn dieser Code zu einem Kompilierungsfehler in der Ausgabe der Macos f√ºhrt, zeigt der Compiler eine Meldung an und zeigt genau auf die Datei, Zeile und Spalte des fehlerhaften Teils des Codes.  Wenn das Makro jedoch einen fehlerhaften Code generiert, zeigt eine Fehlermeldung einen Makroaufruf an.  Wenn Sie beispielsweise ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Makro verwenden, das eine Funktion beim Protokollieren von Aufrufen umschlie√üt</a> und beim Implementieren einer umschlossenen Funktion einen Fehler macht, verweist die Fehlermeldung direkt auf den Fehler in der Datei und nicht auf den vom Makro generierten Code. <br><br><h3>  Syntaxbaummakros </h3><br>  Einige Sprachen gehen sogar noch weiter und bieten Tools zum Verwenden und Erstellen verschiedener Arten von abstrakten Syntaxb√§umen in Makros (Abstract Syntax Tree, AST).  Beispiele hierf√ºr sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Template Haskell</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nim-Makros</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OCaml PPX</a> und fast alle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lisp</a> . <br><br>  Der Nachteil von AST-Makros besteht darin, dass Sie Benutzer nicht zwingen m√∂chten, eine Reihe von Funktionen zum Erstellen von AST-Typen sowie grundlegende Sprachen zu erlernen.  In der Lisp-Sprachfamilie wird dies mithilfe einer starken Vereinfachung und maximalen √úbereinstimmung zwischen Syntax und Struktur des AST gel√∂st. Das Erstellen von Strukturen ist jedoch nicht immer einfach. <br><br>  Daher gibt es in allen Sprachen, die ich erw√§hnt habe, in der einen oder anderen Form ein "Zitat" -Primitiv, dem Sie einen Code in der Sprache geben und der einen Syntaxbaum zur√ºckgibt.  Diese Grundelemente k√∂nnen die Werte des Syntaxbaums mithilfe der √Ñhnlichkeit der Zeichenfolgeninterpolation zusammenf√ºhren.  Hier ist ein Beispiel f√ºr Template Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- using AST construction functions genFn :: Name -&gt; Q Exp genFn f = do x &lt;- newName "x" lamE [varP x] (appE (varE f) (varE x)) -- using quotation with $() for splicing genFn' :: Name -&gt; Q Exp genFn' f = [| \x -&gt; $(varE f) x |]</span></span></code> </pre> <br>         ,     ,   ,           .      .  ,  PPX  OCaml  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     </a> /  ,  .  Rust  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">parsing</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">quotation</a> ,          ,       .    Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> ,    ,  </a> ! <br><br><h3>  Muster </h3><br>    ‚Äî        .   ++  D    ,         ¬´ ¬ª.        ,     ,      ,        ,   . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myMax</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a&gt;b?a:b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> {</span></span> T values[<span class="hljs-number"><span class="hljs-number">2</span></span>]; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ myMax(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); Pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p { {<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>} }; <span class="hljs-comment"><span class="hljs-comment">// This would give us a compile error inside myMax // about Pair being an invalid operand to `&gt;`: // myMax(p, p); }</span></span></code> </pre> <br>       ,                 ,        .     ,         ,     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">D</a>     ,  ,       :       ,    ,       .    D;    <code>if</code>       ( <code>!</code>     ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// We're going to use the isNumeric function in std.traits import std.traits; // The `if` is optional (without it you'll get an error inside like C++) // The `if` is also included in docs and participates in overloading! T myMax(T)(T a, T b) if(isNumeric!T) { return (a&gt;b?a:b); } struct Pair(T) { T[2] values; } void main() { myMax(5, 6); Pair!int p = {[5,6]}; // This would give a compile error saying that `(Pair!int, Pair!int)` // doesn't match the available instance `myMax(T a, T b) if(isNumeric!T)`: // myMax(p, p); }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C++20  ¬´¬ª</a> ,      ,           . <br><br><h3>    </h3><br>    D   ,        (compile time function evaluation)  <code>static if</code> , ,  ,    ,          - runtime-.          , ,   ,    ++    ,    . <br><br>  ,      ¬´    ¬ª. , Zig: <br><br><pre> <code class="plaintext hljs">fn Stack(comptime T: type) type { return struct { items: []T, len: usize, const Self = @This(); pub fn push(self: Self, item: T) { // ... } }; }</code> </pre> <br>  Zig            ,      ,  <code>comptime</code> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Terra</a>    ,   . Terra ‚Äî   Lua,     -  ,     Lua API    ,    quoting  splicing: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> struct Stack { items : &amp;T; <span class="hljs-comment"><span class="hljs-comment">-- &amp;T is a pointer to T len : int; } terra Stack:push(item : T) -- ... end return Stack end</span></span></code> </pre> <br>     Terra  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">        - (domain specific) </a> ,       <a href="">Java</a>  <a href="">Go</a>      .    Terra      runtime     ,   . <br><br><h3>   Rust </h3><br>           ,   .  ,    ,      ++,       .   ,    ,  ,     ,   .      ,                  .     Rust,     ‚Äî  Swift  Haskell. <br><br>  Rust      ¬´ ¬ª (trait bounds). <code>Trait</code> ‚Äî      ,    ,  .  Rust ,     -    ,   ,      ,      .   -  Rust <i></i>         .  ,           -. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_max</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span>&gt;(a: T, b: T) -&gt; T { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &gt; b { a } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { b } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span></span>&lt;T&gt; { values: [T; <span class="hljs-number"><span class="hljs-number">2</span></span>], } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { my_max(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p: Pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; = Pair { values: [<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>] }; <span class="hljs-comment"><span class="hljs-comment">// Would give a compile error saying that // PartialOrd is not implemented for Pair&lt;i32&gt;: // my_max(p,p); }</span></span></code> </pre> <br>           ,            .  Rust       .  Rust 2018    ,    <code>v: &amp;impl SomeTrait</code>  ,   <code>v: &amp;dyn SomeTrait</code>  .      GHC  Swift  Haskell     ,       . <br><br><h3>    </h3><br>        ‚Äî          ,  .      ,    (placeholders)  -,           ,    .            <code>memcpy</code>   ,  !   ,       .          .         JIT,            ,     . <br><br>   ,      ,    ,   ,        ,     ,        !  ,              ,   ,       .  ,        ,              . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461321/">https://habr.com/ru/post/de461321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461307/index.html">Wir laden Sie zum VK Hackathon 2019 ein. Der diesj√§hrige Preispool betr√§gt zwei Millionen Rubel.</a></li>
<li><a href="../de461309/index.html">Alles au√üer Kotlin: Andrei Breslav √ºber die Ausgewogenheit der Geschlechter in IT, Emotionen und mehr</a></li>
<li><a href="../de461313/index.html">Zimbra 8.8.15 LTS ver√∂ffentlicht</a></li>
<li><a href="../de461317/index.html">9 Grunds√§tze f√ºr die Erstellung hochwertiger iOS-Anwendungen</a></li>
<li><a href="../de461319/index.html">Was macht ein Spieledesigner?</a></li>
<li><a href="../de461323/index.html">Eine leicht zug√§ngliche Erkl√§rung des Wellenfunktionskollapsalgorithmus</a></li>
<li><a href="../de461325/index.html">Sieg bei PHDays 9. Wir teilen Life Hacks in drei Teilen. Teil 3</a></li>
<li><a href="../de461327/index.html">Frontend-Krise?</a></li>
<li><a href="../de461329/index.html">Automatische Segmentierung der Atmungsorgane</a></li>
<li><a href="../de461333/index.html">ITX5 Mitap: Live JAVA, Kotlin Magic und Tomatenzunder</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>