<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏾 😱 👸🏽 Generische und Metaprogrammiermodelle: Go, Rust, Swift, D und andere 🕎 🦏 📚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einigen Bereichen der Programmierung ist es normal, eine Datenstruktur oder einen Algorithmus schreiben zu wollen, der mit Elementen unterschiedlic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generische und Metaprogrammiermodelle: Go, Rust, Swift, D und andere</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/461321/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/o5/zc/cso5zcp78nxxi31mspfvdat89w4.jpeg"></div><br>  In einigen Bereichen der Programmierung ist es normal, eine Datenstruktur oder einen Algorithmus schreiben zu wollen, der mit Elementen unterschiedlicher Typen arbeiten kann.  Zum Beispiel eine Liste von Generika oder ein Sortieralgorithmus, der nur eine Vergleichsfunktion benötigt.  In verschiedenen Sprachen werden verschiedene Möglichkeiten zur Lösung dieses Problems vorgeschlagen: vom einfachen Aufzeigen der entsprechenden gemeinsamen Funktionen (C, Go) über Programmierer bis hin zu so leistungsfähigen generischen Systemen, dass sie vollständig werden ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++</a> ).  In diesem Artikel werde ich über generische Systeme aus verschiedenen Sprachen und deren Implementierung sprechen.  Ich werde zunächst das Problem in Sprachen ohne ein ähnliches System (wie C) lösen und dann zeigen, wie das schrittweise Hinzufügen von Erweiterungen zu Systemen aus anderen Sprachen führt. <br><a name="habracut"></a><br>  Ich finde Generika eine interessante Option, da sie ein einfacher Spezialfall des allgemeinen Metaprogrammierungsproblems sind: Schreiben von Programmen, die Klassen anderer Programme generieren können.  Als Beweis werde ich zeigen, wie drei verschiedene und vollständig allgemeine Metaprogrammierungsmethoden als multidirektionale Erweiterungen im Bereich generischer Systeme betrachtet werden können: dynamische Sprachen wie Python, prozedurale Makrosysteme wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Template Haskel</a> und schrittweise Kompilierung wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zig</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Terra</a> . <br><br><h2>  Rückblick </h2><br>  Ich habe ein Blockdiagramm aller im Artikel beschriebenen Systeme gezeichnet, damit Sie deren Inhalt und die Art und Weise, wie diese Systeme miteinander verbunden sind, darstellen können: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/259/577/5fa259577cd99685d90ab7912710e348.png"><br><br><h2>  Hauptideen </h2><br>  Angenommen, wir schreiben in einer Sprache ohne generische Systeme und möchten eine generische Stapeldatenstruktur erstellen, die mit Daten eines beliebigen Typs funktioniert.  Das Problem ist, dass jede Funktions- und Typdefinition nur mit Daten derselben Größe funktioniert und auf eine Weise kopiert wird und im Allgemeinen ähnlich funktioniert. <br><br>  Es gibt zwei Möglichkeiten, dies zu umgehen: Stellen Sie entweder sicher, dass alle Datentypen in unserer Struktur gleich funktionieren, oder erstellen Sie viele Kopien der Datenstruktur mit geringfügigen Änderungen, damit sie mit jedem Datentyp ordnungsgemäß funktionieren.  Diese Ideen bildeten die Grundlage für zwei große Gruppen von Lösungen mit Generika: Boxen und Monomorphisierung. <br><br>  Verpacken bedeutet, alles in einer Reihe in einheitliche „Kisten“ zu packen, die auf die gleiche Weise funktionieren.  Dies geschieht normalerweise so: Die Daten werden in einen Heap gestellt und die Zeiger darauf werden in die Datenstruktur gestellt.  Sie können Zeiger auf alle Typen erstellen, die auf die gleiche Weise funktionieren, sodass derselbe Code mit Daten aller Art funktioniert!  Dies führt jedoch zu einem erhöhten Speicherverbrauch, dynamischer Suche und Cache-Fehlern.  In C bedeutet dies, dass Ihre Datenstruktur <code>void*</code> -Zeiger speichert und Daten einfach in und aus <code>void*</code> (wenn sich die Daten nicht auf dem Heap befinden, werden sie dort abgelegt). <br><br>  Monomorphisierung bedeutet, wiederholt Code für die verschiedenen Datentypen zu kopieren, die wir speichern möchten.  Dann kann jede Codeinstanz direkt die Größen- und Datenmethoden verwenden, mit denen sie ohne dynamische Suche arbeitet.  Bei diesem Ansatz wird der Code am schnellsten ausgeführt, aber seine Größe und Kompilierungszeit erhöhen sich, da wir denselben Code wiederholt mit geringfügigen Änderungen kompilieren.  In C entspricht dies der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Definition der gesamten Datenstruktur als Makro</a> , gefolgt von ihrem Aufruf für jeden Datentyp. <br><br>  Im Allgemeinen wird der Code während der Kompilierung schneller kompiliert, aber seine Leistung kann sich während der Ausführung verschlechtern, während wir während der Monomorphisierung schnellen Code generieren, aber es dauert länger, alle Instanzen des Codes zu kompilieren und zu optimieren.  Ein weiterer Unterschied besteht darin, dass Sie beim Packen von Erweiterungen ein dynamischeres Verhalten des ausführbaren Codes und durch Monomorphisierung verschiedene Instanzen des generischen Codes flexibler trennen können.  Es ist auch erwähnenswert, dass in einigen großen Programmen die Vorteile der Monomorphisierung durch Fehler im Cache zusätzlicher Anweisungen aus dem generierten Code ausgeglichen werden können. <br><br>  Jedes der beschriebenen Schemata für die Arbeit mit Generika kann in verschiedene Richtungen erweitert werden, wenn Sie mehr Funktionen oder Sicherheit benötigen, und die Autoren verschiedener Sprachen haben sehr interessante Lösungen gefunden.  Zum Beispiel können beide Ansätze in Rust und C # verwendet werden! <br><br><h2>  Verpackung </h2><br>  Beginnen wir mit einem Beispiel für eine Basisverpackung in Go: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Stack <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { values []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { this.values = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(this.values, value) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { x := this.values[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] this.values = this.values[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x }</code> </pre> <br>  Außerdem wird das Packen in C ( <code>void*</code> ), Go ( <code>interface{}</code> ), vorgenerischem Java ( <code>Object</code> ) und vorgenerischem Objective-C ( <code>id</code> ) verwendet. <br><br><h2>  Gepackte Generika mit Maischetypen </h2><br>  Die Hauptverpackungsmethode hat Nachteile: <br><br><ul><li>  Abhängig von der Sprache müssen wir häufig bei jedem Lesen oder Schreiben in die Datenstruktur Werte in oder aus dem richtigen Typ umwandeln. <br></li><li>  Nichts hindert uns daran, Elemente unterschiedlichen Typs in die Struktur einzufügen, was zu Fehlern führen kann, die während der Codeausführung wie Abstürze aussehen. <br></li></ul><br>  Beide Probleme können gelöst werden, indem dem System von Funktionalitätstypen Generika hinzugefügt werden, während die Hauptverpackungsmethode auf die gleiche Weise wie zuvor während der Codeausführung verwendet wird.  Dieser Ansatz wird häufig als Typlöschung bezeichnet, da Typen im generischen System überschrieben werden und zu einem Typ unter der Haube werden (wie <code>Object</code> ). <br><br>  Java und Objective-C begannen mit der üblichen Verpackung und erwarben später aus Kompatibilitätsgründen Sprachtools für Generika mit Typ-Mashing, wobei dieselben Sammlungstypen wie zuvor verwendet wurden, jedoch mit den optionalen Parametern generischer Typen.  Betrachten Sie ein Beispiel aus einem Wikipedia-Artikel über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Generika in Java</a> : <br><br><pre> <code class="java hljs">List v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); v.add(<span class="hljs-string"><span class="hljs-string">"test"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// A String that cannot be cast to an Integer Integer i = (Integer)v.get(0); // Run time error List&lt;String&gt; v = new ArrayList&lt;String&gt;(); v.add("test"); Integer i = v.get(0); // (type error) compilation-time error</span></span></code> </pre><br><h3>  Abgeleitete verpackte Generika mit einheitlicher Leistung </h3><br>  OCaml entwickelt die Idee einer einheitlichen Sichtweise weiter.  Es gibt keine primitiven Typen, die eine zusätzliche Paketplatzierung benötigen (da ein <code>int</code> in eine <code>Integer</code> , um in eine <code>ArrayList</code> in Java zu gelangen), da alles bereits gepackt oder durch einen ganzzahligen Wert von der Größe eines Zeigers dargestellt ist, dh alles passt in ein Maschinenwort.  Wenn der Garbage Collector jedoch die in generischen Strukturen gespeicherten Daten betrachtet, muss er Zeiger von Zahlen unterscheiden. Daher werden Zahlen mit einem einzelnen Bit markiert, das dort platziert wird, wo korrekt ausgerichtete Zeiger kein Bit haben, sodass nur Bereiche von 31 oder 63 Bit übrig bleiben. <br><br>  OCaml verfügt auch über ein Typinferenzsystem, sodass Sie eine Funktion schreiben können und der Compiler den am besten geeigneten generischen Typ ausgibt, wenn Sie ihn nicht mit Anmerkungen versehen. Die Funktionen sehen also wie eine dynamisch typisierte Sprache aus: <br><br><pre> <code class="plaintext hljs">let first (head :: tail) = head (* inferred type: 'a list -&gt; 'a *)</code> </pre> <br>  Der angegebene Typ kann als "eine Funktion aus der Liste der Elemente vom Typ <code>'a</code> in etwas mit dem Typ <code>'a</code> " bezeichnet werden.  Dies bedeutet, dass der Rückgabetyp mit dem Listentyp identisch ist und ein beliebiger Typ sein kann. <br><br><h2>  Schnittstellen </h2><br>  Eine weitere Einschränkung herkömmlicher Verpackungen besteht darin, dass verpackte Typen <i>vollständig</i> undurchsichtig sind.  Dies ist kein Problem für Datenstrukturen wie einen Stapel, aber Tools wie das Sortieren generischer Funktionen benötigen zusätzliche Funktionen, wie z. B. typspezifische Vergleichsfunktionen.  Es gibt viele Möglichkeiten, dies zur Laufzeit zu implementieren und in der Sprache wiederzugeben. Technisch gesehen sind dies unterschiedliche Richtungen, und Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieselbe Sprache mit mehreren ähnlichen Ansätzen implementieren</a> .  Die Funktionen verschiedener Sprachen wirken sich jedoch auf ihre Implementierung aus, und erst dann verbessern Erweiterungen die Stärken der ausgewählten Implementierungen.  Dies bedeutet, dass es zwei Sprachfamilien gibt, die auf unterschiedlichen Laufzeitansätzen basieren: virtuelle Methodentabellen (vtables) und Wörterbuchübertragung. <br><br><h3>  Tabellen für Schnittstellenmethoden </h3><br>  Wenn wir typspezifische Funktionen bereitstellen möchten, die sich an die Verpackungsstrategie halten, um eine einheitliche Arbeit mit allem zu ermöglichen, reicht es aus, eine einheitliche Methode zu haben, um ähnliche Funktionen zu finden, die wir vom Objekt erhalten müssen.  Dieser Ansatz wird als "virtuelle Methodentabellen" (vtables, virtuelle Methodentabellen) bezeichnet, obwohl niemand den vollständigen Namen verwendet.  Es wird wie folgt implementiert: Bei einem Nullpunktversatz in jedem generischen Strukturobjekt gibt es einen Zeiger auf eine Tabelle von Funktionszeigern mit einer konsistenten Schaltung.  In diesen Tabellen sucht der generische Code nach Zeigern auf typspezifische Funktionen, indem bestimmte Zeiger mit festen Offsets indiziert werden. <br><br>  Auf diese Weise werden <code>interface</code> in Go- und <code>dyn trait</code> Objekten in Rust implementiert.  Wenn Sie einen Typ in einen Schnittstellentyp der Implementierung umwandeln, wird ein Wrapper für die Schnittstelle erstellt, der einen Zeiger auf das Quellobjekt und einen Zeiger auf die vtable typspezifischer Funktionen enthält.  Dies erfordert jedoch eine zusätzliche Ebene der indirekten Adressierung von Zeigern und ein anderes Schema.  Daher verwendet das Sortieren in Go die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstelle für den Container mit der Swap-Methode</a> und verwendet nicht das Slice der Comparable-Schnittstelle, da hierfür ein völlig neues Slice von Schnittstellentypen im Speicher abgelegt werden müsste, das anstelle des ursprünglichen Slice sortiert würde! <br><br><h3>  Objektorientierte Programmierung </h3><br>  OOP ist eine Spracheigenschaft, die die Funktionen virtueller Typentabellen optimal nutzt.  Anstelle von separaten Schnittstellenobjekten mit vtables fügen OOP-Sprachen wie Java einfach einen Zeiger auf eine Tabelle virtueller Typen am Anfang jedes Objekts ein.  Java-ähnliche Sprachen verfügen über ein Vererbungssystem und Schnittstellen, die mithilfe dieser Objekttabellen vom virtuellen Typ vollständig implementiert werden können. <br><br>  Durch das Einbetten von vtable in jedes Objekt werden nicht nur zusätzliche Funktionen bereitgestellt, sondern auch das Problem gelöst, dass neue Schnittstellentypen mit indirekter Adressierung (Indirektion) erstellt werden müssen.  Im Gegensatz zu Go kann die <code>Comparable</code> in Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Schnittstelle <code>Comparable</code> auf die von ihr implementierten Typen anwenden. <br><br><h3>  Reflexion </h3><br>  Wenn Sie Tabellen mit virtuellen Typen haben, ist es für Sie nicht schwierig, den Compiler zu zwingen, Tabellen mit anderen Informationstypen zu generieren, z. B. Namen von Feldern, Typen und Speicherorten.  Dies ermöglicht den Zugriff auf alle Daten dieses Typs mithilfe von Code, mit dem alle Daten anderer Typen angezeigt werden können.  Dieses Verhalten kann verwendet werden, um der Sprache „Reflexion“ hinzuzufügen, was eine Serialisierung und eine schöne Anzeige beliebiger Typen ermöglicht.  Reflexion als Erweiterung des Verpackungsparadigmas hat einen Nachteil: Dafür reicht nur eine Kopie des Codes aus, aber Sie müssen viele dynamische Suchvorgänge durchführen, wodurch die Serialisierungsgeschwindigkeit verringert wird. <br><br>  Sprachen, die Reflection für die Serialisierung und andere Funktionen verwenden: Java, C # und Go. <br><br><h3>  Dynamisch getippte Sprachen </h3><br>  Reflection ist ein sehr leistungsfähiges Tool, mit dem Sie eine Reihe verschiedener Metaprogrammieraufgaben lösen können.  Sie können jedoch keine neuen Typen erstellen oder Informationen zu den Typen vorhandener Werte bearbeiten.  Wenn wir diese Funktion hinzufügen und Datenzugriffs- und Änderungssyntaxen standardmäßig Reflektion verwenden, erhalten wir dynamisch typisierte Sprachen!  Die unglaubliche Flexibilität der Metaprogrammierung in Sprachen wie Python und Ruby ist dank der effektiven, leistungsstarken Reflexionssysteme entstanden, mit denen Probleme gelöst werden können. <br><br>  Sie können sagen: "Aber dynamische Sprachen funktionieren nicht so, sie implementieren einfach alles mithilfe von Hash-Tabellen!"  Hash-Tabellen sind nur eine gute Datenstruktur zum Erstellen bearbeitbarer Tabellen mit Typinformationen.  Darüber hinaus arbeiten einige Interpreter wie CPython auf diese Weise.  In einer Hochleistungs-JIT, beispielsweise V8, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt es viele virtuelle Typentabellen und</a> Reflexionsinformationen.  In V8 ähneln versteckte Klassen (vtables und Reflection-Informationen) und die Struktur von Objekten denen in Java VM, wobei Objekte zur Laufzeit durch neue virtuelle Typentabellen ersetzt werden können.  Dies ist kein Zufall, da es keine Zufälle gibt: Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwickler</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von V8 arbeitete</a> früher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">an Hochleistungs-Java-VMs</a> . <br><br><h3>  Wörterbuchübertragung </h3><br>  Eine andere Möglichkeit, dynamische Schnittstellen zu implementieren, besteht darin, eine Tabelle mit den erforderlichen Funktionszeigern auf die generische Funktion zu übertragen, die sie benötigt.  Dies ähnelt in gewisser Weise der Erstellung von Go-förmigen Schnittstellenobjekten am Aufrufort. In unserem Fall wird die Tabelle jedoch als verstecktes Argument übergeben und nicht als eines der vorhandenen Argumente in ein Bundle gepackt. <br><br>  Dieser Ansatz wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typklassen in Haskell verwendet</a> , obwohl Sie mit GHC eine Art Monomorphisierung mithilfe von Inlining und Spezialisierung durchführen können.  OCaml verwendet die Wörterbuchübertragung mit einem expliziten Argument in Form <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstklassiger Module. Es</a> wurde jedoch bereits vorgeschlagen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Möglichkeit hinzuzufügen, den Parameter implizit zu machen</a> . <br><br><h3>  Zeugen-Tische in Swift </h3><br>  Die Swift-Autoren verwendeten eine interessante Lösung: Durch das Übertragen des Wörterbuchs sowie das Einfügen von Daten zu den Schriftgrößen und zum Verschieben, Kopieren und Freigeben in die Tabelle können Sie alle erforderlichen Informationen für eine einheitliche Arbeit mit beliebigen Typen bereitstellen, ohne sie zu verpacken.  Somit kann Swift Generika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ohne Monomorphisierung und Platzierung im Speicher in einer einheitlichen Darstellung</a> aller Entitäten implementieren!  Ja, Sie müssen für dynamische Suchvorgänge bezahlen, wie es für die gesamte Familie charakteristisch ist, die Verpackungen verwendet, aber es spart Ressourcen für die Speicherung, den Verbrauch und die Cache-Inkonsistenz.  Mit den <a href="">als @inlinable gekennzeichneten</a> Funktionen kann der Swift-Compiler auch Generika innerhalb des Moduls oder zwischen Modulen spezialisieren (monomorphisieren) und inline <a href="">generieren</a> , um die genannten Kosten zu vermeiden.  Wahrscheinlich wird eine heuristische Bewertung der Auswirkung auf die Codegröße verwendet. <br><br>  Dies erklärt auch, wie Swift <a href="">die ABI-Stabilität implementieren</a> kann, während Sie weiterhin Felder in der Struktur hinzufügen und neu verteilen können, obwohl die Autoren das Attribut <code>@frozen</code> , um dynamische Suchen für eine bessere Leistung abzulehnen. <br><br><h3>  Intensive Typanalyse </h3><br>  Es gibt eine andere Möglichkeit, Schnittstellen für verpackte Typen zu implementieren.  Wir fügen die Typkennung nach dem Beispiel des vtable-Zeigers einem bestimmten Teil des Objekts hinzu und generieren dann Funktionen für jede Schnittstellenmethode, die einen großen <code>switch</code> für alle Typen hat, die diese Methode implementieren, und übergeben sie an die richtige typspezifische Methode. <br><br>  Ich warne nicht davor, Sprachen zu verwenden, die diesen Ansatz verwenden, aber C ++ - Compiler und virtuelle Java-Maschinen verhalten sich ähnlich, wenn sie bei der Optimierung anhand von Profilen feststellen, dass ein bestimmter Ort zum Aufrufen von Generika hauptsächlich mit Objekten bestimmter Typen funktioniert.  Compiler und VMs ersetzen Anrufpunkte durch Prüfungen für jeden normalen Typ und versenden diese Typen dann statisch als Fallback unter Verwendung des herkömmlichen dynamischen Versands.  Daher kann der Verzweigungsvorhersagealgorithmus vorhersagen, auf welcher Verzweigung der Code weitergehen wird, und weiterhin Anweisungen unter Verwendung statischer Aufrufe senden. <br><br><h2>  Monomorphisierung </h2><br>  Dies ist eine Alternative zur Verpackung.  Bei der Monomorphisierung müssen wir einen Weg finden, um für jeden Typ, den wir verwenden möchten, mehrere Versionen des Codes zu generieren.  Compiler haben mehrere Präsentationsphasen, die der Code durchläuft, und können theoretisch in jede dieser Phasen kopiert werden. <br><br><h3>  Quellcode-Generierung </h3><br>  Der einfachste Weg zur Monomorphisierung ist das Kopieren in der ersten Präsentationsphase: Kopieren Sie den Quellcode!  Dann muss der Compiler nicht einmal Generika unterstützen, und dies wird manchmal von Benutzern der Sprachen C und Go durchgeführt, deren Compiler diese Unterstützung nicht haben. <br><br>  In C können Sie einen Präprozessor verwenden und die Datenstruktur in einem Makro oder Header definieren, indem Sie sie wiederholt mit einem anderen <code>#define</code> einfügen.  Go hat Skripte wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Genny</a> , die es einfach machen, Code zu generieren. <br><br>  Der Nachteil des Duplizierens des Quellcodes besteht darin, dass es je nach Sprache erforderlich sein kann, sich mit zahlreichen Problemen und Randfällen zu befassen. Darüber hinaus analysiert und prüft der Compiler viele Male nach Typen, die tatsächlich denselben Code enthalten.  Abhängig von der Sprache und den Werkzeugen kann es wiederum schwierig sein, diese generischen Methoden zu schreiben und zu verwenden, da in einem C-Makro jede Zeile mit einem Backslash endet und alle Arten und Namen von Funktionen manuell in ihre Bezeichner eingeklebt werden müssen, um Kollisionen zu vermeiden. <br><br><h3>  String-Mixins in D. </h3><br>  Die Codegenerierung hat jedoch ihre Vorteile, z. B. die Tatsache, dass Sie Code mit einer vollwertigen Programmiersprache generieren und eine den Benutzern vertraute Ansicht verwenden können. <br><br>  In einigen Sprachen, in denen Generika unterschiedlich implementiert sind, können Sie auch Code für allgemeinere Metaprogrammierungsfälle generieren, die in ihren generischen Systemen nicht berücksichtigt werden, z. B. für die Serialisierung.  Das verständlichste Beispiel sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">String-Mixins in D</a> , mit denen D-Code in Form von String-Werten während der Kompilierung unter Verwendung aller Funktionen der Sprache kompiliert werden kann. <br><br><h3>  Rust-Verfahrensmakros </h3><br>  Ein ähnliches Beispiel, nur mit einer Darstellung im Compiler in nur einer Phase.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust-Prozedurmakros</a> verwenden Token-Streams als Eingabe und Ausgabe und bieten Dienstprogramme zum Konvertieren dieser Streams in Zeichenfolgen und umgekehrt.  Der Vorteil dieses Ansatzes besteht darin, dass Token-Streams Standortinformationen aus dem Quellcode speichern können.  Der vom Benutzer geschriebene Code, das Makro, kann als Token direkt von der Eingabe bis zum Wochenende eingefügt werden.  Und wenn dieser Code zu einem Kompilierungsfehler in der Ausgabe der Macos führt, zeigt der Compiler eine Meldung an und zeigt genau auf die Datei, Zeile und Spalte des fehlerhaften Teils des Codes.  Wenn das Makro jedoch einen fehlerhaften Code generiert, zeigt eine Fehlermeldung einen Makroaufruf an.  Wenn Sie beispielsweise ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Makro verwenden, das eine Funktion beim Protokollieren von Aufrufen umschließt</a> und beim Implementieren einer umschlossenen Funktion einen Fehler macht, verweist die Fehlermeldung direkt auf den Fehler in der Datei und nicht auf den vom Makro generierten Code. <br><br><h3>  Syntaxbaummakros </h3><br>  Einige Sprachen gehen sogar noch weiter und bieten Tools zum Verwenden und Erstellen verschiedener Arten von abstrakten Syntaxbäumen in Makros (Abstract Syntax Tree, AST).  Beispiele hierfür sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Template Haskell</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nim-Makros</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OCaml PPX</a> und fast alle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lisp</a> . <br><br>  Der Nachteil von AST-Makros besteht darin, dass Sie Benutzer nicht zwingen möchten, eine Reihe von Funktionen zum Erstellen von AST-Typen sowie grundlegende Sprachen zu erlernen.  In der Lisp-Sprachfamilie wird dies mithilfe einer starken Vereinfachung und maximalen Übereinstimmung zwischen Syntax und Struktur des AST gelöst. Das Erstellen von Strukturen ist jedoch nicht immer einfach. <br><br>  Daher gibt es in allen Sprachen, die ich erwähnt habe, in der einen oder anderen Form ein "Zitat" -Primitiv, dem Sie einen Code in der Sprache geben und der einen Syntaxbaum zurückgibt.  Diese Grundelemente können die Werte des Syntaxbaums mithilfe der Ähnlichkeit der Zeichenfolgeninterpolation zusammenführen.  Hier ist ein Beispiel für Template Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- using AST construction functions genFn :: Name -&gt; Q Exp genFn f = do x &lt;- newName "x" lamE [varP x] (appE (varE f) (varE x)) -- using quotation with $() for splicing genFn' :: Name -&gt; Q Exp genFn' f = [| \x -&gt; $(varE f) x |]</span></span></code> </pre> <br>         ,     ,   ,           .      .  ,  PPX  OCaml  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     </a> /  ,  .  Rust  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">parsing</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">quotation</a> ,          ,       .    Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> ,    ,  </a> ! <br><br><h3>  Muster </h3><br>    —        .   ++  D    ,         « ».        ,     ,      ,        ,   . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myMax</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a&gt;b?a:b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> {</span></span> T values[<span class="hljs-number"><span class="hljs-number">2</span></span>]; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ myMax(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); Pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p { {<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>} }; <span class="hljs-comment"><span class="hljs-comment">// This would give us a compile error inside myMax // about Pair being an invalid operand to `&gt;`: // myMax(p, p); }</span></span></code> </pre> <br>       ,                 ,        .     ,         ,     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">D</a>     ,  ,       :       ,    ,       .    D;    <code>if</code>       ( <code>!</code>     ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// We're going to use the isNumeric function in std.traits import std.traits; // The `if` is optional (without it you'll get an error inside like C++) // The `if` is also included in docs and participates in overloading! T myMax(T)(T a, T b) if(isNumeric!T) { return (a&gt;b?a:b); } struct Pair(T) { T[2] values; } void main() { myMax(5, 6); Pair!int p = {[5,6]}; // This would give a compile error saying that `(Pair!int, Pair!int)` // doesn't match the available instance `myMax(T a, T b) if(isNumeric!T)`: // myMax(p, p); }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C++20  «»</a> ,      ,           . <br><br><h3>    </h3><br>    D   ,        (compile time function evaluation)  <code>static if</code> , ,  ,    ,          - runtime-.          , ,   ,    ++    ,    . <br><br>  ,      «    ». , Zig: <br><br><pre> <code class="plaintext hljs">fn Stack(comptime T: type) type { return struct { items: []T, len: usize, const Self = @This(); pub fn push(self: Self, item: T) { // ... } }; }</code> </pre> <br>  Zig            ,      ,  <code>comptime</code> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Terra</a>    ,   . Terra —   Lua,     -  ,     Lua API    ,    quoting  splicing: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> struct Stack { items : &amp;T; <span class="hljs-comment"><span class="hljs-comment">-- &amp;T is a pointer to T len : int; } terra Stack:push(item : T) -- ... end return Stack end</span></span></code> </pre> <br>     Terra  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">        - (domain specific) </a> ,       <a href="">Java</a>  <a href="">Go</a>      .    Terra      runtime     ,   . <br><br><h3>   Rust </h3><br>           ,   .  ,    ,      ++,       .   ,    ,  ,     ,   .      ,                  .     Rust,     —  Swift  Haskell. <br><br>  Rust      « » (trait bounds). <code>Trait</code> —      ,    ,  .  Rust ,     -    ,   ,      ,      .   -  Rust <i></i>         .  ,           -. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_max</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span>&gt;(a: T, b: T) -&gt; T { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &gt; b { a } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { b } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span></span>&lt;T&gt; { values: [T; <span class="hljs-number"><span class="hljs-number">2</span></span>], } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { my_max(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p: Pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; = Pair { values: [<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>] }; <span class="hljs-comment"><span class="hljs-comment">// Would give a compile error saying that // PartialOrd is not implemented for Pair&lt;i32&gt;: // my_max(p,p); }</span></span></code> </pre> <br>           ,            .  Rust       .  Rust 2018    ,    <code>v: &amp;impl SomeTrait</code>  ,   <code>v: &amp;dyn SomeTrait</code>  .      GHC  Swift  Haskell     ,       . <br><br><h3>    </h3><br>        —          ,  .      ,    (placeholders)  -,           ,    .            <code>memcpy</code>   ,  !   ,       .          .         JIT,            ,     . <br><br>   ,      ,    ,   ,        ,     ,        !  ,              ,   ,       .  ,        ,              . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461321/">https://habr.com/ru/post/de461321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461307/index.html">Wir laden Sie zum VK Hackathon 2019 ein. Der diesjährige Preispool beträgt zwei Millionen Rubel.</a></li>
<li><a href="../de461309/index.html">Alles außer Kotlin: Andrei Breslav über die Ausgewogenheit der Geschlechter in IT, Emotionen und mehr</a></li>
<li><a href="../de461313/index.html">Zimbra 8.8.15 LTS veröffentlicht</a></li>
<li><a href="../de461317/index.html">9 Grundsätze für die Erstellung hochwertiger iOS-Anwendungen</a></li>
<li><a href="../de461319/index.html">Was macht ein Spieledesigner?</a></li>
<li><a href="../de461323/index.html">Eine leicht zugängliche Erklärung des Wellenfunktionskollapsalgorithmus</a></li>
<li><a href="../de461325/index.html">Sieg bei PHDays 9. Wir teilen Life Hacks in drei Teilen. Teil 3</a></li>
<li><a href="../de461327/index.html">Frontend-Krise?</a></li>
<li><a href="../de461329/index.html">Automatische Segmentierung der Atmungsorgane</a></li>
<li><a href="../de461333/index.html">ITX5 Mitap: Live JAVA, Kotlin Magic und Tomatenzunder</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>