<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÑ üò¥ üéÑ Unterst√ºtzung von Visual Studio 2019 in PVS-Studio üîè üéñÔ∏è üßõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Unterst√ºtzung von Visual Studio 2019 in PVS-Studio betraf eine Reihe von Komponenten: das Plugin selbst, den Befehlszeilenanalysator, die Kerne de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unterst√ºtzung von Visual Studio 2019 in PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/454736/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de3/aea/16e/de3aea16e3b6472a4d5034fd035d8827.png"></div><br>  Die Unterst√ºtzung von Visual Studio 2019 in PVS-Studio betraf eine Reihe von Komponenten: das Plugin selbst, den Befehlszeilenanalysator, die Kerne der C ++ - und C # -Analysatoren sowie einige Dienstprogramme.  In diesem Artikel werde ich kurz erkl√§ren, auf welche Probleme wir bei der Implementierung der Unterst√ºtzung der IDE gesto√üen sind und wie wir sie behoben haben. <br><a name="habracut"></a><br>  Bevor wir beginnen, m√∂chte ich einen Blick auf die Geschichte der Unterst√ºtzung der vorherigen Versionen von Visual Studio in PVS-Studio werfen, damit Sie unsere Vision der Aufgabe und der L√∂sungen, die wir in jeder einzelnen Situation entwickelt haben, besser verstehen. <br><br>  Seit der ersten Version von PVS-Studio, die mit einem Plugin f√ºr Visual Studio ausgeliefert wurde (damals war es Visual Studio 2005), war die Unterst√ºtzung neuer Versionen dieser IDE f√ºr uns eine ziemlich triviale Aufgabe, die im Wesentlichen darauf hinauslief, das Projekt des Plugins zu aktualisieren Datei und Abh√§ngigkeiten der verschiedenen API-Erweiterungen von Visual Studio.  Hin und wieder mussten wir Unterst√ºtzung f√ºr neue Funktionen von C ++ hinzuf√ºgen, mit denen der Visual C ++ - Compiler allm√§hlich zu arbeiten lernte, aber es war im Allgemeinen auch keine schwierige Aufgabe und konnte direkt vor einer neuen Visual Studio-Version problemlos ausgef√ºhrt werden .  Au√üerdem hatte PVS-Studio damals nur einen Analysator - f√ºr C / C ++. <br><br>  Mit der Ver√∂ffentlichung von Visual Studio 2017 haben sich die Dinge ge√§ndert.  Zus√§tzlich zu den gro√üen √Ñnderungen an vielen API-Erweiterungen der IDE ist auch ein Problem mit der Aufrechterhaltung der Abw√§rtskompatibilit√§t des kurz zuvor hinzugef√ºgten neuen C # -Analysators (sowie der neuen Analysatorschicht f√ºr C ++ zur Arbeit mit MSBuild-Projekten) mit dem aufgetreten neue Versionen von MSBuild \ Visual Studio. <br><br>  In Anbetracht all dessen empfehle ich dringend, dass Sie einen verwandten Artikel √ºber die Unterst√ºtzung von Visual Studio 2017 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen:</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung von Visual Studio 2017 und Roslyn 2.0 in PVS-Studio: Manchmal ist es nicht so einfach, vorgefertigte L√∂sungen zu verwenden, wie es scheint</a> ", bevor Sie weiterlesen.  Dieser Artikel beschreibt die Probleme, mit denen wir das letzte Mal konfrontiert waren, und das Modell der Interaktion zwischen verschiedenen Komponenten (wie PVS-Studio, MSBuild und Roslyn).  Wenn Sie diese Details kennen, k√∂nnen Sie den aktuellen Artikel besser verstehen. <br><br>  Die L√∂sung dieser Probleme f√ºhrte letztendlich zu erheblichen √Ñnderungen am Analyseger√§t. Wir hatten gehofft, dass die dann angewandten neuen Ans√§tze uns helfen w√ºrden, zuk√ºnftige Versionen von Visual Studio \ MSBuild viel einfacher und schneller zu unterst√ºtzen.  Diese Hoffnung erwies sich bereits als realistisch, als die zahlreichen Updates von Visual Studio 2017 ver√∂ffentlicht wurden.  Hat uns der neue Ansatz bei der Unterst√ºtzung von Visual Studio 2019 geholfen?  Lesen Sie weiter, um es herauszufinden. <br><br><h2>  PVS-Studio Plugin f√ºr Visual Studio 2019 </h2><br>  Der Start schien vielversprechend.  Wir haben uns nicht viel M√ºhe gegeben, das Plugin auf Visual Studio 2019 zu portieren und es gut starten und laufen zu lassen.  Wir sind jedoch bereits auf zwei Probleme gleichzeitig gesto√üen, die sp√§ter weitere Probleme verursachen k√∂nnten. <br><br>  Das erste hatte mit der <i>IVsSolutionWorkspaceService-</i> Schnittstelle zu tun, die zur Unterst√ºtzung des Lightweight Solution Load-Modus verwendet wurde (der √ºbrigens in einem der fr√ºheren Updates in Visual Studio 2017 deaktiviert worden war).  Es wurde mit dem Attribut " <i>Veraltet"</i> dekoriert, das derzeit nur zum Zeitpunkt der Erstellung eine Warnung ausl√∂ste, aber in Zukunft zu einem gro√üen Problem werden w√ºrde.  Dieser Modus hielt in der Tat nicht lange an ... Das war leicht zu beheben - wir haben einfach aufgeh√∂rt, diese Schnittstelle zu verwenden. <br><br>  Das zweite Problem war die folgende Meldung, die beim Laden von Visual Studio mit aktiviertem Plugin immer wieder angezeigt wurde: <i>Visual Studio hat eine oder mehrere Erweiterungen erkannt, die gef√§hrdet sind oder in einem Feature-VS-Update nicht funktionieren.</i> <br><br>  Die Protokolle der Visual Studio-Starts (die ActivityLog-Datei) halfen beim Aufr√§umen: <br><br>  <i>Warnung: Die Erweiterung 'PVS-Studio' verwendet die Funktion 'Synchrones automatisches Laden' von Visual Studio.</i>  <i>Diese Funktion wird in einem zuk√ºnftigen Visual Studio 2019-Update nicht mehr unterst√ºtzt. Ab diesem Zeitpunkt funktioniert diese Erweiterung nicht mehr.</i>  <i>Bitte wenden Sie sich an den Anbieter der Erweiterung, um ein Update zu erhalten.</i> <br><br>  F√ºr uns bedeutete dies, dass wir vom synchronen in den asynchronen Lademodus wechseln mussten.  Ich hoffe, es macht Ihnen nichts aus, wenn ich Ihnen die Details der Interaktion mit den COM-Schnittstellen von Visual Studio erspare und die √Ñnderungen nur kurz skizziere. <br><br>  Es gibt einen Artikel von Microsoft √ºber das asynchrone Laden von Plugins: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gewusst wie: Verwenden von AsyncPackage zum Laden von VSPackages im Hintergrund</a> ".  Es war jedoch bereits klar, dass weitere √Ñnderungen folgen w√ºrden. <br><br>  Eine der gr√∂√üten √Ñnderungen war der Lademodus bzw. der Initialisierungsmodus.  In fr√ºheren Versionen wurde die gesamte erforderliche Initialisierung mit zwei Methoden durchgef√ºhrt: <i>Initialisierung</i> unserer von <i>Package</i> <i>geerbten</i> Klasse und <i>OnShellPropertyChange</i> .  Letzteres musste hinzugef√ºgt werden, da Visual Studio beim synchronen Laden m√∂glicherweise noch geladen und initialisiert wird und daher einige der erforderlichen Aktionen w√§hrend der Initialisierung des Plugins nicht ausgef√ºhrt werden konnten.  Eine M√∂glichkeit, dies zu beheben, bestand darin, die Ausf√ºhrung dieser Aktionen zu verz√∂gern, bis Visual Studio den Status "Zombie" beendet.  Es war dieser Teil der Logik, den wir in die <i>OnShellPropertyChange-</i> Methode mit einer √úberpr√ºfung des ' <i>Zombie'</i> -Status herausgegriffen haben. <br><br>  Die <i>Initialize-</i> Methode der abstrakten Klasse <i>AsyncPackage</i> , von der asynchron <i>geladene</i> Plugins <i>geerbt werden</i> , ist <i>versiegelt.</i> <i>Daher</i> muss die Initialisierung in der √ºberschriebenen Methode <i>InitializeAsync erfolgen</i> , genau wie wir es getan haben.  Die 'Zombie'-Check-Logik musste ebenfalls ge√§ndert werden, da die Statusinformationen f√ºr unser Plugin nicht mehr verf√ºgbar waren.  Au√üerdem mussten wir noch die Aktionen ausf√ºhren, die nach der Plugin-Initialisierung ausgef√ºhrt werden mussten.  Wir haben das gel√∂st, indem wir die <i>OnPackageLoaded-</i> Methode der <i>IVsPackageLoadEvents-</i> Schnittstelle verwendet haben, in der diese verz√∂gerten Aktionen ausgef√ºhrt wurden. <br><br>  Ein weiteres Problem beim asynchronen Laden war, dass die Befehle des Plugins erst nach dem Laden von Visual Studio verwendet werden konnten.  Das √ñffnen des Analyseprotokolls durch Doppelklicken im Dateimanager (falls Sie es in Visual Studio √∂ffnen mussten) f√ºhrte zum Starten der entsprechenden Version von devenv.exe mit einem Befehl zum √ñffnen des Protokolls.  Der Startbefehl sah ungef√§hr so ‚Äã‚Äãaus: <br><br><pre><code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\Common7\IDE\devenv.exe"</span></span> /command <span class="hljs-string"><span class="hljs-string">"PVSStudio.OpenAnalysisReport C:\Users\vasiliev\source\repos\ConsoleApp\ConsoleApp.plog"</span></span></code> </pre> <br>  Das Flag "/ command" wird hier verwendet, um den in Visual Studio registrierten Befehl auszuf√ºhren.  Dieser Ansatz funktionierte nicht mehr, da Befehle erst nach dem Laden des Plugins verf√ºgbar waren.  Die Problemumgehung bestand darin, den Startbefehl devenv.exe nach dem Laden des Plugins zu analysieren und den Befehl log open auszuf√ºhren, wenn er im Startbefehl gefunden wurde.  Das Verwerfen der Idee, die "geeignete" Schnittstelle f√ºr die Arbeit mit Befehlen zu verwenden, erm√∂glichte es uns, die erforderliche Funktionalit√§t beizubehalten und das Protokoll verz√∂gert zu √∂ffnen, nachdem das Plugin vollst√§ndig geladen wurde. <br><br>  Puh, sieht so aus, als h√§tten wir es endlich geschafft.  Das Plugin wird wie erwartet ohne Warnungen geladen und ge√∂ffnet. <br><br>  Und hier laufen die Dinge schief.  Paul (Hi Paul!) Installiert das Plugin auf seinem Computer und fragt, warum wir immer noch nicht auf asynchrones Laden umgestellt haben. <br><br>  Zu sagen, dass wir schockiert waren, w√§re eine Untertreibung.  Das konnte nicht sein!  Aber es ist real: Hier ist die neue Version des Plugins und hier ist eine Meldung, dass das Paket synchron geladen wird.  Alexander (Hallo Alexander!) Und ich versuche die gleiche Version auf unseren jeweiligen Computern - es funktioniert gut.  Wie ist das m√∂glich?  Dann f√§llt es uns ein, die Versionen der in Visual Studio geladenen PVS-Studio-Bibliotheken zu √ºberpr√ºfen - und wir stellen fest, dass dies die Bibliotheken f√ºr Visual Studio 2017 sind, w√§hrend das VSIX-Paket die neuen Versionen enth√§lt, d. H. F√ºr Visual Studio 2019. <br><br>  Nachdem wir eine Weile an VSIXInstaller herumgebastelt hatten, konnten wir feststellen, dass das Problem mit dem Paket-Cache zu tun hatte.  Diese Theorie wurde auch durch die Tatsache unterst√ºtzt, dass die Einschr√§nkung des Zugriffs auf das zwischengespeicherte Paket (C: \ ProgramData \ Microsoft \ VisualStudio \ Packages) dazu f√ºhrte, dass VSIXInstaller eine Fehlermeldung im Protokoll ausgab.  Seltsamerweise wurden die Informationen zur Installation zwischengespeicherter Pakete nicht angezeigt, wenn der Fehler nicht auftrat. <br><br>  <b>Randnotiz</b> .  W√§hrend ich das Verhalten von VSIX Installer und den zugeh√∂rigen Bibliotheken studierte, dachte ich, wie cool es ist, dass Roslyn und MSBuild Open Source sind, mit denen Sie ihren Code bequem lesen und debuggen und seine Arbeitslogik verfolgen k√∂nnen. <br><br>  Folgendes ist also passiert: Bei der Installation des Plugins hat VSIX Installer festgestellt, dass das entsprechende Paket bereits zwischengespeichert wurde (es war tats√§chlich das .vsix-Paket f√ºr Visual Studio 2017), und dieses Paket anstelle des neuen installiert.  Warum die in der .vsixmanifest-Datei definierten Einschr√§nkungen / Anforderungen (die unter anderem die Installation von Erweiterungen auf eine bestimmte Version von Visual Studio einschr√§nkten) ignoriert wurden, m√ºssen noch beantwortet werden.  Infolgedessen wurde das f√ºr Visual Studio 2017 entwickelte Plugin in Visual Studio 2019 installiert - trotz der in der .vsixmanifest-Datei angegebenen Einschr√§nkungen. <br><br>  Am schlimmsten war jedoch, dass diese Installation das Abh√§ngigkeitsdiagramm von Visual Studio durchbrach, und obwohl die IDE gut zu laufen schien, waren die Dinge tats√§chlich schrecklich.  Sie konnten keine Erweiterungen, Updates usw. installieren oder l√∂schen.  Der "Wiederherstellungs" -Prozess war ebenfalls schmerzhaft, da wir die Erweiterung (dh die Dateien, die sie enthalten) manuell l√∂schen und - auch manuell - die Konfigurationsdateien bearbeiten mussten, in denen die Informationen √ºber das installierte Paket gespeichert waren.  Mit anderen Worten, es hat √ºberhaupt keinen Spa√ü gemacht. <br><br>  Um dies zu beheben und sicherzustellen, dass wir in Zukunft nicht auf solche Situationen sto√üen, haben wir beschlossen, eine eigene GUID f√ºr das neue Paket zu erstellen, damit die Pakete f√ºr Visual Studio 2017 und Visual Studio 2019 sicher voneinander isoliert sind ( Die √§lteren Pakete waren in Ordnung (sie hatten immer eine gemeinsame GUID verwendet). <br><br>  Da wir √ºber unangenehme √úberraschungen gesprochen haben, ist hier noch eines: Nach dem Update auf Vorschau 2 wurde das PVS-Studio-Men√º auf die Registerkarte "Erweiterungen" "verschoben".  Keine gro√üe Sache, aber es machte den Zugriff auf die Funktionalit√§t des Plugins weniger bequem.  Dieses Verhalten blieb auch in den n√§chsten Visual Studio 2019-Versionen, einschlie√ülich der Version, bestehen.  Ich habe Erw√§hnungen dieser "Funktion" weder in der Dokumentation noch im Blog gefunden. <br><br>  Okay, jetzt sah es gut aus und wir schienen endlich mit der Unterst√ºtzung von Visual Studio 2019 fertig zu sein.  Dies erwies sich am n√§chsten Tag nach der Ver√∂ffentlichung von PVS-Studio 7.02 als falsch.  Es war wieder der asynchrone Lademodus.  Beim √ñffnen des Analyseergebnisfensters (oder Starten der Analyse) erscheint das Analysefenster dem Benutzer "leer" - keine Schaltfl√§chen, kein Raster, √ºberhaupt nichts. <br><br>  Dieses Problem trat tats√§chlich hin und wieder w√§hrend der Analyse auf.  Es betraf jedoch nur einen Computer und wurde erst angezeigt, als Visual Studio auf eine der ersten Iterationen von 'Vorschau' aktualisiert wurde.  Wir vermuteten, dass w√§hrend der Installation oder des Updates etwas kaputt gegangen war.  Das Problem verschwand jedoch einige Zeit sp√§ter und trat selbst auf diesem bestimmten Computer nicht auf. Daher dachten wir, dass es "von selbst behoben" wurde.  Aber nein - wir hatten einfach Gl√ºck.  Oder Pech. <br><br>  Wie wir festgestellt haben, war es die Reihenfolge, in der das IDE-Fenster selbst (die von <i>ToolWindowPane</i> abgeleitete <i>Klasse</i> ) und sein Inhalt (unser Steuerelement mit dem Raster und den Schaltfl√§chen) initialisiert wurden.  Unter bestimmten Bedingungen wurde das Steuerelement vor dem Fenster initialisiert, und obwohl die Dinge gut liefen und die <i>FindToolWindowAsync-</i> Methode (die das Fenster beim ersten Zugriff erstellt) ihre Aufgabe gut erledigte, blieb das Steuerelement unsichtbar.  Wir haben dies behoben, indem wir dem Code zum F√ºllen von Fenstern eine verz√∂gerte Initialisierung f√ºr unsere Steuerung hinzugef√ºgt haben. <br><br><h2>  Unterst√ºtzung von C # 8.0 </h2><br>  Die Verwendung von Roslyn als Basis f√ºr den Analysator bietet einen gro√üen Vorteil: Sie m√ºssen die Unterst√ºtzung f√ºr neue Sprachkonstrukte nicht manuell hinzuf√ºgen - dies erfolgt automatisch √ºber die Microsoft. Code Analysis-Bibliotheken, und wir verwenden nur die vorgefertigten L√∂sungen.  Dies bedeutet, dass eine neue Syntax durch einfaches Aktualisieren der Bibliotheken unterst√ºtzt wird. <br><br>  Was die Analyse selbst angeht, mussten wir nat√ºrlich die Dinge selbst optimieren - insbesondere neue Sprachkonstruktionen handhaben.  Sicher, wir hatten den neuen Syntaxbaum automatisch durch einfaches Aktualisieren von Roslyn generiert, aber wir mussten dem Analysator trotzdem beibringen, wie neue oder ge√§nderte Syntaxbaumknoten genau zu interpretieren und zu verarbeiten sind. <br><br>  Die nullbaren Referenztypen sind m√∂glicherweise die am h√§ufigsten diskutierte neue Funktion von C # 8. Ich werde jetzt nicht dar√ºber sprechen, da ein so gro√ües Thema einen separaten Artikel wert ist (der gerade geschrieben wird).  Im Moment haben wir uns entschlossen, nullf√§hige Annotationen in unserem Datenflussmechanismus zu ignorieren (dh wir verstehen, analysieren und √ºberspringen sie).  Die Idee ist, dass einer Variablen, selbst von einem nicht nullbaren Referenztyp, immer noch ziemlich einfach (oder versehentlich) der Wert <i>null</i> zugewiesen werden kann, was zu einem NRE f√ºhrt, wenn versucht wird, ihn zu dereferenzieren.  Unser Analysator kann solche Fehler erkennen und eine m√∂gliche Null-Dereferenzierung melden (wenn er eine solche Zuordnung nat√ºrlich im Code findet), selbst wenn die Variable vom Typ einer nicht nullbaren Referenz ist. <br><br>  Durch die Verwendung von nullbaren Referenztypen und der zugeh√∂rigen Syntax k√∂nnen Sie ziemlich interessanten Code schreiben.  Wir haben es "emotionale Syntax" genannt.  Dieses Snippet ist perfekt kompilierbar: <br><br><pre> <code class="cpp hljs">obj.Calculate(); obj?.Calculate(); obj.Calculate(); obj!?.Calculate(); obj!!!.Calculate();</code> </pre> <br>  √úbrigens haben mich meine Experimente dazu gebracht, einige Tricks zu entdecken, mit denen Sie Visual Studio mithilfe der neuen Syntax "zum Absturz bringen" k√∂nnen.  Sie basieren auf der Tatsache, dass Sie so viele '!'  Zeichen, wie Sie m√∂chten.  Es bedeutet, dass Sie nicht nur Code wie diesen schreiben k√∂nnen: <br><br><pre> <code class="cpp hljs">object temp = null!</code> </pre> <br>  aber auch so: <br><br><pre> <code class="cpp hljs">object temp = null!!!;</code> </pre> <br>  Und wenn Sie es noch weiter vorantreiben, k√∂nnten Sie verr√ºckte Dinge wie diese schreiben: <br><br><pre> <code class="cpp hljs">object temp = null!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!;</code> </pre> <br>  Dieser Code ist kompilierbar. Wenn Sie jedoch versuchen, den Syntaxbaum in Syntax Visualizer √ºber das .NET Compiler Platform SDK anzuzeigen, st√ºrzt Visual Studio ab. <br><br>  Der Fehlerbericht kann aus der Ereignisanzeige abgerufen werden: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.0</span></span><span class="hljs-number"><span class="hljs-number">.28803</span></span><span class="hljs-number"><span class="hljs-number">.352</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5cc37012</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: WindowsBase.ni.dll, version: <span class="hljs-number"><span class="hljs-number">4.8</span></span><span class="hljs-number"><span class="hljs-number">.3745</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5c5bab63</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xc00000fd</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x000c9af4</span></span> Faulting process id: <span class="hljs-number"><span class="hljs-number">0x3274</span></span> Faulting application start time: <span class="hljs-number"><span class="hljs-number">0x01d5095e7259362e</span></span> Faulting application path: C:\<span class="hljs-function"><span class="hljs-function">Program </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Files</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x86)</span></span></span><span class="hljs-function">\ Microsoft Visual Studio\2019\Community\Common7\IDE\devenv.exe Faulting </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">module</span></span></span><span class="hljs-function"> path: C:\WINDOWS\assembly\NativeImages_v4.0.30319_32\ WindowsBase\4480dfedf0d7b4329838f4bbf953027d\WindowsBase.ni.dll Report Id: 66d41eb2-c658-486d-b417-02961d9c3e4f Faulting package full name: Faulting package-relative application ID:</span></span></code> </pre> <br>  Wenn Sie noch verr√ºckter werden und mehrmals mehr Ausrufezeichen hinzuf√ºgen, st√ºrzt Visual Studio ohne Hilfe von Syntax Visualizer von selbst ab.  Die Microsoft.CodeAnalysis-Bibliotheken und der csc.exe-Compiler k√∂nnen mit einem solchen Code ebenfalls nicht umgehen. <br><br>  Diese Beispiele sind nat√ºrlich erfunden, aber ich fand diesen Trick lustig. <br><br><h2>  Toolset </h2><br>  Es war offensichtlich, dass die Aktualisierung des Toolset der schwierigste Teil sein w√ºrde.  Zumindest sah es am Anfang so aus, aber jetzt denke ich, dass die Unterst√ºtzung des Plugins der schwierigste Teil war.  Zum einen hatten wir bereits ein Toolset und einen Mechanismus zur Bewertung von MSBuild-Projekten, was gut war, obwohl es noch erweitert werden musste.  Die Tatsache, dass wir die Algorithmen nicht von Grund auf neu schreiben mussten, machte es viel einfacher.  Die Strategie, sich auf "unser" Toolset zu verlassen, an das wir uns bei der Unterst√ºtzung von Visual Studio 2017 lieber gehalten haben, hat sich erneut als richtig erwiesen. <br><br>  Traditionell beginnt der Prozess mit der Aktualisierung von NuGet-Paketen.  Die Registerkarte zum Verwalten von NuGet-Paketen f√ºr die aktuelle L√∂sung enth√§lt die Schaltfl√§che "Aktualisieren" ... dies hilft jedoch nicht.  Das gleichzeitige Aktualisieren aller Pakete verursachte Konflikte mit mehreren Versionen, und der Versuch, alle zu l√∂sen, schien keine gute Idee zu sein.  Eine schmerzhaftere, aber vermutlich sicherere M√∂glichkeit bestand darin, Zielpakete von Microsoft.Build / Microsoft.CodeAnalysis selektiv zu aktualisieren. <br><br>  Beim Testen der Diagnose wurde sofort ein Unterschied festgestellt: Die Struktur des Syntaxbaums wurde auf einem vorhandenen Knoten ge√§ndert.  Keine gro√üe Sache;  das haben wir schnell behoben. <br><br>  Ich m√∂chte Sie daran erinnern, dass wir unsere Analyseger√§te (f√ºr C #, C ++, Java) an Open-Source-Projekten testen.  Auf diese Weise k√∂nnen wir die Diagnose gr√ºndlich testen. √úberpr√ºfen Sie sie beispielsweise auf falsch positive Ergebnisse oder pr√ºfen Sie, ob wir F√§lle verpasst haben (um die Anzahl der falsch negativen Ergebnisse zu verringern).  Diese Tests helfen uns auch dabei, m√∂gliche Regressionen im ersten Schritt der Aktualisierung der Bibliotheken / Toolsets zu verfolgen.  Diesmal hatten sie auch eine Reihe von Problemen. <br><br>  Eines war, dass sich das Verhalten in CodeAnalysis-Bibliotheken verschlechterte.  Insbesondere bei der √úberpr√ºfung bestimmter Projekte wurden Ausnahmen vom Code der Bibliotheken f√ºr verschiedene Vorg√§nge wie das Abrufen semantischer Informationen, das √ñffnen von Projekten usw. festgestellt. <br><br>  Diejenigen unter Ihnen, die den Artikel √ºber die Unterst√ºtzung von Visual Studio 2017 sorgf√§ltig gelesen haben, erinnern sich, dass unsere Distribution mit einem Dummy geliefert wird - der Datei MSBuild.exe mit 0 Byte. <br><br>  Jetzt mussten wir diese Praxis noch weiter vorantreiben und leere Dummies f√ºr die Compiler csc.exe, vbc.exe und VBCSCompiler.exe einf√ºgen.  Warum?  Wir haben diese L√∂sung gefunden, nachdem wir eines der Projekte aus unserer Testbasis analysiert und Diff-Berichte erhalten hatten: Die neue Version des Analysators gab einige der erwarteten Warnungen nicht aus. <br><br>  Wir haben festgestellt, dass es sich um bedingte Kompilierungssymbole handelt, von denen einige bei Verwendung der neuen Version des Analysators nicht ordnungsgem√§√ü extrahiert wurden.  Um dem Problem auf den Grund zu gehen, mussten wir uns eingehender mit dem Code von Roslyns Bibliotheken befassen. <br><br>  Bedingte Kompilierungssymbole werden mit der <i>GetDefineConstantsSwitch-</i> Methode der Klasse <i>Csc</i> aus der Bibliothek <i>Microsoft.Build.Tasks.CodeAnalysis</i> analysiert.  Die Analyse erfolgt mit der <i>String.Split-</i> Methode f√ºr eine Reihe von Trennzeichen: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] allIdentifiers = originalDefineConstants.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span> });</code> </pre> <br>  Dieser Parsing-Mechanismus funktioniert perfekt.  Alle bedingten Kompilierungssymbole werden korrekt extrahiert.  Okay, lass uns weiter graben. <br><br>  Der n√§chste wichtige Punkt war der Aufruf der <i>ComputePathToTool-</i> Methode der Klasse <i>ToolTask</i> .  Diese Methode berechnet den Pfad zur ausf√ºhrbaren Datei ( <i>csc.exe</i> ) und pr√ºft, ob sie vorhanden ist.  In diesem Fall gibt die Methode den Pfad zur√ºck oder andernfalls <i>null</i> . <br><br>  Der aufrufende Code: <br><br><pre> <code class="cpp hljs">.... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pathToTool = ComputePathToTool(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTool == null) { <span class="hljs-comment"><span class="hljs-comment">// An appropriate error should have been logged already. return false; } ....</span></span></code> </pre> <br>  Da es keine <i>csc.exe-</i> Datei gibt (warum haben wir sie ben√∂tigt?), <i>Wird PathToTool</i> an dieser Stelle der Wert <i>null</i> zugewiesen, und die aktuelle Methode ( <i>ToolTask.Execute</i> ) gibt <i>false zur√ºck</i> .  Die Ergebnisse der Ausf√ºhrung der Aufgabe, einschlie√ülich der extrahierten bedingten Kompilierungssymbole, werden ignoriert. <br><br>  Okay, mal sehen, was passiert, wenn wir die Datei <i>csc.exe</i> dort <i>ablegen</i> , wo sie erwartet wird. <br><br>  Jetzt speichert <i>pathToTool</i> den tats√§chlichen Pfad zur jetzt vorhandenen Datei, und <i>ToolTask.Execute wird weiterhin</i> ausgef√ºhrt.  Der n√§chste wichtige Punkt ist der Aufruf der <i>ManagedCompiler.ExecuteTool-</i> Methode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteTool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathToTool, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> responseFileCommands, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> commandLineCommands)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ProvideCommandLineArgs) { CommandLineArgs = GetArguments(commandLineCommands, responseFileCommands) .Select(arg =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskItem(arg)).ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SkipCompilerExecution) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } .... }</code> </pre> <br>  Die <i>SkipCompilerExecution-</i> Eigenschaft ist <i>true</i> (logischerweise, da wir nicht f√ºr real kompilieren).  Die aufrufende Methode (die bereits erw√§hnte <i>ToolTask.Execute</i> ) pr√ºft, ob der R√ºckgabewert f√ºr <i>ExecuteTool</i> 0 ist, und gibt in diesem <i>Fall true zur√ºck</i> .  Ob Ihre <i>csc.exe</i> ein tats√§chlicher Compiler oder "War and Peace" von Leo Tolstoy war, spielt √ºberhaupt keine Rolle. <br><br>  Das Problem hat also mit der Reihenfolge zu tun, in der die Schritte definiert wurden: <br><br><ul><li>  auf Compiler pr√ºfen; </li><li>  √úberpr√ºfen Sie, ob der Compiler gestartet werden soll. </li></ul><br>  Und wir w√ºrden eine umgekehrte Reihenfolge erwarten.  Um dies zu beheben, wurden die Dummies f√ºr die Compiler hinzugef√ºgt. <br><br>  Okay, aber wie haben wir es geschafft, √ºberhaupt Kompilierungssymbole zu erhalten, ohne dass die Datei csc.exe vorhanden war (und die Aufgabenergebnisse ignoriert wurden)? <br><br>  Nun, auch f√ºr diesen Fall gibt es eine Methode: <i>CSharpCommandLineParser.ParseConditionalCompilationSymbols</i> aus der Bibliothek <i>Microsoft.CodeAnalysis.CSharp</i> .  Es wird auch analysiert, indem die <i>String.Split-</i> Methode f√ºr eine Reihe von Trennzeichen <i>aufgerufen</i> wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] values = value.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">','</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*, StringSplitOptions.RemoveEmptyEntries*/</span></span>);</code> </pre> <br>  Sehen Sie, wie sich dieser Satz von Trennzeichen von dem unterscheidet, der von der <i>Csc.GetDefineConstantsSwitch-</i> Methode behandelt wird?  Hier ist ein Leerzeichen kein Trennzeichen.  Dies bedeutet, dass durch Leerzeichen getrennte bedingte Kompilierungssymbole mit dieser Methode nicht ordnungsgem√§√ü analysiert werden. <br><br>  Dies geschah, als wir die Problemprojekte √ºberpr√ºften: Sie verwendeten durch Leerzeichen getrennte bedingte Kompilierungssymbole und wurden daher erfolgreich von der <i>GetDefineConstantsSwitch-</i> Methode analysiert, nicht jedoch von der <i>ParseConditionalCompilationSymbols-</i> Methode. <br><br>  Ein weiteres Problem, das nach dem Aktualisieren der Bibliotheken auftrat, war in bestimmten F√§llen ein fehlerhaftes Verhalten - insbesondere bei Projekten, die nicht erstellt wurden.  Es wirkte sich auf die Microsoft. <i>Code Analysis-</i> Bibliotheken aus und manifestierte sich als Ausnahmen aller Art: <i>ArgumentNullException</i> (fehlgeschlagene Initialisierung eines internen Loggers), <i>NullReferenceException</i> usw. <br><br>  Ich m√∂chte Ihnen von einem bestimmten Fehler erz√§hlen, den ich ziemlich interessant fand. <br><br>  Wir haben es beim √úberpr√ºfen der neuen Version des Roslyn-Projekts <i>festgestellt</i> : Eine der Bibliotheken hat eine <i>NullReferenceException ausgel√∂st</i> .  Dank detaillierter Informationen zu seiner Quelle haben wir den Quellcode des Problems schnell gefunden und - aus Neugier - beschlossen, zu pr√ºfen, ob der Fehler bei der Arbeit in Visual Studio weiterhin besteht. <br><br>  Wir haben es geschafft, es in Visual Studio (Version 16.0.3) zu reproduzieren.  Dazu ben√∂tigen Sie eine Klassendefinition wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  Sie ben√∂tigen au√üerdem Syntax Visualizer (im Lieferumfang des .NET Compiler Platform SDK enthalten).  Suchen Sie das <i>TypeSymbol</i> (indem Sie auf den <i>Men√ºpunkt</i> "View TypeSymbol (falls vorhanden)" klicken) des Syntaxbaumknotens vom Typ <i>ConstantPatternSyntax</i> ( <i>null</i> ).  Visual Studio wird neu gestartet und die Ausnahmeinformationen - insbesondere die Stapelverfolgung - werden in der Ereignisanzeige verf√ºgbar: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.NullReferenceException at Microsoft.CodeAnalysis.CSharp.ConversionsBase. ClassifyImplicitBuiltInConversionSlow( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet<span class="hljs-string"><span class="hljs-string">'1 &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyBuiltInConversion( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet'</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoForNode( Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode) at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo( Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) ....</code> </pre> <br>  Wie Sie sehen k√∂nnen, wird das Problem durch eine Nullreferenz-Dereferenzierung verursacht. <br><br>  Wie bereits erw√§hnt, ist beim Testen des Analysators ein √§hnliches Problem aufgetreten.  Wenn Sie es mit Debug-Bibliotheken von Microsoft <i>Code Analysis</i> erstellen, k√∂nnen Sie direkt zum Problempunkt gelangen, indem Sie das <i>TypeSymbol</i> des entsprechenden Syntaxbaumknotens <i>nachschlagen</i> . <br><br>  Es wird uns schlie√ülich zur <i>ClassifyImplicitBuiltInConversionSlow-</i> Methode f√ºhren, die im obigen Stack-Trace erw√§hnt wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } Conversion conversion = ClassifyStandardImplicitConversion(source, destination, ref useSiteDiagnostics); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conversion.Exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversion; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; }</code> </pre> <br>  Hier ist der Zielparameter <i>null</i> , sodass beim Aufrufen von <i>destination.SpecialType</i> eine <i>NullReferenceException ausgel√∂st wird</i> .  Ja, der Dereferenzierungsoperation geht <i>Debug.Assert</i> voraus, aber es hilft nicht, weil es tats√§chlich vor nichts sch√ºtzt - es erm√∂glicht Ihnen einfach, das Problem in den Debug-Versionen der Bibliotheken zu erkennen.  Oder nicht. <br><br><h3>  √Ñnderungen am Mechanismus zur Bewertung von C ++ - Projekten </h3><br>  In diesem Teil gab es nicht viel Interessantes: Die vorhandenen Algorithmen erforderten keine gro√üen erw√§hnenswerten √Ñnderungen, aber Sie m√∂chten vielleicht zwei kleinere Probleme kennen. <br><br>  Das erste war, dass wir die Algorithmen √§ndern mussten, die auf dem numerischen Wert von ToolsVersion beruhten.  In bestimmten F√§llen m√ºssen Sie Toolsets vergleichen und beispielsweise die neueste Version ausw√§hlen, ohne auf Details einzugehen.  Die neue Version hat nat√ºrlich einen gr√∂√üeren Wert.  Wir haben erwartet, dass ToolsVersion f√ºr das neue MSBuild / Visual Studio den Wert 16.0 hat.  Ja sicher!  Die folgende Tabelle zeigt, wie sich die Werte verschiedener Eigenschaften im Verlauf des Visual Studio-Entwicklungsverlaufs ge√§ndert haben: <br><div class="scrollable-table"><table><tbody><tr><td>  Visual Studio Produktname <br></td><td>  Versionsnummer von Visual Studio <br></td><td>  Tools-Version <br></td><td>  PlatformToolset-Version <br></td></tr><tr><td>  Visual Studio 2010 <br></td><td>  10.0 <br></td><td>  4.0 <br></td><td>  100 <br></td></tr><tr><td>  Visual Studio 2012 <br></td><td>  11.0 <br></td><td>  4.0 <br></td><td>  110 <br></td></tr><tr><td>  Visual Studio 2013 <br></td><td>  12.0 <br></td><td>  12.0 <br></td><td>  120 <br></td></tr><tr><td>  Visual Studio 2015 <br></td><td>  14.0 <br></td><td>  14.0 <br></td><td>  140 <br></td></tr><tr><td>  Visual Studio 2017 <br></td><td>  15.0 <br></td><td>  15.0 <br></td><td>  141 <br></td></tr><tr><td>  Visual Studio 2019 <br></td><td>  16.0 <br></td><td>  Strom <br></td><td>  142 <br></td></tr></tbody></table></div><br>  Ich wei√ü, dass der Witz √ºber die durcheinandergebrachten Versionsnummern von Windows und Xbox ein alter ist, aber er beweist, dass Sie keine verl√§sslichen Vorhersagen √ºber die Werte (ob im Namen oder in der Version) zuk√ºnftiger Microsoft-Produkte treffen k√∂nnen.  :) :) <br><br>  Wir haben das einfach gel√∂st, indem wir Priorit√§ten f√ºr Toolsets hinzugef√ºgt haben (dh die Priorit√§t als separate Einheit herausgreifen). <br><br>  Das zweite Problem betraf Probleme beim Arbeiten in Visual Studio 2017 oder einer verwandten Umgebung (z. B. wenn die Umgebungsvariable <i>VisualStudioVersion</i> festgelegt ist).  Dies liegt daran, dass die Berechnung der zur Bewertung eines C ++ - Projekts erforderlichen Parameter eine viel schwierigere Aufgabe ist als die Bewertung eines .NET-Projekts.  F√ºr .NET verwenden wir unser eigenes Toolset und den entsprechenden Wert von ToolsVersion.  F√ºr C ++ k√∂nnen wir sowohl unser eigenes Toolset als auch die vom System bereitgestellten verwenden.  Ab Build Tools f√ºr Visual Studio 2017 werden Toolsets in der Datei <i>MSBuild.exe.config</i> anstelle der Registrierung definiert.  Aus diesem Grund konnten wir sie nicht mehr aus der globalen Liste der Toolsets abrufen (z. B. mit <i>Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.Toolsets</i> ), anders als in der Registrierung definiert (z. B. f√ºr Visual Studio 2015 und fr√ºher). <br><br>  All dies hindert uns daran, ein Projekt mit <i>ToolsVersion 15.0 zu evaluieren,</i> da das System das erforderliche Toolset nicht sieht.  Das neueste Toolset, <i>Current</i> , wird weiterhin verf√ºgbar sein, da es unser eigenes Toolset ist. Daher gibt es in Visual Studio 2019 kein solches Problem. Die L√∂sung war recht einfach und erm√∂glichte es uns, dies zu beheben, ohne die vorhandenen Bewertungsalgorithmen zu √§ndern: Wir nur musste zus√§tzlich zu <i>Current ein</i> weiteres Toolset, <i>15.0</i> , in die Liste unserer eigenen Toolsets aufnehmen. <br><br><h3>  √Ñnderungen am Mechanismus zur Bewertung von C # .NET Core-Projekten </h3><br>  Diese Aufgabe umfasste zwei miteinander verbundene Probleme: <br><br><ul><li>  Durch Hinzuf√ºgen des Toolsets "Aktuell" wurde die Analyse von .NET Core-Projekten in Visual Studio 2017 unterbrochen. </li><li>  Die Analyse w√ºrde f√ºr .NET Core-Projekte auf Systemen ohne mindestens eine installierte Kopie von Visual Studio nicht funktionieren. </li></ul><br>  Beide Probleme stammten aus derselben Quelle: Einige der Basisdateien .targets / .props wurden auf falschen Pfaden nachgeschlagen.  Dies hat uns daran gehindert, ein Projekt mit unserem Toolset zu bewerten. <br><br>  Wenn Sie keine Visual Studio-Instanz installiert haben, wird der folgende Fehler angezeigt (mit der vorherigen Toolset-Version <i>15.0</i> ): <br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Windows\Microsoft.NET\Framework64\ 15.0\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found.</code> </pre> <br>  Bei der Evaluierung eines C # .NET Core-Projekts in Visual Studio 2017 wird der folgende Fehler angezeigt (mit der aktuellen Toolset-Version " <i>Aktuell"</i> ): <br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\MSBuild\Current\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found. ....</code> </pre> <br>  Da diese Probleme √§hnlich sind (was sie zu sein scheinen), k√∂nnten wir versuchen, zwei Fliegen mit einer Klappe zu schlagen. <br><br>  In den n√§chsten Abschnitten werde ich erkl√§ren, wie wir das erreicht haben, ohne auf Details einzugehen.  Diese Details (Informationen zur Bewertung von C # .NET Core-Projekten sowie √Ñnderungen am Bewertungsmechanismus in unserem Toolset) werden in einem unserer zuk√ºnftigen Artikel behandelt.  √úbrigens, wenn Sie diesen Artikel sorgf√§ltig gelesen haben, haben Sie wahrscheinlich bemerkt, dass dies der zweite Verweis auf unsere zuk√ºnftigen Artikel ist.  :) :) <br><br>  Wie haben wir dieses Problem gel√∂st?  Wir haben unser eigenes Toolset um die Basisdateien .targets / .props aus dem .NET Core SDK ( <i>Sdk.props</i> , <i>Sdk.targets</i> ) erweitert.  Dies gab uns mehr Kontrolle √ºber die Situation und mehr Flexibilit√§t beim Importmanagement sowie bei der Bewertung von .NET Core-Projekten im Allgemeinen.  Ja, unser Toolset wurde wieder etwas gr√∂√üer, und wir mussten auch Logik zum Einrichten der Umgebung hinzuf√ºgen, die f√ºr die Evaluierung von .NET Core-Projekten erforderlich ist, aber es scheint sich zu lohnen. <br><br>  Bis dahin hatten wir .NET Core-Projekte evaluiert, indem wir einfach die Evaluierung angefordert und uns bei der Ausf√ºhrung auf MSBuild verlassen hatten. <br><br>  Jetzt, da wir mehr Kontrolle √ºber die Situation hatten, √§nderte sich der Mechanismus ein wenig: <br><br><ul><li>  Richten Sie die f√ºr die Evaluierung von .NET Core-Projekten erforderliche Umgebung ein. </li><li>  Bewertung: <ul><li>  Starten Sie die Evaluierung mit .targets / .props-Dateien aus unserem Toolset. </li><li>  Setzen Sie die Auswertung mit externen Dateien fort. </li></ul></li></ul><br>  Diese Sequenz legt nahe, dass die Einrichtung der Umgebung zwei Hauptziele verfolgt: <br><br><ul><li>  Initiieren Sie die Evaluierung mithilfe von .targets / .props-Dateien aus unserem Toolset. </li><li>  Leiten Sie alle nachfolgenden Vorg√§nge in externe .targets / .props-Dateien um. </li></ul><br>  Eine spezielle Bibliothek Microsoft.DotNet.MSBuildSdkResolver wird verwendet, um die erforderlichen .targets / .props-Dateien nachzuschlagen.  Um die Einrichtung der Umgebung mithilfe von Dateien aus unserem Toolset zu initiieren, haben wir eine spezielle Umgebungsvariable verwendet, die von dieser Bibliothek verwendet wird, damit wir auf die Quelle verweisen k√∂nnen, aus der die erforderlichen Dateien importiert werden sollen (dh unser Toolset).  Da die Bibliothek in unserer Distribution enthalten ist, besteht kein Risiko eines pl√∂tzlichen Logikfehlers. <br><br>  Jetzt haben wir zuerst die Sdk-Dateien aus unserem Toolset importiert, und da wir sie jetzt leicht √§ndern k√∂nnen, steuern wir den Rest der Auswertungslogik vollst√§ndig.  Das hei√üt, wir k√∂nnen jetzt entscheiden, welche Dateien und von welchem ‚Äã‚ÄãSpeicherort importiert werden sollen.  Gleiches gilt f√ºr die oben genannten Microsoft.Common.props.  Wir importieren diese und andere Basisdateien aus unserem Toolset, damit wir uns nicht um deren Existenz oder Inhalt k√ºmmern m√ºssen. <br><br>  Sobald alle erforderlichen Importe abgeschlossen und die Eigenschaften festgelegt sind, √ºbergeben wir die Kontrolle √ºber den Evaluierungsprozess an das eigentliche .NET Core SDK, wo alle verbleibenden erforderlichen Vorg√§nge ausgef√ºhrt werden. <br><br><h2>  Fazit </h2><br>  Die Unterst√ºtzung von Visual Studio 2019 war aus mehreren Gr√ºnden im Allgemeinen einfacher als die Unterst√ºtzung von Visual Studio 2017.  Erstens hat Microsoft nicht so viele Dinge ge√§ndert wie beim Aktualisieren von Visual Studio 2015 auf Visual Studio 2017. Ja, sie haben das Basistoolset ge√§ndert und Visual Studio-Plugins gezwungen, in den asynchronen Lademodus zu wechseln, aber diese √Ñnderung war nicht der Fall das drastisch.  Zweitens hatten wir bereits eine vorgefertigte L√∂sung mit unserem eigenen Toolset und Projektbewertungsmechanismus, und wir mussten einfach nicht alles von Grund auf neu aufarbeiten - sondern nur auf dem aufbauen, was wir bereits hatten.  Der relativ schmerzlose Prozess der Unterst√ºtzung der Analyse von .NET Core-Projekten unter neuen Bedingungen (und auf Computern ohne installierte Visual Studio-Kopien) durch Erweiterung unseres Projektevaluierungssystems gibt uns auch Hoffnung, dass wir die richtige Wahl getroffen haben, indem wir einen Teil der Kontrolle √ºbernommen haben unsere H√§nde. <br><br>  Aber ich m√∂chte die im vorherigen Artikel kommunizierte Idee wiederholen: Manchmal ist die Verwendung von vorgefertigten L√∂sungen nicht so einfach, wie es scheint. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454736/">https://habr.com/ru/post/de454736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454720/index.html">Wie kann ich die Dokumentation wiederbeleben?</a></li>
<li><a href="../de454728/index.html">Internetzugang ge√∂ffnet: Die LUWRAIN-Technologie hilft blinden Benutzern</a></li>
<li><a href="../de454730/index.html">Allure Server-Treffen: Videoaufzeichnungen von Berichten</a></li>
<li><a href="../de454732/index.html">5 Robuste Priorisierungstechniken f√ºr IT-Teams</a></li>
<li><a href="../de454734/index.html">Backup, Teil 4: √úbersicht und Testen von zbackup, restic, borgbackup</a></li>
<li><a href="../de454738/index.html">Visual Studio 2019-Unterst√ºtzung in PVS-Studio</a></li>
<li><a href="../de454740/index.html">Mai 2019 Joomla Digest</a></li>
<li><a href="../de454742/index.html">Mindestens ein Vim-Trick, von dem Sie nichts wussten</a></li>
<li><a href="../de454744/index.html">√úbersicht √ºber Java Track Reports von der RigaDevDays Konferenz</a></li>
<li><a href="../de454748/index.html">MongoDB Survival Guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>