<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📂 🤣 🎒 Kualitas Kode Apache Hadoop: Produksi VS Tes 🙎🏽 👩🏼‍🍳 🍊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk mendapatkan kode produksi berkualitas tinggi, tidak cukup hanya memastikan cakupan maksimum dengan pengujian. Tidak diragukan lagi, hasil yang l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kualitas Kode Apache Hadoop: Produksi VS Tes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480918/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c48/f76/cf1/c48f76cf15c8138ce1d944918b1dcc07.png" alt="Gambar 1"></div><br>  Untuk mendapatkan kode produksi berkualitas tinggi, tidak cukup hanya memastikan cakupan maksimum dengan pengujian.  Tidak diragukan lagi, hasil yang luar biasa membutuhkan kode proyek utama dan tes untuk bekerja secara efisien bersama.  Oleh karena itu, tes harus diperhatikan sebanyak kode utama.  Tes yang layak adalah faktor kunci keberhasilan, karena akan menangkap regresi dalam produksi.  Mari kita lihat peringatan analisa statis PVS-Studio untuk melihat pentingnya fakta bahwa kesalahan dalam tes tidak lebih buruk daripada yang ada di produksi.  Fokus hari ini: Apache Hadoop. <br><a name="habracut"></a><br><h2>  Tentang proyek </h2><br>  Mereka yang sebelumnya tertarik dengan Big Data mungkin pernah mendengar atau bahkan bekerja dengan proyek <a href="https://hadoop.apache.org/">Apache Hadoop</a> .  Singkatnya, Hadoop adalah kerangka kerja yang dapat digunakan sebagai dasar untuk membangun sistem Big Data dan bekerja dengannya. <br><br>  Hadoop terdiri dari empat modul utama, masing-masingnya melakukan tugas khusus yang diperlukan untuk sistem analisis data besar: <br><br><ul><li>  Hadoop biasa </li><li>  Kurangi peta </li><li>  Sistem File Terdistribusi Hadoop </li><li>  Benang </li></ul><br>  Bagaimanapun, ada banyak materi tentang itu di Internet. <br><br><h2>  Tentang cek </h2><br>  Seperti yang ditunjukkan dalam dokumentasi, PVS-Studio dapat diintegrasikan dalam proyek dengan berbagai cara: <br><br><ul><li>  Menggunakan plugin maven; </li><li>  Menggunakan plugin gradle; </li><li>  Menggunakan IntellJ IDEA gradle; </li><li>  Langsung menggunakan analisa. </li></ul><br>  Hadoop didasarkan pada sistem pembangunan pakar, oleh karena itu, tidak ada hambatan dengan cek. <br><br>  Setelah saya mengintegrasikan skrip dari dokumentasi dan mengedit salah satu file pom.xml (ada modul dalam dependensi yang tidak tersedia), analisis dimulai! <br><br>  Setelah analisis selesai, saya memilih peringatan yang paling menarik dan memperhatikan bahwa saya memiliki jumlah peringatan yang sama dalam kode produksi dan dalam pengujian.  Biasanya, saya tidak mempertimbangkan peringatan penganalisa, diberikan untuk tes.  Tetapi ketika saya membaginya, saya tidak bisa meninggalkan peringatan 'tes' tanpa pengawasan.  "Mengapa tidak melihatnya?" - Saya pikir, karena bug dalam tes mungkin juga memiliki konsekuensi yang merugikan.  Mereka dapat menyebabkan pengujian yang salah atau sebagian, atau bahkan kesalahan (mereka ada hanya untuk mencentang kotak, bahwa mereka selalu hijau). <br><br>  Setelah saya memilih peringatan yang paling menarik, saya membaginya dengan kelompok-kelompok berikut: produksi, pengujian dan empat modul Hadoop utama.  Dan sekarang saya dengan senang hati memberikan ulasan Anda tentang peringatan penganalisa. <br><br><h2>  Kode produksi </h2><br><h3>  Hadoop biasa </h3><br>  <a href="https://www.viva64.com/en/w/v6033/">V6033</a> Item dengan kunci yang sama 'KDC_BIND_ADDRESS' telah ditambahkan.  MiniKdc.java (163), MiniKdc.java (162) <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MiniKdc</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;String&gt; PROPERTIES = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;String&gt;(); .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { PROPERTIES.add(ORG_NAME); PROPERTIES.add(ORG_DOMAIN); PROPERTIES.add(KDC_BIND_ADDRESS); PROPERTIES.add(KDC_BIND_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">// &lt;= PROPERTIES.add(KDC_PORT); PROPERTIES.add(INSTANCE); .... } .... }</span></span></code> </pre> <br>  Nilai tambah dua kali dalam <i>HashSet</i> adalah cacat yang sangat umum saat memeriksa proyek.  Penambahan kedua sebenarnya akan diabaikan.  Saya harap duplikasi ini hanyalah sebuah tragedi yang tidak perlu.  Bagaimana jika nilai lain dimaksudkan untuk ditambahkan? <br><br><h3>  Kurangi peta </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Dua fragmen kode serupa ditemukan.  Mungkin, ini adalah kesalahan ketik dan variabel 'localFiles' harus digunakan daripada 'localArchives'.  LocalDistributedCacheManager.java (183), LocalDistributedCacheManager.java (178), LocalDistributedCacheManager.java (176), LocalDistributedCacheManager.java (181) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobConf conf, JobID jobId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Update the configuration object with localized data. if (!localArchives.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils .arrayToString(localArchives.toArray(new String[localArchives // &lt;= .size()]))); } if (!localFiles.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils .arrayToString(localFiles.toArray(new String[localArchives // &lt;= .size()]))); } .... }</span></span></code> </pre> <br>  Diagnostik V6072 terkadang menghasilkan beberapa temuan menarik.  Tujuan diagnostik ini adalah untuk mendeteksi fragmen kode tipe yang sama yang dihasilkan dari salin-tempel dan penggantian satu-dua variabel.  Dalam hal ini, beberapa variabel bahkan dibiarkan "tidak berubah". <br><br>  Kode di atas menunjukkan ini.  Di blok pertama variabel <i>localArchives</i> digunakan, di fragmen serupa yang kedua - <i>localFiles</i> .  Jika Anda mempelajari kode ini dengan uji tuntas, alih-alih jalankan dengan cepat, seperti yang sering terjadi saat meninjau kode, Anda akan melihat fragmen, di mana penulis lupa mengganti variabel <i>localArchives</i> . <br><br>  Kesalahan ini dapat menyebabkan skenario berikut: <br><br><ul><li>  Misalkan, kita memiliki <i>Arsip lokal</i> (ukuran = 4) dan <i>Berkas lokal</i> (ukuran = 2); </li><li>  Saat membuat array <i>localFiles.toArray (String baru [localArchives.size ()]))</i> , 2 elemen terakhir akan menjadi <i>null</i> (["pathToFile1", "pathToFile2", null, null]); </li><li>  Kemudian <i>org.apache.hadoop.util.StringUtils.arrayToString</i> akan mengembalikan representasi string dari array kami, di mana nama file terakhir akan disajikan sebagai "null" ("pathToFile1, pathToFile2, null, null" <i>)</i> ; </li><li>  Semua ini akan diteruskan lebih lanjut dan hanya Tuhan yang tahu jenis cek apa yang ada untuk kasus seperti itu =). </li></ul><br>  Ekspresi <a href="https://www.viva64.com/en/w/v6007/">V6007</a> 'children.size ()&gt; 0' selalu benar.  Queue.java (347) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHierarchySameAs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Queue newState)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || children.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(children.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... }</code> </pre> <br>  Karena fakta bahwa jumlah elemen diperiksa untuk 0 secara terpisah, pemeriksaan selanjutnya pada <i>children.size ()&gt; 0</i> akan selalu benar. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/en/w/v6001/">V6001</a> Ada sub-ekspresi identik 'this.bucketSize' di sebelah kiri dan di sebelah kanan operator '%'.  RollingWindow.java (79) <br><br><pre> <code class="java hljs"> RollingWindow(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> windowLenMs, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numBuckets) { buckets = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket[numBuckets]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numBuckets; i++) { buckets[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.windowLenMs = windowLenMs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize = windowLenMs / numBuckets; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize % bucketSize != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new IllegalArgumentException( "The bucket size in the rolling window is not integer: windowLenMs= " + windowLenMs + " numBuckets= " + numBuckets); } }</span></span></code> </pre> <br>  Di sini cacatnya adalah bahwa variabel dibagi dengan sendirinya.  Akibatnya, pemeriksaan untuk multiplisitas akan selalu berhasil dan jika mendapat input yang salah ( <i>windowLenMs</i> , <i>numBuckets</i> ), pengecualian tidak akan pernah dilempar. <br><br><h3>  Benang </h3><br>  <a href="https://www.viva64.com/en/w/v6067/">V6067</a> Dua atau lebih cabang kasus melakukan tindakan yang sama.  TimelineEntityV2Converter.java (386), TimelineEntityV2Converter.java (389) <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ApplicationReport </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToApplicationReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TimelineEntity entity)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (metrics != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> memorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedVcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedMemorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TimelineMetric metric : metrics) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (metric.getId()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_CPU_METRICS: vcoreSeconds = getAverageValue(metric.getValues().values()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_METRICS: memorySeconds = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS: preemptedVcoreSeconds = ....; <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS: preemptedVcoreSeconds = ....; // &lt;= break; default: // Should not happen.. break; } } .... } .... }</span></span></code> </pre> <br>  Fragmen kode yang sama di dua cabang <i>case</i> .  Itu hanya di semua tempat!  Dalam jumlah kasus yang berlaku, ini bukan kesalahan nyata, tetapi hanya alasan untuk berpikir tentang pengembalian <i>sakelar</i> .  Tetapi tidak untuk kasus yang dihadapi.  Fragmen kode yang diulang menetapkan nilai variabel <i>preemptedVcoreSeconds</i> .  Jika Anda melihat dekat pada nama semua variabel dan konstanta, Anda mungkin akan menyimpulkan bahwa jika <i>metric.getId () == APP_MEM_PREEMPT_METRICS</i> nilai harus ditetapkan untuk variabel <i>PreemptedMemorySeconds</i> , bukan untuk <i>preemptedVcoreSeconds</i> .  Dalam hal ini, setelah operator 'switch', <i>preemptedMemorySeconds</i> akan selalu tetap 0, sedangkan nilai <i>preemptedVcoreSeconds</i> mungkin salah. <br><br>  <a href="https://www.viva64.com/en/w/v6046/">V6046</a> Format salah.  Jumlah item format yang berbeda diharapkan.  Argumen tidak digunakan: 2. AbstractSchedulerPlanFollower.java (186) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synchronizePlan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Plan plan, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shouldReplan)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setQueueEntitlement(planQueueName, ....); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (YarnException e) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Exception while trying to size reservation for plan: {}"</span></span>, currResId, planQueueName, e); } .... }</code> </pre> <br>  Variabel <i>planQueueName</i> tidak digunakan saat masuk.  Dalam hal ini, terlalu banyak disalin atau string format belum selesai.  Tapi saya masih menyalahkan copy-paste lama yang bagus, yang dalam beberapa kasus bagus untuk menembak diri sendiri. <br><br><h2>  Kode uji </h2><br><h3>  Hadoop biasa </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Dua fragmen kode serupa ditemukan.  Mungkin, ini adalah kesalahan ketik dan variabel 'allSecretsB' harus digunakan alih-alih 'allSecretsA'.  TestZKSignerSecretProvider.java (316), TestZKSignerSecretProvider.java (309), TestZKSignerSecretProvider.java (306), TestZKSignerSecretProvider.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMultiple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... currentSecretA = secretProviderA.getCurrentSecret(); allSecretsA = secretProviderA.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretA); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, allSecretsA.length); <span class="hljs-comment"><span class="hljs-comment">// &lt;= Assert.assertArrayEquals(secretA2, allSecretsA[0]); Assert.assertArrayEquals(secretA1, allSecretsA[1]); currentSecretB = secretProviderB.getCurrentSecret(); allSecretsB = secretProviderB.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretB); Assert.assertEquals(2, allSecretsA.length); // &lt;= Assert.assertArrayEquals(secretA2, allSecretsB[0]); Assert.assertArrayEquals(secretA1, allSecretsB[1]); .... }</span></span></code> </pre> <br>  Dan lagi V6072.  Perhatikan baik-baik variabel <i>allSecretsA</i> dan <i>allSecretsB</i> . <br><br>  <a href="https://www.viva64.com/en/w/v6043/">V6043</a> Pertimbangkan untuk memeriksa operator 'untuk'.  Nilai awal dan akhir dari iterator adalah sama.  TestTFile.java (235) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrepWithUnknownLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scanner scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = start; i &lt; start; i++) { String key = String.format(localFormatter, i); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] read = readKey(scanner); assertTrue(<span class="hljs-string"><span class="hljs-string">"keys not equal"</span></span>, Arrays.equals(key.getBytes(), read)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { read = readValue(scanner); assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ie) { <span class="hljs-comment"><span class="hljs-comment">// should have thrown exception } String value = "value" + key; read = readLongValue(scanner, value.getBytes().length); assertTrue("values nto equal", Arrays.equals(read, value.getBytes())); scanner.advance(); } return (start + n); }</span></span></code> </pre> <br>  Tes yang selalu hijau?  =).  Bagian dari loop, yang merupakan bagian dari tes itu sendiri, tidak akan pernah dieksekusi.  Ini disebabkan oleh fakta bahwa nilai penghitung awal dan akhir sama dalam pernyataan <i>for</i> .  Akibatnya, kondisi yang <i>saya mulai</i> akan segera menjadi salah, yang mengarah ke perilaku tersebut.  Saya berlari melalui file tes dan melompat ke kesimpulan bahwa sebenarnya <i>saya &lt;(mulai + n)</i> harus ditulis dalam kondisi loop. <br><br><h3>  Kurangi peta </h3><br>  Ekspresi <a href="https://www.viva64.com/en/w/v6007/">V6007</a> 'byteAm &lt;0' selalu salah.  DataWriter.java (322) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">GenerateOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeSegment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> byteAm, OutputStream out)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> headerLen = getHeaderLength(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byteAm &lt; headerLen) { <span class="hljs-comment"><span class="hljs-comment">// not enough bytes to write even the header return new GenerateOutput(0, 0); } // adjust for header length byteAm -= headerLen; if (byteAm &lt; 0) { // &lt;= byteAm = 0; } .... }</span></span></code> </pre> <br>  Kondisi <i>byteAm &lt;0</i> selalu salah.  Untuk mengetahuinya, mari kita beri kode di atas pandangan lain.  Jika eksekusi pengujian mencapai operasi <i>byteAm - = headerLen</i> , itu berarti <i>byteAm&gt; = headerLen.</i>  Dari sini, setelah dikurangi, nilai byteAm tidak akan pernah negatif.  Itu yang harus kita buktikan. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Dua fragmen kode serupa ditemukan.  Mungkin, ini adalah kesalahan ketik dan variabel 'normalFile' harus digunakan daripada 'normalDir'.  TestWebHDFS.java (625), TestWebHDFS.java (615), TestWebHDFS.java (614), TestWebHDFS.java (624) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWebHdfsErasureCodingFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalDir = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(<span class="hljs-string"><span class="hljs-string">"/dir"</span></span>); dfs.mkdirs(normalDir); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(normalDir, <span class="hljs-string"><span class="hljs-string">"file.log"</span></span>); .... <span class="hljs-comment"><span class="hljs-comment">// logic block #1 FileStatus expectedNormalDirStatus = dfs.getFileStatus(normalDir); FileStatus actualNormalDirStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalDirStatus.isErasureCoded(), actualNormalDirStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalDir); assertTrue(normalDir + " should have erasure coding unset in " + ....); // logic block #2 FileStatus expectedNormalFileStatus = dfs.getFileStatus(normalFile); FileStatus actualNormalFileStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalFileStatus.isErasureCoded(), actualNormalFileStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalFile); assertTrue( normalFile + " should have erasure coding unset in " + ....); }</span></span></code> </pre> <br>  Percaya atau tidak, itu V6072 lagi!  Cukup ikuti variabel <i>normalDir</i> dan <i>normalFile.</i> <br><br>  <a href="https://www.viva64.com/en/w/v6027/">V6027</a> Variabel diinisialisasi melalui panggilan ke fungsi yang sama.  Mungkin salah atau kode tidak dioptimalkan.  TestDFSAdmin.java (883), TestDFSAdmin.java (879) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyNodesAndCorruptBlocks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numLiveDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptECBlockGroups, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DFSClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyReplicatedBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyECBlocks)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init vars */</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String expectedCorruptedECBlockGroupsStr = String.format( <span class="hljs-string"><span class="hljs-string">"Block groups with corrupt internal blocks: %d"</span></span>, numCorruptECBlockGroups); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyReplicatedBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyECBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); .... }</code> </pre> <br>  Dalam fragmen ini, variabel <i>tertinggiPriorityLowRedundancyReplicatedBlocksStr</i> dan <i>tertinggiPriorityLowRedundancyECBlocksStr</i> diinisialisasi dengan nilai yang sama.  Seringkali memang seharusnya begitu, tetapi ini tidak terjadi.  Nama-nama variabel panjang dan serupa, jadi tidak mengherankan bahwa fragmen yang disalin tidak diubah dengan cara apa pun.  Untuk memperbaikinya, ketika menginisialisasi variabel tertinggiPriorityLowRedundancyECBlocksStr, penulis harus menggunakan parameter input <i>tertinggiPriorityLowRedundancyECBlocks</i> .  Selain itu, kemungkinan besar, mereka masih perlu memperbaiki garis format. <br><br>  <a href="https://www.viva64.com/en/w/v6019/">V6019</a> Kode tidak terjangkau terdeteksi.  Mungkin saja ada kesalahan.  TestReplaceDatanodeFailureReplication.java (222) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyFileContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., SlowWriter[] slowwriters)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Verify the file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; slowwriters.length; i++) { LOG.info(slowwriters[i].filepath + ....); FSDataInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { in = fs.open(slowwriters[i].filepath); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, x;; j++) { x = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x) != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { Assert.assertEquals(j, x); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { IOUtils.closeStream(in); } } }</code> </pre> <br>  Penganalisa mengeluh bahwa penghitung <i>i ++</i> dalam loop tidak dapat diubah.  Yang berarti bahwa dalam loop <i>for (int i = 0; i &lt;slowwriters.length; i ++) {....}</i> tidak lebih dari satu iterasi yang akan dieksekusi.  Mari kita cari tahu alasannya.  Jadi, dalam iterasi pertama, kami menautkan utas dengan file yang sesuai dengan <i>slowwriters [0]</i> untuk dibaca lebih lanjut.  Selanjutnya, kita membaca konten file melalui loop <i>untuk (int j = 0, x ;; j ++):</i> <br><br><ul><li>  jika kita membaca sesuatu yang relevan, kita membandingkan byte baca dengan nilai saat ini dari penghitung <i>j melalui</i> <i>assertEquals</i> (jika pemeriksaan tidak berhasil, kita gagal dalam pengujian); </li><li>  jika file diperiksa dengan sukses dan kita sampai ke akhir file (kita baca -1), metode keluar. </li></ul><br>  Oleh karena itu, apa pun yang terjadi selama pemeriksaan <i>slowwriter [0]</i> , ia tidak akan memeriksa elemen berikutnya.  Kemungkinan besar, <i>break</i> harus digunakan alih-alih <i>kembali.</i> <br><br><h3>  Benang </h3><br>  <a href="https://www.viva64.com/en/w/v6019/">V6019</a> Kode tidak terjangkau terdeteksi.  Mungkin saja ada kesalahan.  TestNodeManager.java (176) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCreationOfNodeLabelsProviderService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Assert.fail(<span class="hljs-string"><span class="hljs-string">"Exception caught"</span></span>); e.printStackTrace(); } }</code> </pre> <br>  Dalam situasi ini, metode <i>Assert.fail</i> akan mengganggu tes dan stacktrace tidak akan dicetak jika ada pengecualian.  Jika pesan tentang pengecualian yang ditangkap sudah cukup di sini, lebih baik untuk menghapus pencetakan stacktrace untuk menghindari kebingungan.  Jika perlu mencetak, Anda hanya perlu menukar mereka. <br><br>  Banyak fragmen serupa telah ditemukan: <br><br><ul><li>  V6019 Kode tidak terjangkau terdeteksi.  Mungkin saja ada kesalahan.  TestResourceTrackerService.java (928) </li><li>  V6019 Kode tidak terjangkau terdeteksi.  Mungkin saja ada kesalahan.  TestResourceTrackerService.java (737) </li><li>  V6019 Kode tidak terjangkau terdeteksi.  Mungkin saja ada kesalahan.  TestResourceTrackerService.java (685) </li><li>  .... </li></ul><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Dua fragmen kode serupa ditemukan.  Mungkin, ini adalah kesalahan ketik dan variabel 'publicCache' harus digunakan daripada 'usercache'.  TestResourceLocalizationService.java (315), TestResourceLocalizationService.java (309), TestResourceLocalizationService.java (307), TestResourceLocalizationService.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testDirectoryCleanupOnNewlyCreatedStateStore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, URISyntaxException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// verify directory creation for (Path p : localDirs) { p = new Path((new URI(p.toString())).getPath()); // logic block #1 Path usercache = new Path(p, ContainerLocalizer.USERCACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(usercache), ....); // logic block #2 Path publicCache = new Path(p, ContainerLocalizer.FILECACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(publicCache), ....); .... } .... }</span></span></code> </pre> <br>  Dan akhirnya, V6072 lagi =).  Variabel untuk melihat fragmen yang mencurigakan: <i>usercache</i> dan <i>publicCache</i> . <br><br><h2>  Kesimpulan </h2><br>  Ratusan ribu baris kode ditulis dalam pengembangan.  Kode produksi biasanya tetap bersih dari bug, cacat dan cacat (pengembang menguji kode mereka, kode ditinjau dan seterusnya).  Tes pasti lebih rendah dalam hal ini.  Cacat dalam tes dapat dengan mudah bersembunyi di balik "centang hijau".  Seperti yang mungkin Anda dapatkan dari ulasan peringatan hari ini, tes hijau tidak selalu berhasil. <br><br>  Kali ini, ketika memeriksa basis kode Apache Hadoop, analisis statis ternyata sangat dibutuhkan baik dalam kode produksi dan tes yang juga memainkan peran penting dalam pengembangan. <br><br>  Jadi, jika Anda peduli dengan kualitas kode dan pengujian Anda, saya sarankan Anda mengarahkan analisis statis.  Biarkan <a href="https://www.viva64.com/en/pvs-studio-download/">PVS-Studio</a> menjadi pesaing pertama dalam usaha ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480918/">https://habr.com/ru/post/id480918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480904/index.html">PHP Microservice Framework: Lingkungan Pengembangan untuk Swoft</a></li>
<li><a href="../id480906/index.html">Menulis game python sederhana</a></li>
<li><a href="../id480910/index.html">Cara membuat kelas tes dasar untuk tes Selenium dan menginisialisasi melalui JUnit RuleChain</a></li>
<li><a href="../id480912/index.html">Dap beraksi. Menulis TodoMVC. Bagian 1</a></li>
<li><a href="../id480914/index.html">Layanan microser untuk pemula</a></li>
<li><a href="../id480920/index.html">Uji sakelar TP-Link dengan PoE jarak jauh. Dan sedikit tentang peningkatan model lama</a></li>
<li><a href="../id480922/index.html">Evgeny Usvitsky: "Semua orang di dunia tahu di mana mendapatkan geodata secara bebas - hanya di OSM"</a></li>
<li><a href="../id480924/index.html">Bagaimana dan mengapa pembuat remake MediEvil mendesain ulang bos sekte permainan</a></li>
<li><a href="../id480926/index.html">Teori Probabilitas untuk Rendering yang Akurat Secara Fisik</a></li>
<li><a href="../id480928/index.html">Apache Hadoop Code Quality: uji VS produksi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>