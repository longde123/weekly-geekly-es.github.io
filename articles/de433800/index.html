<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍀 🚉 🌴 Verwenden der UDB-PSoC-Controller von Cypress, um Unterbrechungen in einem 3D-Drucker zu reduzieren 🔤 🤞🏻 👨🏿‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den Kommentaren zur Übersetzung der proprietären Dokumentation zu UDB wurde zu Recht darauf hingewiesen, dass einfach trockene Fakten nicht zum Ver...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden der UDB-PSoC-Controller von Cypress, um Unterbrechungen in einem 3D-Drucker zu reduzieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433800/"><img src="https://habrastorage.org/webt/8h/et/xb/8hetxbp_jjuad07ws86ov24ch-c.jpeg"><br><br>  In den Kommentaren zur Übersetzung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">proprietären Dokumentation zu UDB</a> wurde zu Recht darauf hingewiesen, dass einfach trockene Fakten nicht zum Verständnis des Materials beitragen.  Aber dieses Dokument enthält genau die trockenen Fakten.  Um sie mit Übung zu verdünnen, machen wir eine Pause von der Übersetzung.  Lassen Sie uns diesen Block in unsere Hände legen und sehen, was und wie er in der Praxis erreicht werden kann. <br><a name="habracut"></a><br><h2>  Lange Einführung </h2><br>  Dieser Artikel ist der zweite Teil der konzipierten Trilogie.  Hier befindet sich der erste Teil (RGB-LED-Steuerung über die Cypress UDB-Mikrocontroller-Einheit PSoC). <br><br>  Zusätzlich zu den UDB-PSoC-Controllern von Cypress, auf denen bestimmte Schnittstellen implementiert sind, wäre es interessant zu prüfen, wie diese Blöcke Programmierern das Leben erleichtern können, indem der Zentralprozessor von bestimmten ressourcenintensiven Aufgaben entladen wird.  Aber um zu klären, was ich tun werde, muss ich ein umfangreiches Vorwort schreiben. <br><br>  Im Herbst 2015 kaufte ich einen brandneuen MZ3D 3D-Drucker und im Frühjahr 2016 hatte ich es satt, wie die Schrittmotoren klapperten.  Die Zeiten waren wild, wir überlebten so gut wir konnten, also bestand die einzige Lösung darin, von Mikroschritt 1/16 auf 1/32 zu wechseln.  Die Korrespondenz mit der Fabrik zeigte, dass dies bei Arduino nicht möglich ist.  Wie sich herausstellte, gab es in der „Firmware“ jener Jahre eine Einschränkung: Bei einer Schrittfrequenz von mehr als 10 kHz wurden keine virtuellen Schritte ausgeführt, sondern zwei virtuelle Schritte, da das System sonst einfach nicht genügend Zeit hatte, um alle „Schritt“ -Interrupts zu verarbeiten.  Es gab nur einen Ausweg - alles auf die ARM-Plattform zu ziehen.  Es war ein Drag &amp; Drop, kein Download, da es zu diesem Zeitpunkt auch keine vorgefertigten ARM-Lösungen gab.  In ein paar Wochen habe ich das alles auf STM32F4 übertragen, das Motorengeräusch wurde angenehmer, das Problem wurde behoben. <br><br>  Dann begann die Entwicklung des Betriebssystems in unserem Unternehmen, und bei den Besprechungen musste ich lange Zeit beweisen, dass der typische Ansatz zur Verarbeitung von Interrupts in Bezug auf die Geschwindigkeit nicht immer akzeptabel ist und nur diesen typischen, aber sehr gefräßigen Fall anspricht.  Diskussionen zu diesem Thema werden in meinem Artikel über Interrupts im Betriebssystem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier veröffentlicht</a> (Übersicht über ein russisches RTOS, Teil 8. Arbeiten mit Interrupts).  Im Allgemeinen hat sich ein Problem in meinem Kopf schon lange gelöst: Häufige Hilfsinterrupts, die ein Subsystem bedienen, verlangsamen alles andere.  Die einfache Verfeinerung des Zentralprozessors beseitigt natürlich das Problem, bringt aber nicht die tiefe moralische Zufriedenheit, dass alles richtig gemacht wird. <br><br>  In regelmäßigen Abständen kam ich rein theoretisch auf diese Frage zurück.  Zum Beispiel kam mir eines Tages der Gedanke, dass man anstelle eines teuren Controllers drei STM32F103C8T6 nehmen kann, bei denen ein fertiges Steckbrett unter Berücksichtigung der Lieferung 110 Rubel kostet und der Chip selbst noch billiger ist.  In einem von ihnen soll nur die Motorsteuerungsfunktion herausgenommen werden.  Lassen Sie ihn seine ganze Rechenleistung für diese Funktion aufwenden.  Einige der anderen (vielleicht sogar eine) lösen andere Aufgaben (Verarbeiten von Befehlen, Arbeiten mit PWM, Aufrechterhalten der Temperatur usw.) in einer ruhigen Umgebung.  Diese Lösung hat auch ein großes Plus: Die Gesamtzahl der Pins für mehrere Controller ist einfach riesig.  Auf einem STM32 musste ich lange Zeit Solitaire auslegen, welchem ​​Bein ich zuordnen sollte.  Obwohl die Schenkel der Timer-Ausgänge und die ADC-Schenkel der ARMs flexibler zugewiesen sind als die alten Controller (ein Ausgang der Hardwareeinheit kann einem von mehreren physischen Schenkeln zugewiesen werden), verstehen Sie, dass die Flexibilität möglicherweise nicht ausreicht, wenn Sie den Solitaire ausklappen.  Wenn es viele Controller gibt, erhöht sich die Auswahl.  Bei dem, der Schrittmotoren bedient, weisen wir im Allgemeinen einfach alle Beine als digitale Ausgänge zu.  Die anderen haben auch die Möglichkeit, sich umzudrehen. <br><br>  Ein Problem bei diesem Ansatz ist die Synchronisierung dieser Steuerungen.  Theoretisch enthält das MAX Max RTOS alles, was Sie brauchen.  Der Befehlshandler generiert eine Liste von Aufgaben zum Bewegen von Köpfen.  In regelmäßigen Abständen ändert er sie (indem er Beschleunigungen mit neu angekommenen Aufgaben koordiniert).  Daher sollte der Speicher für den Shaper und den Performer gemeinsam genutzt werden.  RTOS MAX enthält die Funktionalität zum Organisieren eines solchen gemeinsam genutzten Speichers.  Ich habe es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier beschrieben</a> (Überblick über ein russisches RTOS, Teil 7. Mittel zum Datenaustausch zwischen Aufgaben).  In der Praxis verdirbt jedoch eine Nuance alles: Die Wartung von Schrittmotoren ist eine zeitkritische Aufgabe.  Die geringste Verzögerung, und wir erhalten Plastikflüsse für einen 3D-Drucker, für andere CNC-Maschinen - also zum Beispiel für Gewinde mit falschem Gewinde.  Die Kommunikation über serielle Schnittstellen ist nicht die schnellste.  Plus - Zeit für Schiedsverfahren und andere offizielle Bedürfnisse.  Und es stellt sich heraus, dass alle Vorteile aus der Entfernung der Funktionalität vom Hauptprozessor in den Overhead gehen.  Natürlich habe ich meine offizielle Position ausgenutzt: Ich habe dieses Problem mit den Entwicklern dieses Subsystems besprochen.  Leider.  Sie sagten, dass es eine Synchronisation ohne großen Aufwand im Betriebssystem gibt, aber für Geräte, die die entsprechenden Busse unterstützen.  Wenn ich nun die TigerShark-Architektur als Grundlage nehme, organisiert das Betriebssystem alles für mich ohne Overhead.  Nur die nach dieser Architektur hergestellten Controller sind um ein Vielfaches teurer als der gesamte 3D-Drucker, den ich einbauen wollte.  Im Allgemeinen wieder inakzeptabel. <br><br>  Wir nähern uns dem Ende einer langwierigen Einführung.  Jemand wird sagen, dass ich aus irgendeinem Grund immer noch einen Prinzen auf einem weißen Pferd suche.  Sie können alles ohne Betriebssystem nehmen und tun, und hier erwäge ich alle möglichen Optionen ... Sie können, Sie können, aber als das praktische Problem „Müde vom Abhören des Druckerabsturzes“ auftrat, wurde es schnell behoben.  Das ist alles.  Sie ist nicht mehr.  Darüber hinaus gibt es seitdem neue Schrittmotortreiber, die dieses Problem im Allgemeinen auf völlig andere Weise lösen (sie erhalten einen Mikroschritt 1/16 und geben 1/256 aus).  Und in dieser Einleitung beschreibe ich genau: "Es gibt keine <b>schöne</b> Lösung für das Problem häufiger Unterbrechungen."  Eine hässliche Entscheidung wurde lange getroffen.  Ich wollte keine Zeit damit verschwenden, andere hässliche Entscheidungen zu überprüfen.  Sie haben nur in meinem Kopf gescrollt. <br><br>  Aber als ich mich mit UDB-Blöcken beschäftigte, schien es mir, dass das Problem schön und dramatisch gelöst werden kann.  Sie können einfach die Verarbeitung von Unterbrechungen von der Software auf die Firmware-Ebene übertragen, wobei der Computerteil dem Gewissen des Hauptprozessors überlassen bleibt.  Keine zusätzlichen Controller erforderlich!  Alles ist auf dem gleichen Chip platziert!  Also, fangen wir an. <br><br><h2>  Sphärisches Pferd im luftleeren Raum </h2><br>  In diesem Artikel steht die Arbeit mit UDB selbst im Vordergrund.  Wenn ich davon sprach, an eine bestimmte „Firmware“ gebunden zu sein, könnten sie mich zu Recht darauf hinweisen, dass ich mich mit dem Hub geirrt habe.  Was ist das für GeekTimes?  Daher ist UDB primär und Schrittmotoren sind nur eine schöne Sache zu veranschaulichen.  In diesem Teil werde ich im Allgemeinen ein kugelförmiges Pferd in einem Vakuum machen.  Er wird praktische Mängel haben, die ich im zweiten Teil beseitigen werde.  Wenn Sie jedoch meine Aktionen wiederholen, können die Leser die Methode zur Entwicklung der Firmware für UDB beherrschen. <br><br>  Also.  Wie funktioniert der Schrittmotor-Steuermechanismus?  Es gibt eine Aufgabe, die die Segmente, die der Kopf mit linearer Geschwindigkeit passieren muss, in eine Linie bringt.  Bisher werde ich so tun, als würde ich mich nicht an die Beschleunigung am Anfang und Ende des Segments erinnern.  Nur der Kopf sollte durchgehen.  Neue Segmente werden in das Ende der Warteschlange gestellt.  Basierend auf der Aufzeichnung vom Kopf sendet eine separate Aufgabe <b>STEP-</b> Signale an alle aktiven Motoren. <br><br>  Lassen Sie den Drucker eine maximale Kopfgeschwindigkeit von 200 mm / s haben.  Pro 1 Millimeter Bewegung seien 200 Schritte erforderlich (diese Zahl entspricht einem echten Drucker MZ3D-256C mit einem Mikroschritt 1/32).  Dann müssen die Impulse mit einer Frequenz von bis zu 200 * 200 = 40.000 Hz = 40 kHz versorgt werden.  Mit einer solchen Frequenz kann eine Aufgabe, die Schrittimpulse sendet, durchaus aufgerufen werden.  Es muss programmgesteuert die Impulse selbst bilden und auch berechnen, wie lange nach dem nächsten Interrupt, der es aktiviert, aufgerufen werden soll. <br><br>  Ich erinnere mich an einen Witz über Kolobok und die drei Bogatyrer, in dem Kolobok die Bogatyrer konsequent begrüßte, ihnen dann konsequent Fragen stellte und Antworten erhielt.  Dann verabschiedete er sich nacheinander von ihnen.  Nun, dann traf er sich mit den dreiunddreißig Rittern.  Der Prozessor spielt die Rolle eines Brötchens, und die Schrittmotoren spielen die Rolle von Bogatyrs.  Es ist klar, dass es bei Vorhandensein einer großen Anzahl von UDB-Blöcken möglich ist, die Arbeit mit Motoren zu parallelisieren, wobei jeder Motor an seinem Block gewartet wird.  Und da wir Segmente haben, in denen sich die Motoren gleichmäßig bewegen, versuchen wir, die Ausrüstung bei solchen Transaktionen und nicht bei jedem Schritt zum Laufen zu bringen. <br><br>  Welche Informationen benötigt ein kugelförmiges Pferd, um einen linearen Abschnitt im Vakuum zu durchlaufen? <br><br><ul><li>  Anzahl der Schritte. </li><li>  Der Zeitraum zwischen den Schritten. </li></ul><br>  Zwei Parameter.  UDB hat nur zwei Batterien und zwei Register der Parameter D0 und D1.  Es scheint, dass alles realisierbar ist.  Wir schätzen nur die Bittiefe, die diese Register haben sollten. <br><br>  Erstens die Anzahl der Schritte.  Wenn 8 Stellen vorhanden sind, kann der Drucker in einem Zyklus des UDB-Betriebs den Kopf des kartesischen Druckers um etwas mehr als 1 mm (200 Mikroschritte) bewegen.  Nicht genug.  Wenn die Kapazität 16 Bit beträgt, beträgt die Anzahl der Schritte 65536. Dies ist 65536/200 = 327 Millimeter.  Akzeptabel für die meisten Modelle.  Für Core, Delta und andere ist eine Schätzung erforderlich, aber insgesamt - für einen vollständigen Hub kann das Segment in mehrere Teile unterteilt werden.  Es wird nicht so viele geben (zwei, also maximal drei). <br><br>  Nun die Periode.  Die Taktfrequenz sei 48 MHz.  48000000/65536 = 732.  Das heißt, die minimal zulässige Frequenz, die unter Verwendung eines 16-Bit-Teilers erhalten werden kann, beträgt 732 Hz.  Zu viel.  In der Marlin-Firmware beträgt das Minimum 120 Hz (was ungefähr 8 MHz geteilt durch dieselbe Konstante 65536 entspricht).  Wir müssen die Register 24 Bit machen.  Dann ist die Mindestfrequenz gleich 48000000 / (2 ^ 24) = 48000000/16777216 = 2,861 Hz. <br><br>  Gut.  Stoppen Sie die langweilige Theorie!  Lass uns weiter üben!  Starten Sie PSoC Creator und wählen Sie Datei-&gt; Neu-&gt; Projekt: <br><br><img src="https://habrastorage.org/webt/tk/9t/bj/tk9tbjfppfjemih3s-ydrk54lfc.png"><br><br>  Als nächstes habe ich das Steckbrett ausgewählt, aus dem die Umgebung grundlegende Informationen über den verwendeten Controller und seine Einstellungen entnimmt: <br><br><img src="https://habrastorage.org/webt/dv/st/hi/dvsthib82j6ynrdxc0sk-5j20nk.png"><br><br>  Ich fühle mich bereits bereit, ein Projekt von Grund auf neu zu erstellen, daher wähle ich <b>Leeres Schema</b> : <br><br><img src="https://habrastorage.org/webt/oi/fx/vv/oifxvvsf0qye7j-mdyoxmbfux4q.png"><br><br>  Geben Sie der Arbeitsumgebung den Namen <b>PSoC3DTest</b> : <br><br><img src="https://habrastorage.org/webt/rr/0u/pd/rr0updtyevaseusbwel37v76bgc.png"><br><br>  Und hier ist er, ein fertiges Projekt! <br><br><img src="https://habrastorage.org/webt/fw/0s/xu/fw0sxucryznmujjsvr5ockarrjc.png"><br><br>  Als erstes möchte ich meine eigene Komponente basierend auf UDB erstellen.  Daher muss ich, wie bereits im letzten Artikel erwähnt, zur Registerkarte <b>Komponenten</b> wechseln: <br><br><img src="https://habrastorage.org/webt/oa/o8/s5/oao8s5whrsdn9xsnophfoaom_n4.png"><br><br>  Klicken Sie mit der rechten Maustaste auf das Projekt und wählen <b>Sie Komponentenelement hinzufügen</b> : <br><br><img src="https://habrastorage.org/webt/zq/kt/hu/zqkthur3pa19fpcrq4kcrmdac_y.png"><br><br>  Wir sagen, dass wir ein <b>UDB-Dokument</b> hinzufügen, den Namen in <b>StepperController ändern</b> und auf <b>Neu erstellen</b> klicken müssen: <br><br><img src="https://habrastorage.org/webt/tz/v8/qk/tzv8qkfqumypnq3ctjeh9moitpc.png"><br><br>  Die Komponente wurde im Baum angezeigt. Außerdem wurde der Editor dieser Komponente geöffnet: <br><br><img src="https://habrastorage.org/webt/yo/4g/np/yo4gnpvs5fuewpovam09lbq3zmw.png"><br><br>  Platzieren Sie den Datenpfadblock auf dem Formular: <br><br><img src="https://habrastorage.org/webt/nx/1o/bl/nx1oblbig1eqyqat0yj-evlvwo0.png"><br><br>  Nachdem wir diesen Block ausgewählt haben, gehen wir zu seinen Eigenschaften und ändern die Bittiefe von 8 auf 24. Die verbleibenden Parameter können unverändert bleiben. <br><br><img src="https://habrastorage.org/webt/1e/oq/rf/1eoqrfsjz5uh1fj2mopwtmf5vao.png"><br><br>  Um alle Blöcke (für alle Motoren) gleichzeitig zu starten, starte ich das Startsignal von außen (füge den <b>Start-</b> Eingang hinzu).  Ausgaben: Ich werde <b>Step</b> direkt <b>beenden</b> , damit ich es dem Schrittmotortreiber sowie <b>Out_Idle übermitteln kann</b> .  Anhand dieses Signals kann der Prozessor feststellen, dass das Gerät zu dem Zeitpunkt seine Arbeit beendet hat.  Die Namen der Schaltkreise, die diesen Ein- und Ausgängen entsprechen, sind in der Abbildung sichtbar. <br><br><img src="https://habrastorage.org/webt/sx/xq/gv/sxxqgvsyvpyr_jvzdblaf_l1soc.png"><br><br>  Bevor ich über die Logik des Automaten spreche, werde ich ein weiteres rein technisches Problem beschreiben: Einstellen der Impulsdauer <b>Schritt</b> .  Die DRV8825-Treiberdokumentation verlangt, dass die Impulsbreite mindestens 1,9 μs beträgt.  Andere Fahrer stellen weniger Anforderungen an die Breite.  Wie bereits im theoretischen Teil erwähnt, sind die vorhandenen Register bereits durch Einstellen der Schrittdauer und der Anzahl der Schritte belegt.  Ob es Ihnen gefällt oder nicht, ein 7-Bit-Zähler sollte auf der Schaltung platziert werden.  Wir nennen es einen One-Shot, der den Schrittimpuls setzt.  Bei einer Frequenz von 48 MHz sollte dieser Zähler mindestens 91,2 Schritte zählen, um eine Dauer von 1,9 μs zu gewährleisten.  Runden Sie auf 92 auf. Jeder Wert, der diesen Wert überschreitet, ist nicht geringer.  Es stellt sich folgende Einstellung heraus: <br><br><img src="https://habrastorage.org/webt/6w/k9/em/6wk9emz-qedseywswmgk24bdjqe.png"><br><br>  <b>Zählername SingleVibrator</b> .  Es wird nie zurückgesetzt, daher ist der <b>Reset-</b> Eingang immer mit Null verbunden. Wenn sich die Maschine (unten beschrieben) im Ein-Zustand befindet, wird sie in allen anderen Zuständen geladen (zuerst habe ich die spezifischen Zustände der Maschine ausgewählt, aber es hat sich herausgestellt, dass dies mit einer so kniffligen Methode möglich ist Es werden viel weniger PLD-Ressourcen benötigt, aber das Ergebnis ist das gleiche.  Der Ladewert ist dezimal 92. Richtig, ein guter Editor ersetzt diesen Wert sofort durch hexadezimal: <br><br><img src="https://habrastorage.org/webt/qt/h0/nv/qth0nvcbb_8m7qty2mj1zpde2m4.png"><br><br>  Wenn der Zähler auf Null gezählt wird, meldet er dies der Kette mit dem Namen <b>One_Finished</b> .  Mit der Theke - das war's. <br><br>  Welche Statusflags verwendet unsere Maschine?  Ich habe es so verstanden (ich erinnere Sie daran, auf die Liste der Ausgaben in Datapath zu doppelklicken, um sie festzulegen): <br><br><img src="https://habrastorage.org/webt/mk/oo/z_/mkooz_ywbi5vnaenpgfqo98p580.png"><br><br><img src="https://habrastorage.org/webt/br/u9/rz/bru9rzw4kk4ja4j6ehutvm7od14.png"><br><br>  Ich werde die Batterie A0 als Zähler für die Impulsdauer verwenden. Wenn ihr Wert Null erreicht, wird ein Flag gespannt, dem ich den Namen <b>Pulse_Finished gegeben habe</b> .  Batterie A1 zählt Impulse für mich.  Daher wird durch das Nullsetzen das Flag <b>Process_Finished gespannt</b> . <br><br>  Wir konstruieren den Übergangsgraphen des Automaten: <br><br><img src="https://habrastorage.org/webt/bv/rr/cv/bvrrcv0pgjs9fvadt08iyqaj92i.png"><br><br>  Die Variable, die ihren Status festlegt, heißt <b>State</b> .  Ordnen Sie diese Variable sofort dem Adressregister des ALU-Befehls zu.  Zuerst habe ich vergessen, dies zu tun, so dass ich lange Zeit nicht verstehen konnte, warum meine Maschine nicht funktioniert.  Doppelklicken Sie auf den Eintragsblock in Datapath: <br><br><img src="https://habrastorage.org/webt/zl/z2/e0/zlz2e0tvkl11wc5ot0id4vsdnh4.png"><br><br>  Und passen: <br><br><img src="https://habrastorage.org/webt/1e/sp/q1/1espq1co36mt063kgyvig-kzhsw.png"><br><br>  Wir beginnen mit dem Übergangsgraphen und den damit verbundenen ALU-Anweisungen. <br><br>  Beginnen wir mit dem <b>Ruhezustand</b> .  Es ist ziemlich gesättigt in seinen Handlungen. <br><br>  Erstens wird der Wert der Datenregister D0 und D1 ständig in die Batterien A0 bzw. A1 gelegt: <br><br><img src="https://habrastorage.org/webt/hz/8p/c-/hz8pc-lydhvzq3cnvsg2jw2qcem.png"><br><br>  Von diesem Eintrag aus sieht das geschulte Auge alles, was Sie brauchen.  Da unsere Augen immer noch nicht gesetzt sind, doppelklicken wir auf den Eintrag und sehen dasselbe, aber im Detail: <br><br><img src="https://habrastorage.org/webt/yu/yy/qe/yuyyqemtvqbcsp25mbud7y3y1mu.png"><br><br>  Der Hauptwert hier ist das Befüllen der Batterie A1, des Impulszählers.  Wenn das Programm den Wert D1 eingibt, geht es sofort zu A1.  Das Programm wird definitiv keine Zeit haben, den Prozess bis zur nächsten Maßnahme zu starten.  Dieser Wert wird überprüft, um eine Bedingung für das Verlassen dieses Zustands zu bilden, dh es gibt keinen anderen Ort, an dem er gefüllt werden kann. <br><br>  Nun wollen wir sehen, was auf der Ebene der Übergangsgraphen gemacht wird: <br><br><img src="https://habrastorage.org/webt/97/p-/2d/97p-2dwdvbxyb_tpi-xaqjdhuck.png"><br><br>  Mit dem Hilfsauslöser <b>Start_Prev</b> können <b>Sie</b> am Eingang <b>Start</b> eine positive <b>Flanke</b> abfangen und eine Verzögerungsleitung für 1 Zyklus organisieren.  Es enthält immer den Status der <b>Starteingabe</b> , der sich auf der vorherigen Kennzahl befand.  Jemand ist besser damit vertraut, dies in Verilog zu sehen: <br><br><img src="https://habrastorage.org/webt/mm/pc/vw/mmpcvwuturlr5nieqnkgieml_tm.png"><br><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text</b> <div class="spoiler_text"><pre><code class="plaintext hljs">always @ (posedge clock) begin : Idle_state_logic case(State) Idle : begin Start_Prev &lt;= (Start); IsIdle &lt;= (1); if (( Start&amp;(!Start_Prev)&amp;(!Process_Finished) ) == 1'b1) begin State &lt;= One ; end end</code> </pre> <br></div></div><br>  Dementsprechend ist die <b>Bedingung Start &amp; (! Start_Prev)</b> nur dann <b>erfüllt</b> , wenn <b>zwischen den Maßnahmen</b> eine positive Differenz der <b>Startlinie auftritt</b> . <br><br>  Wenn sich die Maschine in diesem Zustand befindet, wird der <b>IsIdle-</b> Ausgang in einen einzelnen Zustand versetzt, <b>wodurch</b> die externe Umgebung darüber informiert wird, dass der Block passiv ist.  Bei diesem Ansatz werden weniger PLD-Ressourcen ausgegeben, als wenn das Konstrukt <b>State == Idle</b> an die Ausgabe übergeben wurde. <br><br>  Wenn die Differenz des Startsignals von der externen Umgebung stammt und der Akkumulator A1 einen Wert ungleich Null hat, verlässt die Maschine den <b>Ruhezustand</b> .  Wenn in A1 Null eingegeben wird, ist die Engine nicht an der Entwicklung dieses Segments beteiligt, so dass die Differenz auf der <b>Startlinie</b> ignoriert wird.  Dies gilt für einen nicht verwendeten Extruder.  Bei einigen Druckern wird die Z-Achsen-Engine ebenfalls selten verwendet. Ich möchte Sie daran erinnern, wie eine Bedingung gebildet wird, die in A1 einen Nullwert anzeigt (und dessen Umkehrung ungleich Null ist): <br><br><img src="https://habrastorage.org/webt/ez/kk/up/ezkkuprcmblrfjx22av9dlfu5bc.png"><br><br>  Als nächstes tritt die Maschine in den Zustand <b>Eins ein</b> : <br><br><img src="https://habrastorage.org/webt/zr/qc/cm/zrqccmzwghfncwcqyfekuhawmcg.png"><br><br>  In diesem Zustand wird der <b>Schrittausgang</b> auf 1 gesetzt. Ein Schrittimpuls wird an den Treiber angelegt.  Außerdem wird der Wert des <b>IsIdle-</b> Triggers <b>zurückgesetzt</b> .  Die externe Umgebung wird informiert, dass sich das Gerät in der aktiven Phase befindet. <br><br>  Dieser Zustand wird durch das <b>One_Finished-</b> Signal verlassen, das auf eins angehoben wird, wenn der Sieben-Bit-Zähler auf Null zählt.  Ich <b>möchte</b> Sie daran erinnern, dass das <b>One_Finished-</b> Signal von diesem bestimmten Zähler generiert wird: <br><br><img src="https://habrastorage.org/webt/ls/yp/re/lsypreow8ydou_tqhrls8us-qem.png"><br><br>  Während sich die Maschine in diesem Zustand befindet, lädt die ALU den Wert aus dem Register D0 in die Batterie A0 (Einstellen der Impulsdauer).  Lassen Sie mich Ihnen nur eine kurze Notiz zeigen, die Folgendes sagt: <br><br><img src="https://habrastorage.org/webt/am/b_/fa/amb_faw1o-9vsgframn5iswseas.png"><br><br>  Der geladene Wert wird im folgenden Zustand verwendet.  Die Maschine erzeugt eine Verzögerung, die die Impulsdauer festlegt: <br><br><img src="https://habrastorage.org/webt/hh/eb/kf/hhebkfiwmsmnnrtkf17w2wqby8o.png"><br><br>  Der <b>Step-</b> Ausgang wird auf Null zurückgesetzt.  Die Batterie A0 nimmt ab, wie der folgende kurze Eintrag zeigt: <br><br><img src="https://habrastorage.org/webt/bb/63/dk/bb63dkglkjd8_7wn1s2by22_hym.png"><br><br>  Und wenn Sie darauf doppelklicken - ein vollständiger Eintrag: <br><br><img src="https://habrastorage.org/webt/-8/6d/ry/-86dryefyslh1qsvlo4ggkdojhg.png"><br><br>  Wenn der Wert von A0 Null erreicht, wird das Pules_Finished-Flag gesetzt und die Maschine wird in den <b>Dekrementierungszustand versetzt</b> : <br><br><img src="https://habrastorage.org/webt/6k/sw/yv/6kswyvakmiszucfe1cx49pjcyig.png"><br><br>  In diesem Zustand nimmt in ALU der Wert des Akkumulators A1 ab, wodurch die Anzahl der Impulse eingestellt wird: <br><br><img src="https://habrastorage.org/webt/ci/9r/1e/ci9r1ervyzj1gyma_tpj4uxnzfq.png"><br><br>  Vollversion des Datensatzes: <br><br><img src="https://habrastorage.org/webt/l9/dk/hy/l9dkhy0a6bb2bqpzgmzgtox7clk.png"><br><br>  Je nach Ergebnis erfolgt ein Übergang entweder zum nächsten Impuls oder zum <b>Ruhezustand</b> .  Doppelklicken Sie auf den Status, um die Übergänge unter Berücksichtigung der Prioritäten anzuzeigen: <br><br><img src="https://habrastorage.org/webt/jm/r-/7n/jmr-7nle2advdfl95fn8hnkid0i.png"><br><br>  Eigentlich mit UDB alles.  Jetzt machen wir das entsprechende Symbol.  Klicken Sie dazu mit der rechten Maustaste auf den Editor und wählen <b>Sie Symbol generieren</b> : <br><br><img src="https://habrastorage.org/webt/j6/j3/qc/j6j3qcgoye9-2gac8fgowordfx8.png"><br><br>  Wir gehen zum Projektdiagramm: <br><br><img src="https://habrastorage.org/webt/ab/hb/l4/abhbl4ocjtfgw8r4vjfo8nfs05c.png"><br><br>  Und wir führen eine Schaltung ein, in der es eine bestimmte Anzahl dieser Steuerungen gibt.  Ich habe fünf gewählt (drei Achsen plus zwei Extruder).  Drucker mit einer großen Anzahl von Extrudern werden nicht als billig angesehen.  Sie können FPGA auf sie setzen.  Um die wahre Komplexität zu erkennen, habe ich einen USB-UART-Block (zum Empfangen von Daten von einem Computer oder demselben Raspberry Pi) und einen echten UART (für die Kommunikation mit einem billigen Wi-Fi-Modul ESP8266 oder beispielsweise einem intelligenten Display, das dies kann) verwendet GCODE über UART senden).  Ich habe keine PWMs usw. hinzugefügt, da deren Komplexität ungefähr klar ist und das reale System noch weit entfernt ist.  Es stellte sich irgendwie so heraus: <br><br><img src="https://habrastorage.org/webt/he/a6/ok/hea6okfr7irbrzjwm-bze2xlfxy.png"><br><br>  Das Steuerregister erzeugt ein Triggersignal, das gleichzeitig an alle Blöcke geht.  Lassen Sie außerdem Signale herauskommen, die während der Bildung des Segments statisch sind.  Ich habe alle <b>Idle-</b> Ausgänge mit "And" gesammelt und auf den Interrupt-Eingang angewendet.  Ich habe eine Unterbrechung an einer positiven Front ernannt.  Wenn mindestens ein Motor startet, wird der Interrupt-Eingang zurückgesetzt.  Am Ende des letzten Motors wird dieser gespannt, wodurch der Prozessor über die Bereitschaft zur Ausgabe des nächsten Segments informiert wird.  Passen Sie nun die Frequenzen an, indem Sie auf das <b>Baumelement Clocks</b> doppelklicken: <br><br><img src="https://habrastorage.org/webt/zy/yf/kl/zyyfklrmcfz5kmg-59qmzgdztug.png"><br><br>  Doppelklicken Sie in der <b>angezeigten</b> Tabelle auf das Element <b>PLL_OUT</b> : <br><br><img src="https://habrastorage.org/webt/8z/m0/r1/8zm0r10tu28rjatkhmo1h0skp80.png"><br><br>  Wir werden die Tabelle irgendwie ausfüllen (ich habe die Regeln zum Einrichten dieser Tabelle nicht gut genug verstanden, weshalb ich den Begriff "So etwas" verwende): <br><br><img src="https://habrastorage.org/webt/se/55/ps/se55ps9rti9fyvyguffgxdx0f0i.png"><br><br>  Doppelklicken Sie nun auf die Zeile <b>Clock_1</b> : <br><br><img src="https://habrastorage.org/webt/vn/py/px/vnpypxluipgeeme1fyf9icn9tu4.png"><br><br>  Stellen Sie die Taktfrequenz der UDB-Blöcke auf 48 MHz ein: <br><br><img src="https://habrastorage.org/webt/8z/sk/ik/8zskik6rpyovzo7ryqrxjeptinm.png"><br><br>  Da das Projekt experimentell ist, macht es keinen Sinn, eine API dafür zu erstellen.  Um das im vorherigen Artikel untersuchte Material zu konsolidieren, wechseln wir erneut zur Registerkarte Komponenten. Klicken Sie für das StepperController-Projekt mit der rechten Maustaste durch das Element Komponente hinzufügen, und fügen Sie zuerst die Header-Datei und dann die C-Quellcodedatei hinzu: <br><br><img src="https://habrastorage.org/webt/3i/bg/zk/3ibgzkq8nugwau5lszhe9ikudxi.png"><br><br><img src="https://habrastorage.org/webt/bm/k3/iw/bmk3iwh-aouvspv20g7_1bgi3wq.png"><br><br>  Ich werde oberflächlich die beiden Funktionen der Initialisierung und des Starts des von mir hinzugefügten Segments zeigen.  Der Rest ist im Beispiel zum Artikel zu sehen. <br><br><pre> <code class="plaintext hljs">void `$INSTANCE_NAME`_Start() { `$INSTANCE_NAME`_SingleVibrator_Start(); //"One" Generator start } void `$INSTANCE_NAME`_PrepareStep(int nSteps,int duration) { CY_SET_XTND_REG24(`$INSTANCE_NAME`_Datapath_1_D0_PTR, duration&gt;92?duration-92:0); CY_SET_XTND_REG24(`$INSTANCE_NAME`_Datapath_1_D1_PTR, nSteps&gt;1?nSteps-1:0); }</code> </pre><br>  Ich habe den Namen von <b>main.c</b> durch <b>main.cpp ersetzt</b> , um zu überprüfen, ob die Entwicklungsumgebung normal auf C ++ reagiert, da die Marlin-Firmware objektorientiert ist.  Vorhersehbar überschüttete Fehler, die vorhersehbar durch Hinzufügen einer regulären Sache beseitigt wurden: <br><br><img src="https://habrastorage.org/webt/5m/mn/cd/5mmncdgxig9oxchcekaofuv1k9y.png"><br><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">extern "C" { #include "project.h" }</code> </pre><br></div></div><br>  Für den weltweiten Start von Motoren habe ich eine solche Funktion gemacht (es ist sehr rau, aber für Experimente mit einem kugelförmigen Pferd im Vakuum reicht es aus, bei Experimenten ist die Entwicklungszeit wichtiger als die Schönheit): <br><pre> <code class="plaintext hljs">void StartSteppers() { Stepper_Control_Reg_Write (1); Stepper_Control_Reg_Write (1); Stepper_Control_Reg_Write (1); Stepper_Control_Reg_Write (0); }</code> </pre><br>  Sie startet das Startsignal für alle Fälle sofort für drei Takte und lässt es dann wieder fallen. <br><br>  Beginnen wir mit den Experimenten.  Gehen Sie zunächst einfach über die X- und Y-Engines (im Beispiel initialisiert die erste Gruppe von Aufrufen alle Controller, die zweite setzt die X- und Y-Controller auf die erforderliche Anzahl von Schritten und startet den Prozess): <br><br><pre> <code class="plaintext hljs">int main(void) { CyGlobalIntEnable; /* Enable global interrupts. */ StepperController_X_Start(); StepperController_Y_Start(); StepperController_Z_Start(); StepperController_E0_Start(); StepperController_E1_Start(); StepperController_X_PrepareStep (10,1000); //    StepperController_Y_PrepareStep (50,500); StartSteppers(); //   for(;;) { } }</code> </pre><br>  Wir schauen uns das Ergebnis an: <br><br><img src="https://habrastorage.org/webt/6x/io/v7/6xiov7g15a-ksl1_6kw7vkko0dc.png"><br><br>  Überprüfen Sie die Dauer des positiven Impulses: <br><br><img src="https://habrastorage.org/webt/ay/hk/jy/ayhkjyjphl4-pearn7zi3hnnknc.png"><br><br>  Alles ist richtig.  Schließlich überprüfen wir, wie gut der Interrupt funktioniert.  Fügen Sie eine globale Zählervariable hinzu: <br><br><pre> <code class="plaintext hljs">static int nStep=0;</code> </pre><br>  Diese Variable wird in der <b>Hauptfunktion</b> einer zugewiesen und in der Interrupt-Handler-Funktion erhöht.  Der Interrupt-Handler wird nur einmal ausgelöst, nur zur Überprüfung.  Ich habe es so gemacht: <br><br><pre> <code class="plaintext hljs">extern "C" { CY_ISR(StepperFinished) { if (nStep == 1) { StepperController_X_PrepareStep (5,500); StartSteppers(); nStep += 1; } } }</code> </pre><br>  Und in der <b>Hauptfunktion habe</b> ich buchstäblich zwei Zeilen hinzugefügt: die Einbeziehung von Interrupts und die Zuweisung dieser Variablen.  Und ich weise schon zu, als die Maschinen starteten.  Andernfalls kam eine falsche Interrupt-Anfrage.  Es gibt keinen besonderen Grund, jetzt dagegen anzukämpfen.  Das Projekt ist experimentell. <br><br><img src="https://habrastorage.org/webt/kb/v2/dm/kbv2dmk2s6cg9nzc9fjzypg5uyo.png"><br><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">int main(void) { CyGlobalIntEnable; /* Enable global interrupts. */ isr_1_StartEx(StepperFinished); StepperController_X_Start(); StepperController_Y_Start(); StepperController_Z_Start(); StepperController_E0_Start(); StepperController_E1_Start(); /* Place your initialization/startup code here (eg MyInst_Start()) */ StepperController_X_PrepareStep (10,1000); StepperController_Y_PrepareStep (20,500); StartSteppers(); nStep = 1; for(;;) { } }</code> </pre><br></div></div><br>  Wir überprüfen das Ergebnis (im zweiten Schritt sollte nur Motor X funktionieren und die Schritte sollten halb so viel werden): <br><br><img src="https://habrastorage.org/webt/0q/vi/iq/0qviiqvpko6m9i7o9tub3gmnqhw.png"><br><br>  Alles ist richtig. <br><br><h2>  Fazit </h2><br>  Im Allgemeinen ist bereits klar, dass UDB-Blöcke nicht nur zum Einstellen schneller Hardwarefunktionen verwendet werden können, sondern auch zum Verschieben der Logik von der Software auf die Firmware-Ebene.  Leider stellte sich heraus, dass das Volumen des Artikels so groß war, dass es unmöglich erscheint, die Überprüfung abzuschließen und eine eindeutige Antwort zu erhalten, ob die UDB-Funktionen für die endgültige Lösung der Aufgabe ausreichen.  Bisher ist nur ein kugelförmiges Pferd in einem Vakuum bereit, dessen Aktionen im Prinzip den erforderlichen sehr ähnlich sind, aber ein nerviger Leser, der mit der Theorie der Schrittmotorsteuerung vertraut ist, wird viele Mängel darin finden.  Die vorgestellte Einheit unterstützt keine Beschleunigung, ohne die der Betrieb eines echten Schrittmotors nicht möglich ist.  Vielmehr unterstützt es, aber in diesem Stadium wird eine hohe Interruptrate erforderlich sein, und alles wurde konzipiert, um dies zu vermeiden. <br><br>  Die Genauigkeit der Einstellung der Frequenz des dargestellten Blocks ist bei weitem nicht akzeptabel.  Insbesondere wird eine Pulsfrequenz von 40.000 Hz mit einem Teiler von 1200 und 39966 Hz mit einem Teiler von 1201 bereitgestellt. Zwischenfrequenzen zwischen diesen beiden Werten an diesem Gerät sind nicht erreichbar. <br><br>  Vielleicht gibt es noch einige andere Mängel.  Wir werden uns jedoch im nächsten Artikel mit ihnen befassen, um zu überprüfen, ob genügend UDB-Ressourcen vorhanden sind. <br><br>  In der Zwischenzeit haben die Leser unter anderem ein echtes Beispiel für die Erstellung eines Blocks auf Basis von UDB von Grund auf erhalten.  Das Testprojekt, das beim Schreiben dieses Artikels erhalten wurde, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kann hier aufgenommen werden</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433800/">https://habr.com/ru/post/de433800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433788/index.html">Secure Deal und neue freiberufliche Bewertungen</a></li>
<li><a href="../de433790/index.html">Erweiterte mehrstufige Build-Vorlagen</a></li>
<li><a href="../de433792/index.html">Shell-Skripte in Ansible</a></li>
<li><a href="../de433796/index.html">Wie Homo Sapiens die Welt eroberte. Kommunikations- und Verhandlungsfähigkeiten</a></li>
<li><a href="../de433798/index.html">HomeKit und ioBroker Lass uns zu Hause Freunde finden</a></li>
<li><a href="../de433802/index.html">Wie und warum wir den Big Data Track beim Urban Tech Challenge Hackathon gewonnen haben</a></li>
<li><a href="../de433804/index.html">Mixture Density Networks</a></li>
<li><a href="../de433806/index.html">Wenn das Online-Archiv vergisst</a></li>
<li><a href="../de433808/index.html">5 häufigste Fehler, die Programmierer beim Interview machen</a></li>
<li><a href="../de433810/index.html">Ein problemorientierter Ansatz für Projekte im Internet-Marketing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>