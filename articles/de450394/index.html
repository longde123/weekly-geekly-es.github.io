<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏿 💂 🐰 Untersuchung eines unbekannten Archivs 🎷 😾 🌗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Umzug. Neue Stadt. Jobsuche. Selbst für einen IT-Experten kann dies lange dauern. Eine Reihe von Interviews, die sich im Allgemeinen sehr ähnlich sind...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Untersuchung eines unbekannten Archivs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450394/">  Umzug.  Neue Stadt.  Jobsuche.  Selbst für einen IT-Experten kann dies lange dauern.  Eine Reihe von Interviews, die sich im Allgemeinen sehr ähnlich sind.  Und wie es normalerweise passiert, wenn Sie bereits eine Stelle gefunden haben, wird nach einer Weile ein interessantes Büro angekündigt. <br><br>  Es war schwer zu verstehen, was sie speziell tat, ihr Interessengebiet war jedoch das Studium der Software anderer Leute.  Es klingt faszinierend, obwohl Sie, wenn Sie feststellen, dass dies kein Anbieter zu sein scheint, der Software für die Cybersicherheit veröffentlicht, eine Sekunde innehalten und anfangen, Ihre Rüben zu kratzen. <br><br><img src="https://lh3.googleusercontent.com/Wm2cSc19nc9XsapzlEW-eGMZBZCEgSbZFCSj6hdNNlkqCa40ksCXrYv8ual-VfYF3rcn5OoM9X2OwIJY07u_dD5Lo_7mzZU4D7rQuu164GIDE2_IjBu_J1dIMsjD4uDgyep3yipN"><br><a name="habracut"></a><br>  Kurzum: Sie warfen das Archiv ab und boten an, es als Testaufgabe zu untersuchen und zu versuchen, eine bestimmte Signatur basierend auf den präsentierten Eingabedaten zu berechnen.  Es ist erwähnenswert, dass ich nur sehr wenig Erfahrung mit solchen Aktivitäten hatte und wahrscheinlich deshalb in der ersten Iteration der Lösung nur ein paar Stunden Zeit hatte - dann wurde die Motivation, dies zu tun, zunichte gemacht.  Und ja, natürlich habe ich als erstes versucht, es auf dem Telefon / Emulator auszuführen - diese Anwendung ist ungültig. <br><br>  <b>Was wir haben: ein</b> Archiv mit der Erweiterung <b>".apk"</b> .  Ich habe die Aufgabe selbst unter den Spoiler gestellt, damit sie nicht von Suchmaschinen indiziert wird: Was ist, wenn die Jungs es nicht mögen, dass ich die Lösung auf Habr stelle? <br><br><div class="spoiler">  <b class="spoiler_title">Aufgabe selbst</b> <div class="spoiler_text">  Die APK enthält Funktionen zum Generieren von Signaturen für ein assoziatives Array. <br>  Versuchen Sie, eine Signatur für den folgenden Datensatz zu erhalten: <br><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"user"</span></span> : <span class="hljs-string"><span class="hljs-string">"LeetD3vM4st3R"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"__s33cr$$tV4lu3__"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"hash"</span></span>: <span class="hljs-string"><span class="hljs-string">"34765983265937875692356935636464"</span></span> }</code> </pre> <br></div></div><br><h2>  Ärmel hochkrempeln </h2><br>  Es wird gesagt, dass das Archiv die Funktionalität zum Signieren eines assoziativen Arrays enthält.  Unter der Dateierweiterung verstehen wir sofort, dass es sich um eine für Android geschriebene Anwendung handelt.  Zuerst packen wir das Archiv aus.  Tatsächlich handelt es sich hierbei um ein reguläres ZIP-Archiv, mit dem jeder Archivierer problemlos umgehen kann.  Ich habe das Dienstprogramm apktool verwendet und, wie sich herausstellte, versehentlich ein paar Rechen umgangen.  Ja, es passiert (normalerweise das Gegenteil, ja?).  Der Zauber ist ziemlich einfach: <br><br><pre> <code class="bash hljs">apktool d task.zip</code> </pre> <br>  Es stellt sich heraus, dass der Code und die Ressourcen in der APK-Datei auch in separaten Binärdateien gespeichert sind und andere Software benötigt wird, um sie zu extrahieren.  apktool hat implizit Klassenbytes und Ressourcen herausgezogen und alles in eine natürliche Dateihierarchie zerlegt.  Sie können fortfahren. <br><br><pre> <code class="bash hljs">├── AndroidManifest.xml ├── apktool.yml ├── lib │   └── arm64-v8a ├── original │   ├── AndroidManifest.xml │   └── META-INF ├── res │   ├── anim │   ├── color │   ├── drawable │   ├── layout │   ├── layout-watch-v20 │   ├── mipmap-anydpi-v26 │   ├── values │   └── values-af ├── smali │   ├── android │   ├── butterknife │   ├── com │   ├── net │   └── org └── unknown   └── org</code> </pre> <br>  Wir sehen eine ähnliche Hierarchie (haben die vereinfachte Version verlassen) und versuchen herauszufinden, wo wir anfangen sollen.  Es ist erwähnenswert, dass ich trotzdem einmal ein paar kleine Anwendungen für Android geschrieben habe, so dass mir die Essenz eines Teils der Verzeichnisse und im Allgemeinen die Prinzipien der Android-Anwendungen des Geräts ungefähr klar sind. <br><br>  Zunächst entscheide ich mich, einfach durch die Dateien zu gehen.  Ich öffne AndroidManifest.xml und beginne sinnvoll zu lesen.  Meine Aufmerksamkeit wird von einem seltsamen Attribut angezogen <br><br><pre> <code class="xml hljs">android:supportsRtl="true"</code> </pre> <br>  Es stellt sich heraus, dass er für die Unterstützung von Sprachen mit dem Buchstaben "von rechts nach links" in der Anwendung verantwortlich ist.  Wir beginnen uns anzustrengen.  Nicht gut. <br><br>  Außerdem klammert sich mein Blick an den unbekannten Ordner.  Darunter befindet sich eine Hierarchie des Formulars: <b>org.apache.commons.codec.language.bm</b> und eine große Anzahl von Textdateien mit <b>unklarem</b> Inhalt.  Google den vollständigen Namen des Pakets und es stellt sich heraus, was hier gespeichert ist, was mit dem Suchalgorithmus für Wörter zusammenhängt, die dem angegebenen phonetisch ähnlich sind.  Ehrlich gesagt begann ich mich hier stärker anzustrengen.  Nachdem ich mich ein bisschen in den Verzeichnissen umgesehen hatte, fand ich tatsächlich den Code selbst und dann begann der Spaß.  Ich wurde nicht von dem üblichen Java-Bytecode getroffen, mit dem ich einmal herumspielen konnte, sondern von etwas anderem.  Sehr ähnlich, aber anders. <br><br>  Wie sich herausstellte, hat Android eine eigene virtuelle Maschine - Dalvik.  Und wie jede angesehene virtuelle Maschine verfügt sie über einen eigenen Bytecode.  Es scheint, dass ich beim ersten Versuch, dieses Problem zu lösen, in diesem traurigen Ton eine Pause ankündigte, mich verbeugte, den Vorhang fallen ließ und alles 4 Monate lang warf, bis meine Neugier mich vollständig beendete. <br><br><h2>  Ärmel hochkrempeln [2] </h2><br>  "Aber kann es nicht so sein, dass alles einfacher ist?"  - Dies ist die Frage, die ich mir gestellt habe, als ich die Aufgabe zum zweiten Mal gestartet habe.  Ich begann im Internet nach einem Dekompiler von smali nach Java zu suchen.  Ich habe nur gesehen, dass es unmöglich ist, diesen Prozess eindeutig durchzuführen.  Mit gerunzelter Stirn ging er zu Github und fuhr ein paar Schlüsselbegriffe in die Suchzeile.  Der erste kam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">smali2java</a> . <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> gradle build java -jar smali2java.jar ..</code> </pre> <br>  Fehler  Ich sehe eine riesige Stapelverfolgung und Fehler auf mehreren Seiten des Terminals.  Nachdem ich ein wenig über die Essenz des Inhalts gelesen habe (und Emotionen von der Größe der Stapelspur abgehalten habe), stelle ich fest, dass dieses Tool auf der Grundlage einer bestimmten beschriebenen Grammatik funktioniert und der Bytecode, den sie getroffen hat, eindeutig nicht mit dieser übereinstimmt.  Ich öffne den kleinen Bytecode und sehe darin Anmerkungen, Synthesemethoden und andere seltsame Konstruktionen.  In Java-Bytecode gab es so etwas nicht!  Wie lange  Löschen! <br><br><div class="spoiler">  <b class="spoiler_title">Weitere Details</b> <div class="spoiler_text">  Wie sich herausstellte, ist der virtuellen Dalvik-Maschine (sowie der JVM) die Existenz von Konzepten wie inneren / äußeren Klassen (gelesene verschachtelte Klassen) nicht bekannt, und der Compiler generiert die sogenannten "synthetischen" Methoden, um den Zugriff von der verschachtelten Klasse auf zu ermöglichen externe Felder zum Beispiel. <br><br><h4>  Als Beispiel: </h4><br>  Wenn die äußere Klasse (OuterClass) ein Feld hat <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OuterClass</span></span></span><span class="hljs-class"> </span></span>{ List a; ... }</code> </pre> <br>  Damit die private Klasse auf das Feld der externen Klasse zugreifen kann, generiert der Compiler implizit die folgende Methode: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> synthetic java.util.<span class="hljs-function"><span class="hljs-function">List </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OuterClass p1)</span></span></span><span class="hljs-function"> </span></span>{ p1 = p1.a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; }</code> </pre> <br>  Aufgrund einer solchen „Motorraum“ -Küche wird auch die Arbeit einiger anderer Mechanismen erreicht, die die Sprache bietet. <br><br>  Sie können diese Frage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier aus</a> genauer untersuchen. </div></div><br>  Hilft nicht.  Er schwört sogar auf einen scheinbar nicht verdächtigen Bytecode.  Ich öffne den Quellcode des Dekompilers, lese und sehe etwas sehr Seltsames: Selbst hinduistische Programmierer (bei allem Respekt) hätten dies nicht geschrieben.  Ein Gedanke schleicht sich ein: nicht wirklich der generierte Code.  Ich lehne die Idee für ungefähr 30 Minuten ab und versuche zu verstehen, was der Fehler ist.  KOMPLIZIERT.  Ich öffne Github wieder - und wirklich einen durch Grammatik generierten Parser.  Und hier ist der Generator selbst.  Alles weglegen und versuchen, sich von der anderen Seite zu nähern. <br><br>  <i>Es ist erwähnenswert, dass ich wenig später immer noch versuchte, die Grammatik und stellenweise sogar den Bytecode selbst zu ändern, damit der Dekompiler ihn noch verarbeiten konnte.</i>  <i>Aber selbst als der Bytecode in Bezug auf die Dekompiler-Grammatik gültig wurde, hat das Programm einfach nichts an mich zurückgegeben.</i>  <i>Open Source ...</i> <br><br>  Ich blättere durch den Bytecode und stoße auf mir unbekannte Konstanten.  Googeln, ich treffe das gleiche im Buch über Reverse-Android-Anwendungen.  Ich erinnere mich, dass dies nur die vom Compiler-Präprozessor zugewiesene ID ist, die den Ressourcen der Android-Anwendung zugewiesen ist (die Zeitkonstante für das Schreiben von Code ist R. *).  In der nächsten halben Stunde werde ich kurz untersuchen, welche Register für was verantwortlich sind, in welcher Reihenfolge die Argumente übergeben werden, und mich im Allgemeinen mit der Syntax befassen. <br><br><h2>  Wie sieht es aus? </h2><br><img src="https://lh4.googleusercontent.com/6vy-LnmhLmjl2TnDiAoA632c026jlrPG7zFlclZNXJRdpethXv_iFjRtzwyvQWrqkd1LUKixzHfzXAyDj4c28JAzqVYTmP9uqJTmUYgjJd8Yx5pEDkd0cad34bNg9LYDf3r2jFVj" width="350" height="496" align="left">  Ich habe das Layout des Hauptanwendungsfensters gefunden und daraus bereits verstanden, was in der Anwendung vor sich geht: Auf dem Hauptbildschirm (Aktivität) befindet sich eine RecyclerView (bedingt eine Ansicht, die UI-Objekte wiederverwenden kann, die derzeit nicht für die Speichernutzung angezeigt werden) mit Eingabefeldern Schlüssel / Wert-Paare, einige Schaltflächen, die für das Hinzufügen eines neuen Schlüssel / Wert-Paares zu einem bestimmten abstrakten Container verantwortlich sind, und eine Schaltfläche, die eine Signatur (Signatur) für diesen Container generiert. <br><br>  Wenn ich mir die Anmerkungen ansehe und eine bestimmte Menge Code beobachte, die der generierten verdächtig ähnlich ist, beginne ich zu googeln.  Das Projekt verwendet die ButterKnife-Bibliothek, mit der mithilfe von Anmerkungen <b>() -&gt; bind ()</b> UI-Elemente automatisch <b>aufgeblasen</b> werden können.  Wenn die Klasse Anmerkungen enthält, erstellt der ButterKnife-Anmerkungsprozessor implizit eine weitere Binder-Klasse der Form <b>&lt;original_class&gt; __ViewBinding</b> , die die gesamte Drecksarbeit unter der Haube erledigt.  Eigentlich habe ich all diese Informationen aus nur einer MainActivity-Datei erhalten, nachdem ich die Ähnlichkeit der Java-Quelle manuell daraus wiederhergestellt habe.  Nach einer halben Stunde wurde mir klar, dass die Anmerkungen dieser Bibliothek auch einen Rückruf für Schaltflächenaktionen festlegen können, und ich fand die Schlüsselfunktionen, die tatsächlich für das Hinzufügen eines Schlüssel / Wert-Paares zum Container und das Generieren einer Signatur verantwortlich waren. <br><br>  <i>Natürlich musste ich mich während des Studiums mit den „Innereien“ verschiedener Bibliotheken und Plugins befassen, da selbst schöne Landos mit Cookies nicht alle Anwendungsfälle und Details abdecken, was meiner Meinung nach für jeden „Umkehrer“ eine gängige Praxis ist.</i> <br><br><h2>  Faulheit ist ein Freund eines Programmierers </h2><br>  Nachdem ich mehr Zeit mit der zweiten Quelle verbracht hatte, war ich völlig müde und stellte fest, dass es nicht möglich war, Brei zu kochen.  Ich klettere wieder auf Github und diesmal schaue ich genauer hin.  Ich finde das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Smali2PsuedoJava-</a> Projekt - einen Dekompiler in „Pseudo-Java-Code“.  Selbst wenn dieses Dienstprogramm zumindest etwas zu einem menschlichen Aussehen führen kann, dann ist der Autor für mich ein Becher seines Lieblingsbiers (na ja, oder setzen Sie Github zunächst ein Sternchen). <br><br>  Und es funktioniert wirklich!  Wirkung auf das Gesicht: <br><br><img src="https://lh6.googleusercontent.com/4yxBPy1Wt7_J7uLey66rp_qHwomfvAW_B1C6g3CsrS0DR73J_U42t4JgobNaGIUXVstTEVIaHriawFfRVZL4IqUEObjCL8RdLUv5VCGKiv_jeAxBclaXZlsMvmFUzFuuuuxfshw7"><br><br><h2>  Treffen Sie Cipher.so </h2><br>  Wenig später, als ich den Java-Pseudocode des Projekts studiere und ihn ungläubig mit dem kleinen Bytecode vergleiche, finde ich eine seltsame Bibliothek im Code - Cipher.so.  Beim Googeln stelle ich fest, dass es sich um die Verschlüsselung einer Reihe von Kompilierungszeitwerten im APK-Archiv handelt.  Dies ist normalerweise erforderlich, wenn die Anwendung Konstanten des Formulars verwendet: IP-Adressen, Anmeldeinformationen für eine externe Datenbank, Token für die Autorisierung usw.  - Was kann mit Hilfe des Reverse Engineering der Anwendung erhalten werden.  Es stimmt, der Autor schreibt klar, dass dieses Projekt aufgegeben wird, sagen sie, gehen weg.  Das wird interessant. <br><br>  Diese Bibliothek bietet Zugriff auf Werte über die Java-Bibliothek, wobei die spezifische Methode der für uns interessante Schlüssel ist.  Es weckt nur mein Interesse und ich beginne tiefer zu klettern. <br><br>  Kurz gesagt, was macht Cipher.so und wie funktioniert es: <br><br><ul><li>  In der Gradle-Datei unseres Projekts werden die Schlüssel und die entsprechenden Werte registriert <br></li><li>  Alle Schlüsselwerte werden automatisch in eine separate dynamische Bibliothek (.so) gepackt, die beim Kompilieren generiert wird.  Ja - ja, wird generiert. <br></li><li>  Diese Schlüssel können dann von Java-Methoden bezogen werden, die von Cipher.so generiert wurden <br></li><li>  Nach dem Erstellen der APK werden die Schlüsselnamen von MD5 gehasht (für mehr Sicherheit natürlich). <br></li></ul><br>  Nachdem ich die benötigte dynamische Bibliothek im Archivordner gefunden habe, wähle ich sie aus.  Als erfahrene Umkehrung (nein) versuche ich zunächst, mit einer einfachen zu beginnen - ich beschließe, den Abschnitt mit Konstanten und nach interessanten Linien in einem ELF-ähnlichen Binar zu betrachten.  Leider fehlen Benutzer des Mac, die sich sofort lesen, und vor dem Beginn sagen wir das Geschätzte: <br><br><pre> <code class="bash hljs">brew install binuitls</code> </pre> <br>  Und vergessen Sie nicht, den Pfad zu <b>/ usr / local</b> in PATH zu schreiben, denn <i>Brew</i> schützt Sie auf Gentleman-Weise vor allem ... <br><br><pre> <code class="bash hljs">greadelf -p .rodata lib/arm64-v8a/libcipher-lib.so | head -n 15</code> </pre> <br>  Wir beschränken die Ausgabe auf die ersten 15 Zeilen, da dies sonst für einen unvorbereiteten Ingenieur zu einem Schock führen kann. <br><br><img src="https://lh6.googleusercontent.com/-ka6awAjaQ6zTDJ4sogEHaqBEG2QL3il5HTS1M-HchKGBg4hK5qe__lAtEKtcL7CT0i_lhqtiEZYYRsnTpLmbc10hdpVTMcAeRP0bGJE87jUBvtkncNMJ3s5YtjgGXk0duZeHIrY"><br><br>  In den unteren Adressen bemerken wir verdächtige Zeilen.  Wie ich beim Studium der Quellen von Cipher.so herausgefunden habe, werden die Schlüssel und Werte in die übliche <b>std :: map</b> eingefügt <b>:</b> Dies gibt nur wenige Informationen, aber wir wissen, dass es im Binar neben verschlüsselten Passwörtern auch verschleierte Schlüssel gibt. <br><br>  Wie ist die Verschlüsselung von Werten?  Beim Studium der Quelle stellte ich fest, dass die Verschlüsselung mit AES erfolgt - dem standardmäßigen symmetrischen Verschlüsselungssystem.  Wenn es also verschlüsselte Werte gibt, sollte sich der Schlüssel in der Nähe befinden ... Nachdem ich ihn eine Weile studiert hatte, stieß ich im selben Projekt auf ein Problem mit dem provokanten Titel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Unsichere Schlüsselspeicherung: Geheimnisse sind sehr leicht abzurufen“</a> .  Darin fand ich heraus, dass der Schlüssel in klarer Form im Binar gespeichert ist, und fand den Entschlüsselungsalgorithmus.  Im Beispiel befand sich der Schlüssel an der Nulladresse, und obwohl ich verstanden hatte, dass der Compiler ihn an einer anderen Stelle im Abschnitt .rodata der Binärdatei ablegen konnte, entschied ich, dass diese verdächtige Einheit an der Nulladresse der Schlüssel ist. <br><br>  <b>Versuch Nr. 1: Ich</b> entschlüssele die Werte und glaube, dass der Verschlüsselungsschlüssel der gleiche ist.  Der Fehler.  OpenSSL weist darauf hin, dass etwas nicht stimmt.  Nachdem ich die Quellen von Cipher.so ein wenig gelesen habe, verstehe ich, dass, wenn der Benutzer während der Assemblierung keinen Schlüssel angibt, der Standardschlüssel verwendet wird - <i>Cipher.so@DEFAULT</i> . <br><br>  <b>Versuch 2:</b> Erneuter Fehler.  Hmm ... Wird es durch diese Konstante wirklich neu definiert?  Es ist ganz einfach, einen Fehler zu machen: verwirrender in Gradle geschriebener Code mit "weg" -Formatierung.  Ich überprüfe noch einmal.  Alles scheint so zu sein. <br><br>  Anstelle der Schlüssel sind ihre MD5-Hashes, und dann versuche ich mein Glück zu versuchen und einen Dienst mit Regenbogentischen zu eröffnen.  Voila - einer der Schlüssel ist das Wort "Passwort".  Es gibt keine Sekunde.  Es gibt uns natürlich nicht viel.  Diese beiden Schlüssel befinden sich an den Adressen 240 bzw. 2a2.  Im Prinzip ist es einfach, sie sofort zu erkennen - 32 Zeichen (MD5). <br><br>  Ich habe alles noch einmal überprüft und versucht, die Entschlüsselung mit allen anderen Zeilen (die sich in den unteren Adressen befinden) als Schlüssel für die Entschlüsselung durchzuführen - alles ist vergebens. <br>  Es gibt also einen anderen geheimen Schlüssel, der Algorithmus der Aktionen scheint korrekt zu sein.  Ich werfe diese Aufgabe beiseite und versuche mich nicht zu begraben. <br><br>  Nachdem ich ein bisschen im Container-Signatur-Algorithmus gestöbert habe, sehe ich immer noch Aufrufe der Cipher.so-Bibliothek und des Codes, der auch die kryptografischen Funktionen der Java-Bibliothek verwendet. <br><br><h2>  Ein Rätsel (das ich nie gelöst habe) </h2><br>  In der Funktion, die für die Verschlüsselung verantwortlich ist, wird ganz am Anfang nach Schlüsseln im Container gesucht. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] a(java/util/Map p1) { v0 = p1.size() v1 = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v0 != <span class="hljs-number"><span class="hljs-number">0</span></span>) goto :cond_0 p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[v1]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; :cond_0 v0 = <span class="hljs-string"><span class="hljs-string">"user"</span></span>; v0 = p1.containsKey(v0) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v0 == <span class="hljs-number"><span class="hljs-number">0</span></span>) goto :cond_1 p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[v1]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; ...</code> </pre><br>  Wörtlich: Wenn es einen "Benutzer" -Schlüssel gibt, ist dieser Container nicht signiert (eine Nullsignatur wird zurückgegeben).  Ein seltsames Gefühl: Es scheint, als sei das Problem gelöst, aber es scheint irgendwie verdächtig einfach.  Warum dann alles andere erfinden?  In die Irre führen?  Warum habe ich diesen Code dann noch nicht fließend studiert?  Hmm ... <br><br>  Nein, nicht wahr.  Ich habe die Antwort eines bestimmten Benutzers in einem blauen Messenger angegeben, dessen Kontakte mir bei der Auftragserteilung zur Verfügung gestellt wurden.  Weiter graben.  Vielleicht ändert sich der Eingabeschlüssel / Wertesatz irgendwie, wenn er dem Container hinzugefügt wird?  Ich habe den Code sorgfältig gelesen. <br><br>  Bitte beachten Sie, dass der Dekompiler Anmerkungen aus dem Smali-Code entfernt hat.  Was ist, wenn er etwas Wichtiges entfernt hat?  Ich überprüfe die Hauptdateien - es scheint, nichts Wesentliches.  Alles Wichtige ist vorhanden, aber die Bedeutung geht nicht verloren.  Ich überprüfe Rückruffunktionen, die für das Schreiben eines Schlüssel / Wert-Paares von einer bedingten TextBox in interne Container verantwortlich sind.  Ich habe nichts Verbrecherisches gefunden. <br><br>  Ich wurde in jeder Codezeile so skeptisch wie möglich - ich kann niemandem mehr vertrauen. <br><br>  Einfache Lösung Nr. 2: Ich habe festgestellt, dass der Signaturvorgang damit beginnt, dass in der Signatur des Zertifikats, mit dem die Anwendung signiert wurde, ein Wert (Teilzeichenfolge in der Zeichenfolge) vorhanden ist. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@OnClick</span></span> <span class="hljs-comment"><span class="hljs-comment">//   protected void huvot324yo873yvo837yvo() { String signature = "no data"; boolean result = some_packages.isKeyInSignature(this); if result { Map map = new HashMap(); ...</span></span></code> </pre> <br>  Die Bedeutung selbst liegt natürlich verschlüsselt in diesem unglücklichen Binar.  Und tatsächlich, wenn dieser Wert nicht in der Signatur enthalten ist, signiert der Algorithmus nichts, sondern gibt einfach die Zeichenfolge "keine Daten" als Signatur zurück ... Wieder werden wir für Cipher genommen ... <br><br><h2>  Schlüsselentschlüsselung Endkampf </h2><br>  Um das Ausmaß der Tragödie zu verstehen, war ich folgendermaßen verwirrt: <br><br>  Ich machte einen Hex-Dump von diesem Abschnitt und schaute in die ersten beiden Zeilen, deren Verdacht von Anfang an nicht nachließ. <br><br><img src="https://lh4.googleusercontent.com/J4lmChj6kk0lWWy23D8QngSgnJlNfd-xDP1XyBnw1wyQ_U1NBRLYyx2BFZ4y9D1HXEjcSeCKVvZC3xgVCpx-VSV0bIHD5dcmsfdaX4jrmH-uRFsRMc9VJrqpUEMDEEaijeSTPRbk"><br><br>  Wenn Sie darauf achten, ist das Zeichen, das die Zeilen hier trennt, '0x00'.  Es wird auch häufig von der Standard-C-Bibliothek in Zeichenfolgenfunktionen verwendet.  Aus diesem Grund ist es nicht weniger interessant, welche Art von Leerzeichen sich in der Mitte der ersten Zeile befindet.  Als nächstes beginnen verrückte Versuche, bei denen der Schlüssel ist: <br><br><ul><li>  ganze erste Reihe <br></li><li>  erste Zeile vor dem Leerzeichen <br></li><li>  erste Zeile vom Raum bis zum Ende <br></li><li>  ... <br></li></ul><br>  Der Grad der Paranoia kann bereits geschätzt werden.  Wenn Sie nicht verstehen, wie schwierig und gerissen die Aufgabe sein sollte, fahren Sie los.  Und doch nicht das.  Dann kam mir der Gedanke: "Funktioniert der Algorithmus aufgrund eines Problems auf meinem Computer korrekt?".  Im Allgemeinen ist die Abfolge der Aktionen dort logisch und hat keine Fragen aufgeworfen. Die Frage lautet jedoch: Tun die Befehle auf meinem Computer, was sie von ihnen verlangen?  Also, was denkst du? <br><br>  Nachdem alle Schritte manuell überprüft wurden, stellte sich heraus, dass <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"some_base64_input"</span></span> | openssl base64 -d</code> </pre> <br>  Bei einigen Eingabeargumenten wird plötzlich eine leere Zeichenfolge zurückgegeben.  Hmm. <br><br>  Durch Ersetzen durch den ersten base64-Decoder auf dem Computer und Durchsuchen der Hauptkandidaten wurde sofort ein geeigneter Schlüssel gefunden und die Schlüssel wurden entsprechend entschlüsselt. <br><br><h2>  Abrufen von Signaturen aus einem Zertifikat </h2><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isKeyInSignature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(android.content.Context p1)</span></span></span><span class="hljs-function"> </span></span>{ v0 = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> TRY_0{ v1 = p1.getPackageManager() p0 = p1.getPackageName() v2 = <span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-comment"><span class="hljs-comment">// GET_SIGNATURES PackageInfo p0 = v1.getPackageInfo(p0, v2) android.content.pm.Signature[] p0 = p0.signatures; // Order are not guaranteed v1 = p0.length; v2 = 0x0; :goto_0 if (v2 &gt;= v1) goto :cond_1 v3 = p0[v2]; String v3 = v3.toCharsString() String v4 = net.idik.lib.cipher.so.CipherClient.a() v3 = v3.contains(v4) }TRY_0 catch TRY_0 (android/content/pm/PackageManager$NameNotFoundException) goto :catch_0; if (v3 == 0) goto :cond_0 p1 = 0x1; return p1; :cond_0 v2 = v2 + 0x1; goto :goto_0 :catch_0 p0 = Thrown Exception p1.printStackTrace() :cond_1 return v0; }</span></span></code> </pre> <br>  So sieht der generierte Pseudocode nach meinen kleinen Änderungen aus.  Verwirrt ein paar Dinge: <br><br><ul><li>  schlechte Kenntnisse der Kryptographie und der "Küche" der Gerätezertifikate <br></li><li>  Laut Dokumentation garantiert diese Methode nicht die Reihenfolge der Zertifikate in der zurückgegebenen Sammlung, und dementsprechend wäre es nicht möglich, in derselben Reihenfolge zu durchlaufen - was wäre, wenn die Anwendung mit mehr als einem Zertifikat signiert wäre? <br></li><li>  Mangel an Wissen darüber, wie das Zertifikat aus der APK extrahiert werden kann, da nicht klar ist, was Android Runtime in diesem Fall tut <br></li></ul><br>  Ich musste mich mit all diesen Themen befassen und das Ergebnis war wie folgt: <br><br><ul><li>  Das Zertifikat selbst befindet sich im Verzeichnis <i>original / META-INF / CERT.RSA</i> <i><br></i> <br>  In diesem Verzeichnis gibt es nur eine Datei mit dieser Erweiterung. Dies bedeutet, dass die Anwendung mit nur einem Zertifikat signiert ist <br></li><li>  Auf der Website über Research Engineering von Android-Anwendungen wurde eine Liste gefunden, die die Signatur extrahieren kann, die wir wie Android benötigen.  Zumindest laut Autor. <br></li></ul><br>  Durch Ausführen dieses Codes kann ich die Signatur herausfinden, und in Wirklichkeit ist der Schlüssel, den wir benötigen, eine Teilzeichenfolge.  Mach weiter.  Einfache Lösung Nr. 2 wird weggefegt. <br><br>  In der Tat befindet sich der Schlüssel im Zertifikat. Es bleibt nur zu verstehen, was als nächstes kommt, denn wenn wir den "Benutzer" -Schlüssel haben, erhalten wir alle auch eine Nullsignatur, und wie wir oben erfahren haben, ist dies die falsche Antwort. <br><br><h2>  Schreiben Sie die Dokumentation sorgfältig! </h2><br>  Weitere Studien zur Tatsache, dass die aus den Textfeldern eingegebenen Daten geändert werden, werden mangels Beweisen verworfen.  Paranoia rollt mit neuer Kraft: Vielleicht ist der Code, der die Signatur aus dem Zertifikat gezogen hat, falsch oder handelt es sich um eine Code-Implementierung für alte Android-Versionen?  Ich öffne die Dokumentation erneut und sehe Folgendes: ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://developer.android.com/reference/android/content/pm/Signature.html#toChars ()</a> ): <br><br><img src="https://lh5.googleusercontent.com/1TZ3rj6hzTEWw5YHEl1EWnANjsiqpzGR-tTrXP_Nc6jt42ANPf1QW-fmP-mh7Y2MhgMcZF0Z8CpskzT_ge65C0YCcryiWjjpG0UuPeqkUCsde1qcQgm5NbeqFj4KO3QkdtvHM3v2"><br><br>  <b>Hinweis: Die</b> Funktion codiert die Signatur als ASCII-Text.  Die Ausgabe, die ich oben erhalten habe, war eine hexadezimale Darstellung der Daten.  Diese API kam mir seltsam vor, aber wenn Sie der Dokumentation glauben, stellt sich heraus, dass ich erneut blockiert war und der verschlüsselte Schlüssel keine Teilzeichenfolge der Signatur ist.  Nachdem ich eine Weile nachdenklich auf dem Code gesessen hatte, konnte ich es nicht ertragen und öffnete den Quellcode für diese Klasse.  <a href="">https://android.googlesource.com/platform/frameworks/base/+/e639da7/core/java/android/content/pm/Signature.java</a> <br><br>  Die Antwort ließ nicht lange auf sich warten.  Und tatsächlich im Code selbst - ein Ölgemälde: Das Ausgabeformat ist eine gewöhnliche Hex-Zeichenfolge.  Und jetzt denke: Entweder verstehe ich etwas nicht oder die Dokumentation ist "leicht" falsch geschrieben.  Nachdem ich in keiner Weise gescholten hatte, machte ich mich wieder an die Arbeit. <br><br><h2>  Zusammenfassung </h2><br>  Die folgenden n Stunden sind vergangen: <br><br><ul><li>  Überprüfen der Richtigkeit der Arbeit im Code mit RecyclerView und Ermitteln des Verhaltens durch den Quellcode seitdem  ,           StackOverflow <br></li><li>    ,    ,   Java.    ,    -       («user»)     .       . <br></li></ul><br>  ,        (             ). <br><br>  Nein. ,     .  ,    ,  ,       ,     .  .  —      ,     ,    ,  . <br><br>  ,       ,        .    .       ,           . , -   ,      ,      « »,    ,      . <br><br>  -    c        –      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">arturbrsg</a> . <br><br> Stay tuned. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450394/">https://habr.com/ru/post/de450394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450374/index.html">RAM-Erweiterungskarte für Apple IIgs</a></li>
<li><a href="../de450376/index.html">Wie Yandex.Taxi nach Autos sucht, wenn sie es nicht sind</a></li>
<li><a href="../de450378/index.html">GitLab 11.10</a></li>
<li><a href="../de450384/index.html">Die Geschichte einer kleinen Legacy-Code-Studie</a></li>
<li><a href="../de450386/index.html">Schnittstellen als abstrakte Datentypen in Go</a></li>
<li><a href="../de450396/index.html">So verbessern Sie Ihr schriftliches Englisch: praktische Tipps und nützliche Tools</a></li>
<li><a href="../de450398/index.html">Die furchtlosesten Gifte</a></li>
<li><a href="../de450410/index.html">Terraformer - Infrastruktur zum Codieren</a></li>
<li><a href="../de450416/index.html">Wie Shareware-VPN-Anbieter Ihre Daten verkaufen</a></li>
<li><a href="../de450418/index.html">Die Kunst, organische 3D-Modelle zu erstellen: Subdermale Shader</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>