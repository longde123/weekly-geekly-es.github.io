<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçü§ù‚Äçüë®üèΩ ü§µüèª ‚õΩÔ∏è Validation des adresses m√©moire sur un Cortex-M0 / M3 / M4 / M7 üôçüèæ üñ•Ô∏è üë∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 En ce qui concerne le rel√¢chement du r√©gime l' autre jour, l'indignation dans les commentaires d'un article voisin que les articles ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Validation des adresses m√©moire sur un Cortex-M0 / M3 / M4 / M7</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437256/">  Bonjour, Habr! <br><br>  En ce qui concerne le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rel√¢chement du r√©gime l'</a> autre jour, l'indignation dans les commentaires d'un article voisin que les articles sur les microcontr√¥leurs ne font que clignoter par la LED, et aussi la mort pr√©matur√©e de mon blog standard, que je suis trop paresseux pour restaurer, je vais transf√©rer ici des informations utiles sur une petite lumi√®re regrettable une astuce pour travailler avec les c≈ìurs Cortex-M - v√©rifier la validit√© des adresses al√©atoires. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rl/he/2w/rlhe2wjgxij3ej65fi5t8lverts.jpeg"></div><br>  L'une des fonctionnalit√©s tr√®s utiles et en m√™me temps pour une raison quelconque pr√©d√©finies qui ne sont d√©crites nulle part sur les microcontr√¥leurs Cortex-M (tous) est la possibilit√© de v√©rifier l'exactitude de l'adresse en m√©moire.  Avec lui, vous pouvez d√©terminer la taille du flash, de la RAM et de l'EEPROM, d√©terminer la pr√©sence sur un processeur particulier de p√©riph√©riques et de registres sp√©cifiques, combattre les processus tomb√©s tout en maintenant la sant√© globale du syst√®me d'exploitation, etc. <br><a name="habracut"></a><br>  En mode normal, lorsque vous arrivez √† une adresse inexistante sur Cortex-M3 / M4 / M7, une exception BusFault est lev√©e et, en l'absence de son gestionnaire, elle d√©g√©n√®re en HardFault.  Sur Cortex-M0, il n'y a pas d'exceptions ¬´d√©taill√©es¬ª (MemFault, BusFault, UsageFault), et toute d√©faillance est imm√©diatement transmise √† HardFault. <br><br>  En g√©n√©ral, vous ne pouvez pas ignorer HardFault - cela peut √™tre le r√©sultat d'une d√©faillance mat√©rielle, par exemple, et le comportement ult√©rieur de l'appareil deviendra impr√©visible.  Mais dans le cas particulier, cela peut et doit √™tre fait. <br><br><h4>  Cortex-M3 et Cortex-M4: le d√©faut de bus non rempli </h4><br>  Sur Cortex-M3 et sup√©rieur, la v√©rification de la validit√© de l'adresse est assez simple: vous devez interdire toutes les exceptions (sauf, √©videmment, non masquables) via le registre FAULTMASK, d√©sactiver sp√©cifiquement le traitement BusFault, puis fouiller dans l'adresse v√©rifi√©e et voir si le drapeau BFARVALID dans le registre BFAR , c.-√†-d. registre d'adresse de d√©faut de bus.  Si vous l'avez pris, vous venez d'avoir un BusFault, c'est-√†-dire  L'adresse est incorrecte. <br><br>  Le code ressemble √† ceci, toutes les d√©finitions et fonctions proviennent du CMSIS standard (non-fournisseur), donc il devrait fonctionner sur n'importe quel M3, M4 ou M7: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpu_check_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *address)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Cortex-M3, Cortex-M4, Cortex-M4F, Cortex-M7 are supported */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> BFARVALID_MASK = (<span class="hljs-number"><span class="hljs-number">0x80</span></span> &lt;&lt; SCB_CFSR_BUSFAULTSR_Pos); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_valid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Clear BFARVALID flag by writing 1 to it */</span></span> SCB-&gt;CFSR |= BFARVALID_MASK; <span class="hljs-comment"><span class="hljs-comment">/* Ignore BusFault by enabling BFHFNMIGN and disabling interrupts */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask = __get_FAULTMASK(); __disable_fault_irq(); SCB-&gt;CCR |= SCB_CCR_BFHFNMIGN_Msk; <span class="hljs-comment"><span class="hljs-comment">/* probe address in question */</span></span> *address; <span class="hljs-comment"><span class="hljs-comment">/* Check BFARVALID flag */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((SCB-&gt;CFSR &amp; BFARVALID_MASK) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Bus Fault occured reading the address */</span></span> is_valid = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Reenable BusFault by clearing BFHFNMIGN */</span></span> SCB-&gt;CCR &amp;= ~SCB_CCR_BFHFNMIGN_Msk; __set_FAULTMASK(mask); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> is_valid; }</code> </pre> <br><h4>  Cortex-M0 et Cortex-M0 + </h4><br>  Avec Cortex-M0 et Cortex-M0 +, tout est plus compliqu√©, comme je l'ai dit ci-dessus, ils n'ont pas BusFault et tous les registres correspondants, et les exceptions sont imm√©diatement escalad√©es en HardFault.  Par cons√©quent, il n'y a qu'une seule issue: permettre au gestionnaire HardFault de comprendre que l'exception a √©t√© d√©lib√©r√©ment provoqu√©e et de revenir √† la fonction qui l'a appel√©e, en y passant un indicateur indiquant que HardFault √©tait l√†. <br><br>  Cela se fait uniquement en assembleur.  Dans l'exemple ci-dessous, le registre R5 est mis √† 1 et deux "nombres magiques" sont √©crits dans les registres R1 et R2.  Si HardFault se produit apr√®s avoir essay√© de charger la valeur √† l'adresse en cours de v√©rification, il doit alors v√©rifier les valeurs de R1 et R2, et s'ils trouvent les nombres n√©cessaires, d√©finissez R5 sur z√©ro.  La valeur de R5 est transf√©r√©e au code syshech via une variable sp√©ciale qui est rigidement li√©e √† ce registre, l'adresse √† assembler dans l'assembleur est implicite, nous savons juste que dans arm-none-eabi le premier param√®tre de la fonction est plac√© dans R0. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpu_check_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *address)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Cortex-M0 doesn't have BusFault so we need to catch HardFault */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)address; <span class="hljs-comment"><span class="hljs-comment">/* R5 will be set to 0 by HardFault handler */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* to indicate HardFault has occured */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> result __asm(<span class="hljs-string"><span class="hljs-string">"r5"</span></span>); __<span class="hljs-function"><span class="hljs-function">asm__ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r5, =1 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* set default R5 value */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r1, =0xDEADF00D \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* set magic number */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r2, =0xCAFEBABE \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* 2nd magic to be sure */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldrb r3, [r0] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* probe address */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Le code du gestionnaire HardFault dans sa forme la plus simple ressemble √† ceci: <br><br><pre> <code class="cpp hljs">__attribute__((naked)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hard_fault_default</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Get stack pointer where exception stack frame lies */</span></span> __<span class="hljs-function"><span class="hljs-function">asm__ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* decide if we need MSP or PSP stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movs r0, #4 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* r0 = 0x4 */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mov r2, lr \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* r2 = lr */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"tst r2, r0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* if(lr &amp; 0x4) */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"bne use_psp \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* { */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mrs r0, msp \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* r0 = msp */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"b out \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* } */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" use_psp: \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* else { */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mrs r0, psp \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* r0 = psp */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" out: \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* } */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* catch intended HardFaults on Cortex-M0 to probe memory addresses */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r1, [r0, #0x04] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* read R1 from the stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r2, =0xDEADF00D \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* magic number to be found */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"cmp r1, r2 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* compare with the magic number */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"bne regular_handler \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* no magic -&gt; handle as usual */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r1, [r0, #0x08] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* read R2 from the stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r2, =0xCAFEBABE \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* 2nd magic number to be found */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"cmp r1, r2 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* compare with 2nd magic number */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"bne regular_handler \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* no magic -&gt; handle as usual */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r1, [r0, #0x18] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* read PC from the stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"add r1, r1, #2 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* move to the next instruction */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"str r1, [r0, #0x18] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* modify PC in the stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r5, =0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* set R5 to indicate HardFault */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"bx lr \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* exit the exception handler */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" regular_handler: \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* here comes the rest of the fucking owl */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span></code> </pre> <br>  Au moment de quitter le gestionnaire d'exceptions, Cortex lance les registres, qui sont garantis corrompus par le gestionnaire (R0-R3, R12, LR, PC ...), sur la pile.  Le premier fragment - il est d√©j√† dans la plupart des gestionnaires HardFault pr√™ts √† l'emploi, √† l'exception de ceux √©crits sous du m√©tal nu pur - d√©termine quelle pile: lorsque vous travaillez dans le syst√®me d'exploitation, il peut s'agir de MSP ou de PSP, et ils ont des adresses diff√©rentes.  Dans les projets bare metal, la pile MSP (Main Stack Pointer) est g√©n√©ralement install√©e a priori, sans v√©rification - car la PSP (Process Stack Pointer) ne peut pas √™tre l√† en raison du manque de processus. <br><br>  Apr√®s avoir d√©termin√© la pile souhait√©e et mis son adresse dans R0, nous lisons les valeurs R1 (offset 0x04) et R2 (offset 0x08), la comparons avec des mots magiques, si les deux correspondent - nous lisons la valeur PC (offset 0x18) de la pile, ajoutons 2 (2 octets - la taille de l'instruction sur Cortex-M *) et enregistrez-la sur la pile.  Si cela n'est pas fait, lorsque nous reviendrons du gestionnaire, nous nous retrouverons sur la m√™me instruction qui a r√©ellement provoqu√© l'exception, et nous tournerons toujours en rond.  L'annexe 2 nous am√®ne √† la prochaine instruction au moment du retour. <br><br>  <i><b>* Upd.</b></i>  <i>Dans les commentaires, la question s'est pos√©e sur la taille des instructions sur le Cortex-M, je ferai la bonne r√©ponse ici: dans ce cas, le crash provoque l'instruction LDRB, qui est disponible dans l'architecture ARMv7-M en deux versions - 16 bits et 32 ‚Äã‚Äãbits.</i>  <i>La deuxi√®me option sera s√©lectionn√©e si au moins une des conditions est remplie:</i> <i><br><br></i> <ul><li>  <i>l'auteur a explicitement indiqu√© l'instruction LDRB.W au lieu de LDRB (nous ne le faisons pas)</i> </li><li>  <i>des registres sup√©rieurs √† R7 sont utilis√©s (pour nous - R0 et R3)</i> </li><li>  <i>Un d√©calage sup√©rieur √† 31 octets est sp√©cifi√© (nous n'avons pas de d√©calage)</i> </li></ul> <i><br><br></i>  <i>Dans tous les autres cas (c'est-√†-dire lorsque les op√©randes correspondent au format de la version 16 bits de l'instruction), l'assembleur <b>doit</b> s√©lectionner la version 16 bits.</i> <i><br><br></i>  <i>Par cons√©quent, dans notre cas, il y aura toujours une instruction de 2 octets qui doit √™tre d√©pass√©e, mais si vous modifiez fortement le code, des options sont possibles.</i> <br><br>  Ensuite, √©crivez 0 dans R5, qui sert d'indicateur pour entrer dans HardFault.  Les registres apr√®s R3 ne sont pas enregistr√©s dans la pile avant les registres sp√©ciaux, et lorsque vous quittez le gestionnaire, ils ne sont en aucun cas restaur√©s, c'est donc notre conscience de les g√¢ter ou de ne pas les g√¢cher.  Dans ce cas, nous changeons d√©lib√©r√©ment R5 de 1 √† 0. <br><br>  Le retour du gestionnaire d'interruption se fait exactement dans un sens.  Lorsque vous entrez dans le gestionnaire, une valeur sp√©ciale est √©crite dans le registre LR appel√©e EXC_RETURN, qui est n√©cessaire pour √©crire sur le PC pour quitter le gestionnaire - et pas seulement l'√©crire, mais le faire avec une commande POP ou BX (c'est-√†-dire, ¬´mov pc, lr, par exemple, ne fonctionne pas , bien que la premi√®re fois il vous semble que cela fonctionne).  BX LR ressemble √† une tentative pour acc√©der √† une adresse vide de sens (dans LR, il y aura quelque chose comme 0xFFFFFFF1 qui n'a rien √† voir avec l'adresse r√©elle de la proc√©dure √† laquelle nous devons revenir), mais en r√©alit√©, le processeur voit cette valeur sur le PC (o√π elle ira automatiquement), il restaurera les registres de la pile et continuera d'ex√©cuter notre proc√©dure - avec la proc√©dure suivante apr√®s avoir appel√© HardFault car nous avons augment√© manuellement le PC de cette pile de 2. <br><br>  Vous pouvez lire sur tous les d√©calages et commandes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">clairement o√π</a> , bien s√ªr. <br><br>  Eh bien, ou si les nombres magiques ne sont pas visibles, tout ira √† regular_handler, apr√®s quoi la proc√©dure de traitement HardFault habituelle suit - en r√®gle g√©n√©rale, c'est une fonction qui imprime les valeurs de registre sur la console, d√©cide quoi faire ensuite avec le processeur, etc. <br><br><h4>  D√©termination de la taille de la RAM </h4><br>  L'utilisation de tout cela est simple et directe.  Nous voulons √©crire un firmware qui fonctionne sur plusieurs microcontr√¥leurs avec diff√©rentes quantit√©s de RAM, tout en utilisant √† chaque fois de la RAM dans un programme complet? <br><br>  Oui facile: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpu_find_memory_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> block, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxsize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *address = base; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { address += block; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cpu_check_address(address)) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)(address - base) &lt; maxsize); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)(address - base); } <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> get_cpu_ram_size(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cpu_find_memory_size((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)SRAM_BASE, <span class="hljs-number"><span class="hljs-number">4096</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>); }</code> </pre> <br>  maxsize est n√©cessaire ici afin qu'il ne puisse pas y avoir d'espace entre la quantit√© maximale possible de RAM entre celui-ci et le prochain bloc d'adresses, sur lequel cpu_check_address se cassera.  Dans cet exemple, c'est 80 Ko.  Cela n'a √©galement aucun sens de sonder toutes les adresses - il suffit de regarder la fiche technique pour voir quelle est l'√©tape minimale possible entre les deux mod√®les de contr√¥leur et la d√©finir comme bloc. <br><br><h4>  Transition programmatique vers le chargeur de d√©marrage, situ√© au milieu de nulle part </h4><br>  Parfois, vous pouvez effectuer des astuces plus complexes - par exemple, imaginez que vous souhaitez passer par programme au chargeur de d√©marrage d'usine STM32 pour passer en mode de mise √† jour du firmware via UART ou USB, sans prendre la peine d'√©crire votre chargeur de d√©marrage. <br><br>  Le chargeur de d√©marrage STM32 se trouve dans la zone appel√©e m√©moire syst√®me, √† laquelle vous devez vous rendre, mais il y a un probl√®me - cette zone a des adresses diff√©rentes non seulement sur diff√©rentes s√©ries de processeurs, mais sur diff√©rents mod√®les de la m√™me s√©rie (une plaque √©pique peut √™tre trouv√©e dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AN2606</a> sur pages 22 √† 26).  Lorsque vous ajoutez la fonctionnalit√© correspondante √† la plate-forme en g√©n√©ral, et pas seulement √† un produit sp√©cifique, vous recherchez la polyvalence. <br><br>  Dans les fichiers CMSIS, l'adresse de d√©but de la m√©moire syst√®me est √©galement manquante.  Il n'est pas possible de le d√©terminer par l'ID du chargeur de d√©marrage, car  il s'agit d'un probl√®me de poule et d'oeuf - l'ID du chargeur de d√©marrage se trouve dans le dernier octet de la m√©moire syst√®me, ce qui nous ram√®ne √† la question de l'adresse. <br><br>  Cependant, si nous regardons la carte m√©moire STM32, nous verrons quelque chose comme ceci: <br><br><img src="https://habrastorage.org/webt/l4/nf/b3/l4nfb3xcw87qnsrey9n4mp3t0we.png"><br>  Dans ce cas, nous nous int√©ressons √† l'environnement de la m√©moire syst√®me - par exemple, en haut se trouve une zone une fois programmable (pas dans tous les STM32) et des octets d'options (dans tous).  Cette structure est observ√©e non seulement dans diff√©rents mod√®les, mais dans diff√©rentes lignes STM32, avec la seule diff√©rence dans la pr√©sence d'OTP et la pr√©sence d'un √©cart dans les adresses entre la m√©moire syst√®me et les options. <br><br>  Mais pour nous dans ce cas, la chose la plus importante est que l'adresse de d√©but des octets d'options se trouve dans les en-t√™tes CMSIS standard - elle est appel√©e OB_BASE. <br><br>  Plus simple encore.  Nous √©crivons la fonction pour rechercher la premi√®re adresse valide ou invalide vers le bas ou vers le haut √† partir de l'adresse sp√©cifi√©e: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpu_find_next_valid_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *stop, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> valid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *address = start; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (address == stop) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cpu_check_address(address) == valid) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> address; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stop &gt; start) { address++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { address--; } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br>  Et regardez vers le bas √† partir des octets d'options, d'abord la fin de la m√©moire syst√®me ou de l'OTP adjacent, puis le d√©but de la m√©moire syst√®me en deux passes: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* System memory is the valid area next _below_ Option bytes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *a, *b, *c; a = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)(OB_BASE - <span class="hljs-number"><span class="hljs-number">1</span></span>); b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Here we have System memory top address */</span></span> c = cpu_find_next_valid_address(a, b, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Here we have System memory bottom address */</span></span> c = cpu_find_next_valid_address(c, b, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Et sans trop de difficult√©, nous organisons cela en une fonction qui trouve le d√©but de la m√©moire syst√®me et y saute, c'est-√†-dire qu'il lance le chargeur de d√©marrage: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jump_to_bootloader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> __</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attribute__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((noreturn))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Sets up and jumps to the bootloader */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jump_to_bootloader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* System memory is the valid area next _below_ Option bytes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *a, *b, *c; a = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)(OB_BASE - <span class="hljs-number"><span class="hljs-number">1</span></span>); b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Here we have System memory top address */</span></span> c = cpu_find_next_valid_address(a, b, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Here we have System memory bottom address */</span></span> c = cpu_find_next_valid_address(c, b, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c) { NVIC_SystemReset(); } <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> boot_addr = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)c; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> boot_stack_ptr = *(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*)(boot_addr); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dfu_reset_addr = *(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*)(boot_addr+<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*dfu_bootloader)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*))(dfu_reset_addr); <span class="hljs-comment"><span class="hljs-comment">/* Reset the stack pointer */</span></span> __set_MSP(boot_stack_ptr); dfu_bootloader(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Cela d√©pend du mod√®le de processeur sp√©cifique ... rien ne d√©pend.  La logique ne fonctionnera pas sur les mod√®les qui ont un trou entre OTP et la m√©moire syst√®me - mais je n'ai pas v√©rifi√© s'il y en a.  Travaillera activement avec OTP - v√©rifier. <br><br>  D'autres astuces s'appliquent uniquement √† la proc√©dure habituelle pour appeler le chargeur de d√©marrage √† partir de votre code - n'oubliez pas de r√©initialiser le pointeur de pile et d'appeler la proc√©dure pour quitter le chargeur de d√©marrage avant d'initialiser les p√©riph√©riques, les vitesses d'horloge, etc.: en raison de son minimalisme, le chargeur de d√©marrage peut obstruer initialisez la p√©riph√©rie et attendez-vous √† ce qu'elle soit dans l'√©tat par d√©faut.  Une bonne option pour appeler le chargeur de d√©marrage √† partir d'un endroit arbitraire dans votre programme consiste √† √©crire dans le registre de sauvegarde RTC ou simplement √† une adresse connue dans la m√©moire d'un nombre magique, √† red√©marrer le programme et √† v√©rifier lors des premi√®res √©tapes de l'initialisation de ce num√©ro. <br><br>  PS √âtant donn√© que toutes les adresses de la carte m√©moire du processeur sont align√©es dans le pire des cas par 4, la proc√©dure ci-dessus sera consid√©rablement acc√©l√©r√©e par l'id√©e de les parcourir par incr√©ments de 4 octets au lieu d'un. <br><br><h4>  Avis important </h4><br>  NB: veuillez noter que sur un contr√¥leur sp√©cifique, la validit√© d'une adresse sp√©cifique n'indique pas n√©cessairement la pr√©sence r√©elle de fonctionnalit√©s pouvant se trouver √† cette adresse.  Par exemple, l'adresse du registre contr√¥lant un bloc p√©riph√©rique optionnel peut √™tre valide, bien que le bloc lui-m√™me soit absent dans ce mod√®le.  Du c√¥t√© du fabricant, les astuces les plus int√©ressantes sont possibles, g√©n√©ralement enracin√©es dans l'utilisation des m√™mes cristaux pour diff√©rents mod√®les de processeurs.  Cependant, dans la plupart des cas, ces proc√©dures fonctionnent et s'av√®rent tr√®s utiles. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437256/">https://habr.com/ru/post/fr437256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437244/index.html">Google apprend aux utilisateurs √† reconna√Ætre les e-mails de phishing</a></li>
<li><a href="../fr437248/index.html">Mitap FPGA √† Saint-P√©tersbourg</a></li>
<li><a href="../fr437250/index.html">Comment nous avons cr√©√© une application mobile qui n'a pas besoin d'un concepteur</a></li>
<li><a href="../fr437252/index.html">Cycle de le√ßon SDL 2.0: Le√ßon 3 - Biblioth√®ques d'extension SDL</a></li>
<li><a href="../fr437254/index.html">Informatique ternaire: notions de base</a></li>
<li><a href="../fr437258/index.html">Projet unique de l'√©quipe CATIA DESIGN: concept car Bleu</a></li>
<li><a href="../fr437260/index.html">Windows Phone 8.1: d√©veloppement post-nostalgie. Historique d'une seule application</a></li>
<li><a href="../fr437262/index.html">Comment l'eau de rivi√®re devient-elle potable?</a></li>
<li><a href="../fr437264/index.html">√âpuisement professionnel en informatique (r√©sultats de l'√©tude My Circle)</a></li>
<li><a href="../fr437270/index.html">Nous d√©ployons une machine virtuelle Windows avec un transfert de carte vid√©o virtuelle utilisant QEMU et Intel GVT-g</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>