<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📖 🌴 👉 Sauvegarde, Partie 4: Présentation et test de zbackup, restic, borgbackup 👩‍👧‍👧 🃏 👩🏾‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article abordera les outils logiciels de sauvegarde qui, en divisant le flux de données en composants séparés (morceaux), forment un référentiel. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sauvegarde, Partie 4: Présentation et test de zbackup, restic, borgbackup</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/454734/"><p><img src="https://habrastorage.org/webt/pr/ob/cd/probcd0kvhmv8mspkq9espvxzsq.png"></p><br><p>  Cet article abordera les outils logiciels de sauvegarde qui, en divisant le flux de données en composants séparés (morceaux), forment un référentiel. </p><br><p>  Les composants du référentiel peuvent en outre être compressés et chiffrés, et surtout - avec des processus de sauvegarde répétés - réutilisés à nouveau. </p><br><p>  Une sauvegarde dans un référentiel similaire est une chaîne nommée de composants associés, par exemple, basée sur diverses fonctions de hachage. </p><br><p>  Il existe plusieurs solutions similaires, je me concentrerai sur 3: zbackup, borgbackup et restic. </p><a name="habracut"></a><br><h3 id="ozhidaemye-rezultaty">  Résultats attendus </h3><br><p>  Étant donné que tous les candidats d'une manière ou d'une autre nécessitent la création d'un référentiel, l'un des facteurs les plus importants sera une estimation de la taille du référentiel.  Dans le cas idéal, sa taille ne devrait pas dépasser 13 Go selon la méthodologie acceptée, voire moins - sous réserve d'une bonne optimisation. </p><br><p>  Il est également hautement souhaitable de pouvoir sauvegarder des fichiers directement sans utiliser d'archiveurs tar, ainsi que de travailler avec ssh / sftp sans outils supplémentaires tels que rsync et sshfs. </p><br><p>  <strong>Comportement de sauvegarde:</strong> </p><br><ol><li>  La taille du référentiel sera égale ou inférieure à la taille des modifications. </li><li> Une charge de processeur importante est attendue lors de l'utilisation de la compression et / ou du chiffrement, et une charge assez importante sur le sous-système réseau et disque est probable si le processus d'archivage et / ou de chiffrement fonctionne sur le serveur de stockage de sauvegarde. </li><li>  Si vous endommagez le référentiel, une erreur retardée est probable à la fois lors de la création de nouvelles sauvegardes et lors de la tentative de restauration.  Il est nécessaire de planifier des mesures supplémentaires pour garantir l'intégrité du référentiel ou d'utiliser les moyens intégrés pour vérifier son intégrité. </li></ol><br><p>  Le travail avec le goudron est accepté comme valeur de référence, comme cela a été montré dans l'un des articles précédents. </p><br><h3 id="testirovanie-zbackup">  Test de Zbackup </h3><br><p>  Le mécanisme général de l'opération zbackup est que le programme trouve des zones contenant les mêmes données dans le flux de données fourni à l'entrée, puis il les comprime et les chiffre éventuellement, en n'enregistrant chaque zone qu'une seule fois. </p><br><p>  Pour la déduplication, une fonction de hachage en anneau 64 bits avec une fenêtre coulissante est utilisée pour vérifier par octets la coïncidence avec les blocs de données existants (similaire à la façon dont elle est implémentée dans rsync). </p><br><p>  Pour la compression, lzma et lzo sont utilisés dans l'exécution multithread et pour le chiffrement - aes.  Dans les dernières versions, il est possible à l'avenir de supprimer les anciennes données du référentiel. <br>  Le programme est écrit en C ++ avec des dépendances minimales.  L'auteur a apparemment été inspiré par la voie unix, donc le programme reçoit des données sur stdin lors de la création de sauvegardes, donnant un flux de données similaire à stdout lors de la restauration.  Ainsi, zbackup peut être utilisé comme une très bonne «brique» lors de l'écriture de vos propres solutions de sauvegarde.  Par exemple, l'auteur de l'article, ce programme est le principal outil de sauvegarde pour les machines domestiques depuis environ 2014. </p><br><p>  Un tar standard sera utilisé comme flux de données, sauf indication contraire. </p><br><div class="spoiler">  <b class="spoiler_title">Voyons quels seront les résultats:</b> <div class="spoiler_text"><p>  La vérification du travail a été effectuée en 2 versions: </p><br><ol><li>  un référentiel est créé et zbackup est lancé sur le serveur avec les données source, puis le contenu du référentiel est transféré vers le serveur de stockage de sauvegarde. </li><li>  un référentiel est créé sur le serveur de stockage de sauvegarde, zbackup est lancé via ssh sur le serveur de stockage de sauvegarde, les données lui sont transmises via pipe. </li></ol><br><p>  Les résultats de la première option étaient les suivants: 43m11s - lors de l'utilisation d'un référentiel non chiffré et d'un compresseur lzma, 19m13s - lors du remplacement du compresseur par lzo. </p><br><p>  La charge sur le serveur avec les données source était la suivante (l'exemple avec lzma est montré, avec lzo il y avait environ la même image, mais la proportion de rsync était environ un quart du temps): </p><br><p> <a href=""><img src="https://habrastorage.org/webt/pp/d3/hs/ppd3hsaxn_kffamwcrwstrb_sds.png"></a> </p><br><p>  Il est clair qu'un tel processus de sauvegarde ne convient que pour des modifications relativement rares et légères.  Il est également très souhaitable de limiter le fonctionnement de zbackup à 1 thread, sinon il y aura une charge de processeur très élevée, car  le programme est très bon pour travailler dans plusieurs threads.  La charge du disque était petite, ce qui, en général, avec un sous-système de disque ssd moderne, ne sera pas perceptible.  Vous pouvez également voir clairement le début du processus de synchronisation des données du référentiel avec un serveur distant, la vitesse est comparable à rsync standard et dépend des performances du sous-système de disque du serveur de stockage de sauvegarde.  L'inconvénient de l'approche est le stockage du référentiel local et, par conséquent, la duplication des données. </p><br><p>  Plus intéressante et pratique en pratique, la deuxième option consiste à exécuter zbackup immédiatement sur le serveur de stockage de sauvegarde. </p><br><p>  Tout d'abord, nous allons vérifier le fonctionnement sans utiliser de cryptage avec le compresseur lzma: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/wf/m4/g0/wfm4g0zjf3cktbvihsmmtbg-hcu.png"></a> </p><br><p>  Le temps d'exécution de chaque test: </p><br><div class="scrollable-table"><table><thead><tr><th>  Lancer 1 </th><th>  Lancer 2 </th><th>  Lancer 3 </th></tr></thead><tbody><tr><td>  39m45s </td><td>  40m20s </td><td>  40m3s </td></tr><tr><td>  7m36s </td><td>  8m3s </td><td>  7 min 48 s </td></tr><tr><td>  15m35s </td><td>  15 min 48 s </td><td>  15 min 38 s </td></tr></tbody></table></div><br><p>  Si vous activez le chiffrement en utilisant aes, les résultats sont assez proches: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mf/7p/yv/mf7pyvnly6bmjtxbno88mjtrtn4.png"></a> </p><br><p>  Temps de fonctionnement sur les mêmes données, avec cryptage: </p><br><div class="scrollable-table"><table><thead><tr><th>  Lancer 1 </th><th>  Lancer 2 </th><th>  Lancer 3 </th></tr></thead><tbody><tr><td>  43m40s </td><td>  44m12s </td><td>  44m3s </td></tr><tr><td>  8m3s </td><td>  8 min 15 s </td><td>  8 min 12 s </td></tr><tr><td>  15m0s </td><td>  15m40s </td><td>  15m25s </td></tr></tbody></table></div><br><p>  Si le cryptage est combiné avec la compression sur lzo, cela se passe comme suit: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/38/cz/tb/38cztb4tuzxtgsorc6uysied59k.png"></a> </p><br><p>  Temps de travail: </p><br><div class="scrollable-table"><table><thead><tr><th>  Lancer 1 </th><th>  Lancer 2 </th><th>  Lancer 3 </th></tr></thead><tbody><tr><td>  18m2 </td><td>  18 min 15 s </td><td>  18 min 12 s </td></tr><tr><td>  5 min 13 s </td><td>  5 min 24 s </td><td>  5m20s </td></tr><tr><td>  8 min 48 s </td><td>  9m3s </td><td>  8 min 51 s </td></tr></tbody></table></div></div></div><br><p>  La taille du référentiel résultant était relativement la même et s'élevait à 13 Go.  Cela signifie que la déduplication fonctionne correctement.  De plus, sur des données déjà compressées, l'utilisation de lzo donne un effet tangible, en termes de temps de fonctionnement total, zbackup se rapproche de la duplicité / duplicati, cependant, il est 2 à 5 fois plus lent que ceux basés sur librsync. </p><br><p>  Les avantages sont évidents: économiser de l'espace disque sur le serveur de stockage de sauvegarde.  Quant aux outils de vérification du référentiel - ils ne sont pas fournis par zbackup, il est recommandé d'utiliser une baie de disques à sécurité intégrée ou un fournisseur de cloud. </p><br><p>  En général, une très bonne impression, malgré le fait que le projet est en place depuis environ 3 ans (la dernière demande de fonctionnalité remonte à environ un an, mais sans réponse). </p><br><h3 id="testirovanie-borgbackup">  Test de borgbackup </h3><br><p>  Borgbackup est une fourche de grenier, un autre système de type zbackup.  Il est écrit en python, possède une liste de fonctionnalités similaires à zbackup, mais sait en outre comment: </p><br><ul><li>  Montez les sauvegardes via un fusible </li><li>  Vérifier le contenu du référentiel </li><li>  Travailler en mode client-serveur </li><li>  Utilisez divers compresseurs pour les données, ainsi que la définition heuristique du type de fichier lors de la compression. </li><li>  2 options de cryptage, aes et blake </li><li>  Outil intégré pour </li></ul><br><div class="spoiler">  <b class="spoiler_title">contrôles de performance</b> <div class="spoiler_text"><p>  borgbackup benchmark crud ssh: // backup_server / repo / path local_dir </p><br><p>  Les résultats sont les suivants: </p><br><p>  CZ-BIG 96,51 Mo / s (10 <em>fichiers 100,00 Mo à zéro: 10,36 s)</em> <em><br></em>  <em>RZ-BIG 57,22 Mo / s (10</em> fichiers 100,00 Mo tous à zéro: 17,48 s) <br>  UZ-BIG 253,63 Mo / s (10 <em>fichiers 100,00 Mo à zéro nul: 3,94 s)</em> <em><br></em>  <em>DZ-BIG 351,06 Mo / s (10</em> fichiers 100,00 Mo à zéro: 2,85 s) <br>  CR-BIG 34,30 Mo / s (10 <em>fichiers aléatoires 100,00 Mo: 29,15 s)</em> <em><br></em>  <em>RR-BIG 60,69 Mo / s (10</em> fichiers aléatoires 100,00 Mo: 16,48 s) <br>  UR-BIG 311,06 Mo / s (10 <em>fichiers aléatoires 100,00 Mo: 3,21 s)</em> <em><br></em>  <em>DR-BIG 72,63 Mo / s (10</em> fichiers aléatoires 100,00 Mo: 13,77 s) <br>  CZ-MEDIUM 108,59 Mo / s (1000 <em>fichiers à zéro de 1,00 Mo: 9,21 s)</em> <em><br></em>  <em>RZ-MEDIUM 76,16 Mo / s (1000</em> fichiers 1,00 Mo à zéro absolu: 13,13 s) <br>  UZ-MEDIUM 331,27 Mo / s (1000 <em>fichiers à zéro 1,00 Mo: 3,02 s)</em> <em><br></em>  <em>DZ-MEDIUM 387,36 Mo / s (1000</em> fichiers à zéro de 1,00 Mo: 2,58 s) <br>  CR-MEDIUM 37,80 Mo / s (1000 <em>fichiers aléatoires de 1,00 Mo: 26,45 s)</em> <em><br></em>  <em>RR-MEDIUM 68,90 Mo / s (1000</em> fichiers aléatoires de 1,00 Mo: 14,51 s) <br>  UR-MEDIUM 347,24 Mo / s (1000 <em>fichiers aléatoires de 1,00 Mo: 2,88 s)</em> <em><br></em>  <em>DR-MEDIUM 48,80 Mo / s (1000</em> fichiers aléatoires de 1,00 Mo: 20,49 s) <br>  CZ-SMALL 11,72 Mo / s (10000 <em>fichiers à zéro de 10</em> 000 <em>ko: 8,53 s)</em> <em><br></em>  <em>RZ-SMALL 32,57 Mo / s (10000</em> fichiers à zéro de 10 <em>000</em> ko: 3,07 s) <br>  UZ-SMALL 19,37 Mo / s (10000 <em>fichiers à zéro de 10</em> 000 <em>ko: 5,16 s)</em> <em><br></em>  <em>DZ-SMALL 33,71 Mo / s (10000</em> fichiers à zéro de 10 <em>000</em> ko: 2,97 s) <br>  CR-SMALL 6,85 Mo / s (10000 <em>fichiers aléatoires de 10</em> 000 <em>ko: 14,60 s)</em> <em><br></em>  <em>RR-SMALL 31,27 Mo / s (10000</em> fichiers aléatoires de 10 <em>000</em> ko: 3,20 s) <br>  UR-SMALL 12,28 Mo / s (10000 <em>fichiers aléatoires de 10</em> 000 <em>ko: 8,14 s)</em> <em><br></em>  <em>DR-SMALL 18,78 Mo / s (10000</em> fichiers aléatoires de 10 <em>000</em> Ko: 5,32 s) </p></div></div><br><p>  Lors des tests, l'heuristique sera utilisée en compression avec la définition du type de fichier (compression auto), et les résultats seront les suivants: </p><br><div class="spoiler">  <b class="spoiler_title">Tout d'abord, vérifiez l'opération sans chiffrement:</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/fe/ep/xm/feepxmsoyorprvvt5h00tuj2spg.png"></a> </p><br><p>  Temps de travail: </p><br><div class="scrollable-table"><table><thead><tr><th>  Lancer 1 </th><th>  Lancer 2 </th><th>  Lancer 3 </th></tr></thead><tbody><tr><td>  4m6s </td><td>  4 min 10 s </td><td>  4m5s </td></tr><tr><td>  56s </td><td>  58s </td><td>  54s </td></tr><tr><td>  1m26s </td><td>  1m34s </td><td>  1m30s </td></tr></tbody></table></div><br><p>  Si vous activez l'autorisation du référentiel (mode authentifié), les résultats seront proches: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/3c/qe/kx/3cqekxviy9rzhafckbi0tidjxn4.png"></a> </p><br><p>  Temps de travail: </p><br><div class="scrollable-table"><table><thead><tr><th>  Lancer 1 </th><th>  Lancer 2 </th><th>  Lancer 3 </th></tr></thead><tbody><tr><td>  4 min 11 s </td><td>  4m20s </td><td>  4 min 12 s </td></tr><tr><td>  1m0s </td><td>  1m3s </td><td>  1m2s </td></tr><tr><td>  1m30s </td><td>  1m34s </td><td>  1 min 31 s </td></tr></tbody></table></div><br><p>  Lorsque le cryptage aes a été activé, les résultats ne se sont pas beaucoup détériorés: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/oa/yz/zl/oayzzliqw8zixlppy_idv2l8gzm.png"></a> </p><br><div class="scrollable-table"><table><thead><tr><th>  Lancer 1 </th><th>  Lancer 2 </th><th>  Lancer 3 </th></tr></thead><tbody><tr><td>  4 min 55 s </td><td>  5m2 </td><td>  4 min 58 s </td></tr><tr><td>  1m0s </td><td>  1m2s </td><td>  1m0s </td></tr><tr><td>  1 min 49 s </td><td>  1m50s </td><td>  1m50s </td></tr></tbody></table></div><br><p>  Et si vous changez aes en blake, la situation s'améliorera complètement: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/df/kh/ay/dfkhayqoecs9hw_c_aj2fmxjkbu.png"></a> </p><br><p>  Temps de travail: </p><br><div class="scrollable-table"><table><thead><tr><th>  Lancer 1 </th><th>  Lancer 2 </th><th>  Lancer 3 </th></tr></thead><tbody><tr><td>  4 min 33 s </td><td>  4 min 43 s </td><td>  4 min 40 s </td></tr><tr><td>  59s </td><td>  1m0s </td><td>  1m0s </td></tr><tr><td>  1 min 38 s </td><td>  1 min 43 s </td><td>  1m40s </td></tr></tbody></table></div></div></div><br><p>  Comme dans le cas de zbackup, la taille du référentiel était de 13 Go et même légèrement moins, ce qui, en général, est attendu.  Le temps de travail était très heureux, il est comparable aux solutions basées sur librsync, offrant des possibilités beaucoup plus larges.  J'ai également été satisfait de la possibilité de définir divers paramètres via des variables d'environnement, ce qui donne un avantage très sérieux lors de l'utilisation de borgbackup en mode automatique.  Également satisfait de la charge lors de la sauvegarde: à en juger par la charge du processeur - borgbackup fonctionne sur 1 thread. </p><br><p>  Il n'y avait aucun inconvénient spécial lors de l'utilisation. </p><br><h3 id="testirovanie-restic">  Test de restic </h3><br><p>  Malgré le fait que le restic soit une solution assez nouvelle (les 2 premiers candidats sont connus depuis 2013 et plus), il présente de très bonnes caractéristiques.  Écrit en Go. </p><br><p>  Par rapport à zbackup, il donne en outre: </p><br><ul><li>  Vérification de l'intégrité du référentiel (y compris les pièces d'archivage). </li><li>  Une énorme liste de protocoles et de fournisseurs pris en charge pour le stockage des sauvegardes, ainsi que la prise en charge de rclone - rsync pour les solutions cloud. </li><li>  Comparaison de 2 sauvegardes entre elles. </li><li>  Montage du référentiel via un fusible. </li></ul><br><p>  En général, la liste des possibilités est assez proche de borgbackup, à certains endroits plus, à certains endroits moins.  Parmi les fonctionnalités - le manque de capacité à désactiver le cryptage, et donc les sauvegardes seront toujours cryptées.  Voyons en pratique ce que vous pouvez retirer de ce logiciel: </p><br><div class="spoiler">  <b class="spoiler_title">Les résultats sont les suivants:</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/tq/k5/xn/tqk5xn1xknn33dydmslqofrjfvs.png"></a> </p><br><p>  Temps de travail: </p><br><div class="scrollable-table"><table><thead><tr><th>  Lancer 1 </th><th>  Lancer 2 </th><th>  Lancer 3 </th></tr></thead><tbody><tr><td>  5 min 25 s </td><td>  5m50s </td><td>  5 min 38 s </td></tr><tr><td>  35s </td><td>  38s </td><td>  36s </td></tr><tr><td>  1m54s </td><td>  2m2 </td><td>  1 min 58 s </td></tr></tbody></table></div></div></div><br><p>  Les résultats sont également comparables aux solutions basées sur rsync et, en général, sont très proches de borgbackup, mais la charge du processeur est plus élevée (plusieurs threads fonctionnent) et en dents de scie. </p><br><p>  Très probablement, le programme dépend des performances du sous-système de disque sur le serveur de stockage, comme c'était le cas avec rsync.  La taille du référentiel était de 13 Go, tout comme zbackup ou borgbackup, il n'y avait aucun inconvénient évident lors de l'utilisation de cette solution. </p><br><h3 id="rezultaty">  Résultats </h3><br><p>  En fait, tous les candidats ont obtenu des indicateurs proches, mais à un prix différent.  Borgbackup s'est révélé être le meilleur, un peu plus lent - restique, zbackup, vous ne devriez probablement pas commencer à postuler, <br>  et s'il est déjà utilisé, essayez de passer à borgbackup ou restic. </p><br><h3 id="vyvody">  Conclusions </h3><br><p>  La solution la plus prometteuse est restée  c'est lui qui a le meilleur rapport capacités / vitesse, mais pour l'instant nous ne nous précipiterons pas vers des conclusions générales. </p><br><p>  Borgbackup, en principe, n'est pas pire, mais zbackup est probablement mieux à remplacer.  Cependant, pour garantir le fonctionnement de la règle 3-2-1, zbackup peut toujours être utilisé.  Par exemple, en plus des outils de sauvegarde basés sur (lib) rsync. </p><br><h3 id="anons">  Annonce </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sauvegarde, partie 1: Pourquoi avez-vous besoin d'une sauvegarde, un aperçu des méthodes, des technologies</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sauvegarde, Partie 2: Présentation et test des outils de sauvegarde basés sur rsync</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sauvegarde, Partie 3: Présentation et test de la duplicité, duplicati</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sauvegarde, Partie 4: Présentation et test de zbackup, restic, borgbackup</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sauvegarde, Partie 5: Test de Bacula et Veeam Backup pour Linux</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sauvegarde: pièce demandée par les lecteurs: revue AMANDA, UrBackup, BackupPC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sauvegarde, partie 6: comparaison des outils de sauvegarde</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sauvegarde, partie 7: Conclusions</a> </p><br><p>  <u>Publié par</u> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Finnix</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454734/">https://habr.com/ru/post/fr454734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454716/index.html">Les employés ne veulent pas de nouveaux logiciels - allez à l'occasion ou pliez leur ligne?</a></li>
<li><a href="../fr454720/index.html">Comment faire revivre la documentation?</a></li>
<li><a href="../fr454728/index.html">Accès Internet ouvert: la technologie LUWRAIN aide les utilisateurs aveugles</a></li>
<li><a href="../fr454730/index.html">Meetup Allure Server: enregistrements vidéo de rapports</a></li>
<li><a href="../fr454732/index.html">5 techniques de priorisation robustes pour les équipes informatiques</a></li>
<li><a href="../fr454736/index.html">Prise en charge de Visual Studio 2019 dans PVS-Studio</a></li>
<li><a href="../fr454738/index.html">Prise en charge de Visual Studio 2019 dans PVS-Studio</a></li>
<li><a href="../fr454740/index.html">Mai 2019 Joomla Digest</a></li>
<li><a href="../fr454742/index.html">Au moins une astuce Vim que vous ne connaissiez pas</a></li>
<li><a href="../fr454744/index.html">Présentation des rapports de suivi Java de la conférence RigaDevDays</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>