<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Æ üëáüèø üå≠ Stan Drapkin. Pi√®ges de cryptographie de haut niveau dans .NET üòä üë©üèª‚Äçüî¨ ü¶í</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stan Drapkin est un expert en s√©curit√© et conformit√© avec plus de 16 ans d'exp√©rience avec le .NET Framework (√† partir de .NET 1.0-beta en 2001). Malh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Stan Drapkin. Pi√®ges de cryptographie de haut niveau dans .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/428121/">  Stan Drapkin est un expert en s√©curit√© et conformit√© avec plus de 16 ans d'exp√©rience avec le .NET Framework (√† partir de .NET 1.0-beta en 2001).  Malheureusement, lui-m√™me n'√©crit pas d'articles en russe, nous avons donc convenu avec lui de publier une traduction de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">son rapport avec DotNext Piter</a> .  Ce rapport a <b>remport√© la premi√®re place</b> √† la conf√©rence! <br><br>  Cryptographie sym√©trique, asym√©trique, hybride, haut niveau, bas niveau, flux et cryptographie elliptique moderne.  Cinquante-six minutes de vid√©o sur la cryptographie, et beaucoup plus rapidement - sous forme de texte. <br><br><img src="https://habrastorage.org/webt/ye/8s/g0/ye8sg0kuwhgvtitnjxvwpehfnwc.png"><br><br>  Sous la coupe - vid√©os, diapositives et traduction.  Bonne lecture! <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZqGyV7Jshww" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Diapositives</a> <br><br>  Je m'appelle Stan Drapkin, je suis le directeur technique d'une entreprise sp√©cialis√©e dans la s√©curit√© de l'information et la conformit√© r√©glementaire.  De plus, je suis l'auteur de plusieurs biblioth√®ques open source, tr√®s bien accueillies par la communaut√©.  Combien ont entendu parler d' <i>Inferno</i> ?  Cette biblioth√®que illustre l'approche correcte de la cryptographie dans .NET, et <i>TinyORM</i> impl√©mente micro-ORM pour .NET.  De plus, j'ai √©crit plusieurs livres qui peuvent √™tre pertinents pour le sujet de l'article d'aujourd'hui.  L'un d'eux, l'√©dition 2014, est ¬´Security Driven .NET¬ª, l'autre de 2017 est ¬´Application Security in .NET, succinctement¬ª. <br><br>  Tout d'abord, nous parlerons de ce que j'appelle les quatre √©tapes de la crypto-illumination.  Ensuite, deux sujets principaux suivront, dans le premier, nous parlerons de la cryptographie sym√©trique, dans le second - asym√©trique et hybride.  Dans la premi√®re partie, nous comparons la cryptographie de haut niveau et de bas niveau et examinons un exemple de cryptographie en streaming.  Dans la deuxi√®me partie, nous aurons de nombreuses ¬´aventures¬ª avec RSA, apr√®s quoi nous nous familiariserons avec la cryptographie elliptique moderne. <br><br>  Alors, √† quoi ressemblent ces √©tapes de l'illumination cryptographique?  La premi√®re √©tape - "XOR est tellement cool, regarde, maman, comment puis-je!"  Beaucoup d'entre vous connaissent s√ªrement cette √©tape et connaissent les merveilles de la fonction XOR.  Mais j'esp√®re que la majeure partie de cette √©tape a progress√© et est pass√©e √† la suivante, √† savoir apprendre √† effectuer le chiffrement et le d√©chiffrement √† l'aide d'AES (Advanced Encryption Standard), un algorithme bien connu et tr√®s appr√©ci√©.  La plupart des d√©veloppeurs qui ne visitent pas DotNext en sont √† ce stade.  Mais, puisque vous suivez DotNext et que vous connaissez les rapports sur les dangers des API de bas niveau, vous √™tes tr√®s probablement √† l'√©tape suivante - ¬´J'ai tout fait (a) mal, je dois passer √† des API de haut niveau¬ª.  Eh bien, pour compl√©ter l'image, je mentionnerai √©galement la derni√®re √©tape - la compr√©hension qu'avec la meilleure solution au probl√®me, la cryptographie peut ne pas √™tre n√©cessaire du tout.  Cette √©tape est la plus difficile √† atteindre, et il y a peu de monde dessus.  Un exemple est Peter G. Neumann, qui a dit ce qui suit: ¬´Si vous pensez que la solution √† votre probl√®me r√©side dans la cryptographie, alors vous ne comprenez pas exactement quel est votre probl√®me. <br><br>  Le fait que la cryptographie de bas niveau soit dangereuse a √©t√© discut√© dans de nombreux rapports sur .NET.  Vous pouvez vous r√©f√©rer au rapport de Vladimir Kochetkov en 2015, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Pi√®ges de System.Security.Cryptography"</a> .  Son id√©e principale est qu'√† chaque √©tape du travail avec des API cryptographiques de bas niveau, sans le savoir, nous prenons de nombreuses d√©cisions, pour lesquelles nous n'avons tout simplement pas les connaissances appropri√©es.  La principale conclusion est que, id√©alement, la cryptographie de haut niveau devrait √™tre utilis√©e √† la place de la cryptographie de bas niveau.  C'est une merveilleuse conclusion, mais elle nous am√®ne √† un autre probl√®me - savons-nous exactement √† quoi devrait ressembler la cryptographie de haut niveau?  Parlons-en un peu. <br><br>  D√©finissez les attributs d'une API cryptographique <i>non de</i> haut niveau.  Pour commencer, une telle API ne donnera pas l'impression d'√™tre native de .NET; elle ressemblera plut√¥t √† un shell de bas niveau.  De plus, une telle API sera facile √† utiliser de mani√®re incorrecte, c'est-√†-dire  pas comme il se doit.  De plus, cela vous obligera √† g√©n√©rer de nombreuses choses √©tranges de bas niveau - nonce, vecteurs d'initialisation, etc.  Une telle API vous obligera √† prendre des d√©cisions d√©sagr√©ables auxquelles vous ne serez peut-√™tre pas pr√©par√© - choisissez des algorithmes, des modes de remplissage, des tailles de cl√©, des nonce, etc.  Il ne disposera pas non plus de l'API appropri√©e pour la diffusion en continu (API de diffusion en continu) - nous parlerons de l'aspect de cette derni√®re. <br><br>  En revanche, √† quoi devrait ressembler une API cryptographique de haut niveau?  Je pense qu'il doit tout d'abord √™tre intuitif et concis tant pour le lecteur du code que pour l'auteur.  De plus, une telle API devrait √™tre facile √† apprendre et √† utiliser, et elle devrait √™tre extr√™mement difficile √† appliquer de la mauvaise fa√ßon.  Il doit √©galement √™tre puissant, c'est-√†-dire qu'il doit nous permettre d'atteindre notre objectif avec un petit effort, une petite quantit√© de code.  Enfin, une telle API ne devrait pas avoir une longue liste de restrictions, mises en garde, cas particuliers, en g√©n√©ral - il devrait y avoir un minimum de choses √† retenir lors de l'utilisation avec elle, en d'autres termes - elle devrait √™tre caract√©ris√©e par un faible niveau d'interf√©rence (faible friction), devrait il suffit de travailler sans aucune r√©serve. <br><br>  Apr√®s avoir trait√© les exigences d'une API cryptographique de haut niveau pour .NET, comment pouvons-nous la trouver maintenant?  Vous pouvez essayer simplement google, mais ce serait trop primitif - nous sommes des d√©veloppeurs professionnels, et ce n'est pas notre m√©thode.  Par cons√©quent, nous √©tudions ce probl√®me et testons diverses alternatives.  Mais pour cela, nous devons d'abord nous cr√©er une id√©e correcte de ce qu'est le chiffrement authentifi√©, et pour cela, nous devons comprendre les concepts de base.  Ils sont les suivants: le texte en clair P (texte en clair), que nous convertissons en texte chiffr√© C (texte chiffr√©) de m√™me longueur en utilisant une cl√© secr√®te K (cl√©).  Comme vous pouvez le voir, jusqu'√† pr√©sent, nous travaillons avec un sch√©ma tr√®s simple.  De plus, nous avons √©galement une balise d'authentification T et nonce N. Un param√®tre important est NÃÖ, c'est-√†-dire la r√©utilisation de nonce avec une cl√©.  Comme beaucoup d'entre vous le savent probablement, cela conduit √† une violation de la confidentialit√© du texte, ce qui n'est √©videmment pas souhaitable.  Un autre concept important est l'AD (donn√©es associ√©es), c'est-√†-dire les donn√©es associ√©es.  Il s'agit de donn√©es facultatives authentifi√©es mais ne participant pas au chiffrement et au d√©chiffrement. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f9/41c/537/2f941c537ee2813920df009759b19e97.jpg"><br><br>  Apr√®s avoir compris les concepts de base, examinons les diff√©rentes options des biblioth√®ques cryptographiques pour .NET.  Commen√ßons par l'analyse de <i>Libsodium.NET.</i>  Combien d'entre vous la connaissent?  Comme je le vois, certains sont familiers. <br><br><pre><code class="cs hljs">nonce = SecretAeadAes.GenerateNonce(); c = SecretAeadAes.Encrypt(p, nonce, key, ad); d = SecretAeadAes.Decrypt(c, nonce, key, ad);</code> </pre> <br>  <i>Voici le</i> code C # avec lequel le chiffrement est effectu√© avec <i>Libsodium.NET</i> .  √Ä premi√®re vue, il est assez simple et concis: dans la premi√®re ligne, un nonce est g√©n√©r√©, qui est ensuite utilis√© dans la deuxi√®me ligne, o√π le chiffrement lui-m√™me a lieu, et dans la troisi√®me, o√π le texte est d√©chiffr√©.  Il semblait - quelles difficult√©s pouvait-il y avoir?  Pour commencer, Libsodium.NET propose non pas une, mais trois m√©thodes de chiffrement sym√©triques diff√©rentes: <br><br>  Fois <br><br><pre> <code class="cs hljs">nonce = SecretAeadAes.GenerateNonce(); c = SecretAeadAes.Encrypt(p, nonce, key, ad); d = SecretAeadAes.Decrypt(c, nonce, key, ad);</code> </pre><br>  Deux <br><br><pre> <code class="cs hljs">nonce = SecretAead.GenerateNonce(); c = SecretAead.Encrypt(p, nonce, key, ad); d = SecretAead.Decrypt(c, nonce, key. ad);</code> </pre><br>  Trois <br><br><pre> <code class="cs hljs">nonce = SecretBox.GenerateNonce(); c = SecretBox.Create(p, nonce, key); d = SecretBox.Open(c, nonce, key);</code> </pre><br>  De toute √©vidence, la question se pose - laquelle est la meilleure dans votre situation sp√©cifique?  Pour y r√©pondre, vous devez entrer dans ces m√©thodes, ce que nous allons faire maintenant. <br><br>  La premi√®re m√©thode, <code>SecretAeadAes</code> , utilise AES-GCM avec un nonce 96 bits.  Il est important qu'il ait une liste assez longue de restrictions.  Par exemple, lorsque vous l'utilisez, vous ne devez pas chiffrer plus de 550 gigaoctets avec une seule cl√©, et il ne doit pas y avoir plus de 64 gigaoctets dans un message avec un maximum de 2 <sup>32</sup> messages.  De plus, la biblioth√®que ne vous avertit pas de l'approche de ces restrictions, vous devez les suivre vous-m√™me, ce qui cr√©e une charge suppl√©mentaire pour vous en tant que d√©veloppeur. <br><br>  Seconde m√©thode, <code>SecretAead</code> utilise une autre suite de chiffrement, <code>ChaCha20/Poly1305</code> avec un nonce 64 bits significativement plus petit.  Un si petit nonce rend les collisions extr√™mement probables, et pour cette seule raison, vous ne devez pas utiliser cette m√©thode - sauf dans des cas assez rares et √† condition que vous soyez tr√®s bien vers√© dans le sujet. <br><br>  Enfin, la troisi√®me m√©thode, <code>SecretBox</code> .  Il convient de noter imm√©diatement qu'il n'y a pas de donn√©es associ√©es dans les arguments de cette API.  Si vous avez besoin d'un chiffrement authentifi√© avec AD, cette m√©thode ne vous convient pas.  L'algorithme de chiffrement utilis√© ici est appel√© <code>xSalsa20/Poly1305</code> , nonce est assez grand - 192 bits.  Cependant, le manque de DA est une limitation importante. <br><br>  Lors de l'utilisation de <i>Libsodium.NET</i> , certaines questions se posent.  Par exemple, que devons-nous faire exactement avec le nonce g√©n√©r√© par la premi√®re ligne de code dans les exemples ci-dessus?  La biblioth√®que ne nous dit rien √† ce sujet, nous devons le d√©couvrir par nous-m√™mes.  Tr√®s probablement, nous ajouterons manuellement ce nonce au d√©but ou √† la fin du texte chiffr√©.  De plus, nous pourrions avoir l'impression que la DA dans les deux premi√®res m√©thodes peut √™tre de n'importe quelle longueur.  Mais en fait, la biblioth√®que prend en charge AD pas plus de 16 octets de long - apr√®s tout, 16 octets suffiront √† tout le monde, non?  Continuons.  Que se passe-t-il avec les erreurs de d√©cryptage?  Dans cette biblioth√®que, il a √©t√© d√©cid√© dans ces cas de lever des exceptions.  Si, dans votre environnement, l'int√©grit√© des donn√©es de d√©chiffrement peut √™tre viol√©e, vous aurez de nombreuses exceptions qui devront √™tre g√©r√©es.  Que faire si la taille de votre cl√© n'est pas exactement de 32 octets?  La biblioth√®que ne nous en dit rien, ce sont vos probl√®mes qui ne l'int√©ressent pas.  Un autre sujet important est la r√©utilisation des tableaux d'octets afin de r√©duire la charge sur le garbage collector dans les sc√©narios intensifs.  Par exemple, dans le code, nous avons vu un tableau que le g√©n√©rateur de nonce nous a retourn√©.  Je ne voudrais pas cr√©er un nouveau tampon √† chaque fois, mais r√©utiliser celui existant.  Ce n'est pas possible dans cette biblioth√®que, un tableau d'octets sera r√©g√©n√©r√© √† chaque fois. <br><br>  En utilisant le sch√©ma que nous avons d√©j√† vu, nous allons essayer de comparer diff√©rents algorithmes <i>Libsodium.NET</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3c/6e3/d3c/b3c6e3d3ce4ef29723e2ac691c3fd4d4.jpg"><br><br>  Le premier algorithme, AES-GCM, utilise nonce 96 bits de long (colonne jaune dans l'image).  Il est inf√©rieur √† 128 bits, ce qui cr√©e un certain inconfort, mais pas trop important.  La colonne suivante est bleue, c'est la place occup√©e par la balise d'authentification, avec AES-GCM c'est 16 octets ou 128 bits.  Le deuxi√®me chiffre bleu, entre parenth√®ses, signifie la quantit√© d'entropie, ou al√©atoire, contenue dans cette balise - moins de 128 bits.  Combien moins - dans cet algorithme d√©pend de la quantit√© de donn√©es crypt√©es.  Plus il est crypt√©, plus le tag est faible.  Cela seul devrait donner lieu √† des doutes sur cet algorithme, qui ne fera qu'augmenter si nous regardons la colonne blanche.  Il indique que les r√©p√©titions (collisions) de nonce entra√Æneront la falsification de tous les textes chiffr√©s cr√©√©s par la m√™me cl√©.  Si, par exemple, 100 de vos textes chiffr√©s cr√©√©s par une cl√© commune sur deux, il y a une collision nonce, ce nonce entra√Ænera une fuite interne de la cl√© d'authentification et permettra √† un attaquant de truquer tout autre texte chiffr√© cr√©√© par cette cl√©.  Il s'agit d'une limitation tr√®s importante. <br><br>  Passons √† la deuxi√®me m√©thode <i>Libsodium.NET</i> .  Comme je l'ai dit, ici pour nonce, trop peu d'espace est utilis√©, seulement 64 bits.  La balise occupe 128 bits, mais ne contient que 106 bits d'entropie ou moins, en d'autres termes, nettement inf√©rieur au niveau de s√©curit√© de 128 bits, ce qu'ils tentent dans la plupart des cas d'atteindre.  Quant √† la contrefa√ßon, la situation ici est l√©g√®rement meilleure que dans le cas de l'AES-GCM.  La collision de nonce conduit √† la falsification de textes chiffr√©s, mais uniquement pour les blocs dans lesquels des collisions se sont produites.  Dans l'exemple pr√©c√©dent, nous aurions forg√© 2 textes chiffr√©s, pas 100. <br><br>  Enfin, dans le cas de l'algorithme xSalsa / Poly, nous avons un tr√®s grand nonce de 192 bits, ce qui rend les collisions extr√™mement improbables.  La m√©thode d'authentification est la m√™me que dans la m√©thode pr√©c√©dente, donc l'√©tiquette prend √† nouveau 128 bits et a 106 bits d'entropie ou moins. <br><br>  Comparez tous ces chiffres avec les indicateurs correspondants de la biblioth√®que <i>Inferno</i> .  Dans ce document, le nonce occupe un espace colossal, 320 bits, ce qui rend les collisions presque impossibles.  Quant √† la balise, tout est simple avec elle: elle occupe exactement 128 bits et poss√®de exactement 128 bits d'entropie, rien de moins.  Ceci est un exemple d'une approche fiable et s√ªre. <br><br>  Avant de <i>d√©couvrir Libsodium.NET</i> plus en d√©tail, nous devons comprendre son objectif - malheureusement, tous ceux qui utilisent cette biblioth√®que ne le savent pas.  Pour ce faire, reportez-vous √† sa documentation, qui indique que <i>Libsodium.NET</i> est un wrapper C # pour <i>libsodium</i> .  Il s'agit d'un autre projet open source, dont la documentation indique qu'il s'agit d'un fork de <i>NaCl</i> avec une API compatible.  Eh bien, tournons-nous vers la documentation de <i>NaCl</i> , un autre projet open source.  Dans ce document, comme un objectif, <i>NaCl est</i> postul√© pour fournir toutes les op√©rations n√©cessaires √† la cr√©ation d'outils cryptographiques de haut niveau.  C'est ici que le chien est enterr√©: la t√¢che de <i>NaCl</i> et de tous ses obus est de fournir des √©l√©ments de bas niveau, √† partir desquels quelqu'un d'autre peut d√©j√† assembler des API cryptographiques de haut niveau.  Ces shells eux-m√™mes en tant que biblioth√®ques de haut niveau n'ont pas √©t√© con√ßus.  D'o√π la morale: si vous avez besoin d'une API cryptographique de haut niveau, vous devez trouver une biblioth√®que de haut niveau, ne pas utiliser un wrapper de bas niveau et pr√©tendre que vous travaillez avec une de haut niveau. <br><br>  Voyons comment fonctionne le cryptage dans <i>Inferno</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/64f/367/fe7/64f367fe769bce5d8fa0482f8a301648.jpg"><br><br>  Voici un exemple de code dans lequel, comme dans le cas de <i>Libsodium</i> , chaque chiffrement et d√©chiffrement ne prend qu'une seule ligne.  Les arguments sont la cl√©, le texte et les donn√©es associ√©es facultatives.  Il convient de noter qu'il n'y a pas de nonce, il n'est pas n√©cessaire de prendre de d√©cision, en cas d'erreur de d√©cryptage, il renvoie simplement null, sans lever d'exceptions.  √âtant donn√© que la cr√©ation d'exceptions augmente consid√©rablement la charge du garbage collector, leur absence est tr√®s importante pour les scripts qui traitent des flux de donn√©es volumineux.  J'esp√®re avoir r√©ussi √† vous convaincre que cette approche est optimale. <br><br>  Par int√©r√™t, essayons de crypter une cha√Æne.  Cela devrait √™tre le sc√©nario le plus simple que tout le monde puisse impl√©menter.  Supposons que nous ayons seulement deux valeurs de cha√Æne diff√©rentes possibles: "LEFT" et "RIGHT". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/88b/522/92b/88b52292b7ce52dc2a90302cbbbe1f36.jpg"><br><br>  Dans l'image, vous voyez le cryptage de ces lignes √† l'aide d' <i>Inferno</i> (bien que pour cet exemple, peu importe la biblioth√®que utilis√©e).  Nous chiffrons deux lignes avec une cl√© et obtenons deux textes chiffr√©s, <code>c1</code> et <code>c2</code> .  Tout dans ce code est-il correct?  Est-il pr√™t pour la production?  Quelqu'un peut dire que le probl√®me est possible de mani√®re courte, mais il est loin d'√™tre le principal, nous supposerons donc que la cl√© est utilis√©e de la m√™me mani√®re et qu'elle est de longueur suffisante.  Je veux dire autre chose: avec les approches cryptographiques conventionnelles, <code>c1</code> dans notre exemple sera plus court que <code>c2</code> .  C'est ce qu'on appelle la fuite de longueur - <code>c2</code> dans de nombreux cas sera un octet de plus que <code>c1</code> .  Cela peut permettre √† un attaquant de comprendre quelle cha√Æne est repr√©sent√©e par ce texte chiffr√©, "LEFT" ou "RIGHT".  La fa√ßon la plus simple de r√©soudre ce probl√®me est de faire en sorte que les deux lignes aient la m√™me longueur - par exemple, ajoutez un caract√®re √† la fin de la ligne ¬´GAUCHE¬ª. <br><br>  √Ä premi√®re vue, la fuite de longueur est per√ßue comme un probl√®me quelque peu farfelu qui ne peut pas √™tre rencontr√© dans des applications r√©elles.  Mais en janvier 2018, un article a √©t√© publi√© dans le magazine Wired avec une √©tude men√©e par la soci√©t√© isra√©lienne Checkmarx, sous le titre ¬´Le manque de cryptage dans Tinder permet aux √©trangers de suivre quand vous faites glisser l'√©cran¬ª.  Je vais bri√®vement raconter le contenu, mais d'abord une description approximative de la fonctionnalit√© Tinder.  Tinder est une application qui re√ßoit un flux de photos, puis l'utilisateur fait glisser l'√©cran vers la droite ou la gauche, selon qu'il aime ou non la photo.  Les chercheurs ont d√©couvert que bien que les commandes elles-m√™mes soient correctement crypt√©es √† l'aide de TLS et HTTPS, les donn√©es de la commande de droite prenaient un nombre d'octets diff√©rent de celui des donn√©es de gauche.  Il s'agit, bien s√ªr, d'une vuln√©rabilit√©, mais en soi, elle n'est pas trop importante.  Plus important pour Tinder √©tait le fait qu'ils ont envoy√© les flux avec des photos via HTTP standard, sans aucun cryptage.  Ainsi, l'attaquant pourrait acc√©der non seulement aux r√©actions des utilisateurs aux photos, mais √©galement aux photos elles-m√™mes.  Donc, comme vous pouvez le voir, la fuite de longueur est un probl√®me tr√®s r√©el. <br><br>  Essayons maintenant de crypter le fichier.  Je dois imm√©diatement dire que dans le cryptage de fichiers <i>Libsodium.NET</i> ou, plus g√©n√©ralement, le cryptage de flux n'est pas impl√©ment√© par d√©faut, il doit y √™tre fait manuellement - ce qui, croyez-moi, est tr√®s difficile √† faire correctement.  Dans <i>Inferno</i> , les choses vont beaucoup mieux avec √ßa. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f0/446/955/5f0446955f52e679e6dbeaacee2389b4.jpg"><br><br>  Ci-dessus, vous voyez un exemple pris avec pratiquement aucun changement de MSDN.  C'est tr√®s simple, nous voyons ici un flux pour le fichier source et un autre pour le fichier de destination, ainsi qu'un flux cryptographique qui convertit le premier en second.  Dans ce code, <i>Inferno n'est</i> utilis√© que sur une seule ligne - dans celle o√π la conversion a lieu.  Ainsi, nous avons devant nous une solution simple et en m√™me temps enti√®rement fonctionnelle et test√©e pour le chiffrement de flux. <br><br>  Il faut se rappeler que lors du cryptage avec la m√™me cl√©, nous avons une limite sur le nombre de messages.  Ils existent dans <i>Inferno</i> , et dans cette biblioth√®que, ils sont clairement √©crits √† l'√©cran.  Mais en m√™me temps, ils sont si grands dans <i>Inferno</i> qu'en pratique, vous ne les atteindrez jamais.  Dans <i>Libsodium.NET, les</i> restrictions sont diff√©rentes pour diff√©rents algorithmes, mais dans tous les cas, elles sont suffisamment faibles pour √™tre d√©pass√©es.  Vous devez donc v√©rifier s'ils seront atteints dans chaque sc√©nario individuel. <br><br>  Nous devrions √©galement parler de l'authentification des donn√©es associ√©es, car c'est un sujet qui n'est pas souvent trait√©.  Les AD peuvent √™tre ¬´faibles¬ª: cela signifie qu'ils sont authentifi√©s, mais ils ne sont pas impliqu√©s dans le processus de cryptage et de d√©cryptage.  En revanche, les DA ¬´forts¬ª modifient ce processus lui-m√™me.  La plupart des biblioth√®ques AD que je connais sont faibles, tandis que <i>Inferno</i> utilise la deuxi√®me approche, o√π les AD sont utilis√©es dans le processus de cryptage / d√©cryptage lui-m√™me ... <br><br>  Il devrait √©galement s'attarder sur le niveau de s√©curit√© √† atteindre pour la cryptographie de haut niveau.  En bref, ma r√©ponse est: un cryptage 256 bits avec une balise d'authentification 128 bits.  Pourquoi une cl√© est-elle si grosse?  Il y a plusieurs raisons √† cela, chacune √©tant importante en soi, mais maintenant je voudrais que vous vous souveniez d'une chose: nous devons nous prot√©ger contre les biais possibles lors de la g√©n√©ration de cl√©s cryptographiques.  Permettez-moi d'expliquer ce que l'on entend par biais.  Pour un g√©n√©rateur de bits al√©atoires sans biais, pour chaque bit, les probabilit√©s d'accepter la valeur 0 ou 1 sont √©gales.  Mais supposons que dans notre g√©n√©rateur, le bit prendra la valeur 1 avec une probabilit√© de 56%, et non 50%.  √Ä premi√®re vue, ce biais est faible, mais en fait il est significatif: 25%.  Essayons maintenant de calculer la quantit√© d'entropie que nous obtenons lors de la g√©n√©ration d'un certain nombre de bits avec notre g√©n√©rateur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3eb/f2e/df8/3ebf2edf8c049579b2e4218f9dff16b8.jpg"><br><br>  Dans l'image, vous voyez la formule par laquelle ce calcul sera effectu√©.  Il est important qu'il ne contienne que deux variables: le biais dont nous avons d√©j√† parl√© (biais) et le nombre de bits cr√©√©s par le g√©n√©rateur.  Nous supposons que le biais est de 25% - c'est un cas assez extr√™me, dans la pratique, vous ne travaillerez probablement pas dans des syst√®mes avec un tel g√©n√©rateur de nombres al√©atoires d√©form√©.  Quoi qu'il en soit, avec un biais de 25% et une cl√© de 128 bits, nous n'obtenons que 53 bits d'entropie.  Premi√®rement, il est nettement inf√©rieur √† 128 bits, ce qui est g√©n√©ralement attendu d'un g√©n√©rateur de nombres al√©atoires, et deuxi√®mement, avec les technologies modernes, une telle cl√© peut simplement √™tre une force brute.  Mais si au lieu de la cl√© 128 bits, nous utilisons 256 bits, alors nous obtenons 106 bits d'entropie.  C'est d√©j√† assez bon, bien que inf√©rieur aux 256. Les technologies modernes rendent presque impossible de casser une telle cl√©. <br><br>  √Ä la fin de la premi√®re partie du rapport, je r√©sumerai les r√©sultats interm√©diaires.  Je recommande √† tout le monde d'utiliser des API cryptographiques bien √©crites.  Trouvez celle qui vous convient ou envoyez une p√©tition √† Microsoft pour vous √©crire.  De plus, lorsque vous choisissez une API, vous devez faire attention √† la disponibilit√© de la prise en charge pour travailler avec les threads.  Pour les raisons d√©j√† expliqu√©es, la longueur de cl√© minimale doit √™tre de 256 bits.  Enfin, il convient de garder √† l'esprit que la cryptographie de haut niveau, comme toute autre, n'est pas id√©ale.  Des fuites peuvent se produire et, dans la plupart des sc√©narios, leurs capacit√©s doivent √™tre gard√©es √† l'esprit. <br><br>  Parlons de la cryptographie asym√©trique ou hybride.  Je vais poser une question pi√®ge: pouvez-vous utiliser RSA dans .NET?  Ne vous pr√©cipitez pas pour r√©pondre par l'affirmative, comme beaucoup le font - testons d'abord vos connaissances dans ce domaine.  Les diapositives suivantes seront sp√©cialement con√ßues pour les personnes qui connaissent d√©j√† ce sujet.  Mais d'abord, regardons Wikip√©dia et rappelons-nous ce qu'est exactement RSA au cas o√π quelqu'un aurait oubli√© ou n'aurait pas utilis√© cet algorithme depuis longtemps. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fec/e71/6ba/fece716ba7a00668b4d955c37745e744.png"><br><br>  Supposons qu'il y ait une Alice qui, √† l'aide d'un g√©n√©rateur de nombres al√©atoires, cr√©e une paire de cl√©s qui comprend un priv√© et un public.  Ensuite, il y a un Bob qui veut crypter un message pour Alice: "Bonjour Alice!"  √Ä l'aide de sa cl√© publique, il g√©n√®re un texte chiffr√©, qu'il lui envoie ensuite.  Elle d√©crypte ce texte chiffr√© √† l'aide de la partie priv√©e de sa cl√©. <br><br>  Essayons de reproduire ce sc√©nario dans la pratique. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/35d/021/627/35d021627d87f316a65b87bc4662aa05.jpg"><br><br>  Comme vous pouvez le voir ci-dessus, nous cr√©ons une instance de RSA et chiffrons du texte.  Faites imm√©diatement attention √† ce que .NET nous oblige √† choisir le mode de remplissage.  Il y en a cinq, tous avec des noms obscurs.  Si nous les essayons tous √† tour de r√¥le, nous d√©couvrirons que les trois derniers l√®vent simplement une exception et ne fonctionnent pas.  Nous utiliserons l'un des deux autres - <code>OaepSHA1</code> .  Ici, la cl√© sera de 1 kilobit, ce qui est trop petit pour RSA, c'est pratiquement une cl√© pirat√©e.  Par cons√©quent, nous devons d√©finir la taille de la cl√© manuellement.  La documentation nous apprend qu'il existe une propri√©t√© sp√©ciale <code>.KeySize</code> , qui re√ßoit ou d√©finit la taille de la cl√©. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0e/e77/a12/e0ee77a12bcd866142463ee8440c9b28.jpg"><br><br>  √Ä premi√®re vue, c'est exactement ce dont nous avons besoin, nous √©crivons donc: <code>rsa.KeySize = 3072</code> .  Mais si, guid√© par de vagues soup√ßons, apr√®s cela, nous v√©rifions √† quel point la taille de la cl√© est maintenant √©gale, alors nous d√©couvrirons qu'il faut toujours 1 kilobit.  Peu importe, nous v√©rifierons ce param√®tre √† l'aide de la <code>WriteLine(rsa.KeySize)</code> ou <code>rsa.ExportParameters(false).Modulus.Length * 8</code> - dans ce dernier cas, le composant public de la cl√© RSA est export√©, pour cela nous avons besoin de l'argument "false".  Le module de cette cl√© est un tableau, que nous multiplions par 8 et obtenons la taille en bits - qui sera encore 1 kilobit.  Comme vous pouvez le voir, cet algorithme est encore trop t√¥t pour √™tre envoy√© en production. <br><br>  Nous ne perdrons pas de temps √† comprendre pourquoi cette API ne fonctionne pas; essayez plut√¥t une autre impl√©mentation RSA fournie par Microsoft dans .NET 4.6, c'est-√†-dire compl√®tement nouvelle.  Il s'appelle <i>RSACng</i> et <i>Cng</i> signifie Cryptography next generation.  G√©nial, qui ne veut pas travailler avec des outils de nouvelle g√©n√©ration?  Nous trouverons s√ªrement ici une solution magique √† tous nos probl√®mes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ed/1af/3fb/7ed1af3fbcd93422ff6648e2af791264.jpg"><br><br>  Nous demandons une instance de RSACng, d√©finissons √† nouveau la taille de la cl√© √† 3 kilobits, v√©rifions √† nouveau la taille de la cl√© via <code>WriteLine(rsa.KeySize)</code> - et d√©couvrons √† nouveau que la taille de la cl√© est toujours √©gale √† un kilobit.  De plus, si nous demandons le type de l'objet qui a g√©n√©r√© la cl√© - comme nous nous en souvenons, nous avons demand√© une instance de RSACng - nous d√©couvrons qu'il s'agit de RSACryptoServiceProvider.  Je veux juste partager mon sentiment personnel de d√©sespoir ici et crier: "Pourquoi, Microsoft?!" <br><br>  Apr√®s des tourments et des tourments prolong√©s, nous d√©couvrons qu'en fait, vous devez utiliser le concepteur, pas l'usine. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c20/5e7/be1/c205e7be1603914e310bfb703f25e157.jpg"><br><br>  Ici, la valeur de taille de cl√© par d√©faut est de 2048 bits, ce qui est d√©j√† beaucoup mieux.  Quoi de mieux - ici, nous arrivons enfin √† d√©finir la taille de la cl√© √† 3 kilobits.  Comme on dit, le succ√®s est d√©bloqu√©. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permettez-moi de vous rappeler que jusqu'√† pr√©sent, tous nos efforts ont √©t√© r√©duits √† la cr√©ation de RSA, nous n'avons m√™me pas encore commenc√© le chiffrement. Il y a encore des questions auxquelles nous devons d'abord r√©pondre. Pour commencer, dans quelle mesure pouvez-vous vous fier aux tailles de cl√©s par d√©faut? L'impl√©mentation de la fabrique RSA peut √™tre remplac√©e </font></font><code>machine.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, par cons√©quent, elle peut changer √† votre insu (par exemple, un administrateur syst√®me peut la modifier). Et cela signifie que la taille de cl√© par d√©faut peut √©galement changer. Ainsi, vous ne devez jamais faire confiance aux valeurs fournies par d√©faut, la taille de la cl√© doit toujours √™tre d√©finie ind√©pendamment. Ensuite, quelle est la taille des cl√©s RSA par d√©faut? Il existe deux impl√©mentations RSA dans .NET, l'une bas√©e </font></font><code>RSACryptoServiceProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, l'autre bas√©e</font></font><code>RSACng</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dans le premier, la taille par d√©faut est de 1 kilobits, dans les deux autres. Pour le plaisir, comparons ces valeurs avec celles du r√©seau Bitcoin (BCN). Je m'excuse √† l'avance d'avoir soulev√© un sujet sensible, mais nous ne discuterons pas du Bitcoin ou de la crypto-monnaie, nous ne parlerons que du r√©seau lui-m√™me. Elle a un hashrate publi√©, qui augmente chaque mois et √©quivaut aujourd'hui √† 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hachages par seconde. Cela √©quivaut √† 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">90</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hachages par an. Pour simplifier, supposons qu'un hachage √©quivaut √† une op√©ration de base - bien que ce ne soit pas enti√®rement vrai, il est plus complexe. Si vous lisez des livres sur la cryptographie √©crits par de vrais professionnels, et pas des gens comme moi, alors vous savez que 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> op√©rations (c'est-√†-dire une minute de BCN) suffisent pour casser une cl√© RSA de 1 kilobit, et 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">90</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(un an BCN) - pour casser une cl√© de 2 kilobits. Ces deux valeurs devraient nous inqui√©ter - c'est ce qui peut √™tre r√©alis√© avec les technologies existantes. C'est pourquoi je vous recommande fortement de toujours d√©finir la taille de la cl√© vous-m√™me, et de lui faire au moins 3 kilobits, et si les performances vous le permettent, alors 4. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans .NET, il n'est pas si facile de comprendre comment exporter les cl√©s publiques et priv√©es. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ea/836/078/4ea8360788f3ffdbb6a07dfe9c0587e0.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En haut de la diapositive, vous voyez deux instances de la cl√© RSA, la premi√®re de </font></font><code>RSACryptoServiceProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la seconde de</font></font><code>RSACng</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chacun 4 kilobits. Le code ci-dessous est utilis√© pour extraire les cl√©s publiques et priv√©es des deux instances. Il convient de noter que les deux API sont assez diff√©rentes l'une de l'autre - code diff√©rent, m√©thodes diff√©rentes, param√®tres diff√©rents. De plus, si nous comparons les tailles des cl√©s publiques des premier et deuxi√®me exemplaires, nous verrons qu'elles sont comparables, environ un demi-kilo-octet chacune. Mais la cl√© priv√©e de la nouvelle impl√©mentation RSA est beaucoup plus petite que l'ancienne. Il est n√©cessaire de garder cela √† l'esprit et d'observer l'uniformit√©, afin de ne pas interf√©rer avec ces deux API. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout ce que nous avons fait avec RSA jusqu'√† pr√©sent se r√©sume √† essayer d'obtenir une copie de travail; Essayez maintenant de crypter quelque chose. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c88/fb5/c3c/c88fb5c3ca4ee8a62b9b0bd2595291cf.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez un tableau d'octets, qui sera notre texte en clair (</font></font><code>data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), puis nous allons le crypter en utilisant l'un de ces modes d'addition qui n'a pas g√©n√©r√© d'exception. Mais cette fois, nous avons une exception. Il s'agit d'une exception √† un param√®tre non valide; mais de quel param√®tre parlons-nous? Je n'en ai aucune id√©e - et Microsoft, tr√®s probablement aussi. Si nous essayons d'ex√©cuter la m√™me m√©thode avec d'autres modes de suppl√©ment, alors dans chaque cas, nous obtenons la m√™me exception. Le point n'est donc pas en mode suppl√©ment. Le probl√®me vient donc du code source lui-m√™me. Il est difficile de dire ce qui ne va pas chez lui, alors essayons de le couper en deux au cas o√π. Cette fois, le chiffrement est r√©ussi. Nous sommes perplexes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peut-√™tre que le fait est que nous avons utilis√© le suppl√©ment SHA-1? Comme nous le savons, SHA-1 n'est plus une fonction cryptographiquement solide, donc nos auditeurs et le service de la conformit√© insistent pour que nous nous en d√©barrassions. Remplacer </font></font><code>OaepSHA1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par </font></font><code>OaepSHA256</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, au moins cela rassurera les auditeurs. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/29e/7ed/275/29e7ed275ae1eb8deea59683289b5b6b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais lorsque nous essayons de chiffrer, nous obtenons √† nouveau l'exception du mauvais param√®tre. Toute cette situation est due au fait que la restriction de la taille du texte qui peut √™tre transf√©r√© √† la fonction cryptographique d√©pend non seulement du mode de suppl√©ment, mais √©galement de la taille de la cl√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essayons de savoir exactement √† quoi ressemble cette formule magique, qui d√©termine la quantit√© maximale de donn√©es chiffr√©es. √áa doit √™tre dans la m√©thode</font></font><code>int GetMaxDataSizeForEnc(RSAEncryptionPadding pad)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui calcule ce volume, apr√®s avoir re√ßu le mode suppl√©ment √† l'entr√©e. Le principal inconv√©nient de cette m√©thode est qu'elle n'existe pas, je l'ai invent√©e. J'essaie de transmettre l'id√©e que m√™me les informations les plus √©l√©mentaires dont un d√©veloppeur a besoin pour utiliser correctement RSA ne nous sont pas disponibles. Merci, Microsoft.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici les raisons pour lesquelles le RSA doit √™tre √©vit√©, m√™me pour la signature. Comme j'esp√®re avoir r√©ussi √† le montrer, les API pour RSA dans .NET sont extr√™mement insatisfaisantes. Vous √™tes oblig√© de prendre de nombreuses d√©cisions concernant le mode de suppl√©ment, la taille des donn√©es et autres, ce qui n'est pas souhaitable. De plus, pour un niveau de s√©curit√© de 128 bits, vous aurez besoin d'au moins une cl√© tr√®s volumineuse de 4 kilo-octets. Il vous donnera une cl√© priv√©e de 1 kilo-octet, une cl√© publique d'un demi-kilo-octet et une signature d'un demi-kilo-octet. Pour de nombreux sc√©narios, ces valeurs peuvent ne pas √™tre souhaitables. Et si vous essayez d'atteindre un niveau de s√©curit√© de 256 bits, vous aurez besoin d'une √©norme cl√© - 15360 bits. Dans RSA, l'utilisation d'une telle cl√© est presque impossible. Sur mon ordinateur portable, une telle cl√© est g√©n√©r√©e une minute et demie.En plus de cela, le RSA √† un niveau fondamental, en tant qu'algorithme, impl√©mente tr√®s lentement une signature, quelle que soit sa mise en ≈ìuvre. Pourquoi la vitesse de signature est-elle importante pour nous? Si vous utilisez TLS avec des certificats RSA, la signature est effectu√©e sur le serveur. Et nous, en tant que d√©veloppeurs, sommes les plus affect√©s par ce qui se passe exactement sur le serveur, nous en sommes responsables, son d√©bit est important pour nous. En r√©sum√©, je veux recommander encore une fois de ne pas utiliser RSA.Je veux recommander √† nouveau de ne pas utiliser RSA.Je veux recommander √† nouveau de ne pas utiliser RSA.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, que peut remplacer le RSA? Je voudrais vous pr√©senter les primitives cryptographiques elliptiques modernes. Tout d'abord, vous devez garder √† l'esprit l'ECDSA (Digital Signature Algorithm), qui peut √™tre utilis√© √† la place de RSA pour les signatures. Dans cette abr√©viation et dans les suivantes, EC est un pr√©fixe commun qui signifie Elliptic-Curve (¬´elliptical¬ª). Sur securitydriven.net/inferno/#DSA Signatures, vous pouvez trouver un exemple de code ECDSA, qui, soit dit en passant, est natif de .NET. Un autre algorithme important est ECIES (Integrated Encryption Scheme, ¬´sch√©ma de cryptage int√©gr√© elliptique¬ª). Cet algorithme peut effectuer un cryptage hybride au lieu de RSA, c'est-√†-dire que vous g√©n√©rez une cl√© sym√©trique, cryptez les donn√©es avec, puis cryptez la cl√© elle-m√™me.Un exemple de code est disponible sur l'exemple securitydriven.net/inferno/#ECIES. Enfin, un autre algorithme tr√®s important est l'ECDH (√©change de cl√©s Diffie-Hellman, ¬´√©change de cl√©s Diffie-Hellman¬ª). Il vous permet de cr√©er des cl√©s de chiffrement sym√©trique entre deux parties avec des cl√©s publiques connues. Dans certaines situations et m√©thodes d'utilisation, il permet le secret direct (</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transmettre le secret</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Le lien </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">securitydriven.net/inferno/#DHM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cl√© le code d'√©chantillon disponible Exchange.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour r√©sumer la conversation sur le chiffrement asym√©trique. Vous devez toujours utiliser des API de haut niveau qui ne vous obligent pas √† prendre des d√©cisions auxquelles vous n'√™tes pas pr√™t. Je recommanderais √©galement d'arr√™ter d'utiliser RSA. Bien s√ªr, cela est plus facile √† dire qu'√† faire, car nous travaillons tous avec de grandes applications d√©j√† cr√©√©es, qui peuvent ne pas √™tre enti√®rement refactoris√©es. Dans ce cas, vous devez au moins apprendre √† utiliser correctement RSA. De plus, je vous conseille de vous familiariser avec les algorithmes cryptographiques elliptiques modernes (ECDSA, ECDH, ECIES). Enfin, il est important que la cryptographie de haut niveau ne r√©sout pas comme par magie tous les probl√®mes, vous devez donc vous rappeler les objectifs que vous poursuivez. Je citerai StackOverflow, avec lequel je suis enti√®rement d'accord: ¬´La cryptographie seule ne r√©sout pas les probl√®mes.Le chiffrement sym√©trique ne fait que de la confidentialit√© des donn√©es un probl√®me de gestion des cl√©s. ¬ª</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je vais dire quelques mots sur les ressources qui peuvent vous √™tre utiles. Il existe une biblioth√®que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SecurityDriven.Inferno de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> haut niveau relativement acceptable </font><font style="vertical-align: inherit;">avec une bonne documentation. Il y a un merveilleux livre, Serious Cryptography de Jean-Philippe Aumasson, Serious Cryptography. Il donne un aper√ßu de l'√©tat actuel de la cryptographie, en tenant compte des derni√®res innovations. De plus, j'ai √©crit le livre d√©j√† mentionn√© Application Security in .NET, succinctement, qui est dans le domaine public. Il contient encore plus d'informations sur les pi√®ges de s√©curit√© .NET. Enfin, il y a une excellente pr√©sentation de Vladimir Kochetkov √† Slideshare, qui d√©crit les bases de la th√©orie de la s√©curit√© des applications de mani√®re quelque peu simpliste mais tr√®s solide et explique diverses sources de dangers.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour conclure, voyons quelques exemples suppl√©mentaires que j'ai pr√©par√©s. Au tout d√©but, j'ai parl√© de la quatri√®me √©tape de l'illumination cryptographique, au cours de laquelle il est r√©alis√© que la meilleure solution peut ne pas avoir besoin de cryptographie du tout. Regardons un exemple d'une telle solution. Jetons un coup d'≈ìil au m√©canisme .NET classique - CSRF (Cross-Site Request Forgery, ¬´cross-site request forgery¬ª), con√ßu pour prot√©ger contre une classe d'attaques, y compris la contrefa√ßon de demande intersite. Dans ce mod√®le, nous avons un agent utilisateur - g√©n√©ralement un navigateur. Il essaie d'√©tablir une connexion avec le serveur en envoyant une demande GET. En r√©ponse, le serveur envoie un jeton CSRF, qui est cach√© dans le champ HTML "cach√©". De plus, le m√™me jeton est attach√© √† la r√©ponse comme un cookie, comme un en-t√™te.L'utilisateur traite un formulaire et effectue un POST, qui retourne au serveur avec les deux jetons. Le serveur v√©rifie, premi√®rement, si les deux jetons ont √©t√© envoy√©s et, deuxi√®mement, s'ils correspondent. C'est cette comparaison d'identit√© qui permet au serveur de se prot√©ger contre un attaquant. Il s'agit d'un m√©canisme classique int√©gr√© √† ASP.NET et ASP.NET Core. Mikhail Shcherbakov a fait un excellent rapport dans lequel le travail du CSRF a √©t√© √©tudi√© en d√©tail.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le probl√®me avec cette approche est que la g√©n√©ration de jetons CSRF utilise le chiffrement. La difficult√© est que le chiffrement est en soi une op√©ration complexe et consommatrice de ressources, il charge le processeur, n√©cessite de la m√©moire et augmente le d√©lai. Tout cela n'est pas souhaitable. De plus, l'injection d'un jeton est un processus lourd, d√©routant et peu pratique. Dans de nombreux cas - par exemple, lors de l'utilisation d'AJAX, d'appels asynchrones - son impl√©mentation vous incombe en tant que d√©veloppeur. Ceux qui l'ont fait savent que cette activit√© est extr√™mement d√©sagr√©able. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a22/806/cae/a22806caea546a62b7a14d2af7583d48.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le Crypto identique ou comparable peut √™tre cr√©√© sans l'utilisation du chiffrement, comment </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indiqu√© sur la diapositive. Je comprends que le texte ici est assez compliqu√©, je suis donc pr√™t √† en discuter plus en d√©tail dans la zone de discussion. C'est tout pour moi, merci beaucoup.</font></font><br><br><blockquote>  .       DotNext.      DotNext 2018 Moscow ‚Äî   22-23  2018  - ¬´  ¬ª. <br><br> <b>  </b> .  ,  ,    .          !     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428121/">https://habr.com/ru/post/fr428121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428111/index.html">Arithm√©tique de pr√©cision arbitraire √† Erlang</a></li>
<li><a href="../fr428113/index.html">√Ä la question des courbes de B√©zier, de la vitesse Arduino et d'un site int√©ressant, ou comment j'ai pass√© le week-end</a></li>
<li><a href="../fr428115/index.html">D√©veloppement Web pour le commerce √©lectronique: 5 tendances technologiques pour 2019</a></li>
<li><a href="../fr428117/index.html">Processeurs tensoriels gratuits de Google dans le cloud collaboratif</a></li>
<li><a href="../fr428119/index.html">¬´Class-fields-proposition¬ª ou ¬´Qu'est-ce qui s'est mal pass√© dans tc39 commit¬ª</a></li>
<li><a href="../fr428123/index.html">Semaine de la s√©curit√© 41: Bonne nouvelle</a></li>
<li><a href="../fr428125/index.html">Qui sont les analyses de produits et pourquoi sont-elles n√©cessaires dans une √©quipe?</a></li>
<li><a href="../fr428127/index.html">Cache Nginx: tout nouveau - vieux bien oubli√©</a></li>
<li><a href="../fr428129/index.html">Une logique floue simple coll√©e ¬´de ce qui √©tait¬ª pour un moteur √† turbine √† gaz</a></li>
<li><a href="../fr428131/index.html">Toute la v√©rit√© sur RTOS. Article # 17. Groupes de drapeaux d'√©v√©nements: introduction et services de base</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>