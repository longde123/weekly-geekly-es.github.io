<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙄 👳🏿 🤙 Parametrização incerta como um método universal para criar arquitetura de aplicativos em C ++ e Java, no mínimo. o preço 🧚🏾 👨‍👧 🏇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ é uma linguagem confusa e sua principal desvantagem é a dificuldade de criar blocos isolados de código. Em um projeto típico, tudo depende de tud...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parametrização incerta como um método universal para criar arquitetura de aplicativos em C ++ e Java, no mínimo. o preço</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475268/">  C ++ é uma linguagem confusa e sua principal desvantagem é a dificuldade de criar blocos isolados de código.  Em um projeto típico, tudo depende de tudo.  Este artigo mostra como escrever código altamente isolado que depende minimamente de bibliotecas específicas (incluindo padrão), implementações, reduzindo a dependência de qualquer parte do código em um conjunto de interfaces.  Além disso, serão propostas soluções arquitetônicas para parametrização de código, que podem interessar não apenas programadores C ++, mas também programadores Java.  E o que é importante, a solução proposta é muito econômica em termos de tempo de desenvolvimento. <br><a name="habracut"></a><br>  <i><b>Isenção de responsabilidade</b></i> : neste artigo, reuni minhas idéias sobre arquitetura ideal.  Algumas idéias não são minhas (mas não me lembro de quem), algumas são comuns e conhecidas por todos - isso não é importante, porque não ofereço minhas próprias idéias sobre uma boa arquitetura, mas um código específico que permitirá que essa arquitetura seja abordada a um preço mínimo. <br><br>  <i><b>Isenção de responsabilidade N2</b></i> : <i><b>Ficarei</b></i> feliz com o feedback construtivo expresso em palavras.  Se você entende pior do que eu e me repreende, significa que em algum lugar não expliquei o suficiente e faz sentido refazer o texto.  Se você entende melhor do que eu, significa que vou ganhar uma experiência valiosa.  Agradecemos antecipadamente. <br><br>  <i><b>Isenção de responsabilidade N3</b></i> : escrevi grandes aplicativos a partir do zero, mas não escrevi aplicativos corporativos para servidores e clientes.  Tudo é diferente lá e, provavelmente, minha experiência parecerá estranha para especialistas neste campo.  E o artigo não é sobre isso, os mesmos problemas de escalabilidade não são considerados aqui. <br>  <i><b>Isenção de responsabilidade N4</b></i> ( <b>Atualização.</b> Com base nos comentários): Alguns comentaristas sugeriram que eu reinventasse o Fowler e ofereça padrões de design conhecidos.  Definitivamente não é esse o caso.  Proponho uma ferramenta de parametrização muito pequena que permite implementar esses padrões com um mínimo de rabisco.  Incluindo o Localizador de Serviços e Injeção de Dependência da Fowler, mas não apenas - usando a classe TypedSet, você também pode implementar economicamente um conjunto de estratégias.  Nesse caso, o Fowler acessou através de linhas, o que é caro - minha ferramenta de custo zero, custo zero (se absolutamente estritamente, então log (N) em vez de 2M * log (N), onde M é o comprimento da cadeia de parâmetros para o Localizador de serviços. após o aparecimento do constexpr typeid em c ++ 20, o preço deve ficar completamente zero).  Portanto, peço que você não estenda o significado do artigo aos padrões de design.  Aqui você encontrará apenas um <b><i>método para a</i></b> implementação barata desses padrões. <br><br>  Os exemplos serão em C ++, mas todas as opções acima são bastante implementáveis ​​em Java.  Talvez, com o tempo, eu forneça código de trabalho para Java se a solicitação para isso estiver nos comentários de você. <br><br><h2>  Parte 1. Arquitetura esférica no vácuo </h2><br>  Antes de resolver brilhantemente todas as dificuldades, você precisa criá-las corretamente.  Com maestria criando dificuldades para si mesmo no lugar certo, você pode facilitar bastante a solução deles.  Para isso, formulamos um objetivo cuja solução vamos apresentar métodos - os princípios mínimos da boa arquitetura. <br><br>  De fato, a mágica da boa arquitetura é apenas dois princípios, e o que está escrito abaixo é apenas uma decodificação.  O primeiro princípio é a testabilidade do código.  A testabilidade é como o fio de Ariadne que leva a uma boa arquitetura.  Se você não sabe como escrever um teste de funcionalidade, arruinou a arquitetura.  Se você não sabe como criar uma boa arquitetura, pense em qual será o teste para a funcionalidade que você planejou - e você criará automaticamente uma barra de qualidade arquitetural para si mesmo e bastante alta.  Os pensamentos nos testes aumentam automaticamente a modularidade, diminuem a conectividade e tornam a arquitetura mais lógica. <br><br>  E eu não quero dizer TDD.  Uma doença típica de muitos programadores é o culto religioso de tecnologias lidas em algum lugar sem entender os limites de sua eficácia.  O TDD é bom quando vários programadores estão trabalhando no código, quando há um departamento de testes e as autoridades entendem por que boas práticas de codificação são necessárias e estão prontas para pagar não apenas por algum código que resolve o problema, mas também por sua confiabilidade.  Se seus superiores não estiverem prontos para pagar, você terá que trabalhar mais economicamente.  No entanto, você ainda precisa testar o código - a menos que, é claro, tenha um senso de autopreservação. <br><br>  O segundo princípio é modularidade.  Mais precisamente, modularidade altamente isolada sem o uso de bibliotecas / código rígido que não estão relacionados ao próprio módulo.  Agora, ao projetar arquiteturas de servidor, está na moda dividir um monólito em microsserviços.  Vou lhe contar um segredo terrível - cada módulo no monólito deve ser como um microsserviço.  No sentido de que ele deve se destacar facilmente do código geral com um mínimo de cabeçalhos conectados no ambiente de teste.  Ainda não está claro, mas vou explicar com um exemplo: Você já tentou alocar shared_ptr do boost?  Se ao mesmo tempo você conseguir arrastar não apenas todo o impulso, mas apenas metade de suas matérias-primas, isso significa que você matou de três a cinco dias para eliminar vícios desnecessários !!!  Ao mesmo tempo, você arrasta o fato de que shared_ptr definitivamente não tem nada a ver !!! <br><br>  E é pior que um erro - é um crime arquitetônico. <br><br>  Com uma boa arquitetura, você deve poder remover o shared_ptr, substituindo sem problemas e rapidamente tudo o que não está relacionado ao shared_ptr pelas versões de teste.  Por exemplo, uma versão de teste do alocador.  Ou esqueça o impulso.  Digamos que você escreva um analisador xml / html.  Você precisa trabalhar com seqüências de caracteres e arquivos com o analisador.  E se estivermos falando de uma arquitetura ideal que não esteja ligada às necessidades de uma empresa de produção / software específica, para um analisador com uma arquitetura ideal, não temos o direito de usar as operações de pesquisa std :: istream, std :: file_system, std :: string e hardcode com strings no analisador.  Precisamos fornecer uma interface de fluxo, uma interface para operações de arquivo (talvez dividida em subinterfaces, mas o acesso a subinterfaces ainda precisará ser feito através da interface do módulo de operações de arquivo), uma interface para trabalhar com strings, uma interface de alocador e, idealmente, também uma interface para a própria linha.  Como resultado, podemos substituir sem problemas tudo o que não está relacionado à análise por espaços em branco de teste ou inserir uma versão de teste do alocador / trabalhar com pesquisa de arquivos / string por verificações adicionais.  E a versatilidade da solução aumentará - amanhã, sob a interface do fluxo, não haverá um arquivo, mas um site em algum lugar da Internet, e ninguém notará.  Você pode substituir a biblioteca padrão pelo Qt e, em seguida, alternar para o visual c ++ e começar a usar apenas coisas do Linux - e as alterações serão mínimas.  Como spoiler, direi que, com essa abordagem, a questão do preço surge em pleno crescimento - cobrir tudo com interfaces, incluindo elementos da biblioteca padrão, é caro, mas isso não é um objetivo, mas uma solução. <br><br>  Em geral, o princípio radical de módulo como microsserviço, proclamado neste artigo, é um ponto sensível em C ++ e geralmente é um código positivo.  Se você criar arquivos de declaração e separar interfaces separadamente das implementações, ainda poderá criar independência / isolamento de arquivos cpp um do outro e, em seguida, relativo, não 100%, os cabeçalhos geralmente são tecidos em um monólito sólido, do qual nada pode ser arrancado sem carne.  E embora isso tenha um efeito terrível no tempo de compilação, é.  Além disso, mesmo que a independência dos títulos seja alcançada, isso significa automaticamente a incapacidade de agregar classes.  Na verdade, a única maneira de obter independência dos arquivos .cpp e dos cabeçalhos no c ++ é declarar classes pré-usadas (sem defini-las) e depois usar apenas ponteiros para elas.  assim que você usar a própria classe em vez do ponteiro de classe no arquivo de cabeçalho (ou seja, agregá-la), você criará um monte de todos os .cpp-shniks que incluirão esse cabeçalho e o .cpp-shnik que contém a definição de classe.  Ainda existe o fastpimpl, mas apenas garantimos a criação de dependências no nível do cpp. <br><br>  Portanto, para uma boa arquitetura, o isolamento de módulos é importante - a capacidade de extrair um módulo com o primeiro cabeçalho conectando macros e os principais tipos de biblioteca, com um segundo cabeçalho para declarações e várias inclusões conectando um conjunto de interfaces.  E apenas o que se relaciona com essa funcionalidade, e todo o resto deve ser armazenado em outros módulos e acessível apenas através de interfaces. <br><br>  Declaramos as principais características da boa arquitetura, incluindo os pontos indicados acima, ponto a ponto. <br><br>  Vamos definir o termo "Módulo".  Um módulo é a soma das funcionalidades logicamente relacionadas.  Por exemplo, trabalhe com fluxos ou trabalho de arquivo ou um analisador de html. <br><br>  O módulo “File Work” pode combinar muitas funcionalidades - abra um arquivo, feche, posicione, leia propriedades, leia o tamanho do arquivo.  Ao mesmo tempo, o scanner de pasta pode ser projetado como parte da interface "Trabalho de arquivo" ou como um módulo separado, e o trabalho com fluxos pode ser colocado em um módulo separado, com certeza.  O que, no entanto, não interfere na organização do acesso a todos os outros módulos aos fluxos e ao scanner de pastas indiretamente, através do "Trabalho de Arquivo".  Isso não é necessário, mas bastante lógico. <br><br><ol><li>  Modularidade.  "Módulo como microsserviço" imperativo. </li><li>  Alocação de 20% do código executado 80% do tempo em uma biblioteca separada - o núcleo do programa </li><li>  Testabilidade de cada funcionalidade de cada módulo </li><li>  Interface, é a falta de código rígido.  Você só pode chamar o código rígido diretamente relacionado à funcionalidade do módulo e deve fazer as outras chamadas diretas da biblioteca para um módulo separado e acessá-las por meio da interface. </li><li>  Isolamento completo do módulo por interfaces do ambiente externo.  A proibição de "pregar" implementações que não estão relacionadas à funcionalidade da classe.  E, mais radicalmente, isolar bibliotecas (incluindo as padrão) com interfaces / adaptadores / decoradores </li><li>  A agregação de uma classe ou a criação de uma variável de classe ou fastpimpl é usada apenas quando é essencial para o desempenho. </li></ol><br>  Obviamente, descobriremos como conseguir tudo isso rapidamente por um preço mais baixo, mas eu gostaria de chamar a atenção para outro problema, cuja solução será um bônus para nós - a transferência de parâmetros dependentes da plataforma.  Por exemplo, se você precisar criar um código que funcione igualmente no Android e no Windows, será lógico alocar algoritmos dependentes da plataforma em módulos separados.  Nesse caso, provavelmente, a implementação para o Android pode exigir uma referência ao ambiente Java (jni), JNIEnv *, e possivelmente alguns objetos Java.  E a implementação no Windows pode exigir uma pasta de trabalho do programa (que no android pode ser solicitada ao sistema, com JNIEnv *).  O truque é que o mesmo JNIEnv * não existe no contexto do Windows, portanto, mesmo uma união digitada ou sua alternativa c ++ à std :: variant é impossível.  Obviamente, você pode usar o vetor void * ou o vetor std :: any como parâmetro, mas honestamente, essa é uma muleta atípica.  Atípico - porque rejeita a principal vantagem do c ++, digitação forte.  E isso é mais perigoso que o SARS. <br><br>  Além disso, analisaremos como resolver esse problema de maneira estritamente tipificada. <br><br><h2>  Parte 2. Balas mágicas e seu preço </h2><br>  Então, digamos que temos uma grande quantidade de código que precisa ser escrita do zero, e o resultado será um projeto muito grande. <br><br>  Como pode ser montado de acordo com os princípios que determinamos? <br><br>  A maneira clássica, aprovada por todos os manuais, é dividir tudo em interfaces e estratégias.  Com a ajuda de interfaces e estratégias, se houver muitas delas, qualquer subproblema do nosso projeto pode ser isolado a tal ponto que o princípio "módulo como microsserviço" começará a trabalhar nele.  Mas minha experiência pessoal é que, se você dividir o projeto em 20 a 30 partes, que será isolado no nível de "módulo como microsserviço", terá êxito.  Mas a principal característica da boa arquitetura é a capacidade de testar qualquer classe fora do contexto do projeto.  E se você já isola cada classe, já existem mais de 500 módulos e, na minha experiência, isso aumenta o tempo de desenvolvimento em 3-5 vezes, o que significa que em "condições de combate" você não fará isso e comprometerá preço e qualidade. <br><br>  Alguém pode duvidar, e estará em seu próprio direito.  Vamos fazer uma estimativa aproximada.  Deixe a classe média ter 3-5 membros e 20 funções e 3 construtores.  Além disso, 6 a 10 getters e setters (mutadores) para acesso aos nossos membros.  Total de cerca de 40 unidades na classe.  Em um projeto típico, cada classe de “centro” precisa acessar uma média de cinco funcionalidades, não um centro para 3. Por exemplo, muitas classes precisam de um alocador, sistema de arquivos, trabalho com seqüências de caracteres, trabalho com fluxos e acesso a bancos de dados. <br><br>  Cada estratégia / interface exigirá um membro do tipo <code>std::shared_ptr&lt;CreateStreamStrategy&gt; m_create_stream;</code>  .  Dois mutadores, além de inicialização em cada um dos três construtores.  Além disso, em algum ponto da inicialização de nossa classe, você precisará chamar algo como <code>myclass-&gt;SetCreateStreamStrategy( my_create_stream_strategy )</code> algumas vezes, para um total de 8 unidades por interface / estratégia e, como temos cerca de cinco, haverá 40 unidades.  Ou seja, tornamos a classe de origem duas vezes mais complicada.  E a perda de simplicidade afetará inevitavelmente a legibilidade, e em algum outro lugar do processo de depuração e meia, apesar do fato de que nada parece ter mudado essencialmente. <br><br>  Então a questão é.  Como fazer o mesmo, mas a um preço mínimo?  A primeira coisa que vem à mente é a parametrização estática nos modelos, no estilo do Alexandrescu e da biblioteca Loki. <br><br>  Estamos escrevendo uma aula em grande estilo <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Traits</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMainTaskFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... MyStream stream = Traits::streamwork::Open( stream_name ); ... } };</code> </pre> <br>  Essa decisão tem todas as vantagens arquiteturais que identificamos na primeira parte.  Mas também há muitas desvantagens. <br><br>  Eu mesmo gosto de transbordar, mas me arrependo de admitir: os modelos no código comum são amados apenas pelos mágicos dos modelos.  Uma massa significativa de programadores com a palavra "modelo" franze a testa levemente.  Além disso, na indústria, a grande maioria das vantagens não possui vantagens, mas é um pouco retreinada em syshniks em c ++ que não têm conhecimento profundo das vantagens, mas se enquadram na palavra "modelo" e fingem estar mortos. <br><br>  Se traduzirmos isso em uma linguagem de produção, manter o código na parametrização estática é mais caro e mais complicado. <br><br>  Ao mesmo tempo, se quisermos, para propósitos de maior legibilidade, remover cuidadosamente o corpo da função fora da classe, obteremos um monte de rabiscos com os nomes dos modelos e parâmetros do modelo.  E, no caso de um erro de compilação, obtemos longas prateleiras legíveis por humanos de áreas de causas e problemas com vários modelos aninhados complexos. <br><br>  Mas, existe uma saída simples.  Como mágico de modelo, declaro que quase tudo o que pode ser feito usando parametrização estática / polimorfismo estático pode ser transferido para polimorfismo dinâmico.  Não, é claro, não erradicaremos o modelo mal até o fim - mas não o espalharemos com uma mão generosa para parametrização em cada classe, mas o limitaremos a algumas aulas instrumentais. <br><br><h2>  Parte três.  A solução proposta e o código codificado para esta solução </h2><br>  Então LÁ !!!  Conheça a classe de modelo TypedSet.  Ele associa um ponteiro inteligente desse tipo a um único tipo.  Além disso, para o tipo especificado, ele pode ter um objeto, mas não pode.  Como não gosto do nome, ficarei grato se nos comentários me indicar uma opção mais bem-sucedida. <br><br>  Um tipo - um objeto.  Mas o número de tipos não é limitado!  Portanto, você pode passar uma classe como um parametrizador. <br><br>  Quero chamar sua atenção para um ponto.  Pode parecer que em algum momento você pode precisar de dois objetos em uma interface.  De fato, se essa necessidade surgir, então (na minha opinião) isso significa um erro de arquitetura.  Ou seja, se você tiver dois objetos em uma interface, eles não serão mais interfaces de acesso funcional: essas são variáveis ​​de entrada para a função ou você não possui uma, mas duas funcionalidades às quais precisa acessar, é melhor dividir a interface em duas . <br><br>  Faremos três funções básicas: Criar, Obter e Tem.  Por conseguinte, a criação, recebimento e verificação da presença de um elemento. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// @brief    .      ,    ///           /// class TypedSet { public: template &lt;class TypedElement&gt; void Create( const std::shared_ptr&lt;TypedElement&gt; &amp; value ); template &lt;class TypedElement&gt; std::shared_ptr&lt;TypedElement&gt; Get() const; template &lt;class TypedElement&gt; bool Has() const; size_t GetSize() const { return storage_.size(); } protected: typedef std::map&lt; size_t, std::shared_ptr&lt;void&gt; &gt; Storage; Storage const &amp; storage() const { return storage_; } Storage &amp; get_storage() { return storage_; } private: Storage storage_; }; template &lt;class TypedElement&gt; void TypedSet::Create( const std::shared_ptr&lt;TypedElement&gt; &amp; value ) { size_t hash = typeid(TypedElement).hash_code(); if ( storage().count( hash ) &gt; 0 ) { LogError( "Access Violation" ); return; } std::shared_ptr&lt;void&gt; to_add ( value ); get_storage().insert( std::pair( typeid(TypedElement).hash_code(), to_add ) ); } template &lt;class TypedElement&gt; bool TypedSet::Has() const { size_t hash = typeid(TypedElement).hash_code(); return storage().count( hash ) &gt; 0; } template &lt;class TypedElement&gt; std::shared_ptr&lt;TypedElement&gt; TypedSet::Get() const { size_t hash = typeid(TypedElement).hash_code(); if ( storage().count( hash ) &gt; 0 ) { std::shared_ptr&lt;void&gt; ret( storage().at(hash) ); return std::static_pointer_cast&lt;TypedElement&gt;( ret ); } else { LogError( "Access Violation" ); return std::shared_ptr&lt;TypedElement&gt; (); } }</span></span></code> </pre> <br>  A propósito, vi uma solução alternativa de colegas escrevendo no Qt.  Lá, o acesso à interface desejada era realizado por meio de um singleton, que "mapeou" a interface desejada, empacotada no Varaint, por meio de uma linha de texto (!!!) e, após lançar essa opção, o resultado poderia ser utilizado. <br><br><pre> <code class="cpp hljs">GlobalConfigurator()[<span class="hljs-string"><span class="hljs-string">"FileSystem"</span></span>].Get().As&lt;FileSystem&gt;()</code> </pre> <br>  Certamente funciona, mas a sobrecarga de contar o comprimento e mais amarrar a corda é um pouco assustadora para minha alma otimista.  Aqui, a sobrecarga é zero, porque  a escolha da interface desejada é realizada em tempo de compilação. <br><br>  Com base no TypedSet, podemos criar a classe StrategiesSet, que já é mais avançada.  Nele, armazenaremos não apenas um objeto por interface de acesso para cada funcional, mas também para cada interface (daqui em diante denominada estratégia) um TypedSet adicional com parâmetros para essa estratégia.  Esclareço: os parâmetros, diferentemente das variáveis ​​de função, são definidos uma vez durante a inicialização do programa ou uma vez para uma grande execução do programa.  Os parâmetros permitem que você torne o código realmente multiplataforma.  É neles que dirigimos toda a cozinha dependente da plataforma. <br><br>  Aqui teremos funções mais básicas: Create, Get, CreateParamsSet e GetParamsSet.  Não foi estabelecido, porque é arquitetonicamente redundante: se o seu código se refere à funcionalidade de trabalhar com o sistema de arquivos, mas o código de chamada não o forneceu, você só pode lançar uma exceção ou afirmar, ou <s>fazer com que o programa sebukka</s> chame a função abort (). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategiesSet</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Create</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Strategy&gt; &amp; value ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Strategy&gt; Get(); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateParamsSet</span></span></span><span class="hljs-class">();</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt; GetParamsSet(); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateParam</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ParamType&gt; &amp; value ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ParamType&gt; GetParam(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-function">TypedSet </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strategies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strategies_; } <span class="hljs-function"><span class="hljs-function">TypedSet &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_strategies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strategies_; } <span class="hljs-function"><span class="hljs-function">TypedSet </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">params</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> params_; } <span class="hljs-function"><span class="hljs-function">TypedSet &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_params</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> params_; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamHolder</span></span></span><span class="hljs-class"> {</span></span> ParamHolder( ) : param_ptr( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;TypedSet&gt;() ) {} <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt; param_ptr; }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TypedSet strategies_; TypedSet params_; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategiesSet</span></span></span><span class="hljs-class">:</span></span>:Create( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Strategy&gt; &amp; value ) { get_strategies().Create&lt;Strategy&gt;( value ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Strategy&gt; StrategiesSet::Get() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_strategies().Get&lt;Strategy&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategiesSet</span></span></span><span class="hljs-class">:</span></span>:CreateParamsSet( ) { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ParamHolder&lt;Strategy&gt; Holder; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; Holder &gt; ptr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; Holder &gt;( ); ptr-&gt;param_ptr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; TypedSet &gt;(); get_params().Create&lt; Holder &gt;( ptr ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt; StrategiesSet::GetParamsSet() { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ParamHolder&lt;Strategy&gt; Holder; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( get_params().Has&lt; Holder &gt;() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_params().Get&lt; Holder &gt;()-&gt;param_ptr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LogError(<span class="hljs-string"><span class="hljs-string">"StrategiesSet::GetParamsSet : get unexisting!!!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt;(); } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategiesSet</span></span></span><span class="hljs-class">:</span></span>:CreateParam( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ParamType&gt; &amp; value ) { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ParamHolder&lt;Strategy&gt; Holder; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !params().Has&lt;Holder&gt;() ) CreateParamsSet&lt;Strategy&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( params().Has&lt;Holder&gt;() ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt; params_set = GetParamsSet&lt;Strategy&gt;(); params_set-&gt;Create&lt;ParamType&gt;( value ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LogError( <span class="hljs-string"><span class="hljs-string">"Param creating error: Access Violation"</span></span> ); } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ParamType&gt; StrategiesSet::GetParam() { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ParamHolder&lt;Strategy&gt; Holder; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( params().Has&lt;Holder&gt;() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetParamsSet&lt;Strategy&gt;()-&gt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> Get&lt;ParamType&gt;(); <span class="hljs-comment"><span class="hljs-comment">//   template          .    . } else { LogError( "Access Violation" ); return std::shared_ptr&lt;ParamType&gt; (); } }</span></span></code> </pre> <br>  Uma vantagem adicional é que, no estágio de criação de protótipos, você pode criar uma classe de digitação super grande, acessar acesso a todos os módulos nela e passá-la a todos os módulos como parâmetro, rapidamente se tornar pequena e, em seguida, dividi-la silenciosamente em partes que são minimamente necessárias para cada módulo. <br><br>  Bem, e um caso de uso pequeno e (ainda) excessivamente simplificado.  Espero que você nos comentários me sugira o que você gostaria de ver como um exemplo simples, e farei do artigo uma pequena atualização.  Como diz a sabedoria popular de programação, “libere o mais cedo possível e aprimore o uso de feedback após o lançamento”. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interface1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\niface1\n"</span></span>);} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Interface1() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interface2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\niface2\n"</span></span>);} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Interface2() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interface3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\niface3\n"</span></span>);} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Interface3() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Implementation1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Interface1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nimpl1\n"</span></span>);} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Implementation2</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Interface2 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nimpl2\n"</span></span>);} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintParams</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~PrintParams() {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintParamsUbuntu</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PrintParams { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Ubuntu"</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintParamsWindows</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PrintParams { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Windows"</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintStrategy</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~PrintStrategy() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TypedSet&amp; params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; str )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintWithOsStrategy</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PrintStrategy { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TypedSet&amp; params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; str )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> os = params.Get&lt; PrintParams &gt;()-&gt;GetOs(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" Printing: %s (OS=%s)"</span></span>, str.c_str(), os.c_str() ); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestTypedSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; TypedSet a; a.Create&lt;Interface1&gt;( make_shared&lt;Implementation1&gt;() ); a.Create&lt;Interface2&gt;( make_shared&lt;Implementation2&gt;() ); a.Get&lt;Interface1&gt;()-&gt;Fun(); a.Get&lt;Interface2&gt;()-&gt;Fun(); Log(<span class="hljs-string"><span class="hljs-string">"Double creation:"</span></span>); a.Create&lt;Interface1&gt;( make_shared&lt;Implementation1&gt;() ); Log(<span class="hljs-string"><span class="hljs-string">"Get unexisting:"</span></span>); a.Get&lt;Interface3&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestStrategiesSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; StrategiesSet printing; printing.Create&lt; PrintStrategy &gt;( make_shared&lt;PrintWithOsStrategy&gt;() ); printing.CreateParam&lt; PrintStrategy, PrintParams &gt;( make_shared&lt;PrintParamsWindows&gt;() ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> print_strategy_ptr = printing.Get&lt; PrintStrategy &gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; print_strategy = *print_strategy_ptr; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; print_params = *printing.GetParamsSet&lt; PrintStrategy &gt;(); print_strategy( print_params, <span class="hljs-string"><span class="hljs-string">"Done!"</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TestTypedSet(); TestStrategiesSet(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h2>  Sumário </h2><br>  Assim, resolvemos um problema importante: deixamos na turma apenas a interface diretamente relacionada à funcionalidade da turma.  O resto foi "empurrado" para o StrategiesSet, evitando tanto a bagunça da classe com elementos desnecessários quanto "pregando" certas funcionalidades necessárias aos algoritmos.  Isso nos permitirá não apenas escrever código altamente isolado, com zero dependências de implementações e bibliotecas, mas também economizar uma quantidade enorme de tempo. <br><br>  O código para as classes de exemplo e ferramenta pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui.</a> <br><br>  <b>Upd.</b>  <b>a partir de 13/11/2019</b> <br>  De fato, o código mostrado aqui é apenas um exemplo simplificado de legibilidade.  O fato é que typeid () .Hash_code é implementado em compiladores modernos lenta e ineficientemente.  Seu uso mata muito do significado.  Além disso, como o respeitado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">0xd34df00d sugeriu</a> , o padrão não garante a capacidade de distinguir tipos por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">código hash</a> (na prática, essa abordagem, no entanto, funciona).  Mas o exemplo é bem lido.  Reescrevi TypedSet sem typeid (). Hash_code (), além disso, substitui o mapa por array (mas com a capacidade de alternar rapidamente de mapa para array e vice-versa alterando um dígito em #if).  Acabou sendo mais difícil, mas mais interessante para uso prático. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em coliru</a> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> metatype { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> GetAndIncrease() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter_++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> counter_ = <span class="hljs-number"><span class="hljs-number">1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HashGetterBody</span></span></span><span class="hljs-class"> {</span></span> HashGetterBody() : hash_( counter_.GetAndIncrease() ) { } <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> GetHash() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash_; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Counter counter_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> hash_; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HashGetter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> GetHash() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasher_.GetHash(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> HashGetterBody&lt;Type&gt; hasher_; }; } <span class="hljs-comment"><span class="hljs-comment">// namespace metatype template &lt;typename Type&gt; size_t GetTypeHash() { return metatype::HashGetter&lt;Type&gt;().GetHash(); } namespace details { #if 1 //   ,        () class TypedSetStorage { public: static inline const constexpr size_t kMaxTypes = 100; typedef std::array&lt; std::shared_ptr&lt;void&gt;, kMaxTypes &gt; Storage; void Set( size_t hash_index, const std::shared_ptr&lt;void&gt; &amp; value ) { ++size_; assert( hash_index &lt; kMaxTypes ); // too many types data_[hash_index] = value; } std::shared_ptr&lt;void&gt; &amp; Get( size_t hash_index ) { assert( hash_index &lt; kMaxTypes ); return data_[hash_index]; } const std::shared_ptr&lt;void&gt; &amp; Get( size_t hash_index ) const { if ( hash_index &gt;= kMaxTypes ) return empty_ptr_; return data_[hash_index]; } bool Has( size_t hash_index ) const { if ( hash_index &gt;= kMaxTypes ) return 0; return (bool)data_[hash_index]; } size_t GetSize() const { return size_; } private: Storage data_; size_t size_ = 0; static const inline std::shared_ptr&lt;void&gt; empty_ptr_; }; #else //    ,        (std::map) class TypedSetStorage { public: typedef std::map&lt; size_t, std::shared_ptr&lt;void&gt; &gt; Storage; void Set( size_t hash_index, const std::shared_ptr&lt;void&gt; &amp; value ) { data_[hash_index] = value; } std::shared_ptr&lt;void&gt; &amp; Get( size_t hash_index ) { return data_[hash_index]; } const std::shared_ptr&lt;void&gt; &amp; Get( size_t hash_index ) const { return data_.at(hash_index); } bool Has( size_t hash_index ) const { return data_.count(hash_index) &gt; 0; } size_t GetSize() const { return data_.size(); } private: Storage data_; }; #endif } // namespace details /// @brief    .      ,    ///           /// class TypedSet { public: template &lt;class TypedElement&gt; void Create( const std::shared_ptr&lt;TypedElement&gt; &amp; value ); template &lt;class TypedElement&gt; std::shared_ptr&lt;TypedElement&gt; Get() const; template &lt;class TypedElement&gt; bool Has() const; size_t GetSize() const { return storage_.GetSize(); } protected: typedef details::TypedSetStorage Storage; Storage const &amp; storage() const { return storage_; } Storage &amp; get_storage() { return storage_; } private: Storage storage_; }; template &lt;class TypedElement&gt; void TypedSet::Create( const std::shared_ptr&lt;TypedElement&gt; &amp; value ) { size_t hash = GetTypeHash&lt;TypedElement&gt;(); if ( storage().Has( hash ) ) { LogError( "Access Violation" ); return; } std::shared_ptr&lt;void&gt; to_add ( value ); get_storage().Set( hash, to_add ); } template &lt;class TypedElement&gt; bool TypedSet::Has() const { size_t hash = GetTypeHash&lt;TypedElement&gt;(); return storage().Has( hash ); } template &lt;class TypedElement&gt; std::shared_ptr&lt;TypedElement&gt; TypedSet::Get() const { size_t hash = GetTypeHash&lt;TypedElement&gt;(); if ( storage().Has( hash ) ) { std::shared_ptr&lt;void&gt; ret( storage().Get( hash ) ); return std::static_pointer_cast&lt;TypedElement&gt;( ret ); } else { LogError( "Access Violation" ); return std::shared_ptr&lt;TypedElement&gt; (); } }</span></span></code> </pre><br>  Aqui o acesso é realizado em tempo linear, os hashes de tipo são contados antes que main () seja lançado, as perdas são apenas para verificações de validação, que podem ser descartadas, se desejado. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt475268/">https://habr.com/ru/post/pt475268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt475258/index.html">Uma representação visual das eleições em São Petersburgo - a mágica do envolvimento de voz</a></li>
<li><a href="../pt475260/index.html">A diferença entre uma função assíncrona e uma função que retorna uma promessa</a></li>
<li><a href="../pt475262/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 388 (4 a 10 de novembro de 2019)</a></li>
<li><a href="../pt475264/index.html">Farejadores que poderiam: como a família FakeSecurity infectou lojas on-line</a></li>
<li><a href="../pt475266/index.html">Revertemos 1s móveis no Android. Como adicionar um pouco de funcionalidade e abandonar algumas noites</a></li>
<li><a href="../pt475270/index.html">SwiftUI: Criando seções expansíveis / recolhíveis na exibição de lista</a></li>
<li><a href="../pt475272/index.html">Migrando para a infraestrutura de espera assíncrona no Rust</a></li>
<li><a href="../pt475276/index.html">Como escrever afirmar corretamente</a></li>
<li><a href="../pt475278/index.html">Como espiar um hacker enquanto um hacker espia você</a></li>
<li><a href="../pt475280/index.html">Senhas da Cisco, migração de zona DNS, zero solicitações LDAP, coletamos pacotes Ethernet. Resolvendo problemas em uma rede com r0ot-mi. Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>