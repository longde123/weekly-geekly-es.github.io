<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏼 👏🏻 👸🏻 Interoperabilidade segura em sistemas distribuídos 🐅 ✡️ 👩🏻‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Habr! 

 Meu nome é Alexey Solodky, sou desenvolvedor de PHP no Badoo. E hoje vou compartilhar uma versão em texto da minha palestra para o primeir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interoperabilidade segura em sistemas distribuídos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/413555/"><img src="https://habrastorage.org/webt/ag/m-/8r/agm-8r1daffwnqqhzqagmayd4uc.png" width="800"><br><br>  Oi Habr! <br><br>  Meu nome é Alexey Solodky, sou desenvolvedor de PHP no Badoo.  E hoje vou compartilhar uma versão em texto da minha palestra para o primeiro Meetup do Badoo PHP.  Um vídeo deste e de outros relatórios da mitap pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Qualquer sistema que consiste em pelo menos dois componentes (e se você possui PHP e um banco de dados, esses são dois componentes), enfrenta classes inteiras de riscos na interação entre esses componentes. <br><br>  O departamento de plataforma em que trabalho integra novos serviços internos ao nosso aplicativo.  E resolvendo esses problemas, acumulamos experiência, que eu quero compartilhar. <br><br>  Nosso back-end é um monólito PHP interagindo com muitos serviços (atualmente existem cerca de 50 deles).  Os serviços raramente interagem entre si.  Mas os problemas que falo no artigo também são relevantes para a arquitetura de microsserviços.  De fato, nesse caso, os serviços interagem muito ativamente entre si e, quanto mais interação você tiver, mais problemas terá. <br><br>  Considere o que fazer quando o serviço falhar ou diminuir, como organizar a coleção de métricas e o que fazer quando todas as opções acima não salvarem você. <br><a name="habracut"></a><br><h2>  Falha no serviço </h2><br>  Mais cedo ou mais tarde, o servidor no qual seu serviço está instalado cairá.  Isso acontecerá com certeza e você não poderá se defender - apenas reduza a probabilidade.  Você pode se decepcionar com hardware, rede, código, implantação malsucedida - qualquer coisa.  E quanto mais servidores você tiver, mais frequentemente isso acontecerá. <br><br>  Como fazer seus serviços sobreviverem em um mundo em que os servidores travam constantemente?  Uma abordagem geral para resolver essa classe de problemas é a redundância. <br><br>  A redundância é usada em todos os lugares, em diferentes níveis: do ferro aos data centers inteiros.  Por exemplo, RAID1 para proteger contra falhas no disco rígido ou uma fonte de alimentação de backup para o servidor em caso de falha do primeiro.  Além disso, esse esquema é amplamente aplicado aos bancos de dados.  Por exemplo, você pode usar master-slave para isso. <br><br>  Vamos considerar problemas típicos de redundância usando o esquema mais simples como exemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/9b/rb/lo9brbsy29ca8b0i-1ygtyckncq.png" width="300"></div><br>  O aplicativo se comunica exclusivamente com o mestre, enquanto em segundo plano, de forma assíncrona, os dados são transferidos para o escravo.  Quando o mestre travar, mudaremos para o escravo e continuaremos trabalhando. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ga/lt/o5/galto5cgws3ed44dfwhnqq9zvd4.png" width="300"></div><br><br>  Depois de restaurar o mestre, apenas criamos um novo escravo, e o antigo se transforma em um mestre. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6h/c8/gc/6hc8gc6qzhzso3xscnjblfn1frm.png" width="300"></div><br>  O esquema é simples, mas mesmo com muitas nuances características de qualquer esquema redundante. <br><br><h3>  Carregar </h3><br>  Digamos que um servidor do exemplo acima possa suportar cerca de 100k RPS.  Agora, a carga é de 60k RPS e tudo funciona como um relógio. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/99/gw/j1/99gwj19rezs-ywa-hdopmqcudk8.png" width="300"></div><br>  Porém, com o tempo, a carga no aplicativo e, portanto, a carga no mestre aumentam.  Você pode equilibrar movendo parte da leitura para um escravo. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sv/r4/si/svr4sicizgym8gqndznsygpi0-o.png" width="300"></div><br>  Parece muito bom.  Mantém a carga, o servidor não está mais ocioso.  Mas isso é uma péssima ideia.  É importante lembrar por que você criou o escravo inicialmente - para mudar para ele em caso de problemas com o principal.  Se você começou a carregar os dois servidores, quando o seu mestre travar - e mais cedo ou mais tarde ele travará - você terá que alternar o tráfego principal do mestre para o servidor de backup, e ele já estará carregado.  Essa sobrecarga tornará seu sistema terrivelmente lento ou o desativará completamente. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9t/py/la/9tpylanqp3whk7tcr4csdln6yo0.png" width="300"></div><br><h3>  Dados </h3><br>  O principal problema ao adicionar tolerância a falhas em um serviço é o estado local.  Se o seu serviço for sem estado, ou seja, não armazena dados mutáveis, a sua escala não apresenta um problema.  Nós apenas levantamos quantas instâncias precisamos e equilibramos as solicitações entre elas. <br><br>  No caso em que o serviço é estável, não podemos mais fazer isso.  Você precisa pensar em como armazenar os mesmos dados em todas as instâncias do nosso serviço para que eles permaneçam consistentes. <br><br>  Para resolver esse problema, uma das duas abordagens é usada: replicação síncrona ou assíncrona.  No caso geral, recomendo que você use a opção assíncrona, pois geralmente é mais simples e rápido escrever e, de acordo com as circunstâncias, verifique se você precisa mudar para síncrono. <br><br>  Uma nuance importante a considerar ao trabalhar com replicação assíncrona é a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">consistência eventual</a> .  Isso significa que, em um determinado momento no tempo em diferentes escravos, os dados podem ficar para trás do mestre em intervalos de tempo imprevisíveis e diferentes. <br>  Assim, você não pode ler dados todas as vezes em um servidor aleatório, porque respostas diferentes podem chegar às mesmas solicitações do usuário.  Para contornar esse problema, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">é usado</a> o mecanismo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sessões fixas</a> , o que garante que todas as solicitações de um usuário vão para uma instância. <br><br>  As vantagens de uma abordagem síncrona são que os dados estão sempre em um estado consistente e o risco de perda de dados é menor (porque é considerado gravado somente depois de todos os servidores).  No entanto, você deve pagar por isso com a velocidade de gravação e a complexidade do próprio sistema (por exemplo, vários algoritmos de quorum para proteção contra o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cérebro dividido</a> ). <br><br><h3>  Conclusões </h3><br><ul><li>  <b>Reserve.</b>  Se os dados em si e a disponibilidade de um serviço específico forem importantes, verifique se o serviço sobreviverá à queda de uma máquina específica. <br></li><li>  <b>Ao calcular a carga, considere a queda de alguns servidores.</b>  Se o cluster tiver quatro servidores, verifique se, quando um cai, os três restantes puxam a carga. <br></li><li>  <b>Escolha o tipo de replicação, dependendo das tarefas.</b> <br></li><li>  <b>Não coloque todos os seus ovos em uma cesta.</b>  Verifique se você está distante o suficiente dos servidores.  Dependendo da criticidade da disponibilidade do serviço, seus servidores podem estar em diferentes racks em um data center ou em diferentes data centers em diferentes países.  Tudo depende de quanto desastre global você deseja e está pronto para sobreviver. <br></li></ul><br><h2>  Serviço de silêncio </h2><br>  Em algum momento, seu serviço pode começar a funcionar muito lentamente.  Esse problema pode ocorrer por vários motivos: carga excessiva, atrasos na rede, problemas de hardware ou erros de código.  Parece um problema não tão terrível, mas na verdade é mais insidioso do que parece. <br><br>  Imagine: um usuário solicita uma página.  Acessamos simultânea e sequencialmente os quatro demônios para desenhá-lo.  Eles respondem rapidamente, tudo funciona bem. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vo/u9/q5/vou9q5svtrqqptnxti-vkeuhmbm.png" width="400"></div><br>  Suponha que este caso seja tratado usando nginx com um número fixo de trabalhadores do PHP FPM (com dez, por exemplo).  Se cada solicitação for processada por aproximadamente 20 ms, com a ajuda de cálculos simples, pode-se entender que nosso sistema é capaz de processar cerca de quinhentas solicitações por segundo. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tq/h2/o2/tqh2o239lvw7qiobm8scwzrjma4.png" width="450"></div><br>  O que acontece quando um desses quatro serviços começa a ficar embotado e o processamento de solicitações para ele aumenta de 20 ms para um tempo limite de 1000 ms?  É importante lembrar que, quando trabalhamos com a rede, o atraso pode ser infinitamente grande.  Portanto, você sempre deve definir um tempo limite (nesse caso, é igual a um segundo). <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/uq/ae/rnuqaevpyknuwpgd9a94oygknia.png" width="400"></div><br>  Acontece que o back-end é forçado a aguardar o tempo limite expirar e receber e processar o erro do daemon.  Isso significa que o usuário recebe a página em um segundo em vez de dez milissegundos.  Lento, mas não fatal. <br><br>  Mas qual é o verdadeiro problema aqui?  O fato é que, quando temos todas as solicitações processadas por segundo, a taxa de transferência cai tragicamente para dez solicitações por segundo.  E o décimo primeiro usuário não poderá mais obter uma resposta, mesmo que ele tenha solicitado uma página que não esteja de modo algum associada a um serviço sem graça.  Só porque todos os dez funcionários estão aguardando um tempo limite e não podem processar novas solicitações. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sk/tn/dz/sktndzfsfdbjsgobqxmm5sy_xkw.png" width="450"></div><br>  É importante entender que esse problema não pode ser resolvido aumentando o número de trabalhadores.  Afinal, cada trabalhador exige uma certa quantidade de RAM para o seu trabalho, mesmo que ele não execute um trabalho real, mas simplesmente trava na expectativa de um tempo limite.  Portanto, se você não limitar o número de trabalhadores de acordo com os recursos do seu servidor, aumentar cada vez mais novos trabalhadores colocará o servidor inteiro.  Este caso é um exemplo de falha em cascata, quando a queda de qualquer serviço, mesmo que não seja crítica para o usuário, causa uma falha em todo o sistema. <br><br><h3>  Solução </h3><br>  Existe um padrão chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">disjuntor</a> .  Sua tarefa é bastante simples: ele deve, em algum momento, reduzir um serviço monótono.  Para isso, um proxy é colocado entre o serviço e os trabalhadores.  Pode ser um código PHP com armazenamento ou um daemon no host local.  É importante observar que, se você tiver várias instâncias (seu serviço é replicado), esse proxy deverá rastrear separadamente cada uma delas. <br><br>  Escrevemos nossa implementação desse padrão.  Mas não porque gostamos de escrever código, mas porque quando resolvemos esse problema há muitos anos, não havia soluções prontas. <br><br>  Agora, descreverei em termos gerais sobre nossa implementação e como isso ajuda a evitar esse problema.  E mais sobre ela e suas diferenças em relação a outras soluções podem ser ouvidas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em um relatório de Mikhail Kurmaev na Highload Siberia</a> no final de junho.  A transcrição de seu relatório também estará neste blog. <br><br>  Parece algo como isto: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dz/em/-d/dzem-dkkbiq6qx04cknxzdo99bc.png" width="500"></div><br>  Existe um serviço Sphinx abstrato, que é enfrentado por um disjuntor.  O disjuntor armazena o número de conexões ativas para um daemon específico.  Assim que esse valor atinge o limite, que definimos como uma porcentagem dos trabalhadores disponíveis do FPM na máquina, acreditamos que o serviço começou a ficar mais lento.  Ao atingir o primeiro limite, enviamos uma notificação para a pessoa responsável pelo serviço.  Tal situação é um sinal de que os limites precisam ser revistos ou um indicador de problemas de embotamento. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_g/ou/k6/_gouk6h_xfurcn_o04rslmiwsh8.png" width="500"></div><br>  Se a situação piorar e o número de trabalhadores inibidores atingir o segundo valor limite - em nossa produção, é de cerca de 10% -, reduzimos completamente esse host.  Mais precisamente, o serviço realmente continua a funcionar, mas paramos de enviar solicitações para ele.  O navegador do Circuit os rejeita e imediatamente dá um erro aos trabalhadores, como se o serviço estivesse mentindo. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/co/ao/pd/coaopdx7tp0swvu8qu0t01jf81u.png" width="500"></div><br>  Periodicamente, pulamos automaticamente uma solicitação de um trabalhador para ver se o serviço ganhou vida.  Se ele responder adequadamente, nós o incluiremos novamente no trabalho. <br><br>  Tudo isso é feito para reduzir a situação ao esquema de replicação anterior.  Em vez de esperar um segundo antes de perceber que o host está indisponível, imediatamente obtemos um erro e vamos para o host de backup. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9c/s8/iz/9cs8iz-aepaztqroslluwwregt0.png" width="400"></div><br><br><h3>  Implementações </h3><br>  Felizmente, o Open Source não fica parado e hoje você pode usar uma solução pronta para usar no Github. <br><br>  Existem duas abordagens principais para implementar o disjuntor: uma biblioteca em nível de código e um daemon independente que solicita proxies por meio de si mesmo. <br><br>  A opção com a biblioteca é mais adequada se você tiver um monólito principal em PHP, que interage com vários serviços, e os serviços quase não se comunicam.  Aqui estão algumas implementações disponíveis: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ganesha</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Disjuntor PHP</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Phystrix</a> <br></li></ul><br>  Se você tiver muitos serviços em idiomas diferentes e todos interagirem, a opção no nível do código deverá ser duplicada em todos esses idiomas.  Isso é inconveniente no suporte e, finalmente, leva a diferenças nas implementações. <br><br>  Colocar um daemon nesse caso é muito mais fácil.  Nesse caso, você não precisa editar especialmente o código.  O demônio está tentando tornar a interação transparente.  No entanto, essa opção é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muito mais complicada em termos de arquitetura</a> . <br><br>  Aqui estão algumas opções (a funcionalidade é mais rica lá, mas também há um disjuntor): <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Enviado</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Linkerd</a> <br></li></ul><br><h3>  Conclusões </h3><br><ul><li>  Não confie na rede. <br></li><li>  Todas as solicitações de rede devem ter um tempo limite, porque a rede pode demorar infinitamente. <br></li><li>  Use um disjuntor se desejar evitar falhas de aplicativos em cascata devido ao fato de um pequeno serviço ficar mais lento. <br></li></ul><br><h2>  Monitoramento e telemetria </h2><br><h3>  O que isso dá </h3><br><ul><li>  <b>Previsibilidade.</b>  É importante prever qual é a carga e o que será em um mês para aumentar atempadamente o número de instâncias de serviço.  Isso é especialmente verdadeiro se você estiver lidando com uma infraestrutura de ferro, pois a encomenda de novos servidores leva tempo. </li><li>  <b>Investigação de incidentes.</b>  Mais cedo ou mais tarde, algo vai dar errado de qualquer maneira, e você terá que investigá-lo.  E é importante ter dados suficientes para entender o problema e ser capaz de evitar essas situações no futuro. </li><li>  <b>Prevenção de acidentes.</b>  Idealmente, você deve entender quais padrões levam a falhas.  É importante acompanhar esses padrões e notificar a equipe sobre eles em tempo hábil. </li></ul><br><br><h3>  O que medir </h3><br>  <b>Métricas de integração</b> <br><br>  Como estamos falando da interação entre serviços, monitoramos tudo o que é possível em relação à comunicação do serviço com o aplicativo.  Por exemplo: <br><br><ul><li>  número de solicitações; <br></li><li>  tempo de processamento da solicitação (incluindo percentis); <br></li><li>  número de erros lógicos; <br></li><li>  número de erros do sistema. <br></li></ul><br>  É importante distinguir erros lógicos dos erros do sistema.  Se o serviço cair, é uma situação regular: simplesmente mudamos para o segundo.  Mas não é tão assustador.  Se você iniciar algum tipo de erro lógico, por exemplo, dados estranhos entram no serviço ou os deixam, então isso já precisa ser investigado.  Provavelmente, o erro está relacionado a um erro no código.  Ela própria não vai passar. <br><br>  <b>Métricas internas</b> <br><br>  Por padrão, o serviço é uma caixa preta que faz seu trabalho de maneira incompreensível.  Ainda é desejável entender e coletar o máximo de dados que o serviço pode fornecer.  Se o serviço for um banco de dados especializado que armazena alguns dados da lógica de negócios, acompanhe exatamente quantos dados, qual o tipo e outras métricas de conteúdo.  Se você tiver interação assíncrona, também é importante monitorar as filas pelas quais o serviço se comunica: velocidade de chegada e partida, horário em diferentes estágios (se você tiver vários pontos intermediários), número de eventos na fila. <br><br>  Vamos ver quais métricas podem ser coletadas usando o memcached como exemplo: <br><br><ul><li>  taxa de acerto / erro; <br></li><li>  tempo de resposta para várias operações; <br></li><li>  RPS de várias operações; <br></li><li>  discriminação dos mesmos dados em chaves diferentes; <br></li><li>  chaves com carregamento superior; <br></li><li>  todas as métricas internas fornecidas pelo comando stats. <br></li></ul><br><br><h3>  Como fazer </h3><br>  Se você tem uma empresa pequena, um projeto pequeno e poucos servidores, é uma boa solução conectar algum tipo de SaaS para coletar e visualizar - é mais fácil e mais barato.  Nesse caso, geralmente o SaaS possui uma funcionalidade abrangente e não precisa se preocupar com muitas coisas.  Exemplos de tais serviços: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Datadog</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rollbar</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nova relíquia</a> <br></li></ul><br>  Como alternativa, você sempre pode instalar o Zabbix, Grafana ou qualquer outra solução auto-hospedada em sua própria máquina. <br><br><h3>  Conclusões </h3><br><ul><li>  <b>Colete todas as métricas que puder.</b>  Os dados não são supérfluos.  Quando você tiver que investigar alguma coisa, agradecerá sua premissa. </li><li>  <b>Não se esqueça da interação assíncrona.</b>  Se você possui linhas que alcançam gradualmente, é importante entender a rapidez com que atingem, o que acontece com seus eventos no cruzamento entre os serviços. </li><li>  <b>Se você escrever seu serviço, ensine-o a fornecer estatísticas sobre o trabalho.</b>  Parte dos dados pode ser medida na camada de integração quando nos comunicamos com este serviço.  O restante do serviço deve poder fornecer estatísticas de acordo com o comando condicional.  Por exemplo, em todos os nossos serviços on Go, essa funcionalidade é padrão. </li><li>  <b>Personalize gatilhos.</b>  <b>Os gráficos são bons, mas apenas enquanto você os olha.</b>  É importante que você tenha um sistema personalizado que informará se algo der errado. </li></ul><br><h2>  Memento mori </h2><br>  E agora um pouco sobre coisas tristes.  Você pode ter a sensação de que o exposto acima é uma panacéia e agora nada cairá.  Mas, mesmo que você aplique tudo o que foi descrito acima, algo cairá.  É importante considerar isso. <br>  As razões para a queda são muitas.  Por exemplo, você pode escolher um esquema de replicação insuficientemente paranóico.  Um meteorito caiu no seu data center e depois no segundo.  Ou você acabou de implantar o código com um erro complicado que apareceu inesperadamente. <br><br>  Por exemplo, no Badoo, há uma página "Pessoas próximas".  Lá, os usuários pesquisam outras pessoas próximas para conversar com eles. <br><br><img src="https://habrastorage.org/webt/3q/l4/xm/3ql4xmmqeobxu4vsrqygagstflw.png"><br><br>  Agora, para renderizar a página, o back-end faz chamadas síncronas para cerca de sete serviços.  Para maior clareza, reduza esse número para dois.  Um serviço é responsável por renderizar o bloco central com fotos.  O segundo é para o bloco de publicidade no canto inferior esquerdo.  Quem quiser se tornar mais visível pode chegar lá.  Se temos um serviço que exibe esse anúncio, o bloco simplesmente desaparece. <br><br><img src="https://habrastorage.org/webt/rg/tu/pj/rgtupjtztftw7pgvxpwg7auwa1q.png"><br><br>  A maioria dos usuários nem sabe desse fato: nossa equipe responde rapidamente e logo o bloco reaparece. <br><br>  Mas nem todas as funcionalidades que podemos remover silenciosamente.  Se perdermos o serviço responsável pela parte central da página, isso não funcionará para ocultar.  Portanto, é importante informar ao usuário em seu idioma o que está acontecendo. <br><br><img src="https://habrastorage.org/webt/eh/1q/c3/eh1qc3sr6laokkydqscq_ydilue.png"><br><br>  Também é desejável que a falha de um serviço não leve a uma falha em cascata.  Para cada serviço, é necessário escrever um código que lide com a queda, caso contrário, o aplicativo poderá falhar como um todo. <br><br>  Mas isso não é tudo.  Às vezes, algo cai, sem o qual você não pode viver de forma alguma.  Por exemplo, um banco de dados central ou serviço de sessão.  É importante resolvê-lo corretamente e mostrar ao usuário algo adequado, de alguma forma entretê-lo, para dizer que tudo está sob controle.  Ao mesmo tempo, é importante que tudo esteja realmente sob controle e os monitores sejam notificados do problema. <br><br><img src="https://habrastorage.org/webt/e6/hs/wt/e6hswt9cdlv2kfnt47zuujzyoyq.png"><br><br><img src="https://habrastorage.org/webt/lr/ch/g9/lrchg9mdfortw-jjnzi9ejdzr8u.png"><br><br><h3>  Morrer tão certo </h3><br><ul><li>  <b>Prepare-se para o outono.</b>  Não há bala de prata; portanto, sempre coloque canudos caso o serviço caia completamente, mesmo se você usar redundância. </li><li>  <b>Evite falhas em cascata</b> quando problemas com um dos serviços matam o aplicativo inteiro. </li><li>  <b>Desative a funcionalidade não crítica do usuário.</b>  Isso é normal.  Muitos serviços são usados ​​apenas para necessidades internas e não afetam a funcionalidade fornecida.  Por exemplo, um serviço de estatísticas.  Não importa para o usuário se as estatísticas são coletadas de você ou não.  É importante para ele que o site funcione. </li></ul><br><h2>  Sumário </h2><br>  Para integrar de forma confiável o novo serviço ao sistema, escrevemos uma API de wrapper especial em torno dele no Badoo, que executa as seguintes tarefas: <br><br><ul><li>  balanceamento de carga; </li><li>  timeouts; </li><li>  failover lógico; </li><li>  disjuntor; </li><li>  monitoramento e telemetria; </li><li>  lógica de autorização; </li><li>  serialização e desserialização de dados. </li></ul><br>  É melhor garantir que todos esses itens também sejam abordados na sua camada de integração.  Especialmente se você estiver usando um cliente API de código-fonte pronto.  É importante lembrar que a camada de integração é uma fonte de maior risco de falha em cascata do seu aplicativo. <br><br>  Obrigado pela atenção! <br><br>  <b>Literatura</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Solte-o!</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Engenharia de confiabilidade do site</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criando microsserviços</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413555/">https://habr.com/ru/post/pt413555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413545/index.html">Humor na marca - por que nem sempre é bom</a></li>
<li><a href="../pt413547/index.html">Experimente 2 milhões de sessões sem cabeça</a></li>
<li><a href="../pt413549/index.html">Curso de Desenvolvimento Web</a></li>
<li><a href="../pt413551/index.html">Rolagem e atenção (estudo de 2018)</a></li>
<li><a href="../pt413553/index.html">O registrador REG.RU privou o parceiro de acesso a 70 mil domínios e levou o serviço para si</a></li>
<li><a href="../pt413557/index.html">NewSQL: SQL não vai a lugar nenhum</a></li>
<li><a href="../pt413559/index.html">Degradação da Web ou como tornar a Web legível para humanos</a></li>
<li><a href="../pt413561/index.html">Velocidade da árvore de expressão Linq compilada</a></li>
<li><a href="../pt413563/index.html">4 maneiras de importar um pacote para o Go</a></li>
<li><a href="../pt413565/index.html">Análise de hackers do Kubernetes - backdoor via kubelet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>