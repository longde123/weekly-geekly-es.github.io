<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏻 🕧 👩🏿‍🤝‍👩🏽 Asynchrone JavaScript-Programmierung (Callback, Promise, RxJs) 🕵🏿 👩🏾‍🏫 🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. In Kontakt Omelnitsky Sergey. Vor nicht allzu langer Zeit leitete ich einen reaktiven Programmierstrom, in dem ich über Asynchronität i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchrone JavaScript-Programmierung (Callback, Promise, RxJs)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462355/"><p>  Hallo an alle.  In Kontakt Omelnitsky Sergey.  Vor nicht allzu langer Zeit leitete ich einen reaktiven Programmierstrom, in dem ich über Asynchronität in JavaScript sprach.  Heute möchte ich dieses Material skizzieren. </p><br><p><img src="https://habrastorage.org/webt/oq/x0/s1/oqx0s1ukuyf6izyu-5cxkd9cd-m.png"></p><br><p>  Bevor wir jedoch mit dem Hauptmaterial beginnen, müssen wir eine Einführung machen.  Beginnen wir also mit den Definitionen: Was ist der Stapel und die Warteschlange? </p><br><p>  <strong>Ein Stapel</strong> ist eine Sammlung, deren Elemente nach dem Prinzip "last in, first out" LIFO empfangen werden </p><br><p>  <strong>Eine Warteschlange</strong> ist eine Sammlung, deren Elemente nach dem Prinzip empfangen werden (FIFO „Wer zuerst kommt, mahlt zuerst“) </p><br><p>  Ok, lass uns weitermachen. </p><br><p><img src="https://habrastorage.org/webt/xk/dt/rr/xkdtrrm0vasdzlva2iqgrpjmwuk.png"></p><br><p>  JavaScript ist eine Single-Threaded-Programmiersprache.  Dies bedeutet, dass es nur einen Ausführungsthread und einen Stapel gibt, in dem Funktionen zur Ausführung in die Warteschlange gestellt werden.  Daher kann JavaScript zu einem bestimmten Zeitpunkt nur eine Operation ausführen, während andere Operationen darauf warten, dass sie den Stapel einschalten, bis sie aufgerufen werden. </p><a name="habracut"></a><br><p>  <strong>Der Aufrufstapel</strong> ist eine Datenstruktur, die in einfachen Worten Informationen über die Stelle im Programm aufzeichnet, an der wir uns befinden.  Wenn wir in eine Funktion gehen, setzen wir einen Datensatz darüber oben auf den Stapel.  Wenn wir von der Funktion zurückkehren, ziehen wir das oberste Element aus dem Stapel und befinden uns dort, wo wir diese Funktion aufgerufen haben.  Dies ist alles, was der Stapel tun kann.  Und jetzt eine äußerst interessante Frage.  Wie funktioniert dann Asynchronität in JavasScript? </p><br><p><img src="https://habrastorage.org/webt/h2/-x/aj/h2-xajggqa9vcloczh7owhqiffc.png"></p><br><p>  Zusätzlich zum Stapel haben Browser eine spezielle Warteschlange für die Arbeit mit der sogenannten WebAPI.  Funktionen aus dieser Warteschlange werden erst ausgeführt, nachdem der Stapel vollständig gelöscht wurde.  Erst danach werden sie zur Ausführung aus der Warteschlange auf den Stapel geschoben.  Befindet sich derzeit mindestens ein Element auf dem Stapel, können sie nicht auf den Stapel gelangen.  Genau aus diesem Grund ist das Aufrufen von Funktionen nach Zeitüberschreitung häufig zeitlich nicht genau, da eine Funktion nicht von der Warteschlange zum Stapel wechseln kann, solange sie voll ist. </p><br><p>  Betrachten Sie das folgende Beispiel und führen Sie die schrittweise „Ausführung“ durch.  Sehen Sie auch, was im System passiert. </p><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hi'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cb1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'cb1'</span></span>); }, <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Bye'</span></span>);</code> </pre> <br><p><img src="https://habrastorage.org/webt/tg/i-/xf/tgi-xfd5vxrjxltraxp4o7uhiki.png"></p><br><p>  1) Bisher passiert nichts.  Die Browserkonsole ist sauber, der Aufrufstapel ist leer. </p><br><p><img src="https://habrastorage.org/webt/v4/et/uh/v4etuhvfo-eltv08fhxv1bqx1a0.png"></p><br><p>  2) Anschließend wird der Befehl console.log ('Hi') zum Aufrufstapel hinzugefügt. </p><br><p><img src="https://habrastorage.org/webt/ns/-k/-k/ns-k-klle5egqpwjdzbgxkrwaes.png"></p><br><p>  3) Und es wird ausgeführt </p><br><p><img src="https://habrastorage.org/webt/dp/oo/tz/dpootztdu0jjapitb1v60dzwdcu.png"></p><br><p>  4) Dann wird console.log ('Hi') vom Aufrufstapel entfernt. </p><br><p><img src="https://habrastorage.org/webt/fu/yb/wb/fuybwb7kq0kcxdj4gobj38-r_fc.png"></p><br><p>  5) Gehen Sie nun zum Befehl setTimeout (Funktion cb1 () {...}).  Es wird dem Aufrufstapel hinzugefügt. </p><br><p><img src="https://habrastorage.org/webt/85/ps/v2/85psv2_s7ec0ibxh8h2991nbxi4.png"></p><br><p>  6) Der Befehl setTimeout (Funktion cb1 () {...}) wird ausgeführt.  Der Browser erstellt einen Timer, der Teil der Web-API ist.  Er wird den Countdown machen. </p><br><p><img src="https://habrastorage.org/webt/3a/4p/sh/3a4pshoazrkbxfgcajwjqm1cz-m.png"></p><br><p>  7) Der Befehl setTimeout (Funktion cb1 () {...}) wurde abgeschlossen und aus dem Aufrufstapel entfernt. </p><br><p><img src="https://habrastorage.org/webt/oe/qt/ne/oeqtnemv7rawkjpanipkv41qpeq.png"></p><br><p>  8) Der Befehl console.log ('Bye') wird dem Aufrufstapel hinzugefügt. </p><br><p><img src="https://habrastorage.org/webt/bb/mp/fb/bbmpfba1p2tadcztfm-41py_mgi.png"></p><br><p>  9) Der Befehl console.log ('Bye') wird ausgeführt. </p><br><p><img src="https://habrastorage.org/webt/d0/ra/3z/d0ra3zfarz4ujmyy46cmsofs8ue.png"></p><br><p>  10) Der Befehl console.log ('Bye') wird aus dem Aufrufstapel entfernt. </p><br><p><img src="https://habrastorage.org/webt/5y/by/dr/5ybydrdk6yuexhgyhbxwsvnkefa.png"></p><br><p>  11) Nach mindestens 5000 ms wird der Timer beendet und der cb1-Rückruf in die Rückrufwarteschlange gestellt. </p><br><p><img src="https://habrastorage.org/webt/sx/of/no/sxofnovn3xkkz5oyngnotdggpcs.png"></p><br><p>  12) Die Ereignisschleife nimmt c die Funktion cb1 aus der Rückrufwarteschlange und legt sie auf dem Aufrufstapel ab. </p><br><p><img src="https://habrastorage.org/webt/ge/qp/1t/geqp1t65hnddi0hx0ut4b80ooi0.png"></p><br><p>  13) Die Funktion cb1 wird ausgeführt und fügt console.log ('cb1') zum Aufrufstapel hinzu. </p><br><p><img src="https://habrastorage.org/webt/xi/vq/ac/xivqac36m7yv79qocvstugftlb4.png"></p><br><p>  14) Der Befehl console.log ('cb1') wird ausgeführt. </p><br><p><img src="https://habrastorage.org/webt/hp/tu/gk/hptugkn_5iizvyhez25bpf8zvpy.png"></p><br><p>  15) Der Befehl console.log ('cb1') wird aus dem Aufrufstapel entfernt. </p><br><p><img src="https://habrastorage.org/webt/bh/wr/st/bhwrstroipmqqhrhiit4cmdy-we.png"></p><br><p>  16) Die Funktion cb1 wird aus dem Aufrufstapel entfernt. </p><br><p>  Schauen Sie sich ein Beispiel in der Dynamik an: </p><br><p><img src="https://habrastorage.org/webt/xx/nj/a8/xxnja8sfjhdg5ks3ku5q6yzkxvc.gif"></p><br><p>  Hier haben wir untersucht, wie Asynchronität in JavaScript implementiert ist.  Lassen Sie uns nun kurz über die Entwicklung des asynchronen Codes sprechen. </p><br><h2 id="evolyuciya-asinhronnogo-koda">  Die Entwicklung des asynchronen Codes. </h2><br><pre> <code class="javascript hljs">a(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromA</span></span></span><span class="hljs-function">) </span></span>{ b(resultsFromA, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromB</span></span></span><span class="hljs-function">) </span></span>{ c(resultsFromB, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromC</span></span></span><span class="hljs-function">) </span></span>{ d(resultsFromC, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromD</span></span></span><span class="hljs-function">) </span></span>{ e(resultsFromD, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromE</span></span></span><span class="hljs-function">) </span></span>{ f(resultsFromE, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromF</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resultsFromF); }) }) }) }) }) });</code> </pre> <br><p>  Asynchrone Programmierung, wie wir sie in JavaScript kennen, kann nur mit Funktionen implementiert werden.  Sie können wie jede andere Variable an andere Funktionen übergeben werden.  So wurden die Rückrufe geboren.  Und es ist cool, lustig und provokativ, bis es sich in Traurigkeit, Sehnsucht und Traurigkeit verwandelt.  Warum?  Ja, alles ist einfach: </p><br><ul><li>  Mit der zunehmenden Komplexität des Codes verwandelt sich das Projekt schnell in obskure, wiederholt verschachtelte Blöcke - „Callback Hell“. </li><li>  Fehlerbehandlung kann leicht übersehen werden. </li><li>  Sie können keine Ausdrücke mit return zurückgeben. </li></ul><br><p>  Mit Promise wurde es etwas besser. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">2000</span></span>); }).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { alert(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + <span class="hljs-number"><span class="hljs-number">2</span></span>; }).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'FAILED HERE'</span></span>); alert(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + <span class="hljs-number"><span class="hljs-number">2</span></span>; }).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { alert(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + <span class="hljs-number"><span class="hljs-number">2</span></span>; }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'error: '</span></span>, e); });</code> </pre> <br><ul><li>  Es erschienen Versprechensketten, die die Lesbarkeit des Codes verbesserten </li><li>  Eine separate Fehlerüberwachungsmethode wurde angezeigt </li><li>  Jetzt können Sie mit Promise.all parallel ausführen </li><li>  Wir können verschachtelte Asynchronität mit async / await lösen </li></ul><br><p>  Aber Promis hat seine Grenzen.  Zum Beispiel kann ein Versprechen, ohne mit einem Tamburin zu tanzen, nicht rückgängig gemacht werden, und vor allem funktioniert es mit einem Wert. </p><br><p>  Nun, wir näherten uns reibungslos der reaktiven Programmierung.  Bist du müde  Das Gute ist, dass Sie ein paar Möwen machen, nachdenken und zurückkehren können, um weiterzulesen.  Und ich werde weitermachen. </p><br><p><img src="https://habrastorage.org/webt/pj/0g/7b/pj0g7bgonkiefme08noahs3y0wc.png" alt="Grundlagen der reaktiven Programmierung"></p><br><p>  <strong>Reaktive Programmierung</strong> ist ein Programmierparadigma, das sich auf Datenflüsse und die Ausbreitung von Veränderungen konzentriert.  Schauen wir uns einen Datenstrom genauer an. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     const input = ducument.querySelector('input'); const eventsArray = []; //      eventsArray input.addEventListener('keyup', event =&gt; eventsArray.push(event) );</span></span></code> </pre> <br><p>  Stellen Sie sich vor, wir haben ein Eingabefeld.  Wir erstellen ein Array und speichern das Ereignis für jedes Keyup des Eingabeereignisses in unserem Array.  In diesem Fall möchte ich darauf hinweisen, dass unser Array nach Zeit sortiert ist, d.h.  Der Index späterer Ereignisse ist größer als der Index früherer Ereignisse.  Ein solches Array ist ein vereinfachtes Datenstrommodell, aber noch kein Stream.  Damit dieses Array sicher als Stream bezeichnet werden kann, muss es die Teilnehmer irgendwie darüber informieren können, dass es neue Daten erhalten hat.  Wir kommen also zur Definition des Flusses. </p><br><h3 id="potok-dannyh">  Datenstrom </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { interval } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( take(<span class="hljs-number"><span class="hljs-number">4</span></span>) )</code> </pre> <br><p><img src="https://habrastorage.org/webt/iu/oe/9k/iuoe9k_c75atoryyrxykddnhuzi.gif"></p><br><p>  <strong>Ein Stream</strong> ist ein nach Zeit sortiertes Datenarray, das anzeigen kann, dass sich die Daten geändert haben.  Stellen Sie sich nun vor, wie bequem es ist, Code zu schreiben, in dem Sie mehrere Ereignisse in verschiedenen Teilen des Codes in einer Aktion auslösen müssen.  Wir abonnieren einfach den Stream und er wird uns wissen lassen, wann die Änderungen eintreten.  Und die RxJs-Bibliothek kann dies tun. </p><br><p><img src="https://habrastorage.org/webt/2e/eg/cv/2eegcvxzcaz0j6x_n27h7nko68s.png"></p><br><p>  <strong>RxJS</strong> ist eine Bibliothek für die Arbeit mit asynchronen und ereignisbasierten Programmen unter Verwendung beobachtbarer Sequenzen.  Die Bibliothek bietet den Haupttyp von <em>Observable</em> , verschiedene Hilfstypen ( <em>Observer, Scheduler, Subjects</em> ) und Operatoren für die Arbeit mit Ereignissen wie bei Sammlungen ( <em>Map, Filter, Reduce, alles</em> und dergleichen aus JavaScript Array). </p><br><p>  Schauen wir uns die Grundkonzepte dieser Bibliothek an. </p><br><h3 id="observable-observer-producer">  Beobachtbar, Beobachter, Produzent </h3><br><p>  Observable ist der erste Grundtyp, den wir betrachten werden.  Diese Klasse enthält den Großteil der RxJ-Implementierung.  Es ist einem beobachtbaren Stream zugeordnet, den Sie beide mit der Subscribe-Methode abonnieren können. </p><br><p>  Observable implementiert einen Hilfsmechanismus zum Erstellen von Updates, den sogenannten <em>Observer</em> .  Die Quelle der Werte für Observer heißt <em>Producer</em> .  Dies kann ein Array, ein Iterator, ein Web-Socket, eine Art Ereignis usw. sein.  Wir können also sagen, dass Observable ein Dirigent zwischen Produzent und Beobachter ist. </p><br><p>  Observable behandelt drei Arten von Observer-Ereignissen: </p><br><ul><li>  next - neue Daten </li><li>  Fehler - Ein Fehler, wenn die Sequenz aufgrund einer Ausnahme beendet wurde.  Dieses Ereignis beinhaltet auch die Vervollständigung der Sequenz. </li><li>  complete - Signal über den Abschluss der Sequenz.  Dies bedeutet, dass keine neuen Daten vorhanden sind. </li></ul><br><p>  Schauen wir uns die Demo an: </p><br><p><img src="https://habrastorage.org/webt/mg/qn/pf/mgqnpfxctqlz3yqwseag1fqttrc.gif"></p><br><p>  Zu Beginn werden wir die Werte 1, 2, 3 und nach 1 Sek. Verarbeiten.  Wir werden 4 bekommen und unseren Fluss beenden. </p><br><div class="spoiler">  <b class="spoiler_title">Lautes Denken</b> <div class="spoiler_text"><p>  Und dann wurde mir klar, dass das Erzählen interessanter war als darüber zu schreiben.  : D. </p></div></div><br><h3 id="subscription">  Abonnement </h3><br><p>  Wenn wir einen Stream abonnieren, erstellen wir eine neue <strong>Abonnementklasse</strong> , mit der wir uns mit der Methode zum Abbestellen <em>abmelden können</em> .  Wir können Abonnements auch mit der Methode <em>add</em> gruppieren.  Nun, es ist logisch, dass wir die Gruppierung der Threads mit <em>remove aufheben können</em> .  Die Eingabemethoden zum Hinzufügen und Entfernen akzeptieren ein anderes Abonnement.  Ich möchte darauf hinweisen, dass wir beim Abbestellen alle untergeordneten Abonnements abbestellen, als würden sie die Abmeldemethode aufrufen.  Mach weiter. </p><br><h3 id="vidy-potokov">  Arten von Streams </h3><br><div class="scrollable-table"><table><thead><tr><th>  HEISS </th><th>  KALT </th></tr></thead><tbody><tr><td>  Produzent außerhalb beobachtbar erstellt </td><td>  Produzent erstellt innerhalb beobachtbar </td></tr><tr><td>  Die Daten werden zum Zeitpunkt der Erstellung des Observablen übertragen. </td><td>  Die Daten werden zum Zeitpunkt des Abonnements gemeldet </td></tr><tr><td>  Benötigen Sie mehr Logik zum Abbestellen </td><td>  Der Thread wird von selbst beendet </td></tr><tr><td>  Verwendet eine Eins-zu-Viele-Kommunikation </td><td>  Verwendet eine Eins-zu-Eins-Beziehung </td></tr><tr><td>  Alle Abonnements haben den gleichen Wert. </td><td>  Abonnements sind unabhängig </td></tr><tr><td>  Daten können verloren gehen, wenn kein Abonnement besteht </td><td>  Gibt alle Stream-Werte für ein neues Abonnement erneut aus </td></tr></tbody></table></div><br><p>  Um eine Analogie zu geben, würde ich mir einen heißen Stream wie einen Film in einem Kino vorstellen.  Zu welchem ​​Zeitpunkt kamen Sie von diesem Moment an und begannen zu sehen.  Ich würde einen kalten Strom mit einem Anruf in diesen vergleichen.  Unterstützung.  Jeder Anrufer hört von Anfang bis Ende auf den Anrufbeantworter, aber Sie können auflegen, indem Sie sich abmelden. </p><br><p>  Ich möchte darauf hinweisen, dass es immer noch sogenannte Warmströme gibt (eine solche Definition habe ich sehr selten und nur in fremden Gemeinden getroffen) - dies ist ein Strom, der sich von einem kalten in einen heißen Strom verwandelt.  Es stellt sich die Frage - wo zu verwenden)) Ich werde ein Beispiel aus der Praxis geben. </p><br><p>  Ich arbeite mit einem Winkel.  Er benutzt aktiv rxjs.  Um Daten auf den Server zu übertragen, erwarte ich einen kalten Stream und verwende diesen Stream in der Vorlage mit asyncPipe.  Wenn ich diese Pipe mehrmals verwende, fordert jede Pipe, um zur Definition eines kalten Streams zurückzukehren, Daten vom Server an, was gelinde gesagt seltsam ist.  Und wenn ich einen kalten Strom in einen warmen umwandle, wird die Anfrage einmal gestellt. </p><br><p>  Im Allgemeinen ist das Verständnis der Form von Flüssen für Anfänger recht kompliziert, aber wichtig. </p><br><h3 id="operators">  Betreiber </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${environment.apiUrl}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.apiUrl}</span></span></span><span class="hljs-string">/trade_companies`</span></span>) .pipe( tap(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ data }: TradeCompanyList</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.companies$$.next(cloneDeep(data))), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ data }: TradeCompanyList</span></span></span><span class="hljs-function">) =&gt;</span></span> data) );</code> </pre> <br><p>  Operatoren bieten uns die Möglichkeit, mit Streams zu arbeiten.  Sie helfen bei der Steuerung von Ereignissen, die im Observable auftreten.  Wir werden einige der beliebtesten betrachten, und die Betreiber können über die Links in den nützlichen Informationen detaillierter gefunden werden. </p><br><p>  <strong>Betreiber - von</strong> </p><br><p>  Wir beginnen mit dem Hilfsoperator von.  Es wird ein Observable basierend auf einem einfachen Wert erstellt. </p><br><p><img src="https://habrastorage.org/webt/ty/gv/ns/tygvns2-ufljiud304keflcihtw.png"></p><br><p>  <strong>Operatoren - Filter</strong> </p><br><p><img src="https://habrastorage.org/webt/lu/ej/-q/luej-qu433z2ascmvk4avc9qg80.png"></p><br><p>  Der Filteroperatorfilter filtert, wie der Name schon sagt, das Stream-Signal.  Wenn der Operator true zurückgibt, wird weiter übersprungen. </p><br><p>  <strong>Betreiber - nehmen</strong> </p><br><p><img src="https://habrastorage.org/webt/n3/h-/p7/n3h-p7dnsmlrus2qxcid1k-j0sc.png"></p><br><p>  take - Nimmt den Wert der Anzahl der Emits an, nach denen der Stream endet. </p><br><p>  <strong>Operatoren - debounceTime</strong> </p><br><p><img src="https://habrastorage.org/webt/fm/-h/ov/fm-hovzqqm8setakpkxrq35220i.png"></p><br><p>  debounceTime - verwirft die ausgegebenen Werte, die in den angegebenen Zeitraum zwischen den Ausgabedaten fallen. Nach Ablauf des Zeitintervalls wird der letzte Wert ausgegeben. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { debounceTime, take } = RxOperators; Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; observer.next(i++); <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next(i++) }, 1000); //     1500 setInterval(() =&gt; { observer.next(i++) }, 1500); }).pipe( debounceTime(700), //  700     take(3) );</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/wq/c4/is/wqc4is_4memtbjbseivewpqsm3y.gif"></p><br><p>  <strong>Operatoren - takeWhile</strong> </p><br><p><img src="https://habrastorage.org/webt/be/_4/bw/be_4bwupgcjmlqubh0bnjfwaq3o.png"></p><br><p>  Es gibt Werte aus, bis takeWhile false zurückgibt. Danach wird der Stream abbestellt. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { debounceTime, takeWhile } = RxOperators; Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; observer.next(i++); <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next(i++) }, 1000); }).pipe( takeWhile( producer =&gt; producer &lt; 5 ) );</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/fj/yx/ht/fjyxhtlst2zizvmv6uoei5vi_bm.gif"></p><br><p>  <strong>Operatoren - kombinierenLetzte</strong> </p><br><p>  Der Operator kombinieren kombinierenLatest ähnelt etwas versprechen.all.  Es kombiniert mehrere Threads zu einem.  Nachdem jeder Thread mindestens eine Ausgabe durchgeführt hat, erhalten wir die letzten Werte von jedem in Form eines Arrays.  Darüber hinaus ergeben sich nach jeder Emission aus den kombinierten Flüssen neue Werte. </p><br><p><img src="https://habrastorage.org/webt/cg/lq/pj/cglqpjraurcow4xpusyfy-o-g1i.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { combineLatest, Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer_1 = Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next('a: ' + i++); }, 1000); }); const observer_2 = Observable.create((observer) =&gt; { let i = 1; //     750 setInterval(() =&gt; { observer.next('b: ' + i++); }, 750); }); combineLatest(observer_1, observer_2).pipe(take(5));</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/lx/f6/qc/lxf6qcp3uqlpezwwxzipibko8mw.gif"></p><br><p>  <strong>Bediener - Reißverschluss</strong> </p><br><p>  Zip - wartet auf einen Wert aus jedem Stream und bildet basierend auf diesen Werten ein Array.  Wenn der Wert nicht aus einem Stream stammt, wird die Gruppe nicht gebildet. </p><br><p><img src="https://habrastorage.org/webt/_w/uw/u5/_wuwu5ncu3ikb96iszphaeho1cu.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { zip, Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer_1 = Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next('a: ' + i++); }, 1000); }); const observer_2 = Observable.create((observer) =&gt; { let i = 1; //     750 setInterval(() =&gt; { observer.next('b: ' + i++); }, 750); }); const observer_3 = Observable.create((observer) =&gt; { let i = 1; //     500 setInterval(() =&gt; { observer.next('c: ' + i++); }, 500); }); zip(observer_1, observer_2, observer_3).pipe(take(5));</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/lr/iz/k2/lrizk28md9flrpm-5nkiioxlbw0.gif"></p><br><p>  <strong>Operatoren - forkJoin</strong> </p><br><p>  forkJoin verkettet auch Threads, gibt jedoch nur Werte an, wenn alle Threads vollständig sind. </p><br><p><img src="https://habrastorage.org/webt/kg/yn/i8/kgyni8bmucerz2-o015i4fnrlrg.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { forkJoin, Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer_1 = Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next('a: ' + i++); }, 1000); }).pipe(take(3)); const observer_2 = Observable.create((observer) =&gt; { let i = 1; //     750 setInterval(() =&gt; { observer.next('b: ' + i++); }, 750); }).pipe(take(5)); const observer_3 = Observable.create((observer) =&gt; { let i = 1; //     500 setInterval(() =&gt; { observer.next('c: ' + i++); }, 500); }).pipe(take(4)); forkJoin(observer_1, observer_2, observer_3);</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/34/ny/qn/34nyqnbve4g6gsheeoeaii1qkw0.gif"></p><br><p>  <strong>Operatoren - Karte</strong> </p><br><p>  Der Kartentransformationsoperator konvertiert den Ausgabewert in einen neuen. </p><br><p><img src="https://habrastorage.org/webt/z5/cq/gn/z5cqgnureeelbyknte8aohlkjyo.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take, map } = RxOperators; Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next(i++); }, 1000); }).pipe( map(x =&gt; x * 10), take(3) );</span></span></code> </pre><br><p><img src="https://habrastorage.org/webt/zy/fz/az/zyfzazyep10bcow9f1nxzumq8nk.gif"></p><br><p>  <strong>Operatoren - teilen, tippen</strong> </p><br><p>  Mit dem Tap-Operator können Sie Nebenwirkungen ausführen, dh alle Aktionen, die die Sequenz nicht beeinflussen. </p><br><p>  Der Utility-Share-Betreiber kann es aus einem kalten Strom heiß machen. </p><br><p><img src="https://habrastorage.org/webt/2p/lc/fr/2plcfr9agwst3elkl_yglmmfftk.png"></p><br><p>  Mit den Bedienern fertig.  Fahren wir mit dem Thema fort. </p><br><div class="spoiler">  <b class="spoiler_title">Lautes Denken</b> <div class="spoiler_text"><p>  Und dann ging ich ein paar Möwen trinken.  Diese Beispiele langweilten mich: D. </p></div></div><br><h2 id="semeystvo-subject-ov">  Fachfamilie </h2><br><p>  Die Themenfamilie ist ein Paradebeispiel für heiße Streams.  Diese Klassen sind eine Art Hybrid, die gleichzeitig als beobachtbar und beobachtend fungieren.  Da es sich bei dem Betreff um einen heißen Stream handelt, müssen Sie ihn abbestellen.  Wenn wir über die grundlegenden Methoden sprechen, dann ist dies: </p><br><ul><li>  next - Übertragung neuer Daten in den Stream </li><li>  Fehler - Fehler und Beendigung des Streams </li><li>  vollständig - Beendigung des Streams </li><li>  Abonnieren - Abonnieren Sie den Stream </li><li>  Abbestellen - Abbestellen vom Stream </li><li>  asObservable - verwandeln Sie sich in einen Beobachter </li><li>  toPromise - verwandelt sich in ein Versprechen </li></ul><br><p>  Zuweisen <del>  4 </del>  5 Arten von Themen. </p><br><div class="spoiler">  <b class="spoiler_title">Lautes Denken</b> <div class="spoiler_text"><p>  Er sprach über den Stream 4, aber es stellte sich heraus, dass sie noch einen hinzufügten.  Wie das Sprichwort sagt, lebe und lerne. </p></div></div><br><p>  Einfaches Thema <code>new Subject()</code> ist die einfachste Art von Thema.  Es wird ohne Parameter erstellt.  Übergibt Werte, die erst nach dem Abonnement kamen. </p><br><p>  BehaviorSubject <code>new BehaviorSubject( defaultData&lt;T&gt; )</code> - meiner Meinung nach die häufigste Art von Thema.  Die Eingabe akzeptiert einen Standardwert.  Es werden immer die Daten der letzten Ausgabe gespeichert, die beim Abonnieren übertragen werden.  Diese Klasse verfügt auch über eine nützliche Wertemethode, die den aktuellen Wert des Streams zurückgibt. </p><br><p>  ReplaySubject <code>new ReplaySubject(bufferSize?: number, windowTime?: number)</code> - Die Eingabe kann optional das erste Argument als Größe des <code>new ReplaySubject(bufferSize?: number, windowTime?: number)</code> akzeptieren, den es in sich selbst speichert, und das zweite Mal, während dem Änderungen erforderlich sind. </p><br><p>  AsyncSubject <code>new AsyncSubject()</code> - Beim Abonnieren passiert nichts, und der Wert wird erst zurückgegeben, wenn er abgeschlossen ist.  Es wird nur der letzte Stream-Wert zurückgegeben. </p><br><p>  WebSocketSubject <code>new WebSocketSubject(urlConfigOrSource: string | WebSocketSubjectConfig&lt;T&gt; | Observable&lt;T&gt;, destination?: Observer&lt;T&gt;)</code> - Die Dokumentation enthält <code>new WebSocketSubject(urlConfigOrSource: string | WebSocketSubjectConfig&lt;T&gt; | Observable&lt;T&gt;, destination?: Observer&lt;T&gt;)</code> dazu und ich sehe sie zum ersten Mal.  Wer weiß, was er tut, schreibt, ergänzt. </p><br><p>  Fuf.  Nun, hier haben wir alles überlegt, was ich heute erzählen wollte.  Ich hoffe diese Information war hilfreich.  Sie können sich mit der Referenzliste auf der Registerkarte Nützliche Informationen vertraut machen. </p><br><h2 id="poleznaya-informaciya">  Eine nützliche Information </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stream Link</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionsweise von JS: Übersicht über die Engine, Laufzeitmechanismen, Aufrufstapel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionsweise von JS: Ereignisschleife, Async und fünf Möglichkeiten zur Verbesserung des Codes mithilfe von async / await</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionsweise der Ereignisschleife in JavaSript</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrone JavaScript-Evolution</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist RxJS und warum ist es nützlich, darüber Bescheid zu wissen?</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Praktische Anwendung von RxJS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxJS Observables Tutorial - Erstellen und Abonnieren von Observables</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RXJS: Heiße und kalte Observable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klassen, Funktionen zum Erstellen eines Observable.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Betreiber</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxJS-Operatoren am Beispiel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API-Liste</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sorten von Themen und Zeitplänen in RxJS</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462355/">https://habr.com/ru/post/de462355/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462337/index.html">Site-Statistiken und Ihr kleines Repository</a></li>
<li><a href="../de462339/index.html">Wie hängen Handheld-Schulungen mit den internen Standards von Amazon zusammen und wie hat sich dies auf das Weltbild des Unternehmens ausgewirkt?</a></li>
<li><a href="../de462347/index.html">Die ersten zehn Tage auf dem Weg von einer Eule zu einem Frühaufsteher: Schlaf, Diät, Diät und Bewegung</a></li>
<li><a href="../de462349/index.html">RESTinio ist ein asynchroner HTTP-Server. Ein einfaches Beispiel aus der Praxis: Als Antwort eine große Datenmenge zurückgeben</a></li>
<li><a href="../de462353/index.html">Häufig gestellte Fragen zur LoRaWAN-Protokollsicherheit</a></li>
<li><a href="../de462357/index.html">Erster Prototyp: Unikernels als Entwicklungsstufe von Linux</a></li>
<li><a href="../de462359/index.html">Dat - welches Protokoll ist das und wer verwendet es?</a></li>
<li><a href="../de462365/index.html">Einschränkungen beim maschinellen Lernen</a></li>
<li><a href="../de462367/index.html">13 Fakten zum Risikokapitalismus für Gründer</a></li>
<li><a href="../de462371/index.html">Starten Sie Spring StateMachine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>