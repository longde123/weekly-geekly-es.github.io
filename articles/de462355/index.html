<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèª üïß üë©üèø‚Äçü§ù‚Äçüë©üèΩ Asynchrone JavaScript-Programmierung (Callback, Promise, RxJs) üïµüèø üë©üèæ‚Äçüè´ üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. In Kontakt Omelnitsky Sergey. Vor nicht allzu langer Zeit leitete ich einen reaktiven Programmierstrom, in dem ich √ºber Asynchronit√§t i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchrone JavaScript-Programmierung (Callback, Promise, RxJs)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462355/"><p>  Hallo an alle.  In Kontakt Omelnitsky Sergey.  Vor nicht allzu langer Zeit leitete ich einen reaktiven Programmierstrom, in dem ich √ºber Asynchronit√§t in JavaScript sprach.  Heute m√∂chte ich dieses Material skizzieren. </p><br><p><img src="https://habrastorage.org/webt/oq/x0/s1/oqx0s1ukuyf6izyu-5cxkd9cd-m.png"></p><br><p>  Bevor wir jedoch mit dem Hauptmaterial beginnen, m√ºssen wir eine Einf√ºhrung machen.  Beginnen wir also mit den Definitionen: Was ist der Stapel und die Warteschlange? </p><br><p>  <strong>Ein Stapel</strong> ist eine Sammlung, deren Elemente nach dem Prinzip "last in, first out" LIFO empfangen werden </p><br><p>  <strong>Eine Warteschlange</strong> ist eine Sammlung, deren Elemente nach dem Prinzip empfangen werden (FIFO ‚ÄûWer zuerst kommt, mahlt zuerst‚Äú) </p><br><p>  Ok, lass uns weitermachen. </p><br><p><img src="https://habrastorage.org/webt/xk/dt/rr/xkdtrrm0vasdzlva2iqgrpjmwuk.png"></p><br><p>  JavaScript ist eine Single-Threaded-Programmiersprache.  Dies bedeutet, dass es nur einen Ausf√ºhrungsthread und einen Stapel gibt, in dem Funktionen zur Ausf√ºhrung in die Warteschlange gestellt werden.  Daher kann JavaScript zu einem bestimmten Zeitpunkt nur eine Operation ausf√ºhren, w√§hrend andere Operationen darauf warten, dass sie den Stapel einschalten, bis sie aufgerufen werden. </p><a name="habracut"></a><br><p>  <strong>Der Aufrufstapel</strong> ist eine Datenstruktur, die in einfachen Worten Informationen √ºber die Stelle im Programm aufzeichnet, an der wir uns befinden.  Wenn wir in eine Funktion gehen, setzen wir einen Datensatz dar√ºber oben auf den Stapel.  Wenn wir von der Funktion zur√ºckkehren, ziehen wir das oberste Element aus dem Stapel und befinden uns dort, wo wir diese Funktion aufgerufen haben.  Dies ist alles, was der Stapel tun kann.  Und jetzt eine √§u√üerst interessante Frage.  Wie funktioniert dann Asynchronit√§t in JavasScript? </p><br><p><img src="https://habrastorage.org/webt/h2/-x/aj/h2-xajggqa9vcloczh7owhqiffc.png"></p><br><p>  Zus√§tzlich zum Stapel haben Browser eine spezielle Warteschlange f√ºr die Arbeit mit der sogenannten WebAPI.  Funktionen aus dieser Warteschlange werden erst ausgef√ºhrt, nachdem der Stapel vollst√§ndig gel√∂scht wurde.  Erst danach werden sie zur Ausf√ºhrung aus der Warteschlange auf den Stapel geschoben.  Befindet sich derzeit mindestens ein Element auf dem Stapel, k√∂nnen sie nicht auf den Stapel gelangen.  Genau aus diesem Grund ist das Aufrufen von Funktionen nach Zeit√ºberschreitung h√§ufig zeitlich nicht genau, da eine Funktion nicht von der Warteschlange zum Stapel wechseln kann, solange sie voll ist. </p><br><p>  Betrachten Sie das folgende Beispiel und f√ºhren Sie die schrittweise ‚ÄûAusf√ºhrung‚Äú durch.  Sehen Sie auch, was im System passiert. </p><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hi'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cb1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'cb1'</span></span>); }, <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Bye'</span></span>);</code> </pre> <br><p><img src="https://habrastorage.org/webt/tg/i-/xf/tgi-xfd5vxrjxltraxp4o7uhiki.png"></p><br><p>  1) Bisher passiert nichts.  Die Browserkonsole ist sauber, der Aufrufstapel ist leer. </p><br><p><img src="https://habrastorage.org/webt/v4/et/uh/v4etuhvfo-eltv08fhxv1bqx1a0.png"></p><br><p>  2) Anschlie√üend wird der Befehl console.log ('Hi') zum Aufrufstapel hinzugef√ºgt. </p><br><p><img src="https://habrastorage.org/webt/ns/-k/-k/ns-k-klle5egqpwjdzbgxkrwaes.png"></p><br><p>  3) Und es wird ausgef√ºhrt </p><br><p><img src="https://habrastorage.org/webt/dp/oo/tz/dpootztdu0jjapitb1v60dzwdcu.png"></p><br><p>  4) Dann wird console.log ('Hi') vom Aufrufstapel entfernt. </p><br><p><img src="https://habrastorage.org/webt/fu/yb/wb/fuybwb7kq0kcxdj4gobj38-r_fc.png"></p><br><p>  5) Gehen Sie nun zum Befehl setTimeout (Funktion cb1 () {...}).  Es wird dem Aufrufstapel hinzugef√ºgt. </p><br><p><img src="https://habrastorage.org/webt/85/ps/v2/85psv2_s7ec0ibxh8h2991nbxi4.png"></p><br><p>  6) Der Befehl setTimeout (Funktion cb1 () {...}) wird ausgef√ºhrt.  Der Browser erstellt einen Timer, der Teil der Web-API ist.  Er wird den Countdown machen. </p><br><p><img src="https://habrastorage.org/webt/3a/4p/sh/3a4pshoazrkbxfgcajwjqm1cz-m.png"></p><br><p>  7) Der Befehl setTimeout (Funktion cb1 () {...}) wurde abgeschlossen und aus dem Aufrufstapel entfernt. </p><br><p><img src="https://habrastorage.org/webt/oe/qt/ne/oeqtnemv7rawkjpanipkv41qpeq.png"></p><br><p>  8) Der Befehl console.log ('Bye') wird dem Aufrufstapel hinzugef√ºgt. </p><br><p><img src="https://habrastorage.org/webt/bb/mp/fb/bbmpfba1p2tadcztfm-41py_mgi.png"></p><br><p>  9) Der Befehl console.log ('Bye') wird ausgef√ºhrt. </p><br><p><img src="https://habrastorage.org/webt/d0/ra/3z/d0ra3zfarz4ujmyy46cmsofs8ue.png"></p><br><p>  10) Der Befehl console.log ('Bye') wird aus dem Aufrufstapel entfernt. </p><br><p><img src="https://habrastorage.org/webt/5y/by/dr/5ybydrdk6yuexhgyhbxwsvnkefa.png"></p><br><p>  11) Nach mindestens 5000 ms wird der Timer beendet und der cb1-R√ºckruf in die R√ºckrufwarteschlange gestellt. </p><br><p><img src="https://habrastorage.org/webt/sx/of/no/sxofnovn3xkkz5oyngnotdggpcs.png"></p><br><p>  12) Die Ereignisschleife nimmt c die Funktion cb1 aus der R√ºckrufwarteschlange und legt sie auf dem Aufrufstapel ab. </p><br><p><img src="https://habrastorage.org/webt/ge/qp/1t/geqp1t65hnddi0hx0ut4b80ooi0.png"></p><br><p>  13) Die Funktion cb1 wird ausgef√ºhrt und f√ºgt console.log ('cb1') zum Aufrufstapel hinzu. </p><br><p><img src="https://habrastorage.org/webt/xi/vq/ac/xivqac36m7yv79qocvstugftlb4.png"></p><br><p>  14) Der Befehl console.log ('cb1') wird ausgef√ºhrt. </p><br><p><img src="https://habrastorage.org/webt/hp/tu/gk/hptugkn_5iizvyhez25bpf8zvpy.png"></p><br><p>  15) Der Befehl console.log ('cb1') wird aus dem Aufrufstapel entfernt. </p><br><p><img src="https://habrastorage.org/webt/bh/wr/st/bhwrstroipmqqhrhiit4cmdy-we.png"></p><br><p>  16) Die Funktion cb1 wird aus dem Aufrufstapel entfernt. </p><br><p>  Schauen Sie sich ein Beispiel in der Dynamik an: </p><br><p><img src="https://habrastorage.org/webt/xx/nj/a8/xxnja8sfjhdg5ks3ku5q6yzkxvc.gif"></p><br><p>  Hier haben wir untersucht, wie Asynchronit√§t in JavaScript implementiert ist.  Lassen Sie uns nun kurz √ºber die Entwicklung des asynchronen Codes sprechen. </p><br><h2 id="evolyuciya-asinhronnogo-koda">  Die Entwicklung des asynchronen Codes. </h2><br><pre> <code class="javascript hljs">a(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromA</span></span></span><span class="hljs-function">) </span></span>{ b(resultsFromA, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromB</span></span></span><span class="hljs-function">) </span></span>{ c(resultsFromB, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromC</span></span></span><span class="hljs-function">) </span></span>{ d(resultsFromC, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromD</span></span></span><span class="hljs-function">) </span></span>{ e(resultsFromD, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromE</span></span></span><span class="hljs-function">) </span></span>{ f(resultsFromE, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromF</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resultsFromF); }) }) }) }) }) });</code> </pre> <br><p>  Asynchrone Programmierung, wie wir sie in JavaScript kennen, kann nur mit Funktionen implementiert werden.  Sie k√∂nnen wie jede andere Variable an andere Funktionen √ºbergeben werden.  So wurden die R√ºckrufe geboren.  Und es ist cool, lustig und provokativ, bis es sich in Traurigkeit, Sehnsucht und Traurigkeit verwandelt.  Warum?  Ja, alles ist einfach: </p><br><ul><li>  Mit der zunehmenden Komplexit√§t des Codes verwandelt sich das Projekt schnell in obskure, wiederholt verschachtelte Bl√∂cke - ‚ÄûCallback Hell‚Äú. </li><li>  Fehlerbehandlung kann leicht √ºbersehen werden. </li><li>  Sie k√∂nnen keine Ausdr√ºcke mit return zur√ºckgeben. </li></ul><br><p>  Mit Promise wurde es etwas besser. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">2000</span></span>); }).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { alert(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + <span class="hljs-number"><span class="hljs-number">2</span></span>; }).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'FAILED HERE'</span></span>); alert(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + <span class="hljs-number"><span class="hljs-number">2</span></span>; }).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { alert(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + <span class="hljs-number"><span class="hljs-number">2</span></span>; }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'error: '</span></span>, e); });</code> </pre> <br><ul><li>  Es erschienen Versprechensketten, die die Lesbarkeit des Codes verbesserten </li><li>  Eine separate Fehler√ºberwachungsmethode wurde angezeigt </li><li>  Jetzt k√∂nnen Sie mit Promise.all parallel ausf√ºhren </li><li>  Wir k√∂nnen verschachtelte Asynchronit√§t mit async / await l√∂sen </li></ul><br><p>  Aber Promis hat seine Grenzen.  Zum Beispiel kann ein Versprechen, ohne mit einem Tamburin zu tanzen, nicht r√ºckg√§ngig gemacht werden, und vor allem funktioniert es mit einem Wert. </p><br><p>  Nun, wir n√§herten uns reibungslos der reaktiven Programmierung.  Bist du m√ºde  Das Gute ist, dass Sie ein paar M√∂wen machen, nachdenken und zur√ºckkehren k√∂nnen, um weiterzulesen.  Und ich werde weitermachen. </p><br><p><img src="https://habrastorage.org/webt/pj/0g/7b/pj0g7bgonkiefme08noahs3y0wc.png" alt="Grundlagen der reaktiven Programmierung"></p><br><p>  <strong>Reaktive Programmierung</strong> ist ein Programmierparadigma, das sich auf Datenfl√ºsse und die Ausbreitung von Ver√§nderungen konzentriert.  Schauen wir uns einen Datenstrom genauer an. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     const input = ducument.querySelector('input'); const eventsArray = []; //      eventsArray input.addEventListener('keyup', event =&gt; eventsArray.push(event) );</span></span></code> </pre> <br><p>  Stellen Sie sich vor, wir haben ein Eingabefeld.  Wir erstellen ein Array und speichern das Ereignis f√ºr jedes Keyup des Eingabeereignisses in unserem Array.  In diesem Fall m√∂chte ich darauf hinweisen, dass unser Array nach Zeit sortiert ist, d.h.  Der Index sp√§terer Ereignisse ist gr√∂√üer als der Index fr√ºherer Ereignisse.  Ein solches Array ist ein vereinfachtes Datenstrommodell, aber noch kein Stream.  Damit dieses Array sicher als Stream bezeichnet werden kann, muss es die Teilnehmer irgendwie dar√ºber informieren k√∂nnen, dass es neue Daten erhalten hat.  Wir kommen also zur Definition des Flusses. </p><br><h3 id="potok-dannyh">  Datenstrom </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { interval } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( take(<span class="hljs-number"><span class="hljs-number">4</span></span>) )</code> </pre> <br><p><img src="https://habrastorage.org/webt/iu/oe/9k/iuoe9k_c75atoryyrxykddnhuzi.gif"></p><br><p>  <strong>Ein Stream</strong> ist ein nach Zeit sortiertes Datenarray, das anzeigen kann, dass sich die Daten ge√§ndert haben.  Stellen Sie sich nun vor, wie bequem es ist, Code zu schreiben, in dem Sie mehrere Ereignisse in verschiedenen Teilen des Codes in einer Aktion ausl√∂sen m√ºssen.  Wir abonnieren einfach den Stream und er wird uns wissen lassen, wann die √Ñnderungen eintreten.  Und die RxJs-Bibliothek kann dies tun. </p><br><p><img src="https://habrastorage.org/webt/2e/eg/cv/2eegcvxzcaz0j6x_n27h7nko68s.png"></p><br><p>  <strong>RxJS</strong> ist eine Bibliothek f√ºr die Arbeit mit asynchronen und ereignisbasierten Programmen unter Verwendung beobachtbarer Sequenzen.  Die Bibliothek bietet den Haupttyp von <em>Observable</em> , verschiedene Hilfstypen ( <em>Observer, Scheduler, Subjects</em> ) und Operatoren f√ºr die Arbeit mit Ereignissen wie bei Sammlungen ( <em>Map, Filter, Reduce, alles</em> und dergleichen aus JavaScript Array). </p><br><p>  Schauen wir uns die Grundkonzepte dieser Bibliothek an. </p><br><h3 id="observable-observer-producer">  Beobachtbar, Beobachter, Produzent </h3><br><p>  Observable ist der erste Grundtyp, den wir betrachten werden.  Diese Klasse enth√§lt den Gro√üteil der RxJ-Implementierung.  Es ist einem beobachtbaren Stream zugeordnet, den Sie beide mit der Subscribe-Methode abonnieren k√∂nnen. </p><br><p>  Observable implementiert einen Hilfsmechanismus zum Erstellen von Updates, den sogenannten <em>Observer</em> .  Die Quelle der Werte f√ºr Observer hei√üt <em>Producer</em> .  Dies kann ein Array, ein Iterator, ein Web-Socket, eine Art Ereignis usw. sein.  Wir k√∂nnen also sagen, dass Observable ein Dirigent zwischen Produzent und Beobachter ist. </p><br><p>  Observable behandelt drei Arten von Observer-Ereignissen: </p><br><ul><li>  next - neue Daten </li><li>  Fehler - Ein Fehler, wenn die Sequenz aufgrund einer Ausnahme beendet wurde.  Dieses Ereignis beinhaltet auch die Vervollst√§ndigung der Sequenz. </li><li>  complete - Signal √ºber den Abschluss der Sequenz.  Dies bedeutet, dass keine neuen Daten vorhanden sind. </li></ul><br><p>  Schauen wir uns die Demo an: </p><br><p><img src="https://habrastorage.org/webt/mg/qn/pf/mgqnpfxctqlz3yqwseag1fqttrc.gif"></p><br><p>  Zu Beginn werden wir die Werte 1, 2, 3 und nach 1 Sek. Verarbeiten.  Wir werden 4 bekommen und unseren Fluss beenden. </p><br><div class="spoiler">  <b class="spoiler_title">Lautes Denken</b> <div class="spoiler_text"><p>  Und dann wurde mir klar, dass das Erz√§hlen interessanter war als dar√ºber zu schreiben.  : D. </p></div></div><br><h3 id="subscription">  Abonnement </h3><br><p>  Wenn wir einen Stream abonnieren, erstellen wir eine neue <strong>Abonnementklasse</strong> , mit der wir uns mit der Methode zum Abbestellen <em>abmelden k√∂nnen</em> .  Wir k√∂nnen Abonnements auch mit der Methode <em>add</em> gruppieren.  Nun, es ist logisch, dass wir die Gruppierung der Threads mit <em>remove aufheben k√∂nnen</em> .  Die Eingabemethoden zum Hinzuf√ºgen und Entfernen akzeptieren ein anderes Abonnement.  Ich m√∂chte darauf hinweisen, dass wir beim Abbestellen alle untergeordneten Abonnements abbestellen, als w√ºrden sie die Abmeldemethode aufrufen.  Mach weiter. </p><br><h3 id="vidy-potokov">  Arten von Streams </h3><br><div class="scrollable-table"><table><thead><tr><th>  HEISS </th><th>  KALT </th></tr></thead><tbody><tr><td>  Produzent au√üerhalb beobachtbar erstellt </td><td>  Produzent erstellt innerhalb beobachtbar </td></tr><tr><td>  Die Daten werden zum Zeitpunkt der Erstellung des Observablen √ºbertragen. </td><td>  Die Daten werden zum Zeitpunkt des Abonnements gemeldet </td></tr><tr><td>  Ben√∂tigen Sie mehr Logik zum Abbestellen </td><td>  Der Thread wird von selbst beendet </td></tr><tr><td>  Verwendet eine Eins-zu-Viele-Kommunikation </td><td>  Verwendet eine Eins-zu-Eins-Beziehung </td></tr><tr><td>  Alle Abonnements haben den gleichen Wert. </td><td>  Abonnements sind unabh√§ngig </td></tr><tr><td>  Daten k√∂nnen verloren gehen, wenn kein Abonnement besteht </td><td>  Gibt alle Stream-Werte f√ºr ein neues Abonnement erneut aus </td></tr></tbody></table></div><br><p>  Um eine Analogie zu geben, w√ºrde ich mir einen hei√üen Stream wie einen Film in einem Kino vorstellen.  Zu welchem ‚Äã‚ÄãZeitpunkt kamen Sie von diesem Moment an und begannen zu sehen.  Ich w√ºrde einen kalten Strom mit einem Anruf in diesen vergleichen.  Unterst√ºtzung.  Jeder Anrufer h√∂rt von Anfang bis Ende auf den Anrufbeantworter, aber Sie k√∂nnen auflegen, indem Sie sich abmelden. </p><br><p>  Ich m√∂chte darauf hinweisen, dass es immer noch sogenannte Warmstr√∂me gibt (eine solche Definition habe ich sehr selten und nur in fremden Gemeinden getroffen) - dies ist ein Strom, der sich von einem kalten in einen hei√üen Strom verwandelt.  Es stellt sich die Frage - wo zu verwenden)) Ich werde ein Beispiel aus der Praxis geben. </p><br><p>  Ich arbeite mit einem Winkel.  Er benutzt aktiv rxjs.  Um Daten auf den Server zu √ºbertragen, erwarte ich einen kalten Stream und verwende diesen Stream in der Vorlage mit asyncPipe.  Wenn ich diese Pipe mehrmals verwende, fordert jede Pipe, um zur Definition eines kalten Streams zur√ºckzukehren, Daten vom Server an, was gelinde gesagt seltsam ist.  Und wenn ich einen kalten Strom in einen warmen umwandle, wird die Anfrage einmal gestellt. </p><br><p>  Im Allgemeinen ist das Verst√§ndnis der Form von Fl√ºssen f√ºr Anf√§nger recht kompliziert, aber wichtig. </p><br><h3 id="operators">  Betreiber </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${environment.apiUrl}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.apiUrl}</span></span></span><span class="hljs-string">/trade_companies`</span></span>) .pipe( tap(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ data }: TradeCompanyList</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.companies$$.next(cloneDeep(data))), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ data }: TradeCompanyList</span></span></span><span class="hljs-function">) =&gt;</span></span> data) );</code> </pre> <br><p>  Operatoren bieten uns die M√∂glichkeit, mit Streams zu arbeiten.  Sie helfen bei der Steuerung von Ereignissen, die im Observable auftreten.  Wir werden einige der beliebtesten betrachten, und die Betreiber k√∂nnen √ºber die Links in den n√ºtzlichen Informationen detaillierter gefunden werden. </p><br><p>  <strong>Betreiber - von</strong> </p><br><p>  Wir beginnen mit dem Hilfsoperator von.  Es wird ein Observable basierend auf einem einfachen Wert erstellt. </p><br><p><img src="https://habrastorage.org/webt/ty/gv/ns/tygvns2-ufljiud304keflcihtw.png"></p><br><p>  <strong>Operatoren - Filter</strong> </p><br><p><img src="https://habrastorage.org/webt/lu/ej/-q/luej-qu433z2ascmvk4avc9qg80.png"></p><br><p>  Der Filteroperatorfilter filtert, wie der Name schon sagt, das Stream-Signal.  Wenn der Operator true zur√ºckgibt, wird weiter √ºbersprungen. </p><br><p>  <strong>Betreiber - nehmen</strong> </p><br><p><img src="https://habrastorage.org/webt/n3/h-/p7/n3h-p7dnsmlrus2qxcid1k-j0sc.png"></p><br><p>  take - Nimmt den Wert der Anzahl der Emits an, nach denen der Stream endet. </p><br><p>  <strong>Operatoren - debounceTime</strong> </p><br><p><img src="https://habrastorage.org/webt/fm/-h/ov/fm-hovzqqm8setakpkxrq35220i.png"></p><br><p>  debounceTime - verwirft die ausgegebenen Werte, die in den angegebenen Zeitraum zwischen den Ausgabedaten fallen. Nach Ablauf des Zeitintervalls wird der letzte Wert ausgegeben. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { debounceTime, take } = RxOperators; Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; observer.next(i++); <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next(i++) }, 1000); //     1500 setInterval(() =&gt; { observer.next(i++) }, 1500); }).pipe( debounceTime(700), //  700     take(3) );</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/wq/c4/is/wqc4is_4memtbjbseivewpqsm3y.gif"></p><br><p>  <strong>Operatoren - takeWhile</strong> </p><br><p><img src="https://habrastorage.org/webt/be/_4/bw/be_4bwupgcjmlqubh0bnjfwaq3o.png"></p><br><p>  Es gibt Werte aus, bis takeWhile false zur√ºckgibt. Danach wird der Stream abbestellt. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { debounceTime, takeWhile } = RxOperators; Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; observer.next(i++); <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next(i++) }, 1000); }).pipe( takeWhile( producer =&gt; producer &lt; 5 ) );</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/fj/yx/ht/fjyxhtlst2zizvmv6uoei5vi_bm.gif"></p><br><p>  <strong>Operatoren - kombinierenLetzte</strong> </p><br><p>  Der Operator kombinieren kombinierenLatest √§hnelt etwas versprechen.all.  Es kombiniert mehrere Threads zu einem.  Nachdem jeder Thread mindestens eine Ausgabe durchgef√ºhrt hat, erhalten wir die letzten Werte von jedem in Form eines Arrays.  Dar√ºber hinaus ergeben sich nach jeder Emission aus den kombinierten Fl√ºssen neue Werte. </p><br><p><img src="https://habrastorage.org/webt/cg/lq/pj/cglqpjraurcow4xpusyfy-o-g1i.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { combineLatest, Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer_1 = Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next('a: ' + i++); }, 1000); }); const observer_2 = Observable.create((observer) =&gt; { let i = 1; //     750 setInterval(() =&gt; { observer.next('b: ' + i++); }, 750); }); combineLatest(observer_1, observer_2).pipe(take(5));</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/lx/f6/qc/lxf6qcp3uqlpezwwxzipibko8mw.gif"></p><br><p>  <strong>Bediener - Rei√üverschluss</strong> </p><br><p>  Zip - wartet auf einen Wert aus jedem Stream und bildet basierend auf diesen Werten ein Array.  Wenn der Wert nicht aus einem Stream stammt, wird die Gruppe nicht gebildet. </p><br><p><img src="https://habrastorage.org/webt/_w/uw/u5/_wuwu5ncu3ikb96iszphaeho1cu.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { zip, Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer_1 = Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next('a: ' + i++); }, 1000); }); const observer_2 = Observable.create((observer) =&gt; { let i = 1; //     750 setInterval(() =&gt; { observer.next('b: ' + i++); }, 750); }); const observer_3 = Observable.create((observer) =&gt; { let i = 1; //     500 setInterval(() =&gt; { observer.next('c: ' + i++); }, 500); }); zip(observer_1, observer_2, observer_3).pipe(take(5));</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/lr/iz/k2/lrizk28md9flrpm-5nkiioxlbw0.gif"></p><br><p>  <strong>Operatoren - forkJoin</strong> </p><br><p>  forkJoin verkettet auch Threads, gibt jedoch nur Werte an, wenn alle Threads vollst√§ndig sind. </p><br><p><img src="https://habrastorage.org/webt/kg/yn/i8/kgyni8bmucerz2-o015i4fnrlrg.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { forkJoin, Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer_1 = Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next('a: ' + i++); }, 1000); }).pipe(take(3)); const observer_2 = Observable.create((observer) =&gt; { let i = 1; //     750 setInterval(() =&gt; { observer.next('b: ' + i++); }, 750); }).pipe(take(5)); const observer_3 = Observable.create((observer) =&gt; { let i = 1; //     500 setInterval(() =&gt; { observer.next('c: ' + i++); }, 500); }).pipe(take(4)); forkJoin(observer_1, observer_2, observer_3);</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/34/ny/qn/34nyqnbve4g6gsheeoeaii1qkw0.gif"></p><br><p>  <strong>Operatoren - Karte</strong> </p><br><p>  Der Kartentransformationsoperator konvertiert den Ausgabewert in einen neuen. </p><br><p><img src="https://habrastorage.org/webt/z5/cq/gn/z5cqgnureeelbyknte8aohlkjyo.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take, map } = RxOperators; Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next(i++); }, 1000); }).pipe( map(x =&gt; x * 10), take(3) );</span></span></code> </pre><br><p><img src="https://habrastorage.org/webt/zy/fz/az/zyfzazyep10bcow9f1nxzumq8nk.gif"></p><br><p>  <strong>Operatoren - teilen, tippen</strong> </p><br><p>  Mit dem Tap-Operator k√∂nnen Sie Nebenwirkungen ausf√ºhren, dh alle Aktionen, die die Sequenz nicht beeinflussen. </p><br><p>  Der Utility-Share-Betreiber kann es aus einem kalten Strom hei√ü machen. </p><br><p><img src="https://habrastorage.org/webt/2p/lc/fr/2plcfr9agwst3elkl_yglmmfftk.png"></p><br><p>  Mit den Bedienern fertig.  Fahren wir mit dem Thema fort. </p><br><div class="spoiler">  <b class="spoiler_title">Lautes Denken</b> <div class="spoiler_text"><p>  Und dann ging ich ein paar M√∂wen trinken.  Diese Beispiele langweilten mich: D. </p></div></div><br><h2 id="semeystvo-subject-ov">  Fachfamilie </h2><br><p>  Die Themenfamilie ist ein Paradebeispiel f√ºr hei√üe Streams.  Diese Klassen sind eine Art Hybrid, die gleichzeitig als beobachtbar und beobachtend fungieren.  Da es sich bei dem Betreff um einen hei√üen Stream handelt, m√ºssen Sie ihn abbestellen.  Wenn wir √ºber die grundlegenden Methoden sprechen, dann ist dies: </p><br><ul><li>  next - √úbertragung neuer Daten in den Stream </li><li>  Fehler - Fehler und Beendigung des Streams </li><li>  vollst√§ndig - Beendigung des Streams </li><li>  Abonnieren - Abonnieren Sie den Stream </li><li>  Abbestellen - Abbestellen vom Stream </li><li>  asObservable - verwandeln Sie sich in einen Beobachter </li><li>  toPromise - verwandelt sich in ein Versprechen </li></ul><br><p>  Zuweisen <del>  4 </del>  5 Arten von Themen. </p><br><div class="spoiler">  <b class="spoiler_title">Lautes Denken</b> <div class="spoiler_text"><p>  Er sprach √ºber den Stream 4, aber es stellte sich heraus, dass sie noch einen hinzuf√ºgten.  Wie das Sprichwort sagt, lebe und lerne. </p></div></div><br><p>  Einfaches Thema <code>new Subject()</code> ist die einfachste Art von Thema.  Es wird ohne Parameter erstellt.  √úbergibt Werte, die erst nach dem Abonnement kamen. </p><br><p>  BehaviorSubject <code>new BehaviorSubject( defaultData&lt;T&gt; )</code> - meiner Meinung nach die h√§ufigste Art von Thema.  Die Eingabe akzeptiert einen Standardwert.  Es werden immer die Daten der letzten Ausgabe gespeichert, die beim Abonnieren √ºbertragen werden.  Diese Klasse verf√ºgt auch √ºber eine n√ºtzliche Wertemethode, die den aktuellen Wert des Streams zur√ºckgibt. </p><br><p>  ReplaySubject <code>new ReplaySubject(bufferSize?: number, windowTime?: number)</code> - Die Eingabe kann optional das erste Argument als Gr√∂√üe des <code>new ReplaySubject(bufferSize?: number, windowTime?: number)</code> akzeptieren, den es in sich selbst speichert, und das zweite Mal, w√§hrend dem √Ñnderungen erforderlich sind. </p><br><p>  AsyncSubject <code>new AsyncSubject()</code> - Beim Abonnieren passiert nichts, und der Wert wird erst zur√ºckgegeben, wenn er abgeschlossen ist.  Es wird nur der letzte Stream-Wert zur√ºckgegeben. </p><br><p>  WebSocketSubject <code>new WebSocketSubject(urlConfigOrSource: string | WebSocketSubjectConfig&lt;T&gt; | Observable&lt;T&gt;, destination?: Observer&lt;T&gt;)</code> - Die Dokumentation enth√§lt <code>new WebSocketSubject(urlConfigOrSource: string | WebSocketSubjectConfig&lt;T&gt; | Observable&lt;T&gt;, destination?: Observer&lt;T&gt;)</code> dazu und ich sehe sie zum ersten Mal.  Wer wei√ü, was er tut, schreibt, erg√§nzt. </p><br><p>  Fuf.  Nun, hier haben wir alles √ºberlegt, was ich heute erz√§hlen wollte.  Ich hoffe diese Information war hilfreich.  Sie k√∂nnen sich mit der Referenzliste auf der Registerkarte N√ºtzliche Informationen vertraut machen. </p><br><h2 id="poleznaya-informaciya">  Eine n√ºtzliche Information </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stream Link</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionsweise von JS: √úbersicht √ºber die Engine, Laufzeitmechanismen, Aufrufstapel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionsweise von JS: Ereignisschleife, Async und f√ºnf M√∂glichkeiten zur Verbesserung des Codes mithilfe von async / await</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionsweise der Ereignisschleife in JavaSript</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrone JavaScript-Evolution</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist RxJS und warum ist es n√ºtzlich, dar√ºber Bescheid zu wissen?</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Praktische Anwendung von RxJS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxJS Observables Tutorial - Erstellen und Abonnieren von Observables</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RXJS: Hei√üe und kalte Observable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klassen, Funktionen zum Erstellen eines Observable.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Betreiber</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxJS-Operatoren am Beispiel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API-Liste</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sorten von Themen und Zeitpl√§nen in RxJS</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462355/">https://habr.com/ru/post/de462355/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462337/index.html">Site-Statistiken und Ihr kleines Repository</a></li>
<li><a href="../de462339/index.html">Wie h√§ngen Handheld-Schulungen mit den internen Standards von Amazon zusammen und wie hat sich dies auf das Weltbild des Unternehmens ausgewirkt?</a></li>
<li><a href="../de462347/index.html">Die ersten zehn Tage auf dem Weg von einer Eule zu einem Fr√ºhaufsteher: Schlaf, Di√§t, Di√§t und Bewegung</a></li>
<li><a href="../de462349/index.html">RESTinio ist ein asynchroner HTTP-Server. Ein einfaches Beispiel aus der Praxis: Als Antwort eine gro√üe Datenmenge zur√ºckgeben</a></li>
<li><a href="../de462353/index.html">H√§ufig gestellte Fragen zur LoRaWAN-Protokollsicherheit</a></li>
<li><a href="../de462357/index.html">Erster Prototyp: Unikernels als Entwicklungsstufe von Linux</a></li>
<li><a href="../de462359/index.html">Dat - welches Protokoll ist das und wer verwendet es?</a></li>
<li><a href="../de462365/index.html">Einschr√§nkungen beim maschinellen Lernen</a></li>
<li><a href="../de462367/index.html">13 Fakten zum Risikokapitalismus f√ºr Gr√ºnder</a></li>
<li><a href="../de462371/index.html">Starten Sie Spring StateMachine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>