<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèΩ üéóÔ∏è üèä N√≥s escrevemos um sistema operacional no Rust. Organiza√ß√£o da p√°gina da mem√≥ria üë®üèæ‚ÄçüöÄ üóëÔ∏è üë©üèø‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, apresentamos as p√°ginas , um esquema de gerenciamento de mem√≥ria muito comum que tamb√©m aplicamos em nosso sistema operacional. O artigo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>N√≥s escrevemos um sistema operacional no Rust. Organiza√ß√£o da p√°gina da mem√≥ria</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436606/">  Neste artigo, apresentamos as <i>p√°ginas</i> , um esquema de gerenciamento de mem√≥ria muito comum que tamb√©m aplicamos em nosso sistema operacional.  O artigo explica por que o isolamento de mem√≥ria √© necess√°rio, como funciona a <i>segmenta√ß√£o</i> , o que <i>√© mem√≥ria virtual</i> e como as p√°ginas resolvem o problema de fragmenta√ß√£o.  Tamb√©m exploramos o esquema de tabelas de p√°ginas multin√≠veis na arquitetura x86_64. <br><br>  Este blog est√° publicado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  Se voc√™ tiver alguma d√∫vida ou problema, abra a solicita√ß√£o correspondente l√°. <br><a name="habracut"></a><br><h1>  Prote√ß√£o de mem√≥ria </h1><br>  Uma das principais tarefas do sistema operacional √© isolar os programas um do outro.  Por exemplo, um navegador n√£o deve interferir com um editor de texto.  Existem v√°rias abordagens, dependendo da implementa√ß√£o do hardware e do sistema operacional. <br><br>  Por exemplo, alguns processadores ARM Cortex-M (em sistemas embarcados) possuem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>uma unidade de prote√ß√£o de mem√≥ria</i></a> (MPU) que define um pequeno n√∫mero (por exemplo, 8) de √°reas de mem√≥ria com permiss√µes de acesso diferentes (por exemplo, sem acesso, somente leitura, leitura e leitura). registros).  Cada vez que a mem√≥ria √© acessada, o MPU garante que o endere√ßo esteja na √°rea com as permiss√µes corretas, caso contr√°rio, gera uma exce√ß√£o.  Alterando o escopo e as permiss√µes de acesso, o sistema operacional garante que cada processo tenha acesso apenas √† sua mem√≥ria para isolar os processos um do outro. <br><br>  No x86, s√£o suportadas duas abordagens diferentes para proteger a mem√≥ria: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segmenta√ß√£o</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pagina√ß√£o</a> . <br><br><h1>  Segmenta√ß√£o </h1><br>  A segmenta√ß√£o foi implementada em 1978, inicialmente para aumentar a quantidade de mem√≥ria endere√ß√°vel.  Naquele momento, a CPU suportava apenas endere√ßos de 16 bits, o que limitava a quantidade de mem√≥ria endere√ß√°vel a 64 KB.  Para aumentar esse volume, foram introduzidos registros de segmentos adicionais, cada um contendo um endere√ßo de deslocamento.  A CPU adiciona automaticamente esse deslocamento a cada acesso √† mem√≥ria, endere√ßando at√© 1 MB de mem√≥ria. <br><br>  A CPU seleciona automaticamente um registro de segmento, dependendo do tipo de acesso √† mem√≥ria: o registro de segmento de c√≥digo <code>CS</code> √© usado para receber instru√ß√µes e o registro de segmento de pilha <code>SS</code> √© usado para opera√ß√µes de pilha (push / pop).  Outras instru√ß√µes usam o registro de segmento de dados <code>DS</code> ou o registro de segmento <code>ES</code> opcional.  Mais tarde, dois registradores de segmentos adicionais <code>FS</code> e <code>GS</code> foram adicionados para uso gratuito. <br><br>  Na primeira vers√£o da segmenta√ß√£o, os registros continham diretamente o deslocamento e o controle de acesso n√£o foi realizado.  Com o advento do <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modo protegido, o</a></i> mecanismo mudou.  Quando a CPU opera nesse modo, os descritores de segmento armazenam o √≠ndice em uma tabela de descritores local ou global, que al√©m do endere√ßo de deslocamento cont√©m o tamanho do segmento e as permiss√µes de acesso.  Ao carregar tabelas de descritores globais / locais separadas para cada processo, o sistema operacional pode isolar os processos um do outro. <br><br>  Ao alterar os endere√ßos de mem√≥ria antes do acesso real, a segmenta√ß√£o implementou um m√©todo que agora √© usado em quase todos os lugares: √© <i>a mem√≥ria virtual</i> . <br><br><h3>  Mem√≥ria virtual </h3><br>  A id√©ia da mem√≥ria virtual √© abstrair os endere√ßos de mem√≥ria de um dispositivo f√≠sico.  Em vez de acessar diretamente o dispositivo de armazenamento, uma etapa de convers√£o √© realizada primeiro.  No caso de segmenta√ß√£o, o endere√ßo de deslocamento do segmento ativo √© adicionado no est√°gio de convers√£o.  Imagine um programa que acesse o endere√ßo de mem√≥ria <code>0x1234000</code> em um segmento com um deslocamento de <code>0x1111000</code> : na realidade, o endere√ßo vai para <code>0x2345000</code> . <br><br>  Para distinguir entre dois tipos de endere√ßos, os endere√ßos antes da convers√£o s√£o chamados <i>virtuais</i> e os endere√ßos ap√≥s a convers√£o s√£o chamados <i>f√≠sicos</i> .  H√° uma diferen√ßa importante entre eles: os endere√ßos f√≠sicos s√£o √∫nicos e sempre se referem ao mesmo local exclusivo na mem√≥ria.  Os endere√ßos virtuais, por outro lado, dependem da fun√ß√£o de tradu√ß√£o.  Dois endere√ßos virtuais diferentes podem muito bem se referir ao mesmo endere√ßo f√≠sico.  Al√©m disso, endere√ßos virtuais id√™nticos podem se referir a diferentes endere√ßos f√≠sicos ap√≥s a convers√£o. <br><br>  Um exemplo do uso √∫til dessa propriedade √© o lan√ßamento paralelo do mesmo programa duas vezes: <br><br><img src="https://habrastorage.org/webt/qm/zz/nz/qmzznz4rei5d-xxygzcabu2latw.png"><br><br>  Aqui, o mesmo programa √© executado duas vezes, mas com diferentes fun√ß√µes de convers√£o.  A primeira inst√¢ncia tem um deslocamento de segmento de 100, portanto, seus endere√ßos virtuais 0-150 s√£o convertidos em endere√ßos f√≠sicos 100-250.  A segunda inst√¢ncia tem um deslocamento de 300, que converte os endere√ßos virtuais 0-150 em endere√ßos f√≠sicos 300-450.  Isso permite que ambos os programas executem o mesmo c√≥digo e usem os mesmos endere√ßos virtuais sem interferir um com o outro. <br><br>  Outra vantagem √© que agora os programas podem ser colocados em locais arbitr√°rios na mem√≥ria f√≠sica.  Assim, o sistema operacional usa toda a quantidade de mem√≥ria dispon√≠vel sem a necessidade de recompilar os programas. <br><br><h3>  Fragmenta√ß√£o </h3><br>  A diferen√ßa entre endere√ßos virtuais e f√≠sicos √© uma conquista real da segmenta√ß√£o.  Mas h√° um problema.  Imagine que queremos executar a terceira c√≥pia do programa que vimos acima: <br><br><img src="https://habrastorage.org/webt/rr/np/1m/rrnp1m95lefyki9vwhnwe4uocom.png"><br><br>  Embora exista espa√ßo mais que suficiente na mem√≥ria f√≠sica, a terceira c√≥pia n√£o cabe em lugar algum.  O problema √© que ele precisa de um fragmento <i>cont√≠nuo</i> de mem√≥ria e n√£o podemos usar se√ß√µes livres separadas. <br><br>  Uma maneira de combater a fragmenta√ß√£o √© pausar a execu√ß√£o do programa, aproximar partes da mem√≥ria usadas, atualizar a convers√£o e retomar a execu√ß√£o: <br><br><img src="https://habrastorage.org/webt/hd/rm/zo/hdrmzooae2xt4huangnbzebq3o0.png"><br><br>  Agora, h√° espa√ßo suficiente para iniciar a terceira inst√¢ncia. <br><br>  A desvantagem dessa desfragmenta√ß√£o √© a necessidade de copiar grandes quantidades de mem√≥ria, o que reduz o desempenho.  Este procedimento deve ser executado regularmente at√© que a mem√≥ria fique muito fragmentada.  O desempenho se torna imprevis√≠vel, os programas param a qualquer momento e podem parar de responder. <br><br>  A fragmenta√ß√£o √© uma das raz√µes pelas quais a segmenta√ß√£o n√£o √© usada na maioria dos sistemas.  De fato, ele n√£o √© mais suportado, mesmo no modo de 64 bits no x86.  Em vez de segmenta√ß√£o, s√£o usadas p√°ginas que eliminam completamente o problema de fragmenta√ß√£o. <br><br><h1>  Organiza√ß√£o da p√°gina da mem√≥ria </h1><br>  A id√©ia √© dividir o espa√ßo da mem√≥ria virtual e f√≠sica em pequenos blocos de tamanho fixo.  Os blocos de mem√≥ria virtual s√£o chamados de p√°ginas e os blocos de espa√ßo de endere√ßo f√≠sico s√£o chamados de quadros.  Cada p√°gina √© mapeada individualmente para um quadro, o que permite dividir grandes √°reas de mem√≥ria entre quadros f√≠sicos n√£o adjacentes. <br><br>  A vantagem se torna √≥bvia se voc√™ repetir o exemplo com um espa√ßo de mem√≥ria fragmentado, mas desta vez usando p√°ginas em vez de segmenta√ß√£o: <br><br><img src="https://habrastorage.org/webt/29/rg/95/29rg95blzryjql4qjy_txkbx2uo.png"><br><br>  Neste exemplo, o tamanho da p√°gina √© de 50 bytes, ou seja, cada uma das √°reas de mem√≥ria √© dividida em tr√™s p√°ginas.  Cada p√°gina √© mapeada para um quadro separado, para que uma regi√£o cont√≠gua da mem√≥ria virtual possa ser mapeada para quadros f√≠sicos isolados.  Isso permite que voc√™ execute a terceira inst√¢ncia do programa sem desfragmenta√ß√£o. <br><br><h3>  Fragmenta√ß√£o oculta </h3><br>  Comparada √† segmenta√ß√£o, uma organiza√ß√£o de pagina√ß√£o usa muitas √°reas pequenas de mem√≥ria de tamanho fixo em vez de v√°rias √°reas grandes de tamanho vari√°vel.  Cada quadro tem o mesmo tamanho, portanto, a fragmenta√ß√£o devido a quadros muito pequenos n√£o √© poss√≠vel. <br><br>  Mas isso √© apenas uma <i>apar√™ncia</i> .  De fato, existe uma forma oculta de fragmenta√ß√£o, a chamada <i>fragmenta√ß√£o interna,</i> devido ao fato de que nem toda √°rea de mem√≥ria √© exatamente um m√∫ltiplo do tamanho da p√°gina.  Imagine no exemplo acima, um programa de tamanho 101: ele ainda precisar√° de tr√™s p√°ginas de tamanho 50, e precisar√° de 49 bytes a mais do que voc√™ precisa.  Para maior clareza, a fragmenta√ß√£o devido √† segmenta√ß√£o √© chamada <i>fragmenta√ß√£o externa</i> . <br><br>  N√£o h√° nada de bom na fragmenta√ß√£o interna, mas muitas vezes √© um mal menor que a fragmenta√ß√£o externa.  A mem√≥ria extra ainda √© consumida, mas agora voc√™ n√£o precisa desfragment√°-la, e o volume de fragmenta√ß√£o √© previs√≠vel (em m√©dia, meia p√°gina por √°rea de mem√≥ria). <br><br><h3>  Tabelas de P√°ginas </h3><br>  Vimos que cada um dos milh√µes de p√°ginas poss√≠veis √© mapeado individualmente para um quadro.  Essas informa√ß√µes de tradu√ß√£o de endere√ßo precisam ser armazenadas em algum lugar.  Ao segmentar, registradores de segmentos separados s√£o usados ‚Äã‚Äãpara cada √°rea de mem√≥ria ativa, o que √© imposs√≠vel no caso de p√°ginas, porque h√° muito mais deles que registradores.  Em vez disso, ele usa uma estrutura chamada <i>tabela de p√°gina</i> . <br><br>  Para o exemplo acima, as tabelas ficar√£o assim: <br><br><img src="https://habrastorage.org/webt/ij/g0/93/ijg093nmmxzlvn8fkj3n2fxvujg.png"><br><br>  Como voc√™ pode ver, cada inst√¢ncia do programa possui sua pr√≥pria tabela de p√°ginas.  Um ponteiro para a tabela ativa atual √© armazenado em um registro especial da CPU.  No <code>x86</code> √© chamado de <code>CR3</code> .  Antes de iniciar cada inst√¢ncia do programa, o sistema operacional deve carregar um ponteiro na tabela de p√°ginas correta. <br><br>  Cada vez que a mem√≥ria √© acessada, a CPU l√™ o ponteiro da tabela no registro e procura o quadro correspondente na tabela.  Esta √© uma fun√ß√£o totalmente de hardware que √© executada de forma totalmente transparente para um programa em execu√ß√£o.  Para acelerar o processo, muitas arquiteturas de processadores t√™m um cache especial que lembra os resultados das √∫ltimas convers√µes. <br><br>  Dependendo da arquitetura, atributos como permiss√µes tamb√©m podem ser armazenados no campo de sinalizador da tabela de p√°ginas.  No exemplo acima, o sinalizador <code>r/w</code> torna a p√°gina leg√≠vel e grav√°vel. <br><br><h3>  Tabelas de p√°ginas em camadas </h3><br>  Tabelas de p√°ginas simples t√™m um problema com grandes espa√ßos de endere√ßo: a mem√≥ria √© desperdi√ßada.  Por exemplo, o programa usa quatro p√°ginas virtuais <code>0</code> , <code>1_000_000</code> , <code>1_000_050</code> e <code>1_000_100</code> (usamos <code>_</code> como um separador de d√≠gitos): <br><br><img src="https://habrastorage.org/webt/oh/hc/2d/ohhc2dbnzmw-3qfq1bjmjsksydg.png"><br><br>  Apenas quatro quadros f√≠sicos s√£o necess√°rios, mas h√° mais de um milh√£o de registros na tabela de p√°ginas.  N√£o podemos pular entradas vazias, porque a CPU durante o processo de convers√£o n√£o poder√° ir diretamente para a entrada correta (por exemplo, n√£o √© mais garantido que a quarta p√°gina use a quarta entrada). <br><br>  Para reduzir a perda de mem√≥ria, voc√™ pode usar uma <b>organiza√ß√£o de dois n√≠veis</b> .  A id√©ia √© que usamos tabelas diferentes para √°reas diferentes.  Uma tabela adicional, chamada tabela de p√°gina de <i>segundo n√≠vel</i> , converte entre as √°reas de endere√ßo e as tabelas de p√°gina de primeiro n√≠vel. <br><br>  Isso √© melhor explicado pelo exemplo.  Definimos que cada tabela de n√≠vel 1 √© respons√°vel por uma √°rea de tamanho <code>10_000</code> .  No exemplo acima, as seguintes tabelas existir√£o: <br><br><img src="https://habrastorage.org/webt/7w/3s/qk/7w3sqkqe6zbpna2z4kcnsxqokco.png"><br><br>  A p√°gina 0 cai na primeira √°rea de <code>10_000</code> bytes, portanto, ela usa o primeiro registro na tabela de p√°ginas do segundo n√≠vel.  Essa entrada aponta para a tabela de p√°ginas T1 de primeiro n√≠vel, que determina que a p√°gina 0 se refere ao quadro 0. <br><br>  As p√°ginas <code>1_000_000</code> , <code>1_000_050</code> e <code>1_000_100</code> caem na regi√£o de 100 bytes de <code>10_000</code> , portanto, elas usam o 100¬∫ registro da tabela de p√°ginas de n√≠vel 2. Esse registro aponta para outra tabela de primeiro n√≠vel T2, que converte tr√™s p√°ginas nos quadros 100, 150 e 200. Observa√ß√£o que o endere√ßo da p√°gina nas tabelas do primeiro n√≠vel n√£o cont√©m um deslocamento da regi√£o; portanto, por exemplo, o registro da p√°gina <code>1_000_050</code> √© de apenas <code>50</code> . <br><br>  Ainda temos 100 entradas vazias na tabela do segundo n√≠vel, mas isso √© muito menor que o milh√£o anterior.  O motivo da economia √© que voc√™ n√£o precisa criar tabelas de p√°ginas de primeiro n√≠vel para √°reas de mem√≥ria <code>10_000</code> entre <code>10_000</code> e <code>1_000_000</code> . <br><br>  O princ√≠pio das tabelas de dois n√≠veis pode ser estendido para tr√™s, quatro ou mais n√≠veis.  Em geral, esse sistema √© chamado de tabela de p√°gina <i>multin√≠vel</i> ou <i>hier√°rquica</i> . <br><br>  Conhecendo a organiza√ß√£o da p√°gina e as tabelas de v√°rios n√≠veis, √© poss√≠vel ver como a organiza√ß√£o da p√°gina √© implementada na arquitetura x86_64 (presumimos que o processador funcione no modo de 64 bits). <br><br><h1>  Organiza√ß√£o da p√°gina em x86_64 </h1><br>  A arquitetura x86_64 usa uma tabela de quatro n√≠veis com um tamanho de p√°gina de 4 KB.  Independentemente do n√≠vel, cada tabela de p√°ginas possui 512 elementos.  Cada registro tem um tamanho de 8 bytes; portanto, o tamanho das tabelas √© de 512 √ó 8 bytes = 4 KB. <br><br><img src="https://habrastorage.org/webt/tp/o9/x-/tpo9x-ibzvx7spvyvspck7_rtrq.png"><br><br>  Como voc√™ pode ver, cada √≠ndice de tabela cont√©m 9 bits, o que faz sentido, porque as tabelas possuem 2 ^ 9 = 512 entradas.  Os 12 bits inferiores s√£o o deslocamento da p√°gina de 4 kilobytes (2 ^ 12 bytes = 4 KB).  Os bits 48 a 64 s√£o descartados; portanto, x86_64 n√£o √© realmente um sistema de 64 bits, mas suporta apenas endere√ßos de 48 bits.  H√° planos de expandir o tamanho do endere√ßo para 57 bits por meio de uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tabela de p√°ginas de 5 n√≠veis</a> , mas esse processador ainda n√£o foi criado. <br><br>  Embora os bits 48 a 64 sejam descartados, eles n√£o podem ser configurados para valores arbitr√°rios.  Todos os bits nesse intervalo devem ser c√≥pias do bit 47 para preservar endere√ßos exclusivos e permitir expans√£o futura, por exemplo, para uma tabela de p√°ginas de 5 n√≠veis.  Isso √© chamado de extens√£o de sinal, porque √© muito semelhante a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma extens√£o de sinal em c√≥digo adicional</a> .  Se o endere√ßo for expandido incorretamente, a CPU emitir√° uma exce√ß√£o. <br><br><h3>  Exemplo de convers√£o </h3><br>  Vejamos um exemplo de como a tradu√ß√£o de endere√ßos funciona: <br><br><img src="https://habrastorage.org/webt/zj/ox/fe/zjoxfeno1sahwas8h-ffyxechgm.png"><br><br>  O endere√ßo f√≠sico da tabela de p√°ginas ativas atual das p√°ginas de n√≠vel 4, que √© a tabela raiz das p√°ginas de p√°ginas desse n√≠vel, √© armazenado no <code>CR3</code> .  Cada entrada da tabela de p√°ginas aponta para o quadro f√≠sico da pr√≥xima tabela de n√≠veis.  Uma entrada da tabela de n√≠vel 1 indica o quadro exibido.  Observe que todos os endere√ßos nas tabelas de p√°ginas s√£o f√≠sicos e n√£o virtuais, porque, caso contr√°rio, a CPU precisar√° converter esses endere√ßos (o que pode levar a uma recurs√£o infinita). <br><br>  A hierarquia acima converte duas p√°ginas (em azul).  A partir dos √≠ndices, podemos concluir que os endere√ßos virtuais dessas p√°ginas s√£o <code>0x803fe7f000</code> e <code>0x803FE00000</code> .  Vamos ver o que acontece quando um programa tenta ler a mem√≥ria no endere√ßo <code>0x803FE7F5CE</code> .  Primeiro, converta o endere√ßo em bin√°rio e determine os √≠ndices da tabela de p√°ginas e o deslocamento do endere√ßo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/d08/367/600d08367d49e110f1852796c23f9754.png"><br><br>  Usando esses √≠ndices, agora podemos percorrer a hierarquia das tabelas de p√°ginas e encontrar o quadro correspondente: <br><br><ul><li>  Leia o endere√ßo da tabela de quarto n√≠vel no <code>CR3</code> . </li><li>  O √≠ndice do quarto n√≠vel √© 1, portanto, examinamos o registro com o √≠ndice 1 nesta tabela.  Ela diz que uma tabela de n√≠vel 3 √© armazenada em 16 KB. </li><li>  Carregamos a tabela de terceiro n√≠vel desse endere√ßo e examinamos o registro com o √≠ndice 0, que aponta para a tabela de segundo n√≠vel em 24 KB. </li><li>  O √≠ndice do segundo n√≠vel √© 511, portanto, estamos procurando o √∫ltimo registro nesta p√°gina para descobrir o endere√ßo da tabela do primeiro n√≠vel. </li><li>  A partir da entrada com o √≠ndice 127 na tabela de primeiro n√≠vel, finalmente descobrimos que a p√°gina corresponde a um quadro de 12 KB ou 0xc000 no formato hexadecimal. </li><li>  A etapa final √© adicionar um deslocamento ao endere√ßo do quadro para obter o endere√ßo f√≠sico: 0xc000 + 0x5ce = 0xc5ce. </li></ul><br><img src="https://habrastorage.org/webt/mo/iq/-g/moiq-grelw6eyagqsuygebpugkm.png"><br><br>  Para a p√°gina na tabela do primeiro n√≠vel, o sinalizador <code>r</code> √© especificado, ou seja, apenas a leitura √© permitida.  Uma exce√ß√£o ser√° lan√ßada no n√≠vel do hardware se tentarmos gravar l√°.  As permiss√µes das tabelas de n√≠vel superior se estendem aos n√≠veis inferiores; portanto, se definirmos o sinalizador somente leitura no terceiro n√≠vel, nenhuma p√°gina subsequente de n√≠vel inferior ser√° grav√°vel, mesmo que os sinalizadores que permitem a grava√ß√£o sejam indicados l√°. <br><br>  Embora este exemplo use apenas uma inst√¢ncia de cada tabela, geralmente em cada espa√ßo de endere√ßo, existem v√°rias inst√¢ncias de cada n√≠vel.  M√°ximo: <br><br><ul><li>  uma mesa do quarto n√≠vel, </li><li>  512 tabelas do terceiro n√≠vel (j√° que existem 512 registros na tabela do quarto n√≠vel), </li><li>  512 * 512 tabelas de segundo n√≠vel (j√° que cada uma das tabelas de terceiro n√≠vel possui 512 entradas) e </li><li>  512 * 512 * 512 tabelas do primeiro n√≠vel (512 registros para cada tabela do segundo n√≠vel). </li></ul><br><h3>  Formato da tabela de p√°ginas </h3><br>  Na arquitetura x86_64, as tabelas de p√°ginas s√£o essencialmente matrizes de 512 entradas.  Na sintaxe Rust: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(align(4096))]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PageTable</span></span></span></span> { entries: [PageTableEntry; <span class="hljs-number"><span class="hljs-number">512</span></span>], }</code> </pre> <br>  Conforme indicado no atributo <code>repr</code> , as tabelas devem estar alinhadas na p√°gina, ou seja, na borda de 4 KB.  Esse requisito garante que a tabela sempre preencha de maneira ideal a p√°gina inteira, tornando as entradas muito compactas. <br><br>  O tamanho de cada registro √© 8 bytes (64 bits) e o seguinte formato: <br><br><table><thead><tr><th>  Bit (s) </th><th>  T√≠tulo </th><th>  Valor </th></tr></thead><tbody><tr><td>  0 0 </td><td>  presente </td><td>  p√°gina na mem√≥ria </td></tr><tr><td>  1 </td><td>  grav√°vel </td><td>  registro permitido </td></tr><tr><td>  2 </td><td>  acess√≠vel ao usu√°rio </td><td>  se o bit n√£o estiver definido, somente o kernel ter√° acesso √† p√°gina </td></tr><tr><td>  3 </td><td>  escrever atrav√©s de cache </td><td>  escreva diretamente na mem√≥ria </td></tr><tr><td>  4 </td><td>  desativar cache </td><td>  desativar cache para esta p√°gina </td></tr><tr><td>  5 </td><td>  acessado </td><td>  A CPU define esse bit quando a p√°gina est√° em uso. </td></tr><tr><td>  6 </td><td>  sujo </td><td>  A CPU define esse bit ao escrever na p√°gina </td></tr><tr><td>  7 </td><td>  p√°gina enorme / nula </td><td>  o bit zero em P1 e P4 cria p√°ginas de 1 KB em P3, p√°gina de 2 MB em P2 </td></tr><tr><td>  8 </td><td>  global </td><td>  a p√°gina n√£o √© preenchida do cache ao alternar o espa√ßo de endere√ßo (o bit PGE do registro CR4 deve ser definido) </td></tr><tr><td>  9-11 </td><td>  dispon√≠vel </td><td>  OS pode us√°-los livremente </td></tr><tr><td>  12-51 </td><td>  endere√ßo f√≠sico </td><td>  endere√ßo f√≠sico de 52 bits alinhado √† p√°gina do quadro ou a seguinte tabela de p√°ginas </td></tr><tr><td>  52-62 </td><td>  dispon√≠vel </td><td>  OS pode us√°-los livremente </td></tr><tr><td>  63. </td><td>  sem executar </td><td>  pro√≠be a execu√ß√£o de c√≥digo nesta p√°gina (o bit NXE deve ser definido no registro EFER) </td></tr></tbody></table><br>  Vemos que apenas os bits 12 a 51 s√£o usados ‚Äã‚Äãpara armazenar o endere√ßo f√≠sico do quadro, e o restante funciona como sinalizador ou pode ser usado livremente pelo sistema operacional.  Isso √© poss√≠vel porque sempre apontamos para um endere√ßo alinhado a 4096 bytes ou para uma p√°gina alinhada de tabelas ou para o in√≠cio do quadro correspondente.  Isso significa que os bits de 0 a 11 s√£o sempre zero, portanto, n√£o podem ser armazenados, s√£o simplesmente redefinidos para o n√≠vel de hardware antes de usar o endere√ßo.  O mesmo se aplica aos bits 52-63, uma vez que a arquitetura x86_64 suporta apenas endere√ßos f√≠sicos de 52 bits (e apenas endere√ßos virtuais de 48 bits). <br><br>  Vamos dar uma olhada nos sinalizadores dispon√≠veis: <br><br><ul><li>  O sinalizador <code>present</code> distingue as p√°ginas exibidas das n√£o exibidas.  Pode ser usado para salvar temporariamente as p√°ginas no disco quando a mem√≥ria principal estiver cheia.  Na pr√≥xima vez que a p√°gina for acessada, ocorrer√° uma exce√ß√£o especial PageFault, √† qual o SO responder√° trocando a p√°gina do disco - o programa continua. </li><li>  Os sinalizadores <code>writable</code> e <code>no execute</code> determinam se o conte√∫do da p√°gina √© grav√°vel ou cont√©m instru√ß√µes execut√°veis, respectivamente. </li><li>  Os sinalizadores <code>accessed</code> e <code>dirty</code> s√£o definidos automaticamente pelo processador ao ler ou gravar na p√°gina.  O sistema operacional pode usar essas informa√ß√µes, por exemplo, se trocar de p√°gina ou ao verificar se o conte√∫do da p√°gina foi alterado desde o √∫ltimo bombeamento para o disco. </li><li>  Os sinalizadores de <code>write through caching</code> e <code>disable cache</code> permitem gerenciar o cache de cada p√°gina individualmente. </li><li>  O sinalizador <code>user accessible</code> torna a p√°gina acess√≠vel para c√≥digo no espa√ßo do usu√°rio, caso contr√°rio, est√° dispon√≠vel apenas para o kernel.  Esta fun√ß√£o pode ser usada para acelerar as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chamadas do sistema</a> , mantendo o mapeamento de endere√ßos para o kernel enquanto o programa do usu√°rio est√° em execu√ß√£o.  No entanto, a vulnerabilidade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Spectre</a> permite que essas p√°ginas sejam lidas por programas no espa√ßo do usu√°rio. </li><li>  <code>global</code>  ,                (.   TLB )     (address space switch).     user <code>accessible</code>        . </li><li>  <code>huge page</code>     ,      2  3     .      512 :     2  = 512 √ó 4 ,      1  = 512 √ó 2 .             . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A arquitetura x86_64 define o formato </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das tabelas de p√°ginas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e seus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registros</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , portanto, n√£o precisamos criar essas estruturas sozinhos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buffer de tradu√ß√£o associativa (TLB) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por causa dos quatro n√≠veis, cada convers√£o de endere√ßo requer quatro acessos √† mem√≥ria. Por motivos de desempenho, x86_64 armazena em cache as √∫ltimas tradu√ß√µes no chamado buffer de tradu√ß√£o associativa (TLB). Isso permite que voc√™ pule a convers√£o se ela ainda estiver no cache. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferentemente de outros caches de processador, o TLB n√£o √© completamente transparente, n√£o atualiza ou exclui convers√µes ao alterar o conte√∫do das tabelas de p√°ginas. Isso significa que o kernel deve atualizar o pr√≥prio TLB sempre que modificar a tabela de p√°ginas. Para fazer isso, existe uma instru√ß√£o especial da CPU chamada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>invlpg</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(p√°gina inv√°lida), que remove a tradu√ß√£o da p√°gina especificada do TLB, para que na pr√≥xima vez que ela seja carregada novamente da tabela de p√°ginas. O TLB √© completamente limpo ao recarregar o registro</font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que imita um comutador de espa√ßo de endere√ßo. </font><font style="vertical-align: inherit;">Ambas as op√ß√µes est√£o dispon√≠veis </font><font style="vertical-align: inherit;">atrav√©s do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√≥dulo tlb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no Rust. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â importante lembrar de limpar o TLB ap√≥s cada altera√ß√£o na tabela de p√°ginas, caso contr√°rio, a CPU continuar√° usando a tradu√ß√£o antiga, o que levar√° a erros imprevis√≠veis que s√£o muito dif√≠ceis de depurar.</font></font><br><br><h1>  Implementa√ß√£o </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o mencionamos uma coisa: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nosso n√∫cleo j√° suporta a organiza√ß√£o da p√°gina</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O gerenciador de inicializa√ß√£o do artigo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúMinimal Kernel on Rust‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> j√° estabeleceu uma hierarquia de quatro n√≠veis que mapeia cada p√°gina do nosso kernel para um quadro f√≠sico, porque a organiza√ß√£o da p√°gina √© necess√°ria no modo de 64 bits no x86_64. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso significa que em nosso n√∫cleo todos os endere√ßos de mem√≥ria s√£o virtuais. O acesso ao buffer VGA no endere√ßo </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funcionou apenas porque o identificador do carregador de inicializa√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">converteu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> esta p√°gina na mem√≥ria, ou seja, mapeou a p√°gina virtual </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o quadro f√≠sico </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gra√ßas √† organiza√ß√£o da p√°gina, o kernel j√° √© relativamente seguro: todo acesso al√©m da mem√≥ria permitida causa um erro de p√°gina e n√£o permite a grava√ß√£o na mem√≥ria f√≠sica. </font><font style="vertical-align: inherit;">O carregador at√© define as permiss√µes de acesso corretas para cada p√°gina: somente p√°ginas com c√≥digo ser√£o execut√°veis ‚Äã‚Äãe somente p√°ginas com dados s√£o grav√°veis</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erros de p√°gina (PageFault) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos tentar chamar o PageFault acessando a mem√≥ria fora do kernel. </font><font style="vertical-align: inherit;">Primeiro, crie um manipulador de erros e registre-o em nosso IDT para ver uma exce√ß√£o espec√≠fica em vez de um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erro duplo de um</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tipo geral:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/interrupts.rs lazy_static! { static ref IDT: InterruptDescriptorTable = { let mut idt = InterruptDescriptorTable::new(); [‚Ä¶] idt.page_fault.set_handler_fn(page_fault_handler); // new idt }; } use x86_64::structures::idt::PageFaultErrorCode; extern "x86-interrupt" fn page_fault_handler( stack_frame: &amp;mut ExceptionStackFrame, _error_code: PageFaultErrorCode, ) { use crate::hlt_loop; use x86_64::registers::control::Cr2; println!("EXCEPTION: PAGE FAULT"); println!("Accessed Address: {:?}", Cr2::read()); println!("{:#?}", stack_frame); hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se a p√°gina falhar, a CPU definir√° o caso automaticamente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>CR2</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ele cont√©m o endere√ßo virtual da p√°gina que causou a falha. Para ler e exibir este endere√ßo usando a fun√ß√£o </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cr2::read</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Normalmente, o tipo </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PageFaultErrorCode</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece mais informa√ß√µes sobre o tipo de acesso √† mem√≥ria que causou o erro, mas devido ao </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">LLVM, um</font></a><font style="vertical-align: inherit;"> c√≥digo de erro inv√°lido √© passado, portanto, ignoramos essas informa√ß√µes por enquanto. A execu√ß√£o do programa n√£o pode ser continuada at√© que resolvamos o erro da p√°gina, ent√£o insira no final </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hlt_loop</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora temos acesso √† mem√≥ria fora do kernel:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use blog_os::interrupts::PICS; println!("Hello World{}", "!"); // set up the IDT first, otherwise we would enter a boot loop instead of // invoking our page fault handler blog_os::gdt::init(); blog_os::interrupts::init_idt(); unsafe { PICS.lock().initialize() }; x86_64::instructions::interrupts::enable(); // new let ptr = 0xdeadbeaf as *mut u32; unsafe { *ptr = 42; } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s o in√≠cio, vemos que o manipulador de erros de p√°gina √© chamado: O </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/81e/aad/666/81eaad666e7980ce90867ffe3fcb0be3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registro </font></font><code>CR2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente cont√©m o endere√ßo que </font></font><code>0xdeadbeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desejamos acessar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ponteiro de instru√ß√£o atual √© </font></font><code>0x20430a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, portanto sabemos que esse endere√ßo aponta para uma p√°gina de c√≥digo. </font><font style="vertical-align: inherit;">As p√°ginas de c√≥digo s√£o exibidas pelo carregador somente leitura, portanto, a leitura desse endere√ßo funciona e a grava√ß√£o causar√° um erro. </font><font style="vertical-align: inherit;">Tente alterar o ponteiro </font></font><code>0xdeadbeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>0x20430a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Note: The actual address might be different for you. Use the address that // your page fault handler reports. let ptr = 0x20430a as *mut u32; // read from a code page -&gt; works unsafe { let x = *ptr; } // write to a code page -&gt; page fault unsafe { *ptr = 42; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se comentarmos a √∫ltima linha, podemos garantir que a leitura funcione e a grava√ß√£o cause um erro de PageFault. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acesso a tabelas de p√°ginas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora d√™ uma olhada nas tabelas de p√°ginas do kernel: </font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use x86_64::registers::control::Cr3; let (level_4_page_table, _) = Cr3::read(); println!("Level 4 page table at: {:?}", level_4_page_table.start_address()); [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A fun√ß√£o </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cr3::read</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorna do registro a </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tabela ativa atual de p√°ginas do quarto n√≠vel. Um casal volta </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PhysFrame</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cr3Flags</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Estamos interessados ‚Äã‚Äãapenas no primeiro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s o in√≠cio, vemos este resultado: </font></font><br><br> <code>Level 4 page table at: PhysAddr(0x1000)</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atualmente, a tabela ativa de p√°ginas do quarto n√≠vel √© armazenada na </font><font style="vertical-align: inherit;">mem√≥ria </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√≠sica</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no endere√ßo </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicado pelo tipo </font></font><code>PhysAddr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Agora a pergunta √©: como acessar esta tabela a partir do kernel? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com a organiza√ß√£o da p√°gina, o acesso direto √† mem√≥ria f√≠sica n√£o √© poss√≠vel; caso contr√°rio, os programas poder√£o ignorar facilmente a prote√ß√£o e obter acesso √† mem√≥ria de outros programas. Portanto, a √∫nica maneira de obter acesso √© atrav√©s de alguma p√°gina virtual, que √© traduzida em um quadro f√≠sico em</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este √© um problema t√≠pico porque o kernel deve acessar regularmente as tabelas de p√°ginas, por exemplo, ao alocar uma pilha para um novo encadeamento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As solu√ß√µes para esse problema ser√£o descritas em detalhes no pr√≥ximo artigo. Por enquanto, digamos apenas que o carregador usa um m√©todo chamado </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tabelas de p√°ginas recursivas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A √∫ltima p√°gina do espa√ßo de endere√ßo virtual √© </font></font><code>0xffff_ffff_ffff_f000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, usamos-o para ler algumas entradas nesta tabela:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { let level_4_table_pointer = 0xffff_ffff_ffff_f000 as *const u64; for i in 0..10 { let entry = unsafe { *level_4_table_pointer.offset(i) }; println!("Entry {}: {:#x}", i, entry); } [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reduzimos o endere√ßo da √∫ltima p√°gina virtual para um ponteiro para </font></font><code>u64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Conforme declarado na se√ß√£o anterior, cada entrada da tabela de p√°ginas tem 8 bytes (64 bits) de tamanho e, portanto, </font></font><code>u64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">representa exatamente uma entrada. Usando o loop, </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exibimos os 10 primeiros registros da tabela. Dentro do loop, usamos um bloco n√£o seguro para ler diretamente do ponteiro e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code> offset</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calcular o ponteiro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de iniciar vemos os seguintes resultados: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/725/8b0/9cb/7258b09cb744af09041bb3a2ee05fd54.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De acordo com o formato descrito acima, o valor de </font></font><code>0x2023</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meios de registo possuindo bandeiras 0 </font></font><code>present</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>writable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>accessed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a tradu√ß√£o numa moldura </font></font><code>0x2000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O registro 1 √© transmitido no quadro </font></font><code>0x6e2000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e possui os mesmos sinalizadores, al√©m de</font></font><code>dirty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As entradas 2 a 9 est√£o ausentes, portanto, esses intervalos de endere√ßos virtuais n√£o s√£o mapeados para nenhum endere√ßo f√≠sico. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez de trabalhar diretamente com ponteiros n√£o seguros, voc√™ pode usar um tipo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>PageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use x86_64::structures::paging::PageTable; let level_4_table_ptr = 0xffff_ffff_ffff_f000 as *const PageTable; let level_4_table = unsafe {&amp;*level_4_table_ptr}; for i in 0..10 { println!("Entry {}: {:?}", i, level_4_table[i]); } [‚Ä¶] }</span></span></code> </pre> <br>     <code>0xffff_ffff_ffff_f000</code>  ,       Rust.  - ,      ,      .        <code>&amp;PageTable</code> ,        ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> . <br><br> <code>x86_64</code>       ,     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/70a/d89/73d/70ad8973d35a531c7ad5943ef5144ef8.png"><br><br>   ‚Äî      0   1     3.       ,  <code>0x2000</code>  <code>0x6e5000</code>    ,         .       . <br><br><h1>  Sum√°rio </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O artigo apresenta dois m√©todos de prote√ß√£o de mem√≥ria: segmenta√ß√£o e organiza√ß√£o da p√°gina. O primeiro m√©todo usa √°reas de mem√≥ria de tamanho vari√°vel e sofre fragmenta√ß√£o externa, o segundo usa p√°ginas de tamanho fixo e permite um controle muito mais granular sobre os direitos de acesso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma organiza√ß√£o de p√°ginas armazena informa√ß√µes de convers√£o de p√°ginas em tabelas de um ou mais n√≠veis. A arquitetura x86_64 usa tabelas de quatro n√≠veis com um tamanho de p√°gina de 4 KB. O equipamento ignora automaticamente as tabelas de p√°ginas e armazena em cache os resultados da convers√£o no buffer de tradu√ß√£o associativo (TLB). Ao alterar as tabelas de p√°ginas, ele deve ser for√ßado a limpar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aprendemos que nosso n√∫cleo j√° suporta a organiza√ß√£o da p√°gina e que o acesso n√£o autorizado √† mem√≥ria reduz o PageFault. </font><font style="vertical-align: inherit;">Tentamos acessar as tabelas de p√°ginas ativas no momento, mas conseguimos acessar apenas a tabela de quarto n√≠vel, pois os endere√ßos das p√°ginas armazenam endere√ßos f√≠sicos e n√£o podemos acess√°-los diretamente do kernel.</font></font><br><br><h1>  O que vem a seguir? </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O artigo a seguir √© baseado nos fundamentos fundamentais que aprendemos agora. </font><font style="vertical-align: inherit;">Para acessar as tabelas de p√°ginas do kernel, uma t√©cnica avan√ßada chamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tabelas de p√°ginas recursivas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© usada para percorrer a hierarquia das tabelas e implementar a tradu√ß√£o de endere√ßos program√°tica. </font><font style="vertical-align: inherit;">O artigo tamb√©m explica como criar novas tradu√ß√µes em tabelas de p√°ginas.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436606/">https://habr.com/ru/post/pt436606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436594/index.html">Adeus Chevy Volt: Hist√≥rias e lendas do h√≠brido recarreg√°vel</a></li>
<li><a href="../pt436596/index.html">Os desenvolvedores de pilha cheia est√£o de fato presos no n√≠vel intermedi√°rio. Poupe-se do sofrimento - n√£o siga esse caminho</a></li>
<li><a href="../pt436598/index.html">Um passo gigante para uma m√°quina de xadrez</a></li>
<li><a href="../pt436600/index.html">Direitos autorais ultrapassados ‚Äã‚Äãe coreografia: criadores do Fortnite processados ‚Äã‚Äãdevido √† dan√ßa de personagens do jogo pa</a></li>
<li><a href="../pt436602/index.html">M√≥dulo de carga Dawn: 20 anos em √≥rbita</a></li>
<li><a href="../pt436608/index.html">[SAP] SAPUI5 para manequins: um exerc√≠cio completo passo a passo</a></li>
<li><a href="../pt436610/index.html">Como a especificidade do CSS funciona em um navegador</a></li>
<li><a href="../pt436612/index.html">Brian Krebs: banco de dados de conta de mega vazamento contendo centenas de milh√µes de registros, 2-3 anos</a></li>
<li><a href="../pt436614/index.html">Tesla reduzir√° em 7% o n√∫mero de funcion√°rios permanentes em todo o mundo</a></li>
<li><a href="../pt436616/index.html">Como Cingapura trabalha com inova√ß√£o: da regulamenta√ß√£o do governo √†s boates</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>