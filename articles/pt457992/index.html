<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè† ü§üüèº üåì Interruptor de toque sem fio com luz de fundo fluorescente adicional üôãüèª üßñüèΩ ‚ôçÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sauda√ß√µes a todos os leitores da se√ß√£o fa√ßa voc√™ mesmo ou fa√ßa voc√™ mesmo em Habr! O artigo de hoje ser√° sobre o interruptor de toque no chip TTP223 |...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interruptor de toque sem fio com luz de fundo fluorescente adicional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457992/"> Sauda√ß√µes a todos os leitores da se√ß√£o fa√ßa voc√™ mesmo ou fa√ßa voc√™ mesmo em Habr!  O artigo de hoje ser√° sobre o interruptor de toque no chip TTP223 |  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">datasheet</a> .  O switch opera no microcontrolador nRF52832 |  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">datasheet</a> , m√≥dulo YJ-17103 com uma antena impressa e um conector para uma antena externa MHF4.  O interruptor sens√≠vel ao toque √© alimentado por baterias CR2430 ou CR2450.  O consumo no modo de transmiss√£o n√£o √© superior a 8mA, no modo de suspens√£o n√£o √© superior a 6mA. <br><img src="https://habrastorage.org/webt/nv/3m/ll/nv3mll44dl6x7xfezcqlvf76aum.jpeg"><br><a name="habracut"></a><br><br>  Como todos os projetos anteriores, este tamb√©m √© um projeto do Arduino, o programa est√° escrito no IDE do Arduino.  A implementa√ß√£o do software do dispositivo √© baseada no protocolo Mysensors |  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bibliotecas do GitHub</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">suporte do GitHub para placas</a> nRF5 nos Mysensors.  F√≥rum da comunidade em ingl√™s - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://forum.mysensors.org</a> , f√≥rum da comunidade em russo - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://mysensors.ru/forum/</a> <br>  (Para aqueles que desejam estudar - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Documenta√ß√£o</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Protocolo Serial</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API</a> , <a href="">Protocolo</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Analisador</a> | para aqueles que desejam ajudar no desenvolvimento do projeto - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Documenta√ß√£o</a> ) <br><br>  A placa do interruptor de toque foi desenvolvida no programa Diptrace, levando em considera√ß√£o a fabrica√ß√£o subsequente, de acordo com o m√©todo da Laser Iron Technology (LUT).  A placa foi desenvolvida em tamanhos de 60x60mm (o painel de vidro padr√£o tem dimens√µes de 80x80mm).  O circuito foi impresso nas p√°ginas da revista Antena e transferido por um ferro da Bosch com a configura√ß√£o ‚ÄúLen‚Äù (pot√™ncia m√°xima) para uma placa de fibra de vidro revestida com papel de dupla face de 1,5 mm, 35 ¬µm (por falta de outro). <br><img src="https://habrastorage.org/webt/zw/my/ol/zwmyoloe347bfubkfz7btxbzo90.png"><br><br>  A grava√ß√£o foi realizada com uma solu√ß√£o de cloreto f√©rrico, previamente preparada nas propor√ß√µes de 1,5 partes de uma colher por 250 ml de √°gua morna.  O processo levou 15 minutos. <br>  Os furos para as transi√ß√µes entre camadas e para a montagem do suporte da bateria foram perfurados com uma mini furadeira DREMEL 3000 montada em um suporte de broca DREMEL 220. Os furos para as transi√ß√µes entre camadas foram perfurados com uma broca de 0,4 mm, os furos para o suporte da bateria com uma broca de 1,1 mm.  O corte ao longo das bordas da placa foi realizado com a mesma mini-broca com um bico DREMEL 540 (roda de corte d = 32,0 mm).  A colheita foi realizada em um respirador. <br>  O estanho do cart√£o gravado foi realizado usando uma liga de Rosa em uma solu√ß√£o aquosa (1 colher de ch√° de √°cido c√≠trico cristalizado em 300 ml de √°gua). <br><br>  O processo de soldagem levou cerca de uma hora, a maior parte do tempo foi gasta na soldagem do fio (estanhado, 0,4 mm de di√¢metro) nos orif√≠cios para transi√ß√µes entre camadas. <br><br>  A placa foi lavada com o limpador de aerossol FLUX OFF. <br><img src="https://habrastorage.org/webt/ki/_6/uo/ki_6uon6uucqrmidns10iydvgao.jpeg"><br><br><img src="https://habrastorage.org/webt/kl/my/ix/klmyix8dkj7peomxmtfzt5rucqi.jpeg"><br><br>  O desenvolvimento do gabinete do dispositivo foi realizado em um editor de design tridimensional auxiliado por computador.  Dimens√µes da caixa: 78,5 mm x 78,5 mm x 12 mm. <br><img src="https://habrastorage.org/webt/ix/va/5k/ixva5kuvplal69-idcu7-ptynws.png"><br><br>  O modelo acabado da carca√ßa e a tampa da bateria foram salvos no formato STL; ent√£o, foi necess√°rio preparar esses modelos para impress√£o em uma impressora SLA (adi√ß√£o de suportes, orienta√ß√£o).  Nesse ponto, surgiu um pequeno problema, j√° que a √°rea de impress√£o das impressoras dom√©sticas de SLA √© pequena.  O modelo do corpo do dispositivo na posi√ß√£o mais ideal em rela√ß√£o ao tempo de impress√£o n√£o se encaixava no tamanho da √°rea de impress√£o.  Ao colocar o modelo em 45 graus, tamb√©m deu um resultado decepcionante, o peso do suporte foi igual ao peso do modelo do gabinete.  Decidiu-se imprimir o modelo verticalmente, apoiando-se em uma das laterais, concordando previamente com o fato do p√≥s-processamento.  Demorou 5 horas para selar o gabinete com uma configura√ß√£o de camada de 50 m√≠crons.  Em seguida, o processamento foi realizado com uma lixa de granula√ß√£o muito fina (n√£o escrevo o n√∫mero, porque n√£o sei :)).  A tampa da bateria foi impressa por 40 minutos. <br><img src="https://habrastorage.org/webt/pe/mg/j0/pemgj0d1ebfhby9tqfrywzggb0s.png"><br><br>  Os pain√©is de vidro com Aliexpress s√£o vendidos com uma arma√ß√£o de pl√°stico j√° colada, n√£o houve problemas ao remover a arma√ß√£o.  Tirei o pr√©-aquecimento do painel de vidro com um secador de cabelo comum. <br><img src="https://habrastorage.org/webt/1b/i_/4i/1bi_4iqjmns1ywbtldjxoiyxvy4.jpeg"><br><br><img src="https://habrastorage.org/webt/md/3a/2c/md3a2c-6rddr2-7svvyfltyykqy.jpeg"><br><br>  O difusor para a luz de fundo do LED foi feito de fita dupla face com adesivo acr√≠lico 3M 9088-200.  Para ilumina√ß√£o fluorescente, havia v√°rios materiais para escolher: fita adesiva chinesa e papel adesivo cortado em fitas da empresa dom√©stica Luminophore.  A escolha foi feita em favor de um fabricante nacional; de acordo com meus sentimentos, brilhou mais e mais.  Um quadrado feito de papel com pigmento fluorescente foi colado sobre a fita dupla face 3M 9088-200. <br><br>  O vidro foi colado ao gabinete do disjuntor usando fita dupla face com adesivo acr√≠lico 3M VHB 4910. <br><img src="https://habrastorage.org/webt/il/n3/no/iln3no5zweymnpoi0crulwz6nws.jpeg"><br><br>  A cobertura foi fixada com um parafuso M 1,4 X 5 mm. <br><br>  O custo do dispositivo foi de 890 rublos. <br><br>  A seguir veio a parte do software.  N√£o tem problema  Acontece que os microcircuitos do sensor TTP223 funcionam perfeitamente com energia estabilizada a 3,3V e n√£o s√£o muito bons quando alimentados diretamente de uma bateria bem descarregada.  No in√≠cio do dispositivo com energia na regi√£o de 2,5v, mais ap√≥s um "rebaixamento" adicional ao elaborar a apresenta√ß√£o dos Mysensors, o chip TTP223 (imediatamente ap√≥s a calibra√ß√£o) fez com que o MC interrompesse porque estava com o gatilho ativo. <br><br>  O circuito para fornecer energia ao chip (gerenciamento de energia TTP223 com gpio MK) foi alterado, foi fornecido terra adicional, nas linhas de led rgb (que passam do outro lado da placa do sensor capacitivo), foram substitu√≠dos resistores com maior resist√™ncia.  Tamb√©m foi adicionado ao software: ativa√ß√£o de energia para um microcircuito capacitivo ap√≥s iniciar o framework Mysensors e elaborar a apresenta√ß√£o.  O atraso para a calibra√ß√£o autom√°tica do chip TTP223 √© dobrado quando a energia √© aplicada a ele.  Todas essas altera√ß√µes corrigiram completamente esse problema. <br><br><div class="spoiler">  <b class="spoiler_title">Antes de visualizar o c√≥digo do programa, recomendo que voc√™ se familiarize com a estrutura b√°sica dos esbo√ßos nos Mysensors.</b> <div class="spoiler_text"><code>void before() <br> { <br> //  ,       ,  before()   setup(),       Mysensors,      SPI <br> } <br> <br> void setup() <br> { <br> <br> } <br> <br> void presentation() <br> { <br> //           <br> sendSketchInfo("Name of my sensor node", "1.0"); //   ,   <br> present(CHILD_ID, S_WHATEVER, "Description"); //   ,   <br> } <br> <br> void loop() <br> { <br> <br> } <br></code> <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de teste para o programa touch switch:</b> <div class="spoiler_text">  test_sens.ino <br> <code>/** <br>        NRF_LPCOMP <br> */ <br> bool button_flag; <br> bool sens_flag; <br> bool send_flag; <br> bool detection; <br> bool nosleep; <br> byte timer; <br> unsigned long SLEEP_TIME = 21600000; //6 hours <br> unsigned long oldmillis; <br> unsigned long newmillis; <br> unsigned long interrupt_time; <br> unsigned long SLEEP_TIME_W; <br> uint16_t currentBatteryPercent; <br> uint16_t batteryVoltage = 0; <br> uint16_t battery_vcc_min = 2400; <br> uint16_t battery_vcc_max = 3000; <br> <br> #define MY_RADIO_NRF5_ESB <br> //#define MY_PASSIVE_NODE <br> #define MY_NODE_ID 30 <br> #define MY_PARENT_NODE_ID 0 <br> #define MY_PARENT_NODE_IS_STATIC <br> #define MY_TRANSPORT_UPLINK_CHECK_DISABLED <br> #define IRT_PIN 3 //(PORT0, gpio 5) <br> #include &lt;MySensors.h&gt; <br> // see https://www.mysensors.org/download/serial_api_20 <br> #define SENS_CHILD_ID 0 <br> #define CHILD_ID_VOLT 254 <br> MyMessage sensMsg(SENS_CHILD_ID, V_VAR1); <br> //MyMessage voltMsg(CHILD_ID_VOLT, V_VOLTAGE); <br> <br> void preHwInit() { <br> sleep(2000); <br> pinMode(RED_LED, OUTPUT); <br> digitalWrite(RED_LED, HIGH); <br> pinMode(GREEN_LED, OUTPUT); <br> digitalWrite(GREEN_LED, HIGH); <br> pinMode(BLUE_LED, OUTPUT); <br> digitalWrite(BLUE_LED, HIGH); <br> pinMode(MODE_PIN, INPUT); <br> pinMode(SENS_PIN, INPUT); <br> } <br> <br> void before() <br> { <br> NRF_POWER-&gt;DCDCEN = 1; <br> NRF_UART0-&gt;ENABLE = 0; <br> sleep(1000); <br> digitalWrite(BLUE_LED, LOW); <br> sleep(150); <br> digitalWrite(BLUE_LED, HIGH); <br> } <br> <br> void presentation() { <br> sendSketchInfo("EFEKTA Sens 1CH Sensor", "1.1"); <br> present(SENS_CHILD_ID, S_CUSTOM, "SWITCH STATUS"); <br> //present(CHILD_ID_VOLT, S_MULTIMETER, "Battery"); <br> } <br> <br> void setup() { <br> digitalWrite(BLUE_LED, LOW); <br> sleep(100); <br> digitalWrite(BLUE_LED, HIGH); <br> sleep(200); <br> digitalWrite(BLUE_LED, LOW); <br> sleep(100); <br> digitalWrite(BLUE_LED, HIGH); <br> lpComp(); <br> detection = false; <br> SLEEP_TIME_W = SLEEP_TIME; <br> pinMode(31, OUTPUT); <br> digitalWrite(31, HIGH); <br> /* <br> while (timer &lt; 10) { <br> timer++; <br> digitalWrite(GREEN_LED, LOW); <br> wait(5); <br> digitalWrite(GREEN_LED, HIGH); <br> wait(500); <br> } <br> timer = 0; <br> */ <br> sleep(7000); <br> while (timer &lt; 3) { <br> timer++; <br> digitalWrite(GREEN_LED, LOW); <br> sleep(15); <br> digitalWrite(GREEN_LED, HIGH); <br> sleep(85); <br> } <br> timer = 0; <br> sleep(1000); <br> } <br> <br> void loop() { <br> <br> if (detection) { <br> if (digitalRead(MODE_PIN) == 1 &amp;&amp; button_flag == 0 &amp;&amp; digitalRead(SENS_PIN) == 0) { <br> //back side button detection <br> button_flag = 1; <br> nosleep = 1; <br> } <br> if (digitalRead(MODE_PIN) == 1 &amp;&amp; button_flag == 1 &amp;&amp; digitalRead(SENS_PIN) == 0) { <br> digitalWrite(RED_LED, LOW); <br> wait(10); <br> digitalWrite(RED_LED, HIGH); <br> wait(50); <br> } <br> if (digitalRead(MODE_PIN) == 0 &amp;&amp; button_flag == 1 &amp;&amp; digitalRead(SENS_PIN) == 0) { <br> nosleep = 0; <br> button_flag = 0; <br> digitalWrite(RED_LED, HIGH); <br> lpComp_reset(); <br> } <br> <br> if (digitalRead(SENS_PIN) == 1 &amp;&amp; sens_flag == 0 &amp;&amp; digitalRead(MODE_PIN) == 0) { <br> //sens detection <br> sens_flag = 1; <br> nosleep = 1; <br> newmillis = millis(); <br> interrupt_time = newmillis - oldmillis; <br> SLEEP_TIME_W = SLEEP_TIME_W - interrupt_time; <br> if (send(sensMsg.set(detection))) { <br> send_flag = 1; <br> } <br> } <br> if (digitalRead(SENS_PIN) == 1 &amp;&amp; sens_flag == 1 &amp;&amp; digitalRead(MODE_PIN) == 0) { <br> if (send_flag == 1) { <br> while (timer &lt; 10) { <br> timer++; <br> digitalWrite(GREEN_LED, LOW); <br> wait(20); <br> digitalWrite(GREEN_LED, HIGH); <br> wait(30); <br> } <br> timer = 0; <br> } else { <br> while (timer &lt; 10) { <br> timer++; <br> digitalWrite(RED_LED, LOW); <br> wait(20); <br> digitalWrite(RED_LED, HIGH); <br> wait(30); <br> } <br> timer = 0; <br> } <br> } <br> if (digitalRead(SENS_PIN) == 0 &amp;&amp; sens_flag == 1 &amp;&amp; digitalRead(MODE_PIN) == 0) { <br> sens_flag = 0; <br> nosleep = 0; <br> send_flag = 0; <br> digitalWrite(GREEN_LED, HIGH); <br> sleep(500); <br> lpComp_reset(); <br> } <br> if (SLEEP_TIME_W &lt; 60000) { <br> SLEEP_TIME_W = SLEEP_TIME; <br> sendBatteryStatus(); <br> } <br> } <br> else { <br> //if (detection == -1) { <br> SLEEP_TIME_W = SLEEP_TIME; <br> sendBatteryStatus(); <br> } <br> if (nosleep == 0) { <br> oldmillis = millis(); <br> sleep(SLEEP_TIME_W); <br> } <br> } <br> <br> void sendBatteryStatus() { <br> wait(20); <br> batteryVoltage = hwCPUVoltage(); <br> wait(2); <br> <br> if (batteryVoltage &gt; battery_vcc_max) { <br> currentBatteryPercent = 100; <br> } <br> else if (batteryVoltage &lt; battery_vcc_min) { <br> currentBatteryPercent = 0; <br> } else { <br> currentBatteryPercent = (100 * (batteryVoltage - battery_vcc_min)) / (battery_vcc_max - battery_vcc_min); <br> } <br> <br> sendBatteryLevel(currentBatteryPercent, 1); <br> wait(2000, C_INTERNAL, I_BATTERY_LEVEL); <br> //send(powerMsg.set(batteryVoltage), 1); <br> //wait(2000, 1, V_VAR1); <br> } <br> <br> void lpComp() { <br> NRF_LPCOMP-&gt;PSEL = IRT_PIN; <br> NRF_LPCOMP-&gt;ANADETECT = 1; <br> NRF_LPCOMP-&gt;INTENSET = B0100; <br> NRF_LPCOMP-&gt;ENABLE = 1; <br> NRF_LPCOMP-&gt;TASKS_START = 1; <br> NVIC_SetPriority(LPCOMP_IRQn, 15); <br> NVIC_ClearPendingIRQ(LPCOMP_IRQn); <br> NVIC_EnableIRQ(LPCOMP_IRQn); <br> } <br> <br> void s_lpComp() { <br> if ((NRF_LPCOMP-&gt;ENABLE) &amp;&amp; (NRF_LPCOMP-&gt;EVENTS_READY)) { <br> NRF_LPCOMP-&gt;INTENCLR = B0100; <br> } <br> } <br> <br> void r_lpComp() { <br> NRF_LPCOMP-&gt;INTENSET = B0100; <br> } <br> <br> #if __CORTEX_M == 0x04 <br> #define NRF5_RESET_EVENT(event) \ <br> event = 0; \ <br> (void)event <br> #else <br> #define NRF5_RESET_EVENT(event) event = 0 <br> #endif <br> <br> extern "C" { <br> void LPCOMP_IRQHandler(void) { <br> detection = true; <br> NRF5_RESET_EVENT(NRF_LPCOMP-&gt;EVENTS_UP); <br> NRF_LPCOMP-&gt;EVENTS_UP = 0; <br> MY_HW_RTC-&gt;CC[0] = (MY_HW_RTC-&gt;COUNTER + 2); <br> } <br> } <br> <br> void lpComp_reset () { <br> s_lpComp(); <br> detection = false; <br> NRF_LPCOMP-&gt;EVENTS_UP = 0; <br> r_lpComp(); <br> } <br></code> <br><br>  MyBoardNRF5.cpp <br> <code>#ifdef MYBOARDNRF5 <br> #include &lt;variant.h&gt; <br> <br> /* <br> * Pins descriptions. Attributes are ignored by arduino-nrf5 variant. <br> * Definition taken from Arduino Primo Core with ordered ports <br> */ <br> const PinDescription g_APinDescription[]= <br> { <br> { NOT_A_PORT, 0, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // LFCLK <br> { NOT_A_PORT, 1, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // LFCLK <br> { PORT0, 2, PIO_DIGITAL, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM), ADC_A0, PWM4, NOT_ON_TIMER}, <br> { PORT0, 3, PIO_DIGITAL, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM), ADC_A1, PWM5, NOT_ON_TIMER}, <br> { PORT0, 4, PIO_DIGITAL, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM), ADC_A2, PWM6, NOT_ON_TIMER}, <br> { PORT0, 5, PIO_DIGITAL, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM), ADC_A3, PWM7, NOT_ON_TIMER}, <br> { PORT0, 6, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // INT3 <br> { PORT0, 7, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // INT4 <br> { PORT0, 8, PIO_DIGITAL, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM), No_ADC_Channel, PWM10, NOT_ON_TIMER}, //USER_LED <br> { PORT0, 9, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // NFC1 <br> { PORT0, 10, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // NFC2 <br> { PORT0, 11, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // TX <br> { PORT0, 12, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // RX <br> { PORT0, 13, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // SDA <br> { PORT0, 14, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // SCL <br> { PORT0, 15, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // SDA1 <br> { PORT0, 16, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // SCL1 <br> { PORT0, 17, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // TP4 <br> { PORT0, 18, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // TP5 <br> { PORT0, 19, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // INT2 <br> { PORT0, 20, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // INT1 <br> { PORT0, 21, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // INT1 <br> { PORT0, 22, PIO_DIGITAL, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM), No_ADC_Channel, PWM9, NOT_ON_TIMER}, <br> { PORT0, 23, PIO_DIGITAL, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM), No_ADC_Channel, PWM8, NOT_ON_TIMER}, <br> { PORT0, 24, PIO_DIGITAL, PIN_ATTR_DIGITAL, No_ADC_Channel, NOT_ON_PWM, NOT_ON_TIMER}, // INT <br> { PORT0, 25, PIO_DIGITAL, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM), No_ADC_Channel, PWM11, NOT_ON_TIMER}, //RED_LED <br> { PORT0, 26, PIO_DIGITAL, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM), No_ADC_Channel, PWM11, NOT_ON_TIMER}, //GREEN_LED <br> { PORT0, 27, PIO_DIGITAL, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM), No_ADC_Channel, PWM11, NOT_ON_TIMER}, //BLUE_LED <br> { PORT0, 28, PIO_DIGITAL, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM), ADC_A4, PWM3, NOT_ON_TIMER}, <br> { PORT0, 29, PIO_DIGITAL, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM), ADC_A5, PWM2, NOT_ON_TIMER}, <br> { PORT0, 30, PIO_DIGITAL, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM), ADC_A6, PWM1, NOT_ON_TIMER}, <br> { PORT0, 31, PIO_DIGITAL, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM), ADC_A7, PWM0, NOT_ON_TIMER} <br> }; <br> <br> // Don't remove this line <br> #include &lt;compat_pin_mapping.h&gt; <br> <br> #endif <br></code> <br><br>  MyBoardNRF5.h <br> <code>#ifndef _MYBOARDNRF5_H_ <br> #define _MYBOARDNRF5_H_ <br> <br> #ifdef __cplusplus <br> extern "C" <br> { <br> #endif // __cplusplus <br> <br> // Number of pins defined in PinDescription array <br> #define PINS_COUNT (32u) <br> #define NUM_DIGITAL_PINS (32u) <br> #define NUM_ANALOG_INPUTS (8u) <br> #define NUM_ANALOG_OUTPUTS (8u) <br> <br> /* <br> * LEDs <br> * <br> * This is optional <br> * <br> * With My Sensors, you can use <br> * hwPinMode() instead of pinMode() <br> * hwPinMode() allows to use advanced modes like OUTPUT_H0H1 to drive LEDs. <br> * https://github.com/mysensors/MySensors/blob/development/drivers/NRF5/nrf5_wiring_constants.h <br> * <br> */ <br> #define PIN_LED1 (16) <br> #define PIN_LED2 (15) <br> #define PIN_LED3 (17) <br> #define RED_LED (PIN_LED1) <br> #define GREEN_LED (PIN_LED2) <br> #define BLUE_LED (PIN_LED3) <br> #define INTERRUPT_PIN (5) <br> #define MODE_PIN (25) <br> #define SENS_PIN (27) <br> <br> /* <br> * Analog ports <br> * <br> * If you change g_APinDescription, replace PIN_AIN0 with <br> * port numbers mapped by the g_APinDescription Array. <br> * You can add PIN_AIN0 to the g_APinDescription Array if <br> * you want provide analog ports MCU independed, you can add <br> * PIN_AIN0..PIN_AIN7 to your custom g_APinDescription Array <br> * defined in MyBoardNRF5.cpp <br> */ <br> static const uint8_t A0 = ADC_A0; <br> static const uint8_t A1 = ADC_A1; <br> static const uint8_t A2 = ADC_A2; <br> static const uint8_t A3 = ADC_A3; <br> static const uint8_t A4 = ADC_A4; <br> static const uint8_t A5 = ADC_A5; <br> static const uint8_t A6 = ADC_A6; <br> static const uint8_t A7 = ADC_A7; <br> <br> /* <br> * Serial interfaces <br> * <br> * RX and TX are required. <br> * If you have no serial port, use unused pins <br> * CTS and RTS are optional. <br> */ <br> #define PIN_SERIAL_RX (11) <br> #define PIN_SERIAL_TX (12) <br> <br> #ifdef __cplusplus <br> } <br> #endif <br> <br> #endif <br></code> <br></div></div><br><br>  O switch possui um bot√£o de toque e um bot√£o de rel√≥gio na parte traseira do dispositivo.  Este bot√£o do rel√≥gio ser√° usado para modos de servi√ßo, modo de press√£o de ar, zerando o dispositivo.  O bot√£o implementa um anti-rebote de ferro.  A linha do sensor capacitivo e a linha do bot√£o do rel√≥gio atrav√©s dos diodos Schottky s√£o conectadas e conectadas ao pino anal√≥gico p0.05, as linhas aos pinos p0.25 e p0.27 MK v√£o para o sensor capacitivo e o bot√£o do rel√≥gio para ler os estados ap√≥s ativar a interrup√ß√£o no p0 p0. 05  No pino p0.05, √© ativada uma interrup√ß√£o via comparador (NRF_LPCOMP) por EVENTS_UP.  Tive inspira√ß√£o para resolver o problema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  O switch foi adicionado √† rede Mysensors, gerenciada pelo controlador da casa inteligente, Magordomo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site do projeto</a> ) <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo PHP a ser adicionado ao m√©todo de altern√¢ncia statusUpdate</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getGlobal(<span class="hljs-string"><span class="hljs-string">"MysensorsButton01.status"</span></span>)==<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getGlobal(<span class="hljs-string"><span class="hljs-string">'MysensorsRelay04.status'</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { setGlobal(<span class="hljs-string"><span class="hljs-string">'MysensorsRelay04.status'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getGlobal(<span class="hljs-string"><span class="hljs-string">'MysensorsRelay04.status'</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { setGlobal(<span class="hljs-string"><span class="hljs-string">'MysensorsRelay04.status'</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); } }</code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Assista ao resultado em v√≠deo</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/DVpDjXjeUKg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><br><img src="https://habrastorage.org/webt/ia/zu/2m/iazu2mhz4be1b1kzv_ncyp-lzwc.png"><br><br>  Mais tarde, uma op√ß√£o foi feita com um conversor de impulso, mas isso n√£o est√° relacionado √† opera√ß√£o do chip capacitivo TTP223, h√° mais desejo de uma ilumina√ß√£o boa e uniforme ao trabalhar com torneiras durante toda a vida √∫til da bateria. <br><br><div class="spoiler">  <b class="spoiler_title">Ver</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/qr/_l/qd/qr_lqddvybuh6nplnpbckv_b0mu.png"><br><br><img src="https://habrastorage.org/webt/y4/2p/yi/y42pyintvyekuu3fnftwph_u1wy.png"><br></div></div><br><br>  <b>Projeto Github</b> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/smartboxchannel/EFEKTA_WIRELESS_TOUCH_SWITCH</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Site da comunidade em</a> l√≠ngua russa Mysensors <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Chat de telegrama da Mysensors</a></b> - solu√ß√£o r√°pida para problemas, dicas, truques, instala√ß√£o de placas da Mysensors, trabalhando com microcontroladores atmega 328, stm32, nRF5 no Arduino IDE - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>@mysensors_rus</b></a> <br><br><div class="spoiler">  <b class="spoiler_title">Poucas fotos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/cw/_5/jj/cw_5jjdmlm030e_c26xw8o2eg88.jpeg"><br><br><img src="https://habrastorage.org/webt/ye/qg/np/yeqgnpxygqbxsyoehne_jbcec9c.jpeg"><br><br><img src="https://habrastorage.org/webt/nn/8w/8u/nn8w8uqrdgjwpjnj_2injvyokh4.jpeg"><br><br><img src="https://habrastorage.org/webt/8v/8y/fy/8v8yfywuwsvrjjpz64fm_rkhqvc.jpeg"><br><br><img src="https://habrastorage.org/webt/8k/_w/b5/8k_wb50hjjkuv_nvov0fskernlm.jpeg"><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457992/">https://habr.com/ru/post/pt457992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457980/index.html">Redes neurais e aprendizado profundo, cap√≠tulo 2: como o algoritmo de retropropaga√ß√£o funciona</a></li>
<li><a href="../pt457982/index.html">Mudan√ßa para trabalhar no exterior: 6 servi√ßos para ajudar imigrantes nos EUA e Canad√°</a></li>
<li><a href="../pt457986/index.html">Dia Aberto do JetBrains 2019: transmiss√µes de relat√≥rios</a></li>
<li><a href="../pt457988/index.html">Lista de verifica√ß√£o: inicie comandos SCRUM e obtenha vacinas do scrum zumbi</a></li>
<li><a href="../pt457990/index.html">Eu tinha sete palavras ao me tornar v√≠tima de phishing direcionado</a></li>
<li><a href="../pt457994/index.html">Dicas e truques do Visual Studio</a></li>
<li><a href="../pt457996/index.html">Confiss√£o do chefe: como trabalhar em viagem, dispensar metade do departamento em LA e por que patrocinar a MeksetnoExp Tyoma Lebedev</a></li>
<li><a href="../pt458000/index.html">Avalia√ß√£o da pose humana em imagens para iOS</a></li>
<li><a href="../pt458002/index.html">O que realmente aconteceu com o desaparecido Boeing da Mal√°sia (parte 1/3)</a></li>
<li><a href="../pt458004/index.html">Sistema de controle de tr√°fego de naves espaciais Soyuz-TM parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>