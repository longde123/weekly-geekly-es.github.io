<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游 游 游깽 SQL: soluci칩n de tareas de tiempo de trabajo 驕勇 游띲 游놀游</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="춰Hola, Radio SQL est치 en el aire otra vez! Hoy tenemos una soluci칩n al problema que transmitimos en nuestra transmisi칩n anterior, y prometimos hacerlo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL: soluci칩n de tareas de tiempo de trabajo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/459236/"><p>  춰Hola, Radio SQL est치 en el aire otra vez!  Hoy tenemos una soluci칩n al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema</a> que transmitimos en nuestra transmisi칩n anterior, y prometimos hacerlo la pr칩xima vez.  Y la pr칩xima vez ha llegado. </p><br><p>  La tarea despert칩 una respuesta animada entre los humanoides de la galaxia de la V칤a L치ctea (y no es sorprendente, con su esclavitud laboral, que todav칤a respetan en beneficio de la civilizaci칩n).  Desafortunadamente, en el tercer planeta, el lanzamiento del observatorio espacial Spektr-RG se pospuso a fines de julio de 2019, el RC (cronolog칤a local), con la ayuda de la cual se plane칩 transmitir este programa.  Tuve que buscar rutas de transmisi칩n alternativas, lo que provoc칩 un ligero retraso en la se침al.  Pero todo est치 bien, eso termina bien. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/a6/z4/rca6z4cduxlps2le_c4l_3rwnrg.png"></div><br><p>  Debo decir de inmediato que no habr치 magia en el an치lisis de la tarea, no hay necesidad de buscar revelaciones aqu칤 o esperar una implementaci칩n particularmente efectiva (o especialmente alguna en cualquier otro sentido).  Esta es solo una tarea de an치lisis.  En 칠l, aquellos que no saben c칩mo abordar la soluci칩n de tales problemas podr치n ver c칩mo resolverlos.  Adem치s, no hay nada terrible aqu칤. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">D칠jame recordarte la condici칩n.</b> <div class="spoiler_text"><p>  Hay varios intervalos de tiempo especificados por la fecha y hora de su inicio y finalizaci칩n (un ejemplo en la sintaxis de PostgreSQL): </p><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-03-29 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-08 14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 20:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-11 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-12 16:07:12'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-12-28 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-01-16 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) )</code> </pre> <br><p>  Se requiere en una consulta SQL (c) para calcular la duraci칩n de cada intervalo en horas de trabajo.  Creemos que trabajamos de lunes a viernes de lunes a viernes, las horas de trabajo son siempre de 10:00 a 19:00.  Adem치s, de acuerdo con el calendario de producci칩n de la Federaci칩n de Rusia, hay varios d칤as festivos oficiales que no son d칤as h치biles, y algunos de los d칤as libres, por el contrario, son d칤as h치biles debido al aplazamiento de esos mismos d칤as festivos.  No es necesario acortar los d칤as previos a las vacaciones, los consideramos completos.  Dado que las vacaciones var칤an de un a침o a otro, es decir, se establecen mediante un listado expl칤cito, nos limitaremos a fechas solo de 2018 y 2019.  Estoy seguro de que, si es necesario, la soluci칩n se puede complementar f치cilmente. </p><br><p>  Es necesario agregar una columna con la duraci칩n en horas de trabajo a los per칤odos iniciales de los <em>per칤odos</em> .  Aqu칤 est치 el resultado: </p><br><pre> <code class="pgsql hljs"> id | start_time | stop_time | work_hrs <span class="hljs-comment"><span class="hljs-comment">----+---------------------+---------------------+---------- 1 | 2019-03-29 07:00:00 | 2019-04-08 14:00:00 | 58:00:00 2 | 2019-04-10 07:00:00 | 2019-04-10 20:00:00 | 09:00:00 3 | 2019-04-11 12:00:00 | 2019-04-12 16:07:12 | 13:07:12 4 | 2018-12-28 12:00:00 | 2019-01-16 16:00:00 | 67:00:00</span></span></code> </pre> <br><p>  No verificamos que los datos iniciales sean correctos; siempre consideramos <em>start_time &lt;= stop_time</em> . </p><br><p>  Al final de la condici칩n, el original est치 aqu칤: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://habr.com/en/company/postgrespro/blog/448368/</a> . </p></div></div><br><p>  La tarea da un ligero picante al hecho de que conscientemente he dado una buena mitad de la condici칩n en forma descriptiva (como suele ser el caso en la vida real), dejando a la discreci칩n de la implementaci칩n t칠cnica c칩mo se debe establecer el horario de trabajo.  Por un lado, esto requiere algunas habilidades de pensamiento arquitect칩nico.  Y, por otro lado, el formato listo para usar de esta programaci칩n habr칤a provocado el uso de alguna plantilla.  Y si omites, entonces el pensamiento y la fantas칤a funcionar치n m치s plenamente.  La recepci칩n vali칩 la pena por completo, permiti칠ndome tambi칠n encontrar enfoques interesantes en las soluciones publicadas. </p><br><p>  Entonces, para resolver el problema original de esta manera, ser치 necesario resolver dos subtareas: </p><br><ol><li>  Determine c칩mo establecer de manera m치s compacta un horario de trabajo, y aun as칤, es conveniente usarlo como soluci칩n. </li><li>  Realmente calcule la duraci칩n de cada per칤odo fuente en horas de trabajo de acuerdo con el cronograma de trabajo de la subtarea anterior. </li></ol><br><p>  Y es mejor comenzar con el segundo, para comprender de qu칠 forma necesitamos resolver el primero.  Luego resuelva el primero y regrese nuevamente al segundo para obtener el resultado final. <br>  Recopilaremos el resultado gradualmente, utilizando la sintaxis CTE, que nos permite poner todas las muestras de datos necesarias en subconsultas con nombre separadas y luego vincular todo. </p><br><p>  Pues vamos. </p><br><h3 id="poschitat-dlitelnost-v-rabochih-chasah">  Calcule la duraci칩n en horas de trabajo </h3><br><p>  Para calcular la duraci칩n de cada uno de los per칤odos en horas de trabajo en la frente, debe cruzar el per칤odo inicial (color verde en el diagrama) con los intervalos que describen el tiempo de trabajo (naranja).  Los intervalos de horas de trabajo son los lunes de 10:00 a 19:00, los martes de 10:00 a 19:00 y as칤 sucesivamente.  El resultado se muestra en azul: </p><br><p><img src="https://habrastorage.org/webt/o4/yh/6_/o4yh6_ca7loarlvtghe572p6zdo.png" alt="imagen"></p><br><p>  Por cierto, para confundirme menos, continuar칠 refiri칠ndome a los per칤odos iniciales como per칤odos iniciales, y llamar칠 a intervalos de horas de trabajo. </p><br><p>  El procedimiento debe repetirse para cada per칤odo inicial.  Los per칤odos iniciales para nosotros ya est치n establecidos en la <em>pesta침a de per칤odos (start_time, stop_time)</em> , representaremos las horas de trabajo en forma de tabla, por ejemplo, <em>horario (strat_time, stop_time)</em> , donde cada d칤a laborable est치 presente.  El resultado es un producto cartesiano completo de todos los per칤odos e intervalos iniciales de tiempo de trabajo. </p><br><p>  Las intersecciones se pueden contar de la manera cl치sica, teniendo en cuenta todas las opciones posibles para los intervalos de intersecci칩n: intersectamos el verde con el naranja, el resultado es azul: </p><br><p><img src="https://habrastorage.org/webt/fx/aq/wo/fxaqwo7uud0kyzismeqn6cqeap0.png" alt="imagen"></p><br><p>  y tomando en cada caso el valor deseado para el comienzo y el final del resultado: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.start_time, s.stop_time <span class="hljs-comment"><span class="hljs-comment">-- case #1 from periods p, schedule s where p.start_time &lt;= s.start_time and p.stop_time &gt; s.stop_time union all select p.start_time, s.stop_time -- case #2 from periods p, schedule s where p.start_time &gt;= s.start_time and p.stop_time &gt; s.stop_time and p.start_time &lt; s.stop_time union all select s.start_time, p.stop_time -- case #3 from periods p, schedule s where p.start_time &lt;= s.start_time and p.stop_time &lt; s.stop_time and p.stop_time &gt; s.start_time union all select p.start_time, p.stop_time -- case #4 from periods p, schedule s where p.start_time &gt;= s.start_time and p.stop_time &lt; s.stop_time</span></span></code> </pre> <br><p>  Dado que para cada intersecci칩n solo podemos tener una de cuatro opciones, todas ellas se combinan en una sola solicitud utilizando <em>union all</em> . </p><br><p>  Puede hacer lo contrario utilizando el tipo de rango <em>tsrange</em> disponible en PostgreSQL y la operaci칩n de intersecci칩n ya disponible para ello: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p, schedule s</code> </pre> <br><p>  De acuerdo en eso, uh, un poco m치s f치cil.  En general, hay bastantes cosas peque침as tan convenientes en PostgreSQL, por lo que escribir consultas sobre 칠l es muy bueno. </p><br><h3 id="sgenerirovat-kalendar">  Generar calendario </h3><br><p>  Ahora volvamos a la subtarea con el horario de horas de trabajo. </p><br><p>  Necesitamos obtener el horario de trabajo en forma de intervalos de tiempo de trabajo de 10:00 a 19:00 para cada d칤a laboral, algo as칤 como el <em>horario (hora de inicio, hora de finalizaci칩n)</em> .  Como entendimos, ser치 conveniente resolver nuestro problema.  En la vida real, dicho calendario debe establecerse en una tabla, durante dos a침os solo son unos 500 registros, para fines pr치cticos ser치 necesario establecer incluso diez a침os: esto es un par y medio mil registros, basura real para bases de datos modernas.  Pero tenemos un problema que se resolver치 en una solicitud, y enumerar toda la tabla no es muy pr치ctico.  Intentemos implementarlo de manera m치s compacta. </p><br><p>  En cualquier caso, necesitamos d칤as festivos para eliminarlos del horario base, y aqu칤 solo la lista es adecuada: </p><br><pre> <code class="pgsql hljs"> dates_exclude(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>), <span class="hljs-comment"><span class="hljs-comment">-- 2018 ('2018-01-02'::date), ('2018-01-03'::date), ('2018-01-04'::date), ('2018-01-05'::date), ('2018-01-08'::date), ('2018-02-23'::date), ('2018-03-08'::date), ('2018-03-09'::date), ('2018-05-01'::date), ('2018-05-02'::date), ('2018-05-09'::date), ('2018-06-11'::date), ('2018-06-12'::date), ('2018-11-05'::date), ('2018-12-31'::date), ('2019-01-01'::date), -- 2019 ('2019-01-02'::date), ('2019-01-03'::date), ('2019-01-04'::date), ('2019-01-07'::date), ('2019-01-08'::date), ('2019-03-08'::date), ('2019-05-01'::date), ('2019-05-02'::date), ('2019-05-03'::date), ('2019-05-09'::date), ('2019-05-10'::date), ('2019-06-12'::date), ('2019-11-04'::date) )</span></span></code> </pre> <br><p>  y d칤as h치biles adicionales para agregar: </p><br><pre> <code class="pgsql hljs"> dates_include(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-comment"><span class="hljs-comment">--  2018,  2019  ('2018-04-28'::date), ('2018-06-09'::date), ('2018-12-29'::date) )</span></span></code> </pre> <br><p>  La secuencia de d칤as h치biles durante dos a침os puede generarse mediante una funci칩n especial y muy adecuada <em>generate_series ()</em> , que arroja inmediatamente s치bados y domingos en el camino: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-comment"><span class="hljs-comment">--    </span></span></code> </pre> <br><p>  Obtenemos los d칤as h치biles conectando todo juntos: generamos una secuencia de todos los d칤as h치biles en dos a침os, agregamos d칤as h치biles adicionales de <em>date_include</em> y <em>eliminamos</em> todos los d칤as adicionales de <em>date_exclude</em> : </p><br><pre> <code class="pgsql hljs"> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-comment"><span class="hljs-comment">--     union select d from dates_include --     except select d from dates_exclude --     )</span></span></code> </pre> <br><p>  Y ahora tenemos los intervalos de tiempo que necesitamos: </p><br><pre> <code class="pgsql hljs"> schedule(start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>, d + <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base )</code> </pre> <br><p>  Entonces, tenemos el horario. </p><br><h3 id="sobiraem-vsyo-vmeste">  Poniendo todo junto </h3><br><p>  Ahora obtendremos las intersecciones: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> schedule s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) &amp;&amp; <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time)</code> </pre> <br><p>  Preste atenci칩n a la condici칩n de uni칩n <em>ON</em> , no coincide con dos registros correspondientes de las tablas unidas, no existe tal correspondencia, pero se introduce alguna optimizaci칩n que corta los intervalos de tiempo de trabajo con los que nuestro per칤odo inicial no se cruza.  Esto se hace usando el operador <em>&amp;&amp;</em> , que verifica la intersecci칩n de los intervalos de <em>rango</em> .  Esto elimina muchas intersecciones vac칤as para no interferir con los ojos, pero, por otro lado, elimina la informaci칩n sobre esos per칤odos iniciales que caen completamente fuera de las horas.  Entonces, admiramos que nuestro enfoque funcione y reescribimos la solicitud de la siguiente manera: </p><br><pre> <code class="pgsql hljs"> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p , schedule s ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, start_time, stop_time , sum(upper(wrkh)-lower(wrkh)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> id, start_time, stop_time</code> </pre> <br><p>  En los <em>per칤odos_wrk</em> descomponemos cada per칤odo de origen en intervalos de trabajo, y luego consideramos su duraci칩n total.  El resultado fue un producto cartesiano completo de todos los per칤odos e intervalos, pero no se perdi칩 un solo per칤odo. </p><br><p>  Todo, el resultado es recibido.  No me <em>gustaron los</em> valores <em>NULL</em> para intervalos vac칤os, deje que la consulta muestre un intervalo de longitud cero mejor.  Envuelva la cantidad en <em>fusi칩n ()</em> : </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, start_time, stop_time , coalesce(sum(upper(wrkh)-lower(wrkh)), <span class="hljs-string"><span class="hljs-string">'0 sec'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> id, start_time, stop_time</code> </pre> <br><p>  Todos juntos dan el resultado final: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-03-29 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-08 14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 20:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-11 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-12 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-12-28 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-01-16 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) ), dates_exclude(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>), <span class="hljs-comment"><span class="hljs-comment">-- 2018 ('2018-01-02'::date), ('2018-01-03'::date), ('2018-01-04'::date), ('2018-01-05'::date), ('2018-01-08'::date), ('2018-02-23'::date), ('2018-03-08'::date), ('2018-03-09'::date), ('2018-05-01'::date), ('2018-05-02'::date), ('2018-05-09'::date), ('2018-06-11'::date), ('2018-06-12'::date), ('2018-11-05'::date), ('2018-12-31'::date), ('2019-01-01'::date), -- 2019 ('2019-01-02'::date), ('2019-01-03'::date), ('2019-01-04'::date), ('2019-01-07'::date), ('2019-01-08'::date), ('2019-03-08'::date), ('2019-05-01'::date), ('2019-05-02'::date), ('2019-05-03'::date), ('2019-05-09'::date), ('2019-05-10'::date), ('2019-06-12'::date), ('2019-11-04'::date) ), dates_include(start_time, stop_time) as ( values --  2018,  2019  ('2018-04-28 10:00:00'::timestamp, '2018-04-28 19:00:00'::timestamp), ('2018-06-09 10:00:00'::timestamp, '2018-06-09 19:00:00'::timestamp), ('2018-12-29 10:00:00'::timestamp, '2018-12-29 19:00:00'::timestamp) ) ), schedule_base(start_time, stop_time) as ( select d::timestamp + '10:00:00', d::timestamp + '19:00:00' from generate_series( (select min(start_time) from periods)::date::timestamp , (select max(stop_time) from periods)::date::timestamp , '1 day'::interval ) as days(d) where extract(dow from d) not in (0,6) ), schedule as ( select * from schedule_base where start_time::date not in (select d from dates_exclude) union select * from dates_include ), periods_wrk as ( select p.* , tsrange(p.start_time, p.stop_time) * tsrange(s.start_time, s.stop_time) as wrkh from periods p , schedule s ) select id, start_time, stop_time , sum(coalesce(upper(wrkh)-lower(wrkh), '0 sec'::interval)) from periods_wrk group by id, start_time, stop_time</span></span></code> </pre> <br><p>  춰Hurra! .. Esto podr칤a estar terminado, pero en aras de la exhaustividad consideraremos algunos temas m치s relacionados. </p><br><h3 id="dalneyshee-razvitie-temy">  Mayor desarrollo del tema. </h3><br><p>  D칤as m치s cortos antes de las vacaciones, descansos para almorzar, diferentes horarios para diferentes d칤as de la semana ... En principio, todo est치 claro, debe fijar la definici칩n de <em>horario</em> , solo d칠 un par de ejemplos. </p><br><p>  As칤 es como puede establecer diferentes horas de inicio y finalizaci칩n para un d칤a h치bil, seg칰n el d칤a de la semana: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-comment"><span class="hljs-comment">--  when 2 then '11:00:00'::time --  when 3 then '11:00:00'::time --  --        else '10:00:00'::time end , d + case extract(dow from d) --   19   when 5 then '14:00:00'::time --  else '19:00:00'::time end from schedule_base</span></span></code> </pre> <br><p>  Si necesita tener en cuenta las pausas para el almuerzo de 13:00 a 14:00, en lugar de un intervalo por d칤a, haga dos: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> , d + <span class="hljs-string"><span class="hljs-string">'13:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> , d + <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base</code> </pre> <br><p>  Bueno y as칤 sucesivamente. </p><br><h3 id="proizvoditelnost">  Rendimiento </h3><br><p>  Dir칠 algunas palabras sobre el rendimiento, ya que siempre hay preguntas al respecto.  No voy a masticar mucho, esta es una secci칩n con un asterisco. </p><br><p>  En general, la optimizaci칩n prematura es malvada.  Seg칰n mis muchos a침os de observaci칩n, la legibilidad del c칩digo es su ventaja m치s importante.  Si el c칩digo se lee bien, entonces es m치s f치cil de mantener y desarrollar.  El c칩digo legible requiere impl칤citamente una buena arquitectura de soluci칩n, comentarios adecuados y buenos nombres de variables, compacidad sin sacrificar la legibilidad, etc., es decir, todo para lo que se llama el c칩digo. </p><br><p>  Por lo tanto, la solicitud siempre se escribe de la manera m치s legible posible, y comenzamos a optimizar si y solo si resulta que el rendimiento es insuficiente.  Adem치s, lo optimizaremos con precisi칩n cuando el rendimiento sea insuficiente y exactamente en la medida en que sea suficiente.  Si ciertamente valoras tu propio tiempo y tienes algo que hacer. </p><br><p>  Pero no es correcto realizar un trabajo innecesario en la solicitud; siempre debe intentar tener esto en cuenta. </p><br><p>  En base a esto, incluiremos una optimizaci칩n en la consulta de inmediato: deje que cada per칤odo de origen se entrecruce solo con aquellos intervalos de tiempo de trabajo con los que tiene puntos comunes (en lugar de una condici칩n cl치sica larga en los l칤mites del rango, es m치s conveniente usar el operador <em>&amp;&amp;</em> incorporado para el tipo de <em>rango</em> ).  Esta optimizaci칩n ya apareci칩 en la solicitud, pero ha llevado al hecho de que los per칤odos iniciales que cayeron por completo de las horas de trabajo desaparecieron de los resultados. </p><br><p>  Traiga de vuelta esta optimizaci칩n.  Para hacer esto, use <em>LEFT JOIN</em> , que guardar치 todos los registros de la tabla de <em>per칤odos</em> .  Ahora la subconsulta <em>period_wrk</em> se ver치 as칤: </p><br><pre> <code class="pgsql hljs">, periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p <span class="hljs-keyword"><span class="hljs-keyword">left join</span></span> schedule s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) &amp;&amp; <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time))</code> </pre> <br><p>  El an치lisis de la solicitud muestra que el tiempo en los datos de prueba ha disminuido aproximadamente a la mitad.  Dado que el tiempo de ejecuci칩n depende de lo que el servidor estaba haciendo al mismo tiempo, tom칠 algunas medidas y di un resultado "t칤pico", no el m치s grande, ni el m치s peque침o, del medio. </p><br><p>  Consulta anterior: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyse</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( ... QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------ HashAggregate (cost=334.42..338.39 rows=397 width=36) (actual time=10.724..10.731 rows=4 loops=1) ...</span></span></code> </pre> <br><p>  Nuevo: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyse</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( ... QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------ HashAggregate (cost=186.37..186.57 rows=20 width=36) (actual time=5.431..5.440 rows=4 loops=1) ...</span></span></code> </pre> <br><p>  Pero lo m치s importante es que dicha solicitud tambi칠n se escalar치 mejor, lo que requiere menos recursos del servidor, ya que el producto cartesiano completo crece muy r치pidamente. </p><br><p>  Y en esto me detendr칤a con optimizaciones.  Cuando resolv칤 este problema por m칤 mismo, tuve suficiente rendimiento incluso en una forma mucho m치s terrible de esta solicitud, pero realmente no hab칤a necesidad de optimizar.  Para obtener un informe sobre mis datos una vez por trimestre, puedo esperar diez segundos adicionales.  La hora extra que se dedica a la optimizaci칩n en tales condiciones nunca valdr치 la pena. </p><br><p>  Pero resulta poco interesante; sigamos pensando en c칩mo podr칤an desarrollarse los eventos si realmente se necesitara una optimizaci칩n en t칠rminos de tiempo de ejecuci칩n.  Por ejemplo, queremos monitorear este par치metro en tiempo real para cada uno de nuestros registros en la base de datos, es decir, para cada estornudo se llamar치 a dicha solicitud.  Bueno, o invente su propia raz칩n, 쯣or qu칠 necesitar칤a optimizar? </p><br><p>  Lo primero que viene a la mente es contar una vez y poner en la base de datos una tabla con intervalos de trabajo.  Puede haber contraindicaciones: si la base de datos no se puede cambiar, o se esperan dificultades con el apoyo de los datos relevantes en dicha tabla.  Luego tendr치 que dejar la generaci칩n de tiempo de trabajo "sobre la marcha" en la solicitud, ya que esta no es una subconsulta muy pesada. </p><br><p>  El siguiente y m치s poderoso enfoque (pero no siempre aplicable) es la optimizaci칩n algor칤tmica.  Algunos de estos enfoques ya se han presentado en los comentarios al art칤culo con la condici칩n del problema. </p><br><p>  Este me gusta m치s que nada.  Si hace una tabla con todos los d칤as (no solo de trabajo) del calendario y calcula el total acumulado de cu치ntas horas de trabajo cada d칤a de una determinada "creaci칩n del mundo" han pasado, entonces puede obtener el n칰mero de horas de trabajo entre dos fechas con una operaci칩n de resta.  Solo queda tener en cuenta correctamente las horas de trabajo para el primer y 칰ltimo d칤a, y ya est치.  Esto es lo que obtuve en este enfoque: </p><br><pre> <code class="pgsql hljs"> schedule_base(d, is_working) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">all</span></span>(<span class="hljs-string"><span class="hljs-string">'{2019-01-01,2019-01-02,2019-01-03,2019-01-04,2019-01-07,2019-01-08,2019-03-08,2019-05-01,2019-05-02,2019-05-03,2019-05-09,2019-05-10,2019-06-12,2019-11-04,2018-01-01,2018-01-02,2018-01-03,2018-01-04,2018-01-05,2018-01-08,2018-02-23,2018-03-08,2018-03-09,2018-04-30,2018-05-01,2018-05-02,2018-05-09,2018-06-11,2018-06-12,2018-11-05,2018-12-31}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>(<span class="hljs-string"><span class="hljs-string">'{2018-04-28,2018-06-09,2018-12-29}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> d &lt; <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span> ), schedule(d, is_working, work_hours) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d, is_working , sum(is_working*<span class="hljs-string"><span class="hljs-string">'9 hours'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unbounded</span></span> <span class="hljs-keyword"><span class="hljs-keyword">preceding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , s2.work_hours - s1.work_hours + (<span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> - least(greatest(p.start_time::<span class="hljs-type"><span class="hljs-type">time</span></span>, <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>), <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>)) * s1.is_working - (<span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> - least(greatest(p.stop_time::<span class="hljs-type"><span class="hljs-type">time</span></span>, <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>), <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>)) * s2.is_working <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p, schedule s1, schedule s2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> s1.d = p.start_time::<span class="hljs-type"><span class="hljs-type">date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> s2.d = p.stop_time::<span class="hljs-type"><span class="hljs-type">date</span></span></code> </pre> <br><p>  Explicar칠 brevemente lo que est치 sucediendo aqu칤.  En la subconsulta <em>schedule_base</em> , generamos todos los d칤as del calendario durante dos a침os y cada d칤a determinamos el signo si el d칤a h치bil (= 1) o no (= 0).  Adem치s, en la subconsulta de <em>programaci칩n</em> , consideramos la funci칩n de ventana como el n칰mero total acumulado de horas de trabajo desde 2018-01-01.  Ser칤a posible hacer todo en una subconsulta, pero resultar칤a m치s engorroso, lo que perjudicar칤a la legibilidad.  Luego, en la solicitud principal, consideramos la diferencia entre el n칰mero de horas de trabajo al final y al comienzo del per칤odo y, de manera algo florida, tomamos en cuenta las horas de trabajo para el primer y 칰ltimo d칤a del per칤odo.  La floridez se asocia con el cambio del tiempo antes del comienzo de la jornada laboral a su comienzo, y el tiempo posterior al final de la jornada laboral a su finalizaci칩n.  Adem치s, si la parte de la solicitud con <em>shedule_base</em> y <em>horario se</em> elimina en una tabla precalculada separada (como se sugiri칩 anteriormente), la solicitud se convertir치 en una completamente trivial. </p><br><p>  Comparemos la ejecuci칩n en una muestra m치s grande para mostrar mejor la optimizaci칩n realizada, durante cuatro per칤odos desde la condici칩n de la tarea se dedica m치s tiempo a generar un cronograma de trabajo. </p><br><p>  Tom칠 alrededor de 3 mil per칤odos.  Dar칠 solo la l칤nea de resumen superior en EXPLAIN, los valores t칤picos son los siguientes. </p><br><p>  Opci칩n original: </p><br><pre> <code class="pgsql hljs">GroupAggregate (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">265790.95</span></span>.<span class="hljs-number"><span class="hljs-number">.296098</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">144320</span></span> width=<span class="hljs-number"><span class="hljs-number">36</span></span>) (actual <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">656.654</span></span>.<span class="hljs-number"><span class="hljs-number">.894</span></span><span class="hljs-number"><span class="hljs-number">.383</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">2898</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  Optimizado: </p><br><pre> <code class="pgsql hljs">Hash <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">45.01</span></span>.<span class="hljs-number"><span class="hljs-number">.127</span></span><span class="hljs-number"><span class="hljs-number">.52</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">70</span></span> width=<span class="hljs-number"><span class="hljs-number">36</span></span>) (actual <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">1.620</span></span>.<span class="hljs-number"><span class="hljs-number">.5</span></span><span class="hljs-number"><span class="hljs-number">.385</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">2898</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  La ganancia de tiempo fue un par de 칩rdenes de magnitud.  Con el aumento en el n칰mero de per칤odos y su duraci칩n en a침os, la brecha solo se ampliar치. </p><br><p>  Todo parec칤a estar bien, pero 쯣or qu칠, habiendo hecho tal optimizaci칩n, dej칠 la primera versi칩n de la solicitud para m칤 hasta que su rendimiento fue suficiente?  S칤, porque la versi칩n optimizada es indudablemente m치s r치pida, pero requiere mucho m치s tiempo para entender c칩mo funciona, es decir, la legibilidad ha empeorado.  Es decir, la pr칩xima vez que necesite reescribir la solicitud en mis condiciones cambiadas, yo (o no yo) tendr칠 que dedicar mucho m치s tiempo a comprender c칩mo funciona la solicitud. </p><br><p>  Eso es todo por hoy, mant칠n los tent치culos calientes y te digo adi칩s hasta la pr칩xima versi칩n de Radio SQL. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459236/">https://habr.com/ru/post/459236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459224/index.html">De agente inmobiliario a desarrollador de juegos 2. "Operaci칩n: Android"</a></li>
<li><a href="../459226/index.html">"Fast-PoE y Perpetual-PoE: 쯥on estos nuevos est치ndares o no?"</a></li>
<li><a href="../459230/index.html">Un viaje al centro de llamadas y a la cartera de productos a trav칠s de los ojos del desarrollador</a></li>
<li><a href="../459232/index.html">Rodea, muerde, corta: la nueva competencia Mini AI Cup # 4</a></li>
<li><a href="../459234/index.html">Smem: informes sobre la asignaci칩n de memoria entre procesos y usuarios en Linux</a></li>
<li><a href="../459238/index.html">De una funci칩n matem치tica m치gica: una soluci칩n para gobernarlos a todos</a></li>
<li><a href="../459240/index.html">10 a침os en TI diagnosticados con esquizofrenia, consejos de supervivencia</a></li>
<li><a href="../459242/index.html">Despu칠s de la conferencia T + Conf 2019</a></li>
<li><a href="../459244/index.html">Administrador de productos de Notes: comportamiento del usuario en las p치ginas del juego en la tienda de aplicaciones. 쮺u치nto tiempo lleva descargar un juego?</a></li>
<li><a href="../459246/index.html">쯇or qu칠 est치 disminuyendo la conversi칩n del sitio? Ejemplos de 60 errores de dise침o y usabilidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>