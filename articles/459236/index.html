<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔞 👟 🌗 SQL: solución de tareas de tiempo de trabajo ☯️ 🛴 👩🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¡Hola, Radio SQL está en el aire otra vez! Hoy tenemos una solución al problema que transmitimos en nuestra transmisión anterior, y prometimos hacerlo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL: solución de tareas de tiempo de trabajo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/459236/"><p>  ¡Hola, Radio SQL está en el aire otra vez!  Hoy tenemos una solución al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema</a> que transmitimos en nuestra transmisión anterior, y prometimos hacerlo la próxima vez.  Y la próxima vez ha llegado. </p><br><p>  La tarea despertó una respuesta animada entre los humanoides de la galaxia de la Vía Láctea (y no es sorprendente, con su esclavitud laboral, que todavía respetan en beneficio de la civilización).  Desafortunadamente, en el tercer planeta, el lanzamiento del observatorio espacial Spektr-RG se pospuso a fines de julio de 2019, el RC (cronología local), con la ayuda de la cual se planeó transmitir este programa.  Tuve que buscar rutas de transmisión alternativas, lo que provocó un ligero retraso en la señal.  Pero todo está bien, eso termina bien. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/a6/z4/rca6z4cduxlps2le_c4l_3rwnrg.png"></div><br><p>  Debo decir de inmediato que no habrá magia en el análisis de la tarea, no hay necesidad de buscar revelaciones aquí o esperar una implementación particularmente efectiva (o especialmente alguna en cualquier otro sentido).  Esta es solo una tarea de análisis.  En él, aquellos que no saben cómo abordar la solución de tales problemas podrán ver cómo resolverlos.  Además, no hay nada terrible aquí. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Déjame recordarte la condición.</b> <div class="spoiler_text"><p>  Hay varios intervalos de tiempo especificados por la fecha y hora de su inicio y finalización (un ejemplo en la sintaxis de PostgreSQL): </p><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-03-29 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-08 14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 20:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-11 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-12 16:07:12'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-12-28 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-01-16 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) )</code> </pre> <br><p>  Se requiere en una consulta SQL (c) para calcular la duración de cada intervalo en horas de trabajo.  Creemos que trabajamos de lunes a viernes de lunes a viernes, las horas de trabajo son siempre de 10:00 a 19:00.  Además, de acuerdo con el calendario de producción de la Federación de Rusia, hay varios días festivos oficiales que no son días hábiles, y algunos de los días libres, por el contrario, son días hábiles debido al aplazamiento de esos mismos días festivos.  No es necesario acortar los días previos a las vacaciones, los consideramos completos.  Dado que las vacaciones varían de un año a otro, es decir, se establecen mediante un listado explícito, nos limitaremos a fechas solo de 2018 y 2019.  Estoy seguro de que, si es necesario, la solución se puede complementar fácilmente. </p><br><p>  Es necesario agregar una columna con la duración en horas de trabajo a los períodos iniciales de los <em>períodos</em> .  Aquí está el resultado: </p><br><pre> <code class="pgsql hljs"> id | start_time | stop_time | work_hrs <span class="hljs-comment"><span class="hljs-comment">----+---------------------+---------------------+---------- 1 | 2019-03-29 07:00:00 | 2019-04-08 14:00:00 | 58:00:00 2 | 2019-04-10 07:00:00 | 2019-04-10 20:00:00 | 09:00:00 3 | 2019-04-11 12:00:00 | 2019-04-12 16:07:12 | 13:07:12 4 | 2018-12-28 12:00:00 | 2019-01-16 16:00:00 | 67:00:00</span></span></code> </pre> <br><p>  No verificamos que los datos iniciales sean correctos; siempre consideramos <em>start_time &lt;= stop_time</em> . </p><br><p>  Al final de la condición, el original está aquí: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://habr.com/en/company/postgrespro/blog/448368/</a> . </p></div></div><br><p>  La tarea da un ligero picante al hecho de que conscientemente he dado una buena mitad de la condición en forma descriptiva (como suele ser el caso en la vida real), dejando a la discreción de la implementación técnica cómo se debe establecer el horario de trabajo.  Por un lado, esto requiere algunas habilidades de pensamiento arquitectónico.  Y, por otro lado, el formato listo para usar de esta programación habría provocado el uso de alguna plantilla.  Y si omites, entonces el pensamiento y la fantasía funcionarán más plenamente.  La recepción valió la pena por completo, permitiéndome también encontrar enfoques interesantes en las soluciones publicadas. </p><br><p>  Entonces, para resolver el problema original de esta manera, será necesario resolver dos subtareas: </p><br><ol><li>  Determine cómo establecer de manera más compacta un horario de trabajo, y aun así, es conveniente usarlo como solución. </li><li>  Realmente calcule la duración de cada período fuente en horas de trabajo de acuerdo con el cronograma de trabajo de la subtarea anterior. </li></ol><br><p>  Y es mejor comenzar con el segundo, para comprender de qué forma necesitamos resolver el primero.  Luego resuelva el primero y regrese nuevamente al segundo para obtener el resultado final. <br>  Recopilaremos el resultado gradualmente, utilizando la sintaxis CTE, que nos permite poner todas las muestras de datos necesarias en subconsultas con nombre separadas y luego vincular todo. </p><br><p>  Pues vamos. </p><br><h3 id="poschitat-dlitelnost-v-rabochih-chasah">  Calcule la duración en horas de trabajo </h3><br><p>  Para calcular la duración de cada uno de los períodos en horas de trabajo en la frente, debe cruzar el período inicial (color verde en el diagrama) con los intervalos que describen el tiempo de trabajo (naranja).  Los intervalos de horas de trabajo son los lunes de 10:00 a 19:00, los martes de 10:00 a 19:00 y así sucesivamente.  El resultado se muestra en azul: </p><br><p><img src="https://habrastorage.org/webt/o4/yh/6_/o4yh6_ca7loarlvtghe572p6zdo.png" alt="imagen"></p><br><p>  Por cierto, para confundirme menos, continuaré refiriéndome a los períodos iniciales como períodos iniciales, y llamaré a intervalos de horas de trabajo. </p><br><p>  El procedimiento debe repetirse para cada período inicial.  Los períodos iniciales para nosotros ya están establecidos en la <em>pestaña de períodos (start_time, stop_time)</em> , representaremos las horas de trabajo en forma de tabla, por ejemplo, <em>horario (strat_time, stop_time)</em> , donde cada día laborable está presente.  El resultado es un producto cartesiano completo de todos los períodos e intervalos iniciales de tiempo de trabajo. </p><br><p>  Las intersecciones se pueden contar de la manera clásica, teniendo en cuenta todas las opciones posibles para los intervalos de intersección: intersectamos el verde con el naranja, el resultado es azul: </p><br><p><img src="https://habrastorage.org/webt/fx/aq/wo/fxaqwo7uud0kyzismeqn6cqeap0.png" alt="imagen"></p><br><p>  y tomando en cada caso el valor deseado para el comienzo y el final del resultado: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.start_time, s.stop_time <span class="hljs-comment"><span class="hljs-comment">-- case #1 from periods p, schedule s where p.start_time &lt;= s.start_time and p.stop_time &gt; s.stop_time union all select p.start_time, s.stop_time -- case #2 from periods p, schedule s where p.start_time &gt;= s.start_time and p.stop_time &gt; s.stop_time and p.start_time &lt; s.stop_time union all select s.start_time, p.stop_time -- case #3 from periods p, schedule s where p.start_time &lt;= s.start_time and p.stop_time &lt; s.stop_time and p.stop_time &gt; s.start_time union all select p.start_time, p.stop_time -- case #4 from periods p, schedule s where p.start_time &gt;= s.start_time and p.stop_time &lt; s.stop_time</span></span></code> </pre> <br><p>  Dado que para cada intersección solo podemos tener una de cuatro opciones, todas ellas se combinan en una sola solicitud utilizando <em>union all</em> . </p><br><p>  Puede hacer lo contrario utilizando el tipo de rango <em>tsrange</em> disponible en PostgreSQL y la operación de intersección ya disponible para ello: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p, schedule s</code> </pre> <br><p>  De acuerdo en eso, uh, un poco más fácil.  En general, hay bastantes cosas pequeñas tan convenientes en PostgreSQL, por lo que escribir consultas sobre él es muy bueno. </p><br><h3 id="sgenerirovat-kalendar">  Generar calendario </h3><br><p>  Ahora volvamos a la subtarea con el horario de horas de trabajo. </p><br><p>  Necesitamos obtener el horario de trabajo en forma de intervalos de tiempo de trabajo de 10:00 a 19:00 para cada día laboral, algo así como el <em>horario (hora de inicio, hora de finalización)</em> .  Como entendimos, será conveniente resolver nuestro problema.  En la vida real, dicho calendario debe establecerse en una tabla, durante dos años solo son unos 500 registros, para fines prácticos será necesario establecer incluso diez años: esto es un par y medio mil registros, basura real para bases de datos modernas.  Pero tenemos un problema que se resolverá en una solicitud, y enumerar toda la tabla no es muy práctico.  Intentemos implementarlo de manera más compacta. </p><br><p>  En cualquier caso, necesitamos días festivos para eliminarlos del horario base, y aquí solo la lista es adecuada: </p><br><pre> <code class="pgsql hljs"> dates_exclude(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>), <span class="hljs-comment"><span class="hljs-comment">-- 2018 ('2018-01-02'::date), ('2018-01-03'::date), ('2018-01-04'::date), ('2018-01-05'::date), ('2018-01-08'::date), ('2018-02-23'::date), ('2018-03-08'::date), ('2018-03-09'::date), ('2018-05-01'::date), ('2018-05-02'::date), ('2018-05-09'::date), ('2018-06-11'::date), ('2018-06-12'::date), ('2018-11-05'::date), ('2018-12-31'::date), ('2019-01-01'::date), -- 2019 ('2019-01-02'::date), ('2019-01-03'::date), ('2019-01-04'::date), ('2019-01-07'::date), ('2019-01-08'::date), ('2019-03-08'::date), ('2019-05-01'::date), ('2019-05-02'::date), ('2019-05-03'::date), ('2019-05-09'::date), ('2019-05-10'::date), ('2019-06-12'::date), ('2019-11-04'::date) )</span></span></code> </pre> <br><p>  y días hábiles adicionales para agregar: </p><br><pre> <code class="pgsql hljs"> dates_include(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-comment"><span class="hljs-comment">--  2018,  2019  ('2018-04-28'::date), ('2018-06-09'::date), ('2018-12-29'::date) )</span></span></code> </pre> <br><p>  La secuencia de días hábiles durante dos años puede generarse mediante una función especial y muy adecuada <em>generate_series ()</em> , que arroja inmediatamente sábados y domingos en el camino: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-comment"><span class="hljs-comment">--    </span></span></code> </pre> <br><p>  Obtenemos los días hábiles conectando todo juntos: generamos una secuencia de todos los días hábiles en dos años, agregamos días hábiles adicionales de <em>date_include</em> y <em>eliminamos</em> todos los días adicionales de <em>date_exclude</em> : </p><br><pre> <code class="pgsql hljs"> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-comment"><span class="hljs-comment">--     union select d from dates_include --     except select d from dates_exclude --     )</span></span></code> </pre> <br><p>  Y ahora tenemos los intervalos de tiempo que necesitamos: </p><br><pre> <code class="pgsql hljs"> schedule(start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>, d + <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base )</code> </pre> <br><p>  Entonces, tenemos el horario. </p><br><h3 id="sobiraem-vsyo-vmeste">  Poniendo todo junto </h3><br><p>  Ahora obtendremos las intersecciones: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> schedule s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) &amp;&amp; <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time)</code> </pre> <br><p>  Preste atención a la condición de unión <em>ON</em> , no coincide con dos registros correspondientes de las tablas unidas, no existe tal correspondencia, pero se introduce alguna optimización que corta los intervalos de tiempo de trabajo con los que nuestro período inicial no se cruza.  Esto se hace usando el operador <em>&amp;&amp;</em> , que verifica la intersección de los intervalos de <em>rango</em> .  Esto elimina muchas intersecciones vacías para no interferir con los ojos, pero, por otro lado, elimina la información sobre esos períodos iniciales que caen completamente fuera de las horas.  Entonces, admiramos que nuestro enfoque funcione y reescribimos la solicitud de la siguiente manera: </p><br><pre> <code class="pgsql hljs"> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p , schedule s ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, start_time, stop_time , sum(upper(wrkh)-lower(wrkh)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> id, start_time, stop_time</code> </pre> <br><p>  En los <em>períodos_wrk</em> descomponemos cada período de origen en intervalos de trabajo, y luego consideramos su duración total.  El resultado fue un producto cartesiano completo de todos los períodos e intervalos, pero no se perdió un solo período. </p><br><p>  Todo, el resultado es recibido.  No me <em>gustaron los</em> valores <em>NULL</em> para intervalos vacíos, deje que la consulta muestre un intervalo de longitud cero mejor.  Envuelva la cantidad en <em>fusión ()</em> : </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, start_time, stop_time , coalesce(sum(upper(wrkh)-lower(wrkh)), <span class="hljs-string"><span class="hljs-string">'0 sec'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> id, start_time, stop_time</code> </pre> <br><p>  Todos juntos dan el resultado final: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-03-29 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-08 14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 20:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-11 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-12 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-12-28 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-01-16 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) ), dates_exclude(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>), <span class="hljs-comment"><span class="hljs-comment">-- 2018 ('2018-01-02'::date), ('2018-01-03'::date), ('2018-01-04'::date), ('2018-01-05'::date), ('2018-01-08'::date), ('2018-02-23'::date), ('2018-03-08'::date), ('2018-03-09'::date), ('2018-05-01'::date), ('2018-05-02'::date), ('2018-05-09'::date), ('2018-06-11'::date), ('2018-06-12'::date), ('2018-11-05'::date), ('2018-12-31'::date), ('2019-01-01'::date), -- 2019 ('2019-01-02'::date), ('2019-01-03'::date), ('2019-01-04'::date), ('2019-01-07'::date), ('2019-01-08'::date), ('2019-03-08'::date), ('2019-05-01'::date), ('2019-05-02'::date), ('2019-05-03'::date), ('2019-05-09'::date), ('2019-05-10'::date), ('2019-06-12'::date), ('2019-11-04'::date) ), dates_include(start_time, stop_time) as ( values --  2018,  2019  ('2018-04-28 10:00:00'::timestamp, '2018-04-28 19:00:00'::timestamp), ('2018-06-09 10:00:00'::timestamp, '2018-06-09 19:00:00'::timestamp), ('2018-12-29 10:00:00'::timestamp, '2018-12-29 19:00:00'::timestamp) ) ), schedule_base(start_time, stop_time) as ( select d::timestamp + '10:00:00', d::timestamp + '19:00:00' from generate_series( (select min(start_time) from periods)::date::timestamp , (select max(stop_time) from periods)::date::timestamp , '1 day'::interval ) as days(d) where extract(dow from d) not in (0,6) ), schedule as ( select * from schedule_base where start_time::date not in (select d from dates_exclude) union select * from dates_include ), periods_wrk as ( select p.* , tsrange(p.start_time, p.stop_time) * tsrange(s.start_time, s.stop_time) as wrkh from periods p , schedule s ) select id, start_time, stop_time , sum(coalesce(upper(wrkh)-lower(wrkh), '0 sec'::interval)) from periods_wrk group by id, start_time, stop_time</span></span></code> </pre> <br><p>  ¡Hurra! .. Esto podría estar terminado, pero en aras de la exhaustividad consideraremos algunos temas más relacionados. </p><br><h3 id="dalneyshee-razvitie-temy">  Mayor desarrollo del tema. </h3><br><p>  Días más cortos antes de las vacaciones, descansos para almorzar, diferentes horarios para diferentes días de la semana ... En principio, todo está claro, debe fijar la definición de <em>horario</em> , solo dé un par de ejemplos. </p><br><p>  Así es como puede establecer diferentes horas de inicio y finalización para un día hábil, según el día de la semana: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-comment"><span class="hljs-comment">--  when 2 then '11:00:00'::time --  when 3 then '11:00:00'::time --  --        else '10:00:00'::time end , d + case extract(dow from d) --   19   when 5 then '14:00:00'::time --  else '19:00:00'::time end from schedule_base</span></span></code> </pre> <br><p>  Si necesita tener en cuenta las pausas para el almuerzo de 13:00 a 14:00, en lugar de un intervalo por día, haga dos: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> , d + <span class="hljs-string"><span class="hljs-string">'13:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> , d + <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base</code> </pre> <br><p>  Bueno y así sucesivamente. </p><br><h3 id="proizvoditelnost">  Rendimiento </h3><br><p>  Diré algunas palabras sobre el rendimiento, ya que siempre hay preguntas al respecto.  No voy a masticar mucho, esta es una sección con un asterisco. </p><br><p>  En general, la optimización prematura es malvada.  Según mis muchos años de observación, la legibilidad del código es su ventaja más importante.  Si el código se lee bien, entonces es más fácil de mantener y desarrollar.  El código legible requiere implícitamente una buena arquitectura de solución, comentarios adecuados y buenos nombres de variables, compacidad sin sacrificar la legibilidad, etc., es decir, todo para lo que se llama el código. </p><br><p>  Por lo tanto, la solicitud siempre se escribe de la manera más legible posible, y comenzamos a optimizar si y solo si resulta que el rendimiento es insuficiente.  Además, lo optimizaremos con precisión cuando el rendimiento sea insuficiente y exactamente en la medida en que sea suficiente.  Si ciertamente valoras tu propio tiempo y tienes algo que hacer. </p><br><p>  Pero no es correcto realizar un trabajo innecesario en la solicitud; siempre debe intentar tener esto en cuenta. </p><br><p>  En base a esto, incluiremos una optimización en la consulta de inmediato: deje que cada período de origen se entrecruce solo con aquellos intervalos de tiempo de trabajo con los que tiene puntos comunes (en lugar de una condición clásica larga en los límites del rango, es más conveniente usar el operador <em>&amp;&amp;</em> incorporado para el tipo de <em>rango</em> ).  Esta optimización ya apareció en la solicitud, pero ha llevado al hecho de que los períodos iniciales que cayeron por completo de las horas de trabajo desaparecieron de los resultados. </p><br><p>  Traiga de vuelta esta optimización.  Para hacer esto, use <em>LEFT JOIN</em> , que guardará todos los registros de la tabla de <em>períodos</em> .  Ahora la subconsulta <em>period_wrk</em> se verá así: </p><br><pre> <code class="pgsql hljs">, periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p <span class="hljs-keyword"><span class="hljs-keyword">left join</span></span> schedule s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) &amp;&amp; <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time))</code> </pre> <br><p>  El análisis de la solicitud muestra que el tiempo en los datos de prueba ha disminuido aproximadamente a la mitad.  Dado que el tiempo de ejecución depende de lo que el servidor estaba haciendo al mismo tiempo, tomé algunas medidas y di un resultado "típico", no el más grande, ni el más pequeño, del medio. </p><br><p>  Consulta anterior: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyse</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( ... QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------ HashAggregate (cost=334.42..338.39 rows=397 width=36) (actual time=10.724..10.731 rows=4 loops=1) ...</span></span></code> </pre> <br><p>  Nuevo: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyse</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( ... QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------ HashAggregate (cost=186.37..186.57 rows=20 width=36) (actual time=5.431..5.440 rows=4 loops=1) ...</span></span></code> </pre> <br><p>  Pero lo más importante es que dicha solicitud también se escalará mejor, lo que requiere menos recursos del servidor, ya que el producto cartesiano completo crece muy rápidamente. </p><br><p>  Y en esto me detendría con optimizaciones.  Cuando resolví este problema por mí mismo, tuve suficiente rendimiento incluso en una forma mucho más terrible de esta solicitud, pero realmente no había necesidad de optimizar.  Para obtener un informe sobre mis datos una vez por trimestre, puedo esperar diez segundos adicionales.  La hora extra que se dedica a la optimización en tales condiciones nunca valdrá la pena. </p><br><p>  Pero resulta poco interesante; sigamos pensando en cómo podrían desarrollarse los eventos si realmente se necesitara una optimización en términos de tiempo de ejecución.  Por ejemplo, queremos monitorear este parámetro en tiempo real para cada uno de nuestros registros en la base de datos, es decir, para cada estornudo se llamará a dicha solicitud.  Bueno, o invente su propia razón, ¿por qué necesitaría optimizar? </p><br><p>  Lo primero que viene a la mente es contar una vez y poner en la base de datos una tabla con intervalos de trabajo.  Puede haber contraindicaciones: si la base de datos no se puede cambiar, o se esperan dificultades con el apoyo de los datos relevantes en dicha tabla.  Luego tendrá que dejar la generación de tiempo de trabajo "sobre la marcha" en la solicitud, ya que esta no es una subconsulta muy pesada. </p><br><p>  El siguiente y más poderoso enfoque (pero no siempre aplicable) es la optimización algorítmica.  Algunos de estos enfoques ya se han presentado en los comentarios al artículo con la condición del problema. </p><br><p>  Este me gusta más que nada.  Si hace una tabla con todos los días (no solo de trabajo) del calendario y calcula el total acumulado de cuántas horas de trabajo cada día de una determinada "creación del mundo" han pasado, entonces puede obtener el número de horas de trabajo entre dos fechas con una operación de resta.  Solo queda tener en cuenta correctamente las horas de trabajo para el primer y último día, y ya está.  Esto es lo que obtuve en este enfoque: </p><br><pre> <code class="pgsql hljs"> schedule_base(d, is_working) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">all</span></span>(<span class="hljs-string"><span class="hljs-string">'{2019-01-01,2019-01-02,2019-01-03,2019-01-04,2019-01-07,2019-01-08,2019-03-08,2019-05-01,2019-05-02,2019-05-03,2019-05-09,2019-05-10,2019-06-12,2019-11-04,2018-01-01,2018-01-02,2018-01-03,2018-01-04,2018-01-05,2018-01-08,2018-02-23,2018-03-08,2018-03-09,2018-04-30,2018-05-01,2018-05-02,2018-05-09,2018-06-11,2018-06-12,2018-11-05,2018-12-31}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>(<span class="hljs-string"><span class="hljs-string">'{2018-04-28,2018-06-09,2018-12-29}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> d &lt; <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span> ), schedule(d, is_working, work_hours) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d, is_working , sum(is_working*<span class="hljs-string"><span class="hljs-string">'9 hours'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unbounded</span></span> <span class="hljs-keyword"><span class="hljs-keyword">preceding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , s2.work_hours - s1.work_hours + (<span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> - least(greatest(p.start_time::<span class="hljs-type"><span class="hljs-type">time</span></span>, <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>), <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>)) * s1.is_working - (<span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> - least(greatest(p.stop_time::<span class="hljs-type"><span class="hljs-type">time</span></span>, <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>), <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>)) * s2.is_working <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p, schedule s1, schedule s2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> s1.d = p.start_time::<span class="hljs-type"><span class="hljs-type">date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> s2.d = p.stop_time::<span class="hljs-type"><span class="hljs-type">date</span></span></code> </pre> <br><p>  Explicaré brevemente lo que está sucediendo aquí.  En la subconsulta <em>schedule_base</em> , generamos todos los días del calendario durante dos años y cada día determinamos el signo si el día hábil (= 1) o no (= 0).  Además, en la subconsulta de <em>programación</em> , consideramos la función de ventana como el número total acumulado de horas de trabajo desde 2018-01-01.  Sería posible hacer todo en una subconsulta, pero resultaría más engorroso, lo que perjudicaría la legibilidad.  Luego, en la solicitud principal, consideramos la diferencia entre el número de horas de trabajo al final y al comienzo del período y, de manera algo florida, tomamos en cuenta las horas de trabajo para el primer y último día del período.  La floridez se asocia con el cambio del tiempo antes del comienzo de la jornada laboral a su comienzo, y el tiempo posterior al final de la jornada laboral a su finalización.  Además, si la parte de la solicitud con <em>shedule_base</em> y <em>horario se</em> elimina en una tabla precalculada separada (como se sugirió anteriormente), la solicitud se convertirá en una completamente trivial. </p><br><p>  Comparemos la ejecución en una muestra más grande para mostrar mejor la optimización realizada, durante cuatro períodos desde la condición de la tarea se dedica más tiempo a generar un cronograma de trabajo. </p><br><p>  Tomé alrededor de 3 mil períodos.  Daré solo la línea de resumen superior en EXPLAIN, los valores típicos son los siguientes. </p><br><p>  Opción original: </p><br><pre> <code class="pgsql hljs">GroupAggregate (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">265790.95</span></span>.<span class="hljs-number"><span class="hljs-number">.296098</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">144320</span></span> width=<span class="hljs-number"><span class="hljs-number">36</span></span>) (actual <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">656.654</span></span>.<span class="hljs-number"><span class="hljs-number">.894</span></span><span class="hljs-number"><span class="hljs-number">.383</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">2898</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  Optimizado: </p><br><pre> <code class="pgsql hljs">Hash <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">45.01</span></span>.<span class="hljs-number"><span class="hljs-number">.127</span></span><span class="hljs-number"><span class="hljs-number">.52</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">70</span></span> width=<span class="hljs-number"><span class="hljs-number">36</span></span>) (actual <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">1.620</span></span>.<span class="hljs-number"><span class="hljs-number">.5</span></span><span class="hljs-number"><span class="hljs-number">.385</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">2898</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  La ganancia de tiempo fue un par de órdenes de magnitud.  Con el aumento en el número de períodos y su duración en años, la brecha solo se ampliará. </p><br><p>  Todo parecía estar bien, pero ¿por qué, habiendo hecho tal optimización, dejé la primera versión de la solicitud para mí hasta que su rendimiento fue suficiente?  Sí, porque la versión optimizada es indudablemente más rápida, pero requiere mucho más tiempo para entender cómo funciona, es decir, la legibilidad ha empeorado.  Es decir, la próxima vez que necesite reescribir la solicitud en mis condiciones cambiadas, yo (o no yo) tendré que dedicar mucho más tiempo a comprender cómo funciona la solicitud. </p><br><p>  Eso es todo por hoy, mantén los tentáculos calientes y te digo adiós hasta la próxima versión de Radio SQL. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459236/">https://habr.com/ru/post/459236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459224/index.html">De agente inmobiliario a desarrollador de juegos 2. "Operación: Android"</a></li>
<li><a href="../459226/index.html">"Fast-PoE y Perpetual-PoE: ¿son estos nuevos estándares o no?"</a></li>
<li><a href="../459230/index.html">Un viaje al centro de llamadas y a la cartera de productos a través de los ojos del desarrollador</a></li>
<li><a href="../459232/index.html">Rodea, muerde, corta: la nueva competencia Mini AI Cup # 4</a></li>
<li><a href="../459234/index.html">Smem: informes sobre la asignación de memoria entre procesos y usuarios en Linux</a></li>
<li><a href="../459238/index.html">De una función matemática mágica: una solución para gobernarlos a todos</a></li>
<li><a href="../459240/index.html">10 años en TI diagnosticados con esquizofrenia, consejos de supervivencia</a></li>
<li><a href="../459242/index.html">Después de la conferencia T + Conf 2019</a></li>
<li><a href="../459244/index.html">Administrador de productos de Notes: comportamiento del usuario en las páginas del juego en la tienda de aplicaciones. ¿Cuánto tiempo lleva descargar un juego?</a></li>
<li><a href="../459246/index.html">¿Por qué está disminuyendo la conversión del sitio? Ejemplos de 60 errores de diseño y usabilidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>