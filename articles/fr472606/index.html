<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔴 🤒 ✂️ Nous emballons tout le trafic OS à Tor 👩‍❤️‍💋‍👩 👐🏾 ☮️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tout ce qui est décrit dans l'article est implémenté comme un outil Toroxy disponible sur GitHub  Récemment, l'anonymat en ligne a fait l'objet de vif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous emballons tout le trafic OS à Tor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postuf/blog/472606/"><img src="https://habrastorage.org/webt/z3/d1/g0/z3d1g0m8ezuksztgh1d6wbwenuw.png"><br><br><blockquote>  Tout ce qui est décrit dans l'article est implémenté comme un outil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Toroxy</a> disponible sur GitHub </blockquote>  Récemment, l'anonymat en ligne a fait l'objet de vifs débats.  Ce n'est un secret pour personne que les données sur les visites des ressources Internet à partir d'un appareil local peuvent être collectées à différents niveaux afin de construire un «modèle» de l'utilisateur, qui pourra ensuite être utilisé contre lui (ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pourrait</a> ).  Par conséquent, il n'est pas surprenant qu'un nombre croissant d'utilisateurs actifs d'Internet soient convaincus de la nécessité de mécanismes de proxy et d'anonymisation.  À cet égard, il y a de plus en plus de nouveaux clients VPN, mais, comme le montre la pratique, tous ne peuvent pas vraiment faire confiance: soit tout ne fonctionne pas prêt à l'emploi, alors seul le trafic HTTP est anonymisé, puis la qualité de la mise en œuvre est boiteuse, ou et les développeurs pèchent en fusionnant les données sur leurs utilisateurs. <br><br>  Dans cet article, nous allons essayer d'assembler notre propre outil avec une interface utilisateur à partir d'un certain nombre de composants logiciels, ce qui nous permettrait d'anonymiser complètement le trafic du système local et d'éviter les fuites sur les canaux «d'écoute» à n'importe quelle étape du travail. <br><a name="habracut"></a><br>  Notre objectif principal sera de «construire» un utilitaire fiable à partir d'outils prêts à l'emploi.  De toute évidence, l'idée de créer un outil de qualité à partir de zéro dans un délai raisonnable est semée d'erreurs, et il sera donc plus rapide et plus fiable de choisir des composants prêts à l'emploi, puis de les connecter correctement! <br><br>  Que devrait faire un outil? <br><br><ol><li>  Rediriger tout le trafic du système cible vers les nœuds intermédiaires (de préférence plusieurs) pour masquer de manière fiable la source </li><li>  Suivez les violations possibles de l'anonymat, corrigez-les et signalez-les à l'aide des notifications de l'interface utilisateur </li></ol><br>  Composants sélectionnés pour la création de l'outil: <br><br><ul><li>  tor </li><li>  iptables </li><li>  python3 </li><li>  systemd </li></ul><br>  En mélangeant tous les composants dans un shell appelé «Linux», nous pouvons certainement obtenir quelque chose de valable qui aidera à atteindre l'objectif final. <br><br><h3>  Composant # 1: Tor </h3><br>  C'est autour de cette composante que sera construit le reste de l'infrastructure d'outils.  Tor fournit un mécanisme qui fait partie de tout client VPN - un mécanisme pour envelopper le trafic via des nœuds intermédiaires de manière anonyme pour un observateur externe (dans la configuration standard de ces nœuds 3). <br><br>  Par défaut, le client Tor des référentiels par lots standard après l'installation commence à écouter le port 9050, qui accepte tout client pouvant se chausser.  Le problème est qu'en plus du trafic de chaussettes dans notre système, il peut y avoir un tas d'autres trafics d'applications qui ne fonctionnent pas sur ce protocole.  À cet égard, tout d'abord, au sein du système local, vous devrez couper une fenêtre dans le réseau Tor pour toute nouvelle connexion réseau.  Cela se fait tout simplement en augmentant le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">proxy transparent</a> dans la configuration <a href="">torrc</a> : <br><br><pre><code class="plaintext hljs">/etc/tor/torrc ... TransPort 9040 #           python ControlPort 9051 ...</code> </pre> <br>  Une attention particulière doit être accordée au trafic UDP.  Le fait est que le principe de routage de l'oignon est basé sur le concept de «flux», qui, comme vous le savez, n'existe que dans TCP.  En envoyant un paquet UDP via Tor, le système cible ne pourra pas recevoir de réponse, car le paquet de réponse ne trouvera pas le chemin de retour.  Mais malgré cette particularité, nous avons toujours la possibilité d'anonymiser les requêtes DNS, qui sont connues pour être effectuées sur UDP, et en même temps inclure la résolution .onion: <br><br><pre> <code class="plaintext hljs">/etc/tor/torrc ... AutomapHostsOnResolve 1 DNSPort 53 ...</code> </pre><br>  Sur cela, l'accès à Tor est ouvert dans le bouclage. <br><br><h3>  Composante # 2: Iptables </h3><br>  Puisque notre tâche est de cacher la véritable source de trafic à un observateur externe dans tout le système, et que la fenêtre de Tor est déjà ouverte, il ne reste plus qu'à envelopper tout le trafic dans cette fenêtre.  Le pare-feu système fourni avec le noyau Linux nous aidera à cela: <br><br><pre> <code class="plaintext hljs">#  tcp iptables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports $TRANS_PORT #   udp (dns only) iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports 53 iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT #       iptables -A OUTPUT -j REJECT ip6tables -A OUTPUT -j REJECT</code> </pre><br>  À ce stade, nous obtenons un utilitaire fonctionnel qui masque de manière fiable tout le trafic sortant, mais ce n'est que la moitié du travail. <br><br><h3>  Composant n ° 3: interface utilisateur python + Desktop Evironment </h3><br>  Chaque fois, la configuration manuelle à partir de la console (même si ce sera le lancement d'un script bash) sera assez fatigante, il est donc temps de commencer à écrire un petit utilitaire qui nous aide spécifiquement dans ce qui suit: <br><br><ol><li>  Configuration automatique </li><li>  Modifiez votre identité au sein de Tor à tout moment </li><li>  Surveillance de l'intégrité des règles iptables et réécriture en cas de violation </li><li>  Suivi de votre identité actuelle (IP) </li><li>  Notification des deux paragraphes précédents avec notifications graphiques </li></ol><br>  Au premier démarrage, l'utilitaire téléchargera tous les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">composants nécessaires par</a> lui-même, et lors des lancements suivants, il configurera Tor en conjonction avec iptables, comme décrit ci-dessus. <br><br>  Si vous souhaitez modifier votre adresse IP externe, vous interagirez avec le port de service Tor-9051, qui était ouvert au tout début pour automatiser le changement IP: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> Controller.from_port(port = <span class="hljs-number"><span class="hljs-number">9051</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> controller: controller.authenticate() controller.signal(Signal.NEWNYM)</code> </pre><br>  Le suivi d'intégrité peut être implémenté de manière assez banale (nous le faisons à genoux) en lisant périodiquement la structure des règles iptables et en vérifiant leur somme SHA256: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rulesOk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> RULES_CHECKSUM_CMD = <span class="hljs-string"><span class="hljs-string">"{ iptables-save &amp;&amp; ip6tables-save; } | sed s/\-\-uid\-owner\\\\s[0-9]\\\\+\\\\s//g | grep -viE '^#' | grep -viE '^\:' | sort | uniq | sha256sum | cut -d' ' -f 1"</span></span> checkSum = getoutput(RULES_CHECKSUM_CMD).strip() alright = checkSum == Strings.RULES_CHECKSUM_CORRECT_HASH <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> alright: rules = getoutput(<span class="hljs-string"><span class="hljs-string">'iptables-save &amp;&amp; ip6tables-save'</span></span>) self.lastSnapshotFileName = <span class="hljs-string"><span class="hljs-string">"/tmp/broken-rules-%s.log"</span></span> % time.strftime(<span class="hljs-string"><span class="hljs-string">"%d-%m-%Y_%I-%M-%S"</span></span>) open(self.lastSnapshotFileName, <span class="hljs-string"><span class="hljs-string">"w"</span></span>).write(rules) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre><br>  En outre, s'il existe des incohérences avec la somme de contrôle attendue, vous pouvez enregistrer le vidage des règles iptables dans <code>/tmp/broken-rules-%d-%m-%Y_%I-%M-%S.log</code> pour d'autres procédures.  S'il s'avère que <pre> <code class="python hljs">rulesOk() == <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre>  cela lancera une réécriture de la table des règles iptables. <br><br>  La surveillance de l'adresse IP actuelle se fera en accédant en permanence à une ressource externe qui fournit le client IP - par exemple, <code>ident.me</code> . <br><br>  Enfin, nous utiliserons DE UI pour signaler des problèmes avec les règles ou le changement d'IP.  Chaque environnement graphique est unique d'une manière ou d'une autre, en particulier lorsqu'il s'agit d'utiliser l'interface utilisateur du processus démon, mais sur la plupart des systèmes Linux, un tel code bash appelé à partir de Python affichera avec succès des notifications: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># root UI eval "export $(egrep -z DBUS_SESSION_BUS_ADDRESS /proc/$(pgrep -u $LOGNAME gnome-session)/environ)" export DISPLAY=:0 for USR in `ls /home &amp;&amp; echo root` do # ubuntu gnome + root UI export XAUTHORITY=/home/$USR/.Xauthority notify-send -u {0} '{1}' '{2}' # ubuntu parallels for UID in `ls /run/user/` do su $USR -c "DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$UID/bus notify-send -u {0} '{1}' '{2}'" done done</span></span></code> </pre><br>  En combinant tout cela dans un script Python de 200 lignes, nous obtenons ce que nous avons accompli.  Voici, par exemple, à quoi ressemblera une notification que notre identité a été mise à jour: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c34/9b1/900/c349b19003c9bb00c1e951e6a0b36668.png" alt="image"><br><br>  Et voici à quoi ressemblera la notification: l'intégrité des règles Iptables a été violée, indiquant le vidage contenant la violation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/556/3eb/a2f/5563eba2f4e2abc70ba83caaae1cffdd.png" alt="image"><br><br><h3>  Composant # 4: systemd </h3><br>  Et enfin, nous aimerions certainement faire une configuration unique et ne pas penser à notre sécurité à l'avenir, et donc l'exécution automatique et les services viennent à la rescousse.  Linux possède plusieurs sous-systèmes de gestion de démons standard: systemd, sysV, init.  Dans notre cas, le choix s'est porté sur systemd en raison de la flexibilité de sa configuration. <br><br>  Supposons que le script python écrit à l'étape précédente s'appelle «toroxy» et se trouve dans <code>/usr/bin/</code> , puis son exécution automatique et sa surveillance ultérieure avec une certaine flexibilité pour contrôler le démon seront comme ceci: <br><br><pre> <code class="plaintext hljs">[Unit] Description=Toroxy After=network.target StartLimitIntervalSec=0 [Service] Type=simple Restart=always RestartSec=1 User=root # service toroxy start ExecStart=/usr/bin/toroxy service # service toroxy stop ExecStop=/usr/bin/toroxy stop # service toroxy reload ExecReload=/usr/bin/toroxy switch [Install] #   init 3,       UI     Tor WantedBy=multi-user.target</code> </pre><br>  Presque tout est prêt pour un fonctionnement "industriel".  La touche finale que je voudrais ajouter à l'outil pour plus de fiabilité est l'initialisation automatique des règles iptables au démarrage du système (comme vous le savez, les règles iptables sont réinitialisées lors du redémarrage) en utilisant iptables-persistent: <br><br><pre> <code class="bash hljs">iptables-save &gt; /etc/iptables/rules.v4 ip6tables-save &gt; /etc/iptables/rules.v6 netfilter-persistent start &amp;&amp; netfilter-persistent save</code> </pre><br><h3>  Conclusion </h3><br>  Nous avons donc assemblé notre propre outil à partir d'une combinaison de divers composants qui, avec un degré de fiabilité assez élevé, sont capables de fournir un anonymat continu de l'utilisateur Linux sur le réseau.  En conclusion, il faut dire que tout ce qui est décrit dans l'article est implémenté comme un outil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Toroxy</a> disponible sur GitHub. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472606/">https://habr.com/ru/post/fr472606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472596/index.html">Comment faire des vidéos pour les jeux. Conseils pratiques et directives utiles</a></li>
<li><a href="../fr472598/index.html">Orientation dynamique</a></li>
<li><a href="../fr472600/index.html">Introduction à Git</a></li>
<li><a href="../fr472602/index.html">Comment ne pas faire honte aux réunions, ou le développeur apprend aux développeurs à parler. Entretien avec Alexander Shushunov</a></li>
<li><a href="../fr472604/index.html">Webinaire ouvert «Fluent Validation comme outil de validation des données»</a></li>
<li><a href="../fr472610/index.html">Quels éléments HTML sont les plus demandés: analyse de 8 millions de pages d'un point de vue SEO</a></li>
<li><a href="../fr472612/index.html">Les amis Agile et Knowledge Management?</a></li>
<li><a href="../fr472614/index.html">Tente de commencer à enseigner à un enfant la programmation avec l'édition de poche Minecraft</a></li>
<li><a href="../fr472616/index.html">Comment nous avons mis sur pied une super équipe sur un site distant et ne l'avons jamais regretté</a></li>
<li><a href="../fr472620/index.html">Museum DataArt. Inspection du terminal vidéo Mera CM 7209</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>