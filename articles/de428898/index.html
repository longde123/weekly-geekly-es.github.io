<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌐 🦓 🧕🏼 Problematische Aspekte der Programmierung in C ++ 🔉 🌐 ☝🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C ++ gibt es einige Funktionen, die als potenziell gefährlich eingestuft werden können. Bei Fehlkalkulationen im Design oder ungenauer Codierung kö...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Problematische Aspekte der Programmierung in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428898/"><hr><p>  <i>In C ++ gibt es einige Funktionen, die als potenziell gefährlich eingestuft werden können. Bei Fehlkalkulationen im Design oder ungenauer Codierung können sie leicht zu Fehlern führen.</i>  <i>Der Artikel enthält eine Auswahl solcher Funktionen sowie Tipps zur Reduzierung ihrer negativen Auswirkungen.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Inhaltsverzeichnis </h1><br><div class="spoiler">  <b class="spoiler_title">Inhaltsverzeichnis</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. Typen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bedingte Anweisungen und Bediener</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implizite Konvertierungen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2. Namensauflösung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausblenden von Variablen in verschachtelten Bereichen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionsüberlastung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3. Konstruktoren, Destruktoren, Initialisierung, Löschung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vom Compiler generierte Klassenelementfunktionen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nicht initialisierte Variablen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Initialisierungsverfahren für Basisklassen und nicht statische Klassenmitglieder</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Initialisierungsverfahren für statische Klassenmitglieder und globale Variablen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausnahmen bei Destruktoren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dynamische Objekte und Arrays entfernen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Löschen, wenn die Klassendeklaration unvollständig ist</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Operatoren, Ausdrücke</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bedienerpriorität</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bedienerüberlastung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Verfahren zur Berechnung von Unterausdrücken</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. Virtuelle Funktionen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.1 Virtuelle Funktionen überschreiben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.2 Überladen und Verwenden von Standardparametern</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.3 Aufruf virtueller Funktionen im Konstruktor und Destruktor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.4 Virtueller Destruktor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6. Direkte Arbeit mit dem Speicher</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.1 Puffer überlaufen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2 Z-terminierte Zeichenfolgen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.3 Funktionen mit variabler Anzahl von Parametern</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7. Syntax</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7.1 Komplizierte Ankündigungen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7.2 Mehrdeutigkeit der Syntax</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8. Verschiedenes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.1 Keyword Inline und ODR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.2 Header-Dateien</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.3 switch-Anweisung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.4 Parameter als Wert übergeben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.5 Ressourcenverwaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.6 Links besitzen und nicht besitzen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.7 Binäre Kompatibilität</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.8 Makros</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">9. Zusammenfassung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenzliste</a> <br></p><br></div></div><br><p>  <i>Praemonitus, Praemunitus.</i> <i><br></i>  <i>Vorgewarnt bedeutet bewaffnet.</i>  <i>(lat.)</i> <br></p><br><a name="id-introdaction"></a><br><h1>  Einführung </h1><br><p>  In C ++ gibt es einige Funktionen, die als potenziell gefährlich eingestuft werden können. Bei Fehlkalkulationen im Design oder ungenauer Codierung können sie leicht zu Fehlern führen.  Einige von ihnen können auf eine schwierige Kindheit zurückgeführt werden, andere auf den veralteten C ++ 98-Standard, andere sind bereits mit den Funktionen des modernen C ++ verbunden.  Betrachten Sie die wichtigsten und versuchen Sie, Ratschläge zu geben, wie Sie ihre negativen Auswirkungen verringern können. </p><br><a name="id-1"></a><br><h1>  1. Typen </h1><br><a name="id-1-1"></a><br><h2>  1.1.  Bedingte Anweisungen und Bediener </h2><br><p> Die Notwendigkeit der Kompatibilität mit C führt dazu, dass Sie in der Anweisung <code>if(...)</code> und dergleichen jeden numerischen Ausdruck oder Zeiger ersetzen können und nicht nur Ausdrücke wie <code>bool</code> .  Das Problem wird durch die implizite Konvertierung von <code>bool</code> nach <code>int</code> in arithmetischen Ausdrücken und die Priorität einiger Operatoren verschärft.  Dies führt beispielsweise zu folgenden Fehlern: </p><br><p>  <code>if(a=b)</code> wenn richtig <code>if(a==b)</code> , <br>  <code>if(a&lt;x&lt;b)</code> , wenn richtig <code>if(a&lt;x &amp;&amp; x&lt;b)</code> , <br>  <code>if(a&amp;x==0)</code> , wenn richtig <code>if((a&amp;x)==0)</code> , <br>  <code>if(Foo)</code> wenn richtig <code>if(Foo())</code> , <br>  <code>if(arr)</code> wenn richtig <code>if(arr[0])</code> , <br>  <code>if(strcmp(s,r))</code> wenn korrekt <code>if(strcmp(s,r)==0)</code> . </p><br><p>  Einige dieser Fehler verursachen eine Compiler-Warnung, jedoch keinen Fehler.  Manchmal können auch Code-Analysatoren helfen.  In C # sind solche Fehler fast unmöglich. <code>if(...)</code> und ähnliche Anweisungen einen <code>bool</code> Typ erfordern, können Sie <code>bool</code> und numerische Typen nicht in arithmetischen Ausdrücken mischen. </p><br><p>  Wie man kämpft: </p><br><ul><li>  Programm ohne Warnungen.  Leider hilft dies nicht immer, da einige der oben beschriebenen Fehler keine Warnungen enthalten. </li><li>  Verwenden Sie statische Code-Analysatoren. </li><li>  Altmodische Empfangstechnik: Wenn Sie mit einer Konstanten vergleichen, setzen Sie sie links, zum Beispiel <code>if(MAX_PATH==x)</code> .  Es sieht ziemlich Eigentumswohnung aus (und hat sogar seinen eigenen Namen - "Yoda Notation"), und hilft in einer kleinen Anzahl von Fällen in Betracht gezogen. </li><li>  Verwenden Sie das <code>const</code> Qualifikationsmerkmal so weit wie möglich.  Auch hier hilft es nicht immer. </li><li>  Gewöhnen Sie sich daran, die richtigen logischen Ausdrücke zu schreiben: <code>if(x!=0)</code> anstelle von <code>if(x)</code> .  (Obwohl Sie hier in die Falle der Operatorprioritäten geraten können, sehen Sie sich das dritte Beispiel an.) </li><li>  Seien Sie sehr aufmerksam. </li></ul><br><a name="id-1-2"></a><br><h2>  1.2.  Implizite Konvertierungen </h2><br><p>  C ++ bezieht sich auf stark typisierte Sprachen, aber implizite Typkonvertierungen werden häufig verwendet, um Code kürzer zu machen.  Diese impliziten Konvertierungen können in einigen Fällen zu Fehlern führen. </p><br><p>  Die nervigsten impliziten Konvertierungen sind Konvertierungen eines numerischen Typs oder Zeigers auf <code>bool</code> und von <code>bool</code> nach <code>int</code> .  Es sind diese Transformationen (notwendig für die Kompatibilität mit C), die die in Abschnitt 1.1 beschriebenen Probleme verursachen.  Implizite Konvertierungen, die möglicherweise zu einem Verlust der Genauigkeit numerischer Daten führen (Verengung der Konvertierungen), z. B. von <code>double</code> nach <code>int</code> sind ebenfalls nicht immer angemessen.  In vielen Fällen generiert der Compiler eine Warnung (insbesondere wenn die numerischen Daten möglicherweise an Genauigkeit verlieren), eine Warnung ist jedoch kein Fehler.  In C # sind Konvertierungen zwischen numerischen Typen und <code>bool</code> verboten (auch explizit), und Konvertierungen, die möglicherweise zu Genauigkeitsverlusten bei numerischen Daten führen, sind fast immer ein Fehler. </p><br><p>  Der Programmierer kann andere implizite Konvertierungen hinzufügen: (1) Definieren eines Konstruktors mit einem Parameter ohne das <code>explicit</code> Schlüsselwort;  (2) die Definition eines Typkonvertierungsoperators.  Diese Transformationen schließen zusätzliche Sicherheitslücken, die auf starken Typisierungsprinzipien beruhen. </p><br><p>  In C # ist die Anzahl der integrierten impliziten Konvertierungen viel geringer. Benutzerdefinierte implizite Konvertierungen müssen mit dem <code>implicit</code> Schlüsselwort deklariert werden. </p><br><p>  Wie man kämpft: </p><br><ul><li>  Programm ohne Warnungen. </li><li>  Seien Sie sehr vorsichtig mit den oben beschriebenen Designs, verwenden Sie sie nicht ohne extreme Notwendigkeit. </li></ul><br><a name="id-2"></a><br><h1>  2. Namensauflösung </h1><br><a name="id-2-1"></a><br><h2>  2.1.  Ausblenden von Variablen in verschachtelten Bereichen </h2><br><p>  In C ++ gilt die folgende Regel.  Lass </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    int x;    // ... //  ,       {        int x;        // ...    } }</span></span></code> </pre> <br><p>  Gemäß den C ++ - Regeln verbirgt die in <code></code> deklarierte Variable <code></code> die in <code></code> deklarierte Variable <code></code> <code></code>  Die erste Deklaration <code>x</code> muss sich nicht in einem Block befinden: Sie kann Mitglied einer Klasse oder einer globalen Variablen sein, sie muss nur in Block <code></code> sichtbar sein <code></code> </p><br><p>  Stellen Sie sich jetzt die Situation vor, in der Sie den folgenden Code umgestalten müssen </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    int x;    // ... //  ,       {    // -         } }</span></span></code> </pre> <br><p>  Aus Versehen werden Änderungen vorgenommen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    //  , :    int x;    // -         // ...    //  :    // -      }</span></span></code> </pre> <br><p>  Und jetzt macht der Code "etwas wird mit <code></code> von <code></code> " etwas mit <code></code> von <code></code> !  Es ist klar, dass nicht alles wie zuvor funktioniert und es oft sehr schwierig ist, das zu finden.  Es ist nicht umsonst, dass es in C # verboten ist, lokale Variablen auszublenden (obwohl Klassenmitglieder dies können).  Beachten Sie, dass der Mechanismus zum Ausblenden von Variablen in der einen oder anderen Form in fast allen Programmiersprachen verwendet wird. </p><br><p>  Wie man kämpft: </p><br><ul><li>  Deklarieren Sie Variablen im engsten Bereich. </li><li>  Schreiben Sie keine langen und tief verschachtelten Blöcke. </li><li>  Verwenden Sie Codierungskonventionen, um Kennungen mit unterschiedlichem Gültigkeitsbereich visuell zu unterscheiden. </li><li>  Seien Sie sehr aufmerksam. </li></ul><br><a name="id-2-2"></a><br><h2>  2.2.  Funktionsüberlastung </h2><br><p>  Das Überladen von Funktionen ist ein wesentliches Merkmal vieler Programmiersprachen, und C ++ ist keine Ausnahme.  Diese Gelegenheit muss jedoch sorgfältig genutzt werden, da Sie sonst in Schwierigkeiten geraten können.  In einigen Fällen, zum Beispiel wenn der Konstruktor überladen ist, hat der Programmierer keine Wahl, aber in anderen Fällen kann die Verweigerung der Überladung gerechtfertigt sein.  Berücksichtigen Sie die Probleme, die bei der Verwendung überladener Funktionen auftreten. </p><br><p>  Wenn Sie versuchen, alle möglichen Optionen zu berücksichtigen, die sich beim Auflösen einer Überlastung ergeben können, sind die Regeln zum Auflösen einer Überlastung sehr kompliziert und daher schwer vorherzusagen.  Zusätzliche Komplexität wird durch Vorlagenfunktionen und das Überladen integrierter Operatoren verursacht.  C ++ 11 fügte Probleme mit rvalue-Links und Initialisierungslisten hinzu. </p><br><p>  Der Suchalgorithmus kann Probleme für Kandidaten verursachen, um Überlastungen in verschachtelten Sichtbarkeitsbereichen zu beheben.  Wenn der Compiler Kandidaten im aktuellen Bereich gefunden hat, wird die weitere Suche beendet.  Wenn die gefundenen Kandidaten nicht geeignet, widersprüchlich, gelöscht oder unzugänglich sind, wird ein Fehler generiert, aber es wird keine weitere Suche versucht.  Und nur wenn sich im aktuellen Bereich keine Kandidaten befinden, wechselt die Suche zum nächsten, breiteren Bereich.  Der Mechanismus zum Ausblenden von Namen funktioniert fast genauso wie in Abschnitt 2.1, siehe [Dewhurst]. </p><br><p>  Überladungsfunktionen können die Lesbarkeit des Codes beeinträchtigen, was zu Fehlern führen kann. </p><br><p>  Die Verwendung von Funktionen mit Standardparametern sieht aus wie die Verwendung überladener Funktionen, obwohl natürlich weniger potenzielle Probleme auftreten.  Das Problem mit schlechter Lesbarkeit und möglichen Fehlern bleibt jedoch bestehen. </p><br><p>  Mit äußerster Vorsicht sollten Überlast- und Standardparameter für virtuelle Funktionen verwendet werden, siehe Abschnitt 5.2. </p><br><p>  C # unterstützt auch das Überladen von Funktionen, die Regeln zum Auflösen von Überladungen unterscheiden sich jedoch geringfügig. </p><br><p>  Wie man kämpft: </p><br><ul><li>  Missbrauche nicht die Überladung von Funktionen und entwerfe keine Funktionen mit Standardparametern. </li><li>  Wenn Funktionen überladen sind, verwenden Sie Signaturen, die beim Auflösen von Überladungen nicht zweifelhaft sind. </li><li>  Deklarieren Sie nicht gleichnamige Funktionen im verschachtelten Bereich. </li><li>  Vergessen Sie nicht, dass der in C ++ 11 <code>=delete</code> Mechanismus der Remote-Funktionen ( <code>=delete</code> ) verwendet werden kann, um bestimmte Überlastungsoptionen zu verbieten. </li></ul><br><a name="id-3"></a><br><h1>  3. Konstruktoren, Destruktoren, Initialisierung, Löschung </h1><br><a name="id-3-1"></a><br><h2>  3.1.  Vom Compiler generierte Klassenelementfunktionen </h2><br><p>  Wenn der Programmierer die Elementfunktionen der Klasse aus der folgenden Liste nicht definiert hat - Standardkonstruktor, Kopierkonstruktor, Kopierzuweisungsoperator, Destruktor -, kann der Compiler dies für ihn tun.  C ++ 11 hat dieser Liste einen Verschiebungskonstruktor und einen Verschiebungszuweisungsoperator hinzugefügt.  Diese Elementfunktionen werden als spezielle Elementfunktionen bezeichnet.  Sie werden nur generiert, wenn sie verwendet werden, und zusätzliche Bedingungen, die für jede Funktion spezifisch sind, sind erfüllt.  Wir machen darauf aufmerksam, dass sich diese Verwendung als ziemlich versteckt herausstellen kann (zum Beispiel bei der Implementierung der Vererbung).  Wenn die erforderliche Funktion nicht generiert werden kann, wird ein Fehler generiert.  (Mit Ausnahme von Verschiebungsvorgängen werden sie durch Kopiervorgänge ersetzt.) Die vom Compiler generierten Elementfunktionen sind öffentlich und können eingebettet werden.  Details zu speziellen Mitgliedsfunktionen finden Sie in [Meyers2]. </p><br><p>  In einigen Fällen kann eine solche Hilfe des Compilers ein „Bärendienst“ sein.  Das Fehlen benutzerdefinierter spezieller Elementfunktionen kann zur Erstellung eines trivialen Typs führen, was wiederum das Problem nicht initialisierter Variablen verursacht (siehe Abschnitt 3.2).  Die generierten Elementfunktionen sind öffentlich und dies stimmt nicht immer mit dem Design der Klassen überein.  In den Basisklassen muss der Konstruktor geschützt werden. Manchmal wird für eine genauere Kontrolle des Lebenszyklus des Objekts ein geschützter Destruktor benötigt.  Wenn eine Klasse einen Rohressourcendeskriptor als Mitglied hat und diese Ressource besitzt, muss der Programmierer einen Kopierkonstruktor, einen Kopierzuweisungsoperator und einen Destruktor implementieren.  Die sogenannte „Regel der großen Drei“ ist bekannt. Wenn ein Programmierer mindestens eine der drei Operationen definiert - Kopierkonstruktor, Kopierzuweisungsoperator oder Destruktor -, muss er alle drei Operationen definieren.  Der Verschiebungskonstruktor und der vom Compiler generierte Verschiebungszuweisungsoperator sind bei weitem nicht immer das, was Sie benötigen.  Der vom Compiler generierte Destruktor führt in einigen Fällen zu sehr subtilen Problemen, die zu einem Ressourcenleck führen können (siehe Abschnitt 3.7). </p><br><p>  Der Programmierer kann die Generierung spezieller Elementfunktionen verbieten. In C ++ 11 muss beim Deklarieren das Konstrukt <code>"=delete"</code> verwendet werden. In C ++ 98 muss die entsprechende Elementfunktion als privat deklariert und nicht definiert werden. </p><br><p>  Wenn der Programmierer mit den vom Compiler generierten Elementfunktionen vertraut ist, kann er dies in C ++ 11 explizit angeben und nicht nur die Deklaration löschen.  Dazu müssen Sie beim Deklarieren das Konstrukt <code>"=default"</code> verwenden, während der Code besser gelesen wird und zusätzliche Funktionen im Zusammenhang mit der Verwaltung der Zugriffsebene <code>"=default"</code> werden. </p><br><p>  In C # kann der Compiler einen Standardkonstruktor generieren. Dies verursacht normalerweise keine Probleme. </p><br><p>  Wie man kämpft: </p><br><ul><li>  Steuern Sie den Compiler, der spezielle Elementfunktionen generiert.  Implementieren Sie sie gegebenenfalls selbst oder verbieten Sie sie. </li></ul><br><a name="id-3-2"></a><br><h2>  3.2.  Nicht initialisierte Variablen </h2><br><p>  Konstruktoren und Destruktoren können als Schlüsselelemente des C ++ - Objektmodells bezeichnet werden.  Beim Erstellen eines Objekts muss der Konstruktor aufgerufen werden, und beim Löschen wird der Destruktor aufgerufen.  Kompatibilitätsprobleme mit C haben jedoch einige Ausnahmen erzwungen, und diese Ausnahme wird als triviale Typen bezeichnet.  Sie werden eingeführt, um sichny-Typen und den systemischen Lebenszyklus von Variablen ohne den obligatorischen Aufruf des Konstruktors und Destruktors zu simulieren.  Wenn C-Code in C ++ kompiliert und ausgeführt wird, sollte er genau wie in C funktionieren. Zu den Trivialtypen gehören numerische Typen, Zeiger, Aufzählungen sowie Klassen, Strukturen, Vereinigungen und Arrays, die aus Trivialtypen bestehen.  Klassen und Strukturen müssen einige zusätzliche Bedingungen erfüllen: das Fehlen eines benutzerdefinierten Konstruktors, Destruktors, Kopierers und virtueller Funktionen.  Für eine triviale Klasse kann der Compiler einen Standardkonstruktor und einen Destruktor generieren.  Der Standardkonstruktor setzt das Objekt auf Null, der Destruktor tut nichts.  Dieser Konstruktor wird jedoch nur generiert und verwendet, wenn er bei der Initialisierung der Variablen explizit aufgerufen wird.  Eine Variable eines trivialen Typs wird nicht initialisiert, wenn Sie keine Variante der expliziten Initialisierung verwenden.  Die Initialisierungssyntax hängt vom Typ und Kontext der Variablendeklaration ab.  Statische und lokale Variablen werden beim Deklarieren initialisiert.  Für eine Klasse werden unmittelbare Basisklassen und nicht statische Klassenmitglieder in der Konstruktorinitialisierungsliste initialisiert.  (Mit C ++ 11 können Sie nicht statische Klassenmitglieder beim Deklarieren initialisieren (siehe später).) Bei dynamischen Objekten erstellt der Ausdruck <code>new T()</code> ein vom Standardkonstruktor initialisiertes Objekt, bei trivialem Typ jedoch ein <code>new T</code> für nicht initialisierte Objekte.  Wenn Sie ein dynamisches Array eines trivialen Typs, <code>new T[N]</code> , erstellen, werden seine Elemente immer nicht initialisiert.  Wenn eine Instanz von <code>std::vector&lt;T&gt;</code> erstellt oder erweitert wird und keine Parameter für die explizite Initialisierung von Elementen bereitgestellt werden, wird garantiert, dass sie den Standardkonstruktor aufrufen.  C ++ 11 führt eine neue Initialisierungssyntax ein - mit geschweiften Klammern.  Ein leeres Klammerpaar bedeutet die Initialisierung mit dem Standardkonstruktor.  Eine solche Initialisierung ist überall dort möglich, wo die traditionelle Initialisierung verwendet wird. Außerdem wurde es möglich, nicht statische Mitglieder der Klasse beim Deklarieren zu initialisieren, was die Initialisierung in der Konstruktorinitialisierungsliste ersetzt. </p><br><p>  Eine nicht initialisierte Variable ist wie folgt strukturiert: Wenn sie im <code>namespace</code> Bereich (global) definiert ist, hat sie alle Bits Null. Wenn sie lokal oder dynamisch erstellt wird, erhält sie einen zufälligen Satz von Bits.  Es ist klar, dass die Verwendung einer solchen Variablen zu einem unvorhersehbaren Verhalten des Programms führen kann. </p><br><p>  Zwar steht der Fortschritt nicht still, moderne Compiler erkennen in einigen Fällen nicht initialisierte Variablen und werfen einen Fehler aus.  Nicht initialisierte Codeanalysatoren erkennen noch besser. </p><br><p>  Die C ++ 11-Standardbibliothek verfügt über Vorlagen, die als <code>&lt;type_traits&gt;</code> (Header-Datei <code>&lt;type_traits&gt;</code> ).  Mit einer davon können Sie feststellen, ob der Typ trivial ist.  Der Ausdruck <code>std::is_trivial&lt;&gt;::value</code> ist <code>true</code> wenn <code>T</code> trivialer Typ ist, andernfalls <code>false</code> . </p><br><p>  Sysylische Strukturen werden oft auch als Plain Old Data (POD) bezeichnet.  Wir können davon ausgehen, dass POD und der „triviale Typ“ fast gleichwertige Begriffe sind. </p><br><p>  In C # verursachen nicht initialisierte Variablen einen Fehler, der vom Compiler gesteuert wird.  Felder von Objekten eines Referenztyps werden standardmäßig initialisiert, wenn keine explizite Initialisierung durchgeführt wird.  Felder von Objekten eines signifikanten Typs werden entweder standardmäßig alle initialisiert oder alle müssen explizit initialisiert werden. </p><br><p>  Wie man kämpft: </p><br><ul><li>  Haben Sie die Angewohnheit, eine Variable explizit zu initialisieren.  Eine nicht initialisierte Variable sollte "das Auge schneiden". </li><li>  Deklarieren Sie Variablen im engsten Bereich. </li><li>  Verwenden Sie statische Code-Analysatoren. </li><li>  Entwerfen Sie keine trivialen Typen.  Um sicherzustellen, dass der Typ nicht trivial ist, reicht es aus, einen benutzerdefinierten Konstruktor zu definieren. </li></ul><br><a name="id-3-3"></a><br><h2>  3.3.  Initialisierungsverfahren für Basisklassen und nicht statische Klassenmitglieder </h2><br><p>  Bei der Implementierung des Klassenkonstruktors werden unmittelbare Basisklassen und nicht statische Klassenmitglieder initialisiert.  Die Initialisierungsreihenfolge wird durch den Standard bestimmt: Zuerst die Basisklassen in der Reihenfolge, in der sie in der Liste der Basisklassen deklariert sind, dann nicht statische Mitglieder der Klasse in der Deklarationsreihenfolge.  Bei Bedarf wird für die explizite Initialisierung von Basisklassen und nicht statischen Elementen die Konstruktorinitialisierungsliste verwendet.  Leider müssen die Elemente in dieser Liste nicht in der Reihenfolge sein, in der die Initialisierung erfolgt.  Dies muss berücksichtigt werden, wenn Listenelemente während der Initialisierung Verweise auf andere Listenelemente verwenden.  Bei einem Fehler kann die Verknüpfung zu einem Objekt bestehen, das noch nicht initialisiert wurde.  Mit C ++ 11 können Sie nicht statische Klassenmitglieder beim Deklarieren initialisieren (mit geschweiften Klammern).  In diesem Fall müssen sie nicht in der Konstruktorinitialisierungsliste initialisiert werden, und das Problem wird teilweise behoben. </p><br><p>  In C # wird ein Objekt wie folgt initialisiert: Zuerst werden die Felder vom Basis-Unterobjekt bis zur letzten Ableitung initialisiert, dann werden die Konstruktoren in derselben Reihenfolge aufgerufen.  Das beschriebene Problem tritt nicht auf. </p><br><p>  Wie man kämpft: </p><br><ul><li>  Pflegen Sie die Konstruktorinitialisierungsliste in Deklarationsreihenfolge. </li><li>  Versuchen Sie, die Initialisierung von Basisklassen und Klassenmitgliedern unabhängig zu machen. </li><li>  Verwenden Sie beim Deklarieren die Initialisierung nicht statischer Elemente. </li></ul><br><a name="id-3-4"></a><br><h2>  3.4.  Initialisierungsverfahren für statische Klassenmitglieder und globale Variablen </h2><br><p>  Statische Klassenmitglieder sowie Variablen, die im Bereichsnamespace (global) in verschiedenen Kompilierungseinheiten (Dateien) definiert sind, werden in der von der Implementierung festgelegten Reihenfolge initialisiert.  Dies sollte berücksichtigt werden, wenn solche Variablen während der Initialisierung Verweise aufeinander verwenden.  Die Verknüpfung kann zu einer nicht initialisierten Variablen bestehen. </p><br><p>  Wie man kämpft: </p><br><ul><li>  Treffen Sie besondere Maßnahmen, um diese Situation zu verhindern.  Verwenden Sie beispielsweise lokale statische Variablen (Singleton), die bei der ersten Verwendung initialisiert werden. </li></ul><br><a name="id-3-5"></a><br><h2>  3.5.  Ausnahmen bei Destruktoren </h2><br><p>  Der Destruktor sollte keine Ausnahmen auslösen.  Wenn Sie gegen diese Regel verstoßen, kann es zu undefiniertem Verhalten kommen, meistens zu abnormaler Beendigung. </p><br><p>  Wie man kämpft: </p><br><ul><li>  Vermeiden Sie es, Ausnahmen in den Destruktor zu werfen. </li></ul><br><a name="id-3-6"></a><br><h2>  3.6.  Dynamische Objekte und Arrays entfernen </h2><br><p>  Wenn ein dynamisches Objekt vom Typ <code>T</code> </p><br><pre> <code class="cpp hljs">T* pt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>);</code> </pre> <br><p>  dann wird es mit dem <code>delete</code> gelöscht </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pt;</code> </pre> <br><p>  Wenn ein dynamisches Array erstellt wird </p><br><pre> <code class="cpp hljs">T* pt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[N];</code> </pre> <br><p>  dann wird es mit dem Operator <code>delete[]</code> gelöscht </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] pt;</code> </pre> <br><p>  Wenn Sie diese Regel nicht befolgen, kann es zu undefiniertem Verhalten kommen, dh es kann alles passieren: ein Speicherverlust, ein Absturz usw.  Siehe [Meyers1] für Details. </p><br><p>  Wie man kämpft: </p><br><ul><li>  Verwenden Sie das richtige <code>delete</code> . </li></ul><br><a name="id-3-7"></a><br><h2>  3.7.  Löschen, wenn die Klassendeklaration unvollständig ist </h2><br><p>  Die Allesfresserhaftigkeit des <code>delete</code> kann bestimmte Probleme verursachen, sie kann auf einen Zeiger vom Typ <code>void*</code> oder auf einen Zeiger auf eine Klasse angewendet werden, die eine unvollständige (präemptive) Deklaration aufweist.  Der <code>delete</code> , der auf einen Zeiger auf eine Klasse angewendet wird, ist eine zweiphasige Operation: Zuerst wird der Destruktor aufgerufen, dann wird Speicher freigegeben.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Operator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf einen Zeiger auf eine Klasse mit einer unvollständigen Deklaration </font><font style="vertical-align: inherit;">angewendet wird </font><font style="vertical-align: inherit;">, tritt kein Fehler auf. Der Compiler überspringt einfach den Aufruf an den Destruktor (obwohl eine Warnung ausgegeben wird).</font></font> Betrachten Sie ein Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   X* CreateX(); void Foo() {    X* p = CreateX();    delete p; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Code wird auch dann kompiliert, wenn die </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vollständige Klassendeklaration </font><font style="vertical-align: inherit;">beim Dial-Peer </font><font style="vertical-align: inherit;">nicht verfügbar ist </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Visual Studio zeigt die folgende Warnung an:</font></font><br><p> <code>warning C4150: deletion of pointer to incomplete type 'X'; no destructor called</code> <br> </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es eine Implementierung gibt </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>CreateX()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Code kompiliert wird, wenn er </font></font><code>CreateX()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Zeiger auf ein vom Operator erstelltes Objekt zurückgibt </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der Aufruf </font></font><code>Foo()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfolgreich ausgeführt wird, wird der Destruktor nicht aufgerufen. </font><font style="vertical-align: inherit;">Es ist klar, dass dies zu einem Ressourcenverbrauch führen kann, also noch einmal über die Notwendigkeit, vorsichtig mit Warnungen umzugehen.</font></font></p><br><p>    ,           -.      ,  .       ,      ,   ,   ,   .        [Meyers2]. </p><br><p>  : </p><br><ul><li>   . </li><li>            . </li><li>     . </li></ul><br><a name="id-4"></a><br><h1> 4. ,  </h1><br><a name="id-4-1"></a><br><h2>  4.1.   </h2><br><p>   ++ ,     .      .       .   ,    1.1. </p><br><p>  Hier ist ein Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;c?x:y;</code> </pre> <br><p>        </p><br><pre> <code class="cpp hljs">(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;c)?x:y;</code> </pre> <br><p>   </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;(c?x:y);</code> </pre> <br><p> ,  ,  . </p><br><p>         .            <code>&lt;&lt;</code>      <code>?:</code>      <code>std::out</code>  <code>void*</code> .  ++            ,     . -,          ,    .    <code>?:</code>      .       ,     (  ). </p><br><p>   :  <code>x&amp;f==0</code>    <code>x&amp;(f==0)</code> ,   <code>(x&amp;f)==0</code> , ,  ,  .     -  , ,     ,         ,   . </p><br><p>  . /          .  /    ,  /,    . ,     <code>x/4+1</code>  <code>x&gt;&gt;2+1</code> ,   <code>x&gt;&gt;(2+1)</code> ,   <code>(x&gt;&gt;2)+1</code> ,  . </p><br><p> C#      ,   C++,      ,    -      . </p><br><p>  : </p><br><ul><li>   ,     . , ,    . </li></ul><br><a name="id-4-2"></a><br><h2>  4.2.   </h2><br><p> ++     ,      .        .        ,          , .  4.1.    —    <code>+</code>  <code>+=</code>   .     . ,   : <code>,</code> (), <code>&amp;&amp;</code> , <code>||</code>  .   ,         (-),            (short-circuit evaluation semantics),        ,        .      &amp; ( ).     &amp;    , ..       . </p><br><p>        ,  -    (-) ,  .      . </p><br><p>  -  ,    ,    .  . [Dewhurst]. </p><br><p> C#    ,     , ,   . </p><br><p>  : </p><br><ul><li>    . </li><li>       . </li></ul><br><a name="id-4-3"></a><br><h2>  4.3.    </h2><br><p>   ++           ,         . (   : <code>,</code> (), <code>&amp;&amp;</code> , <code>||</code> , <code>?:</code> .)     ,  ,   ,    .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y=(++x*<span class="hljs-number"><span class="hljs-number">2</span></span>)+(++x*<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  <code>y</code>     . </p><br><p>      ,        .  Hier ist ein Beispiel. </p><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Y</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;X&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Y&gt;)</span></span></span></span>;</code> </pre> <br><p>  <code>Foo()</code>   : </p><br><pre> <code class="cpp hljs">Foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X()), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Y&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Y()));</code> </pre> <br><p>     :  <code>X</code> ,  <code>Y</code> ,  <code>std::shared_ptr&lt;X&gt;</code> ,  <code>std::shared_ptr&lt;Y&gt;</code> .   <code>Y</code>  ,   <code>X</code>   . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X()); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Y&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Y()); Foo(p1, p2);</code> </pre> <br><p>     <code>std::make_shared&lt;Y&gt;</code> (    ,     ): </p><br><pre> <code class="cpp hljs">Foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;X&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Y&gt;());</code> </pre> <br><p>  . [Meyers2]. </p><br><p>  : </p><br><ul><li>    . </li></ul><br><a name="id-5"></a><br><h1> 5.   </h1><br><a name="id-5-1"></a><br><h2>  5.1.    </h2><br><p>  ++98  ,           ( ), ,     (     ,    ).      <code>virtual</code> ,   ,    .   ( ),   ,   ,     . ,     ,  .  ,  ++11    <code>override</code> ,    ,    ,       .          . </p><br><p>  : </p><br><ul><li>    <code>override</code> . </li><li>    .    ,         . </li></ul><br><a name="id-5-2"></a><br><h2>  5.2.       </h2><br><p>            .   ,              ,     .               .    . [Dewhurst]. </p><br><p>  : </p><br><ul><li>           . </li></ul><br><a name="id-5-3"></a><br><h2>  5.3.        </h2><br><p> ,     ,          . , ,     post_construct  pre_destroy. ,      —         .    .   ,        :     ( )   . (, ,      .)     ,           ( ),    ( ).  . [Dewhurst]. ,         ,  . </p><br><p>       —  -         . </p><br><p> ,   C#  ,     ,   ,     .  C#    :   ,      ,       .  ,           ( ,    ). </p><br><p>  : </p><br><ul><li>        ,     ,   . </li></ul><br><a name="id-5-4"></a><br><h2>  5.4.   </h2><br><p>     ,        ,           <code>delete</code>     .          , -    . </p><br><p>  : </p><br><ul><li>     . </li></ul><br><a name="id-6"></a><br><h1> 6.     </h1><br><p>        —      C/C++,        .           .        .     «  ». </p><br><p>  C#        unsafe mode,    . </p><br><a name="id-6-1"></a><br><h2>  6.1.     </h2><br><p>    /++  ,        : <code>strcpy()</code> , <code>strcat()</code> , <code>sprinf()</code> , etc.    ( <code>std::vector&lt;&gt;</code> , etc.)         ,    . (,         ,         ,     . . <strong>Checked Iterators</strong>  MSDN.)      ,      :   ,      ,     ;     ,      . </p><br><p>  C#,   unsafe mode,      . </p><br><p>  : </p><br><ul><li>    , . </li><li>     . </li><li>   z-terminated   ,    <code>_s</code> (.   ). </li></ul><br><a name="id-6-2"></a><br><h2>  6.2. Z-terminated  </h2><br><p>       ,  .    ,  : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">strncpy</span></span>(dst,src,n);</code> </pre> <br><p>  <code>strlen(src)&gt;=n</code> ,  <code>dst</code>     (,      ).      ,       , .  .       —       .   <code>if(*str)</code> ,  <code>if(strlen(str)&gt;0)</code> ,           .         [Spolsky]. </p><br><p>  C#  <code>string</code>      . </p><br><p>  : </p><br><ul><li>    . </li><li>     z-terminated   ,    <code>_s</code> (.   ). </li></ul><br><a name="id-6-3"></a><br><h2>  6.3.      </h2><br><p>    <code>...</code>    .      <code>printf</code> - ,     C.          , ,  ,     ,      .         ,       . </p><br><p>  C#    <code>printf</code> ,     . </p><br><p>  : </p><br><ul><li>     . ,  <code>printf</code> -    /. </li><li>   . </li></ul><br><a name="id-7"></a><br><h1> 7.  </h1><br><a name="id-7-1"></a><br><h2>  7.1.   </h2><br><p>  ++     , ,   ,        .  Hier ist ein Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N = <span class="hljs-number"><span class="hljs-number">4</span></span>, M = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x,                <span class="hljs-comment"><span class="hljs-comment">// 1    *px,              // 2    ax[N],            // 3    *apx[N],          // 4    F(char),          // 5    *G(char),          // 6    (*pF)(char),      // 7    (*apF[N])(char),  // 8    (*pax)[N],        // 9    (*apax[M])[N],    // 10    (*H(char))(long);  // 11</span></span></code> </pre> <br><p>        : </p><br><ol><li>   <code>int</code> ; </li><li>   <code>int</code> ; </li><li>   <code>N</code>   <code>int</code> ; </li><li>   <code>N</code>     <code>int</code> ; </li><li> ,  <code>char</code>   <code>int</code> ; </li><li> ,  <code>char</code>     <code>int</code> ; </li><li>   ,  <code>char</code>   <code>int</code> ; </li><li>   <code>N</code>     ,  <code>char</code>   <code>int</code> ; </li><li>     <code>N</code>   <code>int</code> ; </li><li>   <code>M</code>       <code>N</code>   <code>int</code> ; </li><li> ,  <code>char</code>     ,  <code>long</code>   <code>int</code> . </li></ol><br><p> ,             . (     .) </p><br><p>     <code>*</code>    <code>&amp;</code>     . (    .) </p><br><p>        <code>typedef</code> ( <code>using</code> -). ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*P)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; PH(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>);</code> </pre> <br><p>      ,     . </p><br><p>  C#    ,    . </p><br><p>  : </p><br><ul><li>   . </li></ul><br><a name="id-7-2"></a><br><h2>  7.2.   </h2><br><p>           .     </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>     </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><p>    <code>x</code>  <code>X</code> ,   5.    </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>    <code>x</code> ,    <code>X</code>    ,     <code>x</code>  <code>X</code> ,    .     <code>X</code> ,    ,     : </p><br><pre> <code class="cpp hljs">X x; X x = X(); X x{};    <span class="hljs-comment"><span class="hljs-comment">//   C++11</span></span></code> </pre> <br><p>   ,    ,          ,   .         [Sutter]. </p><br><p>  ,  ,   C++     (      ).         . (    C++  .) </p><br><p>  , ,      ,       ,         . </p><br><p>  C#   ,         ,      . </p><br><p>  : </p><br><ul><li>    . </li></ul><br><a name="id-8"></a><br><h1> 8.  </h1><br><a name="id-8-1"></a><br><h2> 8.1.   <code>inline</code>  ODR </h2><br><p>   ,    <code>inline</code> —             .  ,     .   <code>inline</code>          (One Defenition Rule, ODR).  .            ,   .          ,  ODR.       <code>static</code> :    ,       ,   .   <code>static</code>  <code>inline</code> .      ,        ,  ODR,     . ,       .   - ,          -.         . </p><br><p>  : </p><br><ul><li>  «» <code>inline</code> .          <code>namespace</code> .      ,     . </li><li>        —  <code>namespace</code> . </li></ul><br><a name="id-8-2"></a><br><h2> 8.2.   </h2><br><p>        .        .    ,    ,     ,   ,      . </p><br><p>  : </p><br><ul><li>     ,     . </li><li>  ,     :  () ,    -. </li><li>            <code>using</code> -: <code>using namespace <i></i></code> ,   <code>using</code> -. </li><li>           . </li></ul><br><a name="id-8-3"></a><br><h2> 8.3.  <code>switch</code> <br></h2><br><p>   —  <code>break</code>    <code>case</code> . (  .)  C#     . </p><br><p>  : </p><br><ul><li>   . </li></ul><br><a name="id-8-4"></a><br><h2> 8.4.     </h2><br><p>  ++    ,      —     , —       .    (  <code>class</code>  <code>struct</code> )    ,         . (      ,      #  Java.)    —   ,     . </p><br><ol><li>      ,   .           (  <code>std::string</code> , <code>std::vector</code> , etc.),    ,           . </li><li>    ,        ,     . </li><li>          ,      (slicing),      ,       . </li></ol><br><p>     ,      ,  ,     .      . ,       ,         . ,          .           .    —     ( <code>=delete</code> ),   —     <code>explicit</code> . </p><br><p>  C#      ,           . </p><br><p>  : </p><br><ul><li>   ,     . </li><li>       . </li></ul><br><a name="id-8-5"></a><br><h2> 8.5.  Ressourcenmanagement </h2><br><p>  ++         .     ,     . -       (    ),   ++11   ,        ,   ,           . </p><br><p>      C++   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br><p>  C#   ,       .        ,     .        (using-)      Basic Dispose. </p><br><p>  : </p><br><ul><li>  -       . </li></ul><br><a name="id-8-6"></a><br><h2> 8.6.     </h2><br><p>     «»     .     ,  , C++ , STL-   - . </p><br><p>       .         .     ,        .      .        «»,      .          COM-      . (,    .)      ,    C++   .      —      .        .            .  ,      («»     )    ,      .        . </p><br><p>  #    ,     .     —    . </p><br><p>  : </p><br><ul><li>   . </li><li>        . </li></ul><br><a name="id-8-7"></a><br><h2> 8.7.   </h2><br><p>  C++      ,     :   ,    ,   . (     !)      .        ,      .     ,   .     ,   ,     . (,           .) </p><br><p>      C (    ),   C++       C  (   <code>extern "C"</code> ).      C/C++ . </p><br><p>          -.   <code>#pragma</code> -    ,    ,   . </p><br><p>        , ,    ,    . </p><br><p>     , ,    COM. COM-,    ,   (     ,      ).  COM     ,   ,     . </p><br><p>  C#     . ,   —    ,      C#,    C#  C/C++. </p><br><p>  : </p><br><ul><li>        . </li></ul><br><a name="id-8-8"></a><br><h2> 8.8.  </h2><br><p>        ,         .    ,       .  C++    .  Stattdessen </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> XXL 32</span></span></code> </pre> <br><p>   </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> XXL=<span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br><p>   .       <code>inline</code>   . </p><br><p>  #   (   ). </p><br><p>  : </p><br><ul><li>       . </li></ul><br><a name="id-conclusion"></a><br><h1> 9.  </h1><br><ol><li>      .       .   .      ,       . </li><li>    . </li><li>    .   ++      — ++11/14/17. </li><li>   - ,  -   . </li><li>        . </li></ol><br><a name="id-refs"></a><br><h1>  Referenzliste </h1><br><div class="spoiler">  <b class="spoiler_title">Liste</b> <div class="spoiler_text"><p> [Dewhurst] <br> ,  .   C++.         .: .  . — .:  , 2012. </p><br><p> [Meyers1] <br> , .   C++. 55        .: .  . — .:  , 2014. </p><br><p> [Meyers2] <br> , .    C++: 42    C++11  C++14.: .  . — .:  «.. », 2016. </p><br><p> [Sutter] <br> , .     C++.: .  . — :  «.. », 2015. </p><br><p> [Spolsky] <br> , .   .: .  . — .: -, 2008. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428898/">https://habr.com/ru/post/de428898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428888/index.html">qml: Kraft und Einfachheit</a></li>
<li><a href="../de428890/index.html">Die ganze Wahrheit über RTOS. Artikel Nr. 18. Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a></li>
<li><a href="../de428892/index.html">So erstellen Sie eine Spiel-KI: eine Anleitung für Anfänger</a></li>
<li><a href="../de428894/index.html">Mehrwertsteuer auf inländische Einkäufe</a></li>
<li><a href="../de428896/index.html">Neuronale Netze der Hentai-Zensur</a></li>
<li><a href="../de428900/index.html">Radroboter liefern Waren an Einwohner der USA und Großbritanniens</a></li>
<li><a href="../de428902/index.html">NFC Wireless Tags</a></li>
<li><a href="../de428904/index.html">Fintech Digest: Zentralbankrobotik, Ethereum 2.0, Kryptowährungskontrolle durch Rosfinmonitoring und Trends in Fintech</a></li>
<li><a href="../de428906/index.html">Erstellen von Puzzlespielen mit Puzzleskript</a></li>
<li><a href="../de428908/index.html">Frostpunk: Demontage der Mechanik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>