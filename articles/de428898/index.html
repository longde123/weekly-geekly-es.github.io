<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåê ü¶ì üßïüèº Problematische Aspekte der Programmierung in C ++ üîâ üåê ‚òùüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C ++ gibt es einige Funktionen, die als potenziell gef√§hrlich eingestuft werden k√∂nnen. Bei Fehlkalkulationen im Design oder ungenauer Codierung k√∂...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Problematische Aspekte der Programmierung in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428898/"><hr><p>  <i>In C ++ gibt es einige Funktionen, die als potenziell gef√§hrlich eingestuft werden k√∂nnen. Bei Fehlkalkulationen im Design oder ungenauer Codierung k√∂nnen sie leicht zu Fehlern f√ºhren.</i>  <i>Der Artikel enth√§lt eine Auswahl solcher Funktionen sowie Tipps zur Reduzierung ihrer negativen Auswirkungen.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Inhaltsverzeichnis </h1><br><div class="spoiler">  <b class="spoiler_title">Inhaltsverzeichnis</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. Typen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bedingte Anweisungen und Bediener</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implizite Konvertierungen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2. Namensaufl√∂sung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausblenden von Variablen in verschachtelten Bereichen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktions√ºberlastung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3. Konstruktoren, Destruktoren, Initialisierung, L√∂schung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vom Compiler generierte Klassenelementfunktionen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nicht initialisierte Variablen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Initialisierungsverfahren f√ºr Basisklassen und nicht statische Klassenmitglieder</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Initialisierungsverfahren f√ºr statische Klassenmitglieder und globale Variablen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausnahmen bei Destruktoren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dynamische Objekte und Arrays entfernen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">L√∂schen, wenn die Klassendeklaration unvollst√§ndig ist</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Operatoren, Ausdr√ºcke</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bedienerpriorit√§t</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bediener√ºberlastung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Verfahren zur Berechnung von Unterausdr√ºcken</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. Virtuelle Funktionen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.1 Virtuelle Funktionen √ºberschreiben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.2 √úberladen und Verwenden von Standardparametern</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.3 Aufruf virtueller Funktionen im Konstruktor und Destruktor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.4 Virtueller Destruktor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6. Direkte Arbeit mit dem Speicher</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.1 Puffer √ºberlaufen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2 Z-terminierte Zeichenfolgen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.3 Funktionen mit variabler Anzahl von Parametern</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7. Syntax</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7.1 Komplizierte Ank√ºndigungen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7.2 Mehrdeutigkeit der Syntax</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8. Verschiedenes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.1 Keyword Inline und ODR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.2 Header-Dateien</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.3 switch-Anweisung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.4 Parameter als Wert √ºbergeben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.5 Ressourcenverwaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.6 Links besitzen und nicht besitzen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.7 Bin√§re Kompatibilit√§t</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.8 Makros</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">9. Zusammenfassung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenzliste</a> <br></p><br></div></div><br><p>  <i>Praemonitus, Praemunitus.</i> <i><br></i>  <i>Vorgewarnt bedeutet bewaffnet.</i>  <i>(lat.)</i> <br></p><br><a name="id-introdaction"></a><br><h1>  Einf√ºhrung </h1><br><p>  In C ++ gibt es einige Funktionen, die als potenziell gef√§hrlich eingestuft werden k√∂nnen. Bei Fehlkalkulationen im Design oder ungenauer Codierung k√∂nnen sie leicht zu Fehlern f√ºhren.  Einige von ihnen k√∂nnen auf eine schwierige Kindheit zur√ºckgef√ºhrt werden, andere auf den veralteten C ++ 98-Standard, andere sind bereits mit den Funktionen des modernen C ++ verbunden.  Betrachten Sie die wichtigsten und versuchen Sie, Ratschl√§ge zu geben, wie Sie ihre negativen Auswirkungen verringern k√∂nnen. </p><br><a name="id-1"></a><br><h1>  1. Typen </h1><br><a name="id-1-1"></a><br><h2>  1.1.  Bedingte Anweisungen und Bediener </h2><br><p> Die Notwendigkeit der Kompatibilit√§t mit C f√ºhrt dazu, dass Sie in der Anweisung <code>if(...)</code> und dergleichen jeden numerischen Ausdruck oder Zeiger ersetzen k√∂nnen und nicht nur Ausdr√ºcke wie <code>bool</code> .  Das Problem wird durch die implizite Konvertierung von <code>bool</code> nach <code>int</code> in arithmetischen Ausdr√ºcken und die Priorit√§t einiger Operatoren versch√§rft.  Dies f√ºhrt beispielsweise zu folgenden Fehlern: </p><br><p>  <code>if(a=b)</code> wenn richtig <code>if(a==b)</code> , <br>  <code>if(a&lt;x&lt;b)</code> , wenn richtig <code>if(a&lt;x &amp;&amp; x&lt;b)</code> , <br>  <code>if(a&amp;x==0)</code> , wenn richtig <code>if((a&amp;x)==0)</code> , <br>  <code>if(Foo)</code> wenn richtig <code>if(Foo())</code> , <br>  <code>if(arr)</code> wenn richtig <code>if(arr[0])</code> , <br>  <code>if(strcmp(s,r))</code> wenn korrekt <code>if(strcmp(s,r)==0)</code> . </p><br><p>  Einige dieser Fehler verursachen eine Compiler-Warnung, jedoch keinen Fehler.  Manchmal k√∂nnen auch Code-Analysatoren helfen.  In C # sind solche Fehler fast unm√∂glich. <code>if(...)</code> und √§hnliche Anweisungen einen <code>bool</code> Typ erfordern, k√∂nnen Sie <code>bool</code> und numerische Typen nicht in arithmetischen Ausdr√ºcken mischen. </p><br><p>  Wie man k√§mpft: </p><br><ul><li>  Programm ohne Warnungen.  Leider hilft dies nicht immer, da einige der oben beschriebenen Fehler keine Warnungen enthalten. </li><li>  Verwenden Sie statische Code-Analysatoren. </li><li>  Altmodische Empfangstechnik: Wenn Sie mit einer Konstanten vergleichen, setzen Sie sie links, zum Beispiel <code>if(MAX_PATH==x)</code> .  Es sieht ziemlich Eigentumswohnung aus (und hat sogar seinen eigenen Namen - "Yoda Notation"), und hilft in einer kleinen Anzahl von F√§llen in Betracht gezogen. </li><li>  Verwenden Sie das <code>const</code> Qualifikationsmerkmal so weit wie m√∂glich.  Auch hier hilft es nicht immer. </li><li>  Gew√∂hnen Sie sich daran, die richtigen logischen Ausdr√ºcke zu schreiben: <code>if(x!=0)</code> anstelle von <code>if(x)</code> .  (Obwohl Sie hier in die Falle der Operatorpriorit√§ten geraten k√∂nnen, sehen Sie sich das dritte Beispiel an.) </li><li>  Seien Sie sehr aufmerksam. </li></ul><br><a name="id-1-2"></a><br><h2>  1.2.  Implizite Konvertierungen </h2><br><p>  C ++ bezieht sich auf stark typisierte Sprachen, aber implizite Typkonvertierungen werden h√§ufig verwendet, um Code k√ºrzer zu machen.  Diese impliziten Konvertierungen k√∂nnen in einigen F√§llen zu Fehlern f√ºhren. </p><br><p>  Die nervigsten impliziten Konvertierungen sind Konvertierungen eines numerischen Typs oder Zeigers auf <code>bool</code> und von <code>bool</code> nach <code>int</code> .  Es sind diese Transformationen (notwendig f√ºr die Kompatibilit√§t mit C), die die in Abschnitt 1.1 beschriebenen Probleme verursachen.  Implizite Konvertierungen, die m√∂glicherweise zu einem Verlust der Genauigkeit numerischer Daten f√ºhren (Verengung der Konvertierungen), z. B. von <code>double</code> nach <code>int</code> sind ebenfalls nicht immer angemessen.  In vielen F√§llen generiert der Compiler eine Warnung (insbesondere wenn die numerischen Daten m√∂glicherweise an Genauigkeit verlieren), eine Warnung ist jedoch kein Fehler.  In C # sind Konvertierungen zwischen numerischen Typen und <code>bool</code> verboten (auch explizit), und Konvertierungen, die m√∂glicherweise zu Genauigkeitsverlusten bei numerischen Daten f√ºhren, sind fast immer ein Fehler. </p><br><p>  Der Programmierer kann andere implizite Konvertierungen hinzuf√ºgen: (1) Definieren eines Konstruktors mit einem Parameter ohne das <code>explicit</code> Schl√ºsselwort;  (2) die Definition eines Typkonvertierungsoperators.  Diese Transformationen schlie√üen zus√§tzliche Sicherheitsl√ºcken, die auf starken Typisierungsprinzipien beruhen. </p><br><p>  In C # ist die Anzahl der integrierten impliziten Konvertierungen viel geringer. Benutzerdefinierte implizite Konvertierungen m√ºssen mit dem <code>implicit</code> Schl√ºsselwort deklariert werden. </p><br><p>  Wie man k√§mpft: </p><br><ul><li>  Programm ohne Warnungen. </li><li>  Seien Sie sehr vorsichtig mit den oben beschriebenen Designs, verwenden Sie sie nicht ohne extreme Notwendigkeit. </li></ul><br><a name="id-2"></a><br><h1>  2. Namensaufl√∂sung </h1><br><a name="id-2-1"></a><br><h2>  2.1.  Ausblenden von Variablen in verschachtelten Bereichen </h2><br><p>  In C ++ gilt die folgende Regel.  Lass </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    int x;    // ... //  ,       {        int x;        // ...    } }</span></span></code> </pre> <br><p>  Gem√§√ü den C ++ - Regeln verbirgt die in <code></code> deklarierte Variable <code></code> die in <code></code> deklarierte Variable <code></code> <code></code>  Die erste Deklaration <code>x</code> muss sich nicht in einem Block befinden: Sie kann Mitglied einer Klasse oder einer globalen Variablen sein, sie muss nur in Block <code></code> sichtbar sein <code></code> </p><br><p>  Stellen Sie sich jetzt die Situation vor, in der Sie den folgenden Code umgestalten m√ºssen </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    int x;    // ... //  ,       {    // -         } }</span></span></code> </pre> <br><p>  Aus Versehen werden √Ñnderungen vorgenommen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    //  , :    int x;    // -         // ...    //  :    // -      }</span></span></code> </pre> <br><p>  Und jetzt macht der Code "etwas wird mit <code></code> von <code></code> " etwas mit <code></code> von <code></code> !  Es ist klar, dass nicht alles wie zuvor funktioniert und es oft sehr schwierig ist, das zu finden.  Es ist nicht umsonst, dass es in C # verboten ist, lokale Variablen auszublenden (obwohl Klassenmitglieder dies k√∂nnen).  Beachten Sie, dass der Mechanismus zum Ausblenden von Variablen in der einen oder anderen Form in fast allen Programmiersprachen verwendet wird. </p><br><p>  Wie man k√§mpft: </p><br><ul><li>  Deklarieren Sie Variablen im engsten Bereich. </li><li>  Schreiben Sie keine langen und tief verschachtelten Bl√∂cke. </li><li>  Verwenden Sie Codierungskonventionen, um Kennungen mit unterschiedlichem G√ºltigkeitsbereich visuell zu unterscheiden. </li><li>  Seien Sie sehr aufmerksam. </li></ul><br><a name="id-2-2"></a><br><h2>  2.2.  Funktions√ºberlastung </h2><br><p>  Das √úberladen von Funktionen ist ein wesentliches Merkmal vieler Programmiersprachen, und C ++ ist keine Ausnahme.  Diese Gelegenheit muss jedoch sorgf√§ltig genutzt werden, da Sie sonst in Schwierigkeiten geraten k√∂nnen.  In einigen F√§llen, zum Beispiel wenn der Konstruktor √ºberladen ist, hat der Programmierer keine Wahl, aber in anderen F√§llen kann die Verweigerung der √úberladung gerechtfertigt sein.  Ber√ºcksichtigen Sie die Probleme, die bei der Verwendung √ºberladener Funktionen auftreten. </p><br><p>  Wenn Sie versuchen, alle m√∂glichen Optionen zu ber√ºcksichtigen, die sich beim Aufl√∂sen einer √úberlastung ergeben k√∂nnen, sind die Regeln zum Aufl√∂sen einer √úberlastung sehr kompliziert und daher schwer vorherzusagen.  Zus√§tzliche Komplexit√§t wird durch Vorlagenfunktionen und das √úberladen integrierter Operatoren verursacht.  C ++ 11 f√ºgte Probleme mit rvalue-Links und Initialisierungslisten hinzu. </p><br><p>  Der Suchalgorithmus kann Probleme f√ºr Kandidaten verursachen, um √úberlastungen in verschachtelten Sichtbarkeitsbereichen zu beheben.  Wenn der Compiler Kandidaten im aktuellen Bereich gefunden hat, wird die weitere Suche beendet.  Wenn die gefundenen Kandidaten nicht geeignet, widerspr√ºchlich, gel√∂scht oder unzug√§nglich sind, wird ein Fehler generiert, aber es wird keine weitere Suche versucht.  Und nur wenn sich im aktuellen Bereich keine Kandidaten befinden, wechselt die Suche zum n√§chsten, breiteren Bereich.  Der Mechanismus zum Ausblenden von Namen funktioniert fast genauso wie in Abschnitt 2.1, siehe [Dewhurst]. </p><br><p>  √úberladungsfunktionen k√∂nnen die Lesbarkeit des Codes beeintr√§chtigen, was zu Fehlern f√ºhren kann. </p><br><p>  Die Verwendung von Funktionen mit Standardparametern sieht aus wie die Verwendung √ºberladener Funktionen, obwohl nat√ºrlich weniger potenzielle Probleme auftreten.  Das Problem mit schlechter Lesbarkeit und m√∂glichen Fehlern bleibt jedoch bestehen. </p><br><p>  Mit √§u√üerster Vorsicht sollten √úberlast- und Standardparameter f√ºr virtuelle Funktionen verwendet werden, siehe Abschnitt 5.2. </p><br><p>  C # unterst√ºtzt auch das √úberladen von Funktionen, die Regeln zum Aufl√∂sen von √úberladungen unterscheiden sich jedoch geringf√ºgig. </p><br><p>  Wie man k√§mpft: </p><br><ul><li>  Missbrauche nicht die √úberladung von Funktionen und entwerfe keine Funktionen mit Standardparametern. </li><li>  Wenn Funktionen √ºberladen sind, verwenden Sie Signaturen, die beim Aufl√∂sen von √úberladungen nicht zweifelhaft sind. </li><li>  Deklarieren Sie nicht gleichnamige Funktionen im verschachtelten Bereich. </li><li>  Vergessen Sie nicht, dass der in C ++ 11 <code>=delete</code> Mechanismus der Remote-Funktionen ( <code>=delete</code> ) verwendet werden kann, um bestimmte √úberlastungsoptionen zu verbieten. </li></ul><br><a name="id-3"></a><br><h1>  3. Konstruktoren, Destruktoren, Initialisierung, L√∂schung </h1><br><a name="id-3-1"></a><br><h2>  3.1.  Vom Compiler generierte Klassenelementfunktionen </h2><br><p>  Wenn der Programmierer die Elementfunktionen der Klasse aus der folgenden Liste nicht definiert hat - Standardkonstruktor, Kopierkonstruktor, Kopierzuweisungsoperator, Destruktor -, kann der Compiler dies f√ºr ihn tun.  C ++ 11 hat dieser Liste einen Verschiebungskonstruktor und einen Verschiebungszuweisungsoperator hinzugef√ºgt.  Diese Elementfunktionen werden als spezielle Elementfunktionen bezeichnet.  Sie werden nur generiert, wenn sie verwendet werden, und zus√§tzliche Bedingungen, die f√ºr jede Funktion spezifisch sind, sind erf√ºllt.  Wir machen darauf aufmerksam, dass sich diese Verwendung als ziemlich versteckt herausstellen kann (zum Beispiel bei der Implementierung der Vererbung).  Wenn die erforderliche Funktion nicht generiert werden kann, wird ein Fehler generiert.  (Mit Ausnahme von Verschiebungsvorg√§ngen werden sie durch Kopiervorg√§nge ersetzt.) Die vom Compiler generierten Elementfunktionen sind √∂ffentlich und k√∂nnen eingebettet werden.  Details zu speziellen Mitgliedsfunktionen finden Sie in [Meyers2]. </p><br><p>  In einigen F√§llen kann eine solche Hilfe des Compilers ein ‚ÄûB√§rendienst‚Äú sein.  Das Fehlen benutzerdefinierter spezieller Elementfunktionen kann zur Erstellung eines trivialen Typs f√ºhren, was wiederum das Problem nicht initialisierter Variablen verursacht (siehe Abschnitt 3.2).  Die generierten Elementfunktionen sind √∂ffentlich und dies stimmt nicht immer mit dem Design der Klassen √ºberein.  In den Basisklassen muss der Konstruktor gesch√ºtzt werden. Manchmal wird f√ºr eine genauere Kontrolle des Lebenszyklus des Objekts ein gesch√ºtzter Destruktor ben√∂tigt.  Wenn eine Klasse einen Rohressourcendeskriptor als Mitglied hat und diese Ressource besitzt, muss der Programmierer einen Kopierkonstruktor, einen Kopierzuweisungsoperator und einen Destruktor implementieren.  Die sogenannte ‚ÄûRegel der gro√üen Drei‚Äú ist bekannt. Wenn ein Programmierer mindestens eine der drei Operationen definiert - Kopierkonstruktor, Kopierzuweisungsoperator oder Destruktor -, muss er alle drei Operationen definieren.  Der Verschiebungskonstruktor und der vom Compiler generierte Verschiebungszuweisungsoperator sind bei weitem nicht immer das, was Sie ben√∂tigen.  Der vom Compiler generierte Destruktor f√ºhrt in einigen F√§llen zu sehr subtilen Problemen, die zu einem Ressourcenleck f√ºhren k√∂nnen (siehe Abschnitt 3.7). </p><br><p>  Der Programmierer kann die Generierung spezieller Elementfunktionen verbieten. In C ++ 11 muss beim Deklarieren das Konstrukt <code>"=delete"</code> verwendet werden. In C ++ 98 muss die entsprechende Elementfunktion als privat deklariert und nicht definiert werden. </p><br><p>  Wenn der Programmierer mit den vom Compiler generierten Elementfunktionen vertraut ist, kann er dies in C ++ 11 explizit angeben und nicht nur die Deklaration l√∂schen.  Dazu m√ºssen Sie beim Deklarieren das Konstrukt <code>"=default"</code> verwenden, w√§hrend der Code besser gelesen wird und zus√§tzliche Funktionen im Zusammenhang mit der Verwaltung der Zugriffsebene <code>"=default"</code> werden. </p><br><p>  In C # kann der Compiler einen Standardkonstruktor generieren. Dies verursacht normalerweise keine Probleme. </p><br><p>  Wie man k√§mpft: </p><br><ul><li>  Steuern Sie den Compiler, der spezielle Elementfunktionen generiert.  Implementieren Sie sie gegebenenfalls selbst oder verbieten Sie sie. </li></ul><br><a name="id-3-2"></a><br><h2>  3.2.  Nicht initialisierte Variablen </h2><br><p>  Konstruktoren und Destruktoren k√∂nnen als Schl√ºsselelemente des C ++ - Objektmodells bezeichnet werden.  Beim Erstellen eines Objekts muss der Konstruktor aufgerufen werden, und beim L√∂schen wird der Destruktor aufgerufen.  Kompatibilit√§tsprobleme mit C haben jedoch einige Ausnahmen erzwungen, und diese Ausnahme wird als triviale Typen bezeichnet.  Sie werden eingef√ºhrt, um sichny-Typen und den systemischen Lebenszyklus von Variablen ohne den obligatorischen Aufruf des Konstruktors und Destruktors zu simulieren.  Wenn C-Code in C ++ kompiliert und ausgef√ºhrt wird, sollte er genau wie in C funktionieren. Zu den Trivialtypen geh√∂ren numerische Typen, Zeiger, Aufz√§hlungen sowie Klassen, Strukturen, Vereinigungen und Arrays, die aus Trivialtypen bestehen.  Klassen und Strukturen m√ºssen einige zus√§tzliche Bedingungen erf√ºllen: das Fehlen eines benutzerdefinierten Konstruktors, Destruktors, Kopierers und virtueller Funktionen.  F√ºr eine triviale Klasse kann der Compiler einen Standardkonstruktor und einen Destruktor generieren.  Der Standardkonstruktor setzt das Objekt auf Null, der Destruktor tut nichts.  Dieser Konstruktor wird jedoch nur generiert und verwendet, wenn er bei der Initialisierung der Variablen explizit aufgerufen wird.  Eine Variable eines trivialen Typs wird nicht initialisiert, wenn Sie keine Variante der expliziten Initialisierung verwenden.  Die Initialisierungssyntax h√§ngt vom Typ und Kontext der Variablendeklaration ab.  Statische und lokale Variablen werden beim Deklarieren initialisiert.  F√ºr eine Klasse werden unmittelbare Basisklassen und nicht statische Klassenmitglieder in der Konstruktorinitialisierungsliste initialisiert.  (Mit C ++ 11 k√∂nnen Sie nicht statische Klassenmitglieder beim Deklarieren initialisieren (siehe sp√§ter).) Bei dynamischen Objekten erstellt der Ausdruck <code>new T()</code> ein vom Standardkonstruktor initialisiertes Objekt, bei trivialem Typ jedoch ein <code>new T</code> f√ºr nicht initialisierte Objekte.  Wenn Sie ein dynamisches Array eines trivialen Typs, <code>new T[N]</code> , erstellen, werden seine Elemente immer nicht initialisiert.  Wenn eine Instanz von <code>std::vector&lt;T&gt;</code> erstellt oder erweitert wird und keine Parameter f√ºr die explizite Initialisierung von Elementen bereitgestellt werden, wird garantiert, dass sie den Standardkonstruktor aufrufen.  C ++ 11 f√ºhrt eine neue Initialisierungssyntax ein - mit geschweiften Klammern.  Ein leeres Klammerpaar bedeutet die Initialisierung mit dem Standardkonstruktor.  Eine solche Initialisierung ist √ºberall dort m√∂glich, wo die traditionelle Initialisierung verwendet wird. Au√üerdem wurde es m√∂glich, nicht statische Mitglieder der Klasse beim Deklarieren zu initialisieren, was die Initialisierung in der Konstruktorinitialisierungsliste ersetzt. </p><br><p>  Eine nicht initialisierte Variable ist wie folgt strukturiert: Wenn sie im <code>namespace</code> Bereich (global) definiert ist, hat sie alle Bits Null. Wenn sie lokal oder dynamisch erstellt wird, erh√§lt sie einen zuf√§lligen Satz von Bits.  Es ist klar, dass die Verwendung einer solchen Variablen zu einem unvorhersehbaren Verhalten des Programms f√ºhren kann. </p><br><p>  Zwar steht der Fortschritt nicht still, moderne Compiler erkennen in einigen F√§llen nicht initialisierte Variablen und werfen einen Fehler aus.  Nicht initialisierte Codeanalysatoren erkennen noch besser. </p><br><p>  Die C ++ 11-Standardbibliothek verf√ºgt √ºber Vorlagen, die als <code>&lt;type_traits&gt;</code> (Header-Datei <code>&lt;type_traits&gt;</code> ).  Mit einer davon k√∂nnen Sie feststellen, ob der Typ trivial ist.  Der Ausdruck <code>std::is_trivial&lt;&gt;::value</code> ist <code>true</code> wenn <code>T</code> trivialer Typ ist, andernfalls <code>false</code> . </p><br><p>  Sysylische Strukturen werden oft auch als Plain Old Data (POD) bezeichnet.  Wir k√∂nnen davon ausgehen, dass POD und der ‚Äûtriviale Typ‚Äú fast gleichwertige Begriffe sind. </p><br><p>  In C # verursachen nicht initialisierte Variablen einen Fehler, der vom Compiler gesteuert wird.  Felder von Objekten eines Referenztyps werden standardm√§√üig initialisiert, wenn keine explizite Initialisierung durchgef√ºhrt wird.  Felder von Objekten eines signifikanten Typs werden entweder standardm√§√üig alle initialisiert oder alle m√ºssen explizit initialisiert werden. </p><br><p>  Wie man k√§mpft: </p><br><ul><li>  Haben Sie die Angewohnheit, eine Variable explizit zu initialisieren.  Eine nicht initialisierte Variable sollte "das Auge schneiden". </li><li>  Deklarieren Sie Variablen im engsten Bereich. </li><li>  Verwenden Sie statische Code-Analysatoren. </li><li>  Entwerfen Sie keine trivialen Typen.  Um sicherzustellen, dass der Typ nicht trivial ist, reicht es aus, einen benutzerdefinierten Konstruktor zu definieren. </li></ul><br><a name="id-3-3"></a><br><h2>  3.3.  Initialisierungsverfahren f√ºr Basisklassen und nicht statische Klassenmitglieder </h2><br><p>  Bei der Implementierung des Klassenkonstruktors werden unmittelbare Basisklassen und nicht statische Klassenmitglieder initialisiert.  Die Initialisierungsreihenfolge wird durch den Standard bestimmt: Zuerst die Basisklassen in der Reihenfolge, in der sie in der Liste der Basisklassen deklariert sind, dann nicht statische Mitglieder der Klasse in der Deklarationsreihenfolge.  Bei Bedarf wird f√ºr die explizite Initialisierung von Basisklassen und nicht statischen Elementen die Konstruktorinitialisierungsliste verwendet.  Leider m√ºssen die Elemente in dieser Liste nicht in der Reihenfolge sein, in der die Initialisierung erfolgt.  Dies muss ber√ºcksichtigt werden, wenn Listenelemente w√§hrend der Initialisierung Verweise auf andere Listenelemente verwenden.  Bei einem Fehler kann die Verkn√ºpfung zu einem Objekt bestehen, das noch nicht initialisiert wurde.  Mit C ++ 11 k√∂nnen Sie nicht statische Klassenmitglieder beim Deklarieren initialisieren (mit geschweiften Klammern).  In diesem Fall m√ºssen sie nicht in der Konstruktorinitialisierungsliste initialisiert werden, und das Problem wird teilweise behoben. </p><br><p>  In C # wird ein Objekt wie folgt initialisiert: Zuerst werden die Felder vom Basis-Unterobjekt bis zur letzten Ableitung initialisiert, dann werden die Konstruktoren in derselben Reihenfolge aufgerufen.  Das beschriebene Problem tritt nicht auf. </p><br><p>  Wie man k√§mpft: </p><br><ul><li>  Pflegen Sie die Konstruktorinitialisierungsliste in Deklarationsreihenfolge. </li><li>  Versuchen Sie, die Initialisierung von Basisklassen und Klassenmitgliedern unabh√§ngig zu machen. </li><li>  Verwenden Sie beim Deklarieren die Initialisierung nicht statischer Elemente. </li></ul><br><a name="id-3-4"></a><br><h2>  3.4.  Initialisierungsverfahren f√ºr statische Klassenmitglieder und globale Variablen </h2><br><p>  Statische Klassenmitglieder sowie Variablen, die im Bereichsnamespace (global) in verschiedenen Kompilierungseinheiten (Dateien) definiert sind, werden in der von der Implementierung festgelegten Reihenfolge initialisiert.  Dies sollte ber√ºcksichtigt werden, wenn solche Variablen w√§hrend der Initialisierung Verweise aufeinander verwenden.  Die Verkn√ºpfung kann zu einer nicht initialisierten Variablen bestehen. </p><br><p>  Wie man k√§mpft: </p><br><ul><li>  Treffen Sie besondere Ma√ünahmen, um diese Situation zu verhindern.  Verwenden Sie beispielsweise lokale statische Variablen (Singleton), die bei der ersten Verwendung initialisiert werden. </li></ul><br><a name="id-3-5"></a><br><h2>  3.5.  Ausnahmen bei Destruktoren </h2><br><p>  Der Destruktor sollte keine Ausnahmen ausl√∂sen.  Wenn Sie gegen diese Regel versto√üen, kann es zu undefiniertem Verhalten kommen, meistens zu abnormaler Beendigung. </p><br><p>  Wie man k√§mpft: </p><br><ul><li>  Vermeiden Sie es, Ausnahmen in den Destruktor zu werfen. </li></ul><br><a name="id-3-6"></a><br><h2>  3.6.  Dynamische Objekte und Arrays entfernen </h2><br><p>  Wenn ein dynamisches Objekt vom Typ <code>T</code> </p><br><pre> <code class="cpp hljs">T* pt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>);</code> </pre> <br><p>  dann wird es mit dem <code>delete</code> gel√∂scht </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pt;</code> </pre> <br><p>  Wenn ein dynamisches Array erstellt wird </p><br><pre> <code class="cpp hljs">T* pt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[N];</code> </pre> <br><p>  dann wird es mit dem Operator <code>delete[]</code> gel√∂scht </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] pt;</code> </pre> <br><p>  Wenn Sie diese Regel nicht befolgen, kann es zu undefiniertem Verhalten kommen, dh es kann alles passieren: ein Speicherverlust, ein Absturz usw.  Siehe [Meyers1] f√ºr Details. </p><br><p>  Wie man k√§mpft: </p><br><ul><li>  Verwenden Sie das richtige <code>delete</code> . </li></ul><br><a name="id-3-7"></a><br><h2>  3.7.  L√∂schen, wenn die Klassendeklaration unvollst√§ndig ist </h2><br><p>  Die Allesfresserhaftigkeit des <code>delete</code> kann bestimmte Probleme verursachen, sie kann auf einen Zeiger vom Typ <code>void*</code> oder auf einen Zeiger auf eine Klasse angewendet werden, die eine unvollst√§ndige (pr√§emptive) Deklaration aufweist.  Der <code>delete</code> , der auf einen Zeiger auf eine Klasse angewendet wird, ist eine zweiphasige Operation: Zuerst wird der Destruktor aufgerufen, dann wird Speicher freigegeben.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Operator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf einen Zeiger auf eine Klasse mit einer unvollst√§ndigen Deklaration </font><font style="vertical-align: inherit;">angewendet wird </font><font style="vertical-align: inherit;">, tritt kein Fehler auf. Der Compiler √ºberspringt einfach den Aufruf an den Destruktor (obwohl eine Warnung ausgegeben wird).</font></font> Betrachten Sie ein Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   X* CreateX(); void Foo() {    X* p = CreateX();    delete p; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Code wird auch dann kompiliert, wenn die </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vollst√§ndige Klassendeklaration </font><font style="vertical-align: inherit;">beim Dial-Peer </font><font style="vertical-align: inherit;">nicht verf√ºgbar ist </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Visual Studio zeigt die folgende Warnung an:</font></font><br><p> <code>warning C4150: deletion of pointer to incomplete type 'X'; no destructor called</code> <br> </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es eine Implementierung gibt </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>CreateX()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Code kompiliert wird, wenn er </font></font><code>CreateX()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Zeiger auf ein vom Operator erstelltes Objekt zur√ºckgibt </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der Aufruf </font></font><code>Foo()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfolgreich ausgef√ºhrt wird, wird der Destruktor nicht aufgerufen. </font><font style="vertical-align: inherit;">Es ist klar, dass dies zu einem Ressourcenverbrauch f√ºhren kann, also noch einmal √ºber die Notwendigkeit, vorsichtig mit Warnungen umzugehen.</font></font></p><br><p>    ,           -.      ,  .       ,      ,   ,   ,   .        [Meyers2]. </p><br><p>  : </p><br><ul><li>   . </li><li>            . </li><li>     . </li></ul><br><a name="id-4"></a><br><h1> 4. ,  </h1><br><a name="id-4-1"></a><br><h2>  4.1.   </h2><br><p>   ++ ,     .      .       .   ,    1.1. </p><br><p>  Hier ist ein Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;c?x:y;</code> </pre> <br><p>        </p><br><pre> <code class="cpp hljs">(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;c)?x:y;</code> </pre> <br><p>   </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;(c?x:y);</code> </pre> <br><p> ,  ,  . </p><br><p>         .            <code>&lt;&lt;</code>      <code>?:</code>      <code>std::out</code>  <code>void*</code> .  ++            ,     . -,          ,    .    <code>?:</code>      .       ,     (  ). </p><br><p>   :  <code>x&amp;f==0</code>    <code>x&amp;(f==0)</code> ,   <code>(x&amp;f)==0</code> , ,  ,  .     -  , ,     ,         ,   . </p><br><p>  . /          .  /    ,  /,    . ,     <code>x/4+1</code>  <code>x&gt;&gt;2+1</code> ,   <code>x&gt;&gt;(2+1)</code> ,   <code>(x&gt;&gt;2)+1</code> ,  . </p><br><p> C#      ,   C++,      ,    -      . </p><br><p>  : </p><br><ul><li>   ,     . , ,    . </li></ul><br><a name="id-4-2"></a><br><h2>  4.2.   </h2><br><p> ++     ,      .        .        ,          , .  4.1.    ‚Äî    <code>+</code>  <code>+=</code>   .     . ,   : <code>,</code> (), <code>&amp;&amp;</code> , <code>||</code>  .   ,         (-),            (short-circuit evaluation semantics),        ,        .      &amp; ( ).     &amp;    , ..       . </p><br><p>        ,  -    (-) ,  .      . </p><br><p>  -  ,    ,    .  . [Dewhurst]. </p><br><p> C#    ,     , ,   . </p><br><p>  : </p><br><ul><li>    . </li><li>       . </li></ul><br><a name="id-4-3"></a><br><h2>  4.3.    </h2><br><p>   ++           ,         . (   : <code>,</code> (), <code>&amp;&amp;</code> , <code>||</code> , <code>?:</code> .)     ,  ,   ,    .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y=(++x*<span class="hljs-number"><span class="hljs-number">2</span></span>)+(++x*<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  <code>y</code>     . </p><br><p>      ,        .  Hier ist ein Beispiel. </p><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Y</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;X&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Y&gt;)</span></span></span></span>;</code> </pre> <br><p>  <code>Foo()</code>   : </p><br><pre> <code class="cpp hljs">Foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X()), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Y&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Y()));</code> </pre> <br><p>     :  <code>X</code> ,  <code>Y</code> ,  <code>std::shared_ptr&lt;X&gt;</code> ,  <code>std::shared_ptr&lt;Y&gt;</code> .   <code>Y</code>  ,   <code>X</code>   . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X()); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Y&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Y()); Foo(p1, p2);</code> </pre> <br><p>     <code>std::make_shared&lt;Y&gt;</code> (    ,     ): </p><br><pre> <code class="cpp hljs">Foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;X&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Y&gt;());</code> </pre> <br><p>  . [Meyers2]. </p><br><p>  : </p><br><ul><li>    . </li></ul><br><a name="id-5"></a><br><h1> 5.   </h1><br><a name="id-5-1"></a><br><h2>  5.1.    </h2><br><p>  ++98  ,           ( ), ,     (     ,    ).      <code>virtual</code> ,   ,    .   ( ),   ,   ,     . ,     ,  .  ,  ++11    <code>override</code> ,    ,    ,       .          . </p><br><p>  : </p><br><ul><li>    <code>override</code> . </li><li>    .    ,         . </li></ul><br><a name="id-5-2"></a><br><h2>  5.2.       </h2><br><p>            .   ,              ,     .               .    . [Dewhurst]. </p><br><p>  : </p><br><ul><li>           . </li></ul><br><a name="id-5-3"></a><br><h2>  5.3.        </h2><br><p> ,     ,          . , ,     post_construct  pre_destroy. ,      ‚Äî         .    .   ,        :     ( )   . (, ,      .)     ,           ( ),    ( ).  . [Dewhurst]. ,         ,  . </p><br><p>       ‚Äî  -         . </p><br><p> ,   C#  ,     ,   ,     .  C#    :   ,      ,       .  ,           ( ,    ). </p><br><p>  : </p><br><ul><li>        ,     ,   . </li></ul><br><a name="id-5-4"></a><br><h2>  5.4.   </h2><br><p>     ,        ,           <code>delete</code>     .          , -    . </p><br><p>  : </p><br><ul><li>     . </li></ul><br><a name="id-6"></a><br><h1> 6.     </h1><br><p>        ‚Äî      C/C++,        .           .        .     ¬´  ¬ª. </p><br><p>  C#        unsafe mode,    . </p><br><a name="id-6-1"></a><br><h2>  6.1.     </h2><br><p>    /++  ,        : <code>strcpy()</code> , <code>strcat()</code> , <code>sprinf()</code> , etc.    ( <code>std::vector&lt;&gt;</code> , etc.)         ,    . (,         ,         ,     . . <strong>Checked Iterators</strong>  MSDN.)      ,      :   ,      ,     ;     ,      . </p><br><p>  C#,   unsafe mode,      . </p><br><p>  : </p><br><ul><li>    , . </li><li>     . </li><li>   z-terminated   ,    <code>_s</code> (.   ). </li></ul><br><a name="id-6-2"></a><br><h2>  6.2. Z-terminated  </h2><br><p>       ,  .    ,  : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">strncpy</span></span>(dst,src,n);</code> </pre> <br><p>  <code>strlen(src)&gt;=n</code> ,  <code>dst</code>     (,      ).      ,       , .  .       ‚Äî       .   <code>if(*str)</code> ,  <code>if(strlen(str)&gt;0)</code> ,           .         [Spolsky]. </p><br><p>  C#  <code>string</code>      . </p><br><p>  : </p><br><ul><li>    . </li><li>     z-terminated   ,    <code>_s</code> (.   ). </li></ul><br><a name="id-6-3"></a><br><h2>  6.3.      </h2><br><p>    <code>...</code>    .      <code>printf</code> - ,     C.          , ,  ,     ,      .         ,       . </p><br><p>  C#    <code>printf</code> ,     . </p><br><p>  : </p><br><ul><li>     . ,  <code>printf</code> -    /. </li><li>   . </li></ul><br><a name="id-7"></a><br><h1> 7.  </h1><br><a name="id-7-1"></a><br><h2>  7.1.   </h2><br><p>  ++     , ,   ,        .  Hier ist ein Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N = <span class="hljs-number"><span class="hljs-number">4</span></span>, M = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x,                <span class="hljs-comment"><span class="hljs-comment">// 1    *px,              // 2    ax[N],            // 3    *apx[N],          // 4    F(char),          // 5    *G(char),          // 6    (*pF)(char),      // 7    (*apF[N])(char),  // 8    (*pax)[N],        // 9    (*apax[M])[N],    // 10    (*H(char))(long);  // 11</span></span></code> </pre> <br><p>        : </p><br><ol><li>   <code>int</code> ; </li><li>   <code>int</code> ; </li><li>   <code>N</code>   <code>int</code> ; </li><li>   <code>N</code>     <code>int</code> ; </li><li> ,  <code>char</code>   <code>int</code> ; </li><li> ,  <code>char</code>     <code>int</code> ; </li><li>   ,  <code>char</code>   <code>int</code> ; </li><li>   <code>N</code>     ,  <code>char</code>   <code>int</code> ; </li><li>     <code>N</code>   <code>int</code> ; </li><li>   <code>M</code>       <code>N</code>   <code>int</code> ; </li><li> ,  <code>char</code>     ,  <code>long</code>   <code>int</code> . </li></ol><br><p> ,             . (     .) </p><br><p>     <code>*</code>    <code>&amp;</code>     . (    .) </p><br><p>        <code>typedef</code> ( <code>using</code> -). ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*P)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; PH(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>);</code> </pre> <br><p>      ,     . </p><br><p>  C#    ,    . </p><br><p>  : </p><br><ul><li>   . </li></ul><br><a name="id-7-2"></a><br><h2>  7.2.   </h2><br><p>           .     </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>     </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><p>    <code>x</code>  <code>X</code> ,   5.    </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>    <code>x</code> ,    <code>X</code>    ,     <code>x</code>  <code>X</code> ,    .     <code>X</code> ,    ,     : </p><br><pre> <code class="cpp hljs">X x; X x = X(); X x{};    <span class="hljs-comment"><span class="hljs-comment">//   C++11</span></span></code> </pre> <br><p>   ,    ,          ,   .         [Sutter]. </p><br><p>  ,  ,   C++     (      ).         . (    C++  .) </p><br><p>  , ,      ,       ,         . </p><br><p>  C#   ,         ,      . </p><br><p>  : </p><br><ul><li>    . </li></ul><br><a name="id-8"></a><br><h1> 8.  </h1><br><a name="id-8-1"></a><br><h2> 8.1.   <code>inline</code>  ODR </h2><br><p>   ,    <code>inline</code> ‚Äî             .  ,     .   <code>inline</code>          (One Defenition Rule, ODR).  .            ,   .          ,  ODR.       <code>static</code> :    ,       ,   .   <code>static</code>  <code>inline</code> .      ,        ,  ODR,     . ,       .   - ,          -.         . </p><br><p>  : </p><br><ul><li>  ¬´¬ª <code>inline</code> .          <code>namespace</code> .      ,     . </li><li>        ‚Äî  <code>namespace</code> . </li></ul><br><a name="id-8-2"></a><br><h2> 8.2.   </h2><br><p>        .        .    ,    ,     ,   ,      . </p><br><p>  : </p><br><ul><li>     ,     . </li><li>  ,     :  () ,    -. </li><li>            <code>using</code> -: <code>using namespace <i></i></code> ,   <code>using</code> -. </li><li>           . </li></ul><br><a name="id-8-3"></a><br><h2> 8.3.  <code>switch</code> <br></h2><br><p>   ‚Äî  <code>break</code>    <code>case</code> . (  .)  C#     . </p><br><p>  : </p><br><ul><li>   . </li></ul><br><a name="id-8-4"></a><br><h2> 8.4.     </h2><br><p>  ++    ,      ‚Äî     , ‚Äî       .    (  <code>class</code>  <code>struct</code> )    ,         . (      ,      #  Java.)    ‚Äî   ,     . </p><br><ol><li>      ,   .           (  <code>std::string</code> , <code>std::vector</code> , etc.),    ,           . </li><li>    ,        ,     . </li><li>          ,      (slicing),      ,       . </li></ol><br><p>     ,      ,  ,     .      . ,       ,         . ,          .           .    ‚Äî     ( <code>=delete</code> ),   ‚Äî     <code>explicit</code> . </p><br><p>  C#      ,           . </p><br><p>  : </p><br><ul><li>   ,     . </li><li>       . </li></ul><br><a name="id-8-5"></a><br><h2> 8.5.  Ressourcenmanagement </h2><br><p>  ++         .     ,     . -       (    ),   ++11   ,        ,   ,           . </p><br><p>      C++   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br><p>  C#   ,       .        ,     .        (using-)      Basic Dispose. </p><br><p>  : </p><br><ul><li>  -       . </li></ul><br><a name="id-8-6"></a><br><h2> 8.6.     </h2><br><p>     ¬´¬ª     .     ,  , C++ , STL-   - . </p><br><p>       .         .     ,        .      .        ¬´¬ª,      .          COM-      . (,    .)      ,    C++   .      ‚Äî      .        .            .  ,      (¬´¬ª     )    ,      .        . </p><br><p>  #    ,     .     ‚Äî    . </p><br><p>  : </p><br><ul><li>   . </li><li>        . </li></ul><br><a name="id-8-7"></a><br><h2> 8.7.   </h2><br><p>  C++      ,     :   ,    ,   . (     !)      .        ,      .     ,   .     ,   ,     . (,           .) </p><br><p>      C (    ),   C++       C  (   <code>extern "C"</code> ).      C/C++ . </p><br><p>          -.   <code>#pragma</code> -    ,    ,   . </p><br><p>        , ,    ,    . </p><br><p>     , ,    COM. COM-,    ,   (     ,      ).  COM     ,   ,     . </p><br><p>  C#     . ,   ‚Äî    ,      C#,    C#  C/C++. </p><br><p>  : </p><br><ul><li>        . </li></ul><br><a name="id-8-8"></a><br><h2> 8.8.  </h2><br><p>        ,         .    ,       .  C++    .  Stattdessen </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> XXL 32</span></span></code> </pre> <br><p>   </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> XXL=<span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br><p>   .       <code>inline</code>   . </p><br><p>  #   (   ). </p><br><p>  : </p><br><ul><li>       . </li></ul><br><a name="id-conclusion"></a><br><h1> 9.  </h1><br><ol><li>      .       .   .      ,       . </li><li>    . </li><li>    .   ++      ‚Äî ++11/14/17. </li><li>   - ,  -   . </li><li>        . </li></ol><br><a name="id-refs"></a><br><h1>  Referenzliste </h1><br><div class="spoiler">  <b class="spoiler_title">Liste</b> <div class="spoiler_text"><p> [Dewhurst] <br> ,  .   C++.         .: .  . ‚Äî .:  , 2012. </p><br><p> [Meyers1] <br> , .   C++. 55        .: .  . ‚Äî .:  , 2014. </p><br><p> [Meyers2] <br> , .    C++: 42    C++11  C++14.: .  . ‚Äî .:  ¬´.. ¬ª, 2016. </p><br><p> [Sutter] <br> , .     C++.: .  . ‚Äî :  ¬´.. ¬ª, 2015. </p><br><p> [Spolsky] <br> , .   .: .  . ‚Äî .: -, 2008. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428898/">https://habr.com/ru/post/de428898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428888/index.html">qml: Kraft und Einfachheit</a></li>
<li><a href="../de428890/index.html">Die ganze Wahrheit √ºber RTOS. Artikel Nr. 18. Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a></li>
<li><a href="../de428892/index.html">So erstellen Sie eine Spiel-KI: eine Anleitung f√ºr Anf√§nger</a></li>
<li><a href="../de428894/index.html">Mehrwertsteuer auf inl√§ndische Eink√§ufe</a></li>
<li><a href="../de428896/index.html">Neuronale Netze der Hentai-Zensur</a></li>
<li><a href="../de428900/index.html">Radroboter liefern Waren an Einwohner der USA und Gro√übritanniens</a></li>
<li><a href="../de428902/index.html">NFC Wireless Tags</a></li>
<li><a href="../de428904/index.html">Fintech Digest: Zentralbankrobotik, Ethereum 2.0, Kryptow√§hrungskontrolle durch Rosfinmonitoring und Trends in Fintech</a></li>
<li><a href="../de428906/index.html">Erstellen von Puzzlespielen mit Puzzleskript</a></li>
<li><a href="../de428908/index.html">Frostpunk: Demontage der Mechanik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>