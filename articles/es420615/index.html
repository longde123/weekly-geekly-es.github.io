<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêπ ‚èÆÔ∏è üìò JavaScript: explorar objetos ‚òùüèΩ üëë ‚èèÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El material, cuya traducci√≥n publicamos hoy, est√° dedicado al estudio de objetos, una de las esencias clave de JavaScript. Est√° dise√±ado principalment...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript: explorar objetos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420615/">  El material, cuya traducci√≥n publicamos hoy, est√° dedicado al estudio de objetos, una de las esencias clave de JavaScript.  Est√° dise√±ado principalmente para desarrolladores principiantes que desean optimizar su conocimiento de los objetos. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/vo/lg/xb/volgxbgclrhdnqvvi_qdqfc1yna.jpeg"></a> <br><br>  Los objetos en JavaScript son colecciones din√°micas de propiedades que, adem√°s, contienen una propiedad "oculta" que es un prototipo del objeto.  Las propiedades de los objetos se caracterizan por claves y valores.  Comencemos la conversaci√≥n sobre los objetos JS con claves. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Claves de propiedad de objeto</font> </h2><br>  La clave de propiedad del objeto es una cadena √∫nica.  Puede usar dos m√©todos para acceder a las propiedades: acceder a ellas durante un per√≠odo y especificar la clave del objeto entre corchetes.  Al acceder a las propiedades a trav√©s de un punto, la clave debe ser un identificador de JavaScript v√°lido.  Considere un ejemplo: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> obj = {  <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> : <span class="hljs-string"><span class="hljs-string">"A message"</span></span> } obj.message //<span class="hljs-string"><span class="hljs-string">"A message"</span></span> obj[<span class="hljs-string"><span class="hljs-string">"message"</span></span>] //<span class="hljs-string"><span class="hljs-string">"A message"</span></span></code> </pre> <br>  Cuando intente acceder a una propiedad inexistente de un objeto, no aparecer√° un mensaje de error, pero se devolver√° el valor <code>undefined</code> : <br><br><pre> <code class="hljs objectivec">obj.otherProperty <span class="hljs-comment"><span class="hljs-comment">//undefined</span></span></code> </pre> <br>  Al usar corchetes para acceder a las propiedades, puede usar claves que no sean identificadores de JavaScript v√°lidos (por ejemplo, la clave puede ser una cadena que contenga espacios).  Pueden tener cualquier valor que se pueda convertir en una cadena: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> french = {}; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>] = <span class="hljs-string"><span class="hljs-string">"thank you very much"</span></span>; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//"thank you very much"</span></span></code> </pre> <br>  Si los valores que no son cadenas se utilizan como claves, se convierten autom√°ticamente en cadenas (utilizando, si es posible, el m√©todo <code>toString()</code> ): <br><br><pre> <code class="hljs powershell">et obj = {}; //Number obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">"Number 1"</span></span>; obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //true //Object let number1 = { toString : function() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } } obj[<span class="hljs-type"><span class="hljs-type">number1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //true</code> </pre> <br>  En este ejemplo, el objeto <code>number1</code> se usa como clave.  Al intentar acceder a una propiedad, se convierte a la l√≠nea <code>1</code> y el resultado de esta conversi√≥n se utiliza como clave. <br><br><h2>  <font color="#3AC1EF">Valores de propiedad del objeto</font> </h2><br>  Las propiedades de los objetos pueden ser valores primitivos, objetos o funciones. <br><br><h3>  <font color="#3AC1EF">‚ñçObjeto como valor de propiedad de un objeto</font> </h3><br>  Los objetos se pueden colocar en otros objetos.  Considere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo</a> : <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = { title : <span class="hljs-string"><span class="hljs-string">"The Good Parts"</span></span>, author : {   firstName : <span class="hljs-string"><span class="hljs-string">"Douglas"</span></span>,   lastName : <span class="hljs-string"><span class="hljs-string">"Crockford"</span></span> } } book.author.firstName; <span class="hljs-comment"><span class="hljs-comment">//"Douglas"</span></span></code> </pre> <br>  Se puede usar un enfoque similar para crear espacios de nombres: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> app = {}; app.authorService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; app.bookService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} };</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Funciona como un valor de propiedad de objeto</font> </h3><br>  Cuando una funci√≥n se usa como un valor de propiedad de objeto, generalmente se convierte en un m√©todo de objeto.  Dentro del m√©todo, para acceder al objeto actual, use la <code>this</code> . <br><br>  Sin embargo, esta palabra clave puede tener diferentes significados, dependiendo de c√≥mo se llam√≥ la funci√≥n.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> puede leer sobre situaciones en las que <code>this</code> pierde contexto. <br><br><h2>  <font color="#3AC1EF">La naturaleza din√°mica de los objetos.</font> </h2><br>  Los objetos en JavaScript, por su naturaleza, son entidades din√°micas.  Puede agregarles propiedades en cualquier momento, lo mismo ocurre con la eliminaci√≥n de propiedades: <br><br><pre> <code class="hljs ruby">let obj = {}; obj.message = <span class="hljs-string"><span class="hljs-string">"This is a message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   obj.otherMessage = <span class="hljs-string"><span class="hljs-string">"A new message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    delete obj.otherMessage; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> </code> </pre> <br><h2>  <font color="#3AC1EF">Objetos como matrices asociativas</font> </h2><br>  Los objetos pueden considerarse como matrices asociativas.  Las claves de matriz asociativas son los nombres de propiedad del objeto.  Para acceder a la clave, no necesita mirar todas las propiedades, es decir, la operaci√≥n de acceder a la clave de una matriz asociativa basada en un objeto se realiza en el tiempo O (1). <br><br><h2>  <font color="#3AC1EF">Prototipos de objetos</font> </h2><br>  Los objetos tienen un enlace "oculto", <code>__proto__</code> , que apunta a un objeto prototipo del cual el objeto hereda propiedades. <br><br>  Por ejemplo, un objeto creado usando un objeto literal tiene un enlace a <code>Object.prototype</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; obj.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype; <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Objetos vac√≠os</font> </h3><br>  Como acabamos de ver, el objeto "vac√≠o", <code>{}</code> , en realidad no est√° tan vac√≠o, ya que contiene una referencia a <code>Object.prototype</code> .  Para crear un objeto verdaderamente vac√≠o, debe usar la siguiente construcci√≥n: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)</code> </pre> <br>  Gracias a esto, se crear√° un objeto sin prototipo.  Tales objetos se usan generalmente para crear matrices asociativas. <br><br><h3>  <font color="#3AC1EF">‚ñç Cadena de prototipo</font> </h3><br>  Los objetos prototipo pueden tener sus propios prototipos.  Si intenta acceder a una propiedad de un objeto que no est√° en √©l, JavaScript intentar√° encontrar esta propiedad en el prototipo de este objeto, y si la propiedad deseada no est√° all√≠, se intentar√° encontrarla en el prototipo del prototipo.  Esto continuar√° hasta que se encuentre la propiedad deseada, o hasta que se llegue al final de la cadena del prototipo. <br><br><h2>  <font color="#3AC1EF">Valores de tipo primitivo y envoltorios de objetos</font> </h2><br>  JavaScript le permite trabajar con los valores de tipos primitivos como objetos, en el sentido de que el lenguaje le permite acceder a sus propiedades y m√©todos. <br><br><pre> <code class="hljs ruby">(<span class="hljs-number"><span class="hljs-number">1.23</span></span>).toFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"1.2"</span></span> <span class="hljs-string"><span class="hljs-string">"text"</span></span>.toUpperCase(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"TEXT"</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>.toString(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"true"</span></span></code> </pre> <br>  Adem√°s, por supuesto, los valores de los tipos primitivos no son objetos. <br><br>  Para organizar el acceso a las "propiedades" de los valores de los tipos primitivos, JavaScript, si es necesario, crea objetos envolventes que, despu√©s de ser innecesarios, se destruyen.  El motor JS optimiza el proceso de creaci√≥n y destrucci√≥n de objetos contenedor. <br><br>  Los contenedores de objetos tienen valores de tipo num√©rico, de cadena y l√≥gico.  Los objetos de los tipos correspondientes est√°n representados por las funciones de constructor <code>Number</code> , <code>String</code> y <code>Boolean</code> . <br><br><h2>  <font color="#3AC1EF">Prototipos Embebidos</font> </h2><br>  Los objetos num√©ricos heredan propiedades y m√©todos del prototipo <code>Number.prototype</code> , que es el descendiente de <code>Object.prototype</code> : <br><br><pre> <code class="hljs pgsql">var <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__ === Number.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__.__proto__ === <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  El prototipo de los objetos de cadena es <code>String.prototype</code> .  El prototipo de objetos booleanos es <code>Boolean.prototype</code> .  El prototipo de matrices (que tambi√©n son objetos) es <code>Array.prototype</code> . <br><br>  Las funciones en JavaScript tambi√©n son objetos que tienen un prototipo <code>Function.prototype</code> .  Las funciones tienen m√©todos como <code>bind()</code> , <code>apply()</code> y <code>call()</code> . <br><br>  Todos los objetos, funciones y objetos que representan valores de tipo primitivos (excepto los valores <code>null</code> e <code>undefined</code> ) heredan propiedades y m√©todos de <code>Object.prototype</code> .  Esto lleva al hecho de que, por ejemplo, todos tienen un m√©todo <code>toString()</code> . <br><br><h2>  <font color="#3AC1EF">Extender objetos incrustados con polyfills</font> </h2><br>  JavaScript facilita la extensi√≥n de objetos incrustados con nuevas caracter√≠sticas utilizando los llamados polyfills.  Un polyfill es un fragmento de c√≥digo que implementa caracter√≠sticas que no son compatibles con ning√∫n navegador. <br><br><h3>  <font color="#3AC1EF">‚ñçUso de polyfills</font> </h3><br>  Por ejemplo, hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">polyfill</a> para el m√©todo <code>Object.assign()</code> .  Le permite agregar una nueva funci√≥n al <code>Object</code> si no est√° disponible en √©l. <br><br>  Lo mismo se aplica al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">polyfill</a> <code>Array.from()</code> , que, si el m√©todo <code>from()</code> no est√° en el objeto <code>Array</code> , lo equipa con este m√©todo. <br><br><h3>  <font color="#3AC1EF">‚ñç Polyfill y prototipos</font> </h3><br>  Con la ayuda de polyfills, se pueden agregar nuevos m√©todos a los prototipos de objetos.  Por ejemplo, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">polyfill</a> para <code>String.prototype.trim()</code> permite equipar todos los objetos de cadena con el m√©todo <code>trim()</code> : <br><br><pre> <code class="hljs pgsql">let <span class="hljs-type"><span class="hljs-type">text</span></span> = "   A text "; <span class="hljs-type"><span class="hljs-type">text</span></span>.trim(); //"A text"</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El polyfill</a> para <code>Array.prototype.find()</code> permite equipar todas las matrices con el m√©todo <code>find()</code> .  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">polyfill</a> para <code>Array.prototype.findIndex()</code> funciona de manera similar: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-string"><span class="hljs-string">"C"</span></span>, <span class="hljs-string"><span class="hljs-string">"D"</span></span>, <span class="hljs-string"><span class="hljs-string">"E"</span></span>]; arr.indexOf(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//2</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Herencia individual</font> </h2><br>  El <code>Object.create()</code> permite crear nuevos objetos con un objeto prototipo dado.  Este comando se usa en JavaScript para implementar un √∫nico mecanismo de herencia.  Considere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookPrototype = { <span class="hljs-attr"><span class="hljs-attr">getFullTitle</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title + <span class="hljs-string"><span class="hljs-string">" by "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.author; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(bookPrototype); book.title = <span class="hljs-string"><span class="hljs-string">"JavaScript: The Good Parts"</span></span>; book.author = <span class="hljs-string"><span class="hljs-string">"Douglas Crockford"</span></span>; book.getFullTitle();<span class="hljs-comment"><span class="hljs-comment">//JavaScript: The Good Parts by Douglas Crockford</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Herencia m√∫ltiple</font> </h2><br>  El <code>Object.assign()</code> copia propiedades de uno o m√°s objetos al objeto de destino.  Se puede usar para implementar m√∫ltiples esquemas de herencia.  Aqu√≠ hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> authorDataService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookDataService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userDataService = { <span class="hljs-attr"><span class="hljs-attr">getUsers</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataService = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, authorDataService, bookDataService, userDataService ); dataService.getAuthors(); dataService.getBooks(); dataService.getUsers();</code> </pre> <br><h2>  <font color="#3AC1EF">Objetos inmutables</font> </h2><br>  El <code>Object.freeze()</code> permite "congelar" un objeto.  No puede agregar nuevas propiedades a dicho objeto.  Las propiedades no se pueden eliminar ni se pueden cambiar sus valores.  Al usar este comando, un objeto se vuelve inmutable o inmutable: <br><br><pre> <code class="hljs pgsql">"use strict"; let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "Functional-Light JavaScript", author : "Kyle Simpson" }); book.title = "Other title";//: Cannot assign <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> property <span class="hljs-string"><span class="hljs-string">'title'</span></span></code> </pre> <br>  El <code>Object.freeze()</code> realiza el llamado "congelamiento superficial" de objetos.  Esto significa que los objetos anidados en un objeto "congelado" pueden modificarse.  Para llevar a cabo una "congelaci√≥n profunda" de un objeto, debe "congelar" recursivamente todas sus propiedades. <br><br><h2>  <font color="#3AC1EF">Clonando objetos</font> </h2><br>  Para crear clones (copias) de objetos, puede usar el <code>Object.assign()</code> : <br><br><pre> <code class="hljs pgsql">let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "JavaScript Allong√©", author : "Reginald Braithwaite" }); let clone = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.assign({}, book);</code> </pre> <br>  Este comando realiza una copia superficial de objetos, es decir, solo copia propiedades de nivel superior.  Los objetos anidados resultan ser comunes para los objetos originales y sus copias. <br><br><h2>  <font color="#3AC1EF">Objeto literal</font> </h2><br>  Los literales de objetos brindan a los desarrolladores una forma simple y directa de crear objetos: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span> : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; }, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, }</code> </pre> <br>  Sin embargo, este m√©todo de crear objetos tiene desventajas.  En particular, con este enfoque, todas las propiedades del objeto est√°n disponibles p√∫blicamente, los m√©todos del objeto se pueden redefinir, no se pueden usar para crear nuevas instancias de los mismos objetos: <br><br><pre> <code class="hljs pgsql">timer.fn;//<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> timer.start = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { console.log("New implementation"); }</code> </pre> <br><h2>  <font color="#3AC1EF">M√©todo Object.create ()</font> </h2><br>  Los dos problemas mencionados anteriormente se pueden resolver mediante el uso conjunto de los m√©todos <code>Object.create()</code> y <code>Object.freeze()</code> . <br><br>  Aplicamos esta t√©cnica a nuestro ejemplo anterior.  Primero, cree un prototipo de <code>timerPrototype</code> prototipo congelado que contenga todos los m√©todos necesarios para varias instancias del objeto.  Despu√©s de eso, cree un objeto que sea sucesor de <code>timerPrototype</code> : <br><br><pre> <code class="hljs pgsql">let timerPrototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} }); let timer = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(timerPrototype); timer.__proto__ === timerPrototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  Si el prototipo est√° protegido de los cambios, el objeto que es su heredero no podr√° cambiar las propiedades definidas en el prototipo.  Ahora los m√©todos <code>start()</code> y <code>stop()</code> no se pueden anular: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; timer.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"New implementation"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//: Cannot assign to read only property 'start' of object</span></span></code> </pre> <br>  La <code>Object.create(timerPrototype)</code> se puede usar para crear m√∫ltiples objetos con el mismo prototipo. <br><br><h2>  <font color="#3AC1EF">Funci√≥n constructora</font> </h2><br>  JavaScript tiene las llamadas funciones de constructor, que son "az√∫car sint√°ctico" para realizar los pasos anteriores para crear nuevos objetos.  Considere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; } Timer.prototype = { <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTodos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(getTodos);</code> </pre> <br>  Puede usar cualquier funci√≥n como constructor.  Se llama al constructor utilizando la <code>new</code> palabra clave.  Un objeto creado usando una funci√≥n constructora llamada <code>FunctionConstructor</code> recibir√° un prototipo <code>FunctionConstructor.prototype</code> : <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  Aqu√≠, para evitar un cambio en el prototipo, nuevamente, puede congelar el prototipo: <br><br><pre> <code class="hljs pgsql">Timer.prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} });</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Palabra clave nueva</font> </h3><br>  Cuando se ejecuta un comando de la forma <code>new Timer()</code> , se realizan las mismas acciones que la funci√≥n <code>newTimer()</code> continuaci√≥n: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTimer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newObj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Timer.prototype); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> returnObj = Timer.call(newObj, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(returnObj) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnObj;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newObj; }</code> </pre> <br>  Aqu√≠ se crea un nuevo objeto, cuyo prototipo es <code>Timer.prototype</code> .  Luego se llama a la funci√≥n <code>Timer</code> , que establece los campos para el nuevo objeto. <br><br><h2>  <font color="#3AC1EF">Palabra clave de clase</font> </h2><br>  ECMAScript 2015 introdujo una nueva forma de realizar las acciones anteriores, que es otro lote de "az√∫car sint√°ctico".  Estamos hablando de la palabra clave de <code>class</code> y las construcciones relacionadas asociadas con ella.  Considere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Timer{ constructor(callback){   this.fn = callback; } <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {} stop() {} } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br>  Un objeto creado usando la palabra clave de <code>class</code> basada en una clase llamada <code>ClassName</code> tendr√° el prototipo <code>ClassName.prototype</code> .  Al crear un objeto basado en una clase, use la <code>new</code> palabra clave: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  Usar clases no hace que los prototipos sean inmutables.  Si es necesario, deber√°n "congelarse" de la misma manera que ya lo hicimos nosotros: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br><h2>  <font color="#3AC1EF">Herencia basada en prototipos</font> </h2><br>  En JavaScript, los objetos heredan propiedades y m√©todos de otros objetos.  Las funciones y clases de constructor son "az√∫car sint√°ctico" para crear prototipos de objetos que contienen todos los m√©todos necesarios.  Al usarlos, se crean nuevos objetos que son los herederos del prototipo, cuyas propiedades, espec√≠ficas de una instancia en particular, se establecen utilizando la funci√≥n de constructor o los mecanismos de clase. <br><br>  Ser√≠a bueno si las funciones y clases de constructor pudieran hacer autom√°ticamente prototipos inmutables. <br><br>  Los puntos fuertes de la herencia de prototipos son los ahorros de memoria.  El hecho es que un prototipo se crea solo una vez, despu√©s de lo cual todos los objetos creados sobre su base lo usan. <br><br><h3>  <font color="#3AC1EF">‚ñç El problema de la falta de mecanismos de encapsulaci√≥n integrados</font> </h3><br>  La plantilla de herencia prototipo no utiliza la separaci√≥n de las propiedades de los objetos en privado y p√∫blico.  Todas las propiedades de los objetos est√°n disponibles p√∫blicamente. <br><br>  Por ejemplo, el <code>Object.keys()</code> devuelve una matriz que contiene todas las claves de propiedad del objeto.  Se puede usar para iterar sobre todas las propiedades de un objeto: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> logProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>){ console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>); //  console.log(obj[<span class="hljs-type"><span class="hljs-type">name</span></span>]); //  } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(obj).<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(logProperty);</code> </pre> <br>  Hay un patr√≥n que imita las propiedades privadas, que se basa en el hecho de que los desarrolladores no tendr√°n acceso a esas propiedades cuyos nombres comienzan con un gui√≥n bajo ( <code>_</code> ): <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(callback){   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fn = callback;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._timerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><h2>  <font color="#3AC1EF">Caracter√≠sticas de la f√°brica</font> </h2><br>  Los objetos encapsulados en JavaScript se pueden crear utilizando funciones de f√°brica.  Se ve as√≠: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> TodoStore(callback){   let fn = callback;     <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {},   <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> stop() {}     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,      stop   }); }</code> </pre> <br>  Aqu√≠ la variable <code>fn</code> es privada.  Solo los m√©todos <code>start()</code> y <code>stop()</code> est√°n disponibles p√∫blicamente.  Estos m√©todos no pueden modificarse externamente.  La palabra clave this no se usa aqu√≠, por lo tanto, cuando se usa este m√©todo de creaci√≥n de objetos, el problema de perder <code>this</code> contexto es irrelevante. <br><br>  El comando <code>return</code> usa un objeto literal que contiene solo funciones.  Adem√°s, estas funciones se declaran cerradas; comparten un estado com√∫n.  Para congelar una API p√∫blica de un objeto, se <code>Object.freeze()</code> comando <code>Object.freeze()</code> ya conocido. <br><br>  Aqu√≠, en los ejemplos, usamos el objeto <code>Timer</code> .  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> material puede encontrar su implementaci√≥n completa. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  En JavaScript, los valores de tipos primitivos, objetos ordinarios y funciones se tratan como objetos.  Los objetos tienen una naturaleza din√°mica, se pueden usar como matrices asociativas.  Los objetos son herederos de otros objetos.  Las funciones y clases de constructor son "az√∫car sint√°ctico", le permiten crear objetos basados ‚Äã‚Äãen prototipos.  Puede usar el m√©todo <code>Object.create()</code> para organizar una herencia √∫nica y <code>Object.create()</code> para organizar una herencia m√∫ltiple.  Puede usar funciones de f√°brica para crear objetos encapsulados. <br><br>  <b>Estimados lectores!</b>  Si lleg√≥ a JavaScript desde otros idiomas, cu√©ntenos qu√© le gusta o qu√© no le gustan de los objetos JS, en comparaci√≥n con la implementaci√≥n de objetos en los idiomas que ya conoce. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420615/">https://habr.com/ru/post/es420615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420605/index.html">Descripci√≥n general del algoritmo de entrevista de trabajo: generaci√≥n de conjuntos</a></li>
<li><a href="../es420607/index.html">Eventos digitales en Mosc√∫ del 20 al 26 de agosto.</a></li>
<li><a href="../es420609/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 327 (13 al 19 de agosto de 2018)</a></li>
<li><a href="../es420611/index.html">Modelado de enredo cu√°ntico en C #</a></li>
<li><a href="../es420613/index.html">11 bibliotecas (conjuntos de componentes) para React Native que debes conocer en 2018</a></li>
<li><a href="../es420617/index.html">Gu√≠a de dise√±o web para desarrolladores</a></li>
<li><a href="../es420619/index.html">Im√°genes receptivas: trucos CSS que ahorran tiempo</a></li>
<li><a href="../es420623/index.html">Aplicaciones C ++ distribuidas con un m√≠nimo de esfuerzo.</a></li>
<li><a href="../es420625/index.html">KDD 2018, D√≠a uno, tutoriales</a></li>
<li><a href="../es420627/index.html">Programaci√≥n as√≠ncrona C #: ¬øC√≥mo le va con el rendimiento?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>