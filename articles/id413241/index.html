<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙 🧗🏾 👦🏻 Mencegah fungsi dalam kernel Linux menggunakan ftrace 🌔 🌎 📁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam satu proyek yang terkait dengan keamanan sistem Linux, kami perlu mencegat panggilan ke fungsi-fungsi penting di dalam kernel (seperti membuka f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mencegah fungsi dalam kernel Linux menggunakan ftrace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413241/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/xy/k-/zy/xyk-zye1hkr1vaw41hvsxup3brc.png" alt="Ninja Penguin, En3l" align="right" width="40%"></a>  Dalam satu proyek yang terkait dengan keamanan sistem Linux, kami perlu mencegat panggilan ke fungsi-fungsi penting di dalam kernel (seperti membuka file dan menjalankan proses) untuk memberikan kemampuan untuk memantau aktivitas dalam sistem dan secara preventif memblokir aktivitas proses yang mencurigakan. <br><br>  Selama proses pengembangan, kami berhasil menemukan pendekatan yang cukup bagus, yang memungkinkan kami untuk dengan mudah mencegat fungsi apa pun di kernel dengan nama dan mengeksekusi kode kami di sekitar panggilannya.  Interceptor dapat diinstal dari modul GPL yang dapat dimuat, tanpa membangun kembali kernel.  Pendekatan ini mendukung kernel versi 3.19+ untuk arsitektur x86_64. <br><a name="habracut"></a><br>  <font color="gray">(Gambar Penguin di atas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">© En3l dengan DeviantArt</a> .)</font> <br><br><h2>  Pendekatan yang Dikenal </h2><br><h3>  API Keamanan Linux </h3><br>  Yang paling benar adalah dengan menggunakan <em>Linux Security API</em> - antarmuka khusus yang dibuat khusus untuk keperluan ini.  Di tempat-tempat penting dari kode kernel, panggilan ke fungsi keamanan berada, yang, pada gilirannya, memanggil panggilan balik yang diatur oleh modul keamanan.  Modul keamanan dapat memeriksa konteks operasi dan membuat keputusan apakah diizinkan atau ditolak. <br><br>  Sayangnya, Linux Security API memiliki beberapa batasan penting: <br><br><ul><li>  modul keamanan tidak dapat dimuat secara dinamis, merupakan bagian dari kernel dan memerlukan pembangunan kembali </li><li>  hanya ada satu modul keamanan dalam sistem (dengan beberapa pengecualian) </li></ul><br>  Jika posisi pengembang kernel tidak jelas mengenai banyaknya modul, maka larangan pemuatan dinamis sangat mendasar: modul keamanan harus menjadi bagian dari kernel untuk memastikan keamanan terus-menerus, sejak saat pemuatan. <br><br>  Jadi, untuk menggunakan API Keamanan, Anda harus menyediakan rakitan kernel Anda sendiri, serta mengintegrasikan modul add-on dengan SELinux atau AppArmor, yang digunakan oleh distribusi populer.  Pelanggan tidak ingin berlangganan kewajiban tersebut, sehingga rute ini ditutup. <br><br>  Karena alasan ini, API Keamanan tidak cocok untuk kami, jika tidak, itu akan menjadi pilihan ideal. <br><br><h3>  Modifikasi tabel panggilan sistem </h3><br>  Pemantauan diperlukan terutama untuk tindakan yang dilakukan oleh aplikasi pengguna, sehingga pada prinsipnya itu dapat diimplementasikan pada tingkat panggilan sistem.  Seperti yang Anda ketahui, Linux menyimpan semua penangan panggilan sistem di tabel <code>sys_call_table</code> .  Substitusi nilai dalam tabel ini mengarah ke perubahan perilaku seluruh sistem.  Dengan demikian, dengan menjaga nilai-nilai lama dari handler dan mengganti handler kita sendiri di dalam tabel, kita dapat memotong panggilan sistem apa pun. <br><br>  Pendekatan ini memiliki kelebihan tertentu: <br><br><ul><li>  <strong>Kontrol penuh atas semua panggilan sistem</strong> - satu-satunya antarmuka ke kernel untuk aplikasi pengguna.  Dengan menggunakannya, kami dapat memastikan bahwa kami tidak akan melewatkan tindakan penting yang dilakukan oleh proses pengguna. <br></li><li>  <strong>Overhead minimum.</strong>  Ada investasi modal satu kali saat memperbarui tabel panggilan sistem.  Selain muatan pemantauan yang tak terhindarkan, satu-satunya biaya adalah panggilan fungsi tambahan (untuk memanggil penangan panggilan sistem yang asli). <br></li><li>  <strong>Persyaratan kernel minimum.</strong>  Jika diinginkan, pendekatan ini tidak memerlukan opsi konfigurasi tambahan apa pun di kernel, sehingga secara teori mendukung opsi sistem seluas mungkin. <br></li></ul><br>  Namun, ia juga menderita beberapa kekurangan: <br><br><ul><li>  <strong>Kompleksitas teknis dari implementasi.</strong>  Dengan sendirinya, mengganti pointer dalam sebuah tabel tidaklah sulit.  Tetapi tugas terkait membutuhkan solusi yang tidak jelas dan kualifikasi tertentu: <br><ul><li>  tabel panggilan sistem pencarian </li><li>  modifikasi tabel perlindungan memotong </li><li>  penggantian atom dan aman </li></ul><br>  Ini semua adalah hal yang menarik, tetapi membutuhkan waktu pengembangan yang berharga, pertama untuk implementasi, dan kemudian untuk dukungan dan pemahaman. <br></li><li>  <strong>Ketidakmampuan untuk mencegat beberapa penangan.</strong>  Di kernel sebelum versi 4.16, penanganan panggilan sistem untuk arsitektur x86_64 berisi sejumlah optimisasi.  Beberapa dari mereka menuntut agar pemanggil panggilan sistem menjadi adaptor khusus yang diterapkan pada assembler.  Oleh karena itu, penangan seperti itu terkadang sulit, dan kadang-kadang bahkan tidak mungkin untuk menggantinya dengan Anda sendiri, ditulis dalam C.  Selain itu, berbagai optimasi digunakan dalam versi kernel yang berbeda, yang menambah kesulitan teknis celengan. <br></li><li>  <strong>Hanya panggilan sistem yang dicegat.</strong>  Pendekatan ini memungkinkan Anda untuk mengganti penangan panggilan sistem, yang membatasi titik masuk hanya untuk mereka.  Semua pemeriksaan tambahan dilakukan baik di awal atau di akhir, dan kami hanya memiliki argumen panggilan sistem dan nilai kembalinya.  Terkadang ini mengarah pada kebutuhan untuk menggandakan cek pada kecukupan argumen dan mengakses cek.  Kadang-kadang menyebabkan overhead yang tidak perlu ketika Anda perlu menyalin memori proses pengguna dua kali: jika argumen dilewatkan melalui pointer, maka pertama-tama kita harus menyalinnya sendiri, maka pawang yang asli akan menyalin argumen lagi untuk dirinya sendiri.  Selain itu, dalam beberapa kasus, panggilan sistem memberikan rincian acara yang terlalu rendah yang harus disaring dari kebisingan. <br></li></ul><br>  Awalnya, kami memilih dan berhasil menerapkan pendekatan ini, mengejar manfaat mendukung sejumlah besar sistem.  Namun, pada saat itu kami masih belum tahu tentang fitur x86_64 dan pembatasan panggilan yang dicegat.  Kemudian ternyata sangat penting bagi kami untuk mendukung panggilan sistem yang terkait dengan memulai proses baru - klon () dan exece () - yang hanya istimewa.  Inilah yang membuat kami mencari opsi baru. <br><br><h3>  Menggunakan kprobes </h3><br>  Salah satu opsi yang dipertimbangkan adalah penggunaan <em>kprobes</em> : API khusus yang terutama dirancang untuk debugging dan melacak kernel.  Antarmuka ini memungkinkan Anda untuk mengatur pra-dan pasca-penangan untuk <em>setiap instruksi</em> dalam kernel, serta penangan untuk masuk dan kembali dari suatu fungsi.  Penangan mendapatkan akses ke register dan dapat mengubahnya.  Dengan demikian, kita bisa mendapatkan pemantauan dan kemampuan untuk mempengaruhi jalannya pekerjaan lebih lanjut. <br><br>  Manfaat menggunakan kprobes untuk mencegat: <br><br><ul><li>  <strong>API dewasa.</strong>  Kprobes telah ada dan membaik sejak jaman dahulu (2002).  Mereka memiliki antarmuka yang terdokumentasi dengan baik, sebagian besar jebakan telah ditemukan, pekerjaan mereka telah dioptimalkan sebanyak mungkin, dan sebagainya.  Secara umum, segunung keunggulan dibandingkan sepeda buatan eksperimental. <br></li><li>  <strong>Intersepsi setiap tempat di inti.</strong>  Kprobes diimplementasikan menggunakan breakpoints (instruksi int3) yang tertanam dalam kode yang dapat dieksekusi kernel.  Ini memungkinkan Anda untuk menginstal kprobes secara harfiah di mana saja dalam fungsi apa pun, jika diketahui.  Demikian pula, kretprobes diimplementasikan melalui spoofing alamat kembali pada stack dan memungkinkan Anda untuk mencegat pengembalian dari fungsi apa pun (dengan pengecualian dari mereka yang pada prinsipnya tidak mengembalikan kontrol). <br></li></ul><br>  Kerugian dari kprobes: <br><br><ul><li>  <strong>Kesulitan teknis.</strong>  Kprobes hanyalah cara untuk menetapkan breakpoint di mana saja di kernel.  Untuk mendapatkan argumen fungsi atau nilai-nilai variabel lokal, Anda perlu tahu di mana register atau di mana di stack mereka berada, dan ekstrak secara mandiri dari sana.  Untuk memblokir panggilan fungsi, Anda harus secara manual mengubah keadaan proses sehingga prosesor berpikir bahwa ia telah mengembalikan kontrol dari fungsi. <br></li><li>  <strong>Jprobes sudah usang.</strong>  Jprobes adalah add-on untuk kprobes yang memungkinkan Anda untuk dengan mudah mencegat panggilan fungsi.  Ini akan secara mandiri mengekstraksi argumen fungsi dari register atau stack dan memanggil handler Anda, yang harus memiliki tanda tangan yang sama dengan fungsi hooked.  Tangkapannya adalah bahwa jprobes sudah usang dan dipotong dari kernel modern. <br></li><li>  <strong>Overhead non-sepele.</strong>  Breakpoints mahal, tapi satu kali.  Breakpoints tidak mempengaruhi fungsi lain, tetapi prosesnya relatif mahal.  Untungnya, optimisasi lompat diterapkan untuk arsitektur x86_64, yang secara signifikan mengurangi biaya kprobes, tetapi masih tetap lebih dari, misalnya, ketika memodifikasi tabel panggilan sistem. <br></li><li>  <strong>Keterbatasan kretprobes.</strong>  Kretprobes diimplementasikan dengan spoofing alamat pengirim di stack.  Karenanya, mereka perlu menyimpan alamat asli di suatu tempat untuk kembali ke sana setelah memproses kretprobe.  Alamat disimpan dalam buffer ukuran tetap.  Dalam kasus overflow, ketika terlalu banyak panggilan simultan dari fungsi yang dicegat dieksekusi dalam sistem, kretprobes akan melewati operasi. <br></li><li>  <strong>Dinonaktifkan Ekstrusi.</strong>  Karena kprobes didasarkan pada register prosesor interupsi dan juggle, untuk sinkronisasi semua penangan dieksekusi dengan preemption dinonaktifkan.  Ini memberlakukan batasan tertentu pada penangan: Anda tidak bisa menunggu di dalamnya - mengalokasikan banyak memori, melakukan I / O, tidur di timer dan semaphore, dan hal-hal lain yang diketahui. <br></li></ul><br>  Dalam proses meneliti topik, mata kita tertuju pada kerangka kerja <strong>ftrace</strong> , yang dapat menggantikan jprobes.  Ternyata, itu berfungsi lebih baik untuk kebutuhan intersepsi panggilan fungsi kami.  Namun, jika Anda perlu melacak instruksi spesifik dalam fungsi, maka kprobes tidak boleh diabaikan. <br><br><h3>  Penyambungan </h3><br>  Demi kelengkapan, perlu juga dijelaskan metode klasik fungsi intersep, yang terdiri dari mengganti instruksi di awal fungsi dengan transisi tanpa syarat yang mengarah ke handler kami.  Instruksi asli ditransfer ke tempat lain dan dijalankan sebelum kembali ke fungsi yang dicegat.  Dengan bantuan dua transisi kami menanamkan (splice in) kode tambahan kami ke dalam fungsi, oleh karena itu pendekatan ini disebut <em>splicing</em> . <br><br>  Ini adalah bagaimana optimasi lompatan untuk kprobes diimplementasikan.  Dengan menggunakan splicing, Anda dapat mencapai hasil yang sama, tetapi tanpa biaya tambahan untuk kprobes dan dengan kontrol penuh terhadap situasi. <br><br>  Manfaat penyambungan sudah jelas: <br><br><ul><li>  <strong>Persyaratan kernel minimum.</strong>  Penyambungan tidak memerlukan opsi khusus apa pun di kernel dan berfungsi di awal fungsi apa pun.  Anda hanya perlu tahu alamatnya. <br></li><li>  <strong>Overhead minimum.</strong>  Dua transisi tanpa syarat - itu semua tindakan yang perlu dilakukan oleh kode yang dicegat untuk mentransfer kontrol ke pawang dan sebaliknya.  Transisi seperti itu diprediksi dengan sempurna oleh prosesor dan sangat murah. <br></li></ul><br>  Namun, kelemahan utama dari pendekatan ini secara serius mengaburkan gambar: <br><br><ul><li>  <strong>Kesulitan teknis.</strong>  Dia berguling.  Anda tidak bisa hanya mengambil dan menulis ulang kode mesin.  Berikut adalah daftar tugas yang harus diselesaikan: <br><ul><li>  sinkronisasi instalasi dan penghapusan intersepsi (bagaimana jika fungsi dipanggil langsung dalam proses mengganti instruksinya?) </li><li>  memotong perlindungan pada modifikasi wilayah memori dengan kode </li><li>  Pembatalan cache CPU setelah mengganti instruksi </li><li>  membongkar instruksi yang dapat diganti untuk menyalinnya secara keseluruhan </li><li>  memeriksa tidak adanya transisi di dalam bagian yang diganti </li><li>  periksa kemampuan untuk memindahkan potongan yang diganti ke lokasi lain </li></ul><br>  Ya, Anda dapat memata-matai kprobes dan menggunakan kerangka kerja intranuclear livepatch, tetapi solusi terakhir masih cukup rumit.  Menakutkan membayangkan berapa banyak masalah tidur dalam setiap implementasi baru. <br></li></ul><br>  Secara umum, jika Anda dapat memanggil iblis ini, mensubordinasi hanya kepada para inisiat, dan siap untuk menanggungnya dalam kode Anda, maka splicing adalah pendekatan yang sepenuhnya berfungsi untuk mencegat panggilan fungsi.  Saya memiliki sikap negatif untuk menulis sepeda, jadi opsi ini tetap menjadi cadangan bagi kami seandainya tidak ada kemajuan sama sekali dengan solusi yang sudah jadi lebih mudah. <br><br><h2>  Pendekatan baru dengan ftrace </h2><br>  <strong>Ftrace</strong> adalah kerangka kerja penelusuran kernel tingkat fungsi.  Ini telah dikembangkan sejak 2008 dan memiliki antarmuka yang fantastis untuk program pengguna.  Ftrace memungkinkan Anda untuk melacak frekuensi dan durasi panggilan fungsi, menampilkan grafik panggilan, memfilter fungsi yang menarik berdasarkan templat, dan sebagainya.  Anda dapat mulai membaca tentang fitur ftrace <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> , lalu ikuti tautan dan dokumentasi resmi. <br><br>  Ini mengimplementasikan ftrace berdasarkan kunci kompiler <code>-pg</code> dan <code>-mfentry</code> , yang memasukkan panggilan ke fungsi jejak khusus mcount () atau __fentry __ () pada awal setiap fungsi.  Biasanya, dalam program pengguna, fitur kompiler ini digunakan oleh profiler untuk melacak panggilan ke semua fungsi.  Kernel menggunakan fungsi-fungsi ini untuk mengimplementasikan kerangka kerja ftrace. <br><br>  Memanggil ftrace dari <em>masing-masing</em> fungsi, tentu saja, tidak murah, jadi optimisasi tersedia untuk arsitektur populer: <em>dynamic ftrace</em> .  Intinya adalah bahwa kernel mengetahui lokasi semua panggilan ke mcount () atau __fentry __ () dan pada tahap awal memuat menggantikan kode mesin mereka dengan <strong>nop</strong> - instruksi khusus yang tidak melakukan apa-apa.  Ketika penelusuran disertakan dalam fungsi yang diperlukan, panggilan ftrace ditambahkan kembali.  Jadi, jika ftrace tidak digunakan, maka dampaknya pada sistem minimal. <br><br><h3>  Deskripsi fungsi yang diperlukan </h3><br>  Setiap fungsi yang dicegat dapat dijelaskan oleh struktur berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * struct ftrace_hook -    * * @name:    * * @function:  -,     *   * * @original:   ,     *  ,    * * @address:   ,    * * @ops:   ftrace,  , *      */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *function; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *original; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> address; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_ops</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br>  Pengguna hanya perlu mengisi tiga bidang pertama: nama, fungsi, asli.  Kolom yang tersisa dianggap sebagai detail implementasi.  Deskripsi semua fungsi yang dicegat dapat dirakit menjadi sebuah array dan makro dapat digunakan untuk meningkatkan kekompakan kode: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOOK(_name, _function, _original) \ { \ .name = (_name), \ .function = (_function), \ .original = (_original), \ } static struct ftrace_hook hooked_functions[] = { HOOK(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sys_clone"</span></span></span><span class="hljs-meta">, fh_sys_clone, &amp;real_sys_clone), HOOK(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sys_execve"</span></span></span><span class="hljs-meta">, fh_sys_execve, &amp;real_sys_execve), };</span></span></code> </pre><br>  Wrappers over intercepted functions adalah sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *        execve(). *     .      *  :       , *    ABI (  "asmlinkage"). */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">long</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*real_sys_execve)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *      .   —  *   .      *  .      ,  *    . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  Seperti yang Anda lihat, fungsi yang dicegat dengan kode tambahan minimum.  Satu-satunya hal yang membutuhkan perhatian adalah fungsi tanda tangan.  Mereka harus cocok satu lawan satu.  Tanpa ini, tentu saja, argumen akan dilewatkan secara salah dan semuanya akan menurun.  Untuk mencegat panggilan sistem, ini kurang penting, karena penangannya sangat stabil dan, untuk efisiensi, mengambil argumen dalam urutan yang sama dengan panggilan sistem itu sendiri.  Namun, jika Anda berencana untuk mencegat fungsi-fungsi lain, Anda harus ingat bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak ada antarmuka yang stabil di dalam kernel</a> . <br><br><h3>  Inisialisasi Ftrace </h3><br>  Pertama, kita perlu menemukan dan menyimpan alamat fungsi yang akan kita sadap.  Ftrace memungkinkan Anda untuk melacak fungsi berdasarkan nama, tetapi kami masih perlu mengetahui alamat fungsi asli untuk memanggilnya. <br><br>  Anda bisa mendapatkan alamat menggunakan <em>kallsyms</em> - daftar semua karakter di kernel.  Daftar ini mencakup <em>semua</em> karakter, tidak hanya diekspor untuk modul.  Mendapatkan alamat dari fungsi yang dikaitkan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve_hook_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ hook-&gt;address = kallsyms_lookup_name(hook-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hook-&gt;address) { pr_debug(<span class="hljs-string"><span class="hljs-string">"unresolved symbol: %s\n"</span></span>, hook-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOENT; } *((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*) hook-&gt;original) = hook-&gt;address; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Selanjutnya, Anda perlu menginisialisasi struktur <code>ftrace_ops</code> .  Itu mengikat <br>  bidang ini hanya <em>fungsi</em> , menunjukkan panggilan balik, tetapi kita juga perlu <br>  atur beberapa flag penting: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_install_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; err = resolve_hook_address(hook); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; hook-&gt;ops.func = fh_ftrace_thunk; hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS | FTRACE_OPS_FL_IPMODIFY; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre><br>  <em>fh_ftrace_thunk</em> () adalah panggilan balik kami yang akan dipanggil ftrace saat melacak suatu fungsi.  Tentang dia nanti.  Bendera yang kita atur akan diperlukan untuk menyelesaikan intersepsi.  Mereka menginstruksikan ftrace untuk menyimpan dan mengembalikan register prosesor, yang isinya dapat kita ubah dalam panggilan balik. <br><br>  Sekarang kami siap mengaktifkan intersepsi.  Untuk melakukan ini, Anda harus terlebih dahulu mengaktifkan ftrace untuk fungsi yang menarik bagi kami menggunakan ftrace_set_filter_ip (), dan kemudian mengizinkan ftrace untuk memanggil panggilan balik kami menggunakan register_ftrace_function (): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_install_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"ftrace_set_filter_ip() failed: %d\n"</span></span>, err); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } err = register_ftrace_function(&amp;hook-&gt;ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"register_ftrace_function() failed: %d\n"</span></span>, err); <span class="hljs-comment"><span class="hljs-comment">/*    ftrace   . */</span></span> ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Intersepsi dimatikan dengan cara yang sama, hanya dalam urutan terbalik: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_remove_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; err = unregister_ftrace_function(&amp;hook-&gt;ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"unregister_ftrace_function() failed: %d\n"</span></span>, err); } err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"ftrace_set_filter_ip() failed: %d\n"</span></span>, err); } }</code> </pre><br>  Setelah panggilan ke unregister_ftrace_function () selesai, tidak ada aktivasi dari callback yang terinstal dalam sistem (dan dengan itu pembungkus kami) dijamin.  Karena itu, kita dapat, misalnya, dengan aman membongkar modul pencegat, tanpa takut bahwa di suatu tempat dalam sistem fungsi kita masih dilakukan (karena jika hilang, prosesor akan marah). <br><br><h3>  Melakukan kait fungsi </h3><br>  Bagaimana sebenarnya intersepsi dilakukan?  Sangat sederhana.  Ftrace memungkinkan Anda untuk mengubah status register setelah keluar dari panggilan balik.  Dengan mengubah register% rip - sebuah penunjuk ke instruksi yang dapat dieksekusi berikutnya - kita mengubah instruksi yang dijalankan oleh prosesor - yaitu, kita dapat memaksanya untuk menjalankan transisi tanpa syarat dari fungsi saat ini ke fungsi kita.  Jadi kami mengambil kendali. <br><br>  Callback untuk ftrace adalah sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> notrace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_ftrace_thunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hook</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">);</span></span> regs-&gt;ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;function; }</code> </pre><br>  Dengan menggunakan container_of () makro, kami mendapatkan alamat <code>struct ftrace_hook</code> di alamat <code>struct ftrace_hook</code> disematkan di dalamnya, setelah itu kami mengganti nilai register% rip dalam struktur <code>struct pt_regs</code> dengan alamat penangan kami.  Itu saja.  Untuk arsitektur selain x86_64, register ini dapat disebut secara berbeda (seperti IP atau PC), tetapi ide ini pada prinsipnya berlaku untuk mereka. <br><br>  Perhatikan <strong>kualifikasi notrace yang</strong> ditambahkan untuk callback.  Mereka dapat menandai fitur yang tidak boleh dilacak menggunakan ftrace.  Sebagai contoh, ini adalah bagaimana fungsi ftrace itu sendiri yang terlibat dalam proses penelusuran ditandai.  Ini membantu mencegah sistem dari pembekuan dalam loop tanpa akhir ketika melacak semua fungsi di kernel (ftrace dapat melakukan ini). <br><br>  Callback ftback biasanya panggilan dengan ekstrusi dinonaktifkan (seperti kprobes).  Mungkin ada pengecualian, tetapi Anda tidak harus bergantung padanya.  Namun, dalam kasus kami, batasan ini tidak penting, jadi kami hanya mengganti delapan byte dalam struktur. <br><br>  Fungsi wrapper, yang dipanggil nanti, akan dieksekusi dalam konteks yang sama dengan fungsi aslinya.  Oleh karena itu, di sana Anda dapat melakukan apa yang boleh dilakukan dalam fungsi yang dicegat.  Misalnya, jika Anda mencegat penangan interupsi, Anda masih tidak bisa tidur di pembungkus. <br><br><h3>  Perlindungan Panggilan Rekursif </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada tangkapan dalam kode di atas: ketika wrapper kami memanggil fungsi asli, itu lagi masuk ke ftrace, yang lagi-lagi memanggil callback kami, yang lagi-lagi mentransfer kontrol ke wrapper. Rekursi yang tak terbatas ini perlu disingkat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara paling elegan yang terpikir oleh kami adalah menggunakan </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salah satu argumen dari callback ftrace, yang berisi alamat pengirim ke fungsi yang disebut fungsi yang dilacak. Biasanya argumen ini digunakan untuk membuat grafik panggilan fungsi. Kita dapat menggunakannya untuk membedakan panggilan pertama dari fungsi yang dicegat dari yang diulang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memang saat menelepon kembali</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus menunjuk ke dalam pembungkus kami, sementara pada awalnya - di suatu tempat di tempat lain di kernel. </font><font style="vertical-align: inherit;">Kontrol harus ditransfer hanya ketika fungsi pertama kali dipanggil, semua yang lain harus diizinkan untuk menjalankan fungsi aslinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemeriksaan entri dapat dilakukan dengan sangat efisien dengan membandingkan alamat dengan batas-batas modul saat ini (yang berisi semua fungsi kami). </font><font style="vertical-align: inherit;">Ini bekerja dengan baik jika dalam modul hanya pembungkus memanggil fungsi yang dicegat. </font><font style="vertical-align: inherit;">Kalau tidak, Anda harus lebih selektif. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara total, callback ftrace yang benar adalah sebagai berikut:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> notrace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_ftrace_thunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hook</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!within_module(parent_ip, THIS_MODULE)) regs-&gt;ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;function; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fitur / keunggulan khas dari pendekatan ini: </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Overhead rendah. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanya beberapa pengurangan dan perbandingan. </font><font style="vertical-align: inherit;">Tidak ada spinlocks, daftar berlalu, dan sebagainya.</font></font><br></li><li> <strong>   .</strong>         .       ,         . <br></li><li> <strong>   .</strong>     <em>kretprobes</em>         ,     (      ).           ,       . <br></li></ul><br><h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lihat sebuah contoh: Anda mengetik </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perintah ls</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di terminal </font><font style="vertical-align: inherit;">untuk melihat daftar file di direktori saat ini. Shell (katakanlah Bash) menggunakan sepasang fungsi </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fork</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () + </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execve</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">tradisional dari </font><font style="vertical-align: inherit;">pustaka standar C </font><font style="vertical-align: inherit;">untuk memulai proses baru </font><font style="vertical-align: inherit;">. Secara internal, fungsi-fungsi ini diimplementasikan melalui system call </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clone ()</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execve (),</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> masing-masing. Misalkan kita mencegat panggilan sistem execve () untuk mengontrol awal proses baru. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam bentuk grafik, intersepsi fungsi handler terlihat seperti ini: </font></font><br><br><img alt="diagram urutan intersepsi" src="https://habrastorage.org/webt/ok/mm/4x/okmm4xnova8g2nfmx7y60oocuju.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini kita melihat bagaimana proses pengguna ( </font></font><font color="#66B2FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biru</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) membuat panggilan sistem ke kernel ( </font></font><font color="#EA6B66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merah</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), di mana kerangka kerja ftrace ( </font></font><font color="#A680B8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ungu</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) memanggil fungsi dari modul kami ( </font></font><font color="#97D077"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hijau</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><ol><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proses pengguna menjalankan SYSCALL. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan menggunakan instruksi ini, mode kernel ditransfer dan kontrol ditransfer ke pengendali panggilan sistem tingkat rendah - </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entry_SYSCALL_64</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). </font><font style="vertical-align: inherit;">Dia bertanggung jawab untuk semua panggilan sistem dari program 64-bit pada kernel 64-bit.</font></font><br></li><li> <strong>    .</strong>     , <a href="">  </a> ,      <em>do_syscall_64</em> (), <a href="">  </a> .            <code>sys_call_table</code>          —       <em>sys_execve</em> (). <br></li><li> <strong> ftrace.</strong>         <em>__fentry__</em> (),    ftrace.  ,    ,       <em>nop</em> ,      sys_execve()   . <br></li><li> <strong>Ftrace   .</strong>    ftrace     ,   .         ,    %rip,       . <br></li><li> <strong>  .</strong>     <code>parent_ip</code> ,   do_syscall_64() —        sys_execve() —     ,   <em> %rip</em>   <code>pt_regs</code> . <br></li><li> <strong>Ftrace  .</strong>   FTRACE_SAVE_REGS, ftrace      <code>pt_regs</code>   .    ftrace     .     %rip —      —          . <br></li><li> <strong>  -.</strong> -     sys_execve()   .       <em>fh_sys_execve</em> ().           ,                do_syscall_64(). <br></li><li> <strong>   .</strong>          .  fh_sys_execve()        (  )       .        .        — sys_execve()  ,   <em>real_sys_execve</em> ,      . <br></li><li> <strong>  .</strong>      sys_execve(),     ftrace     . ,       -… <br></li><li> <strong>   .</strong>       sys_execve()    fh_sys_execve(),     do_syscall_64().         sys_execve()   .     : ftrace    sys_execve() . <br></li><li> <strong>  .</strong>       sys_execve()      fh_sys_execve().        .   ,    execve()  ,   ,     ,  . . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajemen kembali ke inti. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, fh_sys_execve () selesai dan kontrol berpindah ke do_syscall_64 (), yang menganggap bahwa pemanggilan sistem selesai seperti biasa. </font><font style="vertical-align: inherit;">Inti melanjutkan bisnis nuklirnya.</font></font><br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajemen kembali ke proses pengguna. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, kernel mengeksekusi instruksi IRET (atau SYSRET, tetapi untuk execve () selalu IRET), pengaturan register untuk proses pengguna baru dan menempatkan prosesor pusat ke mode eksekusi kode pengguna. </font><font style="vertical-align: inherit;">Panggilan sistem (dan memulai proses baru) selesai.</font></font><br></li></ol><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keuntungan dan kerugian </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sebagai hasilnya, kami mendapatkan cara yang sangat mudah untuk mencegat fungsi apa pun di kernel, yang memiliki keuntungan sebagai berikut: </font></font><br><br><ul><li> <strong> API   .</strong>        .       ,     ,      .   —   -,    . <br></li><li> <strong>    .</strong>            .   -     ,     ,  ,  - .      (    ),    . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intersepsi kompatibel dengan penelusuran. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jelas, metode ini tidak bertentangan dengan ftrace, jadi Anda masih dapat mengambil indikator kinerja yang sangat berguna dari kernel. </font><font style="vertical-align: inherit;">Menggunakan kprobes atau splicing dapat mengganggu mekanisme ftrace.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa kerugian dari solusi ini? </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persyaratan konfigurasi kernel. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar berhasil melakukan kait fungsi menggunakan ftrace, kernel harus menyediakan sejumlah fitur:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> daftar karakter kallsym untuk mencari fungsi berdasarkan nama </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kerangka kerja ftrace secara umum untuk penelusuran </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ftrace opsi intersepsi kritis </font></font></li></ul><br>                . ,  ,   ,        ,           . ,     -  ,       . <br></li><li> <strong>   ftrace</strong> ,   kprobes (  ftrace    ),   ,   ,  . , <em> ftrace</em> —      ,    «»  ftrace   . <br></li><li> <strong>  .</strong>    ,      . ,         ,  ftrace    . ,         ,       . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ftrace panggilan ganda. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendekatan analisis pointer yang dijelaskan di atas </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menghasilkan panggilan ftrace lagi untuk fungsi terkait. </font><font style="vertical-align: inherit;">Ini menambahkan sedikit overhead dan dapat merobohkan jejak lain yang akan melihat panggilan dua kali lebih banyak. </font><font style="vertical-align: inherit;">Kelemahan ini dapat dihindari dengan menerapkan sedikit ilmu hitam: panggilan ftrace terletak di awal fungsi, jadi jika alamat fungsi asli dipindahkan 5 byte ke depan (panjang instruksi panggilan), maka Anda dapat melompati ftrace.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pertimbangkan beberapa kelemahan secara lebih rinci. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Persyaratan konfigurasi kernel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai permulaan, kernel harus mendukung ftrace dan kallsyms. </font><font style="vertical-align: inherit;">Untuk melakukan ini, opsi berikut harus diaktifkan:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_FTRACE </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_KALLSYMS </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian, ftrace harus mendukung modifikasi register dinamis. </font><font style="vertical-align: inherit;">Opsi bertanggung jawab untuk ini.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_DYNAMIC_FTRACE_WITH_REGS </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, kernel yang digunakan harus didasarkan pada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versi 3.19 atau lebih tinggi</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk memiliki akses ke bendera FTRACE_OPS_FL_IPMODIFY. </font><font style="vertical-align: inherit;">Versi kernel sebelumnya juga dapat mengganti register% rip, tetapi mulai dengan 3.19 ini harus dilakukan hanya setelah mengatur flag ini. </font><font style="vertical-align: inherit;">Kehadiran sebuah flag untuk kernel lama akan menyebabkan kesalahan kompilasi, dan ketiadaannya untuk kernel baru akan mengarah pada intersepsi kosong. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, untuk melakukan intersepsi, lokasi panggilan ftrace sangat penting: panggilan harus ditempatkan di awal, sebelum prolog fungsi (di mana ruang dialokasikan untuk variabel lokal dan bingkai tumpukan dibentuk). </font><font style="vertical-align: inherit;">Fitur arsitektur ini diperhitungkan oleh opsi</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_HAVE_FENTRY </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arsitektur x86_64 mendukung opsi ini, tetapi i386 tidak. </font><font style="vertical-align: inherit;">Karena keterbatasan arsitektur i386, kompiler tidak dapat memasukkan panggilan ftrace sebelum fungsi prolog, oleh karena itu, pada saat ftrace dipanggil, tumpukan fungsi sudah dimodifikasi. </font><font style="vertical-align: inherit;">Dalam hal ini, untuk mencegat, tidak cukup hanya dengan mengubah nilai register% eip - Anda juga harus membalik semua tindakan yang dilakukan dalam prolog yang berbeda dari satu fungsi ke fungsi lainnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena alasan ini, intersepsi ftrace tidak mendukung arsitektur x86 32-bit. </font><font style="vertical-align: inherit;">Pada prinsipnya, ini dapat diimplementasikan dengan bantuan ilmu hitam tertentu (menghasilkan dan melakukan "anti-prolog"), tetapi kemudian kesederhanaan teknis dari solusi akan menderita, yang merupakan salah satu keuntungan menggunakan ftrace.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kejutan yang tidak terlihat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selama pengujian, kami menemukan satu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fitur</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menarik </font><font style="vertical-align: inherit;">: pada beberapa distribusi, fungsi kait menyebabkan sistem macet dengan erat. Tentu, ini hanya terjadi pada sistem selain yang digunakan oleh pengembang. Masalahnya juga tidak mereproduksi pada prototipe intersepsi asli, dengan distribusi dan versi kernel apa pun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debugging menunjukkan bahwa hang terjadi di dalam fungsi yang dicegat. Untuk beberapa alasan mistik, ketika fungsi asli dipanggil di dalam callback ftrace, alamat </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terus ditentukan dalam kode kernel bukan kode fungsi pembungkus. Karena itu, loop tanpa akhir muncul, karena ftrace memanggil pembungkus kami berulang kali tanpa melakukan tindakan yang bermanfaat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untungnya, kami memiliki kode yang berfungsi dan rusak yang kami miliki, sehingga menemukan perbedaan itu hanya masalah waktu. </font><font style="vertical-align: inherit;">Setelah menyatukan kode dan membuang semua yang tidak perlu, perbedaan antara versi dilokalkan ke fungsi wrapper. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi ini berfungsi:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tapi yang ini - mematikan sistem: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_devel(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_devel(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana ternyata tingkat logging mempengaruhi perilaku? Sebuah studi yang hati-hati terhadap kode mesin dari kedua fungsi tersebut dengan cepat mengklarifikasi situasi dan menyebabkan perasaan ketika kompiler disalahkan. Biasanya dia ada di daftar tersangka di suatu tempat di dekat sinar kosmik, tetapi tidak kali ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalahnya, ternyata, adalah bahwa panggilan ke pr_devel () diperluas ke kekosongan. Versi makro printk ini digunakan untuk masuk selama pengembangan. Entri log seperti itu tidak menarik selama operasi, oleh karena itu, mereka secara otomatis dikeluarkan dari kode jika makro DEBUG tidak dideklarasikan. Setelah itu, fungsi untuk kompiler berubah menjadi ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> real_sys_execve(filename, argv, envp); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan di sini optimasi muncul. </font><font style="vertical-align: inherit;">Dalam kasus ini bekerja disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ekor panggilan optimasi</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ekor panggilan optimasi). </font><font style="vertical-align: inherit;">Ini memungkinkan kompiler untuk mengganti panggilan fungsi yang jujur ​​dengan lompatan langsung ke tubuhnya jika satu fungsi memanggil yang lain dan segera mengembalikan nilainya. </font><font style="vertical-align: inherit;">Dalam kode mesin, panggilan jujur ​​terlihat seperti ini:</font></font><br><br><pre> <code class="hljs xml">0000000000000000 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fh_sys_execve</span></span></span><span class="hljs-tag">&gt;</span></span>: 0: e8 00 00 00 00 callq 5 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fh_sys_execve+0x5</span></span></span><span class="hljs-tag">&gt;</span></span> 5: ff 15 00 00 00 00 callq *0x0(%rip) b: f3 c3 repz retq</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan tidak bekerja - seperti ini: </font></font><br><br><pre> <code class="hljs perl"><span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> &lt;fh_sys_execve&gt;: <span class="hljs-number"><span class="hljs-number">0</span></span>: e8 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> callq <span class="hljs-number"><span class="hljs-number">5</span></span> &lt;fh_sys_execve+<span class="hljs-number"><span class="hljs-number">0x5</span></span>&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>b <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> mov <span class="hljs-number"><span class="hljs-number">0x0</span></span>(%rip),%rax c: ff e<span class="hljs-number"><span class="hljs-number">0</span></span> jmpq *%rax</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pernyataan CALL pertama adalah panggilan __fentry __ () yang sama dengan yang dimasukkan oleh kompiler di awal semua fungsi. Tetapi lebih lanjut dalam kode normal, Anda dapat melihat panggilan ke real_sys_execve (dengan penunjuk dalam memori) melalui instruksi CALL dan kembali dari fh_sys_execve () menggunakan instruksi RET. Kode rusak masuk ke fungsi real_sys_execve () langsung menggunakan JMP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimalisasi panggilan ekor memungkinkan Anda menghemat sedikit waktu dalam pembentukan kerangka tumpukan "yang tidak berarti", yang mencakup alamat balik yang disimpan dalam tumpukan dengan instruksi CALL. Namun, bagi kami, kebenaran alamat pengirim memainkan peran penting - kami menggunakannya </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk membuat keputusan tentang intersepsi. Setelah optimasi, fungsi fh_sys_execve () tidak lagi menyimpan alamat pengirim baru di stack, tetap ada yang lama - menunjuk ke kernel. Oleh karena itu</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terus menunjuk ke dalam nukleus, yang akhirnya mengarah pada pembentukan loop tak terbatas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini juga menjelaskan mengapa masalah hanya terjadi pada beberapa distribusi. Saat mengkompilasi modul, distribusi yang berbeda menggunakan set flag kompilasi yang berbeda. Dalam distribusi tertekan, optimisasi panggilan ekor diaktifkan secara default. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi bagi masalah kami adalah menonaktifkan pengoptimalan panggilan ekor untuk seluruh file dengan fungsi wrapper:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> GCC optimize(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"-fno-optimize-sibling-calls"</span></span></span><span class="hljs-meta">)</span></span></code> </pre><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa lagi yang bisa saya katakan ... Mengembangkan kode tingkat rendah untuk kernel Linux itu menyenangkan. </font><font style="vertical-align: inherit;">Saya berharap publikasi ini menghemat sedikit waktu bagi seseorang dalam pergolakan pilihan, apa yang harus digunakan untuk menulis antivirus terbaik Anda di dunia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda ingin bereksperimen dengan intersepsi sendiri, maka kode modul kernel lengkap dapat ditemukan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413241/">https://habr.com/ru/post/id413241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413231/index.html">Pengantar Kontrak Cerdas</a></li>
<li><a href="../id413233/index.html">Layanan uLogin mengirimkan data dari formulir (surat, telepon) ke situs pihak ketiga dan tidak menghiraukannya</a></li>
<li><a href="../id413235/index.html">Bertaruh pada Prediksi yang Lebih Baik: Matematika Baru Prakiraan Cuaca</a></li>
<li><a href="../id413237/index.html">Facebook membantah produsen perangkat mengirimkan data yang sama dengan pengembang Alexander Kogan</a></li>
<li><a href="../id413239/index.html">Cara membuat smartphone sedikit bodoh</a></li>
<li><a href="../id413243/index.html">School of Data: bagaimana menggabungkan matematika dan bisnis</a></li>
<li><a href="../id413245/index.html">Pada peralatan Dolby Atmos - hanya suara "asli". Dolby melarang upmixing non-pribumi</a></li>
<li><a href="../id413247/index.html">Mengapa memonitor sistem penyimpanan?</a></li>
<li><a href="../id413249/index.html">Menulis modul kernel Linux: I2C</a></li>
<li><a href="../id413251/index.html">Reaksi berantai polimer dan Vladivostok</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>