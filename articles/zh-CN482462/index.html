<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏽 🙇🏻 🏇 在10分钟内学习元流 📯 👊🏾 🏙️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Metaflow是在Netflix中创建的Python框架，专注于数据科学领域。 即，它旨在创建旨在处理数据的项目并管理此类项目。 最近，该公司将其转移到开源类别。 在过去的两年中，Metaflow框架已在Netflix内部广泛使用。 特别是，他允许大大减少完成生产项目所需的时间。 

  

 我...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在10分钟内学习元流</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/482462/">  Metaflow是在Netflix中创建的Python框架，专注于数据科学领域。 即，它旨在创建旨在处理数据的项目并管理此类项目。 最近，该公司将其转移到开源类别。 在过去的两年中，Metaflow框架已在Netflix内部广泛使用。 特别是，他允许大大减少完成生产项目所需的时间。 <br><br> <a href="https://habr.com/ru/company/ruvds/blog/482462/"><img src="https://habrastorage.org/webt/yd/2j/7p/yd2j7p_dpzkyrjeef9us6a7pgs4.png"></a> <br><br> 我们今天翻译的材料是Metaflow的快速指南。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">什么是Metaflow？</font> </h2><br> 下图说明了Netflix中Metaflow框架的实现。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6bd/bb8/297/6bdbb82972a098b8fd241f42d7f55b51.png"></div><br>  <i><font color="#999999">Netflix中的Metaflow实施</font></i> <br><br>  2018年11月，该框架在公司的134个项目中使用。 <br><br> 元流是用于创建和执行数据科学工作流的框架。 它具有以下功能： <br><br><ul><li> 计算资源管理。 </li><li> 容器化任务启动。 </li><li> 管理外部依赖项。 </li><li> 版本控制，重新执行任务，继续执行挂起的任务。 </li><li> 客户端API，用于检查可在Jupyter Notebook环境中使用的任务的结果。 </li><li> 支持本地（例如，在笔记本电脑上）和远程（在云中）任务执行。 在这些模式之间切换的能力。 </li></ul><br>  vtuulos用户在Ycombinator上<a href="https://news.ycombinator.com/item%3Fid%3D21698711">写道</a> ，Metaflow可以自动创建代码，数据和依赖项的快照（快照）。 所有这些都放置在按内容编址的存储库中，该内容通常基于S3，尽管也支持本地文件系统。 这样，您可以继续执行已停止的任务，重现以前获得的结果，并浏览与任务相关的所有内容，例如在Jupyter Notebook中。 <br><br> 一般而言，我们可以说Metaflow旨在提高数据科学家的生产力。 之所以如此，是因为该框架允许他们专门从事数据工作，而不会因解决相关任务而分心。 此外，Metaflow加速了基于生产的项目撤出。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d16/311/176/d1631117682028c779664c90bef2a885.png"></div><br>  <i><font color="#999999">数据科学家的需求与其直接职责有关，并且与执行计算的基础结构有关的辅助任务的解决方案</font></i> <br><br><h2>  <font color="#3AC1EF">Metaflow的工作流程方案</font> </h2><br> 您可以使用Metaflow组织以下工作流程方案： <br><br><ul><li>  <b>协同合作</b> 一位数据科学家想要帮助另一位科学家找到错误的根源。 同时，助手希望将崩溃的任务在其中正常工作的整个环境下载到他的计算机上。 </li><li>  <b>从停止的位置继续停止的任务。</b> 某些任务因错误而停止（或有意停止）。 错误已得到纠正（或代码已编辑）。 有必要重新启动任务，以便从失败（或停止）的地方继续工作。 </li><li>  <b>混合任务执行。</b> 有必要在本地执行工作流程的某个步骤（也许这是从存储在计算机文件夹中的文件中下载数据的步骤），并且需要大量计算资源的另一步骤（也许这是在训练模型）应该在云中执行。 </li><li>  <b>检查完成任务后获得的元数据。</b> 三名数据科学家致力于同一模型的超参数的选择，试图提高该模型的准确性。 之后，您需要分析用于训练模型的任务的结果，并选择表现出最好的超参数集。 </li><li>  <b>使用同一软件包的多个版本。</b> 在项目中，您需要使用不同的版本，例如sklearn库。 在预处理期间，需要版本0.20，在建模期间，需要版本0.22。 </li></ul><br><h2>  <font color="#3AC1EF">典型的元流工作流</font> </h2><br> 从概念和编程角度考虑典型的Metaflow工作流程。 <br><br><h3>  <font color="#3AC1EF">Meta从概念上了解Metaflow工作流程</font> </h3><br> 从概念的角度来看，Metaflow工作流（任务链）由有<a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D1%2586%25D0%25B8%25D0%25BA%25D0%25BB%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584">向无环图</a> （DAG）表示。 下面的插图将帮助您更好地理解这个想法。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/584/53d/52e/58453d52e9dfbd50dcc5b974ffae11e1.png"></div><br>  <i><font color="#999999">线性无环图</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d7/a8d/810/3d7a8d81017d4112913a5c081c70b9a8.png"></div><br>  <i><font color="#999999">具有“平行”路径的非循环图</font></i> <br><br> 图的每个节点代表工作流程中的数据处理步骤。 <br><br> 在任务链的每个步骤中，Metaflow都会执行常规的Python代码，而无需进行任何特殊更改。 代码在单独的容器中执行，代码及其相关性打包到这些容器中。 <br><br>  Metaflow体系结构的关键方面在于它使您无需使用插件即可将conda生态系统中的几乎所有外部库实现到基于该库的项目中。 这将Metaflow与其他类似的通用解决方案区分开来。 例如-从气流。 <br><br><h3>  <font color="#3AC1EF">▍在编程方面的Metaflow工作流程</font> </h3><br> 如果每个任务链（流）满足以下最低要求，则可以表示为标准Python类（此类的名称通常带有单词<code>Flow</code> ）。 <br><br><ul><li> 该类是Metaflow FlowSpec类的后代。 </li><li> 代表任务链中步骤的每个函数都应用了<code>@step</code>装饰器。 </li><li> 在每个<code>@step</code>函数的末尾，必须有一个<code>@step</code>在<code>@step</code>的类似函数的指示。 这可以使用以下类型的构造来完成： <code>self.next(self.function_name_here)</code> 。 </li><li> 该类实现<code>start</code>和<code>end</code>函数。 </li></ul><br> 考虑一个由三个节点组成的最小任务链的示例。 <br><br> 她的方案如下所示： <br><br><pre> <code class="python hljs">start → process_message → end</code> </pre> <br> 这是她的代码： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> metaflow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FlowSpec, step <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LinearFlow</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(FlowSpec)</span></span></span><span class="hljs-class">:</span></span>         <span class="hljs-string"><span class="hljs-string">"""     ,      Metaflow.    """</span></span>       <span class="hljs-comment"><span class="hljs-comment">#         @step    def start(self):        self.message = 'Thanks for reading.'        self.next(self.process_message)    @step    def process_message(self):        print('the message is: %s' % self.message)        self.next(self.end)    @step    def end(self):        print('the message is still: %s' % self.message) if __name__ == '__main__':    LinearFlow()</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Metaflow安装说明</font> </h2><br><h3>  <font color="#3AC1EF">and安装与试运行</font> </h3><br> 这是安装和首次启动Metaflow所需执行的步骤序列： <br><br><ul><li> 安装Metaflow（建议使用Python 3）： <code>pip3 install metaflow</code> 。 </li><li> 将上面的代码片段（在GitHub上）放在<code>linear_flow.py</code>文件中。 </li><li> 要查看此代码实现的任务链的体系结构，请使用<code>python3 linear_flow.py show</code>命令。 </li><li> 要启动流，请运行<code>python3 linear_flow.py run</code> 。 </li></ul><br> 您应该获得类似于以下所示的内容。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/5af/ec5/2815afec51573d8a01db3cd8b4ae19e0.png"></div><br>  <i><font color="#999999">成功的Metaflow健康检查</font></i> <br><br> 这里值得注意一些事情。  Metaflow框架创建一个本地<code>.metaflow</code>数据<code>.metaflow</code> 。 在那里，它存储与任务执行相关的所有元数据以及与任务执行会话相关的快照。 如果您配置了与云数据存储相关的Metaflow设置，则快照将存储在AWS S3存储桶中，而与任务启动相关的元数据将转到基于RDS（关系数据存储，关系数据存储）的元数据服务。 稍后，我们将讨论如何使用客户端API探索该元数据。 另一个琐事虽然很重要，但值得注意，但它是附加到不同步骤的进程标识符（pid，进程ID）不同。 记住-我们上面说过，Metaflow独立地将任务链的每个步骤容器化，并在其自己的环境中执行每个步骤（仅在步骤之间传递数据）。 <br><br><h3>  <font color="#3AC1EF">conconda的安装和配置（如果您计划实现依赖关系）</font> </h3><br> 请按照以下步骤安装conda： <br><br><ul><li>  <a href="https://docs.conda.io/en/latest/miniconda.html">下载</a>并安装Miniconda。 </li><li>  <a href="https://docs.conda.io/projects/conda/en/latest/user-guide/concepts/channels.html">使用</a>命令<code>conda config --add channels conda-forge</code>添加- <a href="https://docs.conda.io/projects/conda/en/latest/user-guide/concepts/channels.html">一个conda通道</a> <code>conda config --add channels conda-forge</code> 。 </li></ul><br> 现在您可以在任务链中嵌入conda依赖项了。 该过程的细节将在下面讨论。 <br><br><h2>  <font color="#3AC1EF">现实的工作流程示例</font> </h2><br> 上面，我们讨论了如何安装Metaflow，以及如何确保系统正常运行。 此外，我们讨论了工作流体系结构的基础，并看了一个简单的示例。 在这里，我们看一个更复杂的示例，同时揭示了Metaflow的一些概念。 <br><br><h3>  <font color="#3AC1EF">▍工作</font> </h3><br> 使用Metaflow创建实现以下功能的工作流： <br><br><ul><li> 将CSV电影数据加载到Pandas数据框中。 </li><li> 流派四分位数的并行计算。 </li><li> 保存带有计算结果的字典。 </li></ul><br><h3>  <font color="#3AC1EF">▍任务链</font> </h3><br>  <code>GenreStatsFlow</code>类的框架如下<code>GenreStatsFlow</code> 。 经过分析后，您将了解此处解决问题的方法的实质。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> metaflow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FlowSpec, step, catch, retry, IncludeFile, Parameter <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenreStatsFlow</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(FlowSpec)</span></span></span><span class="hljs-class">:</span></span>  <span class="hljs-string"><span class="hljs-string">"""    ,  ,   .         :    1)  CSV-   Pandas.    2)     .    3)     .  """</span></span>   @step  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-string"><span class="hljs-string">"""         :        1)      Pandas.        2)    .        3)        .    """</span></span>       <span class="hljs-comment"><span class="hljs-comment"># </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">  CSV         self.genres = []    self.next(self.compute_statistics, foreach='genres') #  1     @catch(var='compute_failed') #  2  @retry(times=1) #  3  @step  def compute_statistics(self):    """    .   ."""    self.genre = self.input #  4    # </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">        self.next(self.join)     @step  def join(self, inputs):    """       ."""    # </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">      self.next(self.end)     @step  def end(self):      """End the flow."""      pass   if __name__ == '__main__':  GenreStatsFlow()</span></span></code> </pre> <br> 考虑该示例的一些重要部分。 该代码包含以下形式的注释： <code>#  n</code> 。 <br><br><ul><li> 在<code> 1</code>的<code>start</code>步骤中，请注意<code>foreach</code>参数。 多亏了它， <code>for each</code> <code>genres</code>列表中<code>for each</code>条目的<code>for each</code>循环， <code>compute_statistics</code>了<code>compute_statistics</code>步骤的副本。 </li><li> 在<code> 2</code> <code>@catch(var='compute_failed')</code>装饰器<code>@catch(var='compute_failed')</code>捕获<code>compute_statistics</code>步骤中<code>compute_statistics</code>任何异常，并将其写入<code>compute_failed</code>变量（可在下一步中读取）。 </li><li> 在<code> 3</code> <code>@retry(times=1)</code>装饰器<code>@retry(times=1)</code>确实执行其名称所暗示的功能。 即，当发生错误时，他重复该步骤。 </li><li>  <code> 4</code>中<code>compute_statistics</code> <code>self.input</code> ？ 问题是， <code>input</code>是Metaflow提供的类变量。 它包含适用于<code>compute_statistics</code>特定实例的<code>compute_statistics</code> （当有多个并行执行的函数副本时）。 仅当节点由多个并行进程表示或合并多个节点时，此变量才由Metaflow添加。 </li><li> 这是在parallel- <code>compute_statistics</code>中运行相同功能的<code>compute_statistics</code> 。 但是，如有必要，您可以同时运行彼此不相关的完全不同的功能。 为此，将<code> 1</code>显示的内容更改为<code>self.next(self.func1, self.function2, self.function3)</code> 。 当然，使用这种方法，也将有必要重写<code>join</code>步骤，从而有可能在其上处理各种功能的结果。 </li></ul><br> 这是想象上面的骨架类的方法。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7af/b4b/d00/7afb4bd00f2cea2df0ebf9fff780b8d2.png"></div><br>  <i><font color="#999999">GenreStatsFlow类的可视表示</font></i> <br><br><h3>  <font color="#3AC1EF">▍读取数据文件并传输参数</font> </h3><br><ul><li> 下载<a href="https://www.mediafire.com/file/g9vfu4xxqbs4h2o/movies.csv/file">此</a>电影CSV文件。 </li><li> 现在，您需要为该程序提供支持，以实现将路径动态传输到<code>movie_data</code>文件并将<code>max_genres</code>值动态传输到<code>max_genres</code>的可能性。 外部争论的机制将在这方面帮助我们。  Metaflow允许您使用工作流启动命令中的其他标志将参数传递给程序。 例如，它可能看起来像这样： <code>python3 tutorial_flow.py run --movie_data=path/to/movies.csv --max_genres=5</code> 。 </li><li>  Metaflow为开发人员提供了<code>IncludeFile</code>和<code>Parameter</code>对象，您可以通过它们读取工作流代码中的输入。 我们通过将<code>IncludeFile</code>和<code>Parameter</code>对象分配给类变量来引用传递的<code>Parameter</code> 。 这取决于我们究竟要读取什么-文件或通常的值。 </li></ul><br> 这是从命令行启动时读取传递给程序的参数的代码： <br><br><pre> <code class="python hljs">    movie_data = IncludeFile(<span class="hljs-string"><span class="hljs-string">"movie_data"</span></span>,                             help=<span class="hljs-string"><span class="hljs-string">"The path to a movie metadata file."</span></span>,                             default = <span class="hljs-string"><span class="hljs-string">'movies.csv'</span></span>)                               max_genres = Parameter(<span class="hljs-string"><span class="hljs-string">'max_genres'</span></span>,                help=<span class="hljs-string"><span class="hljs-string">"The max number of genres to return statistics for"</span></span>,                default=<span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">con将conda包含在任务链中</font> </h3><br><ul><li> 如果尚未安装conda，请参阅本文中有关安装和配置conda的部分。 </li><li> 将<code>GenreStatsFlow</code>提供的<code>GenreStatsFlow</code>装饰器添加到GenreStatsFlow类中。 该装饰器期望获得python版本。 它既可以在代码中设置，也可以使用辅助功能获得。 下面的代码演示了装饰器的用法，并显示了一个辅助函数。 <br><br><pre> <code class="plaintext hljs">def get_python_version():    """     ,    python,       .         conda        python.    """    import platform    versions = {'2' : '2.7.15',                '3' : '3.7.4'}    return versions[platform.python_version_tuple()[0]] #       python. @conda_base(python=get_python_version()) class GenreStatsFlow(FlowSpec):</code> </pre> </li><li> 现在，您可以将<code>@conda</code>装饰器添加到任务链中的任何步骤。 它期望一个具有依赖关系的对象，该对象通过<code>libraries</code>参数传递给它。 在开始该步骤之前，Metaflow将承担准备具有指定依赖项的容器的任务。 如果需要，您可以在不同的步骤中安全地使用不同版本的软件包，因为Metaflow在单独的容器中启动每个步骤。 <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">    @conda(libraries={'pandas' : '0.24.2'})    @step    def start(self):</span></span></code> </pre> </li><li> 现在执行以下命令： <code>python3 tutorial_flow.py --environment=conda run</code> 。 </li></ul><br><h3>  <font color="#3AC1EF">▍步骤实施开始</font> </h3><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@conda(libraries={'pandas' : '0.24.2'})    @step    def start(self):    """         :        1)      Pandas.        2)    .        3)        .    """        import pandas        from io import StringIO        #      Pandas.        self.dataframe = pandas.read_csv(StringIO(self.movie_data))        #   'genres'      .         #   .        self.genres = {genre for genres \                       in self.dataframe['genres'] \                       for genre in genres.split('|')}        self.genres = list(self.genres)        #        .        #  'foreach'             #          self.next(self.compute_statistics, foreach='genres')</span></span></code> </pre> <br> 考虑一下此代码的一些功能： <br><br><ul><li> 请注意，pandas import表达式位于描述该步骤的函数内。 事实是，conda仅在此步骤的范围内引入了这种依赖性。 </li><li> 但是，即使在此步骤之后执行的步骤代码中，此处声明的变量（ <code>dataframe</code>和<code>genres</code> ）仍然可用。 关键是，Metaflow在分离代码执行环境的原理的基础上工作，但允许数据自然地在任务链的各个步骤之间移动。 </li></ul><br><h3>  <font color="#3AC1EF">▍执行compute_statistics步骤</font> </h3><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@catch(var='compute_failed')    @retry    @conda(libraries={'pandas' : '0.25.3'})    @step    def compute_statistics(self):        """            .        """        #             # 'input'.        self.genre = self.input        print("Computing statistics for %s" % self.genre)        #         ,         #        .        selector = self.dataframe['genres'].\                   apply(lambda row: self.genre in row)        self.dataframe = self.dataframe[selector]        self.dataframe = self.dataframe[['movie_title', 'genres', 'gross']]        #     gross   .        points = [.25, .5, .75]        self.quartiles = self.dataframe['gross'].quantile(points).values        #  ,    .        self.next(self.join)</span></span></code> </pre> <br> 请注意，在此步骤中，我们引用在上一个<code>start</code>步骤中声明的<code>dataframe</code>变量。 我们正在修改此变量。 在继续进行下一步时，此方法（意味着使用新的修改后的<code>dataframe</code>对象）使您可以组织有效的数据工作。 <br><br><h3>  <font color="#3AC1EF">▍实施加入步骤</font> </h3><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@conda(libraries={'pandas' : '0.25.3'})    @step    def join(self, inputs):        """               .        """        inputs = inputs[0:self.max_genres]        #   ,    .        self.genre_stats = {inp.genre.lower(): \                            {'quartiles': inp.quartiles,                             'dataframe': inp.dataframe} \                            for inp in inputs}        self.next(self.end)</span></span></code> </pre> <br> 这里值得强调以下几点： <br><br><ul><li> 在此步骤中，我们使用完全不同版本的pandas库。 </li><li>  <code>inputs</code>数组中的每个元素都是先前执行的<code>compute_statistics</code>的副本。 它包含相应功能运行的状态，即各种变量的值。 因此， <code>input[0].quartiles</code>可以包含<code>comedy</code>类型的四分位数，而<code>input[1].quartiles</code> <code>input[0].quartiles</code>可以包含<code>sci-fi</code>类型的四分位数。 </li></ul><br><h3>  <font color="#3AC1EF">▍准备项目</font> </h3><br> 我们刚刚审查过的完整项目代码可以在<a href="https://github.com/Viveckh/metaflow_crash_course_prep/blob/master/tutorial_flow.py">这里</a>找到。 <br><br> 为了查看<code>tutorial_flow.py</code>文件中描述的工作流程如何工作，您需要运行以下命令： <br><br><pre> <code class="python hljs">python3 tutorial_flow.py --environment=conda show</code> </pre> <br> 使用以下命令启动工作流程： <br><br><pre> <code class="python hljs">python3 tutorial_flow.py --environment=conda run --movie_data=path/to/movies.csv --max_genres=<span class="hljs-number"><span class="hljs-number">7</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">检查使用客户端API运行工作流的结果</font> </h2><br> 为了检查数据快照和工作流先前启动的状态，您可以使用Metaflow提供的客户端<a href="https://docs.metaflow.org/metaflow/client">API</a> 。 该API非常适合探索在Jupyter Notebook环境中执行的实验的详细信息。 <br><br> 这是从最后一次成功启动<code>GenreStatsFlow</code>的数据中获取的<code>genre_stats</code>变量输出的简单示例。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> metaflow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Flow, get_metadata <span class="hljs-comment"><span class="hljs-comment">#      print("Using metadata provider: %s" % get_metadata()) #     MovieStatsFlow. run = Flow('GenreStatsFlow').latest_successful_run print("Using analysis from '%s'" % str(run)) genre_stats = run.data.genre_stats print(genre_stats)</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">在云中运行工作流程</font> </h2><br> 在常规计算机上创建并测试工作流之后，很可能希望在云中运行代码以加快工作速度。 <br><br> 当前，Metaflow仅支持与AWS集成。 在下图中，您可以看到Metaflow使用的内部部署和云资源的映射。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08a/acc/458/08aacc458fc3202ec08624422bef0cb4.png"></div><br>  <i><font color="#999999">元流和AWS集成</font></i> <br><br> 要将Metaflow连接到AWS，您必须完成以下步骤： <br><br><ul><li> 首先，您需要通过创建Metaflow可以使用的资源来进行一次AWS设置。 例如，工作团队的成员可以使用相同的资源，他们可以互相演示工作流程的结果。  <a href="https://docs.metaflow.org/metaflow-on-aws/deploy-to-aws">您</a>可以在此处找到相关说明。 设置速度足够快，因为Metaflow具有CloudFormation设置模板。 </li><li> 接下来，在本地计算机上，您需要运行<code>metaflow configure aws</code>并输入系统问题的答案。 有了这些数据，Metaflow将能够使用基于云的数据仓库。 </li><li> 现在，要在云中启动本地工作流，只需在工作流开始<code>--with batch</code>添加<code>--with batch</code>键即可。 例如，它可能看起来像这样： <code>python3 sample_flow.py run --with batch</code> 。 </li><li> 为了执行工作流的混合启动，也就是说，要在本地执行某些步骤，并在云中执行某些步骤，您需要将<code>@batch</code>装饰器添加到需要在云中执行的那些步骤。 例如，像这样： <code>@batch(cpu=1, memory=500)</code> 。 </li></ul><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 在这里，我想指出一些Metaflow功能，这些功能既可以考虑该框架的优点，也可以考虑其缺点： <br><br><ul><li>  Metaflow与AWS紧密集成。 但是在框架开发计划中，有对大量云提供商的支持。 </li><li>  Metaflow是仅支持命令行界面的工具。 它没有图形界面（不同于其他用于组织工作流程的通用框架，例如Airflow）。 </li></ul><br>  <b>亲爱的读者们！</b> 您打算使用Metaflow吗？ <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN482462/">https://habr.com/ru/post/zh-CN482462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN482450/index.html">MVP已成长为产品或我在MVP中的经验（2019年）</a></li>
<li><a href="../zh-CN482452/index.html">巴西体系不是神话。 如何在IT中使用？</a></li>
<li><a href="../zh-CN482456/index.html">我们的FunCode，或我们如何举办iOS开发者竞赛</a></li>
<li><a href="../zh-CN482458/index.html">我不知道的5种Python功能-但徒劳无功</a></li>
<li><a href="../zh-CN482460/index.html">SQL HowTo：在SQL中绘制冷淡的模式</a></li>
<li><a href="../zh-CN482464/index.html">Python中的* args和** kwargs是什么？</a></li>
<li><a href="../zh-CN482466/index.html">您可以为Vue 3.0做准备的5件事</a></li>
<li><a href="../zh-CN482468/index.html">VS Code的5个扩展和主题可以改变前端开发人员的生活</a></li>
<li><a href="../zh-CN482470/index.html">在最简单的廉价手机上快速加载页面</a></li>
<li><a href="../zh-CN482472/index.html">JavaScript是由什么制成的？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>