<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇüèæ üç´ üë®üèø‚Äçü§ù‚Äçüë®üèæ Serializaci√≥n y deserializaci√≥n de .NET Core vs Go Data ü•™ üöõ üöµüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola% username% 


 Mi tarea era comparar el rendimiento de serializaci√≥n para .NET Core y Golang. Despu√©s de buscar en Internet, me encontr√© con un r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serializaci√≥n y deserializaci√≥n de .NET Core vs Go Data</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/homecredit/blog/469271/"><p>  Hola% username% </p><br><p>  Mi tarea era comparar el rendimiento de serializaci√≥n para .NET Core y Golang.  Despu√©s de buscar en Internet, me encontr√© con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> .  Se considera un ejemplo simple de un microservicio REST.  Esto es exactamente lo que necesito, pens√©.  Despu√©s de ver los resultados de la prueba, me sorprendi√≥.  Despu√©s de mirar el c√≥digo fuente, me di cuenta de lo que estaba mal.  Esto es lo que no me gust√≥: </p><br><ul><li>  Para la serializaci√≥n y deserializaci√≥n, se selecciona una matriz de 3 elementos.  Esto claramente no es suficiente. </li><li>  Para Golang, no se utilizan todas las caracter√≠sticas del lenguaje, pero, como saben, la biblioteca incorporada de codificaci√≥n / json es lenta. </li><li>  Como resultado, el autor compara el rendimiento de los servidores web kestrel y net / http. </li></ul><br><p>  Fueron estas deficiencias las que llevaron a una consideraci√≥n m√°s detallada del rendimiento en el marco del ejemplo descrito anteriormente.  Espero que les resulte interesante conocer los resultados. </p><a name="habracut"></a><br><h3 id="sostav-i-opisanie-po">  Composici√≥n y descripci√≥n del software. </h3><br><p>  El c√≥digo fuente del repositorio anterior tambi√©n se tom√≥ como base.  Lo que se ha finalizado: </p><br><ul><li>  Para la API del servidor, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/valyala/fast">se</a> usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/valyala/fast">fasthttp</a> . </li><li>  El servidor API responde con matrices de registros. </li><li>  Cada cliente tiene varios m√©todos para verificar. </li></ul><br><p>  El c√≥digo modificado est√° disponible en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> . </p><br><p>  Para mayor claridad, un ejemplo de respuesta JSON de la API del servidor: </p><br><pre><code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>:<span class="hljs-string"><span class="hljs-string">"id_8299119732867115081"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>:<span class="hljs-string"><span class="hljs-string">"name_5541535679032008745"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Time"</span></span>:<span class="hljs-number"><span class="hljs-number">1566731141</span></span> }, ... { <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>:<span class="hljs-string"><span class="hljs-string">"id_2804604318195309547"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>:<span class="hljs-string"><span class="hljs-string">"name_5914011395631118540"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Time"</span></span>:<span class="hljs-number"><span class="hljs-number">1566731142</span></span> } ]</code> </pre> <br><h3 id="klienty">  Los clientes </h3><br><p>  Para evaluar el rendimiento en cada servicio, se implementan tres m√©todos: </p><br><ul><li>  recibir datos de la API del servidor y enviarlos sin procesar [/ testNoProcess]. </li><li>  recibir datos de la API del servidor: deserializaci√≥n, serializaci√≥n mediante reflexi√≥n y env√≠o [/ testReflection].  Para .NETCore, se utiliz√≥ el paquete Newtonsoft.Json, para Golang, se utiliz√≥ la codificaci√≥n / json. </li><li>  recibir datos de la API del servidor: deserializaci√≥n, serializaci√≥n sin usar reflexi√≥n y env√≠o [/ testNoReflection].  Para .NETCore, se implement√≥ una soluci√≥n basada en Span para minimizar el n√∫mero de asignaciones de memoria.  Golang tiene una soluci√≥n lista para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usar: la</a> biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">easyjson</a> , que ha demostrado ser exclusivamente positiva. </li></ul><br><p>  Con base en estas pruebas, puede evaluar el rendimiento relativo de los servidores web (kestrel y net / http), la ca√≠da del rendimiento cuando se procesan datos utilizando la reflexi√≥n y sin ella para implementaciones en ambos idiomas. </p><br><h3 id="opisanie-metodiki-testirovaniya">  Descripci√≥n de la metodolog√≠a de prueba. </h3><br><p>  Las pruebas se llevaron a cabo en varias etapas para evaluar el rendimiento de cada idioma y cada implementaci√≥n. <br>  Para crear una carga, se seleccion√≥ la utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bombardero</a> .  La utilidad se lanz√≥ con los siguientes par√°metros: -c 125 ‚Äìd 120s, que se pueden interpretar de la siguiente manera: c√≥mo usar 125 subprocesos con un tiempo de prueba de 120 segundos. </p><br><p>  La medici√≥n del rendimiento se realiz√≥ en 3 etapas: </p><br><ol><li>  Dimensi√≥n del servidor API RPS.  Las mediciones se llevaron a cabo para poder evaluar la influencia de los m√©todos de procesamiento en el rendimiento de cada m√©todo. </li><li>  Medici√≥n de RPS del procesamiento de respuesta mediante reflexi√≥n. </li><li>  Mida el procesamiento de respuesta RPS sin usar la reflexi√≥n. </li></ol><br><p>  Sobre la base de estas mediciones, se obtuvieron datos sobre el rendimiento del procesamiento de la respuesta.  La utilizaci√≥n de todos los n√∫cleos de procesador fue del 99,8-100%.  Para la evaluaci√≥n, se seleccionaron los datos iniciales de 10, 30, 100 y 500 registros.  Las matrices de 500 registros en producci√≥n no son comunes, pero estaba interesado en ver c√≥mo se comporta cada uno de los idiomas. </p><br><h3 id="testovyy-stend">  Banco de pruebas </h3><br><p>  Todas las pruebas se ejecutaron en una m√°quina virtual que ejecuta Ubuntu Server 18.04 con todas las actualizaciones para agosto de 2019.  Tiene las siguientes caracter√≠sticas: </p><br><ul><li>  Procesador Core I7-3770K - 4 n√∫cleos. </li><li>  RAM - 4 GB. </li></ul><br><p>  Para la comparaci√≥n de rendimiento, se instalaron .NET Core 2.2 y Golang 1.12. </p><br><p>  Bueno, ahora es el momento de pasar a lo m√°s interesante: los resultados. </p><br><h3 id="rezultaty">  Resultados </h3><br><p>  A continuaci√≥n se muestra una tabla con los resultados de la prueba. </p><br><p><img src="https://habrastorage.org/webt/y7/0o/qa/y70oqawydgs0k7dieoumddehicc.png" alt="alt text" title="Tabla 1. Tabla resumen de resultados de la prueba."></p><br><p>  Puede notar de inmediato que Golang tiene un servidor web m√°s productivo.  La diferencia es de aproximadamente el 12% en comparaci√≥n con Kestrel en .NET Core. <br>  En base a los datos anteriores, se construyeron 2 gr√°ficos.  A continuaci√≥n, puede ver claramente la comparaci√≥n de RPS. </p><br><p><img src="https://habrastorage.org/webt/jt/ow/rp/jtowrpsxtiidgccxehrh7qkq1t8.png" alt="alt text" title="Figura 1. Comparaci√≥n de RPS"></p><br><p>  Debido a la biblioteca net / http m√°s r√°pida, Golang muestra buenos resultados para datos peque√±os.  Con un aumento en el volumen de datos, el rendimiento se compara con el cern√≠calo. </p><br><p>  Cuando se utiliza la reflexi√≥n en un tama√±o de datos peque√±o, el RPS es aproximadamente el mismo, teniendo en cuenta el error de medici√≥n.  Al aumentar el tama√±o de los datos, .NET Core muestra m√°s RPS. </p><br><p>  Al probar sin el uso de la reflexi√≥n, ambos idiomas mostraron una ganancia de rendimiento.  Golang muestra un mejor rendimiento porque inicialmente tiene un mayor RPS (solicitudes por segundo) en las pruebas sin procesamiento.  En datos peque√±os, la ventaja es significativa.  Con el aumento en el tama√±o de los datos, RPS casi se compara.  En la mayor prueba de 500 registros, Golang est√° nuevamente por delante. </p><br><p><img src="https://habrastorage.org/webt/jd/6f/rq/jd6frqyzi1unjzhiicpbibm8dkw.png" alt="alt text" title="Figura 2. Comparaci√≥n de la degradaci√≥n del rendimiento durante el procesamiento JSON, menos es mejor."></p><br><p>  En las pruebas que utilizan la reflexi√≥n, Golang perdi√≥ en todos los frentes.  La ca√≠da del rendimiento en los peores escenarios fue superior al 60%.  Implementar la serializaci√≥n fuera de la caja para el rendimiento generalmente no tiene valor. <br>  Sin reflexionar, Golang fue m√°s r√°pido en todas las pruebas.  Y con el crecimiento de los datos, la ventaja de Golang solo est√° creciendo.  En cualquier caso, la negativa a utilizar la reflexi√≥n proporciona un aumento significativo del rendimiento tanto para Golang como para .NETCore, que, en general, deber√≠a esperarse. </p><br><h3 id="vyvody">  Conclusiones </h3><br><p>  ¬øQu√© conclusiones se pueden sacar de esta peque√±a comparaci√≥n de rendimiento?  Me gustar√≠a formular esto en forma de pros y contras para cada una de las soluciones.  Comencemos con Golang: </p><br><ul><li>  Tiene un mejor rendimiento y se puede mejorar a√∫n m√°s, por ejemplo, mediante el uso de fasthttp como servidor web. </li><li>  Gracias a la generaci√≥n de c√≥digo: uso conveniente de los m√©todos de procesamiento sin usar la reflexi√≥n. </li><li>  Menos consumo de memoria. </li></ul><br><p>  .NET Core tambi√©n tiene varias ventajas: </p><br><ul><li>  El rendimiento es adecuado para la mayor√≠a de los casos. </li><li>  En mi opini√≥n, este es uno de los mejores y m√°s convenientes entornos de desarrollo para Visual Studio. </li></ul><br><p>  El resultado se puede resumir de la siguiente manera: si tiene una API REST y est√° planeando una gran carga, l√≥gica empresarial no demasiado complicada, es mejor usar Golang, en otros casos, puede hacerlo con .NET Core.  ¬øDebo reescribir soluciones preparadas de .NET Core a Golang?  Todos decidir√°n por s√≠ mismos. </p><br><p>  Espero que encuentres √∫til este material.  Todo bien </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/469271/">https://habr.com/ru/post/469271/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../469257/index.html">Integramos comandos de Linux en Windows usando PowerShell y WSL</a></li>
<li><a href="../469259/index.html">Cambio clim√°tico: analizamos la temperatura en diferentes ciudades durante los √∫ltimos 100 a√±os.</a></li>
<li><a href="../469263/index.html">¬øPor qu√© es bueno el karma en Habr√©?</a></li>
<li><a href="../469265/index.html">Acceso multiprocesador Intel Neural Computer Stick a trav√©s de REST</a></li>
<li><a href="../469267/index.html">Manejo de llamadas del sistema usando LD_PRELOAD con un solo punto de entrada</a></li>
<li><a href="../469275/index.html">Como hice en 18 universidades de EE. UU.</a></li>
<li><a href="../469277/index.html">¬øQui√©nes son DevOps?</a></li>
<li><a href="../469287/index.html">Battle Golems de las cartas. C√≥mo convertimos el juego en la Liga de cartas Parobot</a></li>
<li><a href="../469289/index.html">¬øQu√© es el comercio de margen en el intercambio y c√≥mo funciona?</a></li>
<li><a href="../469291/index.html">Inicializaci√≥n y operaci√≥n del int√©rprete de bytecode en JVM HotSpot bajo x86</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>