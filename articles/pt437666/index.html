<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïé üñ®Ô∏è üèûÔ∏è Anunciando a visualiza√ß√£o do F # 4.6 üìâ üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø üí¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Temos o prazer de anunciar que o Visual Studio 2019 enviar√° uma nova vers√£o do F # quando for lan√ßado: F # 4.6! 


 O F # 4.6 √© uma atualiza√ß√£o menor ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anunciando a visualiza√ß√£o do F # 4.6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/437666/"><img align="left" width="200" src="https://habrastorage.org/webt/zh/zi/wx/zhziwxp-1d-vh9pn0kioaevu0kg.png"><p>  Temos o prazer de anunciar que o Visual Studio 2019 enviar√° uma nova vers√£o do F # quando for lan√ßado: F # 4.6! </p><br><p>  O F # 4.6 √© uma atualiza√ß√£o menor para o idioma F #, tornando-o um lan√ßamento de ponto "verdadeiro".  Como nas vers√µes anteriores do F #, o F # 4.6 foi desenvolvido inteiramente por meio de um processo RFC (solicita√ß√µes de coment√°rios) aberto.  A comunidade F # ofereceu feedback muito detalhado nas discuss√µes para esta vers√£o do idioma.  Voc√™ pode ver todos os RFCs que correspondem a esta vers√£o aqui: </p><br><ul><li>  <a href="">RFCs F # 4.6</a> </li><li>  <a href="">FSharp.Core 4.6.0 RFCs</a> </li></ul><br><p>  Esta postagem detalhar√° o conjunto de recursos e como come√ßar. </p><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Original no blog</a> <br><br><h2>  Come√ßar </h2><br><p>  Primeiro, instale: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A visualiza√ß√£o do .NET SDK 2.1.6xx ou 2.2.6xx do .NET SDK</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visual Studio 2019 Visualiza√ß√£o 2</a> </li></ul><br><p>  Em seguida, atualize sua depend√™ncia do FSharp.Core para FSharp.Core 4.6 (ou superior).  Se voc√™ estiver usando o Visual Studio, poder√° fazer isso com a interface do usu√°rio do NuGet Package Management.  Se voc√™ n√£o estiver usando o Visual Studio, ou preferir editar arquivos de projeto manualmente, adicione-o ao arquivo de projeto: </p><br><pre><code class="cpp hljs">&lt;ItemGroup&gt; &lt;PackageReference Update=<span class="hljs-string"><span class="hljs-string">"FSharp.Core"</span></span> Version=<span class="hljs-string"><span class="hljs-string">"4.6.0"</span></span> /&gt; &lt;/ItemGroup&gt;</code> </pre> <br><p>  Depois de instalar os bits necess√°rios, voc√™ pode usar o F # 4.6 com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visual Studio</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visual Studio para Mac</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visual Studio Code com Ionide</a> . </p><br><h2>  Registros an√¥nimos </h2><br><p>  Al√©m de v√°rias corre√ß√µes de bugs, a √∫nica altera√ß√£o de idioma no F # 4.6 √© a introdu√ß√£o dos <a href="">tipos de Registro An√¥nimo</a> . </p><br><h3>  Uso b√°sico </h3><br><p>  De uma perspectiva F #, os Registros An√¥nimos s√£o tipos de registros F # que n√£o t√™m nomes expl√≠citos e podem ser declarados em um est√°gio ad-hoc.  Embora seja improv√°vel que alterem fundamentalmente a maneira como voc√™ escreve c√≥digo F #, eles preenchem muitas lacunas menores encontradas pelos programadores ao longo do tempo e podem ser usados ‚Äã‚Äãpara manipula√ß√£o sucinta de dados que n√£o era poss√≠vel anteriormente. </p><br><p>  Eles s√£o bastante f√°ceis de usar.  Por exemplo, aqui como voc√™ pode interagir com uma fun√ß√£o que produz um registro an√¥nimo: </p><br><pre> <code class="cpp hljs">open System let circleStats radius = let d = radius * <span class="hljs-number"><span class="hljs-number">2.0</span></span> let a = Math.PI * (radius ** <span class="hljs-number"><span class="hljs-number">2.0</span></span>) let c = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * Math.PI * radius {| Diameter=d; Area=a; Circumference=c |} let r = <span class="hljs-number"><span class="hljs-number">2.0</span></span> let stats = circleStats r printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference</code> </pre> <br><p>  No entanto, eles podem ser usados ‚Äã‚Äãpara mais do que apenas cont√™ineres de dados b√°sicos.  A seguir, expande a amostra anterior para usar uma fun√ß√£o de impress√£o mais segura para tipos: </p><br><pre> <code class="cpp hljs">let circleStats radius = let d = radius * <span class="hljs-number"><span class="hljs-number">2.0</span></span> let a = Math.PI * (radius ** <span class="hljs-number"><span class="hljs-number">2.0</span></span>) let c = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * Math.PI * radius {| Diameter=d; Area=a; Circumference=c |} let printCircleStats r (stats: {| Area: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>; Circumference: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>; Diameter: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> |}) = printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference let r = <span class="hljs-number"><span class="hljs-number">2.0</span></span> let stats = circleStats r printCircleStats r stats</code> </pre> <br><p>  Se voc√™ tentar chamar `printCircleStats` com um registro an√¥nimo que tenha os mesmos tipos de dados subjacentes, mas r√≥tulos diferentes, ele falhar√° ao compilar: </p><br><pre> <code class="cpp hljs">printCircleStats r {| Diameter=<span class="hljs-number"><span class="hljs-number">2.0</span></span>; Area=<span class="hljs-number"><span class="hljs-number">4.0</span></span>; MyCircumference=<span class="hljs-number"><span class="hljs-number">12.566371</span></span> |} <span class="hljs-comment"><span class="hljs-comment">// Two anonymous record types have mismatched sets of field names '["Area"; "Circumference"; "Diameter"]' and '["Area"; "Diameter"; "MyCircumference"]'</span></span></code> </pre> <br><p>  √â exatamente assim que os tipos de registro F # funcionam, exceto que tudo foi declarado ad-hoc, e n√£o antecipadamente.  Isso tem vantagens e desvantagens, dependendo da sua situa√ß√£o espec√≠fica, por isso recomendamos o uso criterioso de registros an√¥nimos, em vez de substituir todas as suas declara√ß√µes iniciais de registros F #. </p><br><h3>  Estruturar registros an√¥nimos </h3><br><p>  Os registros an√¥nimos tamb√©m podem ser estruturas usando a palavra-chave <em>struct</em> : </p><br><pre> <code class="cpp hljs">open System let circleStats radius = let d = radius * <span class="hljs-number"><span class="hljs-number">2.0</span></span> let a = Math.PI * (radius ** <span class="hljs-number"><span class="hljs-number">2.0</span></span>) let c = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * Math.PI * radius <span class="hljs-comment"><span class="hljs-comment">// Note that the keyword comes before the '{| |}' brace pair struct {| Area=a; Circumference=c; Diameter=d |} // the 'struct' keyword also comes before the '{| |}' brace pair when declaring the parameter type let printCircleStats r (stats: struct {| Area: float; Circumference: float; Diameter: float |}) = printfn "Circle with radius: %f has diameter %f, area %f, and circumference %f" r stats.Diameter stats.Area stats.Circumference let r = 2.0 let stats = circleStats r printfn "Circle with radius: %f has diameter %f, area %f, and circumference %f" r stats.Diameter stats.Area stats.Circumference</span></span></code> </pre> <br><p>  Voc√™ pode chamar uma fun√ß√£o que usa um registro an√¥nimo struct pode ser feita explicitamente da seguinte maneira: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">let printCircleStats </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stats: struct {| Area: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Circumference: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Diameter: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> |})</span></span></span><span class="hljs-function"> </span></span>= printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference printCircleStats r <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span>| Area=<span class="hljs-number"><span class="hljs-number">4.0</span></span>; Circumference=<span class="hljs-number"><span class="hljs-number">12.6</span></span>; Diameter=<span class="hljs-number"><span class="hljs-number">12.6</span></span> |}</code> </pre> <br><p>  Ou voc√™ pode usar a "infer√™ncia da estrutura" para eliminar o `struct` no site da chamada: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">let printCircleStats </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stats: struct {| Area: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Circumference: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Diameter: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> |})</span></span></span><span class="hljs-function"> </span></span>= printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference printCircleStats r {| Area=<span class="hljs-number"><span class="hljs-number">4.0</span></span>; Circumference=<span class="hljs-number"><span class="hljs-number">12.6</span></span>; Diameter=<span class="hljs-number"><span class="hljs-number">12.6</span></span> |}</code> </pre> <br><p>  Isso tratar√° a inst√¢ncia do registro an√¥nimo que voc√™ criou como se fosse uma estrutura. </p><br><p>  Observe que o inverso n√£o √© verdadeiro: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">let printCircleStats </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stats: {| Area: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Circumference: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Diameter: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> |})</span></span></span><span class="hljs-function"> </span></span>= printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference <span class="hljs-comment"><span class="hljs-comment">// This will fail to compile for hopefully obvious reasons! printCircleStats r struct {| Area=4.0; Circumference=12.6; Diameter=12.6 |}</span></span></code> </pre> <br><p>  Atualmente, n√£o √© poss√≠vel definir os tipos de registro an√¥nimo <em>IsByRefLike</em> ou <em>IsReadOnly</em> struct.  H√° uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sugest√£o de linguagem</a> que prop√µe esse aprimoramento, mas devido a peculiaridades na sintaxe, ele ainda est√° em discuss√£o. </p><br><h3>  Levando as coisas adiante </h3><br><p>  Registros an√¥nimos podem ser usados ‚Äã‚Äãem um conjunto mais amplo de contextos mais avan√ßados. </p><br><h4>  Registros an√¥nimos s√£o serializ√°veis </h4><br><p>  Voc√™ pode serializar e desserializar registros an√¥nimos: </p><br><pre> <code class="cpp hljs">open Newtonsoft.Json let phillip = {| name=<span class="hljs-string"><span class="hljs-string">"Phillip"</span></span>; age=<span class="hljs-number"><span class="hljs-number">28</span></span> |} let str = JsonConvert.SerializeObject(phillip) printfn <span class="hljs-string"><span class="hljs-string">"%s"</span></span> str let phillip' = JsonConvert.DeserializeObject&lt;{|name: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; age: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>|}&gt;(str) printfn <span class="hljs-string"><span class="hljs-string">"Name: %s Age: %d"</span></span> phillip<span class="hljs-string"><span class="hljs-string">'.name phillip'</span></span>.age</code> </pre> <br><p>  Isso gera o que voc√™ pode esperar: </p><br><pre> <code class="cpp hljs">{<span class="hljs-string"><span class="hljs-string">"age"</span></span>:<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-string"><span class="hljs-string">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Phillip"</span></span>} Name: Phillip Age: <span class="hljs-number"><span class="hljs-number">28</span></span></code> </pre> <br><p>  Aqui est√° uma biblioteca de exemplo que tamb√©m √© chamada em outro projeto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> AnonyRecdOne open Newtonsoft.Json <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> AR = let serialize () = let phillip = {| name=<span class="hljs-string"><span class="hljs-string">"Phillip"</span></span>; age=<span class="hljs-number"><span class="hljs-number">28</span></span> |} JsonConvert.SerializeObject(phillip)</code> </pre> <br><pre> <code class="cpp hljs">open AnonyRecdOne open Newtonsoft.Json [&lt;EntryPoint&gt;] let main _ = let str = AR.serialize () let phillip = JsonConvert.DeserializeObject&lt;{|name: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; age: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>|}&gt;(str) printfn <span class="hljs-string"><span class="hljs-string">"Name: %s Age: %d"</span></span> phillip.name phillip.age</code> </pre> <br><p>  Isso pode facilitar as coisas para cen√°rios como dados leves passando por uma rede em um sistema composto por microsservi√ßos. </p><br><h4>  Registros an√¥nimos podem ser combinados com outras defini√ß√µes de tipo </h4><br><p>  Voc√™ pode ter um modelo de dados semelhante a uma √°rvore em seu dom√≠nio, como o exemplo a seguir: </p><br><pre> <code class="cpp hljs">type FullName = { FirstName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; LastName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } type Employee = | Engineer of FullName | Manager of name: FullName * reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> | Executive of name: FullName * reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> * assistant: Employee</code> </pre> <br><p>  √â comum ver casos modelados como tuplas com campos de uni√£o nomeados, mas √† medida que os dados ficam mais complicados, voc√™ pode extrair cada caso com registros: </p><br><pre> <code class="cpp hljs">type FullName = { FirstName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; LastName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } type Employee = | Engineer of FullName | Manager of Manager | Executive of Executive <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Manager = { Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Executive = { Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; Assistant: Employee }</code> </pre> <br><p>  Agora, essa defini√ß√£o recursiva pode ser reduzida com registros an√¥nimos se ela se adequar √† sua base de c√≥digo: </p><br><pre> <code class="cpp hljs">type FullName = { FirstName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; LastName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } type Employee = | Engineer of FullName | Manager of {| Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> |} | Executive of {| Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; Assistant: Employee |}</code> </pre> <br><p>  Como nos exemplos anteriores, essa t√©cnica deve ser aplicada criteriosamente e quando aplic√°vel ao seu cen√°rio. </p><br><h4>  Registros an√¥nimos facilitam o uso do LINQ em F # </h4><br><p>  Os programadores de F # geralmente preferem usar os combinadores List, Array e Sequence ao trabalhar com dados, mas √†s vezes pode ser √∫til usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LINQ</a> .  Tradicionalmente, isso tem sido um pouco doloroso, j√° que o LINQ faz uso de tipos an√¥nimos C #. </p><br><p>  Com registros an√¥nimos, voc√™ pode usar os m√©todos LINQ da mesma maneira que faria com tipos C # e an√¥nimos: </p><br><pre> <code class="cpp hljs">open System.Linq let names = [ <span class="hljs-string"><span class="hljs-string">"Ana"</span></span>; <span class="hljs-string"><span class="hljs-string">"Felipe"</span></span>; <span class="hljs-string"><span class="hljs-string">"Emillia"</span></span>] let nameGrouping = names.Select(fun n -&gt; {| Name=n; FirstLetter=n.[<span class="hljs-number"><span class="hljs-number">0</span></span>] |}) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ng in nameGrouping <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> printfn <span class="hljs-string"><span class="hljs-string">"%s has first letter %c"</span></span> ng.Name ng.FirstLetter</code> </pre> <br><p>  Isso imprime: </p><br><pre> <code class="cpp hljs">Ana has first letter A Felipe has first letter F Emillia has first letter E</code> </pre> <br><h4>  Registros an√¥nimos facilitam o trabalho com o Entity Framework e outros ORMs </h4><br><p>  Os programadores de F # que usam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">express√µes de consulta de F #</a> para interagir com um banco de dados devem observar pequenas melhorias na qualidade de vida com registros an√¥nimos. </p><br><p>  Por exemplo, voc√™ pode estar acostumado a usar tuplas para agrupar dados com uma cl√°usula `select`: </p><br><pre> <code class="cpp hljs">let q = query { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row in db.Status <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> select (row.StatusID, row.Name) }</code> </pre> <br><p>  Mas isso resulta em colunas com nomes como <em>Item1</em> e <em>Item2</em> que n√£o s√£o ideais.  Antes dos registros an√¥nimos, voc√™ precisaria declarar um tipo de registro e us√°-lo.  Agora voc√™ n√£o precisa fazer isso: </p><br><pre> <code class="cpp hljs">let q = query { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row in db.Status <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> select {| StatusID = row.StatusID; Name = row.Name |} }</code> </pre> <br><p>  N√£o √© necess√°rio especificar o tipo de registro antecipadamente!  Isso torna as express√µes de consulta muito mais alinhadas com o SQL real que elas modelam. </p><br><p>  Os registros an√¥nimos tamb√©m permitem evitar a cria√ß√£o de tipos <em>AnonymousObject</em> em consultas mais avan√ßadas, apenas para criar um agrupamento ad-hoc de dados para os fins da consulta. </p><br><h4>  Registros an√¥nimos facilitam o uso do roteamento personalizado no ASP.NET Core </h4><br><p>  Voc√™ j√° pode estar usando o ASP.NET Core com F #, mas pode ter encontrado um constrangimento ao definir rotas personalizadas.  Como nos exemplos anteriores, isso ainda pode ser feito definindo um tipo de registro antecipadamente, mas isso costuma ser visto como desnecess√°rio pelos desenvolvedores de F #.  Agora voc√™ pode fazer isso inline: </p><br><pre> <code class="cpp hljs">app.UseMvc(fun routes -&gt; routes.MapRoute(<span class="hljs-string"><span class="hljs-string">"blog"</span></span>,<span class="hljs-string"><span class="hljs-string">"blog/{*article}"</span></span>, defaults={| controller=<span class="hljs-string"><span class="hljs-string">"Blog"</span></span>; action=<span class="hljs-string"><span class="hljs-string">"Article"</span></span> |}) |&gt; ignore ) |&gt; ignore</code> </pre> <br><p>  Ainda n√£o √© o ideal devido ao fato de o F # ser estrito sobre os tipos de retorno (diferente do C #, onde voc√™ n√£o precisa ignorar explicitamente as coisas que retornam um valor).  No entanto, isso permite remover as defini√ß√µes de registro definidas anteriormente que n√£o tinham outro objetivo, al√©m de permitir o envio de dados ao pipeline de middleware do ASP.NET. </p><br><h4>  Copie e atualize express√µes com registros an√¥nimos </h4><br><p>  Assim como nos tipos de registro, voc√™ pode usar a sintaxe de copiar e atualizar com registros an√¥nimos: </p><br><pre> <code class="cpp hljs">let data = {| X = <span class="hljs-number"><span class="hljs-number">1</span></span>; Y = <span class="hljs-number"><span class="hljs-number">2</span></span> |} let expandedData = {| data with Z = <span class="hljs-number"><span class="hljs-number">3</span></span> |} <span class="hljs-comment"><span class="hljs-comment">// Gives {| X=1; Y=2; Z=3 |} let stringifiedY = {| expandedData with Y="Hello!" |} // Gives {| X=1; Y="Hello!"; Z=3 |}</span></span></code> </pre> <br><p>  A express√£o original tamb√©m pode ser um tipo de registro: </p><br><pre> <code class="cpp hljs">type R = { X: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } let data = { X=<span class="hljs-number"><span class="hljs-number">1</span></span> } let data' = {| data with Y = <span class="hljs-number"><span class="hljs-number">2</span></span> |} <span class="hljs-comment"><span class="hljs-comment">// Gives {| X=1; Y=2 |}</span></span></code> </pre> <br><p>  Voc√™ tamb√©m pode copiar dados para e da refer√™ncia e estruturar registros an√¥nimos: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Copy data from a reference record into a struct anonymous record type R1 = { X: int } let r1 = { X=1 } let data1 = struct {| r1 with Y=1 |} // Copy data from a struct record into a reference anonymous record [&lt;Struct&gt;] type R2 = { X: int } let r2 = { X=1 } let data2 = {| r1 with Y=1 |}</span></span></code> </pre> <br><p>  O uso de express√µes de copiar e atualizar oferece aos registros an√¥nimos um alto grau de flexibilidade ao trabalhar com dados em F #. </p><br><h4>  Igualdade e correspond√™ncia de padr√µes </h4><br><p>  Registros an√¥nimos s√£o estruturalmente equipar√°veis ‚Äã‚Äãe compar√°veis: </p><br><pre> <code class="cpp hljs">{| a = <span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span> |} = {| a = <span class="hljs-number"><span class="hljs-number">2</span></span> |} <span class="hljs-comment"><span class="hljs-comment">// true {| a = 1+1 |} &gt; {| a = 1 |} // true</span></span></code> </pre> <br><p>  No entanto, os tipos que est√£o sendo comparados devem ter a mesma "forma": </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// error FS0001: Two anonymous record types have mismatched sets of field names '["a"]' and '["a"; "b"]' {| a = 1+1 |} = {| a = 2; b = 1|}</span></span></code> </pre> <br><p>  Embora voc√™ possa equiparar e comparar registros an√¥nimos, n√£o √© poss√≠vel fazer correspond√™ncia de padr√µes sobre eles.  Isso ocorre por dois motivos: </p><br><ul><li>  Um padr√£o deve ser respons√°vel por todos os campos de um registro an√¥nimo, diferentemente dos tipos de registro.  Isso ocorre porque os registros an√¥nimos n√£o suportam subtipagem estrutural - s√£o tipos nominais. </li><li>  N√£o h√° capacidade de ter padr√µes adicionais em uma express√£o de correspond√™ncia de padr√£o, pois cada padr√£o distinto implicaria um tipo de registro an√¥nimo diferente. </li><li>  O requisito de contabilizar todos os campos em um registro an√¥nimo tornaria um padr√£o mais detalhado do que o uso da nota√ß√£o "ponto". </li></ul><br><p>  Em vez disso, a sintaxe ‚Äúponto‚Äù √© usada para extrair valores de um registro an√¥nimo.  Isso sempre ser√° t√£o detalhado quanto se a correspond√™ncia de padr√µes fosse usada e, na pr√°tica, √© prov√°vel que seja menos detalhada, porque nem sempre √© poss√≠vel extrair todo valor de um registro an√¥nimo.  Veja como trabalhar com um exemplo anterior, em que registros an√¥nimos fazem parte de uma uni√£o discriminada: </p><br><pre> <code class="cpp hljs">type Employee = | Engineer of FullName | Manager of {| Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> |} | Executive of {| Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; Assistant: Employee |} let getFirstName e = match e with | Engineer fullName -&gt; fullName.FirstName | Manager m -&gt; m.Name.FirstName | Executive ex -&gt; ex.Name.FirstName</code> </pre> <br><p>  Atualmente, existe uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sugest√£o aberta</a> para permitir a correspond√™ncia de padr√µes em registros an√¥nimos nos contextos limitados de que eles realmente poderiam ser ativados.  Se voc√™ tem um caso de uso proposto, use esse problema para discuti-lo! </p><br><h2>  Adi√ß√µes FSharp.Core </h2><br><p>  N√£o seria outra vers√£o do F # sem acr√©scimos √† Biblioteca do F # Core! </p><br><h3>  Expans√£o ValueOption </h3><br><p>  O tipo <em>ValueOption</em> introduzido no F # 4.5 agora tem mais alguns itens anexados ao tipo: </p><br><ul><li>  O atributo <em>DebuggerDisplay</em> para ajudar na depura√ß√£o </li><li>  <em>Membros IsNone</em> , <em>IsSome</em> , <em>None</em> , <em>Some</em> , <em>op_Implicit</em> e <em>ToString</em> </li></ul><br><p>  Isso confere "paridade" ao tipo de op√ß√£o. </p><br><p>  Al√©m disso, agora existe um m√≥dulo <em>ValueOption</em> contendo as mesmas fun√ß√µes que o m√≥dulo `Option` possui: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> ValueOption = [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"IsSome"</span></span>)&gt;] val <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> isSome: voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; bool [&lt;CompiledName("IsNone")&gt;] val inline isNone: voption:'</span></span>T voption -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"DefaultValue"</span></span>)&gt;] val defaultValue: value:<span class="hljs-string"><span class="hljs-string">'T -&gt; voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T [&lt;CompiledName("DefaultWith")&gt;] val defaultWith: defThunk:(unit -&gt; '</span></span>T) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>T [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"OrElse"</span></span>)&gt;] val orElse: ifNone:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T voption [&lt;CompiledName("OrElseWith")&gt;] val orElseWith: ifNoneThunk:(unit -&gt; '</span></span>T voption) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>T voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"GetValue"</span></span>)&gt;] val get: voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>T [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Count"</span></span>)&gt;] val count: voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; int [&lt;CompiledName("Fold")&gt;] val fold&lt;'</span></span>T,<span class="hljs-string"><span class="hljs-string">'State&gt; : folder:('</span></span>State -&gt; <span class="hljs-string"><span class="hljs-string">'T -&gt; '</span></span>State) -&gt; state:<span class="hljs-string"><span class="hljs-string">'State -&gt; voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'State [&lt;CompiledName("FoldBack")&gt;] val foldBack&lt;'</span></span>T,<span class="hljs-string"><span class="hljs-string">'State&gt; : folder:('</span></span>T -&gt; <span class="hljs-string"><span class="hljs-string">'State -&gt; '</span></span>State) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; state:'</span></span>State -&gt; <span class="hljs-string"><span class="hljs-string">'State [&lt;CompiledName("Exists")&gt;] val exists: predicate:('</span></span>T -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; bool [&lt;CompiledName("ForAll")&gt;] val forall: predicate:('</span></span>T -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; bool [&lt;CompiledName("Contains")&gt;] val inline contains: value:'</span></span>T -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; bool when '</span></span>T : equality [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Iterate"</span></span>)&gt;] val iter: action:(<span class="hljs-string"><span class="hljs-string">'T -&gt; unit) -&gt; voption:'</span></span>T voption -&gt; unit [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Map"</span></span>)&gt;] val <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>: mapping:(<span class="hljs-string"><span class="hljs-string">'T -&gt; '</span></span>U) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>U voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Map2"</span></span>)&gt;] val map2: mapping:(<span class="hljs-string"><span class="hljs-string">'T1 -&gt; '</span></span>T2 -&gt; <span class="hljs-string"><span class="hljs-string">'U) -&gt; voption1: '</span></span>T1 voption -&gt; voption2: <span class="hljs-string"><span class="hljs-string">'T2 voption -&gt; '</span></span>U voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Map3"</span></span>)&gt;] val map3: mapping:(<span class="hljs-string"><span class="hljs-string">'T1 -&gt; '</span></span>T2 -&gt; <span class="hljs-string"><span class="hljs-string">'T3 -&gt; '</span></span>U) -&gt; <span class="hljs-string"><span class="hljs-string">'T1 voption -&gt; '</span></span>T2 voption -&gt; <span class="hljs-string"><span class="hljs-string">'T3 voption -&gt; '</span></span>U voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Bind"</span></span>)&gt;] val bind: binder:(<span class="hljs-string"><span class="hljs-string">'T -&gt; '</span></span>U voption) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>U voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Flatten"</span></span>)&gt;] val flatten: voption:<span class="hljs-string"><span class="hljs-string">'T voption voption -&gt; '</span></span>T voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Filter"</span></span>)&gt;] val filter: predicate:(<span class="hljs-string"><span class="hljs-string">'T -&gt; bool) -&gt; voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T voption [&lt;CompiledName("ToArray")&gt;] val toArray: voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T[] [&lt;CompiledName("ToList")&gt;] val toList: voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T list [&lt;CompiledName("ToNullable")&gt;] val toNullable: voption:'</span></span>T voption -&gt; Nullable&lt;<span class="hljs-string"><span class="hljs-string">'T&gt; [&lt;CompiledName("OfNullable")&gt;] val ofNullable: value:Nullable&lt;'</span></span>T&gt; -&gt; <span class="hljs-string"><span class="hljs-string">'T voption [&lt;CompiledName("OfObj")&gt;] val ofObj: value: '</span></span>T -&gt; <span class="hljs-string"><span class="hljs-string">'T voption when '</span></span>T : null [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"ToObj"</span></span>)&gt;] val toObj: value: <span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>T when <span class="hljs-string"><span class="hljs-string">'T : null</span></span></code> </pre> <br><p>  Isso deve aliviar qualquer preocupa√ß√£o de que `ValueOption` seja o irm√£o estranho da` Option` que n√£o recebe o mesmo conjunto de funcionalidades. </p><br><h3>  tryExactlyOne para List, Array e Seq </h3><br><p>  Esta boa fun√ß√£o foi contribu√≠da por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Grzegorz Dziadkiewicz</a> .  Veja como funciona: </p><br><pre> <code class="cpp hljs">List.tryExactlyOne [] <span class="hljs-comment"><span class="hljs-comment">// None List.tryExactlyOne [1] // Some 1 List.tryExactlyOne [1; 2] // None Array.tryExactlyOne null // ArgumentNullException Array.tryExactlyOne [||] // None Array.tryExactlyOne [|1|] // Some 1 Array.tryExactlyOne [|1; 2|] // None Seq.tryExactlyOne null // ArgumentNullException Seq.tryExactlyOne (Seq.ofList []) // None Seq.tryExactlyOne (Seq.ofList [1]) // Some 1 Seq.tryExactlyOne (Seq.ofList [1; 2]) // None</span></span></code> </pre> <br><h2>  Finalizando </h2><br><p>  Embora a lista total de recursos no F # 4.6 n√£o seja enorme, eles ainda s√£o bastante profundos!  N√≥s encorajamos voc√™ a experimentar o F # 4.6 e nos deixar um feedback para que possamos ajustar as coisas antes do lan√ßamento completo.  Como sempre, obrigado √† comunidade F # por suas contribui√ß√µes - tanto na discuss√£o de c√≥digo quanto na de design - que nos ajudam a continuar avan√ßando no idioma F #. </p><br><p>  Felicidades e hackers felizes! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437666/">https://habr.com/ru/post/pt437666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437654/index.html">Impressoras fotopol√≠meros 3D baratas e acess√≠veis</a></li>
<li><a href="../pt437656/index.html">Elefante em uma loja de porcelana: impressoras 3D com um enorme campo de impress√£o</a></li>
<li><a href="../pt437658/index.html">Guia: Thymeleaf + Spring. Parte 3</a></li>
<li><a href="../pt437660/index.html">Atualiza√ß√£o do perfil vital√≠cio no Visual Studio 2019 Preview 2</a></li>
<li><a href="../pt437664/index.html">Recupera√ß√£o composta</a></li>
<li><a href="../pt437670/index.html">Atualiza√ß√µes de back-end do MSVC no Visual Studio 2019 Preview 2: Novas otimiza√ß√µes, OpenMP e melhorias na taxa de compila√ß√£o</a></li>
<li><a href="../pt437672/index.html">cyberd: computando o conhecimento da web3</a></li>
<li><a href="../pt437674/index.html">M√©todos de reconhecimento de objetos 3D para ve√≠culos n√£o tripulados. Relat√≥rio Yandex</a></li>
<li><a href="../pt437676/index.html">Universidades e aceleradores corporativos como alavanca para lan√ßar startups B2B nos EUA</a></li>
<li><a href="../pt437680/index.html">Minha cole√ß√£o DIY no Youtube</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>