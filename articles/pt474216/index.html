<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐹 🛀🏽 🤟🏾 O que traz a combinação de testes manuais e automatizados: a experiência Wrike 👨🏾‍🤝‍👨🏻 🗜️ 🚴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lendo artigos sobre o tópico de teste na web, dois tópicos aparecem condicionalmente: 1) o teste manual está acabando, os autotestes (doravante referi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O que traz a combinação de testes manuais e automatizados: a experiência Wrike</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wrike/blog/474216/"><img src="https://habrastorage.org/webt/jg/uo/3e/jguo3eeblu6l26megn468bzw7tw.png"><br>  Lendo artigos sobre o tópico de teste na web, dois tópicos aparecem condicionalmente: 1) o teste manual está acabando, os autotestes (doravante referidos como autotestes são Selenium UI e REST) ​​são tudo;  2) o teste automático não é uma panacéia; o teste manual é indispensável.  Ao mesmo tempo, a partir dos artigos, há uma tendência a um aumento nos requisitos de qualidade de software e velocidade de desenvolvimento de produtos.  Wrike é apenas o caso quando esses requisitos são críticos. <br><br>  O produto já tem 12 anos, mas ainda está crescendo ativamente.  As implantações ocorrem uma vez ao dia, e às vezes duas.  Portanto, é extremamente importante para nós que a regressão seja realizada exclusivamente em autotestes.  No entanto, no Wrike (na empresa), existem mais de 30 equipes de scrum, e o pessoal da equipe de automação não é de borracha.  Em tais circunstâncias, para esperar a automação de cenários manuais, na melhor das hipóteses, um ou dois sprints não são uma opção.  A experiência de nossa empresa diz que um testador manual pode escrever autotestes independentemente, sujeito a certas nuances.  No artigo, vou falar sobre eles e por que, na minha opinião, essa capacidade não apenas ajuda a acompanhar as tendências, mas também é útil para o próprio testador. <br><a name="habracut"></a><br><h2>  <font color="#9fd326">Processo padrão</font> </h2><br><img src="https://habrastorage.org/webt/-e/ai/sw/-eaisw_2cqiyashkplwfnu3o360.png"><br>  A que processo muitas equipes estão acostumadas?  Isso varia de caso para caso, mas os recursos comuns são praticamente os mesmos.  Existem departamentos de teste automático e manual.  Os testadores manuais podem ser distribuídos entre os comandos scrum.  Nesse caso, a automação, por regra, não tem relação com uma equipe específica. <br><br>  Ao trabalhar com novas funcionalidades, o testador cria scripts de teste, alguns dos quais ele marca de maneira predeterminada para os fabricantes de automóveis.  Além disso, se já houver casos em que os ajustes forem feitos, eles também serão anotados para atualizar o código.  Em seguida, os testes marcados são transferidos para o departamento de automação.  Uma equipe de engenheiros de automação assume a tarefa de corrigir a corrente e escrever novos autotestes em um dos seguintes sprints.  Além de programar cenários de teste, as tarefas do automatizador incluem executar autotestes, analisar os resultados, além de apoiar e desenvolver o projeto de teste.  Acontece que o departamento de automação atua como executor de terceirização e os testadores manuais são um tipo de cliente. <br><br>  Além disso, o cliente gasta tempo compilando um TOR detalhado e preciso, discutindo periodicamente os métodos de implementação e selecionando os testes necessários.  Também há riscos de que, durante a ausência de autoteste, os erros possam ser ignorados.  Não esqueça que há uma camada de problemas técnicos que só poderiam ser resolvidos em testes automáticos, o que economizaria muito tempo.  Essas tarefas deverão ser verificadas manualmente na parte em que a automação ainda está ausente. <br><br>  O contratado, não estando muito imerso na funcionalidade em que a equipe estava envolvida, levará tempo para mergulhar superficialmente na tarefa e na conscientização do TOR.  Ao mesmo tempo, é provável que o teste não seja traduzido com precisão no código, pelo que não verificará o que gostaríamos.  Por conseguinte, a eficiência da base de teste é reduzida. <br><br>  A equipe de automação, sendo o único colaborador do projeto de teste, tem controle total sobre sua base de códigos, o que permite que ele seja facilmente desenvolvido em qualquer direção.  No entanto, o tempo para isso se torna insuficiente devido ao aumento da carga de outras equipes.  O problema pode ser resolvido com a expansão da equipe, mas o custo da automação excederá sua eficácia.  Mesmo se você remover parte da carga, dando aos testadores manuais a oportunidade de executar testes e analisar os que caíram, isso não trará o resultado adequado.  Como eles não possuem ferramentas para depurar testes, eles podem não entender que o teste travou devido a uma alteração no xpath e assim por diante. <br><br>  Consequentemente, na saída, obtemos que os autotestes com esse esquema não acompanham o crescimento do produto, o que leva a uma cobertura ruim do código.  Devido a uma interpretação imprecisa do TK, os testes podem ignorar os erros.  Quando estão desatualizados por um longo tempo, os que caem não são reparados imediatamente, e é difícil para os testadores manuais saberem imediatamente qual parte do sistema está bem coberta pela automação.  Os autotestes se tornam algum tipo de caixa preta, na qual os testadores desconfiam.  Portanto, o número de verificações manuais desnecessárias está aumentando, os termos das tarefas são ampliados e a qualidade diminui a longo prazo. <br><br>  Você pode trabalhar com essas deficiências, mas quanto maior o produto e a empresa, mais doloroso para os participantes do processo e, o mais importante, é difícil seguir a tendência de aumentar a velocidade e melhorar a qualidade.  O próprio testador se torna refém da rotina e praticamente não permanece no desenvolvimento do tempo. <br><br><h2>  <font color="#9fd326">Maneira Wrike</font> </h2><br><img src="https://habrastorage.org/webt/aw/1s/s5/aw1ss5krkgydvvudfelgilp-bvu.png"><br>  Então, como funciona no exemplo da equipe em que trabalho.  Existem equipes de teste automáticas e manuais.  Os dados iniciais ainda são semelhantes, mas as diferenças começam.  Os testadores manuais são distribuídos entre suas equipes de scrum.  Cada equipe de scrum tem seu próprio autotester.  Às vezes, pode ser alocado não a uma, mas a duas equipes, se a carga permitir. <br><br>  Ao trabalhar com novas funcionalidades, o testador escreve listas de verificação, de acordo com as quais realiza verificações manuais.  A parte mínima exigida dos testes desta lista de verificação é automatizada.  O próprio testador grava esses autotestes no momento em que o recurso está em desenvolvimento ou teste.  Além disso, o código escrito é fornecido ao revisor para revisão.  Com raras exceções, uma tarefa sem autoteste não pode ser emitida. <br><br>  Obviamente, não há exigência no Wrike de escrever autotestes por testadores manuais.  Isso fica a critério da equipe.  Você pode dar tudo para a automação.  Você pode limitar-se a corrigir novos testes quebrados e / ou escrever por analogia e delegar tarefas mais complexas (criar novos testes ou expandir identificadores antigos de back-end, objeto de página ou etapas e classes de teste) a uma ferramenta de automação dedicada.  Tudo depende de você, mas é estúpido perder essas vantagens que a gravação independente de testes automáticos oferece. <br><br>  Toda a nossa regressão é baseada em autotestes, e as responsabilidades dos testadores manuais incluem executar e analisar falhas de autoteste.  Para cada ramo em que a equipe está trabalhando, eles executam testes automáticos como garantidor inicial e final da qualidade.  Portanto, é muito mais fácil para aqueles que escrevem autotestes entenderem por que um teste em execução na ramificação falhou.  Às vezes, ferramentas como reexecução e um relatório no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Allure são</a> realmente suficientes, onde você pode entender o motivo da falha do teste na captura de tela e nas etapas.  No entanto, geralmente o melhor assistente é a capacidade de executar testes localmente, brincar com as etapas ou executá-las no modo de depuração, ver o xpath esperado e real.  Sem experiência em trabalhar com um projeto de teste, isso levará muito tempo ou será necessário distrair a ferramenta de automação dedicada. <br><br>  Além disso, a gravação independente de autotestes permite executá-los antes mesmo do lançamento do recurso.  O testador sempre sabe o grau de cobertura de sua parte do sistema e as tarefas técnicas rolam apenas em testes automáticos, o que economiza significativamente tempo e recursos da equipe.  Os testes em si são sempre relevantes, pois as falhas são ajustadas antes do lançamento.  Os testes interrompidos são corrigidos imediatamente no mesmo ramo em que os novos são gravados. <br><br>  O testador manual é imerso ao máximo na tarefa da equipe, portanto, o mínimo necessário de testes automáticos é selecionado, cobrindo a maioria dos casos.  A amostra é revisada várias vezes durante o teste, pois durante as verificações manuais, a funcionalidade é estudada com mais detalhes com todas as nuances.  Consequentemente, a eficiência desses testes está aumentando.  Escrever autotestes permite entender melhor a arquitetura do aplicativo, os componentes usados ​​e a interação do front-end com o back-end.  Por fim, esse conhecimento ajuda a uma abordagem mais consciente e eficaz dos testes de produtos.  Por exemplo, se algum comando faz alterações no componente geral, é mais provável que você saiba com antecedência se seu escopo será ou não afetado, pois ao trabalhar com o xpath, você entende quais componentes são usados ​​em sua parte do aplicativo. <br><br>  Pode-se argumentar que escrever autotestes leva tempo.  Sim, as tarefas serão liberadas um a três dias depois do que o normal, mas a longo prazo vale a pena.  Além disso, existem métodos de otimização.  Por exemplo, enquanto um recurso está em desenvolvimento, você pode elaborar as listas de verificação necessárias e deixar um espaço em branco para os testes, economizando tempo.  Se você possui uma estrutura de funcionalidade pronta, é possível adicionar ou corrigir xpaths existentes, se necessário, criar um novo Objeto de Página ou ajustar as etapas.  Então, na fase de escrever autotestes, após verificações manuais, você só precisará adicionar os blocos de código na ordem correta. <br><br>  Graças à estrutura desenvolvida por nossa equipe de automação, escrever autotestes na maior parte representa compilar código a partir de blocos - como o Lego.  Essa simplicidade permite que você se adapte rapidamente aos testadores manuais e comece a escrever autotestes por analogia com os existentes.  Por experiência própria, direi que demorou cerca de duas semanas desde o momento em que fui trabalhar no Wrike até os primeiros autotestes que escrevi, juntamente com outras tarefas. <br><br>  O controle de qualidade dos testes automatizados escritos é realizado através da revisão do código.  Nem uma única ramificação de teste entra no lançamento sem uma revisão.  Este é um bom momento de treinamento, pois o testador extrai informações úteis dos comentários em seu código e desenvolve a experiência de boas soluções: por exemplo, ele gerencia a biblioteca Java padrão com mais eficiência ou define o xpath com mais precisão.  Da próxima vez, ficará claro qual a melhor forma de trabalhar com uma situação específica. <br><br>  Obviamente, o desenvolvimento de um projeto de teste, uma estrutura e o treinamento de testadores manuais consomem os recursos de automação, especialmente no estágio inicial, mas parece-me que esses esforços foram totalmente recompensados.  Temos muitas melhorias no ambiente de teste automatizado que facilitam nosso trabalho.  O produto em si tem uma boa cobertura, para que você possa confiar na regressão.  Isso ajuda a acelerar o processo de implantação de recursos no ambiente do usuário e protege muito os nervos dos testadores. <br><br>  De acordo com a experiência de nossa equipe, este é um dos melhores processos para trabalhar com um produto grande e de rápido desenvolvimento em uma grande empresa.  Além disso, está alinhado com as tendências atuais em melhorar a qualidade do software e a velocidade de sua entrega aos usuários.  O próprio testador praticamente se livra da rotina, desenvolve-se em várias direções e olha a aplicação sob vários ângulos. <br><br><h2>  <font color="#9fd326">Brevemente sobre o principal</font> </h2><br>  Por conveniência, destacarei as vantagens de um testador manual em um único local, para que seja mais fácil perceber sua importância individualmente ou em conjunto: <br><br><ul><li>  Uma imagem mais completa é formada sobre o nível e a qualidade da automação de seus escopos; </li><li>  Os autotestes estão disponíveis antes do lançamento do recurso, o que possibilita verificar rapidamente sua qualidade a qualquer momento; </li><li>  A eficiência dos autotestes aumenta, assim como a eficiência dos testes em geral; </li><li>  Uma abordagem mais informada e eficaz dos testes está sendo formada; </li><li>  Livrar-se de regressões manuais monótonas e longos testes de avaliação; </li><li>  Crescimento pessoal e desenvolvimento de competências. </li></ul><br><h2>  <font color="#9fd326">Resumir</font> </h2><br>  Claro, não há bala de prata.  O que é adequado para uma empresa pode ser fortemente rejeitado por outra.  No caso do Wrike, o produto cresce extremamente rápido e não há tempo para longas regressões manuais e testes de avaliação.  Temos esse papel desempenhado por autotestes, que cobrem quase todos os componentes de um grande produto.  Isso ajuda a manter a qualidade, otimizar recursos e fornecer novas funcionalidades aos usuários mais rapidamente. <br><br>  A má notícia é que ele não pode ficar sem erros, mas no nosso caso, na maioria das vezes, esses são casos extremos.  A boa notícia é que os erros durante as correções também são cobertos por autotestes. <br>  Por alguma razão, tornou-se tão comum na comunidade que a idéia de escrever autotestes por testadores manuais é rejeitada.  Existem dois argumentos mais populares por parte dos testadores: "Eles não pagam mais por isso" e "Já temos trabalho suficiente".  Para mim, pessoalmente, ambos os argumentos desmoronam quando percebo que posso executar autotestes no momento em que um recurso é desenvolvido e, em pouco tempo, entendo como ele funciona corretamente.  Vale muito a pena.  Nosso trabalho é melhorar e manter a qualidade do produto, para que todas as oportunidades sejam usadas para facilitar isso.  Desde o momento em que comecei a escrever autotestes, a rotina do meu trabalho se tornou cada vez menos consciente. <br><br>  PS Este artigo reflete apenas a experiência de nossa equipe e pode não corresponder às suas crenças.  Portanto, ficarei feliz em saber sobre as abordagens que o guiarão em seu trabalho.  Também ficarei feliz com críticas saudáveis ​​e com a oportunidade de discutir o artigo nos comentários. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt474216/">https://habr.com/ru/post/pt474216/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt474200/index.html">Lançamento do Windows Terminal Preview 1910</a></li>
<li><a href="../pt474202/index.html">O sucesso não está sem a ajuda de outra pessoa: como "crescer" um projeto finalizado para o mercado através de um pré-acelerador</a></li>
<li><a href="../pt474204/index.html">Diga uma palavra sobre diferentes ticks ou como não obter um erro no Powershell ao trabalhar com Get-Date</a></li>
<li><a href="../pt474208/index.html">Longhorn, Rancher distribuiu armazenamento para K8s, transferido para CNCF</a></li>
<li><a href="../pt474212/index.html">Python em um mês</a></li>
<li><a href="../pt474220/index.html">Habr Weekly # 25 / Trabalho em equipe informal, funcionários autistas e críticas por telegrama</a></li>
<li><a href="../pt474222/index.html">Yurchik - um mutante pequeno, mas formidável (história de N.-F.)</a></li>
<li><a href="../pt474224/index.html">Kotlin vs. Swift: Android e iOS caminhando para uma linguagem universal?</a></li>
<li><a href="../pt474226/index.html">Apresentando o Orleans 3.0</a></li>
<li><a href="../pt474228/index.html">Uma licença de projeto de código aberto que exige que os usuários "não causem danos"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>