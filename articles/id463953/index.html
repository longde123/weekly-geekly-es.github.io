<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌩️ 🕳️ 👩🏻‍🏭 Menerapkan Pola Desain Perintah di Unity 🧛🏽 👩‍❤️‍💋‍👨 👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pernahkah Anda bertanya-tanya bagaimana dalam game seperti Super Meat Boy fungsi replay diimplementasikan? Salah satu cara untuk mengimplementasikanny...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menerapkan Pola Desain Perintah di Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463953/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fef/cfb/edf/fefcfbedf0b2e0711f2e831b0d069ebf.gif" alt="gambar"></div><br>  Pernahkah Anda bertanya-tanya bagaimana dalam game seperti <i>Super Meat Boy</i> fungsi replay diimplementasikan?  Salah satu cara untuk mengimplementasikannya adalah dengan melakukan input dengan cara yang sama seperti yang dilakukan pemain, yang, pada gilirannya, berarti bahwa input tersebut perlu disimpan.  Anda dapat menggunakan <em>pola Command</em> untuk ini dan banyak lagi. <br><br>  Templat Perintah juga berguna untuk membuat fungsi Batalkan dan Ulangi dalam permainan strategi. <br><br>  Dalam tutorial ini, kami mengimplementasikan Templat perintah di C # dan menggunakannya untuk memandu karakter bot melalui labirin tiga dimensi.  Dari tutorial Anda akan belajar: <br><br><ul><li>  Dasar-dasar pola Perintah. </li><li>  Bagaimana menerapkan pola Perintah </li><li>  Cara membuat antrian perintah input dan menunda eksekusi. </li></ul><a name="habracut"></a><br><blockquote>  <em>Catatan</em> : diasumsikan bahwa Anda sudah terbiasa dengan Unity dan memiliki pengetahuan rata-rata tentang C #.  Dalam tutorial ini kita akan bekerja dengan <em>Unity 2019.1</em> dan <em>C # 7</em> . </blockquote><br><h2>  Mulai bekerja </h2><br>  Untuk memulai, unduh <a href="">materi proyek</a> .  Buka zip file dan buka proyek <em>Starter</em> di Unity. <br><br>  Pergi ke <em>RW / Adegan</em> dan buka adegan <em>Utama</em> .  Adegan ini terdiri dari bot dan labirin, serta UI terminal yang menampilkan instruksi.  Desain level dibuat dalam bentuk kisi, yang berguna ketika kita memindahkan bot secara visual melalui labirin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53b/ab9/660/53bab9660bdd0a5017b570d43a57b2d9.png"></div><br>  Jika Anda mengklik <em>Play</em> , kita akan melihat bahwa instruksi tidak berfungsi.  Ini normal karena kami akan menambahkan fungsionalitas ini ke tutorial. <br><br>  Bagian paling menarik dari adegan ini adalah GameObject <em>Bot</em> .  Pilih di jendela Hierarki dengan mengkliknya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/187/35e/acf/18735eacfd1f8df8920749ea80a12b8f.png"></div><br>  Di Inspektur, Anda dapat melihat bahwa ia memiliki komponen <em>Bot</em> .  Kami akan menggunakan komponen ini dengan mengeluarkan perintah input. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a5/2e3/2bc/2a52e32bc7feb6baafae6af958cc4910.png"></div><br><h2>  Kami memahami logika bot </h2><br>  Pergi ke <em>RW / Skrip</em> dan buka skrip <em>Bot</em> di editor kode.  Anda tidak perlu tahu apa yang terjadi dalam skrip <em>Bot</em> .  Tapi lihat dua metode: <code>Move</code> dan <code>Shoot</code> .  Sekali lagi, Anda tidak perlu mencari tahu apa yang terjadi di dalam metode ini, tetapi Anda perlu memahami cara menggunakannya. <br><br>  Perhatikan bahwa metode <code>Move</code> menerima parameter input <code>CardinalDirection</code> .  <code>CardinalDirection</code> adalah enumerasi.  Elemen enumerasi dari tipe <code>CardinalDirection</code> bisa <code>Up</code> , <code>Down</code> , <code>Right</code> atau <code>Left</code> .  Tergantung pada <code>CardinalDirection</code> dipilih <code>CardinalDirection</code> bot bergerak tepat satu kotak di sepanjang kisi dalam arah yang sesuai. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02c/72e/8ca/02c72e8ca19f987e6e36774558242058.png"></div><br>  Metode <code>Shoot</code> memaksa bot untuk menembakkan peluru yang menghancurkan <em>dinding kuning</em> , tetapi tidak berguna terhadap dinding lain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/f18/2bb/b34f182bb9c0bb682606d0c5a1beb0fd.gif"></div><br>  Akhirnya, lihat metode <code>ResetToLastCheckpoint</code> ;  untuk memahami apa yang dia lakukan, lihat labirin.  Ada titik-titik di labirin yang disebut <em>pos pemeriksaan</em> .  Untuk melewati labirin, bot harus sampai ke titik kontrol <em>hijau</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4c/d3b/fc9/e4cd3bfc9d59944e28d9a22206141888.png"></div><br>  Ketika bot menginjak titik kontrol baru, maka itu menjadi yang <em>terakhir</em> baginya.  <code>ResetToLastCheckpoint</code> me-reset posisi bot, memindahkannya ke titik kontrol terakhir. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/829/617/95a/82961795afe53c9b45f1f8037896783c.gif"></div><br>  Meskipun kami tidak dapat menggunakan metode ini, kami akan segera memperbaikinya.  Untuk memulai, Anda perlu belajar tentang pola desain <em>Perintah</em> . <br><br><h2>  Apa itu Pola Desain Perintah? </h2><br>  Pola Perintah adalah salah satu dari 23 pola desain yang dijelaskan dalam <i>Pola Desain: Elemen-elemen</i> buku <i>Perangkat Lunak Berorientasi Objek yang Dapat</i> Digunakan Kembali yang ditulis oleh Geng Empat oleh Erich Gamma, Richard Helm, Ralph Johnson dan John Vlissides (GoF, Geng Empat). <br><br>  Para penulis melaporkan bahwa "pola Perintah merangkum permintaan sebagai objek, sehingga memungkinkan kami untuk membuat parameter objek lain dengan berbagai permintaan, antrian atau permintaan log, dan mendukung operasi yang dapat dibalik." <br><br>  Wow!  Bagaimana itu? <br><br>  Saya mengerti definisi ini tidak terlalu sederhana, jadi mari kita menganalisisnya. <br><br>  <em>Enkapsulasi</em> berarti pemanggilan metode dapat dienkapsulasi sebagai objek. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07d/5c3/214/07d5c32142de4fd36bd2cd73c543856a.png" width="50%" height="50%"></div><br>  Metode enkapsulasi dapat mempengaruhi banyak objek tergantung pada parameter input.  Ini disebut <em>parameterisasi</em> objek lain. <br><br>  "Perintah" yang dihasilkan dapat disimpan bersama dengan tim lain sampai mereka dieksekusi.  Ini adalah <em>antrian</em> permintaan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/035/637/264/0356372640076e0829d2a427cf3552f1.png" width="50%" height="50%"></div><br>  <i>Antrian Tim</i> <br><br>  Akhirnya, <em>reversibilitas</em> berarti operasi dapat dikembalikan menggunakan fungsi Undo. <br><br>  OK, tapi bagaimana ini tercermin dalam kode? <br><br>  Kelas <em>Command</em> akan memiliki metode <em>Execute</em> , yang menerima sebagai input parameter objek (dengan mana perintah dieksekusi) yang disebut <em>Receiver</em> .  Faktanya, metode Execute <em>dienkapsulasi</em> oleh kelas Command. <br><br>  Banyak instance dari kelas Command dapat dilewatkan sebagai objek biasa, yaitu, mereka dapat disimpan dalam struktur data seperti antrian, tumpukan, dll. <br><br>  Untuk menjalankan perintah, Anda harus memanggil metode Execute-nya.  Kelas yang memulai eksekusi disebut <em>Invoker</em> . <br><br>  Proyek saat ini berisi kelas kosong yang disebut <code>BotCommand</code> .  Di bagian selanjutnya, kami akan mengimplementasikan implementasi di atas untuk memungkinkan bot melakukan tindakan menggunakan templat Perintah. <br><br><h2>  Pindahkan bot </h2><br><h3>  Implementasi pola perintah </h3><br>  Di bagian ini, kami menerapkan pola Perintah.  Ada banyak cara untuk mengimplementasikannya.  Dalam tutorial ini kita akan membahas salah satunya. <br><br>  Untuk memulai, buka <em>RW / Skrip</em> dan dan buka skrip <em>BotCommand</em> di editor.  Kelas <code>BotCommand</code> masih kosong, tetapi tidak lama. <br><br>  Masukkan kode berikut ke dalam kelas: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//1 private readonly string commandName; //2 public BotCommand(ExecuteCallback executeMethod, string name) { Execute = executeMethod; commandName = name; } //3 public delegate void ExecuteCallback(Bot bot); //4 public ExecuteCallback Execute { get; private set; } //5 public override string ToString() { return commandName; }</span></span></code> </pre> <br>  Apa yang sedang terjadi di sini? <br><br><ol><li>  Variabel <code>commandName</code> digunakan hanya untuk menyimpan nama perintah yang dapat dibaca manusia.  Tidak perlu menggunakannya dalam template, tetapi kita akan membutuhkannya nanti dalam tutorial. </li><li>  Konstruktor <code>BotCommand</code> menerima fungsi dan string.  Ini akan membantu kita mengatur metode <code>Execute</code> objek Command dan <code>name</code> . </li><li>  Delegasi <code>ExecuteCallback</code> mendefinisikan jenis metode yang dienkapsulasi.  Metode enkapsulasi akan mengembalikan batal dan menerima sebagai parameter input objek bertipe <code>Bot</code> (komponen <em>Bot</em> ). </li><li>  Properti <code>Execute</code> akan merujuk ke metode enkapsulasi.  Kami akan menggunakannya untuk memanggil metode enkapsulasi. </li><li>  Metode <code>ToString</code> diganti untuk mengembalikan string <code>commandName</code> .  Ini nyaman, misalnya, untuk digunakan di UI. </li></ol><br>  Simpan perubahan dan hanya itu!  Kami telah berhasil menerapkan pola Perintah. <br><br>  Masih menggunakannya. <br><br><h3>  Membangun tim </h3><br>  Buka <em>BotInputHandler</em> di folder <em>RW / Scripts</em> . <br><br>  Di sini kita akan membuat lima contoh <code>BotCommand</code> .  Contoh-contoh ini akan merangkum metode untuk memindahkan GameObject Bot ke atas, bawah, kiri, dan kanan, serta untuk pemotretan. <br><br>  Untuk mengimplementasikan ini, masukkan berikut ini ke dalam kelas ini: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//1 private static readonly BotCommand MoveUp = new BotCommand(delegate (Bot bot) { bot.Move(CardinalDirection.Up); }, "moveUp"); //2 private static readonly BotCommand MoveDown = new BotCommand(delegate (Bot bot) { bot.Move(CardinalDirection.Down); }, "moveDown"); //3 private static readonly BotCommand MoveLeft = new BotCommand(delegate (Bot bot) { bot.Move(CardinalDirection.Left); }, "moveLeft"); //4 private static readonly BotCommand MoveRight = new BotCommand(delegate (Bot bot) { bot.Move(CardinalDirection.Right); }, "moveRight"); //5 private static readonly BotCommand Shoot = new BotCommand(delegate (Bot bot) { bot.Shoot(); }, "shoot");</span></span></code> </pre> <br>  Dalam setiap contoh ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">metode anonim</a> diteruskan ke konstruktor.  Metode anonim ini akan diringkas di dalam objek perintah yang sesuai.  Seperti yang Anda lihat, tanda tangan dari masing-masing metode anonim memenuhi persyaratan yang ditentukan oleh delegasi <code>ExecuteCallback</code> . <br><br>  Selain itu, parameter kedua ke konstruktor adalah string yang menunjukkan nama perintah.  Nama ini akan dikembalikan oleh metode <code>ToString</code> dari instance perintah.  Nanti kita akan menerapkannya untuk UI. <br><br>  Dalam empat contoh pertama, metode anonim memanggil metode <code>Move</code> pada objek <code>bot</code> .  Namun, parameter inputnya berbeda. <br><br>  Perintah <code>MoveUp</code> , <code>MoveDown</code> , <code>MoveLeft</code> dan <code>MoveRight</code> melewati parameter <code>Move</code> <code>CardinalDirection.Up</code> , <code>CardinalDirection.Down</code> , <code>CardinalDirection.Left</code> dan <code>CardinalDirection.Right</code> .  Seperti yang disebutkan di bagian <i>What is Command Design Pattern</i> , mereka menunjukkan arah yang berbeda untuk Bot GameObject untuk dipindahkan. <br><br>  Dalam contoh kelima, metode anonim memanggil metode <code>Shoot</code> untuk objek <code>bot</code> .  Berkat ini, bot akan menembakkan shell selama eksekusi perintah. <br><br>  Sekarang kita telah membuat perintah, kita perlu mengaksesnya entah bagaimana ketika pengguna membuat input. <br><br>  Untuk melakukan ini, <code>BotInputHandler</code> kode berikut dalam <code>BotInputHandler</code> , segera setelah perintah instances: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BotCommand </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.W)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MoveUp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.S)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MoveDown; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.D)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MoveRight; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.A)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MoveLeft; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.F)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Shoot; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Metode <code>HandleInput</code> mengembalikan satu instance dari perintah tergantung pada tombol yang ditekan oleh pengguna.  Simpan perubahan Anda sebelum melanjutkan. <br><br><h3>  Menerapkan perintah </h3><br>  Luar biasa, sekarang saatnya menggunakan tim yang kami buat.  Buka <em>RW / Script</em> lagi dan buka skrip <em>SceneManager</em> di editor.  Di kelas ini, Anda akan melihat tautan ke variabel <code>uiManager</code> dari tipe <code>UIManager</code> . <br><br>  Kelas <code>UIManager</code> menyediakan metode pembantu yang berguna untuk <em>UI terminal</em> yang kami gunakan dalam adegan ini.  Jika metode dari <code>UIManager</code> digunakan, maka tutorial akan menjelaskan apa yang dilakukannya, tetapi secara umum untuk tujuan kita, tidak perlu mengetahui struktur internalnya. <br><br>  Selain itu, variabel <code>bot</code> mengacu pada komponen bot yang terpasang pada GameObject <em>Bot</em> . <br><br>  Sekarang tambahkan kode berikut ke kelas <code>SceneManager</code> , ganti dengan komentar <code>//1</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//1 private List&lt;BotCommand&gt; botCommands = new List&lt;BotCommand&gt;(); private Coroutine executeRoutine; //2 private void Update() { if (Input.GetKeyDown(KeyCode.Return)) { ExecuteCommands(); } else { CheckForBotCommands(); } } //3 private void CheckForBotCommands() { var botCommand = BotInputHandler.HandleInput(); if (botCommand != null &amp;&amp; executeRoutine == null) { AddToCommands(botCommand); } } //4 private void AddToCommands(BotCommand botCommand) { botCommands.Add(botCommand); //5 uiManager.InsertNewText(botCommand.ToString()); } //6 private void ExecuteCommands() { if (executeRoutine != null) { return; } executeRoutine = StartCoroutine(ExecuteCommandsRoutine()); } private IEnumerator ExecuteCommandsRoutine() { Debug.Log("Executing..."); //7 uiManager.ResetScrollToTop(); //8 for (int i = 0, count = botCommands.Count; i &lt; count; i++) { var command = botCommands[i]; command.Execute(bot); //9 uiManager.RemoveFirstTextLine(); yield return new WaitForSeconds(CommandPauseTime); } //10 botCommands.Clear(); bot.ResetToLastCheckpoint(); executeRoutine = null; }</span></span></code> </pre> <br>  Wow, berapa banyak kodenya!  Tapi jangan khawatir;  kami akhirnya siap untuk peluncuran nyata pertama proyek di jendela Game. <br><br>  Saya akan menjelaskan kodenya nanti.  Ingatlah untuk menyimpan perubahan. <br><br><h3>  Menjalankan game untuk menguji templat Perintah </h3><br>  Jadi sekarang saatnya untuk membangun;  Klik <em>Mainkan</em> di editor Persatuan. <br><br>  Anda harus bisa memasukkan perintah pindah menggunakan <em>tombol WASD</em> .  Untuk memasukkan perintah pemotretan, tekan tombol <em>F.</em>  Untuk menjalankan perintah, tekan <em>Enter</em> . <br><br><blockquote>  <em>Catatan</em> : sampai proses eksekusi selesai, memasukkan perintah baru tidak mungkin. </blockquote><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20b/ef8/483/20bef8483dd70829836bd9234178f5dd.gif"></div><br>  Perhatikan bahwa garis ditambahkan ke UI terminal.  Tim di UI ditandai dengan namanya.  Ini dimungkinkan berkat variabel <code>commandName</code> . <br><br>  Juga, perhatikan bagaimana UI bergulir sebelum eksekusi dan bagaimana garis dihapus selama eksekusi. <br><br><h3>  Kami mempelajari tim lebih dekat </h3><br>  Saatnya mempelajari kode yang kami tambahkan di bagian "Menerapkan Perintah": <br><br><ol><li>  Daftar <code>botCommands</code> menyimpan tautan ke instance dari <code>BotCommand</code> .  Ingat bahwa untuk menghemat memori, kita hanya dapat membuat lima instance perintah, tetapi mungkin ada beberapa referensi untuk satu perintah.  Selain itu, variabel <code>executeCoroutine</code> merujuk ke <code>ExecuteCommandsRoutine</code> , yang mengontrol eksekusi perintah. </li><li>  <code>Update</code> memeriksa apakah pengguna telah menekan tombol Enter;  jika demikian, ia memanggil <code>ExecuteCommands</code> , atau <code>ExecuteCommands</code> <code>CheckForBotCommands</code> . </li><li>  <code>CheckForBotCommands</code> menggunakan metode <code>HandleInput</code> statis dari <code>BotInputHandler</code> untuk memeriksa apakah pengguna telah menyelesaikan input, dan jika demikian, perintah <em>dikembalikan</em> .  Perintah yang dikembalikan dilewatkan ke <code>AddToCommands</code> .  Namun, jika perintah dijalankan, mis.  jika <code>executeRoutine</code> bukan nol, maka itu akan kembali tanpa melewati apa pun ke <code>AddToCommands</code> .  Artinya, pengguna harus menunggu sampai selesai. </li><li>  <code>AddToCommands</code> menambahkan tautan baru ke instance perintah yang <code>botCommands</code> di <code>botCommands</code> . </li><li>  Metode <code>InsertNewText</code> dari kelas <code>InsertNewText</code> menambahkan baris teks baru ke UI terminal.  String teks adalah string yang diteruskan sebagai parameter input.  Dalam hal ini, kami memberikan commandName ke <code>commandName</code> . </li><li>  Metode <code>ExecuteCommandsRoutine</code> meluncurkan <code>ExecuteCommandsRoutine</code> . </li><li>  <code>ResetScrollToTop</code> dari <code>UIManager</code> menggulirkan terminal UI ke atas.  Ini dilakukan sesaat sebelum dimulainya eksekusi. </li><li>  <code>ExecuteCommandsRoutine</code> berisi perulangan <code>for</code> yang mengulangi perintah di dalam daftar <code>botCommands</code> dan mengeksekusi mereka satu per satu, meneruskan objek <code>bot</code> ke metode yang dikembalikan oleh properti <code>Execute</code> .  Setelah setiap eksekusi, jeda ditambahkan dalam <code>CommandPauseTime</code> detik. </li><li>  Metode <code>RemoveFirstTextLine</code> dari <code>UIManager</code> menghapus baris teks pertama di UI terminal, jika ada.  Yaitu, ketika sebuah perintah dieksekusi, namanya dihapus dari UI. </li><li>  Setelah semua perintah <code>botCommands</code> dihapus dan bot diatur ulang ke breakpoint terakhir menggunakan <code>ResetToLastCheckpoint</code> .  Pada akhirnya, <code>executeRoutine</code> <code>null</code> dan pengguna dapat terus memasukkan perintah. </li></ol><br><h2>  Menerapkan Fitur Undo dan Redo </h2><br>  Jalankan lagi pemandangan itu dan cobalah untuk sampai ke titik kontrol hijau. <br><br>  Anda akan melihat bahwa sementara kami tidak dapat membatalkan perintah yang dimasukkan.  Ini berarti bahwa jika Anda membuat kesalahan, Anda tidak dapat kembali sampai Anda menyelesaikan semua perintah yang Anda masukkan.  Anda dapat memperbaikinya dengan menambahkan fitur <em>Undo</em> dan <em>Redo</em> . <br><br>  Kembali ke <em>SceneManager.cs</em> dan tambahkan deklarasi variabel berikut segera setelah deklarasi <i>Daftar</i> untuk <code>botCommands</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Stack&lt;BotCommand&gt; undoStack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;BotCommand&gt;();</code> </pre> <br>  Variabel <code>undoStack</code> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">tumpukan</a> (dari keluarga Koleksi) yang akan menyimpan semua referensi ke perintah yang dapat dibatalkan. <br><br>  Sekarang kita menambahkan dua metode <code>UndoCommandEntry</code> dan <code>RedoCommandEntry</code> yang akan mengeksekusi Undo dan Redo.  Di kelas <code>SceneManager</code> , <code>SceneManager</code> kode berikut setelah <code>ExecuteCommandsRoutine</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UndoCommandEntry</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 if (executeRoutine != null || botCommands.Count == 0) { return; } undoStack.Push(botCommands[botCommands.Count - 1]); botCommands.RemoveAt(botCommands.Count - 1); //2 uiManager.RemoveLastTextLine(); } private void RedoCommandEntry() { //3 if (undoStack.Count == 0) { return; } var botCommand = undoStack.Pop(); AddToCommands(botCommand); }</span></span></code> </pre> <br>  Mari kita menganalisis kodenya: <br><br><ol><li>  Jika perintah dieksekusi atau daftar <code>botCommands</code> kosong, metode <code>UndoCommandEntry</code> apa <code>UndoCommandEntry</code> apa.  Kalau tidak, itu menulis tautan ke perintah terakhir yang dimasukkan pada tumpukan <code>undoStack</code> .  Ini juga menghapus tautan ke perintah dari daftar <code>botCommands</code> . </li><li>  Metode <code>RemoveLastTextLine</code> dari <code>UIManager</code> menghapus baris teks terakhir dari UI terminal sehingga UI cocok dengan konten <code>botCommands</code> . </li><li>  Jika tumpukan <code>undoStack</code> kosong, maka <code>RedoCommandEntry</code> tidak melakukan apa pun.  Jika tidak, ia mengekstrak perintah terakhir dari atas <code>undoStack</code> dan menambahkannya kembali ke daftar <code>AddToCommands</code> menggunakan <code>AddToCommands</code> . </li></ol><br>  Sekarang kita akan menambahkan input keyboard untuk menggunakan fungsi-fungsi ini.  Di dalam kelas <code>SceneManager</code> ganti tubuh metode <code>Update</code> dengan kode berikut: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Return)) { ExecuteCommands(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.U)) <span class="hljs-comment"><span class="hljs-comment">//1 { UndoCommandEntry(); } else if (Input.GetKeyDown(KeyCode.R)) //2 { RedoCommandEntry(); } else { CheckForBotCommands(); }</span></span></code> </pre> <br><ol><li>  Ketika Anda menekan tombol <em>U</em> , metode <code>UndoCommandEntry</code> . </li><li>  Ketika Anda menekan tombol <em>R</em> , metode <code>RedoCommandEntry</code> . </li></ol><br><h3>  Penanganan Case Tepi </h3><br>  Bagus, kita hampir selesai!  Tetapi pertama-tama, kita perlu melakukan hal berikut: <br><br><ol><li>  Saat memasukkan perintah baru, tumpukan <code>undoStack</code> harus dihapus. </li><li>  Sebelum menjalankan perintah, tumpukan <code>undoStack</code> harus dibersihkan. </li></ol><br>  Untuk mengimplementasikan ini, pertama-tama kita perlu menambahkan metode baru ke <code>SceneManager</code> .  Masukkan metode berikut setelah <code>CheckForBotCommands</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddNewCommand</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BotCommand botCommand</span></span></span><span class="hljs-function">)</span></span> { undoStack.Clear(); AddToCommands(botCommand); }</code> </pre> <br>  Metode ini menghapus <code>undoStack</code> dan kemudian memanggil metode <code>AddToCommands</code> . <br><br>  Sekarang ganti panggilan ke <code>AddToCommands</code> di dalam <code>AddToCommands</code> dengan kode berikut: <br><br><pre> <code class="cs hljs"> AddNewCommand(botCommand);</code> </pre> <br>  Kemudian masukkan baris berikut setelah <code>if</code> di dalam metode <code>ExecuteCommands</code> untuk menghapus sebelum menjalankan perintah <code>undoStack</code> : <br><br><pre> <code class="cs hljs"> undoStack.Clear();</code> </pre> <br>  Dan akhirnya kita selesai! <br><br>  Simpan pekerjaan Anda.  Bangun proyek dan klik di editor <em>Play</em> .  Masukkan perintah seperti sebelumnya.  Tekan <em>U</em> untuk membatalkan perintah.  Tekan <em>R</em> untuk mengulangi perintah yang dibatalkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fef/cfb/edf/fefcfbedf0b2e0711f2e831b0d069ebf.gif" width="1024" height="576"></div><br>  Cobalah untuk sampai ke pos pemeriksaan hijau. <br><br><h2>  Ke mana harus pergi selanjutnya? </h2><br>  Untuk mempelajari lebih lanjut tentang pola desain yang digunakan dalam pemrograman game, saya sarankan Anda mempelajari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Pola Pemrograman Game</a> Robert Nystrom. <br><br>  Untuk mempelajari lebih lanjut tentang teknik C # lanjutan, ambil kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">C # Collections, Lambdas, dan LINQ</a> . <br><br><h3>  Tugas </h3><br>  Sebagai tugas, cobalah untuk sampai ke titik kontrol hijau di ujung labirin.  Saya menyembunyikan salah satu solusi di bawah spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Solusi</b> <div class="spoiler_text"><ul><li>  pindah × 2 </li><li>  moveRight × 3 </li><li>  pindah × 2 </li><li>  moveLeft </li><li>  tembak </li><li>  moveLeft × 2 </li><li>  pindah × 2 </li><li>  moveLeft × 2 </li><li>  moveDown × 5 </li><li>  moveLeft </li><li>  tembak </li><li>  moveLeft </li><li>  pindah × 3 </li><li>  menembak × 2 </li><li>  pindah × 5 </li><li>  moveRight × 3 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dab/f9e/05f/dabf9e05f3cb79ab20a6a663108295fe.png"></div></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463953/">https://habr.com/ru/post/id463953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463933/index.html">Skrip Python 20-baris yang mengucapkan selamat pagi kepada orang tua setiap hari melalui WhatsApp</a></li>
<li><a href="../id463937/index.html">Saya tidak menyembunyikan apa pun</a></li>
<li><a href="../id463939/index.html">SimbirSoft telah merilis solusi mobile untuk perusahaan asuransi</a></li>
<li><a href="../id463943/index.html">Kesengsaraan unicorn hitam</a></li>
<li><a href="../id463951/index.html">c.tech: Cassandra Meetup # 2</a></li>
<li><a href="../id463955/index.html">Bagaimana mengembangkan konsep untuk mengubah platform IP? Instruksi untuk digunakan</a></li>
<li><a href="../id463957/index.html">Bagaimana cara menyebarkan daftar wawancara yang terhubung sendiri</a></li>
<li><a href="../id463961/index.html">Mapper sendiri atau sedikit tentang ExpressionTrees</a></li>
<li><a href="../id463963/index.html">Pengenalan wajah di lokasi konstruksi</a></li>
<li><a href="../id463965/index.html">Aplikasi typeset di LaTeX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>