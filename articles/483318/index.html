<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游끨 游 游낎 Bot para monitorear servicios web en media hora: telegram + bash + cron 游냠 鮫놾잺 游댕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A veces es necesario supervisar r치pidamente un nuevo servicio, pero no hay infraestructura / experiencia preparada a la mano. En esta gu칤a, en media h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bot para monitorear servicios web en media hora: telegram + bash + cron</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483318/"><img src="https://habrastorage.org/webt/ks/-r/l9/ks-rl9jvsn3vka3r5kxkj4jvbxg.jpeg"><br><br>  A veces es necesario supervisar r치pidamente un nuevo servicio, pero no hay infraestructura / experiencia preparada a la mano.  En esta gu칤a, en media hora implementaremos una herramienta para monitorear cualquier servicio web usando solo las herramientas incorporadas de ubuntu: bash, cron y curl.  Usaremos telegramas para entregar alertas. <br><br>  "Cherry on the cake" ser치 la participaci칩n emocional de los usuarios.  Est치 controlado por personas, funciona. <br><a name="habracut"></a><br>  Cuando creamos un chatbot en el servicio de telemedicina Doctor Near para determinar el nivel de estr칠s del usuario, necesit치bamos monitoreo.  En un par de horas, se realiz칩 un mini proyecto, que no solo funciona muy bien, sino que tambi칠n agrega comentarios positivos. <br><br>  Para comenzar, obtenga un repositorio con scripts: <br><br><pre><code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/rshekhovtsov/msms.git</code> </pre> <br>  Vaya a la carpeta msms y luego trabaje en ella. <br><br>  Si el telegrama est치 bloqueado, use un proxy.  La opci칩n m치s f치cil y confiable son los torsocks: <br><br><pre> <code class="bash hljs">sudo apt install tor sudo apt install torsocks</code> </pre> <br>  Como ejemplo, configuraremos el monitoreo de la p치gina de inicio de google.com en tres pasos. <br><br><h2>  PASO 1. Cree un bot en Telegram y obtenga la identificaci칩n de usuario </h2><br><ul><li>  En la cadena de b칰squeda de contactos en Telegram, busque <a href="https://t.me/botfather" rel="nofollow">@botfather</a> : <br><br><img src="https://habrastorage.org/webt/mf/8r/tx/mf8rtxrovcs-4r8ax2pn7fuxusc.png"><br></li><li>  Comenzamos con el bot칩n de Inicio, ingresamos el comando / newbot y respondemos preguntas.  Debe tener en cuenta que el nombre es el nombre del bot que se mostrar치 a los usuarios, y el nombre de usuario es 칰nico y debe terminar en "bot": <br><br><img src="https://habrastorage.org/webt/gc/q5/fx/gcq5fxjht5xytwso83degwhmslm.png"><br><br>  Entre otras cosas, el bot emitir치 un token secreto para la API HTTP, que debe copiar y guardar en el archivo telegram-api-key.txt en la carpeta msms. <br></li><li>  Escribimos el nombre de nuestro bot en la l칤nea de b칰squeda de telegramas y lo ejecutamos. <br></li><li>  Como toque final, agr칠guenos a la lista de destinatarios de alertas de monitoreo: <br><br><pre> <code class="bash hljs">sudo chmod +x ./recipients-setup.sh torsocks ./recipients-setup.sh</code> </pre> <br>  El script mostrar치 una lista de llamadas recientes al bot, debe haber una l칤nea con nuestra identificaci칩n y nombre en el telegrama.  Tomamos esta identificaci칩n y la guardamos en el archivo services / google-recipients.txt.  Formato de archivo: cada l칤nea es una identificaci칩n.  Un ejemplo: <br><br><pre> <code class="bash hljs">123456789 987654321</code> </pre> </li></ul><br>  Para agregar un nuevo destinatario, debe pedirle que inicie el bot en Telegram, ejecute recipients-setup.sh y agregue la identificaci칩n al archivo. <br><br><h2>  PASO 2. Configurar el monitoreo </h2><br>  La descripci칩n del servicio se produce al crear un archivo ini en la carpeta de servicios.  Deben establecerse cinco par치metros: <br><br><ol><li>  <b>MSMS_SERVICE_NAME</b> : nombre del servicio: se utilizar치 en alertas y <b>registros de</b> monitoreo. </li><li>  <b>MSMS_SERVICE_ENDPOINT</b> : el punto final del servicio con el que nos estaremos contactando curl. </li><li>  <b>MSMS_CURL_PARAMS</b> : par치metros de curvatura adicionales, consulte el ejemplo a continuaci칩n. </li><li>  <b>MSMS_EXPECTED</b> : respuesta de servicio esperada.  Se usa si la respuesta es corta. </li><li>  <b>MSMS_EXPECTED_FILE</b> : nombre de archivo con la respuesta de servicio esperada.  Si se especifica, sobrescribe MSMS_EXPECTED. </li><li>  <b>MSMS_RECIPIENTS</b> : archivo con una lista de destinatarios de notificaciones. </li></ol><br>  La solicitud en google.com devuelve un html fijo con un redireccionamiento, lo usaremos como la respuesta esperada del servidor: <br><br><pre> <code class="bash hljs">curl google.com &gt; services/google-response.html</code> </pre> <br>  Cree el archivo services / google.ini: <br><br><pre> <code class="bash hljs">MSMS_SERVICE_NAME=<span class="hljs-string"><span class="hljs-string">'google front page'</span></span> <span class="hljs-comment"><span class="hljs-comment"># service endpoint MSMS_SERVICE_ENDPOINT='google.com' # curl parameters MSMS_CURL_PARAMS='-s --connect-timeout 3 -m 7' # expected service response MSMS_EXPECTED_FILE='google-response.html' # recipients list file MSMS_RECIPIENTS='google-recipients.txt'</span></span></code> </pre> <br>  En <code>MSMS_CURL_PARAMS</code> puede especificar todo lo que curl puede hacer, incluyendo: <br><br><ol><li>  Deshabilite los mensajes curl para no obstruir la consola y registrar: <code>-s</code> </li><li>  Establezca el tiempo de espera de conexi칩n con el servicio que se verifica (en segundos): <code>--connect-timeout 3</code> </li><li>  Establecer tiempo de espera de respuesta: <code>-m 7</code> </li><li>  Deshabilite la verificaci칩n de certificados para SSL (por ejemplo, si se utiliza un certificado autofirmado): <code>--insecure</code> </li><li>  Especifique el tipo de solicitud http: <code>-X POST</code> </li><li>  Especifique encabezados: <code>-H "Content-Type: application/json"</code> </li><li>  Especifique el cuerpo de la solicitud como una cadena o archivo.  Ejemplo para el archivo: <code>-d @request.json</code> </li></ol><br>  Desactivamos las notificaciones y establecemos tiempos de espera de 3 segundos.  en conexi칩n y 7 seg.  para recibir una respuesta del servicio. <br><br>  <b>Atenci칩n</b> : especifique valores de par치metros entre comillas simples, como en el ejemplo.  Desafortunadamente, bash es bastante fr치gil en este sentido, y una <s>mariposa que vuela accidentalmente en el</s> lugar equivocado puede conducir a la <s>muerte del universo con</s> errores dif칤ciles de diagnosticar. <br><br>  Configuramos el monitoreo.  Comprueba que todo est치 bien: <br><br><pre> <code class="bash hljs">sudo chmod +x ./monitoring.sh torsocks ./monitoring.sh</code> </pre> <br>  El script debe mostrar un mensaje de la forma: <br><br><pre> <code class="bash hljs">2020-01-10 12:14:31 health-check <span class="hljs-string"><span class="hljs-string">"google front page"</span></span>: OK</code> </pre> <br><h2>  PASO 3. Ajuste el horario </h2><br>  Configure un horario de monitoreo en cron: <br><br><pre> <code class="bash hljs">sudo crontab -e</code> </pre> <br>  Agregue una l칤nea para revisar google.com cada minuto: <br><br><pre> <code class="bash hljs">*/1 * * * * torsocks &lt;   &gt;/monitoring.sh &gt;&gt; &lt;   &gt;/monitoring.log 2&gt;&amp;1</code> </pre> <br>  Agregue una alerta todos los d칤as a las 11.00, confirmando el monitoreo en s칤.  Para hacer esto, pase el par치metro DIARIO al script: <br><br><pre> <code class="bash hljs">0 11 * * * torsocks &lt;   &gt;/monitoring.sh DAILY &gt;&gt; &lt;   &gt;/monitoring.log 2&gt;&amp;1</code> </pre><br>  <code>2&gt;&amp;1</code> : t칠cnica est치ndar que redirige los errores al flujo de salida principal.  Como resultado, tambi칠n se incluir치n en el registro de monitoreo. <br><br>  Guarda los cambios y atr치palos con el comando: <br><br><pre> <code class="bash hljs"> sudo service cron reload</code> </pre> <br>  Puede leer m치s sobre la configuraci칩n de cron, por ejemplo, <a href="https://losst.ru/nastrojka-cron" rel="nofollow">aqu칤</a> . <br><br>  Por lo tanto, cada minuto se lanzar치 un script de monitoreo, al que se acceder치 a trav칠s de gol en google.com.  Si la respuesta recibida difiere de la esperada, el script enviar치 una notificaci칩n en el telegrama a la lista de destinatarios.  El registro de auditor칤a se mantiene en el archivo tracking.log. <br><br>  Si necesita agregar otro servicio, simplemente creamos un nuevo archivo ini en la carpeta de servicios y, si es necesario, creamos una lista separada de destinatarios.  Todo lo dem치s funcionar치 autom치ticamente. <br><br>  Si el servicio verificado no est치 disponible, se enviar치 una alerta cada minuto.  Si no puede restaurar r치pidamente el servicio, puede desactivar temporalmente las notificaciones en las propiedades del bot en Telegram. <br><br>  Ahora echemos un vistazo m치s de cerca a las caracter칤sticas adicionales y la implementaci칩n de scripts. <br><br><h2>  Plantillas de mensajes y compromiso emocional </h2><br>  Para que la comunicaci칩n con el bot sea m치s animada, lo llamamos Manechka, agregamos el avatar de imagen correspondiente y contratamos a especialistas profesionales de relaciones p칰blicas para crear mensajes de texto.  Puede utilizar nuestros logros o cambiar a su gusto. <br><br>  Por ejemplo, as칤: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zs/kk/nd/zskkndbpynjm9l-o2ujyvblznlw.jpeg"></div><br>  o aun as칤: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ul/nh/e3/ulnhe3lg9gypwy56x53sk-kuegm.png"></div><br>  Por que no <br><br>  El nombre del bot y el avatar se configuran a trav칠s de <a href="https://t.me/botfather" rel="nofollow">@botfather</a> . <br>  Las plantillas de mensajes se encuentran en la carpeta de <b>plantillas</b> : <br><br><ul><li>  <b>curl-fail.txt</b> : mensaje enviado cuando curl devolvi칩 un c칩digo de error distinto de cero.  Por lo general, habla de la imposibilidad de llegar al servicio. </li><li>  <b>daily.txt</b> : mensaje diario que confirma que la supervisi칩n del servicio est치 funcionando. </li><li>  <b>service-fail.txt</b> : mensaje enviado cuando la respuesta del servicio es diferente a la esperada. </li></ul><br>  Examinemos las posibilidades de personalizaci칩n utilizando el ejemplo de las plantillas de mensajes integradas. <br>  Las plantillas usan emojis.  Desafortunadamente, habr no los muestra. <br>  Para seleccionar emojis es conveniente usar la b칰squeda en <a href="https://emojipedia.org/" rel="nofollow">emojipedia.org</a> : <br><br><img src="https://habrastorage.org/webt/wj/uy/_3/wjuy_3icssro1d0hpptoe5xq91e.jpeg"><br><br>  Simplemente copie y pegue el car치cter apropiado en el texto de la plantilla (este es el Unicode habitual). <br><ol><li>  curl-fail.txt: <br><br><pre> <code class="bash hljs">,  ...      \<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_SERVICE_NAME</span></span></span><span class="hljs-string">\" \`CURL EXIT CODE: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$EXIT_CODE</span></span></span><span class="hljs-string">\`</span></span></code> </pre> <br>  Utilizamos el nombre del servicio que especificamos (variable <code>MSMS_SERVICE_NAME</code> ) y una variable de script interno con el c칩digo de terminaci칩n de curl ( <code>EXIT_CODE</code> ).  Tambi칠n formateamos el mensaje usando el marcado de <a href="https://core.telegram.org/bots/api" rel="nofollow">telegrama</a> : los caracteres `` '' enmarcan el texto de un ancho fijo.  Como las comillas y los ap칩strofes son caracteres bash oficiales, los escapamos con el car치cter "\".  Los nombres de las variables est치n precedidos por un signo "$". <br><br>  Resultado: <br><br><img src="https://habrastorage.org/webt/po/zf/3n/pozf3neoa1bjqxslwqny1ocal2s.jpeg"><br></li><li>  service-fail.txt: <br><br><pre> <code class="bash hljs">,  ...  \<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_SERVICE_NAME</span></span></span><span class="hljs-string">\"     ,     : \`</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$RESPONSE</span></span></span><span class="hljs-string">\`</span></span></code> </pre> <br>  Resultado: <br><br><img src="https://habrastorage.org/webt/kv/f1/tl/kvf1tlzbrmm3cqdpf70tnm0m2z4.jpeg"><br><br>  Aqu칤 usamos otra variable de script: <code>RESPONSE</code> .  Contiene la respuesta del servicio. <br></li><li>  daily.txt: <br><br><pre> <code class="bash hljs">, !    , c  : \<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_SERVICE_NAME</span></span></span><span class="hljs-string">\"  ...     ?</span></span></code> </pre><br>  Resultado: <br><br><img src="https://habrastorage.org/webt/qs/ox/r_/qsoxr_bkdi8qva9ms1xzwpxugxa.jpeg"><br></li></ol><br>  Pasemos a la implementaci칩n de scripts. <br><br><h2>  Script de monitoreo </h2><br>  <b>Monitoring.sh</b> hace que el autodescubrimiento sea simple: toma todos los archivos ini de la carpeta de servicios y para cada uno ejecuta el script principal con la l칩gica para verificar y enviar alertas: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash cd $(dirname "$0")/services for service_ini in $(ls *.ini); do bash ../msms.sh "$1" "$service_ini" done</span></span></code> </pre> <br>  Para generar un mensaje diario sobre el estado de supervisi칩n, el script puede pasar el par치metro DIARIO. <br><br>  Tenga en cuenta que cuando se inicia el script, la carpeta actual cambia a servicios.  Esto permite que los archivos ini especifiquen las rutas de los archivos en relaci칩n con los servicios. <br><br><h2>  Script para verificar y enviar alertas </h2><br>  <b>msms.sh</b> contiene la l칩gica b치sica de verificar un servicio y enviar alertas. <br><br>  Trabajar con telegrama: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># telegram endpoint TG_API_URL="https://api.telegram.org/bot$(cat ../telegram-api-key.txt)/sendMessage" ################################################################# # send message to telegram # parameter: message text ################################################################# function send_message { for chat_id in $(cat ../$MSMS_RECIPIENTS); do curl -s -X POST --connect-timeout 10 $TG_API_URL -d chat_id=$chat_id -d parse_mode="Markdown" -d text="$1" echo done }</span></span></code> </pre><br>  Creamos una URL para acceder a la API REST de telegramas utilizando la clave privada almacenada en el archivo. <br><br>  La funci칩n send_message usa curl para enviar mensajes a esta API REST, tomando la identificaci칩n del destinatario del archivo que especificamos en ini.  En los datos que enviamos, indicamos que usamos marcado de mensajes: <code>parse_mode="Markdown"</code> . <br><br>  Imprima la fecha y hora actual y cargue el archivo ini. <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $(date <span class="hljs-string"><span class="hljs-string">'+%Y-%m-%d %H:%M:%S'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># load variables from .ini file: . $2</span></span></code> </pre><br>  La linea magica <code>. $2</code>  <code>. $2</code> ejecuta el archivo ini pasado como segundo par치metro como un script ordinario, ingresando los valores especificados en 칠l en las variables de entorno. <br><br>  Descargue la respuesta esperada del archivo si se <code>MSMS_EXPECTED_FILE</code> par치metro <code>MSMS_EXPECTED_FILE</code> : <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_EXPECTED_FILE</span></span></span><span class="hljs-string">"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> MSMS_EXPECTED=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(cat "$MSMS_EXPECTED_FILE")</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre><br>  Realice una verificaci칩n de servicio con el env칤o de alertas, si es necesario: <br><br><pre> <code class="bash hljs">RESPONSE=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(eval curl $MSMS_CURL_PARAMS \"$MSMS_SERVICE_ENDPOINT\")</span></span></span><span class="hljs-string">"</span></span> EXIT_CODE=$? <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$EXIT_CODE</span></span> != 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> health-check \<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_SERVICE_NAME</span></span></span><span class="hljs-string">\" FAILED: CURL EXIT WITH </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$EXIT_CODE</span></span></span><span class="hljs-string"> MESSAGE="</span></span>$(cat ../templates/curl-fail.txt)<span class="hljs-string"><span class="hljs-string">" MESSAGE=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(eval echo $MESSAGE)</span></span></span><span class="hljs-string"> send_message "</span></span><span class="hljs-variable"><span class="hljs-variable">$MESSAGE</span></span><span class="hljs-string"><span class="hljs-string">" elif [[ "</span></span><span class="hljs-variable"><span class="hljs-variable">$RESPONSE</span></span><span class="hljs-string"><span class="hljs-string">" != "</span></span><span class="hljs-variable"><span class="hljs-variable">$MSMS_EXPECTED</span></span><span class="hljs-string"><span class="hljs-string">" ]]; then echo health-check \"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_SERVICE_NAME</span></span></span><span class="hljs-string">\" FAILED: "</span></span><span class="hljs-variable"><span class="hljs-variable">$RESPONSE</span></span><span class="hljs-string"><span class="hljs-string">" MESSAGE="</span></span>$(cat ../templates/service-fail.txt)<span class="hljs-string"><span class="hljs-string">" MESSAGE=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(eval echo $MESSAGE)</span></span></span><span class="hljs-string"> send_message "</span></span><span class="hljs-variable"><span class="hljs-variable">$MESSAGE</span></span><span class="hljs-string"><span class="hljs-string">" else echo health-check \"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_SERVICE_NAME</span></span></span><span class="hljs-string">\": OK fi</span></span></code> </pre><br>  Primero asignamos la variable <code>RESPONSE</code> al resultado del comando curl para este servicio. <br><br>  Expresi칩n <code>EXIT_CODE=$?</code>  pone el resultado del 칰ltimo comando, es decir  rizo  Si necesita enviar una alerta, la plantilla se lee del archivo correspondiente y el env칤o a los destinatarios se <code>send_message</code> mediante <code>send_message</code> . <br><br>  El 칰ltimo bloque procesa el par치metro DIARIO: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">"DAILY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> health-check \<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_SERVICE_NAME</span></span></span><span class="hljs-string">\" DAILY MESSAGE="</span></span>$(cat ../templates/daily.txt)<span class="hljs-string"><span class="hljs-string">" MESSAGE=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(eval echo $MESSAGE)</span></span></span><span class="hljs-string"> send_message "</span></span><span class="hljs-variable"><span class="hljs-variable">$MESSAGE</span></span><span class="hljs-string"><span class="hljs-string">" fi</span></span></code> </pre> <br>  Env칤a un mensaje confirmando la salud del monitoreo en s칤. <br><br><h2>  Obtener una lista de identificaci칩n de usuario </h2><br>  <b>recipients-setup.sh</b> llama a la API de telegramas para obtener los 칰ltimos mensajes dirigidos al bot: <br><br><pre> <code class="bash hljs">curl -s https://api.telegram.org/bot$(cat telegram-api-key.txt)/getUpdates \ | python recipients-setup.py</code> </pre> <br>  Utiliza la magia de Python para enumerar muy bien la salida.  Esto es opcional, simplemente puede tomar la identificaci칩n deseada de json, que el comando generar치: <br><br><pre> <code class="bash hljs">torsocks curl -s https://api.telegram.org/bot$(cat telegram-api-key.txt)/getUpdates</code> </pre> <br><h2>  Conclusi칩n </h2><br>  Por lo tanto, puede usar scripts y plantillas de mensajes ya preparados, configurando solo servicios y listas observables para notificaciones;  Puede crear una nueva "identidad" para el bot;  y puede tomar su decisi칩n sobre la base de la propuesta. <br><br>  Como opciones para un mayor desarrollo, la configuraci칩n y administraci칩n de monitoreo en el bot en s칤 se sugiere, pero aqu칤 no puede prescindir de Python.  Si alguien pone sus manos delante de m칤, ya sabe d칩nde cargar la solicitud de extracci칩n :-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/483318/">https://habr.com/ru/post/483318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../483308/index.html">Experimento VonmoTrade. Parte 4: Gr치ficos comerciales</a></li>
<li><a href="../483310/index.html">Crea lentes para Snapchat usando pix2pix</a></li>
<li><a href="../483312/index.html">La gran teor칤a del copo de nieve</a></li>
<li><a href="../483314/index.html">C칩mo hacer acciones asincr칩nicas de Redux usando Redux-Thunk</a></li>
<li><a href="../483316/index.html">Introducci칩n r치pida a SwiftUI</a></li>
<li><a href="../483320/index.html">Creaci칩n de un museo medieval de realidad virtual.</a></li>
<li><a href="../483322/index.html">Desarrollo de API REST: 쯖u치l es el enfoque de Code First?</a></li>
<li><a href="../483324/index.html">Procesos flexibles en el equipo de TI.</a></li>
<li><a href="../483328/index.html">API REST - 쯈u칠 es HATEOAS?</a></li>
<li><a href="../483330/index.html">Acerca del funcionamiento de una PC con el ejemplo de Windows 10 y el teclado, parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>