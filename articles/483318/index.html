<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏉 😀 🏴 Bot para monitorear servicios web en media hora: telegram + bash + cron 🐱 ♑️ 🔗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A veces es necesario supervisar rápidamente un nuevo servicio, pero no hay infraestructura / experiencia preparada a la mano. En esta guía, en media h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bot para monitorear servicios web en media hora: telegram + bash + cron</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483318/"><img src="https://habrastorage.org/webt/ks/-r/l9/ks-rl9jvsn3vka3r5kxkj4jvbxg.jpeg"><br><br>  A veces es necesario supervisar rápidamente un nuevo servicio, pero no hay infraestructura / experiencia preparada a la mano.  En esta guía, en media hora implementaremos una herramienta para monitorear cualquier servicio web usando solo las herramientas incorporadas de ubuntu: bash, cron y curl.  Usaremos telegramas para entregar alertas. <br><br>  "Cherry on the cake" será la participación emocional de los usuarios.  Está controlado por personas, funciona. <br><a name="habracut"></a><br>  Cuando creamos un chatbot en el servicio de telemedicina Doctor Near para determinar el nivel de estrés del usuario, necesitábamos monitoreo.  En un par de horas, se realizó un mini proyecto, que no solo funciona muy bien, sino que también agrega comentarios positivos. <br><br>  Para comenzar, obtenga un repositorio con scripts: <br><br><pre><code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/rshekhovtsov/msms.git</code> </pre> <br>  Vaya a la carpeta msms y luego trabaje en ella. <br><br>  Si el telegrama está bloqueado, use un proxy.  La opción más fácil y confiable son los torsocks: <br><br><pre> <code class="bash hljs">sudo apt install tor sudo apt install torsocks</code> </pre> <br>  Como ejemplo, configuraremos el monitoreo de la página de inicio de google.com en tres pasos. <br><br><h2>  PASO 1. Cree un bot en Telegram y obtenga la identificación de usuario </h2><br><ul><li>  En la cadena de búsqueda de contactos en Telegram, busque <a href="https://t.me/botfather" rel="nofollow">@botfather</a> : <br><br><img src="https://habrastorage.org/webt/mf/8r/tx/mf8rtxrovcs-4r8ax2pn7fuxusc.png"><br></li><li>  Comenzamos con el botón de Inicio, ingresamos el comando / newbot y respondemos preguntas.  Debe tener en cuenta que el nombre es el nombre del bot que se mostrará a los usuarios, y el nombre de usuario es único y debe terminar en "bot": <br><br><img src="https://habrastorage.org/webt/gc/q5/fx/gcq5fxjht5xytwso83degwhmslm.png"><br><br>  Entre otras cosas, el bot emitirá un token secreto para la API HTTP, que debe copiar y guardar en el archivo telegram-api-key.txt en la carpeta msms. <br></li><li>  Escribimos el nombre de nuestro bot en la línea de búsqueda de telegramas y lo ejecutamos. <br></li><li>  Como toque final, agréguenos a la lista de destinatarios de alertas de monitoreo: <br><br><pre> <code class="bash hljs">sudo chmod +x ./recipients-setup.sh torsocks ./recipients-setup.sh</code> </pre> <br>  El script mostrará una lista de llamadas recientes al bot, debe haber una línea con nuestra identificación y nombre en el telegrama.  Tomamos esta identificación y la guardamos en el archivo services / google-recipients.txt.  Formato de archivo: cada línea es una identificación.  Un ejemplo: <br><br><pre> <code class="bash hljs">123456789 987654321</code> </pre> </li></ul><br>  Para agregar un nuevo destinatario, debe pedirle que inicie el bot en Telegram, ejecute recipients-setup.sh y agregue la identificación al archivo. <br><br><h2>  PASO 2. Configurar el monitoreo </h2><br>  La descripción del servicio se produce al crear un archivo ini en la carpeta de servicios.  Deben establecerse cinco parámetros: <br><br><ol><li>  <b>MSMS_SERVICE_NAME</b> : nombre del servicio: se utilizará en alertas y <b>registros de</b> monitoreo. </li><li>  <b>MSMS_SERVICE_ENDPOINT</b> : el punto final del servicio con el que nos estaremos contactando curl. </li><li>  <b>MSMS_CURL_PARAMS</b> : parámetros de curvatura adicionales, consulte el ejemplo a continuación. </li><li>  <b>MSMS_EXPECTED</b> : respuesta de servicio esperada.  Se usa si la respuesta es corta. </li><li>  <b>MSMS_EXPECTED_FILE</b> : nombre de archivo con la respuesta de servicio esperada.  Si se especifica, sobrescribe MSMS_EXPECTED. </li><li>  <b>MSMS_RECIPIENTS</b> : archivo con una lista de destinatarios de notificaciones. </li></ol><br>  La solicitud en google.com devuelve un html fijo con un redireccionamiento, lo usaremos como la respuesta esperada del servidor: <br><br><pre> <code class="bash hljs">curl google.com &gt; services/google-response.html</code> </pre> <br>  Cree el archivo services / google.ini: <br><br><pre> <code class="bash hljs">MSMS_SERVICE_NAME=<span class="hljs-string"><span class="hljs-string">'google front page'</span></span> <span class="hljs-comment"><span class="hljs-comment"># service endpoint MSMS_SERVICE_ENDPOINT='google.com' # curl parameters MSMS_CURL_PARAMS='-s --connect-timeout 3 -m 7' # expected service response MSMS_EXPECTED_FILE='google-response.html' # recipients list file MSMS_RECIPIENTS='google-recipients.txt'</span></span></code> </pre> <br>  En <code>MSMS_CURL_PARAMS</code> puede especificar todo lo que curl puede hacer, incluyendo: <br><br><ol><li>  Deshabilite los mensajes curl para no obstruir la consola y registrar: <code>-s</code> </li><li>  Establezca el tiempo de espera de conexión con el servicio que se verifica (en segundos): <code>--connect-timeout 3</code> </li><li>  Establecer tiempo de espera de respuesta: <code>-m 7</code> </li><li>  Deshabilite la verificación de certificados para SSL (por ejemplo, si se utiliza un certificado autofirmado): <code>--insecure</code> </li><li>  Especifique el tipo de solicitud http: <code>-X POST</code> </li><li>  Especifique encabezados: <code>-H "Content-Type: application/json"</code> </li><li>  Especifique el cuerpo de la solicitud como una cadena o archivo.  Ejemplo para el archivo: <code>-d @request.json</code> </li></ol><br>  Desactivamos las notificaciones y establecemos tiempos de espera de 3 segundos.  en conexión y 7 seg.  para recibir una respuesta del servicio. <br><br>  <b>Atención</b> : especifique valores de parámetros entre comillas simples, como en el ejemplo.  Desafortunadamente, bash es bastante frágil en este sentido, y una <s>mariposa que vuela accidentalmente en el</s> lugar equivocado puede conducir a la <s>muerte del universo con</s> errores difíciles de diagnosticar. <br><br>  Configuramos el monitoreo.  Comprueba que todo está bien: <br><br><pre> <code class="bash hljs">sudo chmod +x ./monitoring.sh torsocks ./monitoring.sh</code> </pre> <br>  El script debe mostrar un mensaje de la forma: <br><br><pre> <code class="bash hljs">2020-01-10 12:14:31 health-check <span class="hljs-string"><span class="hljs-string">"google front page"</span></span>: OK</code> </pre> <br><h2>  PASO 3. Ajuste el horario </h2><br>  Configure un horario de monitoreo en cron: <br><br><pre> <code class="bash hljs">sudo crontab -e</code> </pre> <br>  Agregue una línea para revisar google.com cada minuto: <br><br><pre> <code class="bash hljs">*/1 * * * * torsocks &lt;   &gt;/monitoring.sh &gt;&gt; &lt;   &gt;/monitoring.log 2&gt;&amp;1</code> </pre> <br>  Agregue una alerta todos los días a las 11.00, confirmando el monitoreo en sí.  Para hacer esto, pase el parámetro DIARIO al script: <br><br><pre> <code class="bash hljs">0 11 * * * torsocks &lt;   &gt;/monitoring.sh DAILY &gt;&gt; &lt;   &gt;/monitoring.log 2&gt;&amp;1</code> </pre><br>  <code>2&gt;&amp;1</code> : técnica estándar que redirige los errores al flujo de salida principal.  Como resultado, también se incluirán en el registro de monitoreo. <br><br>  Guarda los cambios y atrápalos con el comando: <br><br><pre> <code class="bash hljs"> sudo service cron reload</code> </pre> <br>  Puede leer más sobre la configuración de cron, por ejemplo, <a href="https://losst.ru/nastrojka-cron" rel="nofollow">aquí</a> . <br><br>  Por lo tanto, cada minuto se lanzará un script de monitoreo, al que se accederá a través de gol en google.com.  Si la respuesta recibida difiere de la esperada, el script enviará una notificación en el telegrama a la lista de destinatarios.  El registro de auditoría se mantiene en el archivo tracking.log. <br><br>  Si necesita agregar otro servicio, simplemente creamos un nuevo archivo ini en la carpeta de servicios y, si es necesario, creamos una lista separada de destinatarios.  Todo lo demás funcionará automáticamente. <br><br>  Si el servicio verificado no está disponible, se enviará una alerta cada minuto.  Si no puede restaurar rápidamente el servicio, puede desactivar temporalmente las notificaciones en las propiedades del bot en Telegram. <br><br>  Ahora echemos un vistazo más de cerca a las características adicionales y la implementación de scripts. <br><br><h2>  Plantillas de mensajes y compromiso emocional </h2><br>  Para que la comunicación con el bot sea más animada, lo llamamos Manechka, agregamos el avatar de imagen correspondiente y contratamos a especialistas profesionales de relaciones públicas para crear mensajes de texto.  Puede utilizar nuestros logros o cambiar a su gusto. <br><br>  Por ejemplo, así: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zs/kk/nd/zskkndbpynjm9l-o2ujyvblznlw.jpeg"></div><br>  o aun así: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ul/nh/e3/ulnhe3lg9gypwy56x53sk-kuegm.png"></div><br>  Por que no <br><br>  El nombre del bot y el avatar se configuran a través de <a href="https://t.me/botfather" rel="nofollow">@botfather</a> . <br>  Las plantillas de mensajes se encuentran en la carpeta de <b>plantillas</b> : <br><br><ul><li>  <b>curl-fail.txt</b> : mensaje enviado cuando curl devolvió un código de error distinto de cero.  Por lo general, habla de la imposibilidad de llegar al servicio. </li><li>  <b>daily.txt</b> : mensaje diario que confirma que la supervisión del servicio está funcionando. </li><li>  <b>service-fail.txt</b> : mensaje enviado cuando la respuesta del servicio es diferente a la esperada. </li></ul><br>  Examinemos las posibilidades de personalización utilizando el ejemplo de las plantillas de mensajes integradas. <br>  Las plantillas usan emojis.  Desafortunadamente, habr no los muestra. <br>  Para seleccionar emojis es conveniente usar la búsqueda en <a href="https://emojipedia.org/" rel="nofollow">emojipedia.org</a> : <br><br><img src="https://habrastorage.org/webt/wj/uy/_3/wjuy_3icssro1d0hpptoe5xq91e.jpeg"><br><br>  Simplemente copie y pegue el carácter apropiado en el texto de la plantilla (este es el Unicode habitual). <br><ol><li>  curl-fail.txt: <br><br><pre> <code class="bash hljs">,  ...      \<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_SERVICE_NAME</span></span></span><span class="hljs-string">\" \`CURL EXIT CODE: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$EXIT_CODE</span></span></span><span class="hljs-string">\`</span></span></code> </pre> <br>  Utilizamos el nombre del servicio que especificamos (variable <code>MSMS_SERVICE_NAME</code> ) y una variable de script interno con el código de terminación de curl ( <code>EXIT_CODE</code> ).  También formateamos el mensaje usando el marcado de <a href="https://core.telegram.org/bots/api" rel="nofollow">telegrama</a> : los caracteres `` '' enmarcan el texto de un ancho fijo.  Como las comillas y los apóstrofes son caracteres bash oficiales, los escapamos con el carácter "\".  Los nombres de las variables están precedidos por un signo "$". <br><br>  Resultado: <br><br><img src="https://habrastorage.org/webt/po/zf/3n/pozf3neoa1bjqxslwqny1ocal2s.jpeg"><br></li><li>  service-fail.txt: <br><br><pre> <code class="bash hljs">,  ...  \<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_SERVICE_NAME</span></span></span><span class="hljs-string">\"     ,     : \`</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$RESPONSE</span></span></span><span class="hljs-string">\`</span></span></code> </pre> <br>  Resultado: <br><br><img src="https://habrastorage.org/webt/kv/f1/tl/kvf1tlzbrmm3cqdpf70tnm0m2z4.jpeg"><br><br>  Aquí usamos otra variable de script: <code>RESPONSE</code> .  Contiene la respuesta del servicio. <br></li><li>  daily.txt: <br><br><pre> <code class="bash hljs">, !    , c  : \<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_SERVICE_NAME</span></span></span><span class="hljs-string">\"  ...     ?</span></span></code> </pre><br>  Resultado: <br><br><img src="https://habrastorage.org/webt/qs/ox/r_/qsoxr_bkdi8qva9ms1xzwpxugxa.jpeg"><br></li></ol><br>  Pasemos a la implementación de scripts. <br><br><h2>  Script de monitoreo </h2><br>  <b>Monitoring.sh</b> hace que el autodescubrimiento sea simple: toma todos los archivos ini de la carpeta de servicios y para cada uno ejecuta el script principal con la lógica para verificar y enviar alertas: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash cd $(dirname "$0")/services for service_ini in $(ls *.ini); do bash ../msms.sh "$1" "$service_ini" done</span></span></code> </pre> <br>  Para generar un mensaje diario sobre el estado de supervisión, el script puede pasar el parámetro DIARIO. <br><br>  Tenga en cuenta que cuando se inicia el script, la carpeta actual cambia a servicios.  Esto permite que los archivos ini especifiquen las rutas de los archivos en relación con los servicios. <br><br><h2>  Script para verificar y enviar alertas </h2><br>  <b>msms.sh</b> contiene la lógica básica de verificar un servicio y enviar alertas. <br><br>  Trabajar con telegrama: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># telegram endpoint TG_API_URL="https://api.telegram.org/bot$(cat ../telegram-api-key.txt)/sendMessage" ################################################################# # send message to telegram # parameter: message text ################################################################# function send_message { for chat_id in $(cat ../$MSMS_RECIPIENTS); do curl -s -X POST --connect-timeout 10 $TG_API_URL -d chat_id=$chat_id -d parse_mode="Markdown" -d text="$1" echo done }</span></span></code> </pre><br>  Creamos una URL para acceder a la API REST de telegramas utilizando la clave privada almacenada en el archivo. <br><br>  La función send_message usa curl para enviar mensajes a esta API REST, tomando la identificación del destinatario del archivo que especificamos en ini.  En los datos que enviamos, indicamos que usamos marcado de mensajes: <code>parse_mode="Markdown"</code> . <br><br>  Imprima la fecha y hora actual y cargue el archivo ini. <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $(date <span class="hljs-string"><span class="hljs-string">'+%Y-%m-%d %H:%M:%S'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># load variables from .ini file: . $2</span></span></code> </pre><br>  La linea magica <code>. $2</code>  <code>. $2</code> ejecuta el archivo ini pasado como segundo parámetro como un script ordinario, ingresando los valores especificados en él en las variables de entorno. <br><br>  Descargue la respuesta esperada del archivo si se <code>MSMS_EXPECTED_FILE</code> parámetro <code>MSMS_EXPECTED_FILE</code> : <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_EXPECTED_FILE</span></span></span><span class="hljs-string">"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> MSMS_EXPECTED=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(cat "$MSMS_EXPECTED_FILE")</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre><br>  Realice una verificación de servicio con el envío de alertas, si es necesario: <br><br><pre> <code class="bash hljs">RESPONSE=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(eval curl $MSMS_CURL_PARAMS \"$MSMS_SERVICE_ENDPOINT\")</span></span></span><span class="hljs-string">"</span></span> EXIT_CODE=$? <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$EXIT_CODE</span></span> != 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> health-check \<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_SERVICE_NAME</span></span></span><span class="hljs-string">\" FAILED: CURL EXIT WITH </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$EXIT_CODE</span></span></span><span class="hljs-string"> MESSAGE="</span></span>$(cat ../templates/curl-fail.txt)<span class="hljs-string"><span class="hljs-string">" MESSAGE=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(eval echo $MESSAGE)</span></span></span><span class="hljs-string"> send_message "</span></span><span class="hljs-variable"><span class="hljs-variable">$MESSAGE</span></span><span class="hljs-string"><span class="hljs-string">" elif [[ "</span></span><span class="hljs-variable"><span class="hljs-variable">$RESPONSE</span></span><span class="hljs-string"><span class="hljs-string">" != "</span></span><span class="hljs-variable"><span class="hljs-variable">$MSMS_EXPECTED</span></span><span class="hljs-string"><span class="hljs-string">" ]]; then echo health-check \"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_SERVICE_NAME</span></span></span><span class="hljs-string">\" FAILED: "</span></span><span class="hljs-variable"><span class="hljs-variable">$RESPONSE</span></span><span class="hljs-string"><span class="hljs-string">" MESSAGE="</span></span>$(cat ../templates/service-fail.txt)<span class="hljs-string"><span class="hljs-string">" MESSAGE=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(eval echo $MESSAGE)</span></span></span><span class="hljs-string"> send_message "</span></span><span class="hljs-variable"><span class="hljs-variable">$MESSAGE</span></span><span class="hljs-string"><span class="hljs-string">" else echo health-check \"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_SERVICE_NAME</span></span></span><span class="hljs-string">\": OK fi</span></span></code> </pre><br>  Primero asignamos la variable <code>RESPONSE</code> al resultado del comando curl para este servicio. <br><br>  Expresión <code>EXIT_CODE=$?</code>  pone el resultado del último comando, es decir  rizo  Si necesita enviar una alerta, la plantilla se lee del archivo correspondiente y el envío a los destinatarios se <code>send_message</code> mediante <code>send_message</code> . <br><br>  El último bloque procesa el parámetro DIARIO: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">"DAILY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> health-check \<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MSMS_SERVICE_NAME</span></span></span><span class="hljs-string">\" DAILY MESSAGE="</span></span>$(cat ../templates/daily.txt)<span class="hljs-string"><span class="hljs-string">" MESSAGE=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(eval echo $MESSAGE)</span></span></span><span class="hljs-string"> send_message "</span></span><span class="hljs-variable"><span class="hljs-variable">$MESSAGE</span></span><span class="hljs-string"><span class="hljs-string">" fi</span></span></code> </pre> <br>  Envía un mensaje confirmando la salud del monitoreo en sí. <br><br><h2>  Obtener una lista de identificación de usuario </h2><br>  <b>recipients-setup.sh</b> llama a la API de telegramas para obtener los últimos mensajes dirigidos al bot: <br><br><pre> <code class="bash hljs">curl -s https://api.telegram.org/bot$(cat telegram-api-key.txt)/getUpdates \ | python recipients-setup.py</code> </pre> <br>  Utiliza la magia de Python para enumerar muy bien la salida.  Esto es opcional, simplemente puede tomar la identificación deseada de json, que el comando generará: <br><br><pre> <code class="bash hljs">torsocks curl -s https://api.telegram.org/bot$(cat telegram-api-key.txt)/getUpdates</code> </pre> <br><h2>  Conclusión </h2><br>  Por lo tanto, puede usar scripts y plantillas de mensajes ya preparados, configurando solo servicios y listas observables para notificaciones;  Puede crear una nueva "identidad" para el bot;  y puede tomar su decisión sobre la base de la propuesta. <br><br>  Como opciones para un mayor desarrollo, la configuración y administración de monitoreo en el bot en sí se sugiere, pero aquí no puede prescindir de Python.  Si alguien pone sus manos delante de mí, ya sabe dónde cargar la solicitud de extracción :-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/483318/">https://habr.com/ru/post/483318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../483308/index.html">Experimento VonmoTrade. Parte 4: Gráficos comerciales</a></li>
<li><a href="../483310/index.html">Crea lentes para Snapchat usando pix2pix</a></li>
<li><a href="../483312/index.html">La gran teoría del copo de nieve</a></li>
<li><a href="../483314/index.html">Cómo hacer acciones asincrónicas de Redux usando Redux-Thunk</a></li>
<li><a href="../483316/index.html">Introducción rápida a SwiftUI</a></li>
<li><a href="../483320/index.html">Creación de un museo medieval de realidad virtual.</a></li>
<li><a href="../483322/index.html">Desarrollo de API REST: ¿cuál es el enfoque de Code First?</a></li>
<li><a href="../483324/index.html">Procesos flexibles en el equipo de TI.</a></li>
<li><a href="../483328/index.html">API REST - ¿Qué es HATEOAS?</a></li>
<li><a href="../483330/index.html">Acerca del funcionamiento de una PC con el ejemplo de Windows 10 y el teclado, parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>