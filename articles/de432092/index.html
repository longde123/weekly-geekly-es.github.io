<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÆ ü¶å üöÇ Unangenehme Fehler beim Schreiben von Unit-Tests üíê üè° üè®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neulich werde ich einen internen Bericht erstellen, in dem ich unseren Entwicklern die unangenehmen Fehler erl√§utere, die beim Schreiben von Komponent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unangenehme Fehler beim Schreiben von Unit-Tests</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432092/">  Neulich werde ich einen internen Bericht erstellen, in dem ich unseren Entwicklern die unangenehmen Fehler erl√§utere, die beim Schreiben von Komponententests auftreten k√∂nnen.  Die aus meiner Sicht unangenehmsten Fehler sind, wenn die Tests bestanden werden, aber gleichzeitig machen sie es so falsch, dass es besser w√§re, nicht zu bestehen.  Und ich habe beschlossen, Beispiele f√ºr solche Fehler mit allen zu teilen.  Sicherlich noch etwas aus dieser Gegend zu erz√§hlen.  Beispiele sind f√ºr Node.JS und Mocha geschrieben, aber im Allgemeinen gelten diese Fehler f√ºr jedes andere √ñkosystem. <br><br>  Um es interessanter zu machen, sind einige von ihnen in Form eines Problemcodes und eines Spoilers eingerahmt, der √∂ffnet, und Sie werden sehen, was das Problem war.  Ich empfehle daher, dass Sie sich zuerst den Code ansehen, einen Fehler darin finden und dann den Spoiler √∂ffnen.  Es wird keine L√∂sung f√ºr die Probleme angegeben - ich schlage vor, selbst dar√ºber nachzudenken.  Nur weil ich faul bin.  Die Reihenfolge der Liste macht keinen Sinn - es ist nur eine Sequenz, in der ich mich an alle m√∂glichen wirklichen Probleme erinnerte, die uns zu blutigen Tr√§nen brachten.  Sicherlich werden Ihnen viele Dinge offensichtlich erscheinen - aber selbst erfahrene Entwickler k√∂nnen versehentlich solchen Code schreiben. <br><br><a name="habracut"></a><br>  Also lass uns gehen. <br><br><h3>  0. Fehlende Tests </h3><br>  Seltsamerweise glauben viele immer noch, dass das Schreiben von Tests die Entwicklungsgeschwindigkeit verlangsamt.  Nat√ºrlich ist es offensichtlich, dass mehr Zeit f√ºr das Schreiben von Tests und das Schreiben von Code aufgewendet werden muss, der getestet werden kann.  Aber nach dem Debuggen und Regressionen m√ºssen Sie viel mehr Zeit verbringen ... <br><br><h3>  1. Das Fehlen laufender Tests </h3><br>  Wenn Sie Tests haben, die Sie nicht oder von Zeit zu Zeit ausf√ºhren, ist dies wie das Fehlen von Tests.  Und es ist noch schlimmer - Sie haben einen veralteten Testcode und ein falsches Sicherheitsgef√ºhl.  Tests sollten mindestens in CI-Prozessen ausgef√ºhrt werden, wenn Code in einen Zweig verschoben wird.  Und besser - lokal vor dem Push.  Dann muss der Entwickler in wenigen Tagen nicht mehr zum Build zur√ºckkehren, was, wie sich herausstellte, nicht bestanden hat. <br><br><h3>  2. Mangelnde Deckung </h3><br>  Wenn Sie immer noch nicht wissen, welche Abdeckung in Tests enthalten ist, ist es jetzt an der Zeit, zu lesen.  Zumindest <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> .  Andernfalls besteht eine gute Chance, dass Ihr Test 10% des Codes √ºberpr√ºft, von dem Sie glauben, dass er √ºberpr√ºft wird.  Fr√ºher oder sp√§ter werden Sie definitiv darauf treten.  Selbst eine 100% ige Abdeckung des Codes garantiert nat√ºrlich in keiner Weise seine vollst√§ndige Richtigkeit - aber dies ist viel besser als die mangelnde Abdeckung, da es Ihnen viel mehr potenzielle Fehler zeigt.  Kein Wunder, dass die neuesten Versionen von Node.JS sogar integrierte Tools zum Lesen haben.  Im Allgemeinen ist das Thema Berichterstattung tiefgreifend und √§u√üerst ganzheitlich, aber ich werde nicht zu tief darauf eingehen - ich m√∂chte ein wenig √ºber viel sagen. <br><br><h3>  3. </h3><br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'bluebird'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sinon = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'sinon'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MightyLibrary</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> someLongFunction() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// just imagine a really complex and long function here } } async function doItQuickOrFail() { let res; try { res = await MightyLibrary.someLongFunction().timeout(1000); } catch (err) { if (err instanceof Promise.TimeoutError) { return false; } throw err; } return res; } describe('using Timeouts', ()=&gt;{ it('should return false if waited too much', async ()=&gt;{ // stub function to emulate looong work sinon.stub(MightyLibrary, 'someLongFunction').callsFake(()=&gt;Promise.delay(10000).then(()=&gt;true)); const res = await doItQuickOrFail(); assert.equal(res, false); }); });</span></span></code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Was ist hier los?</b> <div class="spoiler_text"><blockquote>  Zeit√ºberschreitungen bei Unit-Tests. <br><br>  Hier wollten sie √ºberpr√ºfen, ob das Einstellen von Zeit√ºberschreitungen f√ºr einen langen Vorgang wirklich funktioniert.  Im Allgemeinen macht dies ohnehin wenig Sinn - Sie sollten die Standardbibliotheken nicht √ºberpr√ºfen - aber auch dieser Code f√ºhrt zu einem anderen Problem -, um die Ausf√ºhrungszeit von Tests f√ºr eine Sekunde zu verl√§ngern.  Es scheint, dass dies nicht so viel ist ... Aber multiplizieren Sie diese Sekunde mit der Anzahl √§hnlicher Tests, mit der Anzahl der Entwickler, mit der Anzahl der Starts pro Tag ... Und Sie werden verstehen, dass Sie aufgrund solcher Zeit√ºberschreitungen w√∂chentlich viele Stunden Arbeit verlieren k√∂nnen, wenn nicht sogar t√§glich. </blockquote><br></div></div><br><br><h3>  4. </h3><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testData = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'./testData.json'</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>)); describe(<span class="hljs-string"><span class="hljs-string">'some block'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should do something'</span></span>, ()=&gt;{ someTest(testData); }) })</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Was ist hier los?</b> <div class="spoiler_text"><blockquote>  Laden von Testdaten au√üerhalb von Testbl√∂cken. <br><br>  Auf den ersten Blick scheint es egal zu sein, wo die Testdaten gelesen werden sollen - in der Beschreibung, im Block oder im Modul selbst.  Auch beim zweiten.  Stellen Sie sich jedoch vor, Sie haben Hunderte von Tests, von denen viele umfangreiche Daten verwenden.  Wenn Sie sie au√üerhalb des Tests laden, f√ºhrt dies dazu, dass alle Testdaten bis zum Ende der Testausf√ºhrung im Speicher verbleiben und der Start im Laufe der Zeit immer mehr RAM verbraucht - bis sich herausstellt, dass die Tests √ºberhaupt nicht mehr ausgef√ºhrt werden Standardarbeitsmaschinen. </blockquote><br></div></div><br><br><h3>  5. </h3><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sinon = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'sinon'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// eslint-disable-next-line class-methods-use-this say() { return 'Wow'; } } describe('stubsEverywhere', ()=&gt;{ before(()=&gt;{ sinon.stub(Dog.prototype, 'say').callsFake(()=&gt;{ return 'meow'; }); }); it('should say meow', ()=&gt;{ const dog = new Dog(); assert.equal(dog.say(), 'meow', 'dog should say "meow!"'); }); });</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Was ist hier los?</b> <div class="spoiler_text"><blockquote>  Der Code wird tats√§chlich durch Stubs ersetzt. <br><br>  Sicher haben Sie diesen l√§cherlichen Fehler sofort gesehen.  In echtem Code ist dies nat√ºrlich nicht so offensichtlich - aber ich habe Code gesehen, der so mit Stubs aufgeh√§ngt war, dass ich √ºberhaupt nichts getestet habe. </blockquote><br></div></div><br><br><h3>  6. </h3><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sinon = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'sinon'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span></span>{ fetch() {} loadData() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fetch(); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sinon.sandbox || !sinon.sandbox.stub) { sinon.sandbox = sinon.createSandbox(); } describe(<span class="hljs-string"><span class="hljs-string">'My widget'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'is awesome'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> widget = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Widget(); widget.fetch = sinon.sandbox.stub().returns({ <span class="hljs-attr"><span class="hljs-attr">one</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">two</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); widget.loadData(); assert.isTrue(widget.fetch.called); }); });</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Was ist hier los?</b> <div class="spoiler_text"><blockquote>  Abh√§ngigkeit zwischen Tests. <br><br>  Auf den ersten Blick ist klar, dass sie vergessen haben, hier zu schreiben <br><br><pre> <code class="javascript hljs"> afterEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { sinon.sandbox.restore(); });</code> </pre> <br><br>  Das Problem ist aber nicht nur das, sondern dass f√ºr alle Tests dieselbe Sandbox verwendet wird.  Und es ist sehr leicht, die Testausf√ºhrungsumgebung so zu verwechseln, dass sie voneinander abh√§ngig werden.  Danach werden die Tests nur in einer bestimmten Reihenfolge durchgef√ºhrt, und im Allgemeinen ist nicht klar, was getestet werden soll. <br><br>  Gl√ºcklicherweise wurde sinon.sandbox irgendwann f√ºr veraltet und ausgeschnitten erkl√§rt, sodass Sie nur bei einem Legacy-Projekt auf ein solches Problem sto√üen k√∂nnen. Es gibt jedoch so viele andere M√∂glichkeiten, die Testausf√ºhrungsumgebung so zu verwirren, dass eine sp√§tere Untersuchung schmerzhaft schmerzhaft ist. Welcher Code ist an falschem Verhalten schuld?  √úbrigens gab es k√ºrzlich einen Beitrag in einem Hub √ºber eine Art Vorlage wie ‚ÄûIce Factory‚Äú - dies ist kein Allheilmittel, aber manchmal hilft es in solchen F√§llen. </blockquote><br><br></div></div><br><br><h3>  7. Riesige Testdaten in der Testdatei </h3><br><br>  Sehr oft habe ich gesehen, wie gro√üe JSON-Dateien und sogar XML direkt im Test lagen.  Ich denke, es ist offensichtlich, warum sich dies nicht lohnt - es wird schmerzhaft, es anzusehen, zu bearbeiten, und jede IDE wird es Ihnen nicht danken.  Wenn Sie gro√üe Testdaten haben, nehmen Sie diese aus der Testdatei. <br><br><h3>  8. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crypto = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'crypto'</span></span>); describe(<span class="hljs-string"><span class="hljs-string">'extraTests'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should generate unique bytes'</span></span>, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = crypto.randomBytes(<span class="hljs-number"><span class="hljs-number">256</span></span>); arr.push(value); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unique = arr.filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el, index</span></span></span><span class="hljs-function">)=&gt;</span></span>arr.indexOf(el) === index); assert.equal(arr.length, unique.length, <span class="hljs-string"><span class="hljs-string">'Data is not random enough!'</span></span>); }); });</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Was ist hier los?</b> <div class="spoiler_text"><blockquote>  Zus√§tzliche Tests. <br><br>  In diesem Fall war der Entwickler sehr besorgt, dass seine eindeutigen Kennungen eindeutig sein w√ºrden, und schrieb daher einen Scheck daf√ºr.  Im Allgemeinen ein verst√§ndlicher Wunsch - aber es ist besser, die Dokumentation zu lesen oder einen solchen Test mehrmals durchzuf√ºhren, ohne ihn dem Projekt hinzuzuf√ºgen.  Es macht keinen Sinn, es in jedem Build auszuf√ºhren. <br><br>  Nun, das Unentschieden f√ºr zuf√§llige Werte im Test ist an sich schon eine gro√üartige M√∂glichkeit, sich in den Fu√ü zu schie√üen, indem Sie einen instabilen Test von Grund auf neu durchf√ºhren. </blockquote><br></div></div><br><br><h3>  9. Mangel an Mok </h3><br>  Es ist viel einfacher, Tests mit einer Live-Datenbank und 100-prozentigen Diensten auszuf√ºhren und Tests mit ihnen durchzuf√ºhren. <br>  Aber fr√ºher oder sp√§ter wird es wieder Fr√ºchte tragen - Datenentfernungstests werden auf der Produktbasis durchgef√ºhrt, fallen aufgrund eines defekten Partnerservices ab oder Ihr CI verf√ºgt einfach nicht √ºber eine Basis, auf der sie ausgef√ºhrt werden k√∂nnen.  Im Allgemeinen ist das Element ziemlich ganzheitlich, aber in der Regel - wenn Sie externe Dienste emulieren k√∂nnen, ist es besser, dies zu tun. <br><br><h3>  11. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomError</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mytestFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomError(<span class="hljs-string"><span class="hljs-string">'important message'</span></span>); } describe(<span class="hljs-string"><span class="hljs-string">'badCompare'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should throw only my custom errors'</span></span>, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> errorHappened = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { mytestFunction(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { errorHappened = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; assert.isTrue(err <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> CustomError); } assert.isTrue(errorHappened); }); });</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Was ist hier los?</b> <div class="spoiler_text"><blockquote>  Kompliziertes Fehler-Debugging. <br><br>  Alles ist nicht schlecht, aber es gibt ein Problem: Wenn der Test pl√∂tzlich abst√ºrzt, wird ein Fehler im Formular angezeigt <br><br> <code>1) badCompare <br> should throw only my custom errors: <br> <br> AssertionError: expected false to be true <br> + expected - actual <br> <br> -false <br> +true <br> <br> at Context.it (test/011_badCompare/test.js:23:14)</code> <br> <br>  Um zu verstehen, welche Art von Fehler tats√§chlich aufgetreten ist, m√ºssen Sie den Test neu schreiben.  Versuchen Sie also im Falle eines unerwarteten Fehlers, den Test dar√ºber sprechen zu lassen, und nicht nur die Tatsache, dass es passiert ist. </blockquote><br></div></div><br><br><h3>  12. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someVeryBigFunc1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// imagine a tonn of code here } function someVeryBigFunc2() { return 2; // imagine a tonn of code here } describe('all Before Tests', ()=&gt;{ let res1; let res2; before(async ()=&gt;{ res1 = await someVeryBigFunc1(); res2 = await someVeryBigFunc2(); }); it('should return 1', ()=&gt;{ assert.equal(res1, 1); }); it('should return 2', ()=&gt;{ assert.equal(res2, 2); }); });</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Was ist hier los?</b> <div class="spoiler_text"><blockquote>  Alles im Vorblock. <br><br>  Es scheint, dass ein cooler Ansatz darin besteht, alle Operationen im "Vorher" -Block auszuf√ºhren und daher nur √úberpr√ºfungen im "Es" zu belassen. <br>  Nicht wirklich. <br>  Denn in diesem Fall gibt es ein Durcheinander, in dem Sie weder den Zeitpunkt der tats√§chlichen Ausf√ºhrung der Tests noch den Grund f√ºr den Sturz verstehen k√∂nnen, noch was sich auf einen Test bezieht und was auf einen anderen. <br>  Daher sollte die gesamte Arbeit des Tests (mit Ausnahme von Standardinitialisierungen) innerhalb des Tests selbst ausgef√ºhrt werden. </blockquote><br></div></div><br><br><h3>  13. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> moment = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'moment'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someDateBasedFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">date</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moment().isAfter(date)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } describe(<span class="hljs-string"><span class="hljs-string">'useFutureDate'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should return 0 for passed date'</span></span>, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pastDate = moment(<span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>); assert.equal(someDateBasedFunction(pastDate), <span class="hljs-number"><span class="hljs-number">0</span></span>); }); it(<span class="hljs-string"><span class="hljs-string">'should return 1 for future date'</span></span>, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itWillAlwaysBeInFuture = moment(<span class="hljs-string"><span class="hljs-string">'2030-01-01'</span></span>); assert.equal(someDateBasedFunction(itWillAlwaysBeInFuture), <span class="hljs-number"><span class="hljs-number">1</span></span>); }); });</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Was ist hier los?</b> <div class="spoiler_text"><blockquote>  Termine binden. <br><br>  Es scheint auch ein offensichtlicher Fehler zu sein - aber es tritt auch regelm√§√üig bei m√ºden Entwicklern auf, die bereits glauben, dass morgen niemals kommen wird.  Und der Build, der gestern gut lief, f√§llt heute pl√∂tzlich ab. <br><br>  Denken Sie daran, dass jedes Datum fr√ºher oder sp√§ter kommen wird - verwenden Sie also entweder die Zeitemulation mit Dingen wie "sinon.fakeTimers" oder setzen Sie zumindest entfernte Daten wie 2050 - lassen Sie Ihre Nachkommen verletzen ... </blockquote><br></div></div><br><br><h3>  14. </h3><br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'dynamicRequires'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should return english locale'</span></span>, ()=&gt;{ <span class="hljs-comment"><span class="hljs-comment">// HACK : // Some people mutate locale in tests to chinese so I will require moment here // eslint-disable-next-line global-require const moment = require('moment'); const someDate = moment('2010-01-01').format('MMMM'); assert.equal(someDate, 'January'); }); });</span></span></code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Was ist hier los?</b> <div class="spoiler_text"><blockquote>  Dynamisches Laden von Modulen. <br><br>  Wenn Sie Eslint haben, haben Sie wahrscheinlich bereits dynamische Abh√§ngigkeiten gesperrt.  Oder nicht. <br>  Oft sehe ich, dass Entwickler versuchen, Bibliotheken oder verschiedene Module direkt in die Tests zu laden.  Sie wissen jedoch im Allgemeinen, wie "erfordern" funktioniert - aber sie bevorzugen die Illusion, dass sie ein sauberes Modul erhalten sollen, das bisher niemand verwirrt hat. <br>  Diese Annahme ist insofern gef√§hrlich, als das Laden zus√§tzlicher Module w√§hrend der Tests langsamer ist und wiederum zu einem undefinierteren Verhalten f√ºhrt. </blockquote><br></div></div><br><br><h3>  15. </h3><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someComplexFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Imagine a piece of really strange code here return 1; } describe('cryptic', ()=&gt;{ it('success', ()=&gt;{ const result = someComplexFunc(); assert.equal(result, 1); }); it('should not fail', ()=&gt;{ const result = someComplexFunc(); assert.equal(result, 1); }); it('is right', ()=&gt;{ const result = someComplexFunc(); assert.equal(result, 1); }); it('makes no difference for solar system', ()=&gt;{ const result = someComplexFunc(); assert.equal(result, 1); }); });</span></span></code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Was ist hier los?</b> <div class="spoiler_text"><blockquote>  Unverst√§ndliche Testnamen. <br><br>  Sie m√ºssen m√ºde von offensichtlichen Dingen sein, oder?  Aber Sie m√ºssen immer noch dazu sagen, weil sich viele nicht die M√ºhe machen, verst√§ndliche Namen f√ºr die Tests zu schreiben - und als Ergebnis ist es m√∂glich zu verstehen, was ein bestimmter Test nur nach viel Forschung tut. </blockquote><br></div></div><br><br><h3>  16. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'bluebird'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someTomeoutingFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.TimeoutError(); } describe(<span class="hljs-string"><span class="hljs-string">'no Error check'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should throw error'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timedOut = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> someTomeoutingFunction(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { timedOut = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } assert.equal(timedOut, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); }); });</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Was ist hier los?</b> <div class="spoiler_text"><blockquote>  Fehlende √úberpr√ºfung des ausgel√∂sten Fehlers. <br><br>  Oft m√ºssen Sie √ºberpr√ºfen, ob die Funktion in einigen F√§llen einen Fehler ausl√∂st.  Aber Sie m√ºssen immer √ºberpr√ºfen, ob dies die Droiden sind, nach denen wir suchen - da sich pl√∂tzlich herausstellen kann, dass ein anderer Fehler an einem anderen Ort und aus anderen Gr√ºnden aufgetreten ist ... </blockquote><br></div></div><br><br><h3>  17. </h3><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someBadFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'I am just wrong!'</span></span>); } describe.skip(<span class="hljs-string"><span class="hljs-string">'skipped test'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should be fine'</span></span>, ()=&gt;{ someBadFunc(); }); });</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Was ist hier los?</b> <div class="spoiler_text"><blockquote>  Deaktivierte Tests. <br><br>  Nat√ºrlich kann es immer dann vorkommen, dass der Code bereits viele Male mit Ihren H√§nden getestet wurde, Sie ihn dringend rollen m√ºssen und der Test aus irgendeinem Grund nicht funktioniert.  Zum Beispiel aufgrund der nicht offensichtlichen Komplikation eines anderen Tests, √ºber den ich zuvor geschrieben habe.  Und der Test ist ausgeschaltet.  Und das ist normal.  Nicht normal - Stellen Sie den Test nicht sofort wieder ein.  Wenn dies nicht getan wird, vervielfacht sich die Anzahl der deaktivierten Tests und ihr Code wird st√§ndig veraltet.  Bis die einzige M√∂glichkeit bleibt - zeigen Sie Gnade und werfen Sie all diese Tests nafig, denn es ist schneller, sie erneut zu schreiben, als die Fehler zu verstehen. </blockquote><br></div></div><br><br>  Hier ist eine solche Auswahl herausgekommen.  Alle diese Tests bestehen die Tests gut, sind jedoch vom Design her fehlerhaft.  F√ºgen Sie Ihre Optionen in den Kommentaren oder im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository hinzu, das</a> ich erstellt habe, um solche Fehler zu sammeln. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432092/">https://habr.com/ru/post/de432092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432082/index.html">Microsoft AI Chatbot startet China Clothing Collection</a></li>
<li><a href="../de432084/index.html">Wie wir einen Schichtwettbewerb zwischen Produktionsarbeitern arrangiert haben (wie in der UdSSR)</a></li>
<li><a href="../de432086/index.html">3D-Druck an der nach M.V. Lomonosov benannten internationalen Schule</a></li>
<li><a href="../de432088/index.html">MySQL-Hochverf√ºgbarkeit auf GitHub</a></li>
<li><a href="../de432090/index.html">Magento Meetup Kharkiv No. 4 - Videoberichte</a></li>
<li><a href="../de432094/index.html">Gemeinsamer Online-Hackathon von OpenGift und Credits Blockchain Platform</a></li>
<li><a href="../de432096/index.html">Komplette CMake-Anleitung. Teil Zwei: Build System</a></li>
<li><a href="../de432098/index.html">Autopiloten im Stra√üenverkehr, wie man mit Specials umgeht. mit dem Transport?</a></li>
<li><a href="../de432100/index.html">Wie wir die Abrechnungskonvertierung verbessert haben</a></li>
<li><a href="../de432102/index.html">Explizite JavaScript-Funktionen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>