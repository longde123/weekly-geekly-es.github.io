<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏼 🥅 ✂️ Kubernet dalam produksi: layanan 🤟🏼 🤩 🍺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Enam bulan lalu, kami menyelesaikan migrasi semua layanan tanpa kewarganegaraan kami ke kubernetes. Sekilas, tugasnya cukup sederhana: Anda perlu meng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernet dalam produksi: layanan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/okmeter/blog/424229/"><p><img align="left" width="250" src="https://habrastorage.org/webt/ww/yz/_z/wwyz_zvbfjx8vrreqprenpo0a00.png">  Enam bulan lalu, kami menyelesaikan migrasi semua layanan tanpa kewarganegaraan kami ke kubernetes.  Sekilas, tugasnya cukup sederhana: Anda perlu menggunakan cluster, menulis spesifikasi aplikasi dan menjalankannya.  Karena obsesi untuk memastikan stabilitas dalam pekerjaan layanan kami, saya harus segera mulai memahami cara kerja k8 dan menguji berbagai skenario kegagalan.  Sebagian besar pertanyaan yang saya miliki tentang segala sesuatu yang berkaitan dengan jaringan.  Salah satu masalah yang licin adalah pengoperasian Layanan di kubernetes. </p><br><p>  Dokumentasi memberi tahu kami: </p><br><ul><li>  jalankan aplikasi </li><li>  mengatur sampel liveness / kesiapan </li><li>  buat layanan </li><li>  maka semuanya akan bekerja: load balancing, failover, dll. </li></ul><br><p>  Namun dalam praktiknya, semuanya agak lebih rumit.  Mari kita lihat bagaimana cara kerjanya. </p><a name="habracut"></a><br><h2 id="nemnogo-teorii">  Sedikit teori </h2><br><p>  Lebih jauh, maksud saya bahwa pembaca sudah terbiasa dengan perangkat kubernetes dan terminologinya, kita hanya ingat apa layanan itu. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan</a> adalah inti dari k8s, yang menggambarkan seperangkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perapian</a> dan metode untuk mengaksesnya. </p><br><p>  Misalnya, kami meluncurkan aplikasi kami: </p><br><pre><code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: webapp spec: selector: matchLabels: app: webapp replicas: 2 template: metadata: labels: app: webapp spec: containers: - name: webapp image: defaultxz/webapp command: ["/webapp", "0.0.0.0:80"] ports: - containerPort: 80 readinessProbe: httpGet: {path: /, port: 80} initialDelaySeconds: 1 periodSeconds: 1</code> </pre> <br><pre> <code class="bash hljs">$ kubectl get pods -l app=webapp NAME READY STATUS RESTARTS AGE webapp-5d5d96f786-b2jxb 1/1 Running 0 3h webapp-5d5d96f786-rt6j7 1/1 Running 0 3h</code> </pre> <br><p>  Sekarang, untuk mengaksesnya, kita harus membuat layanan di mana kita menentukan saluran mana yang ingin kita akses (pemilih) dan di port mana: </p><br><pre> <code class="plaintext hljs">kind: Service apiVersion: v1 metadata: name: webapp spec: selector: app: webapp ports: - protocol: TCP port: 80 targetPort: 80</code> </pre> <br><pre> <code class="bash hljs">$ kubectl get svc webapp NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE webapp ClusterIP 10.97.149.77 &lt;none&gt; 80/TCP 1d</code> </pre> <br><p>  Sekarang kita dapat mengakses layanan kami dari mesin apa pun di kluster: </p><br><pre> <code class="bash hljs">curl -i http://10.97.149.77 HTTP/1.1 200 OK Date: Mon, 24 Sep 2018 11:55:14 GMT Content-Length: 2 Content-Type: text/plain; charset=utf-8</code> </pre> <br><h2 id="kak-eto-vse-rabotaet">  Bagaimana cara kerjanya? </h2><br><img src="https://habrastorage.org/webt/bn/uc/y4/bnucy4fkcptbeo3fwyycr-fc6po.jpeg"><br><p>  Sangat disederhanakan: </p><br><ul><li>  Anda sudah kubectl menerapkan spesifikasi Penerapan </li><li>  keajaiban terjadi, rinciannya tidak penting dalam konteks ini </li><li>  sebagai hasilnya, simpul-simpul aplikasi yang berfungsi ternyata ada pada beberapa simpul </li><li>  sekali setiap interval kubelet (agen k8s pada setiap node) melakukan sampel liness / readiness dari semua pod yang berjalan pada node-nya, ia mengirimkan hasilnya ke apiserver (antarmuka ke otak k8s) </li><li>  kube-proxy pada setiap node menerima pemberitahuan dari apiserver tentang semua perubahan dalam layanan dan perapian yang berpartisipasi dalam layanan </li><li>  kube-proxy mencerminkan semua perubahan dalam konfigurasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">subsistem yang mendasarinya</a> (iptables, ipvs) </li></ul><br><p>  Untuk mempermudah, pertimbangkan metode proxy default - iptables.  Di iptables, kami memiliki untuk ip virtual kami 10.97.149.77: </p><br><pre> <code class="bash hljs">-A KUBE-SERVICES -d 10.97.149.77/32 -p tcp -m comment --comment <span class="hljs-string"><span class="hljs-string">"default/webapp: cluster IP"</span></span> -m tcp --dport 80 -j KUBE-SVC-BL7FHTIPVYJBLWZN</code> </pre> <br><p>  lalu lintas menuju ke <strong>rantai KUBE-SVC-BL7FHTIPVYJBLWZN</strong> , di mana ia didistribusikan di antara 2 rantai lainnya </p><br><pre> <code class="bash hljs">-A KUBE-SVC-BL7FHTIPVYJBLWZN -m comment --comment <span class="hljs-string"><span class="hljs-string">"default/webapp:"</span></span> -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-UPKHDYQWGW4MVMBS -A KUBE-SVC-BL7FHTIPVYJBLWZN -m comment --comment <span class="hljs-string"><span class="hljs-string">"default/webapp:"</span></span> -j KUBE-SEP-FFCBJRUPEN3YPZQT</code> </pre> <br><p>  ini adalah pod kami: </p><br><pre> <code class="bash hljs">-A KUBE-SEP-UPKHDYQWGW4MVMBS -p tcp -m comment --comment <span class="hljs-string"><span class="hljs-string">"default/webapp:"</span></span> -m tcp -j DNAT --to-destination 10.244.0.10:80 -A KUBE-SEP-FFCBJRUPEN3YPZQT -p tcp -m comment --comment <span class="hljs-string"><span class="hljs-string">"default/webapp:"</span></span> -m tcp -j DNAT --to-destination 10.244.0.11:80</code> </pre> <br><h2 id="testiruem-otkaz-odnogo-iz-podov">  Menguji kegagalan salah satu perapian </h2><br><p>  Aplikasi pengujian webapp saya dapat beralih ke mode "ruam kesalahan", untuk ini Anda perlu menarik URL "/ err". </p><br><p>  Hasil dari ab -c 50 -n 20.000 di tengah-tengah tes menarik "/ err" pada salah satu perapian: </p><br><pre> <code class="bash hljs">Complete requests: 20000 Failed requests: 3719</code> </pre> <br><p>  Intinya di sini bukanlah jumlah kesalahan spesifik (jumlah mereka akan bervariasi tergantung pada beban), tetapi itu adalah.  Secara umum, kami melemparkan "buruk" di bawah keseimbangan, tetapi pada saat beralih klien layanan menerima kesalahan.  Penyebab kesalahan cukup mudah untuk dijelaskan: tes kesiapan dilakukan kubelet sekali per detik + bahkan waktu yang singkat untuk menyebarkan informasi yang di bawah tidak menanggapi tes. </p><br><h2 id="pomozhet-li-ipvs-bekend-dlya-kube-proxy-experimental">  Akankah backend IPVS untuk proxy kubus (percobaan) membantu? </h2><br><p>  Tidak juga!  Ini memecahkan masalah optimasi proxy, menawarkan algoritma penyeimbang kustom, tetapi tidak memecahkan masalah pemrosesan kegagalan. </p><br><h2 id="kak-byt">  Bagaimana menjadi </h2><br><p>  Masalah ini hanya bisa diselesaikan oleh penyeimbang yang bisa mencoba lagi (coba lagi).  Dengan kata lain, untuk http kita membutuhkan penyeimbang L7.  Penyeimbang seperti itu untuk kubernet sudah digunakan penuh baik dalam bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masuknya</a> (tersirat sebagai titik dalam perpindahan ke cluster, tetapi pada umumnya ia melakukan persis apa yang dibutuhkannya), atau sebagai implementasi dari lapisan terpisah - sebuah service mesh, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">istio</a> . </p><br><p>  Dalam produksi kami, kami belum mulai menggunakan ingress atau service mesh karena kerumitan tambahan.  Abstraksi semacam itu, menurut pendapat saya, membantu dalam kasus di mana Anda perlu sering mengkonfigurasi sejumlah besar layanan.  Tetapi pada saat yang sama Anda "membayar" pengendalian dan infrastruktur sederhana.  Anda akan menghabiskan waktu ekstra untuk mencari tahu cara mengatur rertai dan waktu tunggu untuk layanan tertentu. </p><br><h2 id="kak-delaem-my">  Bagaimana kita </h2><br><p>  Kami menggunakan layanan k8 tanpa kepala.  Layanan tersebut tidak memiliki ip virtual dan, karenanya, proxy-kubus dan iptables tidak terlibat dalam pekerjaan mereka.  Untuk setiap layanan seperti itu, Anda bisa mendapatkan daftar perapian langsung baik melalui DNS atau melalui API. </p><br><p>  Untuk aplikasi yang berinteraksi dengan layanan lain, kami membuat wadah sespan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utusan</a> .  Evoy secara berkala menerima daftar pod terbaru untuk semua layanan yang diperlukan melalui DNS, dan yang paling penting, ia dapat melakukan upaya berulang-ulang untuk menanyakan pod lain jika terjadi kesalahan.  Anda bisa menjalankannya sebagai DaemonSet pada setiap node, tetapi kemudian jika instance ini gagal, semua aplikasi yang menggunakannya akan berhenti bekerja.  Karena konsumsi sumber daya oleh proksi ini cukup kecil, kami memutuskan untuk menggunakannya dalam varian wadah sespan. </p><br><p>  Ini pada dasarnya persis apa yang dilakukan istio, tetapi dalam kasus kami keseimbangan telah bergeser ke kesederhanaan (tidak perlu belajar istio, mengalami bug).  Mungkin keseimbangan ini akan berubah, dan kami akan mulai menggunakan sesuatu seperti istio. </p><br><p>  <em>Kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">okmeter.io</a> kubernetes jelas-jelas berakar, dan kami percaya pada distribusinya lebih lanjut.</em>  <em>Dukungan untuk memantau k8 di layanan kami sedang dalam perjalanan, tetap disini!</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424229/">https://habr.com/ru/post/id424229/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424211/index.html">Memahami Antarmuka Penyimpanan Kontainer (dalam Kubernetes dan lainnya)</a></li>
<li><a href="../id424215/index.html">Elm Nyaman dan canggung</a></li>
<li><a href="../id424217/index.html">Alasan untuk perang suci, serta permohonan perdamaian</a></li>
<li><a href="../id424223/index.html">Pelanggan sekali pakai. Segmentasi untuk pembelian berulang</a></li>
<li><a href="../id424227/index.html">Meratakan titik secara merata di seluruh bidang dalam pytorch dan tensorflow</a></li>
<li><a href="../id424231/index.html">Cara menghasilkan uang dari hosters</a></li>
<li><a href="../id424233/index.html">Komputer diajarkan untuk mendeteksi demensia dengan akurasi 93%</a></li>
<li><a href="../id424235/index.html">Cara menggunakan STATSPACK bukannya AWR di Oracle Standard Edition</a></li>
<li><a href="../id424237/index.html">Isi daya otak Anda secara langsung! Runtimes, kompiler dan kinerja di Joker 2018</a></li>
<li><a href="../id424239/index.html">Seminar Musim Gugur IBM - Kontainer, Visi Komputer, Transformasi Digital</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>