<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüî¨ üê≤ üë©üèº‚Äçüî¨ Representaci√≥n de fuentes con m√°scaras de cobertura, parte 1 ‚òïÔ∏è ü§∏üèæ üï∫üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cuando comenzamos a desarrollar nuestro perfilador de rendimiento , sab√≠amos que har√≠amos casi todo el procesamiento de la interfaz de usuario por nue...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Representaci√≥n de fuentes con m√°scaras de cobertura, parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433670/"><div style="text-align:center;"><img width="310" height="458" src="https://habrastorage.org/getpro/habr/post_images/a00/1c5/f74/a001c5f74ba839b1e77da01aadac6912.png" alt="imagen"></div><br>  Cuando comenzamos a desarrollar nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">perfilador de rendimiento</a> , sab√≠amos que har√≠amos casi todo el procesamiento de la interfaz de usuario por nuestra cuenta.  Pronto tuvimos que decidir qu√© enfoque elegir para renderizar fuentes.  Ten√≠amos los siguientes requisitos: <br><br><ol><li>  Debemos poder representar cualquier fuente de cualquier tama√±o en tiempo real para adaptarnos a las fuentes del sistema y los tama√±os elegidos por los usuarios de Windows. </li><li>  El renderizado de fuentes debe ser muy r√°pido, sin frenado cuando se permite renderizar fuentes. </li><li>  Nuestra interfaz de usuario tiene un mont√≥n de animaciones suaves, por lo que el texto debe poder moverse suavemente por la pantalla. </li><li>  Debe ser legible con tama√±os de fuente peque√±os. </li></ol><br>  Al no ser un gran especialista en ese momento, busqu√© informaci√≥n en Internet y encontr√© muchas t√©cnicas utilizadas para representar fuentes.  Tambi√©n habl√© con el director t√©cnico de Guerrilla Games, Michail van der Leu.  Esta compa√±√≠a experiment√≥ con muchas formas de renderizar fuentes, y su motor de renderizado fue uno de los mejores del mundo.  Mihil describi√≥ brevemente su idea para una nueva t√©cnica de representaci√≥n de fuentes.  Aunque ya hubi√©ramos tenido suficientes t√©cnicas disponibles, esta idea me intrig√≥ y comenc√© a implementarla, sin prestar atenci√≥n al maravilloso mundo de la representaci√≥n de fuentes que se me abri√≥. <br><a name="habracut"></a><br>  En esta serie de art√≠culos, describir√© en detalle la t√©cnica que usamos, dividiendo la descripci√≥n en tres partes: <br><br><ul><li>  En la <strong>primera parte,</strong> aprenderemos c√≥mo renderizar glifos en tiempo real usando 16xAA, muestreados desde una cuadr√≠cula uniforme. </li><li>  En la <strong>segunda parte,</strong> pasaremos a la cuadr√≠cula girada para realizar bellamente el suavizado de bordes horizontales y verticales.  Tambi√©n veremos c√≥mo el sombreador terminado se reduce casi por completo a una textura y una tabla de b√∫squeda. </li><li>  En la <strong>tercera parte,</strong> aprenderemos c√≥mo rasterizar glifos en tiempo real usando Compute y CPU. </li></ul><br>  Tambi√©n puede ver los resultados finales en el generador de perfiles, pero aqu√≠ hay un ejemplo de una pantalla con la fuente Segoe UI renderizada utilizando nuestro renderizador de fuentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/518/faf/57f/518faf57f2f977406e864ddbd939af6b.png"></div><br>  Aqu√≠ hay un aumento en la letra S, un tama√±o rasterizado de solo 6x9 texels.  Los datos vectoriales originales se representan como una ruta y el patr√≥n de muestra girado se representa a partir de rect√°ngulos verdes y rojos.  Dado que se procesa con una resoluci√≥n muy superior a 6 √ó 9, los tonos de gris no se representan en el tono final de p√≠xeles, muestra el tono del subp√≠xel.  Esta es una visualizaci√≥n de depuraci√≥n muy √∫til para asegurarse de que todos los c√°lculos en el nivel de subp√≠xeles funcionen correctamente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba1/aa9/5b3/ba1aa95b30f977d242d90994416b8ef8.png"></div><br><h1>  Idea: almacenar recubrimiento en lugar de sombra </h1><br>  El principal problema con el que deben lidiar los renderizadores de fuentes es mostrar datos de fuentes vectoriales escalables en una cuadr√≠cula de p√≠xeles fija.  El m√©todo de transici√≥n del espacio vectorial a p√≠xeles terminados en diferentes t√©cnicas es muy diferente.  En la mayor√≠a de estas t√©cnicas, los datos de la curva se rasterizan antes de procesarlos en un almacenamiento temporal (por ejemplo, una textura) para obtener un tama√±o espec√≠fico en p√≠xeles.  El almacenamiento temporal se utiliza como cach√© de glifos: cuando el mismo glifo se representa varias veces, los glifos se toman del cach√© y se reutilizan para evitar la rasterizaci√≥n. <br><br>  La diferencia en la t√©cnica es claramente visible en c√≥mo se almacenan los datos en un formato de datos intermedio.  Por ejemplo, el sistema de fuentes de Windows rasteriza los glifos a un tama√±o espec√≠fico en p√≠xeles.  Los datos se almacenan como un <strong>tono</strong> por p√≠xel.  La sombra describe la mejor aproximaci√≥n de la cobertura por el glifo de este p√≠xel.  Al renderizar, los p√≠xeles simplemente se copian de la cach√© de glifos a la cuadr√≠cula de p√≠xeles de destino.  Al convertir datos a un formato de p√≠xeles, no se escalan bien, por lo tanto, al alejar, aparecen glifos difusos, y al acercar, aparecen glifos en los que los bloques son claramente visibles.  Por lo tanto, para cada tama√±o final, los glifos se representan en el cach√© de glifos. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los campos distanciados firmados</a> utilizan un enfoque diferente.  En lugar de matiz para el p√≠xel, se mantiene la <strong>distancia</strong> al borde m√°s cercano del glifo.  La ventaja de este m√©todo es que para los bordes curvos, los datos se escalan mucho mejor que las sombras.  A medida que el glifo se acerca, las curvas permanecen suaves.  La desventaja de este enfoque es que los bordes rectos y afilados se suavizan.  Mucho mejor que SDF se logra con soluciones avanzadas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FreeType</a> , que almacenan datos de color. <br><br>  En los casos en que se retiene un tono para un p√≠xel, primero debe calcular su cobertura.  Por ejemplo, stb_truetype tiene buenos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplos</a> de c√≥mo puede calcular la cobertura y el tono.  Otra forma popular de aproximar la cobertura es muestrear el glifo a una frecuencia m√°s alta que la resoluci√≥n final.  Esto cuenta el n√∫mero de muestras que se ajustan al glifo en el √°rea de p√≠xeles objetivo.  El n√∫mero de visitas dividido por el n√∫mero m√°ximo de muestras posibles determina el tono.  Dado que la cobertura ya se ha convertido en un tono para una resoluci√≥n y <strong>alineaci√≥n de</strong> cuadr√≠cula de p√≠xeles espec√≠fica, es imposible colocar glifos entre los p√≠xeles de destino: el tono no puede reflejar correctamente la cobertura real con muestras de la ventana de p√≠xeles de destino.  Por esto, as√≠ como por algunas otras razones que consideraremos m√°s adelante, dichos sistemas no admiten el movimiento de subp√≠xeles. <br><br>  Pero, ¬øqu√© pasa si necesitamos mover libremente el glifo entre los p√≠xeles?  Si el tono se calcula por adelantado, no podemos averiguar cu√°l deber√≠a ser el tono cuando se mueve entre p√≠xeles en el √°rea de p√≠xeles objetivo.  Sin embargo, podemos retrasar la conversi√≥n de cobertura a matiz en el momento del renderizado.  Para hacer esto, no almacenaremos la sombra, sino el <strong>revestimiento</strong> .  Muestramos un glifo con una frecuencia de resoluci√≥n objetivo de 16, y para cada muestra guardamos un solo bit.  Al muestrear en una cuadr√≠cula de 4 √ó 4, es suficiente almacenar solo 16 bits por p√≠xel.  Esta ser√° nuestra <strong>m√°scara de tapa</strong> .  Durante el renderizado, necesitamos contar cu√°ntos bits entran en la ventana de p√≠xeles de destino, que tiene la misma resoluci√≥n que el repositorio de texel, pero no est√° f√≠sicamente adjunto.  La siguiente animaci√≥n muestra una parte del glifo (azul) rasterizado en cuatro texels.  Cada texel se divide en una cuadr√≠cula de 4 √ó 4 celdas.  Un rect√°ngulo gris indica una ventana de p√≠xeles que se mueve din√°micamente a trav√©s del glifo.  En tiempo de ejecuci√≥n, se cuenta el n√∫mero de muestras que caen en la ventana de p√≠xeles para determinar el tono. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/6d3/dca/f796d3dcaf7c4b1763ff8ee5621c09c9.gif"></div><br><h2>  Brevemente sobre las t√©cnicas b√°sicas de representaci√≥n de fuentes </h2><br>  Antes de pasar a discutir la implementaci√≥n de nuestro sistema de representaci√≥n de fuentes, quiero hablar brevemente sobre las principales t√©cnicas utilizadas en este proceso: sugerencia de fuentes y representaci√≥n de subp√≠xeles (esta t√©cnica se llama ClearType en Windows).  Puede omitir esta secci√≥n si solo est√° interesado en las t√©cnicas de suavizado. <br><br>  En el proceso de implementaci√≥n del renderizador, aprend√≠ cada vez m√°s sobre la larga historia del desarrollo del renderizado de fuentes.  La investigaci√≥n se centra por completo en el √∫nico aspecto de la representaci√≥n de fuentes: legibilidad en tama√±os peque√±os.  Crear un renderizador excelente para fuentes grandes es bastante simple, pero es incre√≠blemente dif√≠cil escribir un sistema que mantenga la legibilidad en tama√±os peque√±os.  El estudio del renderizado de fuentes tiene una larga historia, sorprendente en su profundidad.  Lea, por ejemplo, sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tragedia de</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trama</a> .  Es l√≥gico que este fuera el principal problema para los especialistas en computaci√≥n, porque en las primeras etapas de las computadoras, la resoluci√≥n de la pantalla era bastante baja.  Esta debe haber sido una de las primeras tareas que los desarrolladores de sistemas operativos tuvieron que hacer frente: ¬øc√≥mo hacer que el texto sea legible en dispositivos con baja resoluci√≥n de pantalla?  Para mi sorpresa, los sistemas de renderizado de fuentes de alta calidad est√°n muy orientados a p√≠xeles.  Por ejemplo, un glifo se construye de tal manera que comienza en el borde del p√≠xel, su ancho es un m√∫ltiplo del n√∫mero de p√≠xeles y el contenido se ajusta para adaptarse a los p√≠xeles.  Esta t√©cnica se llama mallado.  Estoy acostumbrado a trabajar con juegos de computadora y gr√°ficos en 3D, donde el mundo est√° construido a partir de unidades y se proyecta en p√≠xeles, as√≠ que me sorprendi√≥ un poco.  Descubr√≠ que en el campo del renderizado de fuentes es una elecci√≥n muy importante. <br><br>  Para mostrar la importancia de la malla, veamos un posible escenario para la rasterizaci√≥n de glifos.  Imagine que un glifo se rasteriza en una cuadr√≠cula de p√≠xeles, pero la forma del glifo no coincide perfectamente con la estructura de la cuadr√≠cula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c2/b4f/aa1/2c2b4faa132766685d630964d582d9dd.png"></div><br>  Antialiasing har√° que los p√≠xeles a la derecha e izquierda del glifo sean igualmente grises.  Si el glifo se desplaza ligeramente para que coincida mejor con los bordes de los p√≠xeles, solo se colorear√° un p√≠xel y se volver√° completamente negro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/c63/1b0/9b5c631b00fcdcfcd2a3a36f06ab9d2d.png"></div><br>  Ahora que el glifo coincide bien con los p√≠xeles, los colores se han vuelto menos borrosos.  La diferencia en nitidez es muy grande.  Las fuentes occidentales tienen muchos glifos con l√≠neas horizontales y verticales, y si no coinciden bien con la cuadr√≠cula de p√≠xeles, los tonos de gris hacen que la fuente sea borrosa.  Incluso la mejor t√©cnica anti-aliasing no puede hacer frente a este problema. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La sugerencia de fuentes</a> fue propuesta como una soluci√≥n.  Los autores de fuentes deben agregar informaci√≥n a sus fuentes sobre c√≥mo los glifos deben ajustarse a p√≠xeles si no se ajustan perfectamente.  El sistema de representaci√≥n de fuentes distorsiona estas curvas para ajustarlas a la cuadr√≠cula de p√≠xeles.  Esto aumenta enormemente la claridad de la fuente, pero tiene un precio: <br><br><ul><li>  Las fuentes se <em>distorsionan</em> ligeramente.  Las fuentes no se ven exactamente como se esperaba. </li><li>  Todos los glifos deben estar unidos a la cuadr√≠cula de p√≠xeles: el comienzo del glifo y el ancho del glifo.  Por lo tanto, es imposible animarlos entre p√≠xeles. </li></ul><br>  Curiosamente, al resolver este problema, Apple y Microsoft fueron de diferentes maneras.  Microsoft se adhiere a la claridad absoluta, y Apple busca mostrar las fuentes con mayor precisi√≥n.  En Internet puede encontrar personas quej√°ndose de las fuentes borrosas en las m√°quinas Apple, pero a muchas personas les gusta lo que ven en Apple.  Eso es en parte una cuesti√≥n de gustos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠ est√° la</a> publicaci√≥n de Joel sobre software, y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠ est√° la</a> publicaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Peter Bilak</a> sobre este tema, pero si busca en Internet, puede encontrar mucha m√°s informaci√≥n. <br><br>  Dado que la resoluci√≥n DPI en pantallas modernas est√° aumentando r√°pidamente, surge la pregunta de si se necesitar√°n sugerencias de fuentes en el futuro, como lo es hoy.  En mi estado actual, encuentro que la fuente insin√∫a una t√©cnica muy valiosa para representar fuentes con claridad.  Sin embargo, la t√©cnica descrita en mi art√≠culo puede convertirse en una alternativa interesante en el futuro, porque los glifos se pueden colocar libremente en el lienzo sin distorsi√≥n.  Y dado que esta es esencialmente una t√©cnica anti-aliasing, se puede usar para cualquier prop√≥sito, y no solo para renderizar fuentes. <br><br>  Finalmente, hablar√© brevemente sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">representaci√≥n de subp√≠xeles</a> .  En el pasado, la gente se dio cuenta de que puede triplicar la resoluci√≥n horizontal de la pantalla utilizando los rayos individuales rojo, verde y azul de un monitor de computadora.  Cada p√≠xel se construye a partir de estos rayos, que est√°n f√≠sicamente separados.  Nuestro ojo mezcla sus valores, creando un solo color de p√≠xel.  Cuando el glifo cubre solo una parte del p√≠xel, entonces solo se activa el haz que se superpone al glifo, lo que triplica la resoluci√≥n horizontal.  Si ampl√≠a la imagen de la pantalla utilizando una t√©cnica como ClearType, puede ver los colores alrededor de los bordes del glifo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fff/998/d3e/fff998d3e0cc29ff6abe7b18a0725e61.png"></div><br>  Curiosamente, el enfoque que analizar√© en el art√≠culo se puede extender a la representaci√≥n de subp√≠xeles.  Ya he implementado su prototipo.  Su √∫nico inconveniente es que, debido a la adici√≥n de filtros en t√©cnicas como ClearType, necesitamos tomar m√°s muestras de textura.  Quiz√°s lo considerar√© en el futuro. <br><br><h1>  Representaci√≥n de glifos utilizando una cuadr√≠cula uniforme </h1><br>  Supongamos que muestreamos un glifo con una resoluci√≥n 16 veces el objetivo y lo guardamos en una textura.  Describir√© c√≥mo se hace esto en la tercera parte del art√≠culo.  Un patr√≥n de muestreo es una cuadr√≠cula uniforme, es decir, 16 puntos de muestreo est√°n distribuidos uniformemente sobre el texel.  Cada glifo se procesa con la misma resoluci√≥n que la resoluci√≥n de destino, almacenamos 16 bits por texel y cada bit corresponde a una muestra.  Como veremos en el proceso de c√°lculo de la m√°scara de cobertura, el orden de almacenamiento de las muestras es importante.  En general, los puntos de muestreo y sus posiciones para un texel se ven as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7b/b2c/7f4/a7bb2c7f477e44883b531d2bae004058.png"></div><br><h2>  Obteniendo texels </h2><br>  Cambiaremos la ventana de p√≠xeles por los bits de cobertura almacenados en los texels.  Necesitamos responder a la siguiente pregunta: ¬øcu√°ntas muestras entrar√°n en nuestra ventana de p√≠xeles?  Est√° ilustrado por la siguiente imagen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/027/d8f/bf0/027d8fbf08ed742fa9d5c529778f91a3.png"></div><br>  Aqu√≠ vemos cuatro texels, en los que un glifo se superpone parcialmente.  Un p√≠xel (indicado en azul) cubre parte de los texels.  Necesitamos determinar cu√°ntas muestras cruza nuestra ventana de p√≠xeles.  Primero necesitamos lo siguiente: <br><br><ul><li>  Calcule la posici√≥n relativa de la ventana de p√≠xeles en comparaci√≥n con 4 texels. </li><li>  Obtenga los texels con los que se cruza nuestra ventana de p√≠xeles. </li></ul><br>  Nuestra implementaci√≥n se basa en OpenGL, por lo que el origen del espacio de textura comienza en la parte inferior izquierda.  Comencemos calculando la posici√≥n relativa de la ventana de p√≠xeles.  La coordenada UV pasada al sombreador de p√≠xeles es la coordenada UV del centro del p√≠xel.  Suponiendo que los rayos UV est√°n normalizados, primero podemos convertir los rayos UV en espacio de texel multiplic√°ndolo por el tama√±o de la textura.  Restando 0.5 del centro del p√≠xel, obtenemos la esquina inferior izquierda de la ventana de p√≠xeles.  Al redondear este valor hacia abajo, calculamos la posici√≥n inferior izquierda del texel inferior izquierdo.  La imagen muestra un ejemplo de estos tres puntos en el espacio texel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82b/437/a14/82b437a149bdf438c840e6d7a61695ba.png"></div><br>  La diferencia entre la esquina inferior izquierda del p√≠xel y la esquina inferior izquierda de la cuadr√≠cula de texel es la posici√≥n relativa de la ventana de p√≠xeles en coordenadas normalizadas.  En esta imagen, la posici√≥n de la ventana de p√≠xeles ser√° [0.69, 0.37].  En c√≥digo: <br><br> <code>vec2 bottomLeftPixelPos = uv * size -0.5; <br> vec2 bottomLeftTexelPos = floor(bottomLeftPixelPos); <br> vec2 weigth = bottomLeftPixelPos - bottomLeftTexelPos;</code> <br> <br>  Usando la instrucci√≥n textureGather, podemos obtener cuatro texels a la vez.  Est√° disponible solo en OpenGL 4.0 y superior, por lo que puede ejecutar cuatro texelFetch en su lugar.  Si solo pasamos las coordenadas UV de textureGather, entonces, con la combinaci√≥n perfecta de la ventana de p√≠xeles con el texel, surgir√° un problema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d19/f39/8ab/d19f398abc0e3f871f186fec042975cf.png"></div><br>  Aqu√≠ vemos tres texel horizontales con una ventana de p√≠xeles (que se muestra en azul) que coincide exactamente con el texel central.  El peso calculado es cercano a 1.0, pero textureGather eligi√≥ los texels centrales y derechos.  La raz√≥n es que los c√°lculos realizados por textureGather pueden diferir ligeramente del c√°lculo del peso en coma flotante.  La diferencia en el redondeo de los c√°lculos de GPU y los c√°lculos de peso de coma flotante produce fallas en los centros de los p√≠xeles. <br><br>  Para resolver este problema, debe asegurarse de que los c√°lculos de peso coincidan con el muestreo de TextureGather.  Para hacer esto, nunca tomaremos muestras de centros de p√≠xeles, y en su lugar, siempre tomaremos muestras en el centro de la cuadr√≠cula de texel 2 √ó 2.  Desde la posici√≥n inferior de texel calculada y ya redondeada hacia abajo, agregamos texel completo para llegar al centro de la cuadr√≠cula de texel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4a/34c/730/f4a34c7308653a6b1f19d429adb11bf4.png"></div><br>  Esta imagen muestra que usando el centro de la cuadr√≠cula de texel, los cuatro puntos de muestreo tomados por textureGather siempre estar√°n en el centro de los texel.  En c√≥digo: <br><br> <code>vec2 centerTexelPos = (bottomLeftTexelPos + vec2(1.0, 1.0)) / size; <br> uvec4 result = textureGather(fontSampler, centerTexelPos, 0);</code> <br> <br><h2>  M√°scara horizontal de ventana de p√≠xeles </h2><br>  Tenemos cuatro texels y juntos forman una cuadr√≠cula de 8 √ó 8 bits de cobertura.  Para contar los bits en una ventana de p√≠xeles, primero debemos restablecer los bits fuera de la ventana de p√≠xeles.  Para hacer esto, crearemos una m√°scara de ventana de p√≠xeles y realizaremos Y bit a bit entre la m√°scara de p√≠xeles y las m√°scaras de cobertura de texel.  El enmascaramiento horizontal y vertical se realiza por separado. <br><br>  La m√°scara de p√≠xeles horizontal debe moverse junto con el peso horizontal, como se muestra en esta animaci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/6e0/195/c086e01955d3c85a93bd655bddff089d.gif"></div><br>  La imagen muestra una m√°scara de 8 bits con el valor 0x0F0 desplaz√°ndose hacia la derecha (los ceros se insertan a la izquierda).  En la animaci√≥n, una m√°scara se anima linealmente con peso, pero en realidad, un cambio de bit es una operaci√≥n paso a paso.  La m√°scara cambia de valor cuando la ventana de p√≠xeles cruza el borde de la muestra.  En la siguiente animaci√≥n, esto se muestra en columnas rojas y verdes, animadas paso a paso.  El valor cambia solo cuando los centros de las muestras se cruzan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a10/cfe/946/a10cfe946385aec1041c87eef64d707f.gif"></div><br>  Para que la m√°scara se mueva solo en el centro de la celda, pero no en sus bordes, un simple redondeo es suficiente: <br><br> <code>unsigned int pixelMask = 0x0F0 &gt;&gt; int(round(weight.x * 4.0));</code> <br> <br>  Ahora tenemos una m√°scara de p√≠xeles de una cadena completa de 8 bits que abarca dos texels.  Si elegimos el tipo correcto de almacenamiento en nuestra m√°scara de cobertura de 16 bits, entonces hay formas de combinar el texel izquierdo y derecho y realizar el enmascaramiento horizontal de p√≠xeles para una l√≠nea completa de 8 bits a la vez.  Sin embargo, esto se vuelve problem√°tico con el enmascaramiento vertical cuando pasamos a las cuadr√≠culas rotadas.  Por lo tanto, en cambio, combinamos entre s√≠ dos texels izquierdos y por separado dos texels derechos para crear dos m√°scaras de cobertura de 32 bits.  Enmascaramos los resultados izquierdo y derecho por separado. <br><br>  Las m√°scaras para los texels izquierdos usan los 4 bits superiores de la m√°scara de p√≠xeles, y las m√°scaras para los texels derechos usan los 4 bits inferiores.  En una cuadr√≠cula uniforme, cada fila tiene la misma m√°scara horizontal, por lo que podemos copiar la m√°scara para cada fila, despu√©s de lo cual la m√°scara horizontal estar√° lista: <br><br> <code>unsigned int leftRowMask = pixelMask &gt;&gt; 4; <br> unsigned int rightRowMask = pixelMask &amp; 0xF; <br> unsigned int leftMask = (leftRowMask &lt;&lt; 12) | (leftRowMask &lt;&lt; 8) | (leftRowMask &lt;&lt; 4) | leftRowMask; <br> unsigned int rightMask = (rightRowMask &lt;&lt; 12) | (rightRowMask &lt;&lt; 8) | (rightRowMask &lt;&lt; 4) | rightRowMask;</code> <br> <br>  Para enmascarar, combinamos dos texels izquierdos y dos texels derechos, y luego enmascaramos las l√≠neas horizontales: <br><br> <code>unsigned int left = ((topLeft &amp; leftMask) &lt;&lt; 16) | (bottomLeft &amp; leftMask); <br> unsigned int right = ((topRight &amp; rightMask) &lt;&lt; 16) | (bottomRight &amp; rightMask);</code> <br> <br>  Ahora el resultado puede verse as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a4/c67/0a8/2a4c670a8c523334f9b01dddd790d11e.png"></div><br>  Ya podemos contar los bits de este resultado utilizando la instrucci√≥n bitCount.  Deber√≠amos dividir no entre 16, sino entre 32, porque despu√©s del enmascaramiento vertical todav√≠a podemos tener 32 bits potenciales, y no 16. Aqu√≠ est√° la representaci√≥n completa del glifo en esta etapa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/334/c6f/ae9334c6fdaedfcd4c17b75c26e4836b.png"></div><br>  Aqu√≠ vemos una letra S ampliada representada en base a los datos del vector original (contorno blanco) y la visualizaci√≥n de los puntos de muestreo.  Si el punto es verde, entonces est√° dentro del glifo, si es rojo, entonces no.  La escala de grises muestra los tonos calculados en esta etapa.  En el proceso de renderizaci√≥n de fuentes, existen muchas posibilidades de errores, que van desde la rasterizaci√≥n, la forma en que los datos se almacenan en un atlas de texturas y el c√°lculo del tono final.  Tales visualizaciones son incre√≠blemente √∫tiles para validar c√°lculos.  Son especialmente importantes para depurar artefactos a nivel de subp√≠xel. <br><br><h2>  Enmascaramiento vertical </h2><br>  Ahora estamos listos para enmascarar los bits verticales.  Para enmascarar verticalmente, utilizamos un m√©todo ligeramente diferente.  Para lidiar con el desplazamiento vertical, es importante recordar c√≥mo guardamos los bits: en orden de filas.  La l√≠nea inferior son los cuatro bits menos significativos, y la l√≠nea superior son los cuatro bits m√°s significativos.  Simplemente podemos limpiar uno por uno, desplaz√°ndolos seg√∫n la posici√≥n vertical de la ventana de p√≠xeles. <br><br>  Crearemos una √∫nica m√°scara que cubra la altura completa de dos texels.  Como resultado, queremos guardar cuatro l√≠neas <strong>completas</strong> de texels y enmascarar todo lo dem√°s, es decir, la m√°scara ser√° de 4 √ó 4 bits, que es igual a 0xFFFF.  Seg√∫n la posici√≥n de la ventana de p√≠xeles, cambiamos las l√≠neas inferiores y borramos las l√≠neas superiores. <br><br> <code>int shiftDown = int(round(weightY * 4.0)) * 4; <br> left = (left &gt;&gt; shiftDown) &amp; 0xFFFF; <br> right = (right &gt;&gt; shiftDown) &amp; 0xFFFF;</code> <br> <br>  Como resultado, tambi√©n enmascaramos los bits verticales fuera de la ventana de p√≠xeles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9e/007/90d/d9e00790d66da0f0caac1226937136dc.png"></div><br>  Ahora es suficiente para nosotros contar los bits que quedan en los texels, lo que se puede hacer con la operaci√≥n bitCount, luego dividir el resultado entre 16 y obtener el tono deseado. <br><br> <code>float shade = (bitCount(left) + bitCount(right)) / 16.0;</code> <br> <br>  Ahora el renderizado completo de la carta se ve as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a00/1c5/f74/a001c5f74ba839b1e77da01aadac6912.png"></div><br><h1>  Continuar√° ... </h1><br>  En la segunda parte, daremos el siguiente paso y veremos c√≥mo puede aplicar esta t√©cnica a las cuadr√≠culas giradas.  Calcularemos este esquema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/f7a/c09/ee0f7ac0925a10db70b9b7330a879961.png"></div><br>  Y veremos que casi todo esto se puede reducir a varias tablas. <br><br>  Gracias a Sebastian Aaltonen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">@SebAaltonen</a> ) por su ayuda para resolver el problema de textureGather y, por supuesto, a Michael van der Leu ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">@MvdleeuwGG</a> ) por sus ideas y conversaciones interesantes por las noches. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433670/">https://habr.com/ru/post/es433670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433652/index.html">5G a trav√©s de los ojos de los usuarios. Expectativas y preocupaciones</a></li>
<li><a href="../es433658/index.html">TI en Alemania: c√≥mo buscar trabajo en las grandes ciudades de Alemania</a></li>
<li><a href="../es433660/index.html">C√≥mo habl√© en DefCamp por quinta vez</a></li>
<li><a href="../es433664/index.html">SATA SSD Enterprise en Infortrend 2-Storage Storage - Medici√≥n del rendimiento</a></li>
<li><a href="../es433666/index.html">Diccionario Funcorp</a></li>
<li><a href="../es433672/index.html">Chicos, ¬øRuby est√° muerto o no?</a></li>
<li><a href="../es433674/index.html">El t√∫nel de prueba de la empresa aburrida se abre en California esta noche</a></li>
<li><a href="../es433676/index.html">¬øQui√©n gana m√°s dinero en TI: empleados de oficina o remotos?</a></li>
<li><a href="../es433678/index.html">Crypto-hacking: un nuevo tipo de ataque al centro de datos</a></li>
<li><a href="../es433680/index.html">Eventos de invierno para la industria del juego en HSE y simulador gamedev de escritorio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>