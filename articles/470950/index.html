<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë® üë©‚Äçüíª üåõ bear_hug: juegos en arte ASCII en Python3.6 + üÉè ü§µüèø üö¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para mis juegos en el arte ASCII, escrib√≠ la biblioteca bear_hug con una cola de eventos, una colecci√≥n de widgets, soporte ECS y otras peque√±as cosas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>bear_hug: juegos en arte ASCII en Python3.6 +</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470950/"><img src="https://habrastorage.org/webt/b0/zu/vj/b0zuvjk4xdzcznbys9oslxl_veo.png"><br><br>  Para mis juegos en el arte ASCII, escrib√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la biblioteca bear_hug</a> con una cola de eventos, una colecci√≥n de widgets, soporte ECS y otras peque√±as cosas √∫tiles.  En este art√≠culo veremos c√≥mo usarlo para hacer un juego de trabajo m√≠nimo. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Renuncias</b> <div class="spoiler_text"><ul><li>  Soy el √∫nico desarrollador de la biblioteca, por lo que puedo ser parcial. </li><li>  bear_hug es esencialmente una envoltura alrededor de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bearlibterminal</a> , por lo que no habr√° operaciones de nivel relativamente bajo con glifos. </li><li>  Hay una funcionalidad similar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clubsandwich</a> , pero no la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">us√©</a> y no puedo compararla. </li></ul></div></div><br>  Bajo el cap√≥ de bear_hug est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bearlibterminal</a> , una biblioteca SDL para crear una ventana de pseudo-consola.  Es decir, en TTY puro, como algunos ncurses, no funcionar√°.  Pero la imagen es la misma en Linux, en Windows, y no depende de la configuraci√≥n del terminal de usuario.  Esto es importante, especialmente para los juegos, porque cuando cambias la fuente ASCII-art, Dios puede convertirse en lo que: <br><br><img src="https://habrastorage.org/webt/ys/rh/6f/ysrh6fhay5u9slnpwvqn53is1ek.png"><br>  <i>El mismo dibujo en su forma original y despu√©s de copiar y pegar en diferentes programas.</i> <br><br>  Por supuesto, la biblioteca fue escrita para proyectos relativamente a gran escala.  Pero para no distraerse con el dise√±o y la arquitectura del juego, en este art√≠culo crearemos algo simple.  Un proyecto de una noche, en el que hay algo para mostrar las funciones b√°sicas de la biblioteca.  A saber: un clon simplificado de esos mismos tanques con Dandy (tambi√©n son Battle City).  Habr√° un tanque de jugador, tanques enemigos, muros destruibles, sonido y puntuaci√≥n.  Pero el men√∫ principal, los niveles y las bonificaciones seleccionadas no lo ser√°n.  No porque sea imposible agregarlos, sino porque este proyecto no es m√°s que un Halloworld. <br><br><img src="https://habrastorage.org/webt/8k/e7/my/8ke7mymnrejpei7isjbxtbwvyjs.png"><br>  <i>Habr√° un gameover, pero no habr√° victoria.</i>  <i>Porque la vida es dolor.</i> <br><br>  Todo el material utilizado en el art√≠culo est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el github</a> ;  la biblioteca en s√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tambi√©n</a> est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en PyPI</a> (bajo la licencia MIT). <br><br>  En primer lugar, necesitamos activos.  Para dibujar arte ASCII, utilizo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">REXpaint</a> de Josh Ge (tambi√©n conocido como Kyzrati), el desarrollador del bagel de ciencia ficci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cogmind</a> .  El editor es gratuito, aunque no de c√≥digo abierto;  La versi√≥n oficial es solo para Windows, pero todo funciona bien con Wine.  La interfaz es bastante clara y conveniente: <br><br><img src="https://habrastorage.org/webt/jf/x-/bi/jfx-bigu3sedblmkuspxh_pd4d4.png"><br><br>  Guardamos en el formato binario local .xp y copiamos desde <code>/path/to/rexpaint/images</code> a la carpeta con el juego futuro.  En principio, tambi√©n se admite cargar im√°genes desde archivos .txt, pero obviamente es imposible guardar los colores de los caracteres individuales en un archivo de texto.  S√≠, y editar el arte ASCII en un cuaderno no es conveniente para m√≠ personalmente.  Para no codificar las coordenadas y el tama√±o de cada elemento, estos datos se almacenan en un archivo JSON separado: <br><br><div class="spoiler">  <b class="spoiler_title">battlecity.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"player_r"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"xsize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ysize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"player_l"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-attr"><span class="hljs-attr">"xsize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ysize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, ... ]</code> </pre> <br></div></div><br>  Sonidos bajo licencias gratuitas de descarga de Internet.  Hasta ahora, solo se admite .wav.  Eso es todo con activos, puede comenzar a codificar.  En primer lugar, debe inicializar el terminal y la cola de eventos. <br><br><div class="spoiler">  <b class="spoiler_title">game.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  terminal = BearTerminal(font_path='cp437_12x12.png', size='91x60', title='AsciiCity', filter=['keyboard', 'mouse']) #   dispatcher = BearEventDispatcher() # ,         loop = BearLoop(terminal, dispatcher)</span></span></code> </pre> <br></div></div><br>  El terminal es la ventana real del juego.  Puede colocar widgets en √©l, y arroja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eventos de entrada</a> seg√∫n sea necesario.  Como teclas al crear un terminal, puede usar todas las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">opciones</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">terminal bearlibterminal</a> ;  en este caso, establecemos la fuente, el tama√±o de la ventana (en caracteres), el t√≠tulo de la ventana y los m√©todos de entrada que nos interesan. <br><br>  En cuanto a la cola de eventos, tiene una interfaz muy simple: dispatcher.add_event (event) agrega el evento a la cola, y dispatcher.register_listener (listener, event_types) le permite suscribirse.  Un firmante (por ejemplo, un widget o componente) debe tener una devoluci√≥n de llamada on_event, que toma un evento como un argumento √∫nico y no devuelve nada o devuelve otro evento o conjunto de eventos.  El evento en s√≠ consiste en tipo y valor;  el tipo aqu√≠ no es en el sentido de str o int, sino en el sentido de "variedad", por ejemplo, 'key_down' o 'tick'.  La cola solo acepta eventos de tipos conocidos (integrados o creados por el usuario) y los env√≠a a on_event a todos aquellos que se suscriban a este tipo.  No verifica los valores de ninguna manera, pero existen convenciones dentro de la biblioteca sobre qu√© es un valor v√°lido para cada tipo de evento. <br><br>  Primero, ponemos en cola a un par de oyentes.  Esta es la clase base para objetos que pueden suscribirse a eventos, pero no son widgets o componentes.  En principio, no es necesario usarlo, siempre que el firmante tenga el m√©todo on_event. <br><br><div class="spoiler">  <b class="spoiler_title">Oyentes</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       dispatcher.register_listener(ClosingListener(), ['misc_input', 'tick']) #       dispatcher.register_listener(EntityTracker(), ['ecs_create', 'ecs_destroy']) #   jukebox = SoundListener({'shot': 'shot.wav', 'explosion': 'explosion.wav'}) # https://freesound.org/people/EMSIarma/sounds/108852/ # https://freesound.org/people/FlashTrauma/sounds/398283/ dispatcher.register_listener(jukebox, 'play_sound')</span></span></code> </pre> <br></div></div><br>  Una lista completa de los tipos de eventos integrados se encuentra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la documentaci√≥n</a> .  Es f√°cil ver que hay eventos para la creaci√≥n y destrucci√≥n de entidades, pero no para da√±os.  Dado que tendremos objetos que no se separan de un solo disparo (las paredes y el tanque del jugador), lo crearemos: <br><br><div class="spoiler">  <b class="spoiler_title">Registro de tipo de evento</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,    #   dispatcher.register_event_type('ac_damage') #       logger = LoggingListener(sys.stderr) dispatcher.register_listener(logger, ['ac_damage', 'play_sound'])</span></span></code> </pre> <br></div></div><br>  Aceptamos que, como valor, este evento tendr√° una tupla de la identificaci√≥n de la entidad que sufri√≥ el da√±o y el valor del da√±o.  LoggingListener es solo una herramienta de depuraci√≥n que imprime todos los eventos recibidos donde sea que digan, en este caso en stderr.  En este caso, quer√≠a asegurarme de que el da√±o pasara correctamente y que el sonido se solicita siempre cuando deber√≠a. <br><br>  Con Listeners por ahora, puede agregar el primer widget.  Tenemos este campo de juego de clase ECSLayout.  Este es un dise√±o de este tipo, que puede colocar widgets en entidades y moverlos en respuesta a eventos ecs_move, y al mismo tiempo considera colisiones.  Como la mayor√≠a de los widgets, tiene dos argumentos obligatorios: una lista anidada de caracteres (posiblemente vac√≠a, un espacio o Ninguno) y una lista anidada de colores para cada car√°cter.  Los colores con nombre se aceptan como colores, RGB en el formato `0xAARRGGBB` (o` 0xARGB`, `0xRGB`,` 0xRRGGBB`) y en el formato '#fff'.  Los tama√±os de ambas listas deben coincidir;  de lo contrario, se lanza una excepci√≥n. <br><br><div class="spoiler">  <b class="spoiler_title">Primer widget</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   .  8460,   9160. # 7         chars = [[' ' for x in range(84)] for y in range(60)] colors = copy_shape(chars, 'gray') layout = ECSLayout(chars, colors) # 'all' -  ,      dispatcher.register_listener(layout, 'all')</span></span></code> </pre> <br></div></div><br>  Como ahora tenemos en qu√© colocar los objetos del juego, podemos comenzar a crear entidades.  Todo el c√≥digo de entidades y componentes se mueve a un archivo separado.  El m√°s simple de ellos es un muro de ladrillo destructible.  Ella sabe c√≥mo estar en un lugar determinado, mostrar su widget, servir como objeto de colisi√≥n y recibir da√±os.  Despu√©s de un da√±o suficiente, la pared desaparece. <br><br><div class="spoiler">  <b class="spoiler_title">entidades.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_wall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dispatcher, atlas, entity_id, x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   wall = Entity(entity_id) #  wall.add_component(PositionComponent(dispatcher, x, y)) wall.add_component(CollisionComponent(dispatcher)) wall.add_component(PassingComponent(dispatcher)) wall.add_component(DestructorComponent(dispatcher)) #     ,      #    -  /   images_dict = {'wall_3': atlas.get_element('wall_3'), 'wall_2': atlas.get_element('wall_2'), 'wall_1': atlas.get_element('wall_1')} wall.add_component(SwitchWidgetComponent(dispatcher, SwitchingWidget(images_dict=images_dict, initial_image='wall_3'))) wall.add_component(VisualDamageHealthComponent(dispatcher, hitpoints=3, widgets_dict={3: 'wall_3', 2: 'wall_2', 1: 'wall_1'})) #     dispatcher.add_event(BearEvent('ecs_create', wall)) dispatcher.add_event(BearEvent('ecs_add', (wall.id, wall.position.x, wall.position.y)))</span></span></code> </pre> <br></div></div><br>  En primer lugar, se crea el objeto de entidad en s√≠.  Contiene solo un nombre (que debe ser √∫nico) y un conjunto de componentes.  Se pueden transferir de una vez al momento de la creaci√≥n o, como aqu√≠, agregarse uno a la vez.  Luego se crean todos los componentes necesarios.  Como widget, se usa SwitchWidget, que contiene varios dibujos del mismo tama√±o y puede cambiarlos por comando.  Por cierto, los dibujos se cargan desde el atlas al crear un widget.  Y, finalmente, el anuncio de la creaci√≥n de la entidad y el orden de dibujarlo en las coordenadas necesarias entran en la cola. <br><br>  De los componentes no integrados, solo hay salud.  Cre√© el componente base "Componente de salud" y hered√© de √©l el "widget de cambio del componente de salud" (para mostrar el muro intacto y en varias etapas de destrucci√≥n). <br><br><div class="spoiler">  <b class="spoiler_title">clase HealthComponent</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HealthComponent</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Component)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, hitpoints=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, name=<span class="hljs-string"><span class="hljs-string">'health'</span></span>, **kwargs) self.dispatcher.register_listener(self, <span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span>) self._hitpoints = hitpoints <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, event)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.event_type == <span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> event.event_value[<span class="hljs-number"><span class="hljs-number">0</span></span>] == self.owner.id: self.hitpoints -= event.event_value[<span class="hljs-number"><span class="hljs-number">1</span></span>] @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hitpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._hitpoints @hitpoints.setter <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hitpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> isinstance(value, int): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> BearECSException( <span class="hljs-string"><span class="hljs-string">f'Attempting to set hitpoints of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{self.owner.id}</span></span></span><span class="hljs-string"> to non-integer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{value}</span></span></span><span class="hljs-string">'</span></span>) self._hitpoints = value <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._hitpoints &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: self._hitpoints = <span class="hljs-number"><span class="hljs-number">0</span></span> self.process_hitpoint_update() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_hitpoint_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Should be overridden by child classes. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotImplementedError(<span class="hljs-string"><span class="hljs-string">'HP update processing should be overridden'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#           return dumps({'class': self.__class__.__name__, 'hitpoints': self.hitpoints})</span></span></code> </pre> <br></div></div><br>  Al crear un componente, la clave 'nombre' se pasa a super () .__ init__.  Cuando se agrega un componente a una entidad, bajo el nombre de esta clave se agregar√° al __dict__ de la entidad y se puede acceder a trav√©s de entity_object.health.  Adem√°s de la conveniencia de la interfaz, este enfoque es bueno porque proh√≠be la emisi√≥n de entidades de varios componentes homog√©neos.  Y el hecho de que est√© codificado dentro del componente no le permite insertar por error, por ejemplo, el WidgetComponent en la ranura del componente de mantenimiento.  Inmediatamente despu√©s de la creaci√≥n, el componente se suscribe a las clases de eventos que le interesan, en este caso ac_damage.  Despu√©s de recibir dicho evento, el m√©todo on_event verificar√° si se trata de su propietario durante una hora.  Si es as√≠, restar√° el valor deseado de los puntos de golpe y extraer√° la devoluci√≥n de llamada para cambiar la salud, la clase base es abstracta.  Tambi√©n existe el m√©todo __repr__, que se utiliza para la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">serializaci√≥n en JSON</a> (por ejemplo, para guardar).  No es necesario agregarlo, pero todos los componentes integrados y la mayor√≠a de los widgets incorporados lo tienen. <br><br>  La herencia del componente de salud subyacente de VisualDamageHealthComponent anula la devoluci√≥n de llamada en el cambio de salud: <br><br><div class="spoiler">  <b class="spoiler_title">clase VisualDamageHealthComponent</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VisualDamageHealthComponent</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(HealthComponent)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""       .    HP=0 """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, widgets_dict={}, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self.widgets_dict = OrderedDict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(widgets_dict.keys()): self.widgets_dict[int(x)] = widgets_dict[x] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_hitpoint_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.hitpoints == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hasattr(self.owner, <span class="hljs-string"><span class="hljs-string">'destructor'</span></span>): self.owner.destructor.destroy() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.widgets_dict: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.hitpoints &gt;= x: self.owner.widget.switch_to_image(self.widgets_dict[x])</code> </pre> <br></div></div><br>  Mientras la salud est√° por encima de 0, le pide al componente responsable del widget que dibuje el muro en el estado deseado.  Aqu√≠, la llamada descrita anteriormente se usa a trav√©s del atributo del objeto de entidad.  Una vez que los puntos de vida hayan terminado, el componente responsable de la destrucci√≥n correcta de la entidad y todos los componentes se llamar√°n de la misma manera. <br><br>  Para otras entidades, todo es similar, solo el conjunto de componentes es diferente.  Los tanques se agregan con controladores (entrada para el jugador, IA para oponentes) y widgets giratorios, para proyectiles, un componente de colisi√≥n que causa da√±o a los que golpean.  No analizar√© cada uno de ellos, porque es voluminoso y bastante trivial;  mira solo el colisionador de proyectiles.  Tiene un m√©todo collided_into, llamado cuando la entidad anfitriona se estrell√≥ contra algo: <br><br><div class="spoiler">  <b class="spoiler_title">colisionador de componentes de bala</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collided_into</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, entity)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> entity: self.owner.destructor.destroy() <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> hasattr(EntityTracker().entities[entity], <span class="hljs-string"><span class="hljs-string">'collision'</span></span>): self.dispatcher.add_event(BearEvent(event_type=<span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span>, event_value=( entity, self.damage))) self.owner.destructor.destroy()</code> </pre> <br></div></div><br>  Para asegurarse de que es realmente posible obtener una v√≠ctima (que puede ser incorrecta para, por ejemplo, elementos de fondo), el proyectil usa EntityTracker ().  Este es un singleton que rastrea todas las entidades creadas y destruidas;  a trav√©s de √©l, puede obtener un objeto de entidad por nombre y hacer algo con sus componentes.  En este caso, se verifica que entity.collision (el controlador de colisi√≥n de la v√≠ctima) existe en absoluto. <br><br>  Ahora en el archivo principal del juego, simplemente llamamos a todas las funciones necesarias para crear entidades: <br><br><div class="spoiler">  <b class="spoiler_title">Volver a game.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  , -     atlas = Atlas(XpLoader('battlecity.xp'), 'battlecity.json') #   create_player_tank(dispatcher, atlas, 30, 50) #    wall_array = [[0 for _ in range(14)], [0 for _ in range(14)], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0], [0 for _ in range(14)], [0 for _ in range(14)], [0 for _ in range(14)] ] for y in range(10): for x in range(14): if wall_array[y][x] == 1: create_wall(dispatcher, atlas, f'wall{x}{y}', x*6, y*6) #   -  .     . create_spawner_house(dispatcher, atlas, 35, 0)</span></span></code> </pre> <br></div></div><br>  Los contadores de puntos y puntos de golpe no son entidades y no est√°n en el campo de batalla.  Por lo tanto, no se agregan a ECSLayout, sino directamente a la terminal a la derecha del mapa.  Los widgets relevantes heredan de Label (widget de salida de texto) y tienen un m√©todo on_event para descubrir qu√© les interesa.  A diferencia de Layout, el terminal no actualiza autom√°ticamente los widgets en cada tic, as√≠ que despu√©s de cambiar el texto, los widgets le dicen que haga esto: <br><br><div class="spoiler">  <b class="spoiler_title">oyentes.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScoreLabel</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Label)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""   """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(text=<span class="hljs-string"><span class="hljs-string">'Score:\n0'</span></span>) self.score = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, event)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.event_type == <span class="hljs-string"><span class="hljs-string">'ecs_destroy'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'enemy'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> event.event_value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'bullet'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> event.event_value: <span class="hljs-comment"><span class="hljs-comment">#    self.score += 10 self.text = f'Score:\n{self.score}' self.terminal.update_widget(self) class HPLabel(Label): """   """ def __init__(self, *args, **kwargs): super().__init__(text='HP:\n5') self.hp = 5 def on_event(self, event): if event.event_type == 'ac_damage' and event.event_value[0] == 'player': self.hp -= event.event_value[1] self.text = f'HP:\n{self.hp}' self.terminal.update_widget(self)</span></span></code> </pre> <br></div></div><br>  El generador enemigo y el objeto responsable de la salida de "GAME OVER" no se muestran en absoluto, por lo que heredan de Listener.  El principio es el mismo: los objetos escuchan la cola, esperan el momento adecuado y luego crean una entidad o widget. <br><br><div class="spoiler">  <b class="spoiler_title">gameover</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    - . . . class GameOverListener(Listener): """       """ def __init__(self, *args, widget=None, **kwargs): print (args) super().__init__(*args, *kwargs) self.widget = widget def on_event(self, event): if event.event_type == 'ecs_destroy' and event.event_value == 'player': self.terminal.add_widget(self.widget, pos=(20, 20), layer=5)</span></span></code> </pre><br></div></div><br>  Ahora hemos creado todo lo que necesitamos y podemos comenzar el juego. <br><br><div class="spoiler">  <b class="spoiler_title">Lanzamos</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,   Listeners    terminal.start() terminal.add_widget(layout) terminal.add_widget(score, pos=(85, 10)) terminal.add_widget(hp, pos=(85, 15))</span></span></code> </pre> <br></div></div><br>  Los widgets se agregan a la pantalla solo despu√©s de que comienza.  Las entidades podr√≠an agregarse al mapa anteriormente: los eventos de creaci√≥n (en los que se almacena toda la entidad, incluido el widget) simplemente se acumulan en la cola y se resuelven en el primer tic.  Pero el terminal puede agregar widgets solo despu√©s de que se haya creado una ventana con √©xito. <br><br>  En este punto, tenemos un prototipo que funciona, puede <s>emitir en Early Access por veinte d√≥lares</s> agregar funciones y pulir el juego.  Pero esto ya est√° m√°s all√° del alcance de Halloworld, y de ah√≠ el art√≠culo.  Solo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agregar√©</a> que la compilaci√≥n independiente del sistema python se puede construir usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pyinstaller</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470950/">https://habr.com/ru/post/470950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470930/index.html">Gamificaci√≥n del producto. Ratatype de historia</a></li>
<li><a href="../470934/index.html">Cura antes de la boda: proliferaci√≥n celular y habilidades regenerativas de las medusas</a></li>
<li><a href="../470938/index.html">C√≥mo abrir un enlace en Python. Trabajar con WebBrowser y resolver un problema con Internet Explorer</a></li>
<li><a href="../470940/index.html">MSK VUE.JS Meetup # 3 en Mail.ru Group: materiales de mitap</a></li>
<li><a href="../470942/index.html">Desde principiantes hasta iconos de estilo: c√≥mo hicimos premios en 2GIS</a></li>
<li><a href="../470952/index.html">Consejos y trucos forenses digitales: aplicaci√≥n "Su tel√©fono" Forense</a></li>
<li><a href="../470954/index.html">Instale Zimbra OSE 8.8.15 y Zextras Suite Pro en Ubuntu 18.04 LTS</a></li>
<li><a href="../470958/index.html">Las sondas de vida en Kubernetes pueden ser peligrosas</a></li>
<li><a href="../470962/index.html">JSConf Budapest 2019</a></li>
<li><a href="../470964/index.html">Juguetes de madera - inscripciones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>