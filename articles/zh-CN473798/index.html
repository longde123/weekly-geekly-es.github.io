<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💄 🍁 🥈 面向协议的编程。 第一部分 🧑 🗨️ 👻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="让我们仔细研究一下面向协议的编程主题。 为了方便起见，将材料分为三个部分。 


 本材料是WWDC 2016演示文稿的评论翻译。 与“引擎盖下的东西”应该保留在那里的普遍看法相反，有时弄清楚那里发生的事情非常有用。 这将有助于正确使用该物品并将其用于预期目的。 


 本部分将解决面向对象编程中的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>面向协议的编程。 第一部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473798/"><p> 让我们仔细研究一下面向协议的编程主题。 为了方便起见，将材料分为三个部分。 </p><br><p> 本材料是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WWDC 2016演示文稿的</a>评论翻译。 与“引擎盖下的东西”应该保留在那里的普遍看法相反，有时弄清楚那里发生的事情非常有用。 这将有助于正确使用该物品并将其用于预期目的。 </p><a name="habracut"></a><br><p> 本部分将解决面向对象编程中的关键问题以及POP如何解决它们。 一切都将以Swift语言的实际情况来考虑，细节将被视为协议的“引擎部分”。 </p><br><h2 id="problemy-oop-i-zachem-nam-nuzhno-pop">  OOP问题以及为什么我们需要POP </h2><br><p> 众所周知，在OOP中，有许多弱点可以“重载”程序执行。 考虑最明确和最常见的： </p><br><ol><li> 分配：堆栈还是堆？ </li><li> 参考计数：或多或少？ </li><li> 方法分配：静态还是动态？ </li></ol><br><h3 id="11-allocation---stack">  1.1分配-堆栈 </h3><br><p>堆栈是一个相当简单和原始的数据结构。 我们可以放在堆栈的顶部（推动），我们可以从堆栈的顶部（弹出）取出。 简单的是，这就是我们所能做的。 </p><br><p> 为简单起见，让我们假设每个堆栈都有一个变量（堆栈指针）。 它用于跟踪堆栈的顶部并存储一个整数（Integer）。 因此，使用堆栈的操作速度等于将Integer重写为该变量的速度。 </p><br><p>  Push-放在堆栈顶部，增加堆栈指针； </p><br><p> 弹出-减少堆栈指针。 </p><br><h3 id="tipy-znacheniy"> 值类型 </h3><br><p> 让我们考虑一下使用结构（struct）在Swift中进行堆栈操作的原理。 </p><br><p> 在Swift中，值类型是结构（struct）和枚举（enum），引用类型是类（class）和函数/闭包（func）。 值类型存储在堆栈中，引用类型存储在堆中。 </p><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">// (1) let point2 = point1 // (2) point2.x = 5 // (3) //  point1 //  point2 // (4)</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/tq/vj/8y/tqvj8yfygyvbneaqfwwuiig8on0.png"></p><br><ol><li> 我们将第一个结构放在堆栈上 </li><li> 复制第一个结构的内容 </li><li> 更改第二个结构的内存（第一个结构保持不变） </li><li> 使用终止。 可用内存 </li></ol><br><h3 id="12-allocation---heap">  1.2分配-堆 </h3><br><p> 堆是树状的数据结构。 堆实现主题在这里不会受到影响，但是我们将尝试将其与堆栈进行比较。 </p><br><p> 为什么，如果可能的话，值得使用Stack而不是Heap？ 原因如下： </p><br><ul><li> 参考计数 </li><li> 空闲内存管理及其寻找分配 </li><li> 重写内存以进行释放 </li></ul><br><p> 所有这些只是使Heap正常工作的一小部分，与Stack相比，显然它要小得多。 </p><br><p> 例如，当我们需要堆栈上的可用内存时，我们只需获取堆栈指针的值并将其增加（因为堆栈中堆栈指针上方的所有内容都是可用内存）-O（1）是时间恒定的操作。 </p><br><p> 当我们在Heap上需要可用内存时，我们开始使用数据树结构中的适当搜索算法来搜索它-最佳情况下，我们有一个O（登录）操作，该操作在时间上不是恒定的，并取决于特定的实现。 <br> 实际上，堆要复杂得多：它的工作是由操作系统中其他许多机制提供的。 </p><br><p> 还要注意的是，在多线程模式下使用堆会大大加重这种情况，因为有必要确保不同线程的共享资源（内存）同步。 这可以通过使用锁（信号灯，自旋锁等）来实现。 </p><br><h3 id="ssylochnye-tipy"> 参考类型 </h3><br><p> 让我们看看使用类在Heap中Swift的工作方式。 </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">// (1) let point2 = point1 // (2) point2.x = 5 // (3) //  point1 //  point2 // (4)</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/o4/ct/y3/o4cty3n_4gizx4o0-amtg2f5tqm.png"></p><br><p>  1.将班级主体放在堆上。 将指向此主体的指针放在堆栈上。 </p><br><ol><li> 复制指向类主体的指针 </li><li> 我们改变一个阶级的身体 </li><li> 使用终止。 可用内存 </li></ol><br><h3 id="13-allocation---nebolshoy-i-realnyy-primer">  1.3分配-一个小的“真实”示例 </h3><br><p> 在某些情况下，选择堆栈不仅可以简化内存处理，而且可以提高代码质量。 考虑一个例子： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> red, green, blue } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Orientation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tail</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">none</span></span>, tail, bubble } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cache: [<span class="hljs-type"><span class="hljs-type">String</span></span>: <span class="hljs-type"><span class="hljs-type">UIImage</span></span>] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeBalloon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color: Color, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation: Orientation, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tail: Tail)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIImage</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-string"><span class="hljs-string">"\(color):\(orientation):\(tail)"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = cache[key] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> image } ... }</code> </pre> <br><p> 如果缓存字典具有带有键key的值，则该函数将仅返回缓存的UIImage。 </p><br><h3 id="problemy-etogo-koda"> 此代码的问题是： </h3><br><p> 最好不要使用String作为缓存中的键，因为String最终“可能是任何东西”。 </p><br><p> 字符串是写时复制结构，为了实现其动态性，它会将所有其Character-s存储在堆中。 因此，String是一种结构，并存储在Stack中，但其所有内容都存储在Heap中。 </p><br><p> 为了提供更改线的能力（删除线的一部分，向该线添加新线），这是必需的。 如果字符串的所有字符都存储在堆栈中，那么这样的操作将是不可能的。 例如，在C中，字符串是静态的，这意味着在运行时不能增加字符串的大小，因为所有内容都存储在Stack中。 有关Swift中的写时复制和更详细的行解析，请单击<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> 。 </p><br><h3 id="reshenie"> 解决方案： </h3><br><ol><li><p> 使用非常明显的结构代替字符串： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attributes</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hashable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color: <span class="hljs-type"><span class="hljs-type">Color</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orientation: <span class="hljs-type"><span class="hljs-type">Orientation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tail: <span class="hljs-type"><span class="hljs-type">Tail</span></span> }</code> </pre> <br></li><li><p> 将字典更改为： </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cache: [<span class="hljs-type"><span class="hljs-type">Attributes</span></span>: <span class="hljs-type"><span class="hljs-type">UIImage</span></span>] = []</code> </pre> <br></li><li><p> 摆脱字符串 </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-type"><span class="hljs-type">Attributes</span></span>(color: color, orientation: orientation, tail: tail)</code> </pre> <br></li></ol><br><p> 在Attributes结构中，所有属性都存储在Stack中，因为枚举存储在Stack中。 这意味着此处没有隐式使用Heap，并且现在非常精确地定义了高速缓存字典的键，从而提高了此代码的安全性和清晰度。 我们还摆脱了对堆的隐式使用。 </p><br><p>  <strong>结论：</strong>堆栈比堆更容易，更快捷-大多数情况下的选择是显而易见的。 </p><br><h3 id="2-podschet-ssylok">  2.参考计数 </h3><br><p> 为了什么 </p><br><p>  Swift应该知道何时可以在Heap上释放一块内存，例如由类或函数的实例占用。 这是通过链接计数机制实现的-托管在Heap上的每个实例（类或函数）都有一个变量，用于存储指向它的链接数。 当没有链接到实例时，Swift决定释放为其分配的一块内存。 </p><br><p> 应该注意的是，对于这种机制的“高质量”实施，与增加和减少堆栈指针相比，需要更多的资源。 这是由于以下事实：链接数的值可以从不同的线程增加（因为您可以从不同的线程引用类或函数）。 同样，不要忘记需要确保不同线程（自旋锁，信号灯等）的共享资源（链接数可变）同步。 </p><br><p> 堆栈：查找可用内存并释放已用内存-堆栈指针操作 </p><br><p> 堆：搜索可用内存并释放已用内存-树搜索算法和引用计数。 </p><br><p> 在Attributes结构中，所有属性都存储在Stack中，因为枚举存储在Stack中。 这意味着此处没有隐式使用Heap，并且现在非常精确地定义了高速缓存字典的键，从而提高了此代码的安全性和清晰度。 我们还摆脱了对堆的隐式使用。 </p><br><h3 id="psevdokod"> 伪代码 </h3><br><p> 考虑一小段伪代码，以演示链接计数的工作原理： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> refCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(...) { ... <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point2 = point1 retain(point2) <span class="hljs-comment"><span class="hljs-comment">// retain() -  refCount  1    point2.x = 5 //  `point1` release(point1) // release() -  refCount  1 //  `point2` release(point2)</span></span></code> </pre> <br><h3 id="struct"> 结构 </h3><br><p> 使用结构时，根本不需要诸如引用计数之类的机制： </p><br><ol><li> 结构未存储在堆上 </li><li>  struct-分配时复制，因此没有参考 </li></ol><br><h3 id="kopirovanie-ssylok"> 复制链接 </h3><br><p> 同样，在赋值时复制struct和Swift中的其他任何值类型。 如果结构本身存储链接，则还将复制它们： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Label</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> font: <span class="hljs-type"><span class="hljs-type">UIFont</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { ... text.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> font.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label = <span class="hljs-type"><span class="hljs-type">Label</span></span>(text: <span class="hljs-string"><span class="hljs-string">"Hi"</span></span>, font: font) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label2 = label retain(label2.text._storage) <span class="hljs-comment"><span class="hljs-comment">//    `String`       Heap retain(label2.font) //  label release(label.text._storage) release(label.font) //  label2 release(label2.text._storage) release(label2.font)</span></span></code> </pre> <br><p>  label和label2共享在Heap上托管的常见实例： </p><br><ul><li> 文字内容 </li><li> 和字体 </li></ul><br><p> 因此，如果该结构本身存储链接，则在复制此结构时，链接数将增加一倍，这在不必要的情况下会对程序的“轻松”产生负面影响。 </p><br><h3 id="i-snova-realnyy-primer"> 再次是“真实的”示例： </h3><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attachment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fileUrl: <span class="hljs-type"><span class="hljs-type">URL</span></span> <span class="hljs-comment"><span class="hljs-comment">//   HEAP  let uuid: String //    HEAP  let mimeType: String //    HEAP  init?(fileUrl: URL, uuid: String, mimeType: String) { guard mimeType.isMimeType else { return nil } self.fileUrl = fileUrl self.uuid = uuid self.mimeType = mimeType } }</span></span></code> </pre> <br><p> 这种结构的问题在于： </p><br><ol><li>  3堆分配 </li><li> 因为String可以是任何字符串，所以安全性和代码清晰度会受到影响。 </li></ol><br><p> 同时，uuid和mimeType是严格定义的东西： </p><br><p>  uuid是格式为xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx的字符串 <br>  mimeType是类型/扩展名格式的字符串。 </p><br><h3 id="reshenie-1"> 解决方案 </h3><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> uuid: <span class="hljs-type"><span class="hljs-type">UUID</span></span> <span class="hljs-comment"><span class="hljs-comment">// UUID  ,    Foundation</span></span></code> </pre> <br><p> 对于mimeType，枚举可以正常工作： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MimeType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(rawValue: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> rawValue { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .jpeg <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/png"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .png <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/gif"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .gif <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> jpeg, png, gif }</code> </pre> <br><p> 或更容易： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MimeType</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> jpeg = <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> png = <span class="hljs-string"><span class="hljs-string">"image/png"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> gif = <span class="hljs-string"><span class="hljs-string">"image/gif"</span></span> }</code> </pre> <br><p> 并且不要忘记更改： </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mimeType: <span class="hljs-type"><span class="hljs-type">MimeType</span></span></code> </pre> <br><h3 id="31-method-dispatch">  3.1方法分派 </h3><br><ul><li> 这是一种算法，用于寻找被调用的方法代码 </li></ul><br><p> 在讨论此机制的实现之前，值得确定在这种情况下什么是“消息”和“方法”： </p><br><ul><li> 消息是我们发送给对象的名称。 参数仍然可以与名称一起发送。 </li></ul><br><pre> <code class="swift hljs">circle.draw(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: origin)</code> </pre> <br><p> 消息是draw-方法的名称。 接收者对象是一个圆。 起源也是一个论点。 </p><br><ul><li>  method是响应消息而返回的代码。 </li></ul><br><p> 然后，方法调度是一种算法，该算法决定应为特定消息提供哪种方法。 </p><br><h2 id="bolee-konkretno-o-method-dispatch-v-swift"> 更具体地说，关于Swift中的方法调度 </h2><br><p> 由于我们可以从父类继承并覆盖其方法，因此Swift必须确切知道在特定情况下需要调用该方法的哪种实现。 </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">me</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"parent"</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">me</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"child"</span></span>) } }</code> </pre> <br><p> 创建几个实例并调用me方法： </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parent = <span class="hljs-type"><span class="hljs-type">Parent</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> child = <span class="hljs-type"><span class="hljs-type">Child</span></span>() parent.me() <span class="hljs-comment"><span class="hljs-comment">// "parent" child.me() // "child"</span></span></code> </pre> <br><p> 一个相当明显和简单的例子。 如果： </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array: [<span class="hljs-type"><span class="hljs-type">Parent</span></span>] = [<span class="hljs-type"><span class="hljs-type">Child</span></span>(), <span class="hljs-type"><span class="hljs-type">Child</span></span>(), <span class="hljs-type"><span class="hljs-type">Parent</span></span>(), <span class="hljs-type"><span class="hljs-type">Child</span></span>()] array.forEach { $<span class="hljs-number"><span class="hljs-number">0</span></span>.me() <span class="hljs-comment"><span class="hljs-comment">// "child" "child" "parent" "child" }</span></span></code> </pre> <br><p> 这并不是很明显，需要资源和某种机制来确定me方法的正确实现。 资源是处理器和RAM。 机制是方法调度。 </p><br><p> 换句话说，方法调度是程序确定要调用的方法实现的方式。 </p><br><p> 在代码中调用方法时，必须知道其实现。 如果她知道 <br> 在编译时，这就是静态调度。 如果在调用之前（在运行时，在执行代码时）确定实现，那么这就是动态调度。 </p><br><h3 id="32-method-dispatch---static-dispatch">  3.2方法分派-静态分派 </h3><br><p> 最佳，因为： </p><br><ol><li> 编译器知道将调用哪个代码块（方法实现）。 因此，他可以尽可能地优化此代码，并采用内联这样的机制。 </li><li> 同样，在执行代码时，程序将简单地执行编译器已知的该代码块。 将不会花费资源和时间来确定该方法的正确实现，这将加速程序的执行。 </li></ol><br><h3 id="33-method-dispatch---dynamic-dispatch">  3.3方法分派-动态分派 </h3><br><p> 不是最佳的，因为： </p><br><ol><li> 该方法的正确实现将在程序执行时确定，这需要资源和时间 </li><li> 没有编译器优化是不可能的 </li></ol><br><h3 id="34-method-dispatch---inlining">  3.4方法分派-内联 </h3><br><p> 提到了诸如内联的机制，但这是什么？ 考虑一个例子： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Point.draw implementation } } func drawAPoint(_ param: Point) { param.draw() } let point = Point(x: 0, y: 0) drawAPoint(point)</span></span></code> </pre> <br><ul><li>  point.draw（）方法和drawAPoint函数将通过“静态分派”处理，因为为编译器确定正确的实现没有困难（因为没有继承且无法重新定义） </li><li> 由于编译器知道将要执行的操作，因此可以对其进行优化。 首先优化drawAPoint，只需将函数调用替换为其代码即可： </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) point.draw()</code> </pre> <br><ul><li> 然后优化point.draw，因为该方法的实现也是众所周知的： </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Point.draw implementation</span></span></code> </pre> <br><p> 我们创建了一个点，执行了draw方法的代码-编译器只是将必需的代码替换为这些函数，而不是调用它们。 在动态调度中，这将变得更加复杂。 </p><br><h3 id="35-method-dispatch---inheritance-based-polymorphism">  3.5方法分派-基于继承的多态性 </h3><br><p> 为什么需要动态调度？ 没有它，就不可能定义被子类覆盖的方法。 多态是不可能的。 考虑一个例子： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, y1, x2, y2: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawables: [<span class="hljs-type"><span class="hljs-type">Drawable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawables { d.draw() }</code> </pre> <br><ul><li>  drawables数组可以包含Point和Line </li><li> 从直观上讲，此处无法进行静态调度。  for循环中的d可以是Line，也可以是Point。 编译器无法确定这一点，并且每种类型都有其自己的draw实现 </li></ul><br><p> 那么动态调度如何工作？ 每个对象都有一个类型字段。 所以Point（...）。类型将等于Point，而Line（...）。类型将等于Line。 程序（静态）存储器中的某个位置还有一个表（虚拟表），其中每种类型都有一个列表及其方法实现。 </p><br><p> 在Objective-C中，类型字段称为isa字段。 它存在于每个Objective-C对象（NSObject）上。 </p><br><p> 类方法存储在虚拟表中，并且不了解自己。 为了在此方法中使用self，需要将其传递到其中（self）。 </p><br><p> 因此，编译器会将这段代码更改为： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">self</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Point)</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">self</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Line)</span></span></span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawables: [<span class="hljs-type"><span class="hljs-type">Drawable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawables { vtable[d.type].draw(d) }</code> </pre> <br><p> 在执行代码时，您需要查看虚拟表，在其中找到类d，从结果列表中获取draw方法，并将其传递为类型为self的d对象。 对于简单的方法调用来说，这是一项体面的工作，但是必须确保多态性能够正常工作。 任何OOP语言都使用类似的机制。 </p><br><h2 id="method-dispatch---itog"> 方法分派-摘要 </h2><br><ul><li> 默认情况下，通过Dynamic Dispatch处理类方法。 但是，并非所有类方法都需要通过动态调度来处理。 如果该方法未被覆盖，则可以使用final关键字将其开头，然后编译器将知道该方法不能被覆盖，并将通过静态分派对其进行处理。 </li><li> 非类方法不能被覆盖（因为struct和enum不支持继承），并且可以通过静态分派来处理 </li></ul><br><h2 id="problemy-oop---itog">  OOP问题-摘要 </h2><br><p> 有必要注意以下琐事： </p><br><ol><li> 创建实例时：它将位于何处？ </li><li> 使用此实例时：链接计数将如何工作？ </li><li> 调用方法时：如何处理？ </li></ol><br><p> 如果我们为动力付出了代价却没有意识到并且不需要它，那么这将对正在实施的程序产生负面影响。 </p><br><p> 多态是非常重要和有用的事情。 目前，所有已知的是Swift中的多态性与类和引用类型直接相关。 反过来，我们说类又慢又重，结构又简单又容易。 通过结构可能实现多态吗？ 面向协议的编程可以为这个问题提供答案。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN473798/">https://habr.com/ru/post/zh-CN473798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN473786/index.html">里加黑客马拉松的注册工作即将结束。 奖-PhysTech短期培训</a></li>
<li><a href="../zh-CN473788/index.html">蛋白质发现现代生物学的未知方面</a></li>
<li><a href="../zh-CN473790/index.html">3d图形中的样条线，最自动化的选项</a></li>
<li><a href="../zh-CN473794/index.html">移动网络钓鱼-无尽的威胁</a></li>
<li><a href="../zh-CN473796/index.html">光纤HDMI延长器。 300米</a></li>
<li><a href="../zh-CN473800/index.html">生物雷达，纸板无人机和飞行香肠-Nikita Kalinovsky关于好的和坏的搜索技术</a></li>
<li><a href="../zh-CN473802/index.html">阿兰·庞巴（Alain Bombar）-凯旋后倒下</a></li>
<li><a href="../zh-CN473804/index.html">初级质量检查的薪水是多少？</a></li>
<li><a href="../zh-CN473806/index.html">这就是我们想要的互联网：社交媒体如何变成致命武器</a></li>
<li><a href="../zh-CN473812/index.html">2019年11月IT领域人力资源专业人员的事件摘要</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>