<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏣 🌸 💦 Erstellen Sie mit Dynamic Proxy und Spring IoC Ihre eigene Spring Data Repository-Stilbibliothek 🙌🏾 👋🏽 🆙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aber was wäre, wenn Sie beispielsweise eine Schnittstelle wie diese erstellen könnten: 


@Service public interface GoogleSearchApi { /** * @return ht...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie mit Dynamic Proxy und Spring IoC Ihre eigene Spring Data Repository-Stilbibliothek</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458548/"><p> Aber was wäre, wenn Sie beispielsweise eine Schnittstelle wie diese erstellen könnten: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoogleSearchApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> http status code for Google main page */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainPageStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Und dann injizieren Sie es einfach und rufen Sie seine Methoden auf: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CommandLineRunner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(App.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> GoogleSearchApi api; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GoogleSearchApi api)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api = api; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Main page status: "</span></span> + api.mainPageStatus()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(App.class, args); } }</code> </pre> <br><p>  Dies ist durchaus möglich (und nicht sehr schwierig) zu implementieren.  Als nächstes werde ich zeigen, wie und warum es geht. </p><a name="habracut"></a><br><p>  Vor kurzem hatte ich die Aufgabe, die Interaktion der Entwickler mit einem der verwendeten Frameworks zu vereinfachen.  Es war notwendig, ihnen eine noch einfachere und bequemere Möglichkeit zu geben, mit ihm zu arbeiten, als die, die bereits implementiert worden war. </p><br><p>  Eigenschaften, die ich mit einer solchen Lösung erreichen wollte: </p><br><ul><li>  deklarative Beschreibung der gewünschten Aktion </li><li>  Mindestmenge an Code erforderlich </li><li>  Integration in das verwendete Abhängigkeitsinjektions-Framework (in unserem Fall Spring) </li></ul><br><p>  Dies ist in den Bibliotheken <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring Data Repository</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Retrofit</a> implementiert.  In ihnen beschreibt der Benutzer die gewünschte Interaktion in Form einer Java-Oberfläche, ergänzt durch Anmerkungen.  Der Benutzer muss die Implementierung nicht selbst schreiben - die Bibliothek generiert sie zur Laufzeit basierend auf den Signaturen von Methoden, Anmerkungen und Typen. </p><br><p>  Als ich das Thema studierte, hatte ich viele Fragen, deren Antworten im Internet verstreut waren.  In diesem Moment würde mich ein Artikel wie dieser nicht verletzen.  Deshalb habe ich hier versucht, alle Informationen und meine Erfahrungen an einem Ort zu sammeln. </p><br><p>  In diesem Beitrag werde ich am Beispiel eines Wrappers für einen http-Client zeigen, wie Sie diese Idee implementieren können.  Ein Beispiel für ein Spielzeug, das nicht für den realen Gebrauch gedacht ist, sondern den Ansatz demonstriert.  Der Quellcode des Projekts kann auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://bitbucket.org/bachkovsky/dynamic-proxy-">Bitbucket</a> studiert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://bitbucket.org/bachkovsky/dynamic-proxy-">werden</a> . </p><br><h3 id="kak-eto-vyglyadit-dlya-polzovatelya">  Wie sieht es für den Benutzer aus? </h3><br><p>  Der Benutzer beschreibt den von ihm benötigten Dienst in Form einer Schnittstelle.  So führen Sie beispielsweise http-Anforderungen bei Google aus: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Some Google requests */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoogleSearchApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> http status code for Google main page */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainPageStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> request object for Google main page */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com"</span></span>) <span class="hljs-function"><span class="hljs-function">HttpGet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainPageRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> query search query * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> result of search request execution */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com/search?q={query}"</span></span>) <span class="hljs-function"><span class="hljs-function">CloseableHttpResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String query)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> query doodle search query * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> language doodle search language * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> http status code for doodle search result */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com/doodles/?q={query}&amp;hl={language}"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchDoodleStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String query, String language)</span></span></span></span>; }</code> </pre> <br><p>  Was die Implementierung dieser Schnittstelle letztendlich bewirken wird, wird durch die Signatur bestimmt.  Wenn der Rückgabetyp int ist, wird eine http-Anforderung ausgeführt und der Status als Ergebniscode zurückgegeben.  Wenn der Rückgabetyp CloseableHttpResponse ist, wird die gesamte Antwort zurückgegeben und so weiter.  Wenn die Anfrage gestellt wird, nehmen wir den Uri aus der Anmerkung und ersetzen die gleichen übertragenen Werte anstelle von Platzhaltern in ihrem Inhalt. </p><br><p>  In diesem Beispiel habe ich mich darauf beschränkt, drei Rückgabetypen und eine Anmerkung zu unterstützen.  Sie können auch Methodennamen und Parametertypen verwenden, um eine Implementierung auszuwählen, und alle Arten von Kombinationen davon verwenden, aber ich werde dieses Thema in diesem Beitrag nicht öffnen. </p><br><p>  Wenn ein Benutzer diese Schnittstelle verwenden möchte, bettet er sie mit Spring in seinen Code ein: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CommandLineRunner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(App.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> GoogleSearchApi api; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GoogleSearchApi api)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api = api; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Main page status: "</span></span> + api.mainPageStatus()); LOG.info(<span class="hljs-string"><span class="hljs-string">"Main page request: "</span></span> + api.mainPageRequest()); LOG.info(<span class="hljs-string"><span class="hljs-string">"Doodle search status: "</span></span> + api.searchDoodleStatus(<span class="hljs-string"><span class="hljs-string">"tesla"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (CloseableHttpResponse response = api.searchSomething(<span class="hljs-string"><span class="hljs-string">"qweqwe"</span></span>)) { LOG.info(<span class="hljs-string"><span class="hljs-string">"Search result "</span></span> + response); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(App.class, args); } }</code> </pre> <br><p>  Die Integration mit Spring war in meinem Arbeitsprojekt erforderlich, aber es ist natürlich nicht das einzig mögliche.  Wenn Sie die Abhängigkeitsinjektion nicht verwenden, können Sie die Implementierung beispielsweise über die statische Factory-Methode abrufen.  Aber in diesem Artikel werde ich den Frühling betrachten. </p><br><p>  Dieser Ansatz ist sehr praktisch: Markieren Sie Ihre Schnittstelle einfach als Bestandteil von Spring (in diesem Fall Service-Annotation) und sie kann implementiert und verwendet werden. </p><br><h3 id="kak-zastavit-spring-podderzhivat-etu-magiyu">  Wie man den Frühling dazu bringt, diese Magie zu unterstützen </h3><br><p>  Eine typische Spring-Anwendung durchsucht den Klassenpfad beim Start und sucht nach allen Komponenten, die mit speziellen Anmerkungen gekennzeichnet sind.  Für sie registriert es BeanDefinitions, Rezepte, mit denen diese Komponenten erstellt werden.  Wenn Spring jedoch bei konkreten Klassen weiß, wie sie erstellt werden, welche Konstruktoren aufgerufen und was sie übergeben werden müssen, verfügt Spring für abstrakte Klassen und Schnittstellen nicht über solche Informationen.  Daher wird für unsere GoogleSearchApi Spring keine BeanDefinition erstellt.  Dabei wird er Hilfe von uns brauchen. </p><br><p>  Um die Logik der Verarbeitung von BeanDefinitions abzuschließen, gibt es im Frühjahr eine BeanDefinitionRegistryPostProcessor-Schnittstelle.  Damit können wir der BeanDefinitionRegistry jede gewünschte Definition von Beans hinzufügen. </p><br><p>  Leider habe ich keine Möglichkeit gefunden, mich in die Spring-Logik des Klassenpfad-Scans zu integrieren, um sowohl normale Beans als auch unsere Schnittstellen in einem einzigen Durchgang zu verarbeiten.  Daher habe ich den Nachkommen der ClassPathScanningCandidateComponentProvider-Klasse erstellt und verwendet, um alle mit der Service-Annotation gekennzeichneten Schnittstellen zu finden: </p><br><p>  Vollständiger Paket-Scan-Code und Registrierung von BeanDefinitions: </p><br><div class="spoiler">  <b class="spoiler_title">DynamicProxyBeanDefinitionRegistryPostProcessor</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicProxyBeanDefinitionRegistryPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanDefinitionRegistryPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,     private static final String[] SCAN_PACKAGES = {"com"}; private final InterfaceScanner classpathScanner; public DynamicProxyBeanDefinitionRegistryPostProcessor() { classpathScanner = new InterfaceScanner(); //   .      Service classpathScanner.addIncludeFilter(new AnnotationTypeFilter(Service.class)); } @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { for (String basePackage : SCAN_PACKAGES) { createRepositoryProxies(basePackage, registry); } } @SneakyThrows private void createRepositoryProxies(String basePackage, BeanDefinitionRegistry registry) { for (BeanDefinition beanDefinition : classpathScanner.findCandidateComponents(basePackage)) { Class&lt;?&gt; clazz = Class.forName(beanDefinition.getBeanClassName()); //      bean definition BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(clazz); builder.addConstructorArgValue(clazz); //,          builder.setFactoryMethodOnBean( "createDynamicProxyBean", DynamicProxyBeanFactory.DYNAMIC_PROXY_BEAN_FACTORY ); registry.registerBeanDefinition(ClassUtils.getShortNameAsProperty(clazz), builder.getBeanDefinition()); } } @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { } private static class InterfaceScanner extends ClassPathScanningCandidateComponentProvider { InterfaceScanner() { super(false); } @Override protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) { return beanDefinition.getMetadata().isInterface(); } } }</span></span></code> </pre> </div></div><br><p>  Fertig!  Zu Beginn der Anwendung führt Spring diesen Code aus und registriert alle erforderlichen Schnittstellen wie Beans. </p><br><p>  Das Erstellen einer Implementierung der gefundenen Beans wird an eine separate Komponente von DynamicProxyBeanFactory delegiert: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(DYNAMIC_PROXY_BEAN_FACTORY) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicProxyBeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String DYNAMIC_PROXY_BEAN_FACTORY = <span class="hljs-string"><span class="hljs-string">"repositoryProxyBeanFactory"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DynamicProxyInvocationHandlerDispatcher proxy; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicProxyBeanFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DynamicProxyInvocationHandlerDispatcher proxy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.proxy = proxy; } <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unused"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createDynamicProxyBean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; beanClass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//noinspection unchecked return (T) Proxy.newProxyInstance(beanClass.getClassLoader(), new Class[]{beanClass}, proxy); } }</span></span></code> </pre> <br><p>  Zum Erstellen der Implementierung wird der gute alte Dynamic Proxy-Mechanismus verwendet.  Eine Implementierung wird im laufenden Betrieb mit der Proxy.newProxyInstance-Methode erstellt.  Es wurden bereits viele Artikel über ihn geschrieben, daher werde ich hier nicht im Detail darauf eingehen. </p><br><h3 id="poisk-nuzhnogo-obrabotchika-i-obrabotka-vyzova">  Den richtigen Handler finden und Anrufe bearbeiten </h3><br><p>  Wie Sie sehen können, leitet DynamicProxyBeanFactory die Methodenverarbeitung an DynamicProxyInvocationHandlerDispatcher um.  Da wir möglicherweise viele Implementierungen von Handlern haben (für jede Annotation, für jeden zurückgegebenen Typ usw.), ist es logisch, einen zentralen Ort für deren Speicherung und Suche einzurichten. </p><br><p>  Um festzustellen, ob der Handler für die Verarbeitung der aufgerufenen Methode geeignet ist, habe ich die Standard-InvocationHandler-Schnittstelle um eine neue Methode erweitert </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerMatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> true} if handler is able to handle given method, {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> false} othervise */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Method method)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProxyInvocationHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvocationHandler</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerMatcher</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  Das Ergebnis ist die ProxyInvocationHandler-Schnittstelle, deren Implementierungen unsere Handler sein werden.  Außerdem werden Handler-Implementierungen als Komponente markiert, damit Spring sie für uns in einer großen Liste in DynamicProxyInvocationHandlerDispatcher sammeln kann: </p><br><div class="spoiler">  <b class="spoiler_title">DynamicProxyInvocationHandlerDispatcher</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.bachkovsky.dynproxy.lib.proxy; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.SneakyThrows; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.stereotype.Component; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.reflect.InvocationHandler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.reflect.Method; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-comment"><span class="hljs-comment">/** * Top level dynamic proxy invocation handler, which finds correct implementation based and uses it for method * invocation */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicProxyInvocationHandlerDispatcher</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvocationHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;ProxyInvocationHandler&gt; proxyHandlers; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> proxyHandlers all dynamic proxy handlers found in app context */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicProxyInvocationHandlerDispatcher</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;ProxyInvocationHandler&gt; proxyHandlers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.proxyHandlers = proxyHandlers; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (method.getName()) { <span class="hljs-comment"><span class="hljs-comment">// three Object class methods don't have default implementation after creation with Proxy::newProxyInstance case "hashCode": return System.identityHashCode(proxy); case "toString": return proxy.getClass() + "@" + System.identityHashCode(proxy); case "equals": return proxy == args[0]; default: return doInvoke(proxy, method, args); } } @SneakyThrows private Object doInvoke(Object proxy, Method method, Object[] args) { return findHandler(method).invoke(proxy, method, args); } private ProxyInvocationHandler findHandler(Method method) { return proxyHandlers.stream() .filter(h -&gt; h.canHandle(method)) .findAny() .orElseThrow(() -&gt; new IllegalStateException("No handler was found for method: " + method)); } }</span></span></code> </pre> </div></div><br><p>  In der findHandler-Methode gehen wir alle Handler durch und geben den ersten zurück, der die übergebene Methode verarbeiten kann.  Dieser Suchmechanismus ist möglicherweise nicht sehr effektiv, wenn viele Handler-Implementierungen vorhanden sind.  Vielleicht müssen Sie dann über eine geeignetere Struktur zum Speichern nachdenken als über eine Liste. </p><br><h3 id="realizaciya-obrabotchikov">  Handler-Implementierung </h3><br><p>  Die Aufgaben der Handler umfassen das Lesen von Informationen über die aufgerufene Methode der Schnittstelle und das Verarbeiten des Aufrufs selbst. </p><br><p>  Was soll der Handler in diesem Fall tun: </p><br><ol><li>  Lesen Sie die Uri-Anmerkung und holen Sie sich den Inhalt </li><li>  Ersetzen Sie Uri-Platzhalter in der Zeichenfolge durch echte Werte </li><li>  Rückgabetyp der Lesemethode </li><li>  Wenn der Rückgabetyp geeignet ist, verarbeiten Sie die Methode und geben Sie das Ergebnis zurück. </li></ol><br><p>  Die ersten drei Punkte werden für alle zurückgegebenen Typen benötigt, daher habe ich den allgemeinen Code in eine abstrakte Oberklasse eingefügt <br>  HttpInvocationHandler: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpInvocationHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProxyInvocationHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HttpClient client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UriHandler uriHandler; HttpInvocationHandler(HttpClient client, UriHandler uriHandler) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client = client; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uriHandler = uriHandler; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Method method)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uriHandler.canHandle(method); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Method method, Object[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uriHandler.getUriString(method, args); } }</code> </pre> <br><p>  Die UriHandler-Hilfsklasse implementiert die Arbeit mit der Uri-Annotation: Lesen von Werten, Ersetzen von Platzhaltern.  Ich werde den Code hier nicht geben, weil  es ist ziemlich nützlich. <br>  Es ist jedoch zu beachten, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie zum Kompilieren</a> der Parameternamen aus der Signatur der Java-Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beim Kompilieren die Option "-parameters" hinzufügen müssen</a> . <br>  HttpClient - ein Wrapper über Apachevsky CloseableHttpClient, ist ein Backend für diese Bibliothek. </p><br><p>  Als Beispiel für einen bestimmten Handler werde ich einen Handler angeben, der einen Statusantwortcode zurückgibt: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpCodeInvocationHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpInvocationHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HttpCodeInvocationHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpClient client, UriHandler uriHandler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(client, uriHandler); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (CloseableHttpResponse resp = client.execute(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpGet(getUri(method, args)))) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resp.getStatusLine().getStatusCode(); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Method method)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.canHandle(method) &amp;&amp; method.getReturnType().equals(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.class); } }</code> </pre> <br><p>  Andere Handler werden ähnlich hergestellt.  Das Hinzufügen neuer Handler ist einfach und erfordert keine Änderung des vorhandenen Codes. Erstellen Sie einfach einen neuen Handler und markieren Sie ihn als Spring-Komponente. </p><br><p>  Das ist alles.  Der Code ist geschrieben und bereit zu gehen. </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Je mehr ich über ein solches Design nachdenke, desto mehr sehe ich Fehler darin.  Schwächen, die ich sehe: </p><br><ul><li>  Typ Sicherheit, was nicht ist.  Stellen Sie die Anmerkung falsch ein - bevor Sie sich mit RuntimeException treffen.  Verwendete die falsche Kombination aus Rückgabetyp und Anmerkung - dasselbe. </li><li>  Schwache Unterstützung durch die IDE.  Fehlende automatische Vervollständigung.  Der Benutzer kann nicht sehen, welche Aktionen ihm in seiner Situation zur Verfügung stehen (als ob er einen „Punkt“ hinter das Objekt setzen und eine Liste der verfügbaren Methoden sehen würde). </li><li>  Es gibt nur wenige Anwendungsmöglichkeiten.  Der bereits erwähnte http-Client fällt mir ein und der Client wechselt zur Datenbank.  Aber warum kann dies sonst angewendet werden? </li></ul><br><p>  In meinem Arbeitsentwurf hat der Ansatz jedoch Wurzeln geschlagen und ist beliebt.  Die Vorteile, die ich bereits erwähnt habe - Einfachheit, wenig Code, Deklarativität - ermöglichen es Entwicklern, sich auf das Schreiben von wichtigerem Code zu konzentrieren. </p><br><p>  Was denkst du über diesen Ansatz?  Lohnt sich die Mühe?  Welche Probleme sehen Sie bei diesem Ansatz?  Während ich immer noch versuche, es zu verstehen, während es in unserer Produktion herumgerollt wird, würde ich gerne hören, was andere Leute darüber denken.  Ich hoffe, dieses Material war für jemanden nützlich. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458548/">https://habr.com/ru/post/de458548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458524/index.html">VC Wortwolke am Knie</a></li>
<li><a href="../de458530/index.html">Zabbix, Zeitreihen und TimescaleDB</a></li>
<li><a href="../de458532/index.html">Pioniere neuer Technologien: Vadim Artsev erzählte, wie er aufhörte, blind zu sein</a></li>
<li><a href="../de458536/index.html">Python + Pyside2 oder einfach "Rechner"</a></li>
<li><a href="../de458546/index.html">Automation Day oder wie wir die Ebene der Autotests aufbauen</a></li>
<li><a href="../de458550/index.html">Symbole GOST-Bibliothek für DipTrace</a></li>
<li><a href="../de458552/index.html">Informationen zum Vergleichen von Speicherformaten in Hadoop: Beginnen wir mit ORC</a></li>
<li><a href="../de458556/index.html">Entwickeln Sie die Chrome-Erweiterung mit Angular CLI</a></li>
<li><a href="../de458558/index.html">Präsentationen mit Magento Meetup Kharkiv - Videos und Präsentationen</a></li>
<li><a href="../de458560/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 12. Erweitertes VLAN</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>