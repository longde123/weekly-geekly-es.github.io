<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóÇÔ∏è üõÅ ‚è∏Ô∏è C√≥mo funciona JS: comunicaciones WebRTC y P2P üì® üö≠ üìß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Recomendar lectura] Las otras 19 partes del ciclo  Parte 1: Descripci√≥n general del motor, mecanismos de tiempo de ejecuci√≥n, pila de llamadas 
 Part...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo funciona JS: comunicaciones WebRTC y P2P</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416821/"><div class="spoiler">  <b class="spoiler_title">[Recomendar lectura] Las otras 19 partes del ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descripci√≥n general del motor, mecanismos de tiempo de ejecuci√≥n, pila de llamadas</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acerca de los componentes internos V8 y la optimizaci√≥n del c√≥digo</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">administrar la memoria, cuatro tipos de p√©rdidas de memoria y tratar con ellas</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bucle de eventos, as√≠ncrono y cinco formas de mejorar su c√≥digo con as√≠ncrono / espera</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WebSocket y HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Que elegir</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Caracter√≠sticas y alcance de WebAssembly</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajadores web y cinco escenarios de uso</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajadores de servicio</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">notificaciones push web</a> <br>  Parte 10: realizar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguimiento de los cambios en el DOM con MutationObserver</a> <br>  Parte 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motores de representaci√≥n de p√°ginas web y consejos para optimizar su rendimiento</a> <br>  Parte 12: El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subsistema de red de los navegadores, optimizando su rendimiento y seguridad.</a> <br>  Parte 12: El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subsistema de red de los navegadores, optimizando su rendimiento y seguridad.</a> <br>  Parte 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Animaci√≥n con CSS y JavaScript.</a> <br>  Parte 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: √°rboles de sintaxis abstracta, an√°lisis y su optimizaci√≥n</a> <br>  Parte 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: clases y herencia, transpilaci√≥n en Babel y TypeScript</a> <br>  Parte 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: almacenamiento</a> <br>  Parte 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: tecnolog√≠a Shadow DOM y componentes web</a> <br>  Parte 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: Mecanismos de comunicaci√≥n WebRTC y P2P</a> <br>  Parte 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: Elementos personalizados</a> </div></div><br>  Hoy publicamos una traducci√≥n de la parte 18 de una serie de materiales dedicados a todo lo relacionado con JavaScript.  Aqu√≠ hablaremos sobre la tecnolog√≠a WebRTC, que tiene como objetivo organizar el intercambio directo de datos entre las aplicaciones del navegador en tiempo real. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/aff/ed1/fee/affed1fee433a9375eefd24a753a89b8.png" alt="imagen"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Revisar</font> </h2><br>  ¬øQu√© es WebRTC?  Para empezar, vale la pena decir que la abreviatura RTC significa comunicaci√≥n en tiempo real (comunicaci√≥n en tiempo real).  Esto solo brinda mucha informaci√≥n sobre esta tecnolog√≠a. <br><br>  WebRTC ocupa un nicho muy importante entre los mecanismos de la plataforma web.  Anteriormente, las tecnolog√≠as P2P (redes punto a punto, conexiones punto a punto, redes punto a punto, punto a punto) utilizadas por aplicaciones como los chats de escritorio les brindaban oportunidades que los proyectos web no ten√≠an.  WebRTC marca la diferencia para las tecnolog√≠as web. <br><br>  WebRTC, si consideramos esta tecnolog√≠a en t√©rminos generales, permite que las aplicaciones web creen conexiones P2P, que discutiremos a continuaci√≥n.  Adem√°s, cubriremos los siguientes temas aqu√≠ para mostrar la imagen completa de la estructura interna de WebRTC: <br><br><ul><li>  Comunicaciones P2P. </li><li>  Cortafuegos y tecnolog√≠a NAT Traversal. </li><li>  Se√±alizaci√≥n, sesiones y protocolos. </li><li>  API de WebRTC </li></ul><br><h2>  <font color="#3AC1EF">Comunicaciones P2P</font> </h2><br>  Supongamos que dos usuarios han lanzado, cada uno en su propio navegador, una aplicaci√≥n que le permite organizar un chat de video usando WebRTC.  Quieren establecer una conexi√≥n P2P.  Despu√©s de tomar la decisi√≥n, necesitamos un mecanismo que permita a los navegadores de los usuarios encontrarse y establecer comunicaci√≥n teniendo en cuenta los mecanismos de protecci√≥n de la informaci√≥n disponibles en los sistemas.  Despu√©s de establecer una conexi√≥n, los usuarios podr√°n intercambiar informaci√≥n multimedia en tiempo real. <br><br>  Una de las principales dificultades asociadas con las conexiones P2P del navegador es que los navegadores primero necesitan descubrirse entre s√≠ y luego establecer una conexi√≥n de red basada en sockets para proporcionar transferencia de datos bidireccional.  Sugerimos discutir las dificultades asociadas con la instalaci√≥n de tales conexiones. <br><br>  Cuando una aplicaci√≥n web necesita algunos datos o recursos, los descarga del servidor y eso es todo.  La direcci√≥n del servidor es conocida por la aplicaci√≥n.  Si estamos hablando, por ejemplo, de crear un chat P2P, cuya operaci√≥n se basa en la conexi√≥n directa de los navegadores, las direcciones de estos navegadores no se conocen de antemano.  Como resultado, para establecer una conexi√≥n P2P, tendr√° que lidiar con algunos problemas. <br><br><h2>  <font color="#3AC1EF">Cortafuegos y protocolo transversal NAT</font> </h2><br>  Las computadoras ordinarias, por regla general, no tienen direcciones IP externas est√°ticas asignadas a ellas.  La raz√≥n de esto es que tales computadoras generalmente est√°n ubicadas detr√°s de firewalls y dispositivos NAT. <br><br>  NAT es un mecanismo que traduce las direcciones IP locales internas ubicadas detr√°s de un firewall en direcciones IP globales externas.  La tecnolog√≠a NAT se utiliza, en primer lugar, por razones de seguridad y, en segundo lugar, debido a las restricciones impuestas por IPv4 en la cantidad de direcciones IP globales disponibles.  Es por eso que las aplicaciones web que usan WebRTC no deber√≠an basarse en el hecho de que el dispositivo actual tiene una direcci√≥n IP est√°tica global. <br><br>  Veamos c√≥mo funciona NAT.  Si est√° en una red corporativa y est√° conectado a WiFi, a su computadora se le asignar√° una direcci√≥n IP que solo existe detr√°s de su dispositivo NAT.  Supongamos que esta es la direcci√≥n IP 172.0.23.4.  Sin embargo, para el mundo exterior, su direcci√≥n IP puede parecer 164.53.27.98.  Como resultado, el mundo exterior considera que sus solicitudes provienen de la direcci√≥n 164.53.27.98, pero gracias a NAT, las respuestas a las solicitudes realizadas por su computadora a servicios externos se enviar√°n a su direcci√≥n interna 172.0.23.4.  Esto sucede usando tablas de traducci√≥n.  Tenga en cuenta que adem√°s de la direcci√≥n IP, tambi√©n se requiere un n√∫mero de puerto para la conexi√≥n en red. <br><br>  Dado que NAT est√° involucrado en el proceso de interacci√≥n de su sistema con el mundo exterior, su navegador, para establecer una conexi√≥n WebRTC, necesita conocer la direcci√≥n IP de la computadora en la que se est√° ejecutando el navegador que desea comunicar. <br><br>  Aqu√≠ es donde los servidores STUN (Session Traversal Utilities for NAT) y TURN (Traversal Using Relys around NAT) entran en escena.  Para garantizar el funcionamiento de la tecnolog√≠a WebRTC, primero se realiza una solicitud al servidor STUN para averiguar su direcci√≥n IP externa.  De hecho, estamos hablando de una solicitud hecha a un servidor remoto para averiguar desde qu√© direcci√≥n IP el servidor recibe esta solicitud.  Habiendo recibido una solicitud similar, el servidor remoto enviar√° una respuesta que contiene la direcci√≥n IP visible para √©l. <br><br>  Basado en el supuesto de que este esquema es operativo y que recibi√≥ informaci√≥n sobre su direcci√≥n IP y puerto externos, puede informar a otros participantes en el sistema (los llamaremos pares) sobre c√≥mo contactarlo directamente.  Estos pares tambi√©n pueden hacer lo mismo usando los servidores STUN o TURN y pueden decirle qu√© direcciones se les asignan. <br><br><h2>  <font color="#3AC1EF">Se√±alizaci√≥n, sesiones y protocolos.</font> </h2><br>  El proceso de encontrar la informaci√≥n de red descrita anteriormente es una de las partes de un gran sistema de se√±alizaci√≥n que, en el caso de WebRTC, se basa en el est√°ndar JSEP (Protocolo de establecimiento de sesi√≥n de JavaScript).  La se√±alizaci√≥n incluye descubrimiento de recursos de red, creaci√≥n y administraci√≥n de sesiones, seguridad de comunicaci√≥n, coordinaci√≥n de par√°metros de medios, manejo de errores. <br><br>  Para que la conexi√≥n funcione, los pares deben acordar los formatos de datos que intercambiar√°n y recopilar informaci√≥n sobre las direcciones de red de la computadora en la que se ejecuta la aplicaci√≥n.  El mecanismo de se√±alizaci√≥n para compartir esta informaci√≥n cr√≠tica no forma parte de la API de WebRTC. <br><br>  La se√±alizaci√≥n no est√° definida por el est√°ndar WebRTC, y no est√° implementada en su API para proporcionar flexibilidad en las tecnolog√≠as y protocolos utilizados.  La se√±alizaci√≥n y los servidores que la soportan son responsabilidad del desarrollador de la aplicaci√≥n WebRTC. <br><br>  Basado en el supuesto de que su aplicaci√≥n WebRTC que se ejecuta en el navegador puede determinar la direcci√≥n IP externa del navegador utilizando STUN, como se describi√≥ anteriormente, el siguiente paso es analizar los par√°metros de la sesi√≥n y establecer una conexi√≥n con otro navegador. <br><br>  La discusi√≥n inicial de los par√°metros de sesi√≥n y el establecimiento de una conexi√≥n se realiza utilizando un protocolo de se√±alizaci√≥n / comunicaci√≥n especializado en comunicaciones multimedia.  Este protocolo, adem√°s, es responsable de cumplir con las reglas bajo las cuales se administra y finaliza la sesi√≥n. <br><br>  Uno de estos protocolos se llama SIP (Protocolo de inicio de sesi√≥n).  Tenga en cuenta que debido a la flexibilidad del subsistema de se√±alizaci√≥n WebRTC, SIP no es el √∫nico protocolo de se√±alizaci√≥n que se puede utilizar.  El protocolo de se√±alizaci√≥n seleccionado, adem√°s, debe funcionar con un protocolo de capa de aplicaci√≥n llamado SDP (Protocolo de descripci√≥n de sesi√≥n), que se utiliza cuando se usa WebRTC.  Todos los metadatos relacionados con los datos multimedia se transmiten utilizando el protocolo SDP. <br><br>  Cualquier par (es decir, una aplicaci√≥n que utiliza WebRTC) que intenta ponerse en contacto con otro par genera un conjunto de rutas candidatas para el protocolo ICE (Establecimiento de conectividad interactiva).  Los candidatos representan una combinaci√≥n de direcci√≥n IP, puerto y protocolo de transporte que se pueden usar.  Tenga en cuenta que una computadora puede tener muchas interfaces de red (cableadas, inal√°mbricas, etc.), por lo que se le pueden asignar varias direcciones IP, una para cada interfaz. <br><br>  Aqu√≠ hay un diagrama con MDN que ilustra el proceso anterior de intercambio de datos. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/eb5/3a2/c33eb53a21f48ec8f629ac38fc503d4e.png"></div><br>  <i><font color="#999999">El proceso de intercambio de datos necesarios para establecer una conexi√≥n P2P</font></i> <br><br><h2>  <font color="#3AC1EF">Establecer una conexi√≥n</font> </h2><br>  Cada par primero descubre su direcci√≥n IP externa como se describe anteriormente.  Luego, se crean din√°micamente "canales" de datos de se√±alizaci√≥n, que sirven para detectar pares y apoyar el intercambio de datos entre ellos, para discutir los par√°metros de sesi√≥n y su instalaci√≥n. <br><br>  Estos "canales" son desconocidos e inaccesibles para el mundo exterior, se requiere un identificador √∫nico para acceder a ellos. <br><br>  Tenga en cuenta que debido a la flexibilidad de WebRTC y al hecho de que el proceso de se√±alizaci√≥n no est√° definido por el est√°ndar, el concepto de "canales" y el orden de su uso pueden variar ligeramente seg√∫n las tecnolog√≠as utilizadas.  De hecho, algunos protocolos no requieren un mecanismo de "canal" para organizar el intercambio de datos.  A los fines de este material, suponemos que se utilizan los "canales" en la implementaci√≥n del sistema. <br><br>  Si dos o m√°s pares est√°n conectados al mismo "canal", los pares tienen la oportunidad de intercambiar datos y discutir informaci√≥n de la sesi√≥n.  Este proceso es similar a una plantilla de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">editor-suscriptor</a> .  En general, el par que inicia la conexi√≥n env√≠a una "oferta" utilizando un protocolo de se√±alizaci√≥n como SIP o SDP.  El iniciador espera recibir una "respuesta" del destinatario de la propuesta, que est√° conectada al "canal" considerado. <br><br>  Despu√©s de recibir la respuesta, se lleva a cabo el proceso de determinar y discutir los mejores candidatos de ICE recolectados por cada fiesta.  Despu√©s de seleccionar los candidatos ICE √≥ptimos, se acuerdan los par√°metros de datos que se intercambiar√°n entre pares y el mecanismo de enrutamiento de la red (direcci√≥n IP y puerto). <br><br>  Luego, se establece una sesi√≥n de socket de red activa entre pares.  Adem√°s, cada par crea flujos de datos locales y puntos finales de canales de datos, y la transmisi√≥n bidireccional de datos multimedia comienza a usar la tecnolog√≠a aplicada. <br><br>  Si el proceso de negociaci√≥n para elegir el mejor candidato de ICE no tiene √©xito, lo que a veces ocurre debido a la falla de los cortafuegos y los sistemas NAT, se usa una opci√≥n de respaldo, que consiste en usar, como un rel√©, un servidor TURN.  Este proceso involucra un servidor que act√∫a como intermediario que transmite los datos intercambiados entre pares.  Tenga en cuenta que este esquema no es una conexi√≥n P2P real en la que los pares transmiten datos directamente entre s√≠. <br><br>  Cuando se utiliza una reserva con TURN para el intercambio de datos, cada par ya no necesita saber c√≥mo comunicarse con los dem√°s y c√≥mo transferirle datos.  En cambio, los pares necesitan saber qu√© servidor TURN externo necesita enviar datos multimedia en tiempo real y desde qu√© servidor deben recibir durante la sesi√≥n de comunicaci√≥n. <br><br>  Es importante comprender que ahora era una forma alternativa de organizar las comunicaciones.  Los servidores TURN deben ser muy confiables, tener un gran ancho de banda y una gran potencia de c√≥mputo, admitir el trabajo con cantidades potencialmente grandes de datos.  El uso de un servidor TURN, por lo tanto, obviamente conlleva costos adicionales y un aumento en la complejidad del sistema. <br><br><h2>  <font color="#3AC1EF">API de WebRTC</font> </h2><br>  Hay tres categor√≠as principales de API que existen en WebRTC: <br><br><ul><li>  La API de captura y transmisi√≥n de medios es responsable de la captura y transmisi√≥n de medios.  Esta API le permite conectarse a dispositivos de entrada, como micr√≥fonos y c√°maras web, y recibir transmisiones multimedia de ellos. </li><li>  API RTCPeerConnection  Usando la API de esta categor√≠a, es posible, desde un punto final de WebRTC, enviar, en tiempo real, la secuencia capturada de datos de audio o video a trav√©s de Internet a otro punto final de WebRTC.  Con esta API, puede crear conexiones entre la m√°quina local y el par remoto.  Proporciona m√©todos para conectarse a un par remoto, para administrar la conexi√≥n y para monitorear su estado.  Sus mecanismos se utilizan para cerrar conexiones innecesarias. </li><li>  RTCDataChannel API  Los mecanismos representados por esta API permiten la transferencia de datos arbitrarios.  Cada canal de datos est√° asociado con una interfaz RTCPeerConnection. </li></ul><br>  Hablemos de estas API. <br><br><h2>  <font color="#3AC1EF">API Media Capture y Streams</font> </h2><br>  Media Capture and Streams API, a menudo denominada Media Stream API o Stream API, es una API que admite trabajar con flujos de datos de audio y video, m√©todos para trabajar con ellos.  Usando esta API, puede establecer restricciones relacionadas con los tipos de datos, aqu√≠ hay devoluciones de llamada para completar con √©xito y sin √©xito las operaciones que se utilizan cuando se utilizan mecanismos asincr√≥nicos para trabajar con datos y eventos que se generan durante la operaci√≥n. <br><br>  El m√©todo <code>getUserMedia()</code> de la API <code>getUserMedia()</code> le pide al usuario permiso para trabajar con dispositivos de entrada que producen transmisiones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MediaStream</a> con pistas de audio o video que contienen los tipos de medios solicitados.  Dicha transmisi√≥n puede incluir, por ejemplo, una pista de video (su fuente es una fuente de video virtual o de hardware, como una c√°mara, una grabadora de video, un servicio para compartir pantalla, etc.), una pista de audio (las fuentes de audio f√≠sicas o virtuales pueden formarla de manera similar, como un micr√≥fono, un convertidor de anal√≥gico a digital, etc.) y posiblemente otros tipos de pistas. <br><br>  Este m√©todo devuelve la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">promesa</a> que se resuelve en el objeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MediaStream</a> .  Si el usuario rechaza la solicitud de permiso o el medio correspondiente no est√° disponible, la promesa se resolver√°, respectivamente, con un <code>NotFoundError</code> <code>PermissionDeniedError</code> o <code>NotFoundError</code> . <br><br>  Puede acceder al Singleton de <code>MediaDevice</code> trav√©s del objeto <code>navigator</code> : <br><br><pre> <code class="hljs php">navigator.mediaDevices.getUserMedia(constraints) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> });</code> </pre> <br>  Tenga en cuenta que cuando llama al m√©todo <code>getUserMedia()</code> , debe pasarle un objeto de <code>constraints</code> que le indique a la API qu√© tipo de flujo debe devolver.  Aqu√≠ puede configurar muchas cosas, incluida la c√°mara que desea usar (frontal o posterior), velocidad de fotogramas, resoluci√≥n, etc. <br><br>  A partir de la versi√≥n 25, los navegadores basados ‚Äã‚Äãen Chromium permiten la transferencia de datos de audio de <code>getUserMedia()</code> elementos de audio o video (sin embargo, tenga en cuenta que, por defecto, los elementos multimedia estar√°n deshabilitados). <br><br>  El m√©todo <code>getUserMedia()</code> tambi√©n se puede usar como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un nodo de entrada para la API de audio web</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gotStream</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stream</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.AudioContext = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.AudioContext || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.webkitAudioContext;   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> audioContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AudioContext();   <span class="hljs-comment"><span class="hljs-comment">//  AudioNode     var mediaStreamSource = audioContext.createMediaStreamSource(stream);   //       ,    ,   //       !   mediaStreamSource.connect(audioContext.destination); } navigator.getUserMedia({audio:true}, gotStream);</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Limitaciones relacionadas con la protecci√≥n de la informaci√≥n personal.</font> </h2><br>  La captura no autorizada de datos de un micr√≥fono o c√°mara es una interferencia grave con la vida personal del usuario.  Por lo tanto, el uso de <code>getUserMedia()</code> proporciona la implementaci√≥n de requisitos muy espec√≠ficos para notificar al usuario sobre lo que est√° sucediendo y para administrar los permisos.  El m√©todo <code>getUserMedia()</code> siempre debe obtener el permiso del usuario antes de abrir cualquier dispositivo de entrada que recopile medios, como una c√°mara web o un micr√≥fono.  Los navegadores pueden ofrecer la opci√≥n de una configuraci√≥n de permiso √∫nica para un dominio, pero deben solicitar permiso al menos la primera vez que acceden a dispositivos de medios, y el usuario debe otorgar expl√≠citamente dicho permiso. <br><br>  Adem√°s, las reglas relacionadas con la notificaci√≥n al usuario sobre lo que est√° sucediendo son importantes aqu√≠.  Los navegadores deben mostrar un indicador que indique el uso de un micr√≥fono o una c√°mara.  La visualizaci√≥n de dicho indicador no depende de la presencia en el sistema de indicadores de hardware que indiquen el funcionamiento de dichos dispositivos.  Adem√°s, los navegadores deben mostrar un indicador de que se ha otorgado permiso para usar el dispositivo de entrada, incluso si el dispositivo no se usa en alg√∫n momento para registrar datos relevantes. <br><br><h2>  <font color="#3AC1EF">Interfaz RTCPeerConnection</font> </h2><br>  La interfaz RTCPeerConnection es una conexi√≥n WebRTC entre la computadora local y el par remoto.  Proporciona m√©todos para conectarse a un sistema remoto, para soportar la conexi√≥n y monitorear su estado, y para cerrar la conexi√≥n despu√©s de que ya no sea necesaria. <br><br>  Aqu√≠ hay un diagrama de arquitectura WebRTC que demuestra el papel de RTCPeerConnection. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/a16/dfe/4c0a16dfe63b400dc7082cd733ffa863.png"></div><br>  <i><font color="#999999">RTCPeerConnection Role</font></i> <br><br>  Desde una perspectiva de JavaScript, el conocimiento principal que se puede extraer del an√°lisis de este diagrama es que RTCPeerConnection abstrae al desarrollador web de mecanismos complejos ubicados en niveles m√°s profundos del sistema.  Los c√≥decs y protocolos utilizados por WebRTC hacen un gran trabajo para permitir el intercambio de datos en tiempo real, incluso cuando se utilizan redes no confiables.  Estas son algunas de las tareas resueltas por estos mecanismos: <br><br><ul><li>  P√©rdida de paquetes de enmascaramiento. </li><li>  Cancelaci√≥n de eco. </li><li>  Adaptaci√≥n de ancho de banda. </li><li>  B√∫fer din√°mico para eliminar la fluctuaci√≥n de fase. </li><li>  Control autom√°tico de volumen. </li><li>  Reducci√≥n de ruido y supresi√≥n. </li><li>  "Limpiando" la imagen. </li></ul><br><h2>  <font color="#3AC1EF">RTCDataChannel API</font> </h2><br>  Al igual que con los datos de audio y video, WebRTC admite la transmisi√≥n en tiempo real de otros tipos de datos.  La API RTCDataChannel le permite organizar un intercambio P2P de datos arbitrarios. <br><br>  Hay muchos escenarios para usar esta API.  Aqu√≠ hay algunos de ellos: <br><br><ul><li>  Juegos </li><li>  Chats de texto en tiempo real. </li><li>  Transferencia de archivos. </li><li>  Organizaci√≥n de redes descentralizadas. </li></ul><br>  Esta API est√° dirigida al uso m√°s eficiente de las capacidades de la API RTCPeerConnection y le permite organizar un sistema de intercambio de datos potente y flexible en un entorno P2P.  Entre sus caracter√≠sticas est√°n las siguientes: <br><br><ul><li>  Trabajo efectivo con sesiones usando RTCPeerConnection. </li><li>  Soporte para m√∫ltiples canales de comunicaci√≥n utilizados simult√°neamente con priorizaci√≥n. </li><li>  Soporte para m√©todos confiables y poco confiables de entrega de mensajes. </li><li>  Gesti√≥n de seguridad incorporada (DTLS) y congesti√≥n. </li></ul><br>  La sintaxis aqu√≠ es similar a la utilizada cuando se trabaja con la tecnolog√≠a WebSocket.  El m√©todo <code>send()</code> y el evento de <code>message</code> se aplican aqu√≠: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> peerConnection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webkitRTCPeerConnection(servers,   {<span class="hljs-attr"><span class="hljs-attr">optional</span></span>: [{<span class="hljs-attr"><span class="hljs-attr">RtpDataChannels</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}]} ); peerConnection.ondatachannel = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{   receiveChannel = event.channel;   receiveChannel.onmessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">)</span></span>{       <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">"#receiver"</span></span>).innerHTML = event.data;   }; }; sendChannel = peerConnection.createDataChannel(<span class="hljs-string"><span class="hljs-string">"sendDataChannel"</span></span>, {<span class="hljs-attr"><span class="hljs-attr">reliable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>}); <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">"button#send"</span></span>).onclick = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">"textarea#send"</span></span>).value;   sendChannel.send(data); }</code> </pre> <br><h2>  <font color="#3AC1EF">WebRTC en el mundo real</font> </h2><br>  En el mundo real, la comunicaci√≥n WebRTC requiere servidores.  Los sistemas no son demasiado complicados; gracias a ellos, se implementa la siguiente secuencia de acciones: <br><br><ul><li>  Los usuarios se descubren e intercambian informaci√≥n unos de otros, por ejemplo, nombres. </li><li>  Las aplicaciones de cliente WebRTC (pares) intercambian informaci√≥n de red. </li><li>  Los pares intercambian informaci√≥n sobre datos multimedia, como el formato y la resoluci√≥n de video. </li><li>  Las aplicaciones de cliente WebRTC establecen una conexi√≥n que pasa por alto las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puertas de enlace NAT</a> y los firewalls. </li></ul><br>  En otras palabras, WebRTC necesita cuatro tipos de funciones de servidor: <br><br><ul><li>  Medios para descubrir usuarios y organizar su interacci√≥n. </li><li>  Se√±alizaci√≥n </li><li>  Omitir NAT y firewalls. </li><li>  Servidores de retransmisi√≥n utilizados cuando no se puede establecer una conexi√≥n P2P. </li></ul><br>  El protocolo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">STUN</a> y su extensi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TURN</a> son utilizados por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ICE</a> para permitir que RTCPeerConnection funcione con mecanismos de derivaci√≥n NAT y para hacer frente a otras dificultades encontradas al transmitir datos a trav√©s de una red. <br><br>  Como ya se mencion√≥, ICE es un protocolo para conectar pares, como dos clientes de video chat.  Al comienzo de la sesi√≥n de comunicaci√≥n, ICE intenta conectar pares directamente, con el menor retraso posible, a trav√©s de UDP.  Durante este proceso, los servidores STUN tienen una √∫nica tarea: permitir que los pares detr√°s de NAT conozcan su direcci√≥n p√∫blica y puerto.  Eche un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta lista de</a> servidores STUN disponibles (Google tambi√©n tiene dichos servidores). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/935/4e9/1a09354e9eb986043dc153ffb8b82500.png"></div><br>  <i><font color="#999999">Servidores STUN</font></i> <br><br><h2>  <font color="#3AC1EF">Detecci√≥n de candidatos de ICE</font> </h2><br>  Si no se puede establecer la conexi√≥n UDP, ICE intenta establecer una conexi√≥n TCP: primero, a trav√©s de HTTP, luego, a trav√©s de HTTPS.  Si no se puede establecer una conexi√≥n directa, en particular, debido a la incapacidad de eludir los NAT y firewalls corporativos, ICE utiliza un intermediario (retransmisi√≥n) en forma de servidor TURN.  En otras palabras, ICE primero intentar√° usar STUN con UDP para la conexi√≥n directa de sus pares, y si esto no funciona, usar√° una opci√≥n alternativa con un inquilino en forma de servidor TURN.  El t√©rmino "b√∫squeda de candidatos" se refiere al proceso de b√∫squeda de interfaces de red y puertos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80d/c0a/41b/80dc0a41b9c4f59966b325e95c99e9c3.png"></div><br>  <i><font color="#999999">Encontrar interfaces de red y puertos adecuados</font></i> <br><br><h2>  <font color="#3AC1EF">Seguridad</font> </h2><br>  Las aplicaciones de comunicaciones en tiempo real o los complementos relacionados pueden generar problemas de seguridad.  En particular, estamos hablando de lo siguiente: <br><br><ul><li>  Los datos de medios no cifrados u otros datos pueden ser interceptados a lo largo de la ruta entre navegadores, o entre un navegador y un servidor. </li><li>  Una aplicaci√≥n puede, sin el conocimiento del usuario, grabar y transmitir datos de video y audio a un atacante. </li><li>  Junto con un complemento o aplicaci√≥n de aspecto inofensivo, un virus u otro software malicioso puede llegar a la computadora del usuario. </li></ul><br>  WebRTC tiene varios mecanismos dise√±ados para hacer frente a estas amenazas: <br><br><ul><li>  Las implementaciones de WebRTC utilizan protocolos seguros como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DTLS</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SRTP</a> . </li><li>  Para todos los componentes de los sistemas WebRTC, el uso del cifrado es obligatorio.  Esto tambi√©n se aplica a los mecanismos de se√±alizaci√≥n. </li><li>  WebRTC no es un complemento.  Los componentes de WebRTC se ejecutan en el entorno limitado del navegador y no en un proceso separado.  Los componentes se actualizan cuando se actualiza el navegador. </li><li>  El acceso a la c√°mara y al micr√≥fono debe darse expl√≠citamente.  Y, cuando se usa una c√°mara o un micr√≥fono, este hecho se muestra claramente en la interfaz de usuario del navegador. </li></ul><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  WebRTC es una tecnolog√≠a muy interesante y poderosa para proyectos que utilizan la transferencia de cualquier informaci√≥n entre navegadores en tiempo real.  El autor del material dice que su empresa, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SessionStack</a> , utiliza mecanismos tradicionales para intercambiar datos con los usuarios, lo que implica el uso de servidores.  Sin embargo, si usaran WebRTC para resolver los problemas correspondientes, esto permitir√≠a organizar el intercambio de datos directamente entre los navegadores, lo que reducir√≠a el retraso en la transferencia de datos y reducir√≠a la carga en la infraestructura de la compa√±√≠a. <br><br>  <b>Estimados lectores!</b>  ¬øUtiliza la tecnolog√≠a WebRTC en sus proyectos? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416821/">https://habr.com/ru/post/es416821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416809/index.html">Modelos de billar Elo y EloBet</a></li>
<li><a href="../es416813/index.html">Cuando 2 x 3 = 2, o una vez m√°s sobre la virtualizaci√≥n de datos</a></li>
<li><a href="../es416815/index.html">C√≥mo dejamos de pasar una semana emitiendo un puesto de desarrollo</a></li>
<li><a href="../es416817/index.html">3er lugar en la etapa de calificaci√≥n de DataScienceGame 2018</a></li>
<li><a href="../es416819/index.html">Adi√≥s, microservicios: de cien ni√±os problem√°ticos a una superestrella</a></li>
<li><a href="../es416823/index.html">Sangre, sudor y p√≠xeles: de qu√© trata el libro de Jason Schreier</a></li>
<li><a href="../es416825/index.html">C√≥mo no ser un desarrollador mediocre</a></li>
<li><a href="../es416827/index.html">Contenedores para adultos (Parte 02): una gu√≠a pr√°ctica de terminolog√≠a</a></li>
<li><a href="../es416829/index.html">Modelo de modelo ABI v0.5.6 Beta</a></li>
<li><a href="../es416831/index.html">El enrutamiento externo del tr√°fico dom√©stico ruso se reducir√° al 5%</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>