<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üßöüèΩ üëèüèª .NET: Herramientas para trabajar con subprocesos m√∫ltiples y asincron√≠a. Parte 2 üê¨ üë¶üèæ üëπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Publico el art√≠culo original sobre Habr, cuya traducci√≥n se publica en el blog Codingsight . 

 Sigo creando una versi√≥n de texto de mi charla en la r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: Herramientas para trabajar con subprocesos m√∫ltiples y asincron√≠a. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459514/">  <i>Publico el art√≠culo original sobre Habr, cuya traducci√≥n se publica en el blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Codingsight</a> .</i> <br><br>  Sigo creando una versi√≥n de texto de mi charla en la reuni√≥n de subprocesos m√∫ltiples.  La primera parte se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , all√≠ se trataba m√°s sobre el conjunto b√°sico de herramientas para iniciar un hilo o tarea, formas de ver su estado y algunas peque√±as cosas dulces como PLinq.  En este art√≠culo, quiero centrarme m√°s en los problemas que pueden surgir en un entorno multiproceso y en algunas formas de resolverlos. <br><br><h2>  Contenido </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acerca de los recursos compartidos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Posibles problemas al trabajar en un entorno multiproceso</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Punto muerto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Condici√≥n de carrera</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ocupado-espera</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hilo de hambre</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Herramientas de sincronizaci√≥n</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enclavado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Monitor.Enter, Monitor.Exit, lock</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SpinLock, SpinWait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Monitor.Wait, Monitor.Pulse [Todos]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ReaderWriterLockSlim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ResetEvent Family</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusiones</a> </li></ul><br><a name="habracut"></a><br><a name="SharedResources"></a><br><h2>  Acerca de los recursos compartidos </h2><br>  Es imposible escribir un programa que funcione en m√∫ltiples hilos, pero al mismo tiempo no tendr√≠a un solo recurso compartido:  incluso si funciona en su nivel de abstracci√≥n, al bajar uno o m√°s niveles por debajo resulta que todav√≠a hay un recurso com√∫n.  Dar√© algunos ejemplos: <br><br>  <b>Ejemplo # 1:</b> <br><br>  Temiendo posibles problemas, hizo que los hilos funcionen con diferentes archivos.  Por archivo a transmitir.  Le parece que el programa no tiene un solo recurso com√∫n. <br><br>  Despu√©s de haber bajado varios niveles a continuaci√≥n, entendemos que solo hay un disco duro, y su controlador o sistema operativo tendr√° que resolver los problemas para garantizar el acceso a √©l. <br><br>  <b>Ejemplo # 2:</b> <br><br>  Despu√©s de leer el <i>ejemplo</i> 1, decidi√≥ colocar los archivos en dos m√°quinas remotas diferentes con dos piezas de hierro y sistemas operativos f√≠sicamente diferentes.  Mantenemos 2 conexiones diferentes a trav√©s de FTP o NFS. <br><br>  Habiendo bajado varios niveles a continuaci√≥n, entendemos que nada ha cambiado, y el controlador de la tarjeta de red o el sistema operativo de la m√°quina en la que se ejecuta el programa tendr√° que resolver el problema del acceso competitivo. <br><br>  <b>Ejemplo # 3:</b> <br><br>  Despu√©s de haber perdido una parte considerable de su cabello en un intento de probar la posibilidad de escribir un programa multiproceso, rechaza completamente los archivos y descompone los c√°lculos en dos objetos diferentes, los enlaces a cada uno de los cuales est√°n disponibles solo para una secuencia. <br><br>  Clavo la √∫ltima docena de clavos en el ata√∫d de esta idea: un tiempo de ejecuci√≥n y un recolector de basura, un programador de subprocesos, f√≠sicamente una RAM y memoria, un procesador todav√≠a son recursos compartidos. <br><br>  Entonces, descubrimos que es imposible escribir un programa multiproceso sin un √∫nico recurso compartido en todos los niveles de abstracci√≥n en todo el ancho de la pila de tecnolog√≠a completa.  Afortunadamente, cada uno de los niveles de abstracci√≥n, por regla general, resuelve parcial o completamente los problemas de acceso competitivo o simplemente lo proh√≠be (por ejemplo: cualquier marco de UI proh√≠be trabajar con elementos de diferentes hilos), por lo tanto, los problemas surgen con mayor frecuencia con recursos compartidos en Su nivel de abstracci√≥n.  Para resolverlos, introduzca el concepto de sincronizaci√≥n. <br><a name="Problems"></a><br><h2>  Posibles problemas al trabajar en un entorno multiproceso </h2><br>  Los errores en el software se pueden dividir en varios grupos: <br><br><ol><li>  El programa no produce un resultado.  Se bloquea o se congela. </li><li>  El programa devuelve un resultado incorrecto. </li><li>  El programa produce el resultado correcto, pero no satisface uno u otro requisito no funcional.  Corre demasiado tiempo o consume demasiados recursos. </li></ol><br>  En un entorno multiproceso, los dos problemas principales que causan los errores 1 y 2 son el <b>punto muerto</b> y la <b>condici√≥n de carrera</b> . <br><a name="Deadlock"></a><br><h3>  Punto muerto </h3><br>  Punto muerto - punto muerto.  Hay muchas variaciones diferentes.  Los m√°s comunes son los siguientes: <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  Mientras el <b>Hilo # 1 estaba</b> haciendo algo, el <b>Hilo # 2</b> bloque√≥ el recurso <b>B</b> , un poco m√°s tarde el <b>Hilo # 1</b> bloque√≥ el recurso <b>A</b> e intenta bloquear el recurso <b>B</b> , desafortunadamente esto nunca suceder√°, porque  <b>El subproceso # 2</b> liberar√° el recurso <b>B</b> solo despu√©s de bloquear el recurso <b>A.</b> <br><a name="RaceCondition"></a><br><h3>  Condici√≥n de carrera </h3><br>  Condici√≥n de carrera: condici√≥n de carrera.  La situaci√≥n en la que el comportamiento y el resultado de los c√°lculos realizados por el programa dependen del trabajo del planificador de subprocesos en tiempo de ejecuci√≥n. <br>  Lo desagradable de esta situaci√≥n radica precisamente en el hecho de que su programa puede no funcionar solo una vez de cada cien o incluso de un mill√≥n. <br><br>  La situaci√≥n se ve agravada por el hecho de que los problemas pueden ir juntos, por ejemplo: con un cierto comportamiento del planificador de subprocesos, se produce un punto muerto. <br><br>  Adem√°s de estos dos problemas que conducen a errores obvios en el programa, tambi√©n existen aquellos que pueden no conducir a un resultado de c√°lculo incorrecto, pero se gastar√° m√°s tiempo o potencia de procesamiento para obtenerlo.  Dos de estos problemas son: <b>Busy Wait</b> y <b>Thread Starvation</b> . <br><a name="BusyWait"></a><br><h3>  Ocupado-espera </h3><br>  Busy-Wait es un problema en el que el programa consume recursos del procesador no para realizar c√°lculos, sino para esperar. <br><br>  A menudo, este problema en el c√≥digo se parece a esto: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br>  Este es un ejemplo de c√≥digo extremadamente malo ya que  Tal c√≥digo ocupa completamente un n√∫cleo de su procesador sin hacer absolutamente nada √∫til.  Puede justificarse si y solo si es cr√≠ticamente importante procesar un cambio en alg√∫n valor en otro hilo.  Y hablando r√°pido, estoy hablando del caso cuando no puedes esperar ni siquiera unos pocos nanosegundos.  En otros casos, es decir, en todo lo que puede producir un cerebro sano, es m√°s razonable usar las variedades ResetEvent y sus versiones Slim.  Sobre ellos a continuaci√≥n. <br><br>  Quiz√°s uno de los lectores propondr√° resolver el problema de cargar completamente un n√∫cleo con una espera in√∫til agregando construcciones como Thread.Sleep (1) al bucle.  Esto realmente resolver√° el problema, pero crear√° otro: el tiempo de respuesta al cambio ser√° en promedio de medio milisegundo, lo que puede no ser mucho, pero catastr√≥ficamente m√°s de lo que podr√≠a usar las primitivas de sincronizaci√≥n de la familia ResetEvent. <br><a name="ThreadStarvation"></a><br><h3>  Hilo de hambre </h3><br>  Thread-Starvation es un problema en el que el programa tiene demasiados hilos trabajando simult√°neamente.  ¬øQu√© significa exactamente esos flujos que est√°n ocupados con los c√°lculos, y no solo esperando una respuesta de cualquier IO?  Con este problema, se pierde toda la ganancia de rendimiento posible del uso de subprocesos, porque  El procesador pasa mucho tiempo cambiando de contexto. <br>  Es conveniente buscar tales problemas usando varios perfiladores, a continuaci√≥n se muestra un ejemplo de una captura de pantalla del perfilador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dotTrace</a> lanzado en modo Timeline. <br><br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>(Se puede hacer clic en la imagen)</i> <br><br>  En el programa que no sufre de hambre de transmisi√≥n, no habr√° color rosa en los gr√°ficos que reflejan las transmisiones.  Adem√°s, en la categor√≠a Subsistemas, est√° claro que el 30,6% del programa estaba esperando a la CPU. <br><br>  Cuando se diagnostica un problema de este tipo, se resuelve de manera bastante simple: comenz√≥ demasiados hilos a la vez, comenz√≥ menos o no todos a la vez. <br><a name="SyncPrimitives"></a><br><h2>  Herramientas de sincronizaci√≥n </h2><br><a name="Interlocked"></a><br><h3>  Enclavado </h3><br>  Esta es quiz√°s la forma m√°s ligera de sincronizar.  Interlocked es una colecci√≥n de operaciones at√≥micas simples.  Una operaci√≥n at√≥mica se llama operaci√≥n en el momento en que nada puede suceder.  En .NET, Interlocked est√° representado por la clase est√°tica del mismo nombre con varios m√©todos, cada uno de los cuales implementa una operaci√≥n at√≥mica. <br><br>  Para darse cuenta del horror de las operaciones no at√≥micas, intente escribir un programa que comience 10 hilos, cada uno de los cuales haga un mill√≥n de incrementos de la misma variable, y al final de su trabajo imprima el valor de esta variable; desafortunadamente ser√° muy diferente de 10 millones, adem√°s Cada vez que se inicia el programa, ser√° diferente.  Esto sucede porque incluso una operaci√≥n tan simple como un incremento no es at√≥mica, sino que implica extraer un valor de la memoria, calcular uno nuevo y escribir de nuevo.  Por lo tanto, dos subprocesos pueden realizar simult√°neamente cada una de estas operaciones, en cuyo caso se perder√° el incremento. <br><br>  La clase Interlocked proporciona m√©todos de aumento / disminuci√≥n; es f√°cil adivinar lo que hacen.  Son convenientes de usar si est√° procesando datos en m√∫ltiples hilos y considera algo.  Dicho c√≥digo funcionar√° mucho m√°s r√°pido que el bloqueo cl√°sico.  Si Interlocked se usa para la situaci√≥n descrita en el √∫ltimo p√°rrafo, el programa dar√° 10 millones de forma estable en cualquier situaci√≥n. <br><br>  El m√©todo CompareExchange realiza, a primera vista, una funci√≥n bastante obvia, pero toda su presencia le permite implementar muchos algoritmos interesantes, especialmente la familia sin bloqueo. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  El m√©todo toma tres valores: el primero se pasa por referencia y este es el valor que se cambiar√° al segundo, si en el momento de la comparaci√≥n location1 coincide con comparand, entonces se devolver√° el valor original de location1.  Suena bastante confuso, porque es m√°s f√°cil escribir c√≥digo que realice las mismas operaciones que CompareExchange: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br>  Solo una implementaci√≥n en la clase Interlocked ser√° at√≥mica.  Es decir, si escribimos ese c√≥digo nosotros mismos, podr√≠a haber ocurrido una situaci√≥n cuando la condici√≥n location1 == comparand ya se hab√≠a cumplido, pero para cuando se ejecut√≥ la expresi√≥n location1 = value, otro subproceso hab√≠a cambiado el valor de location1 y se perder√≠a. <br><br>  Podemos encontrar un buen ejemplo de uso de este m√©todo en el c√≥digo que genera el compilador para cualquier evento de C #. <br><br>  Escribamos una clase simple con un evento MyEvent: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  Construyamos el proyecto en la configuraci√≥n de lanzamiento y abramos el ensamblaje usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dotPeek</a> con la opci√≥n Mostrar c√≥digo generado por el compilador activada: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br>  Aqu√≠ puede ver que detr√°s de escena, el compilador gener√≥ un algoritmo bastante sofisticado.  Este algoritmo protege contra la situaci√≥n de perder una suscripci√≥n a un evento cuando varios hilos se suscriben a este evento simult√°neamente.  Escribamos el m√©todo add con m√°s detalle, recordando lo que hace el m√©todo CompareExchange detr√°s de escena <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br>  Esto ya est√° un poco m√°s claro, aunque probablemente todav√≠a necesite una explicaci√≥n.  En palabras, describir√≠a este algoritmo de la siguiente manera: <br><br>  <i>Si MyEvent sigue igual que en el momento en que comenzamos a ejecutar Delegate.Combine, escriba en √©l lo que Delegate.Combine devuelve, y si no, no importa, intentemos nuevamente y repita hasta que salga.</i> <i><br></i> <br><br>  Por lo tanto, no se perder√° ninguna suscripci√≥n al evento.  Tendr√° que resolver un problema similar si de repente desea implementar una matriz din√°mica libre de bloqueos segura para subprocesos.  Si varias secuencias se apresuran a agregarle elementos, entonces es importante que todas se agreguen al final. <br><a name="Lock"></a><br><h3>  Monitor.Enter, Monitor.Exit, lock </h3><br>  Estas son las construcciones m√°s utilizadas para la sincronizaci√≥n de subprocesos.  Implementan la idea de una secci√≥n cr√≠tica: es decir, el c√≥digo escrito entre llamadas a Monitor.Enter, Monitor.Exit en un recurso puede ejecutarse al mismo tiempo en un solo hilo.  La declaraci√≥n de bloqueo es az√∫car sint√°ctica alrededor de las llamadas de entrada / salida envueltas en try-finally.  Una buena caracter√≠stica de implementar una secci√≥n cr√≠tica en .NET es la capacidad de volver a ingresarla para la misma secuencia.  Esto significa que dicho c√≥digo se ejecutar√° sin problemas: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br>  Es poco probable, por supuesto, que alguien escriba de esta manera, pero si difunde este c√≥digo en varios m√©todos en profundidad, esta funci√≥n puede ahorrarle algunos errores.  Para hacer posible este truco, los desarrolladores de .NET tuvieron que agregar una restricci√≥n: solo se puede usar una instancia de un tipo de referencia como objeto de sincronizaci√≥n, y se agregan impl√≠citamente varios bytes a cada objeto donde se escribir√° el identificador de flujo. <br><br>  Esta caracter√≠stica de la secci√≥n cr√≠tica en c # impone una limitaci√≥n interesante en el funcionamiento de la declaraci√≥n de bloqueo: no puede usar la declaraci√≥n de espera dentro de la declaraci√≥n de bloqueo.  Al principio, me sorprendi√≥, porque se compila una construcci√≥n similar de Try-finally Monitor.Enter / Exit.  Cual es el problema  Aqu√≠ es necesario volver a leer cuidadosamente el √∫ltimo p√°rrafo una vez m√°s, y luego agregarle alg√∫n conocimiento sobre el principio de async / wait: el c√≥digo despu√©s de wait no necesariamente se ejecutar√° en el mismo hilo que el c√≥digo antes de wait, depende del contexto de sincronizaci√≥n y la presencia o sin llamada a ConfigureAwait.  De ello se deduce que Monitor.Exit puede ejecutarse en un subproceso que no sea Monitor.Enter, que generar√° una <b>SynchronizationLockException</b> .  Si no lo cree, puede ejecutar el siguiente c√≥digo en una aplicaci√≥n de consola: arrojar√° una SynchronizationLockException. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br>  Es de destacar que en WinForms o una aplicaci√≥n WPF, este c√≥digo funcionar√° correctamente si se llama desde el hilo principal.  Habr√° un contexto de sincronizaci√≥n que implementa un retorno al UI-Thread despu√©s de esperar.  En cualquier caso, no debe jugar con la secci√≥n cr√≠tica en el contexto del c√≥digo que contiene el operador de espera.  En estos casos, es mejor usar primitivas de sincronizaci√≥n, que se discutir√°n m√°s adelante. <br><br>  Hablando sobre el trabajo de la secci√≥n cr√≠tica en .NET, vale la pena mencionar otra caracter√≠stica de su implementaci√≥n.  La secci√≥n cr√≠tica en .NET opera en dos modos: modo spin-wait y modo kernel.  El algoritmo spin-wait se representa convenientemente como el siguiente pseudoc√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br>  Esta optimizaci√≥n est√° dirigida a la captura m√°s r√°pida de la secci√≥n cr√≠tica en poco tiempo, sobre la base de la suposici√≥n de que si el recurso est√° ocupado ahora, est√° a punto de liberarse ahora.  Si esto no sucede en un corto per√≠odo de tiempo, el subproceso va a esperar en modo kernel, lo que, como volver de √©l, lleva tiempo.  Los desarrolladores de .NET han optimizado el escenario de bloqueo corto tanto como sea posible, desafortunadamente, si muchos hilos comienzan a romper la secci√≥n cr√≠tica, esto puede conducir a una carga de CPU alta y repentina. <br><a name="SpinLock"></a><br><h3>  SpinLock, SpinWait </h3><br>  Como mencion√© el algoritmo spin-wait, vale la pena mencionar las estructuras BCL SpinLock y SpinWait.  Deben usarse si hay razones para creer que siempre habr√° una oportunidad de bloquear r√°pidamente.  Por otro lado, apenas vale la pena recordarlos antes de que los resultados de la creaci√≥n de perfiles muestren que el uso de otras primitivas de sincronizaci√≥n es el cuello de botella de su programa. <br><a name="Pulse"></a><br><h3>  Monitor.Wait, Monitor.Pulse [Todos] </h3><br>  Este par de m√©todos se deben considerar juntos.  Con su ayuda, se pueden implementar varios escenarios Productor-Consumidor. <br><br>  <i>Productor-Consumidor: un patr√≥n de dise√±o multiproceso / multiproceso que supone la presencia de uno o m√°s subprocesos / procesos que producen datos y uno o m√°s procesos / subprocesos que procesan estos datos.</i>  <i>Usualmente usa una colecci√≥n compartida.</i> <br><br>  Ambos m√©todos solo se pueden invocar si el hilo que los est√° causando tiene un bloqueo en este momento.  El m√©todo de espera libera el bloqueo y se cuelga hasta que otro hilo llama a Pulse. <br><br>  Para demostrar el trabajo, escrib√≠ un peque√±o ejemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>(Us√© la imagen, no el texto, para mostrar visualmente el orden de ejecuci√≥n de las instrucciones)</i> <br><br>  <u>Parse: establezca</u> un retraso de 100 ms al comienzo de la segunda transmisi√≥n, espec√≠ficamente para garantizar que su ejecuci√≥n comience m√°s tarde. <br>  - T1: comienza la transmisi√≥n de la l√≠nea n. ¬∞ 2 <br>  - T1: la l√≠nea # 3 ingresa a la secci√≥n cr√≠tica <br>  - T1: L√≠nea # 6 la corriente se queda dormida <br>  - T2: comienza la transmisi√≥n de la l√≠nea n. ¬∞ 3 <br>  - T2: la l√≠nea 4 se congela mientras espera una secci√≥n cr√≠tica <br>  - T1: la l√≠nea # 7 libera la secci√≥n cr√≠tica y se congela mientras espera que Pulse salga <br>  - T2: la l√≠nea # 8 ingresa a la secci√≥n cr√≠tica <br>  - T2: la l√≠nea # 11 notifica a T1 utilizando el m√©todo Pulse <br>  - T2: la l√≠nea # 14 sale de la secci√≥n cr√≠tica.  Hasta entonces, T1 no puede continuar la ejecuci√≥n. <br>  - T1: la l√≠nea # 15 se despierta <br>  - T1: la l√≠nea # 16 deja la secci√≥n cr√≠tica <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MSDN</a> tiene una observaci√≥n importante con respecto al uso de los m√©todos Pulse / Wait, a saber: El monitor no almacena informaci√≥n de estado, lo que significa que si se llama al m√©todo Pulse antes de que se llame al m√©todo Wait, puede llegar a un punto muerto.</i>  <i>Si esta situaci√≥n es posible, entonces es mejor usar una de las clases de la familia ResetEvent.</i> <br><br>  El ejemplo anterior demuestra claramente c√≥mo funcionan los m√©todos Wait / Pulse de la clase Monitor, pero a√∫n deja dudas sobre cu√°ndo se debe usar.  Un buen ejemplo ser√≠a una implementaci√≥n de BlockingQueue &lt;T&gt;, por otro lado, la implementaci√≥n de BlockingCollection &lt;T&gt; de System.Collections.Concurrent usa SemaphoreSlim para la sincronizaci√≥n. <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br>  Esta es mi primitiva de sincronizaci√≥n amada, representada por la clase de espacio de nombres System.Threading del mismo nombre.  Me parece que muchos programas funcionar√≠an mejor si sus desarrolladores usaran esta clase en lugar del bloqueo habitual. <br><br>  <i>Idea: muchos hilos pueden leer, solo uno escribe.</i>  <i>Tan pronto como la transmisi√≥n declara su deseo de escribir, no se pueden iniciar nuevas lecturas, pero esperar√°n a que se complete la grabaci√≥n.</i>  <i>Tambi√©n existe el concepto de bloqueo de lectura actualizable, que se puede utilizar si comprende durante el proceso de lectura que necesita escribir algo, dicho bloqueo se convertir√° en bloqueo de escritura en una operaci√≥n at√≥mica.</i> <br><br>  <i>Tambi√©n hay una clase ReadWriteLock en el espacio de nombres System.Threading, pero es muy recomendable para nuevos desarrollos.</i>  <i>La versi√≥n delgada permitir√° evitar una serie de casos que conducen a puntos muertos, adem√°s de que le permite capturar r√°pidamente el bloqueo, porque</i>  <i>admite sincronizaci√≥n en modo de espera de giro antes de salir para el modo kernel.</i> <br><br>  Si en el momento de leer este art√≠culo a√∫n no conoc√≠a esta clase, creo que ha recordado muchos ejemplos del c√≥digo escrito recientemente, donde tal enfoque de bloqueo permitir√≠a que el programa funcione de manera eficiente. <br><br>  La interfaz de la clase ReaderWriterLockSlim es simple y directa, pero su uso dif√≠cilmente puede llamarse conveniente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br>  Me gusta envolver su uso en una clase, lo que hace que usarlo sea mucho m√°s conveniente. <br>  Idea: para hacer m√©todos de lectura / escritura de bloqueo que devuelven un objeto con el m√©todo de eliminaci√≥n, esto permitir√° que se usen en el uso y por el n√∫mero de l√≠neas dif√≠cilmente diferir√° del bloqueo habitual. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br>  Tal truco te permite simplemente escribir m√°s: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  ResetEvent Family </h3><br>  Incluyo las clases ManualResetEvent, ManualResetEventSlim, AutoResetEvent para esta familia. <br>  Las clases ManualResetEvent, su versi√≥n Slim y la clase AutoResetEvent pueden estar en dos estados: <br>  - Sin se√±alizar, en este estado, todos los hilos que llamaron a WaitOne se cuelgan hasta que el evento pase al estado se√±alado. <br>  - El estado bajado (indicado), en este estado se liberan todos los flujos que cuelgan de la llamada WaitOne.  Todas las nuevas llamadas WaitOne en un evento en desuso pasan condicionalmente al instante. <br><br>  La clase AutoResetEvent difiere de la clase ManualResetEvent en que ingresa autom√°ticamente en un estado activado despu√©s de liberar exactamente un subproceso.  Si varios subprocesos se cuelgan esperando AutoResetEvent, entonces la llamada Set liberar√° solo un arbitrario, a diferencia de ManualResetEvent.  ManualResetEvent lanzar√° todos los hilos. <br><br>  Veamos un ejemplo de c√≥mo funciona AutoResetEvent: <br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br><br>  El ejemplo muestra que el evento entra en un estado de armado (sin se√±alizaci√≥n) autom√°ticamente solo al soltar el hilo que cuelga en la llamada WaitOne. <br><br>  La clase ManualResetEvent, a diferencia de ReaderWriterLock, no est√° marcada como obsoleta y no se recomienda su uso despu√©s de la aparici√≥n de su versi√≥n Slim.  La versi√≥n delgada de esta clase se usa eficientemente para expectativas cortas, ya que  Sucede en el modo Spin-Wait, la versi√≥n normal es adecuada para los largos. <br><br>  Adem√°s de las clases ManualResetEvent y AutoResetEvent, tambi√©n existe la clase CountdownEvent.  Esta clase es conveniente para la implementaci√≥n de algoritmos, donde la parte que logr√≥ ser paralela es seguida por la parte de reunir los resultados.  Este enfoque se conoce como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fork-join</a> .  Un excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo est√°</a> dedicado al trabajo de esta clase, por lo tanto, no lo analizar√© en detalle aqu√≠. <br><a name="Conclusions"></a><br><h2>  Conclusiones </h2><br><ul><li>  Cuando se trabaja con subprocesos, dos problemas que resultan en resultados incorrectos o faltantes son condici√≥n de carrera y punto muerto </li><li>  Los problemas que hacen que el programa gaste m√°s tiempo o recursos: hambruna de hilos y espera ocupada </li><li>  .NET es rico en sincronizaci√≥n de hilos </li><li>  Hay 2 modos de espera de bloqueo: Spin Wait, Core Wait.  Algunas primitivas de sincronizaci√≥n de hilos .NET usan ambos </li><li>  Interlocked es un conjunto de operaciones at√≥micas, utilizado en algoritmos sin bloqueo, es la primitiva de sincronizaci√≥n m√°s r√°pida </li><li>  El operador de bloqueo y Monitor.Enter / Exit implementan la idea de una secci√≥n cr√≠tica: un c√≥digo que solo puede ejecutarse por un hilo a la vez </li><li>  Los m√©todos Monitor.Pulse / Wait son convenientes para implementar scripts Productor-Consumidor </li><li>  ReaderWriterLockSlim puede ser m√°s eficiente que el bloqueo regular en scripts donde la lectura paralela es aceptable </li><li>  La familia de clases ResetEvent puede ser √∫til para la sincronizaci√≥n de subprocesos. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459514/">https://habr.com/ru/post/459514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459500/index.html">HTML es la web</a></li>
<li><a href="../459502/index.html">Continuamos desarrollando una plataforma de aventura para los rusos: caracter√≠sticas de interfaz y preferencias de verano.</a></li>
<li><a href="../459504/index.html">Curso para j√≥venes dise√±adores de juegos: c√≥mo contar el equilibrio de personajes y equipos sin matem√°ticas</a></li>
<li><a href="../459506/index.html">Las aventuras de los esquivos Malvari, Parte III: Intrincados guiones de VBA para la risa y el beneficio</a></li>
<li><a href="../459508/index.html">5 diapositivas que los presentadores experimentados ignoran</a></li>
<li><a href="../459518/index.html">Explicaci√≥n de la tarea de Python con entrevistas de trabajo.</a></li>
<li><a href="../459520/index.html">Un modelo de una serie natural de n√∫meros y sus elementos. Rombos</a></li>
<li><a href="../459528/index.html">¬øC√≥mo ense√±amos la ecolog√≠a francesa y recogemos botellas?</a></li>
<li><a href="../459530/index.html">Microbiota Historia de los m√©todos de estudio e investigaci√≥n.</a></li>
<li><a href="../459532/index.html">C√≥mo elegir un n√∫mero aleatorio del 1 al 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>