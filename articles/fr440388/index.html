<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåØ üíÄ ü§± Intervalles: la prochaine √©volution C ++ üçê üö¥üèª üë®üèª‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La norme C ++ 20 appara√Ætra bient√¥t, dans laquelle, tr√®s probablement, le concept de gammes sera ajout√©, mais peu de gens savent ce qu'ils sont et ce ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intervalles: la prochaine √©volution C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440388/"> La norme C ++ 20 appara√Ætra bient√¥t, dans laquelle, tr√®s probablement, le concept de <i>gammes</i> sera ajout√©, mais peu de gens savent ce qu'ils sont et ce avec quoi ils mangent.  Je ne pouvais pas trouver accessible √† un large public de sources en langue russe sur cette b√™te, donc dans cet article, je voudrais en parler davantage, bas√© sur une conf√©rence d'Arno Sch√∂dl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"From Iterators to Ranges: The Upcoming Evolution Of the STL"</a> de Meeting C ++ 2015- de l'ann√©e.  J'essaierai de rendre cet article aussi clair que possible pour ceux qui rencontrent ce concept pour la premi√®re fois, et en m√™me temps, je parlerai de toutes sortes de puces comme des adaptateurs d'intervalle pour ceux qui connaissent d√©j√† ce concept et veulent en savoir plus. <br><br><h2>  Biblioth√®ques avec plages </h2><br>  Au moment d'√©crire ces lignes, il existe trois biblioth√®ques principales qui impl√©mentent des intervalles: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boost.range</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gamme v3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">biblioth√®que publique think-cell</a> </li></ul><br>  La premi√®re biblioth√®que, en fait, est l'anc√™tre de ce concept (ce qui n'est pas surprenant, car il n'y a rien dans la collection de biblioth√®ques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boost</a> :)).  La seconde est la biblioth√®que d'Eric Niebler, qui sera d√©crite plus loin.  Et enfin, la derni√®re biblioth√®que, comme vous pouvez le deviner, a √©t√© √©crite par think-cell, qui, pourrait-on dire, a d√©velopp√© et am√©lior√© Boost.Range. <br><a name="habracut"></a><br><h2>  Pourquoi les intervalles sont notre avenir? </h2><br>  Pour ceux qui ne connaissent pas le concept d'intervalle, nous d√©finissons ce concept non trivial comme celui qui a un d√©but et une fin (une <u>paire d'it√©rateurs</u> ). <br><br>  Consid√©rons maintenant la t√¢che suivante: il y a un vecteur, il faut en supprimer tous les √©l√©ments r√©p√©titifs.  Selon la norme actuelle, nous le r√©soudrions comme ceci: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; vec=...; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort( vec.begin(), vec.end() ); vec.erase( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique( vec.begin(), vec.end() ), vec.end() );</code> </pre> <br>  Dans ce cas, nous indiquons le nom du vecteur jusqu'√† <b>6</b> fois!  Cependant, en utilisant le concept d'intervalles (combinant des it√©rateurs au d√©but et √† la fin du vecteur en un seul objet), vous pouvez √©crire plusieurs fois plus facilement en sp√©cifiant le vecteur souhait√© <b>une</b> seule <b>fois</b> : <br><br><pre> <code class="cpp hljs">tc::unique_inplace( tc::sort(vec) );</code> </pre> <br><h2>  Lesquels des intervalles sont actuellement dans la norme actuelle? </h2><br>  Dans la norme C ++ 11, une boucle bas√©e sur une plage et un acc√®s universel au d√©but / √† la fin des conteneurs ont √©t√© ajout√©s, et dans la derni√®re norme C ++ 17, rien de nouveau li√© aux intervalles n'a √©t√© ajout√©. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; i : &lt;range_expression&gt; ) { ... }</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin/end(&lt;range_expression&gt;)</code> </pre> <br><h2>  Intervalles futurs </h2><br>  Arr√™tons-nous maintenant sur la biblioth√®que Range V3 mentionn√©e pr√©c√©demment.  Eric Nibler, son cr√©ateur, comme son projet de maison a cr√©√© les <i>sp√©cifications techniques de</i> la <i>gamme</i> , modifiant la biblioth√®que d' <i>algorithmes</i> pour prendre en charge les intervalles.  Cela ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> ranges { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> What &gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) find( Rng &amp;&amp; rng, What <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; what ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find( ranges::begin(rng), ranges::end(rng), what ); } }</code> </pre> <br>  Sur son site, il y a un aper√ßu de ce qu'il veut standardiser, c'est la <i>gamme V3</i> . <br><br><h2>  Que peut-on envisager? </h2><br>  Tout d'abord, les <i>conteneurs</i> (vecteur, cha√Æne, liste, etc.), car ils ont un d√©but et une fin.  Il est clair que les conteneurs ont leurs propres √©l√©ments, c'est-√†-dire que lorsque nous parlons de conteneurs, nous faisons r√©f√©rence √† tous leurs √©l√©ments.  De m√™me, lors de la copie et de la d√©claration d'une constante (copie profonde et coh√©rence).  Deuxi√®mement, les <i>vues</i> peuvent √©galement √™tre consid√©r√©es comme des intervalles.  Les vues ne sont qu'une paire d'it√©rateurs pointant respectivement vers le d√©but et la fin.  Voici leur mise en ≈ìuvre la plus simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_range</span></span></span><span class="hljs-class"> {</span></span> It m_itBegin; It m_itEnd; <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itBegin; } <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itEnd; } };</code> </pre> <br>  Les vues, √† leur tour, ne se r√©f√®rent qu'aux √©l√©ments, donc la copie et la coh√©rence sont paresseuses (cela n'affecte pas les √©l√©ments). <br><br><h2>  Adaptateurs d'intervalle </h2><br>  Les inventeurs d'intervalles ne se sont pas arr√™t√©s l√†, car sinon ce concept serait plut√¥t inutile.  Par cons√©quent, ils ont introduit un tel concept d'adaptateurs de gamme. <br><br><h3>  Transformer l'adaptateur </h3><br>  Consid√©rez la t√¢che suivante: laissez un vecteur <i>int</i> donn√©, dans lequel nous devons trouver le premier √©l√©ment √©gal √† 4: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find(v, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Imaginons maintenant que le type du vecteur ne soit pas int, mais une sorte de structure complexe auto-√©crite, mais dans laquelle il y a un int, et la t√¢che est toujours la m√™me: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find_if( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.id == <span class="hljs-number"><span class="hljs-number">4</span></span>; } );</code> </pre> <br>  Il est clair que ces deux codes sont similaires en s√©mantique, cependant, ils diff√®rent consid√©rablement dans la syntaxe, car dans ce dernier cas, nous avons d√ª √©crire manuellement une fonction qui traverse le champ <i>int</i> .  Mais si vous utilisez un adaptateur de transformation (adaptateur de <i>transformation</i> ), tout semble beaucoup plus succinct: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  En fait, l'adaptateur de transformation ¬´transforme¬ª notre structure en cr√©ant une classe wrapper autour du champ int.  Il est clair que le pointeur pointe vers le champ <i>id</i> , mais si nous voulions qu'il pointe vers la structure enti√®re, nous devons l'ajouter √† la fin de <i>.base ()</i> .  Cette commande encapsule le champ, gr√¢ce auquel le pointeur peut parcourir toute la structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>).base();</code> </pre><br>  Voici un exemple d'impl√©mentation d'un adaptateur de transformation (il se compose d'it√©rateurs, chacun ayant son propre foncteur): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">transform_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">//    decltype( tc::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; public: decltype(auto) operator*() const { return m_func(*m_it); } decltype(auto) base() const { return (m_it); } ... }; };</span></span></code> </pre><br><h3>  Adaptateur de filtre </h3><br>  Et si, dans la derni√®re t√¢che, nous devions trouver non pas le premier √©l√©ment de ce type, mais ¬´filtrer¬ª le champ <b>entier</b> de <i>int</i> pour la pr√©sence de tels √©l√©ments?  Dans ce cas, nous utiliserions un adaptateur de filtre: <br><br><pre> <code class="cpp hljs">tc::filter( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> == a.id; } );</code> </pre><br>  Notez que le filtre est ex√©cut√© paresseusement pendant les it√©rations. <br><br>  Et voici son impl√©mentation na√Øve (quelque chose comme √ßa est impl√©ment√© dans Boost.Range): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">//     decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_itEnd; public: iterator&amp; operator++() { ++m_it; while( m_it != m_itEnd &amp;&amp; !static_cast&lt;bool&gt;(m_func(*m_it)) ) ++m_it; return *this; } ... }; };</span></span></code> </pre><br>  Comme nous pouvons le voir, deux it√©rateurs sont n√©cessaires ici au lieu d'un, comme c'√©tait le cas dans l'adaptateur de transformation.  Le deuxi√®me it√©rateur est n√©cessaire afin de ne pas d√©passer accidentellement les limites du conteneur lors des it√©rations. <br><br><h2>  Quelques optimisations </h2><br>  Ok, mais √† quoi ressemble l'it√©rateur de <b>tc :: filter (tc :: filter (tc :: filter (...)))</b> ? <br><br><h3>  Boost.range </h3><br>  Dans le cadre de l'impl√©mentation ci-dessus, cela ressemble √† ceci: <br><br><div class="spoiler">  <b class="spoiler_title">Les faibles de c≈ìur ne regardent pas!</b> <div class="spoiler_text"> <code>m_func3 <br> m_it3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br></code> <br></div></div><br>  De toute √©vidence, c'est <u>terriblement</u> inefficace. <br><br><h3>  Gamme v3 </h3><br>  Voyons comment optimiser cet adaptateur.  L'id√©e d'Eric Nibler √©tait de mettre des informations g√©n√©rales (un foncteur et un pointeur √† la fin) dans l'objet adaptateur, puis nous pouvons stocker un lien vers cet objet adaptateur et l'it√©rateur souhait√© <br> <code>*m_rng <br> m_it <br></code> <br>  Ensuite, dans le cadre d'une telle impl√©mentation, un triple filtre ressemblera √† ceci: <br><br><div class="spoiler">  <b class="spoiler_title">Tyk</b> <div class="spoiler_text"> <code>m_rng3 <br> m_it3 <br> m_rng2 <br> m_it2 <br> m_rng1 <br> m_it1 <br></code> <br></div></div><br>  Ce n'est toujours pas parfait, bien que parfois plus rapide que la mise en ≈ìuvre pr√©c√©dente. <br><br><h3>  think-cell, concept d'index </h3><br>  Consid√©rons maintenant la solution think-cell.  Ils ont introduit le soi-disant <i>concept d'index</i> pour r√©soudre ce probl√®me.  Un index est un tel it√©rateur qui effectue toutes les m√™mes op√©rations qu'un it√©rateur r√©gulier, mais il le fait en se r√©f√©rant aux intervalles. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">index_range</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = ...; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrement_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">reference </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dereference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ... };</code> </pre><br>  Nous montrons comment combiner un index avec un it√©rateur r√©gulier. <br><br>  Il est clair qu'un it√©rateur r√©gulier peut √©galement √™tre consid√©r√© comme un index.  Dans le sens inverse, la compatibilit√© peut √™tre impl√©ment√©e, par exemple, comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; iterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { m_rng.increment_index(m_idx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } ... };</code> </pre><br>  Ensuite, le triple filtre sera mis en ≈ìuvre de mani√®re tr√®s efficace: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> Func m_func; Base&amp; m_base; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::Index; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { m_base.increment_index(idx); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( idx != m_base.end_index() &amp;&amp; !m_func(m_base.dereference_index(idx)) ); } };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; ... };</code> </pre><br>  Dans le cadre d'une telle impl√©mentation, l'algorithme fonctionnera rapidement quelle que soit la profondeur du filtre. <br><br><h2>  Intervalles avec les conteneurs lvalue et rvalue </h2><br>  Voyons maintenant comment les intervalles fonctionnent avec les conteneurs lvalue et rvalue: <br><br><h3>  lvalue </h3><br>  La plage V3 et think-cell se comportent de la m√™me mani√®re avec lvalue.  Supposons que nous ayons un code comme celui-ci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(vec, pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br>  Ici, nous avons un vecteur pr√©c√©demment d√©clar√© qui se trouve dans la m√©moire (lvalue), et nous devons cr√©er un intervalle, puis travailler en quelque sorte avec lui.  Nous cr√©ons une vue en utilisant <i>view :: filter</i> ou <i>tc :: filter</i> et devenons heureux, il n'y a pas d'erreur, et nous pouvons ensuite utiliser cette vue, par exemple, dans any_of. <br><br><h3>  Gamme V3 et rvalue </h3><br>  Cependant, si notre vecteur n'√©tait pas encore en m√©moire (par exemple, si nous venions de le cr√©er), et nous aurions fait face √† la m√™me t√¢che, alors nous aurions essay√© d'√©crire et face √† une erreur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">//   bool b = ranges::any_of(rng, pred2);</span></span></code> </pre><br>  Pourquoi est-elle apparue?  La vue sera un lien suspendu vers rvalue car nous cr√©ons un vecteur et le mettons directement dans un filtre, c'est-√†-dire qu'il y aura un lien rvalue dans le filtre, qui pointera alors vers quelque chose d'inconnu lorsque le compilateur passe √† la ligne suivante et qu'une erreur se produit.  Afin de r√©soudre ce probl√®me, la gamme V3 a propos√© une <i>action</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = action::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">//   bool b = ranges::any_of(rng, pred2);</span></span></code> </pre> <br>  L'action fait tout √† la fois, c'est-√†-dire qu'elle prend simplement un vecteur, filtre par pr√©dicat et le place dans un intervalle.  Cependant, l'inconv√©nient est qu'il n'est plus paresseux, et think-cell a essay√© de corriger ce inconv√©nient. <br><br><h3>  think-cell et rvalue </h3><br>  Think-cell a fait en sorte qu'au lieu de visualiser un conteneur soit cr√©√©: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = tc::filter(creates_vector(), pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br>  Par cons√©quent, nous ne rencontrons pas une erreur similaire, car dans leur impl√©mentation, le filtre collecte le conteneur rvalue au lieu du lien, cela se produit donc paresseusement.  Dans la gamme V3, ils ne voulaient pas faire cela, car ils craignaient qu'il y ait des erreurs en raison du comportement du filtre en tant que vue ou en tant que conteneur, mais think-cell est convaincu que les programmeurs comprennent comment le filtre se comporte, et la plupart des erreurs surviennent pr√©cis√©ment √† cause de cette "paresse". <br><br><h2>  Intervalles du g√©n√©rateur </h2><br>  Nous g√©n√©ralisons le concept d'intervalles.  En fait, il existe des intervalles sans it√©rateurs.  Ils sont appel√©s <i>gammes de g√©n√©rateurs</i> .  Supposons que nous ayons un widget GUI (un √©l√©ment d'interface) et que nous appelions un widget move.  Nous avons une fen√™tre qui demande de d√©placer son widget, nous avons √©galement un bouton dans la zone de <i>liste</i> , et une autre fen√™tre devrait √©galement faire d√©filer ses widgets, c'est-√†-dire que nous appelons <i>traverse_widgets</i> , qui relie les √©l√©ments √† un foncteur ( <i>vous pouvez dire qu'il y a une fonction d'√©num√©ration o√π vous connectez le foncteur, et la fonction liste tous les √©l√©ments qu'elle a dans ce foncteur</i> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse_widgets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Func func )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window1) { window1-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } func(button1); func(listbox1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window2) { window2-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } }</code> </pre><br>  Cela rappelle un peu l'espacement des widgets, mais il n'y a pas d'it√©rateurs ici.  Les √©crire directement serait inefficace et surtout tr√®s difficile.  Dans ce cas, nous pouvons dire que de telles structures sont √©galement consid√©r√©es comme des intervalles.  Ensuite, dans de tels cas, il existe une utilisation de m√©thodes d'intervalle utiles, telles que <i>any_of</i> : <br><br><pre> <code class="cpp hljs">mouse_hit_any_widget=tc::any_of( [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func) { traverse_widgets(func); }, [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; widget) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.mouse_hit(); } );</code> </pre><br>  think-cell essaie d'impl√©menter des m√©thodes pour qu'elles aient la m√™me interface pour toutes sortes d'intervalles: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tc { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Rng </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bResult = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; tc::enumerate( rng, [&amp;](bool_context b) { bResult = bResult || b; } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bResult; } }</code> </pre><br>  En utilisant <i>tc :: enumerate</i> , la diff√©rence entre les intervalles est cach√©e, car une telle impl√©mentation adh√®re au concept d' <i>it√©ration interne</i> (ce que les concepts d' <i>it√©ration</i> <i>externe</i> et <i>interne</i> sont d√©crits plus en d√©tail dans la le√ßon), cependant, cette impl√©mentation a ses inconv√©nients, √† savoir, <i>std :: any_of</i> s'arr√™te d√®s que <i>true</i> est rencontr√©.  Ils essaient de r√©soudre ce probl√®me, par exemple, en ajoutant des exceptions (les <i>intervalles de g√©n√©rateur</i> dits <i>interrompus</i> ). <br><br><h2>  Conclusion </h2><br>  Je d√©teste la boucle for bas√©e sur la plage, car elle motive les gens √† l'√©crire l√† o√π ils sont n√©cessaires et l√† o√π ils ne sont pas n√©cessaires, car la concision du code empire souvent, par exemple, les gens √©crivent ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n : rng) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( is_prime(n) ) { b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  √† la place: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = tc::any_of( rng, is_prime );</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440388/">https://habr.com/ru/post/fr440388/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440372/index.html">Mon compilateur Pascal et l'art contemporain polonais</a></li>
<li><a href="../fr440374/index.html">Les fonctions Yandex envoient du courrier</a></li>
<li><a href="../fr440378/index.html">Retour aux microservices avec Istio. 2e partie</a></li>
<li><a href="../fr440382/index.html">200 est-il bon ou mauvais?</a></li>
<li><a href="../fr440386/index.html">Lib√©rer la gestion des erreurs en √©liminant les erreurs</a></li>
<li><a href="../fr440390/index.html">Le monde diversifi√© des syst√®mes embarqu√©s et la place d'Embox dans celui-ci</a></li>
<li><a href="../fr440392/index.html">WebRTC sur votre site - pas de bugs et pas de budget</a></li>
<li><a href="../fr440394/index.html">PostgreSQL el√©vation de privil√®ges - CVE-2018-10915 parsing</a></li>
<li><a href="../fr440398/index.html">Historique de la participation (et de la victoire) √† la Russian AI Cup 2018 - CodeBall</a></li>
<li><a href="../fr440400/index.html">Apache Kafka + Spring Boot: Bonjour, microservices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>