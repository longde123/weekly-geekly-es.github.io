<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↩️ 😣 🙌🏻 Le livre "C ++. La pratique de la programmation multithread " 🚷 🧚🏿 👲🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, habrozhiteli! Le langage C ++ est choisi lorsque vous devez créer des applications vraiment rapides comme l'éclair. Et un traitement compétitif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre "C ++. La pratique de la programmation multithread "</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/484818/"> <a href="https://habr.com/ru/company/piter/blog/484818/"><img src="https://habrastorage.org/webt/cr/ym/3u/crym3urkeecjcfe-nsvq0nrw59y.jpeg" align="left" alt="image"></a>  Salut, habrozhiteli!  Le langage C ++ est choisi lorsque vous devez créer des applications vraiment rapides comme l'éclair.  Et un traitement compétitif de haute qualité les rendra encore plus rapides.  Les nouvelles fonctionnalités de C ++ 17 vous permettent d'utiliser toute la puissance de la programmation multithread pour résoudre facilement les problèmes de traitement graphique, d'apprentissage automatique, etc. Anthony Williams, un expert en traitement compétitif, examine des exemples et décrit des tâches pratiques, et partage des secrets qui seront utiles à tous dans y compris les développeurs les plus expérimentés. <br><br>  Dans le livre • Un aperçu complet des fonctionnalités de C ++ 17.  • Lancement et contrôle de flux.  • Synchronisation des opérations concurrentielles.  • Développement d'un code compétitif.  • Débogage d'applications multithread.  Le livre convient aux développeurs de niveau intermédiaire utilisant C et C ++.  Une expérience en programmation compétitive n'est pas requise. <br><a name="habracut"></a><br><h3>  Développement de code compétitif </h3><br><h3>  8.1.  Façons de répartir le travail entre les threads </h3><br>  Imaginez que vous ayez besoin de construire une maison.  Pour ce faire, vous devrez creuser une fosse de fondation, remplir la fondation elle-même, ériger des murs, poser des tuyaux et du câblage électrique, etc. Théoriquement, avec des compétences suffisantes, tout peut être fait indépendamment, mais cela prendra probablement beaucoup de temps et vous devrez passer d'un travail à un autre.  Mais vous pouvez embaucher des assistants.  Ensuite, il faudra choisir le nombre d'assistants à embaucher et décider de ce qu'ils devraient être en mesure de faire.  Vous pouvez, par exemple, embaucher deux ouvriers et travailler avec eux.  Ensuite, vous devez toujours passer d'une œuvre à une autre, mais maintenant les choses iront plus vite, car il y aura plus d'artistes. <br><br>  Vous pouvez choisir une autre option - embaucher une équipe de spécialistes, comme un maçon, un charpentier, un électricien et un plombier.  Chacun travaillera dans sa propre spécialité, par conséquent, jusqu'à ce que le plombier ait un front de travail, il restera inactif.  Et pourtant, les choses iront plus vite qu'avant, car il y a plus de travailleurs, et tandis que l'électricien effectuera le câblage dans la cuisine, le plombier peut aller aux toilettes.  Mais lorsqu'il n'y a pas de travail pour un spécialiste spécifique, plus de temps d'arrêt sont obtenus.  Cependant, on peut noter que même avec les temps d'arrêt pris en compte, le travail se déplace plus rapidement lorsque des spécialistes viennent au travail, plutôt qu'une équipe de travailleurs.  Les spécialistes n'ont pas besoin de changer constamment d'outils et chacun d'entre eux accomplira sa tâche plus rapidement que l'ouvrier.  Que ce soit effectivement le cas, cela dépend des circonstances spécifiques: tout est appris dans la pratique. <br><br>  Même si vous impliquez des spécialistes, vous devez toujours choisir un nombre différent de travailleurs de différentes spécialités.  Il est peut-être judicieux d'embaucher, par exemple, plus de maçons que d'électriciens.  De plus, la composition de votre équipe et l'efficacité globale de son travail peuvent changer si vous devez construire plusieurs maisons à la fois.  Même s'il y a peu de travail pour un plombier dans une seule maison, alors lors de la construction de plusieurs maisons à la fois, il peut être pris pour toute la journée.  De plus, si vous n'avez pas à payer de spécialistes pour les temps d'arrêt, vous pouvez recruter une équipe plus importante, même si le nombre de personnes travaillant simultanément ne change pas. <br><br>  Mais arrêtez de parler de la construction.  Qu'est-ce que tout cela a à voir avec les threads?  Et vous pouvez leur appliquer des considérations similaires.  Vous devez décider du nombre de threads à utiliser et des tâches à effectuer.  Avons-nous besoin de fils universels qui effectuent le travail nécessaire à un moment particulier, ou de fils spécialisés bien adaptés à une seule chose?  Ou peut-être vaut-il la peine de combiner les deux?  Ces décisions doivent être prises quelles que soient les raisons de la parallélisation du programme, et les performances et la clarté du code dépendent considérablement de leur succès.  Par conséquent, il est si important d'imaginer quelles options sont disponibles afin de prendre une décision compétente lors du développement de la structure de l'application.  Dans cette section, nous considérerons un certain nombre de méthodes de distribution des tâches, en commençant par la distribution des données entre les threads jusqu'à ce que tout autre travail soit effectué. <br><br><h3>  8.1.1.  Répartition des données entre les threads avant traitement </h3><br>  Les plus faciles à paralléliser sont des algorithmes simples, tels que std :: for_each, qui effectuent des opérations sur chaque élément d'un ensemble de données.  Pour paralléliser cet algorithme, vous pouvez affecter chaque élément à l'un des threads de traitement.  À l'avenir, lors de l'examen des problèmes de performances, il deviendra clair que la meilleure option de distribution pour obtenir des performances optimales dépend des caractéristiques de la structure des données. <br><br>  Lors de la distribution de données, le cas le plus simple est celui où les N premiers éléments sont affectés à un flux, les N éléments suivants à un autre, et ainsi de suite (Fig. 8.1), mais d'autres schémas peuvent être utilisés.  Quelle que soit la méthode de distribution des données, chaque thread ne traite que les éléments qui lui sont attribués, sans interagir avec les autres threads jusqu'à la fin du traitement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ie/ex/rm/ieexrmf49u6qerfqmuhtcgpbgpe.png" alt="image"></div><br>  La structure doit être familière à toute personne ayant <a href="http://www.mpi-forum.org/">travaillé</a> avec la programmation dans les environnements Message Passing Interface (MPI, <a href="http://www.mpi-forum.org/">www.mpi-forum.org</a> ) ou OpenMP (http://www.openmp.org/): la tâche est divisée en plusieurs tâches exécutées en parallèle, les workflows les exécutent indépendamment les uns des autres et les résultats sont collectés au stade final de l'information.  Cette approche a été utilisée dans l'exemple avec la fonction d'accumulation de la section 2.4: les tâches parallèles et l'étape de réduction sont une accumulation.  Pour un algorithme for_each simple, l'étape finale est manquante, car il n'y a rien à réduire. <br><br>  Le fait qu'un mix soit défini comme l'essence de l'étape finale joue un rôle très important: une implémentation élémentaire similaire à celle montrée dans l'extrait 2.9 effectuera ce mix comme une étape séquentielle finale.  Mais souvent, cette étape est également parallélisée: l'accumulation est une opération de réduction, de sorte que le code du Listing 2.9 peut être modifié pour obtenir un appel récursif du même code lorsque, par exemple, le nombre de threads est supérieur au nombre minimal d'éléments traités par le thread.  Vous pouvez également forcer les workflows à effectuer des étapes de cumul dès que chacun d'eux a terminé sa tâche, plutôt que de démarrer de nouveaux threads à chaque fois. <br><br>  Malgré toute son efficacité, cette technique n'est pas polyvalente.  Parfois, les données ne peuvent pas être divisées à l'avance avec précision, car la composition de chaque pièce n'est connue qu'au cours du traitement.  En particulier, cela est évident lorsque vous utilisez des algorithmes récursifs tels que Quicksort, ils nécessitent donc une approche différente. <br><br><h3>  8.1.2.  Distribution de données récursive </h3><br>  L'algorithme Quicksort comporte deux étapes principales: la division des données en deux parties - tout ce qui revient à l'un des éléments (référence), et tout ce qui se trouve après dans l'ordre de tri final, et le tri récursif de ces deux moitiés.  Il est impossible de le paralléliser en divisant au préalable les données, car il est possible de déterminer dans quelle «moitié» elles tombent uniquement lors du traitement des éléments.  Si vous avez l'intention de paralléliser cet algorithme, vous devez utiliser l'essence même de la récursivité.  À chaque niveau de récursivité, de plus en plus d'appels à la fonction quick_sort sont effectués, car vous devez trier ceux qui sont plus grands que la référence et ceux qui sont plus petits que lui.  Ces appels récursifs sont indépendants les uns des autres car ils font référence à des ensembles d'éléments distincts.  De ce fait, ils sont les premiers candidats à la compétitivité.  Cette distribution récursive est représentée sur la Fig.  8.2. <br><br>  Cette implémentation a déjà été rencontrée au chapitre 4. Au lieu de faire deux appels récursifs pour les moitiés plus grandes et plus petites, nous avons utilisé la fonction std :: async (), qui exécute des tâches asynchrones pour la moitié la plus petite à chaque étape.  En raison de l'utilisation de std :: async (), la bibliothèque de threads C ++ a dû décider quand démarrer la tâche dans un nouveau thread et quand - en mode synchrone. <br><br>  Il existe une circonstance importante: lors du tri d'un grand ensemble de données, le démarrage d'un nouveau thread pour chaque récursivité entraînera une augmentation rapide du nombre de threads.  Lors de l'examen des problèmes de performances, il sera démontré qu'un trop grand nombre de threads peuvent ralentir l'application.  En outre, avec un grand nombre de flux de données, cela peut tout simplement ne pas suffire.  L'idée même de diviser la tâche entière dans un tel mode récursif semble très réussie, il vous suffit de surveiller attentivement le nombre de threads.  Dans les cas simples, la fonction std :: async () gère cela, mais il existe d'autres options. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rz/ji/l3/rzjil3fye0-nfj2quxo75cvxon4.png" alt="image"></div><br>  L'un d'eux consiste à utiliser la fonction std :: thread :: hardware_concurrency () pour sélectionner le nombre de threads, comme cela a été fait dans la version parallèle de la fonction accumulate () du Listing 2.9.  Ensuite, au lieu de démarrer un nouveau thread pour chaque appel récursif, vous pouvez placer le fragment à trier sur une pile adaptée aux threads, par exemple, comme indiqué dans les chapitres 6 et 7. Si le thread n'a rien à faire ou s'il a fini de traiter tous ses fragments ou attend que le fragment soit trié, il peut prenez un fragment de la pile et triez-le. <br><br>  Le listing 8.1 montre une implémentation simple de cette technologie.  Comme dans la plupart des autres exemples, il ne fait que démontrer l'intention et n'est pas un code prêt pour une utilisation pratique.  Si vous utilisez le compilateur C ++ 17 et que votre bibliothèque le prend en charge, vous devez utiliser les algorithmes parallèles fournis par la bibliothèque standard conformément aux descriptions données au chapitre 10. <br><br>  Listing 8.1.  Un algorithme Quicksort parallèle qui utilise une pile de fragments en attente de tri <br><br><img src="https://habrastorage.org/webt/ko/nb/h6/konbh6b_q40lp0uz-gxyunwws3g.png" alt="image"><br><img src="https://habrastorage.org/webt/5s/md/52/5smd5279wgwzktq4thil54lidqy.png" alt="image"><br><img src="https://habrastorage.org/webt/ro/js/kt/rojsktncuxgmls2wtndzt9ywhqy.png" alt="image"><br><br>  Ici, la fonction parallel_quick_sort <b>(19)</b> place la majeure partie des responsabilités fonctionnelles sur la classe sorter <b>(1)</b> , qui fournit un moyen facile de regrouper la pile de fragments non triés <b>(2)</b> et de plusieurs threads <b>(3)</b> .  Le travail principal est effectué dans la fonction du composant do_sort <b>(9)</b> , qui est occupée par le partitionnement de données habituel <b>(10)</b> .  Cette fois, au lieu de démarrer un nouveau thread pour chaque fragment, il pousse ce fragment sur la pile (11) et ne démarre un nouveau thread que s'il existe une ressource processeur libre (12).  Puisqu'un fragment avec des valeurs inférieures à celle de la référence peut être traité par un autre flux, nous devons attendre sa disponibilité <b>(13)</b> .  Afin que le temps ne soit pas perdu (dans le cas où nous avons un seul thread ou que tous les autres threads sont déjà occupés), une tentative est faite pour traiter les fragments de la pile pendant cette période d'attente <b>(14)</b> .  La fonction try_sort_chunk récupère un fragment de la pile <b>(7)</b> , le trie <b>(8)</b> et enregistre les résultats dans la promesse de promesse afin qu'ils puissent recevoir le flux qui a mis ce fragment sur la pile <b>(15)</b> . <br><br>  Maintenant, les threads qui viennent d'être lancés sont en boucle et essaient de trier les fragments de la pile <b>(17)</b> si l'indicateur end_of_data <b>(16)</b> n'est pas défini.  Entre les vérifications, ils abandonnent la ressource informatique à d'autres threads afin de pouvoir pousser du travail supplémentaire sur la pile.  Le travail du code en termes de mise en ordre de ces threads dépend du destructeur de votre classe sorter <b>(4)</b> .  Lorsque toutes les données sont triées, la fonction do_sort renverra le contrôle (même en maintenant l'activité des threads de travail), le thread principal reviendra de parallel_quick_sort <b>(20)</b> et détruira l'objet trieur.  Il définira l'indicateur end_of_data <b>(5)</b> et attendra que les threads finissent de fonctionner <b>(6). La</b> définition de l'indicateur arrêtera la boucle dans la fonction des threads (16). <br><br>  Avec cette approche, le problème du nombre illimité de threads inhérent à la fonction spawn_task qui a lancé le nouveau thread disparaîtra et la dépendance à la bibliothèque de threads C ++, qui sélectionnera le nombre de threads pour vous, comme lors de l'utilisation de std :: async (), disparaîtra.  Au lieu de cela, pour éviter un changement de tâche trop fréquent, le nombre de threads est limité par la valeur renvoyée par la fonction std :: thread :: hardware_concurrency ().  Mais un autre problème se pose: la gestion de ces flux et l'échange de données entre eux compliquent grandement le code.  De plus, malgré le fait que les threads traitent des éléments de données individuels, tous accèdent à la pile, y ajoutant de nouveaux fragments et prenant des fragments pour traitement.  Une concurrence aussi intense peut réduire les performances, même si une pile sans verrouillage (et donc non bloquante) est utilisée, et les raisons de cela seront bientôt examinées. <br><br>  Cette approche est une version spéciale du pool de threads - un ensemble de threads, chacun recevant le travail de la liste des travaux différés, l'exécute, puis se tourne vers la liste pour un nouveau.  Certains problèmes potentiels inhérents au pool de threads (y compris la concurrence lors de l'accès à la liste des travaux) et les moyens de les résoudre sont abordés dans le chapitre 9. Sur la mise à l'échelle de l'application créée afin qu'elle s'exécute sur plusieurs processeurs, nous aborderons ce chapitre un peu plus tard (voir sous-section 8.2.1). <br><br>  Lors de la distribution des données avant le traitement et en mode récursif, il est supposé qu'elles sont fixées à l'avance et une recherche est en cours pour leur distribution.  Mais cela ne se produit pas toujours: si les données sont créées en mode dynamique ou proviennent d'une source externe, cette approche ne fonctionne pas.  Dans ce cas, il peut être plus raisonnable de répartir le travail en fonction du type de tâche et non en fonction des données elles-mêmes. <br><br><h3>  8.1.3.  Répartition du travail par type de tâche </h3><br>  La répartition du travail entre les threads en attribuant à chacun d'entre eux (à l'avance ou de manière récursive pendant le traitement des données) différentes données dans tous les cas est basée sur l'hypothèse que les threads vont faire le même travail sur chaque pièce.  Une autre distribution du travail est la spécialisation des flux, où chacun effectue une tâche distincte, car les plombiers et les électriciens effectuent différentes tâches dans la construction d'une maison.  Les flux peuvent fonctionner avec des données différentes ou identiques, mais dans ce dernier cas, ils le font à des fins différentes. <br><br>  Cette division particulière du travail résulte de la séparation des tâches à l'aide de la concurrence: chaque fil a une tâche distincte, qu'il effectue indépendamment des autres flux.  Parfois, d'autres threads peuvent fournir des données au flux ou produire des événements auxquels il doit répondre, mais en général, chaque flux se concentre sur les performances de haute qualité d'une seule tâche.  C'est une bonne conception de base, où chaque morceau de code doit être responsable d'une chose. <br><br><h3>  Répartition du travail par type de tâche afin de partager les responsabilités </h3><br>  Une application monothread doit faire face à des conflits liés au principe de responsabilité unique, lorsque plusieurs tâches doivent être exécutées en continu pendant un certain temps, ou que l'application doit faire face au traitement des événements entrants en temps opportun (par exemple, un utilisateur appuie sur une touche ou des données arrivent sur le réseau) en présence d'autres tâches inachevées.  Dans un environnement informatique à thread unique, vous devez créer indépendamment du code qui exécute une partie de la tâche A, une partie de la tâche B, vérifie si une touche est enfoncée et s'il n'y a pas de paquets réseau, puis revient cycliquement à la partie suivante de la tâche A. tâches A en raison de la nécessité de maintenir son état et de rendre périodiquement le contrôle à la boucle principale.  Si vous ajoutez trop de tâches au cycle, le travail peut ralentir considérablement et l'utilisateur remarquera probablement une réaction lente aux frappes.  Je suis sûr que tout le monde a observé les manifestations extrêmes d'une situation similaire dans certaines applications: vous définissez une tâche pour l'application, et l'interface ne réagit à rien tant qu'elle n'est pas terminée. <br><br>  Ici, les flux entrent en scène.  Si vous exécutez chaque tâche dans un thread distinct, le système d'exploitation peut le faire à votre place.  Dans le code de la tâche A, vous pouvez vous concentrer sur l'achèvement de la tâche sans vous soucier du maintien de l'état et du retour à la boucle principale, ni du temps qui s'écoulera avant que cela ne se produise.  Autrement dit, le système d'exploitation enregistrera automatiquement l'état et passera au bon moment à la tâche B ou C, et si le système sur lequel le programme sera exécuté a plusieurs cœurs ou processeurs, il sera possible d'exécuter simultanément les tâches A et B. Le code de traitement des frappes ou des reçus les paquets réseau peuvent maintenant être exécutés en temps opportun, et tout le monde en bénéficiera: l'utilisateur recevra une réponse adéquate du programme et vous, en tant que développeur, recevrez un code simplifié, car chaque flux peut être dirigé  effectuer des opérations directement liées à ses fonctions, sans les mélanger avec le flux de contrôle et l'interaction avec l'utilisateur. <br><br>  Une image idéale se dessine.  Mais tout peut-il se passer de cette façon?  Comme toujours, tout dépend des circonstances spécifiques.  Si l'indépendance totale est respectée et que les flux n'ont pas besoin d'échanger des données entre eux, c'est exactement ce qui se passera.  Malheureusement, une situation similaire est observée assez rarement.  Souvent, les actions nécessaires à l'utilisateur ont la forme de tâches d'arrière-plan pratiques, et elles doivent informer l'utilisateur de la tâche, mettant à jour l'interface utilisateur d'une manière ou d'une autre.  Ou l'utilisateur peut avoir besoin d'arrêter la tâche, donc l'interface utilisateur devra en quelque sorte envoyer un message à la tâche en arrière-plan, ce qui provoquera l'arrêt de son exécution.  Dans les deux cas, il est nécessaire de considérer soigneusement la conception et la synchronisation appropriée, mais les tâches effectuées resteront fragmentées.  Le thread d'interface utilisateur contrôle toujours cette interface, mais il peut être affecté à l'exécution d'une mise à jour à la demande d'autres threads.  Un thread qui implémente une tâche en arrière-plan se concentre toujours sur les opérations requises pour la terminer; il arrive également que l'un des threads en arrière-plan permette à la tâche d'arrêter l'autre thread.  Dans les deux cas, les flux ne se soucient pas de l'origine de la demande, ils se soucient uniquement du fait qu'elle soit conçue pour eux et directement liée à leurs responsabilités. <br><br>  Le partage des responsabilités entre plusieurs threads présente deux dangers graves.  Premièrement, il peut s’avérer que des responsabilités inappropriées sont réparties.  Un signe de cela est trop de données partagées par les flux, ou le fait que différents flux doivent s’attendre les uns les autres.          .      .        , , ,    ,             .   ,        ,     —   , ,        . <br><br>                .             ,     ,         . <br><br><h3>      </h3><br>                 ,            .      : ,     ,         . <br><br>            —        .   ,     ,      .   ,     ,       ,           . <br><br>      ,    8.1.1,   ,           . ,                  . <br><br>     ,        :    ,       . ,        20          ,      3 .      ,         .  ,   ,    ,  ,   12       ,  24  —   . .  20     .      .         .       , ,  ,   ,   12 . ,   12       ,        .      ,  :  ,   ,     ,  ,       ,        .      3         12 . <br><br>      ,    9 ,         .            . ,  ,      .          25   ,    —  .  ,       ,    : ,   100   ,  ,    1 ,    100 ,    1     100 .     ,  ,        .       ,     ,  , . <br><br>       ,    ,     ,   ,      . <br><br><h3> 8.2. ,      </h3><br>            ,  ,      .        ,  ,     .     ,       16      ,     . <br><br>    ,        —   ,    ,    (      ),      .          ,    :      ? <br><br><h3> 8.2.1.     ? </h3><br>  ( )     ,          .   ,    ,        ,          .     ,     .      ,     . ,         ,         (   )       .     ,   ,      ,            . <br><br>     16-       16  :          16 .    ,        16 .   ,    ,         (   ).    ,    16    ,      ,           ,      1.       (oversubscription). <br><br>          ,       ,    C++11 (Standard Thread Library)   std::thread::hardware_concurrency().             . <br><br>   std::thread::hardware_concurrency()    :       -  ,   ,        .   ,        ,  std::thread::hardware_concurrency(),     .  std::async()    ,           .           . <br><br>      ,    ,    ,      .              —   ,   ,     . ,     ,   ,       ,          C++.   ,     std::async(),       ,   ,    .       ,     .   ,      ,      std::thread::hardware_concurrency(),     .      ,      ,  ,    . <br><br>       ,                 .          ,     ,      ,    ,        . <br><br>         ,        —          . <br><br>  »Plus d'informations sur le livre sont disponibles sur <a href="https://www.piter.com/collection/new/product/c-praktika-mnogopotochnogo-programmirovaniya%3F_gs_cttl%3D120%255E_%255Eamp%255E_%255Egs_direct_link%3D1%255E_%255Eamp%255E_%255Egsaid%3D82744%255E_%255Eamp%255E_%255Egsmid%3D29789%255E_%255Eamp%255E_%255Egstid%3Dc">le site Web de l'éditeur</a> <br>  » <a href="https://storage.piter.com/upload/contents/978544610831/978544610831_X.pdf">Contenu</a> <br>  » <a href="https://storage.piter.com/upload/contents/978544610831/978544610831_p.pdf">Extrait</a> <br><br>    25%   — <b>C++</b> <br><br>  Lors du paiement de la version papier du livre, un livre électronique est envoyé par e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484818/">https://habr.com/ru/post/fr484818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484804/index.html">Que chiffrer dans un système d'entreprise? Et pourquoi faire ça?</a></li>
<li><a href="../fr484806/index.html">Différence entre cPanel et Plesk Obsidian</a></li>
<li><a href="../fr484812/index.html">Mon expérience avec Plesk</a></li>
<li><a href="../fr484814/index.html">6. Mise en route de Fortinet v6.0. Filtrage Web et contrôle des applications</a></li>
<li><a href="../fr484816/index.html">Utilisation de hooks d'opérations pour sauvegarder des fichiers sur macOS à la volée</a></li>
<li><a href="../fr484820/index.html">FAQ.Net - un programme de prise de notes gratuit pour Windows avec une conception mise à jour</a></li>
<li><a href="../fr484822/index.html">Blazor: comment empêcher un composant de tomber malade ou deux approches pour séparer le code du balisage</a></li>
<li><a href="../fr484824/index.html">La guerre pour éteindre les lumières</a></li>
<li><a href="../fr484826/index.html">L'intelligence artificielle aggrave encore plus la mauvaise médecine</a></li>
<li><a href="../fr484834/index.html">Comment construire une stratégie d'entreprise pour la formation et le développement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>