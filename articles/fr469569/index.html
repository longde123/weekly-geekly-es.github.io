<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüè≠ üèá üåó Arend - Langage de type d√©pendant bas√© sur HoTT (partie 1) üßúüèø üëÉüèΩ üíÉüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous parlerons du nouveau langage JetBrains avec les types d√©pendants d'Arend (le langage est nomm√© d'apr√®s Gating Rent ). Ce langag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arend - Langage de type d√©pendant bas√© sur HoTT (partie 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/469569/"> Dans cet article, nous parlerons du nouveau langage JetBrains avec les types d√©pendants d'Arend (le langage est nomm√© d'apr√®s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gating Rent</a> ).  Ce langage a √©t√© d√©velopp√© par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JetBrains Research au</a> cours des derni√®res ann√©es.  Bien que les d√©p√¥ts il y a un an aient √©t√© rendus publics sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/JetBrains</a> , la version compl√®te d'Arend n'est arriv√©e qu'en juillet de cette ann√©e. <br><br>  Nous allons essayer de dire en quoi Arend diff√®re des syst√®mes existants de math√©matiques formalis√©es bas√©es sur des types d√©pendants, et quelles fonctionnalit√©s sont d√©sormais disponibles pour ses utilisateurs.  Nous supposons que le lecteur de cet article est g√©n√©ralement familier avec les types d√©pendants et a entendu au moins une des langues bas√©es sur les types d√©pendants: Agda, Idris, Coq ou Lean.  Cependant, nous ne nous attendons pas √† ce que le lecteur ait des types d√©pendants √† un niveau avanc√©. <br><br>  Pour plus de simplicit√© et de concr√©tisation, notre histoire sur les types Arend et homotopie sera accompagn√©e de l'impl√©mentation sur Arend de l'algorithme de tri de liste le plus simple - m√™me avec cet exemple, vous pouvez sentir la diff√©rence entre Arend et Agda et Coq.  Il existe d√©j√† un certain nombre d'articles sur Habr√© consacr√©s aux types d√©pendants.  Disons que l'impl√©mentation de listes de tri √† l'aide de la m√©thode QuickSort sur Agda existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un tel article</a> .  Nous allons impl√©menter un algorithme plus simple pour trier les inserts.  Dans ce cas, nous nous concentrerons sur les constructions du langage Arend, et non sur l'algorithme de tri lui-m√™me. <br><a name="habracut"></a><br>  Ainsi, la principale diff√©rence entre Arend et d'autres langages √† types d√©pendants est la th√©orie logique sur laquelle il est bas√©.  Arend utilise √† ce titre la th√©orie du type d'homotopie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hoevodsky</a> r√©cemment d√©couverte ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HoTT</a> ).  Plus pr√©cis√©ment, Arend est bas√© sur une variation de HoTT appel√©e ¬´th√©orie des types avec espacement¬ª.  Rappelons que Coq est bas√© sur le soi-disant calcul des constructions inductives (Calcul des constructions inductives), tandis que Agda et Idris sont bas√©s sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">th√©orie intensionnelle des types de Martin-L√∂f</a> .  Le fait qu'Arend soit bas√© sur HoTT affecte de mani√®re significative ses constructions syntaxiques et le fonctionnement de l'algorithme de v√©rification de type (typcheker).  Nous allons discuter de ces fonctionnalit√©s dans cet article. <br><br>  Essayons de d√©crire bri√®vement l'√©tat de l'infrastructure linguistique.  Pour Arend, il existe un plugin pour IntelliJ IDEA, qui peut √™tre install√© directement √† partir du r√©f√©rentiel des plugins IDEA.  En principe, l'installation du plugin est suffisante pour fonctionner pleinement avec Arend, vous n'avez toujours pas besoin de t√©l√©charger et d'installer quoi que ce soit.  En plus de la v√©rification de type, le plugin Arend fournit des fonctionnalit√©s famili√®res aux utilisateurs d'IDEA: il y a la mise en √©vidence et l'alignement du code, divers refactorings et conseils.  Il existe √©galement la possibilit√© d'utiliser la version console d'Arend.  Une description plus d√©taill√©e du processus d'installation peut √™tre trouv√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Les exemples de code de cet article sont bas√©s sur la biblioth√®que standard d'Arend, nous vous recommandons donc de t√©l√©charger son code source √† partir du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rentiel</a> .  Apr√®s le t√©l√©chargement, le r√©pertoire source doit √™tre import√© en tant que projet IDEA √† l'aide de la commande Importer un projet.  √Ä Arend, certaines sections de la th√©orie des types d'homotopie et de la th√©orie des anneaux ont d√©j√† √©t√© formalis√©es.  Par exemple, dans la biblioth√®que standard, il y a une impl√©mentation de l'anneau de nombres rationnels Q avec des preuves de toutes les propri√©t√©s th√©oriques de l'anneau requises. <br><br>  Une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation linguistique</a> d√©taill√©e, dans laquelle de nombreux points abord√©s dans cet article sont expliqu√©s plus en d√©tail, est √©galement du domaine public.  Vous pouvez directement poser des questions aux d√©veloppeurs Arend sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">canal t√©l√©gramme</a> . <br><br><h2>  1. Pr√©sentation de HoTT / Arend </h2><br>  La th√©orie de type homotopie (ou, en bref, HoTT) est un type de th√©orie de type intensionnel qui diff√®re de la th√©orie de type classique de Martin-L√∂f (MLTT, sur laquelle Agda est bas√©e) et du calcul de construction inductive (CIC, sur lequel Coq est bas√©), en ce que, avec les instructions et les ensembles contiennent les soi-disant types d'un niveau d'homotopie sup√©rieur. <br><br>  Dans cet article, nous ne nous fixons pas l'objectif d'expliquer en d√©tail les fondements de HoTT - pour une exposition d√©taill√©e de cette th√©orie, il serait n√©cessaire de relire l'int√©gralit√© du livre (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> ).  On constate seulement qu'une th√©orie bas√©e sur l'axiomatique de HoTT est, en un sens, beaucoup plus √©l√©gante et int√©ressante que la th√©orie classique de type Martin-L√∂f.  Ainsi, un certain nombre d'axiomes qui devaient auparavant √™tre postul√©s en plus (par exemple, l'extensionnalit√© fonctionnelle) sont prouv√©s dans HoTT comme th√©or√®mes.  De plus, dans HoTT, on peut d√©finir en interne des sph√®res d'homotopie multidimensionnelles et m√™me compter certains de leurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">groupes d'homotopie</a> . <br><br>  Cependant, ces aspects de HoTT sont principalement int√©ressants pour les math√©maticiens, et le but de cet article est d'expliquer comment l'Arend bas√© sur HoTT se compare favorablement avec Agda / MLTT et Coq / CIC par l'exemple de la repr√©sentation aussi simple et famili√®re √† toute entit√© de programmeur que des listes ordonn√©es.  √Ä la lecture de cet article, il suffit de traiter HoTT comme une sorte de th√©orie de type intensionnelle avec une axiomatique plus d√©velopp√©e, ce qui est pratique lorsque l'on travaille avec des univers et des √©galit√©s. <br><br><h2>  1.1 Types d√©pendants, correspondance Curry-Howard, univers </h2><br>  Rappelons que les langages avec des types d√©pendants diff√®rent des langages de programmation fonctionnels ordinaires en ce qu'en plus des types de donn√©es habituels, tels que les listes ou les nombres naturels, il existe des types en fonction de la valeur du param√®tre.  Les exemples les plus simples de ces types sont des vecteurs d'une longueur donn√©e n ou des arbres √©quilibr√©s d'une profondeur donn√©e d.  Quelques autres exemples de ces types sont mentionn√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici.</a> <br><br>  Rappelons que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correspondance Curry-Howard</a> permet d'interpr√©ter les √©nonc√©s de logique comme des types d√©pendants.  L'id√©e principale de cette correspondance est qu'un type vide correspond √† une fausse d√©claration et que les types remplis correspondent √† une vraie d√©claration.  Les √©l√©ments de type peuvent √™tre consid√©r√©s comme des preuves de l'√©nonc√© logique correspondant.  Par exemple, tout √©l√©ment tel que des entiers peut √™tre consid√©r√© comme une preuve du fait que des entiers existent (c'est-√†-dire que le type d'entiers est renseign√©). <br><br>  Diff√©rentes constructions naturelles sur les types correspondent √† diff√©rents connecteurs logiques: <br><br><ul><li>  <i>Le produit des types A √ó B</i> est parfois appel√© le type d'une paire Pair A B. Puisque ce type est rempli si et seulement si les deux types A et B sont remplis, cette construction correspond au ¬´et¬ª logique. </li><li>  <i>La somme des types A + B.</i> Dans Haskell, ce type est appel√© Soit A B. Puisque ce type est rempli si et seulement si l'un des types A ou B est rempli, cette construction correspond √† un ¬´ou¬ª logique. <br></li><li>  <i>Type fonctionnel A ‚Üí B.</i>  Toute fonction de ce type convertit les √©l√©ments de A en √©l√©ments de B. Ainsi, une telle fonction existe exactement lorsque l'existence d'un √©l√©ment de type A implique l'existence d'un √©l√©ment de type B. Par cons√©quent, cette construction correspond √† l'implication. <br></li></ul><br>  Supposons maintenant que l'on nous donne un certain type A et une famille de types B param√©tr√©s par un √©l√©ment a de type A. Donnons des exemples de constructions plus complexes sur des types d√©pendants. <br><br><ul><li>  <i>Type de fonction d√©pendante</i> <b>Œ†</b> (a: A) (B a).  Ce type co√Øncide avec le type fonctionnel habituel A ‚Üí B si B est ind√©pendant de A. Une fonction de type <b>Œ†</b> (a: A) (B a) convertit tout √©l√©ment a de type A en √©l√©ment de type B a.  Ainsi, une telle fonction existe si et seulement si, <i>pour tout a</i> : A, il existe un √©l√©ment B a.  Par cons√©quent, cette construction correspond au quantificateur universel ‚àÄ.  Pour le type fonctionnel d√©pendant, Arend utilise la syntaxe <code><b>\Pi</b> (x : A) -&gt; B a</code> , et le terme habitant ce type peut √™tre construit en utilisant l'expression lambda <code><b>\lam</b> (a : A) =&gt; f a.</code> </li><li>  <i>Le type de paires d√©pendantes est <b>Œ£</b> (a: A) (B a).</i>  Ce type co√Øncide avec les types habituels de paires A √ó B si B est ind√©pendant de A. Le type <b>Œ£</b> (a: A) (B a) est rempli exactement lorsqu'il <i>existe</i> un √©l√©ment a: A et un √©l√©ment de type B a.  Ainsi, ce type correspond au quantificateur d'existence <code>‚àÉ</code> .  Le type de paires d√©pendantes dans Arend est d√©sign√© par <code>\Sigma (a : A) (B a)</code> , et les termes qui les habitent sont construits en utilisant le constructeur de la paire <code>(a, b)</code> <i>d√©pendante)</i> <code>(a, b)</code> . <br></li><li>  <i>Le type d'√©galit√© est</i> a = a ', o√π a et a' sont deux √©l√©ments d'un certain type A. Un tel type est rempli si a et a 'sont √©gaux, et est vide sinon.  √âvidemment, ce type est un analogue du pr√©dicat d'√©galit√© en logique. </li></ul><br>  √Ä ce stade, nous renvoyons le lecteur √† des sources dans lesquelles la correspondance Curry-Howard est discut√©e plus en d√©tail (voir, par exemple, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cours magistral</a> ou des articles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ). <br><br>  Toutes les expressions consid√©r√©es dans la th√©orie des types doivent avoir un certain type.  √âtant donn√© que les expressions d√©signant des types sont √©galement consid√©r√©es dans le cadre de cette th√©orie, elles doivent √©galement √™tre affect√©es √† un certain type.  La question est, quel type de type devrait-il √™tre? <br><br>  La premi√®re d√©cision na√Øve qui vient √† l'esprit est d'assigner √† tous les types un type formel <code>\Type</code> , appel√© l' <i>univers</i> (il est ainsi appel√© parce qu'il contient tous les types en g√©n√©ral).  Si nous utilisons cet univers, les constructions de somme et les produits de type mentionn√©s ci-dessus recevront la signature <code>\Type ‚Üí \Type ‚Üí \Type</code> , et les constructions plus complexes du produit d√©pendant et la somme d√©pendante recevront la signature <code><b>Œ†</b> (A : \Type) ‚Üí ((A ‚Üí \Type) ‚Üí \Type)</code> . <br><br>  √Ä ce stade, la question se pose: quel type doit avoir l'univers <code>\Type</code> lui-m√™me?  Une tentative na√Øve de dire que le type de l'univers <code>\Type</code> , par d√©finition, est <code>\Type</code> lui-m√™me conduit au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">paradoxe Girard</a> , donc au lieu d'un seul univers <code>\Type</code> consid√©rons une <i>hi√©rarchie</i> infinie <i>d'univers</i> , c'est-√†-dire  la cha√Æne imbriqu√©e d'univers <code>\Type 1 &lt; \Type 2 &lt; ‚Ä¶</code> , dont les niveaux sont num√©rot√©s par des nombres naturels, et le type de l'univers <code>\Type i</code> , par d√©finition, est l'univers <code>\Type (i+1)</code> .  Pour les constructions de type mentionn√©es ci-dessus, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des signatures</a> plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">complexes</a> doivent √©galement √™tre introduites. <br><br>  Ainsi, les univers en th√©orie des types sont n√©cessaires pour que toute expression ait un certain type.  Dans certaines vari√©t√©s de th√©orie des types, les univers sont utilis√©s dans un autre but: distinguer les vari√©t√©s de types.  Nous avons d√©j√† vu que les ensembles et les instructions sont des cas particuliers de types.  Cela montre qu'il pourrait √™tre judicieux d'introduire dans la th√©orie un univers Prop distinct pour les instructions et une hi√©rarchie distincte des univers Set <sub>i</sub> pour les ensembles.  C'est exactement l'approche utilis√©e dans le Calcul des constructions inductives, la th√©orie sur laquelle le syst√®me Coq est bas√©. <br><br><h2>  1.2 Exemples de types inductifs et de fonctions r√©cursives les plus simples </h2><br>  Consid√©rez les d√©finitions sur Arend des types de donn√©es inductifs les plus simples: type bool√©en, type de nombre naturel et listes polymorphes.  Arend utilise le mot-cl√© <code>\data</code> pour introduire de nouveaux types inductifs. <br><br> <code>\data Empty --  ,    <br> <br> \data Bool <br> | true <br> | false <br> <br> \data Nat <br> | zero <br> | suc Nat <br> <br> \data List (A : \Set) <br> | nil <br> | \infixr 5 :-: A (List A)</code> <br> <br>  Comme vous pouvez le voir dans les exemples ci-dessus, apr√®s le mot-cl√© <code>\data</code> , vous devez sp√©cifier le nom du type inductif et une liste de ses constructeurs.  Dans le m√™me temps, le type de donn√©es et les constructeurs peuvent avoir certains param√®tres.  Disons que dans l'exemple ci-dessus, le type <code>List</code> a un param√®tre <code>A</code>  Le constructeur de liste <code>nil</code> n'a pas de param√®tres, et le constructeur: -: a deux param√®tres (dont l'un est de type <code>A</code> et l'autre est de type <code>List A</code> ).  L'univers <code>\Set</code> compose de types qui sont des ensembles (la d√©finition des ensembles sera donn√©e dans la section suivante).  Le <code>\infixr</code> vous permet d'utiliser la notation infixe pour le constructeur: -: et, en outre, indique √† l'analyseur Arend que l'op√©rateur: -: est une op√©ration associative √† droite avec la priorit√© 5. <br><br>  Dans Arend, tous les mots cl√©s commencent par un caract√®re barre oblique inverse (¬´\¬ª), une impl√©mentation inspir√©e de LaTeX.  Notez simplement que les r√®gles lexicales d'Arend sont tr√®s lib√©rales: <code>Circle_HSpace, contrFibers=&gt;Equiv, suc/=0, zro_*-left</code> et m√™me <code>n:Nat</code> - tous ces litt√©raux sont des exemples d'identifiants valides dans Arend.  Le dernier exemple montre √† quel point il est important pour l'utilisateur Arend <i>de se rappeler de mettre des espaces entre les identifiants et les deux points</i> .  Notez que dans les identifiants Arend, il n'est pas autoris√© d'utiliser des caract√®res Unicode (en particulier, vous ne pouvez pas utiliser le cyrillique). <br><br>  Arend utilise le mot cl√© <code>\func</code> pour d√©finir les fonctions.  La syntaxe de cette construction est la suivante: apr√®s le mot-cl√© <code>\func</code> , vous devez sp√©cifier le nom de la fonction, ses param√®tres et le type de la valeur de retour.  Le dernier √©l√©ment dans la d√©finition d'une fonction est son corps. <br><br>  S'il est possible de sp√©cifier explicitement l'expression dans laquelle la fonction donn√©e doit √™tre calcul√©e, alors pour indiquer le corps de la fonction, le jeton =&gt; est utilis√©.  Consid√©rons, par exemple, la d√©finition d'une fonction de n√©gation de type. <br><br><pre> <code class="plaintext hljs">\func Not (A : \Type) : \Type =&gt; A -&gt; Empty</code> </pre> <br>  Le type de retour d'une fonction ne doit pas toujours √™tre sp√©cifi√© explicitement.  Dans l'exemple ci-dessus, Arend serait en mesure de d√©duire ind√©pendamment le type <code>Not</code> , et nous pourrions omettre l'expression ¬´: <code>\Type</code> ¬ª apr√®s les crochets. <br><br>  Comme dans la plupart des syst√®mes math√©matiques formalis√©s, l'utilisateur n'a pas √† indiquer un niveau pr√©dictif explicite dans l'univers <code>\Type</code> , et les d√©finitions dans lesquelles les univers sont utilis√©s sans sp√©cifier explicitement un niveau pr√©dictif sont consid√©r√©es comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polymorphes</a> . <br><br>  Essayons maintenant de d√©finir une fonction qui calcule la longueur de la liste.  Une telle fonction est facile √† identifier gr√¢ce √† la correspondance de motifs.  Arend utilise pour cela le mot-cl√© <code>\elim</code> .  Apr√®s cela, vous devez sp√©cifier les variables par lesquelles la comparaison est effectu√©e (s'il existe plusieurs variables de ce type, elles doivent √™tre √©crites avec une virgule).  Si la comparaison est effectu√©e pour tous les param√®tres explicites, alors <code>\elim</code> ainsi que les variables peuvent √™tre omis.  Il est suivi d'un bloc de points de comparaison, s√©par√©s les uns des autres par une barre verticale "|".  Chaque √©l√©ment de ce bloc est une expression de la forme <code>¬´,    ¬ª =&gt; ¬´¬ª</code> . <br><br><pre> <code class="plaintext hljs">\func length {A : \Set} (l : List A) : Nat | nil =&gt; 0 | :-: x xs =&gt; suc (length xs)</code> </pre> <br>  Dans l'exemple ci-dessus, le param√®tre A de la fonction de <code>length</code> est entour√© d'accolades.  Ces crochets dans Arend sont utilis√©s pour d√©signer des arguments implicites, c'est-√†-dire  arguments que l'utilisateur peut omettre lors de l'appel d'une fonction ou de l'utilisation d'un type.  Notez que dans Arend, vous ne pouvez pas utiliser la notation infixe pour d√©signer les constructeurs lors de la correspondance avec un mod√®le, de sorte que la notation pr√©fixe est utilis√©e dans l'exemple d'exemple. <br><br>  Comme dans Coq / Agda, dans Arend, toutes les fonctions doivent √™tre garanties d'√™tre termin√©es (c'est-√†-dire que la v√©rification de terminaison est pr√©sente dans Arend).  Dans la d√©finition de la fonction de longueur, cette v√©rification est r√©ussie, car un appel r√©cursif r√©duit strictement le premier argument explicite.  Si une telle r√©duction ne se produisait pas, Arend enverrait un message d'erreur. <br><br><pre> <code class="plaintext hljs">\func bad : Nat =&gt; bad [ERROR] Termination check failed for function 'bad' In: bad</code> </pre> <br>  Arend permet des d√©pendances circulaires et des fonctions mutuellement r√©cursives pour lesquelles des contr√¥les d'ach√®vement sont √©galement effectu√©s.  L'algorithme de cette v√©rification est impl√©ment√© sur la base de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de</a> A. Abel.  Vous y trouverez une description plus d√©taill√©e des conditions que les fonctions mutuellement r√©cursives doivent remplir. <br><br><h2>  1.3 En quoi les ensembles diff√®rent-ils des √©nonc√©s? </h2><br>  Nous avons pr√©c√©demment √©crit que des exemples de types sont des ensembles et des instructions.  De plus, nous avons utilis√© les mots cl√©s <code>\Type</code> et <code>\Set</code> pour d√©signer les univers dans Arend.  Dans cette section, nous allons essayer d'expliquer plus en d√©tail en quoi les √©nonc√©s diff√®rent des ensembles en termes de vari√©t√©s de la th√©orie des types intensionnels (MLTT, CIC, HoTT), et en m√™me temps expliquer en quoi consiste la signification des mots cl√©s <code>\Prop</code> , <code>\Set</code> et <code>\Type</code> dans Arend. <br><br>  Rappelons que dans la th√©orie classique de Martin-L√∂f, il n'y a pas de s√©paration des types en ensembles et en √©nonc√©s.  En particulier, en th√©orie, il n'y a qu'un seul univers cumulatif (qui est d√©sign√© par Set in Agda, ou Type in Idris, ou Sort in Lean).  Cette approche est la plus simple, mais il existe des situations o√π ses lacunes se manifestent.  Supposons que nous essayons d'impl√©menter le type "liste ordonn√©e" comme une paire d√©pendante compos√©e d'une liste et d'une preuve de son ordre.  Il s'av√®re alors que, dans le cadre du MLTT ¬´pur¬ª, il ne sera pas possible de prouver l'√©galit√© des listes ordonn√©es constitu√©es d'√©l√©ments identiques, qui en m√™me temps diff√®rent en termes de preuve de commande.  Avoir une telle √©galit√© serait tr√®s naturel et souhaitable, de sorte que l'impossibilit√© de la prouver peut √™tre consid√©r√©e comme un d√©faut th√©orique du MLTT. <br><br>  Dans Agda, ce probl√®me est partiellement r√©solu √† l'aide de ce que l'on appelle des annotations d'immat√©rialit√© (voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source</a> , dans laquelle l'exemple de liste est discut√© plus en d√©tail).  Ces annotations, cependant, ne sont pas une construction de la th√©orie MLTT, ni des constructions √† part enti√®re sur des types (il est impossible de marquer avec une annotation de type qui n'est pas utilis√©e dans l'argument de fonction). <br><br>  Dans CIC, bas√© sur CIC, il existe deux univers diff√©rents imbriqu√©s l'un dans l'autre: <code>Prop</code> (l'univers des √©nonc√©s) et <code>Set</code> (l'univers des ensembles), qui sont immerg√©s dans la hi√©rarchie compl√®te des univers <code>Type</code> .  La principale diff√©rence entre <code>Prop</code> et <code>Set</code> est qu'il existe un certain nombre de restrictions sur les variables dont le type appartient √† <code>Prop</code> dans Coq.  Par exemple, ils ne peuvent pas √™tre utilis√©s dans les calculs et leur comparaison avec l'√©chantillon n'est possible qu'√† l'int√©rieur des preuves d'autres d√©clarations.  D'autre part, tous les √©l√©ments du type appartenant √† l'univers <code>Prop</code> sont √©gaux dans l'axiome de la preuve sans cons√©quence, voir la d√©claration dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Coq.Logic.ProofIrrelevance</a> .  En utilisant cet axiome, nous pourrions facilement prouver l'√©galit√© des listes ordonn√©es mentionn√©es ci-dessus. <br><br>  Enfin, consid√©rons l'approche Arend / HoTT des d√©clarations et des univers.  La principale diff√©rence est que HoTT renonce √† l'axiome de la preuve sans cons√©quence.  Autrement dit, il n'y a pas d'axiome sp√©cial dans HoTT qui postule que tous les √©l√©ments des d√©clarations sont √©gaux.  Mais dans HoTT, un type, <i>par d√©finition</i> , est une d√©claration s'il peut √™tre prouv√© que tous ses √©l√©ments sont √©gaux les uns aux autres.  Nous pouvons d√©finir un pr√©dicat sur les types qui est vrai si le type est une instruction: <br><br><pre> <code class="plaintext hljs">\func isProp (A : \Type) =&gt; \Pi (aa' : A) -&gt; a = a'</code> </pre> <br>  La question se pose: quels types satisfont ce pr√©dicat, c'est-√†-dire, sont des d√©clarations?  Il est facile de v√©rifier que cela est vrai pour les types vides et singleton.  Pour les types o√π il y a au moins deux √©l√©ments diff√©rents, cela ne sera plus vrai. <br><br>  Bien s√ªr, nous voulons que tous les connecteurs logiques n√©cessaires soient d√©finis sur les instructions.  Dans la section 1.1, nous avons d√©j√† discut√© de la fa√ßon dont ils pouvaient √™tre d√©termin√©s √† l'aide de constructions th√©oriques de type.  Il y a cependant le probl√®me suivant: toutes les op√©rations que nous avons saisies ne conservent pas la propri√©t√© <code>isProp</code> .  Les constructions du produit des types et du type fonctionnel (d√©pendant) conservent cette propri√©t√©, contrairement aux constructions de la somme des types et des paires d√©pendantes.  Ainsi, nous ne pouvons pas utiliser la disjonction et le quantificateur d'existence. <br><br>  Ce probl√®me peut √™tre r√©solu √† l'aide d'une nouvelle construction, qui est ajout√©e √† HoTT, la soi-disant <i>troncature propositionnelle</i> .  Cette conception vous permet de transformer n'importe quel type en d√©claration.  Elle peut √™tre consid√©r√©e comme une op√©ration formelle, √©galisant tous les termes qui habitent ce type.  Cette op√©ration est quelque peu similaire aux annotations d'immat√©rialit√© d'Agda, cependant, contrairement √† elles, c'est une op√©ration √† part enti√®re sur les types avec signature <code>\Type -&gt; \Prop</code> . <br><br>  Le dernier exemple important d'instructions est l'√©galit√© de deux √©l√©ments d'un certain type.  Il s'av√®re que dans le cas g√©n√©ral, le type d'√©galit√© <code>a = a'</code> ne doit pas n√©cessairement √™tre une d√©claration.  Les types pour lesquels il s'agit d'un sont appel√©s ensembles: <br><br><pre> <code class="plaintext hljs">\func isSet (A : \Type) =&gt; \Pi (aa' : A) -&gt; isProp (a = a')</code> </pre> <br>  Tous les types que l'on trouve dans les langages de programmation ordinaires satisfont √† ce pr√©dicat, c'est-√†-dire que l'√©galit√© sur eux est une d√©claration.  Par exemple, cela est vrai pour les nombres naturels, les entiers, les produits d'ensembles, les sommes d'ensembles, les fonctions sur les ensembles, les listes d'ensembles et d'autres types de donn√©es inductives construits √† partir d'ensembles.  Cela signifie que si nous ne sommes int√©ress√©s que par de telles constructions famili√®res, nous ne pouvons pas penser √† des types arbitraires qui ne satisfont pas ce pr√©dicat.  Tous les types trouv√©s dans Coq sont des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ensembles</a> . <br><br>  Les types qui ne sont pas des ensembles deviennent utiles si vous voulez traiter de la th√©orie des types d'homotopie.  Pour l'instant, nous renvoyons simplement le lecteur au <a href="">module de</a> biblioth√®que standard contenant la d√©finition d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sph√®re √† n dimensions</a> , un exemple d'un type qui n'est pas un ensemble. <br><br>  Arend a des univers sp√©ciaux <code>\Prop</code> et <code>\Set</code> , constitu√©s respectivement d'instructions et d'ensembles.  Si nous savons d√©j√† que le type A est contenu dans l'univers <code>\Prop</code> (ou <code>\Set</code> ), alors la preuve de la <code>isProp</code> (ou <code>isSet</code> ) correspondante dans Arend peut √™tre obtenue en utilisant l'axiome <code>Path.inProp</code> int√©gr√© au <a href="">pr√©lude</a> (nous donnons un exemple d'utilisation de cet axiome dans la section 2.3). <br><br><pre> <code class="plaintext hljs">\func inProp {A : \Prop} : \Pi (aa' : A) -&gt; a = a'</code> </pre> <br>  Nous avons d√©j√† not√© que toutes les constructions naturelles sur les types ne conservent pas la propri√©t√© <code>isProp</code> .  Par exemple, les types de donn√©es inductifs avec deux ou plusieurs constructeurs ne le satisfont jamais.  Comme indiqu√© ci-dessus, nous pouvons utiliser la construction de <i>troncature propositionnelle</i> qui transforme n'importe quel type en instruction. <br>  Dans la biblioth√®que Arend, l'impl√©mentation standard de la troncature propositionnelle est appel√©e <code>Logic.TruncP</code> .  On pourrait d√©finir un type de ¬´ou¬ª logique dans Arend comme tronquant la somme des types: <br><br><pre> <code class="plaintext hljs">\data \fixr 2 Or (AB : \Type) -- Sum of types; analogue of Coq's type "sum" | inl A | inr B \func \infixr 2 || (AB : \Type) =&gt; TruncP (sum AB) -- Logical ‚Äúor‚Äù, analogue of Coq's type "\/"</code> </pre> <br>  Dans Arend, il existe un autre moyen plus simple et plus pratique de d√©finir un type inductif tronqu√© propositionnellement.  Pour ce faire, ajoutez simplement le mot cl√© <code>\truncated</code> avant de d√©finir le type de donn√©es.  Par exemple, la d√©finition d'un ¬´ou¬ª logique dans la biblioth√®que standard Arend est donn√©e comme suit. <br><br><pre> <code class="plaintext hljs">\truncated \data \infixr 2 || (AB : \Type) : \Prop -- Logical ‚Äúor‚Äù, analogue of Coq's type "\/" | byLeft A | byRight B</code> </pre> <br>  Les travaux ult√©rieurs avec des types tronqu√©s propositionnellement ressemblent √† ceux des types assign√©s √† l'univers <code>Prop</code> dans Coq.  Par exemple, la correspondance de mod√®le d'une variable dont le type est une instruction n'est autoris√©e que dans une situation o√π le type de l'expression d√©finie est lui-m√™me une instruction.  Ainsi, il est toujours facile de d√©finir la fonction <code>Or-to-||</code>  par comparaison avec l'√©chantillon, mais la fonction inverse, uniquement si le type A <code>`Or`</code> B est une instruction (ce qui est assez rare, par exemple, lorsque les types <code>A</code> et <code>B</code> sont tous deux des instructions et s'excluent mutuellement). <br><br><pre> <code class="plaintext hljs">\func Or-to-|| {AB : \Prop} (a-or-b : A `Or` B) : A || B | inl a =&gt; byLeft a | inr b =&gt; byRight</code> </pre> <br>  Rappelons √©galement que la particularit√© du m√©canisme des univers dans Coq est que si une d√©finition a √©t√© assign√©e √† l'univers <code>Prop</code> , il ne sera en aucun cas possible de l'utiliser dans le calcul.  Pour cette raison, les d√©veloppeurs de Coq eux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">-</a> m√™mes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne recommandent pas l'</a> utilisation de constructions propositionnelles, mais conseillent de les remplacer par des analogues de l'univers des ensembles, si possible.  Le m√©canisme des univers Arend ne pr√©sente pas cet inconv√©nient, c'est-√†-dire que dans certaines situations, il est possible d'utiliser des instructions dans les calculs.  Nous donnerons un exemple d'une telle situation lorsque nous discuterons de la mise en ≈ìuvre de l'algorithme de tri de liste. <br><br><h2>  1.4 Classes √† Arend </h2><br>  Notre objectif √©tant d'impl√©menter l'algorithme de tri le plus simple, il semble utile de vous familiariser avec l'impl√©mentation des ensembles ordonn√©s disponibles dans la biblioth√®que standard d'Arend. <br><br>  Dans Arend, les classes sont utilis√©es pour encapsuler les op√©rations et les axiomes qui d√©finissent les structures math√©matiques, ainsi que pour mettre en √©vidence les relations entre ces structures √† l'aide de l'h√©ritage.  Les classes sont √©galement des espaces de noms, √† l'int√©rieur desquels il est commode de placer des constructions et des th√©ories qui ont un sens appropri√©. <br><br>  La classe de base dont toutes les classes d'ordre dans Arend sont h√©rit√©es est la classe <code>BaseSet</code> , qui ne contient aucun membre autre que la d√©signation <code>E</code> pour l'ensemble h√¥te (c'est-√†-dire l'ensemble sur lequel les <code>BaseSet</code> descendantes <code>BaseSet</code> introduisent d√©j√† diverses op√©rations).  Consid√©rez la d√©finition de cette classe √† partir de la biblioth√®que Arend standard. <br><br><pre> <code class="plaintext hljs">\class BaseSet (E : \Set) -- ,    </code> </pre> <br>  Dans la d√©finition ci-dessus, la porteuse <code>E</code> d√©clar√©e param√®tre de classe.  On peut se demander s'il existe une diff√©rence entre la d√©finition de <code>BaseSet</code> ci-dessus et la d√©finition suivante, dans laquelle l'op√©rateur E est d√©fini comme un champ de classe? <br><br><pre> <code class="plaintext hljs">\class BaseSet' --      | E : \Set</code> </pre> <br>  Une r√©ponse l√©g√®rement inattendue est que dans Arend <i>il n'y a pas de diff√©rence</i> entre les deux d√©finitions dans le sens o√π tout param√®tre de classe (m√™me implicite) dans Arend est, en fait, son champ.  Ainsi, pour les deux impl√©mentations de <code>BaseSet</code> , on pourrait utiliser l'expression <code>xE</code> pour acc√©der au champ E. <code>BaseSet</code> toujours une diff√©rence entre les variantes ci-dessus de la d√©finition de <code>BaseSet</code> , mais elle est plus subtile, nous l'examinerons plus en d√©tail dans la section suivante lorsque nous discuterons des instances de classe ( instances de classe). <br><br>  L'op√©ration de tri d'une liste n'a de sens que si un ordre lin√©aire est sp√©cifi√© sur le type d'objets dans la liste.Par cons√©quent, nous consid√©rons d'abord les d√©finitions d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ensemble partiellement ordonn√© strict</a> et d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ensemble ordonn√© lin√©airement.</a> <br><br><pre> <code class="plaintext hljs">\class StrictPoset \extends BaseSet { | \infix 4 &lt; : E -&gt; E -&gt; \Prop | &lt;-irreflexive (x : E) : Not (x &lt; x) | &lt;-transitive (xyz : E) : x &lt; y -&gt; y &lt; z -&gt; x &lt; z } \class LinearOrder \extends StrictPoset { | &lt;-comparison (xyz : E) : x &lt; z -&gt; x &lt; y || y &lt; z | &lt;-connectedness (xy : E) : Not (x &lt; y) -&gt; Not (y &lt; x) -&gt; x = y }</code> </pre> <br>  Du point de vue de la th√©orie des types, les classes dans Arend peuvent √™tre consid√©r√©es comme des analogues des types sigma avec une syntaxe plus pratique pour les projections et les constructeurs.  ,  Arend-    -,       . <br><br>     ,     <i></i> .     ,      . ,  StrictPoset  <code>&lt;-irreflexive</code>  <code>&lt;-transitive</code>  ,   <code>E</code>  <code>&lt;</code> ‚Äî .     ,     (,  ,    )    ,       . <br><br>        ,   ,    .   ,   Arend  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ,  ,      .  ,       . ,     ,        ,     ,      .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>  : <br><br><pre> <code class="plaintext hljs">\class DecSet \extends BaseSet | decideEq (xy : E) : Dec (x = y)</code> </pre> <br>  <code>Dec</code>     ,  <code>Dec E</code>     ,  <code>E</code> ,      <code>E</code> ,   <code>E</code> . <br><br><pre> <code class="plaintext hljs">\data Dec (E : \Prop) | yes E | no (Not E)</code> </pre> <br> , ,  <code>Dec</code> (  decidable)   <code>Order.LinearOrder</code> .  Dec    , ,  ,     <code>trichotomy</code> , ,      <code>E</code> ,    &lt;.  , <code>Dec</code>      Comparable  Java. <br><br><pre> <code class="plaintext hljs">\class Dec \extends LinearOrder, DecSet { | trichotomy (xy : E) : (x = y) || (x &lt; y) || (y &lt; x) | &lt;-comparison xyz x&lt;z =&gt; {?} --   | &lt;-connectedness xyx/&lt;yy/&lt;x =&gt; {?} | decideEq xy =&gt; {?} }</code> </pre> <br>   <code>Dec</code>         <code>Dec</code> ,    ,   ,  ,            .     <code>Dec</code>    ,     . <br><br>       ,          <code>Dec</code> (        ).  <code>Dec</code> ,   Arend    ( <code>Dec</code>     <code>LinearOrder,</code>  <code>DecSet</code> ),  ,     (diamond inheritance). <br><br>       :                ,     (    ,       ). <br><br>    <code>Dec</code>   <code>Order.LinearOrder</code>   IDEA    (      [Ctrl]+[H]),   ,    . <br><br><img src="https://habrastorage.org/webt/zu/sd/p3/zusdp3ojbuxbuhs11ffqppfjm04.png"><br><br>              Arend (    IDEA    <code>BaseSet</code> ).   ,      . <br><br><h2> 1.5  ,  ,     . </h2><br>        <code>StrictPoset</code>     Nat.  Arend       ,     .       -,  ,    ,   - (   ),           . <br><br>         :   .             . <br><br><pre> <code class="plaintext hljs">data \infix 4 &lt; (ab : Nat) \with | zero, suc _ =&gt; zero&lt;suc_ | suc a, suc b =&gt; suc&lt;suc (a &lt; b) \lemma irreflexivity (x : Nat) (p : x &lt; x) : Empty | suc a, suc&lt;suc a&lt;a =&gt; irreflexivity a a&lt;a \lemma transitivity (xyz : Nat) (p : x &lt; y) (q : y &lt; z) : x &lt; z | zero, suc y', suc z', zero&lt;suc_, suc&lt;suc y'&lt;z' =&gt; zero&lt;suc_ | suc x', suc y', suc z', suc&lt;suc x'&lt;y', suc&lt;suc y'&lt;z' =&gt; suc&lt;suc (transitivity x' y' z' x'&lt;y' y'&lt;z')</code> </pre> <br>       <code>\func</code>   <code>\lemma</code> .      ,       ,        ,     .      ,   <code>\lemma</code>  ,        <code>\Prop</code> . <br><br>    <code>x'&lt;y'</code> ‚Äî    -,    <code>x' &lt; y'</code> .         - (.. ,       ,     ). <br><br>      (instance)  <code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Arend a plusieurs options de syntaxe diff√©rentes pour cela. La premi√®re fa√ßon d'instancier une classe est d'utiliser un mot-cl√© </font></font><code>\new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans n'importe quelle expression. Dans ce cas, une ¬´instance de classe anonyme¬ª sera cr√©√©e.</font></font><br><br><pre> <code class="plaintext hljs">\func NatOrder =&gt; \new StrictPoset { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br>  <code>StrictPoset { ‚Ä¶ }</code>       <code>\new</code> :       - <code>StrictPoset</code> .   -    , ,    ,        <code>\new</code>  .   <code>\new C { ‚Ä¶ }</code>   <code>C { ‚Ä¶ }</code> .       C,      C. ,    ,  <code>NatOrder</code>    <code>StrictPoset</code> . <br><br>    ,         .  ,       <code>StrictPoset Nat</code>      <code>StrictPoset { | E =&gt; Nat }</code> . ,        <code>NatOrder</code>  <code>StrictPoset</code> ,           (     ). <br><br>      <code>NatOrder</code>      <code>\cowith</code>    (          - ). <br><br><pre> <code class="plaintext hljs">\func NatOrder : StrictPoset \cowith { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br> , ,          <code>\instance.</code> <br><br><pre> <code class="plaintext hljs">\instance NatOrder : StrictPoset { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br>  Arend     ,     Haskell.   <code>NatOrder</code>    <code>\instance</code>    <code>\cowith</code>      ,           <code>StrictPoset</code> (    ). <br><br> ,    <code>BaseSet</code>    - E     (   ),      ,         E   .      . <br><br>  ,         Arend      .   Arend  ,            ,       (  ,  ¬´ <i> </i> ¬ª         <code>\classifying \field</code> ,    Arend      ).      : <br><br><ul><li> Arend                . ,  <code>X</code>   <code>StrictPoset</code> ,   <code>List X</code>         <code>List XE</code> . <br></li><li> Arend          . </li></ul><br>  ,    . ,         <code>\instance</code>    <code>StrictPoset</code>    ,     <code>Nat</code>    <code>Int</code> (   <code>NatOrder</code>  <code>IntOrder</code> ). <br><br> ,      <code>x &lt; y</code>      ,  x, y   ,    ,  x, y   .    Arend  ,     <code>NatOrder.&lt;</code> ,    ‚Äî <code>IntOrder.&lt;</code> . <br><br>    ,     . Arend ,   &lt;    <code>StrictPoset</code> ,       E. , Arend      <code>x&lt;y</code>          <code>StrictPoset</code> (  ),     E   .    ,    <code>&lt;</code>     . <br><br> ,                     Arend.        ,     <code>\use \coerce</code>  <i> </i>  .  Arend      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ‚Äî   ,   ,       .       -  ,    <code>\where</code> . <br><br>       .  <code>fromNat</code>         . <br><br><pre> <code class="plaintext hljs">\data Int | pos Nat | neg Nat \with { zero =&gt; pos zero } \where { \use \coerce fromNat (n : Nat) =&gt; pos n }</code> </pre> <br>    <code>\use \coerce</code>  <code>\func</code>   ,          .     ,         ,      (,     ,        ). <br><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> HoTT   </a>  JetBrains Research. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469569/">https://habr.com/ru/post/fr469569/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469551/index.html">VDS avec une carte vid√©o - nous en savons beaucoup sur les perversions</a></li>
<li><a href="../fr469555/index.html">Diffusion: Meetup Moscou Kubernetes # 6</a></li>
<li><a href="../fr469557/index.html">Generic Recycler View ou comment ne pas √©crire de code passe-partout</a></li>
<li><a href="../fr469561/index.html">Calcul de la racine carr√©e enti√®re</a></li>
<li><a href="../fr469567/index.html">Contexte: d√©tails sur l'iPhone 11, 11 Pro et la nouvelle Apple Watch apr√®s deux semaines de tests</a></li>
<li><a href="../fr469573/index.html">Linux Piter 2019: ce qui attend les invit√©s pour une conf√©rence Linux √† grande √©chelle et pourquoi ne pas la manquer</a></li>
<li><a href="../fr469575/index.html">Comment reprogrammer le mode veille: 30 jours tous les matins, je fais briller une lumi√®re verte brillante dans mes yeux</a></li>
<li><a href="../fr469577/index.html">Forensics de disque, forensics de m√©moire et forensics de log. Cadre de volatilit√© et autopsie. R√©solution de probl√®mes avec r0ot-mi. Partie 1</a></li>
<li><a href="../fr469581/index.html">Analyse de l'effet Picabu</a></li>
<li><a href="../fr469583/index.html">OpenVPN et Active Directory (Kerberos sans certificats utilisateur)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>