<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏹️ 🥐 🥒 Kami sedang melakukan proyek pembelajaran mesin dengan Python. Bagian 2 ✋🏻 💪🏿 🐁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mesin Pembelajaran Lengkap Walk-Through dengan Python: Bagian Dua 

 Menyusun semua bagian dari proyek pembelajaran mesin bisa rumit. Dalam seri artik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami sedang melakukan proyek pembelajaran mesin dengan Python. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/425907/"><img src="https://habrastorage.org/getpro/habr/post_images/225/910/6f3/2259106f3ccc19ae2b8b1ec9f316c4f2.png"><br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin Pembelajaran Lengkap Walk-Through dengan Python: Bagian Dua</a></i> <br><br>  Menyusun semua bagian dari proyek pembelajaran mesin bisa rumit.  Dalam seri artikel ini, kita akan melewati semua tahap implementasi proses pembelajaran mesin menggunakan data nyata, dan mencari tahu bagaimana berbagai teknik digabungkan satu sama lain. <br><br>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama,</a> kami membersihkan dan menyusun data, melakukan analisis eksplorasi, mengumpulkan serangkaian atribut untuk digunakan dalam model, dan menetapkan garis dasar untuk mengevaluasi hasil.  Dengan bantuan artikel ini kita akan belajar bagaimana menerapkan dalam Python dan membandingkan beberapa model pembelajaran mesin, melakukan penyetelan hyperparametric untuk mengoptimalkan model terbaik, dan mengevaluasi kinerja model akhir pada set data uji. <br><br>  Semua kode proyek ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di GitHub</a> , dan ini adalah buku catatan kedua yang terkait dengan artikel saat ini.  Anda dapat menggunakan dan memodifikasi kode sesuai keinginan! <br><a name="habracut"></a><br><h2>  Evaluasi Model dan Seleksi </h2><br>  Memo: Kami sedang mengerjakan tugas regresi terkontrol, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">informasi energi untuk bangunan di New York</a> untuk membuat model yang memprediksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Skor Bintang Energi</a> mana yang akan diterima gedung tertentu.  Kami tertarik pada keakuratan peramalan dan interpretabilitas model. <br><br>  Hari ini Anda dapat memilih dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak model pembelajaran mesin yang tersedia</a> , dan kelimpahan ini bisa menakutkan.  Tentu saja, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ulasan perbandingan</a> pada jaringan yang akan membantu Anda menavigasi ketika memilih suatu algoritma, tetapi saya lebih suka untuk mencoba beberapa dan melihat mana yang lebih baik.  Untuk sebagian besar, pembelajaran mesin didasarkan pada hasil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">empiris daripada teoritis</a> , dan hampir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak mungkin untuk memahami terlebih dahulu model mana yang lebih akurat</a> . <br><br>  Biasanya disarankan agar Anda mulai dengan model yang sederhana dan dapat ditafsirkan, seperti regresi linier, dan jika hasilnya tidak memuaskan, kemudian beralih ke metode yang lebih kompleks, tetapi biasanya lebih akurat.  Grafik ini (sangat anti-ilmiah) menunjukkan hubungan antara akurasi dan interpretabilitas dari beberapa algoritma: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a1/602/9a1/1a16029a1b75b5ba4022d477615f352f.png"><br>  <i>Interpretabilitas dan akurasi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> ).</i> <br><br>  Kami akan mengevaluasi lima model dengan berbagai tingkat kompleksitas: <br><br><ul><li>  Regresi linier. </li><li>  Metode tetangga terdekat k. </li><li>  "Hutan acak." </li><li>  Meningkatkan gradien. </li><li>  Metode vektor dukungan. </li></ul><br>  Kami tidak akan mempertimbangkan aparatur teoritis dari model ini, tetapi implementasinya.  Jika Anda tertarik pada teori, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar Pembelajaran Statistik</a> (tersedia gratis) atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembelajaran Mesin Langsung dengan Scikit-Learn dan TensorFlow</a> .  Dalam kedua buku, teorinya dijelaskan dengan sempurna dan efektivitas penggunaan metode yang disebutkan dalam bahasa R dan Python, masing-masing, ditampilkan. <br><br><h4>  Isi nilai yang hilang </h4><br>  Meskipun ketika kami membersihkan data, kami membuang kolom di mana lebih dari setengah nilai hilang, kami masih memiliki banyak nilai.  Model pembelajaran mesin tidak dapat bekerja dengan data yang hilang, jadi kita perlu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengisinya</a> . <br><br>  Pertama, kami mempertimbangkan data dan mengingat tampilannya: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-comment"><span class="hljs-comment"># Read in data into dataframes train_features = pd.read_csv('data/training_features.csv') test_features = pd.read_csv('data/testing_features.csv') train_labels = pd.read_csv('data/training_labels.csv') test_labels = pd.read_csv('data/testing_labels.csv') Training Feature Size: (6622, 64) Testing Feature Size: (2839, 64) Training Labels Size: (6622, 1) Testing Labels Size: (2839, 1)</span></span></code> </pre> <br>  Setiap nilai <code>NaN</code> adalah catatan yang hilang dalam data.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda dapat mengisinya dengan cara yang berbeda</a> , dan kami akan menggunakan metode imputasi median yang cukup sederhana, yang menggantikan data yang hilang dengan nilai rata-rata untuk kolom yang sesuai. <br><br>  Dalam kode di bawah ini, kita akan membuat objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scikit-Learn</a> Imputer dengan strategi median.  Kemudian kami melatihnya pada data pelatihan (menggunakan <code>imputer.fit</code> ), dan menerapkannya untuk mengisi nilai-nilai yang hilang dalam set pelatihan dan tes (menggunakan <code>imputer.transform</code> ).  Artinya, catatan yang hilang dalam <i>data uji</i> akan diisi dengan nilai median yang sesuai dari <i>data pelatihan</i> . <br><br>  Kami mengisi dan tidak melatih model pada data sebagaimana adanya, untuk menghindari masalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kebocoran data uji</a> ketika informasi dari dataset uji masuk ke pelatihan. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Create an imputer object with a median filling strategy imputer = Imputer(strategy='median') # Train on the training features imputer.fit(train_features) # Transform both training data and testing data X = imputer.transform(train_features) X_test = imputer.transform(test_features) Missing values in training features: 0 Missing values in testing features: 0</span></span></code> </pre> <br>  Sekarang semua nilai diisi, tidak ada celah. <br><br><h4>  Penskalaan Fitur </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penskalaan</a> adalah proses umum untuk mengubah rentang karakteristik.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini adalah langkah yang perlu</a> , karena tanda-tanda diukur dalam unit yang berbeda, yang berarti mereka mencakup rentang yang berbeda.  Ini sangat mendistorsi hasil algoritma seperti metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vektor dukungan</a> dan metode tetangga k-terdekat, yang memperhitungkan jarak antara pengukuran.  Dan penskalaan memungkinkan Anda untuk menghindari ini.  Meskipun metode seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">regresi linier dan "hutan acak"</a> tidak memerlukan penskalaan fitur, lebih baik untuk tidak mengabaikan langkah ini ketika membandingkan beberapa algoritma. <br><br>  Kami akan skala menggunakan setiap atribut ke rentang dari 0 hingga 1. Kami mengambil semua nilai atribut, pilih minimum dan membaginya dengan perbedaan antara maksimum dan minimum (rentang).  Metode penskalaan ini sering disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">normalisasi, dan cara utama lainnya adalah standardisasi</a> . <br><br>  Proses ini mudah diterapkan secara manual, jadi kami <code>MinMaxScaler</code> menggunakan objek MinMaxScaler dari Scikit-Learn.  Kode untuk metode ini identik dengan kode untuk mengisi nilai yang hilang, hanya penskalaan yang digunakan alih-alih menempel.  Ingat bahwa kita mempelajari model hanya pada set pelatihan, dan kemudian kita mengubah semua data. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Create the scaler object with a range of 0-1 scaler = MinMaxScaler(feature_range=(0, 1)) # Fit on the training data scaler.fit(X) # Transform both the training and testing data X = scaler.transform(X) X_test = scaler.transform(X_test)</span></span></code> </pre> <br>  Sekarang, setiap atribut memiliki nilai minimum 0, dan maksimum 1. Mengisi nilai-nilai yang hilang dan penskalaan atribut - dua tahap ini diperlukan di hampir semua proses pembelajaran mesin. <br><br><h4>  Kami menerapkan model pembelajaran mesin di Scikit-Learn </h4><br>  Setelah semua pekerjaan persiapan, proses membuat, melatih, dan menjalankan model relatif sederhana.  Kita akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka Scikit-Learn</a> dalam Python, yang didokumentasikan dengan indah dan dengan sintaksis yang rumit untuk membangun model.  Dengan mempelajari cara membuat model di Scikit-Learn, Anda dapat dengan cepat mengimplementasikan semua jenis algoritma. <br><br>  Kami akan mengilustrasikan proses penciptaan, pelatihan ( <code>.fit</code> ) dan pengujian ( <code>.predict</code> ) menggunakan gradient boosting: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.ensemble <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GradientBoostingRegressor <span class="hljs-comment"><span class="hljs-comment"># Create the model gradient_boosted = GradientBoostingRegressor() # Fit the model on the training data gradient_boosted.fit(X, y) # Make predictions on the test data predictions = gradient_boosted.predict(X_test) # Evaluate the model mae = np.mean(abs(predictions - y_test)) print('Gradient Boosted Performance on the test set: MAE = %0.4f' % mae) Gradient Boosted Performance on the test set: MAE = 10.0132</span></span></code> </pre> <br>  Hanya satu baris kode untuk membuat, melatih, dan menguji.  Untuk membangun model lain, kami menggunakan sintaks yang sama, hanya mengubah nama algoritma. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/215/58f/ab4/21558fab42e2669b96132dff6a5b2691.png"><br><br>  Untuk mengevaluasi model secara objektif, kami menghitung level dasar menggunakan nilai median tujuan dan mendapat 24,5.  Dan hasilnya jauh lebih baik, sehingga masalah kita dapat diselesaikan dengan menggunakan pembelajaran mesin. <br><br>  Dalam kasus kami, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peningkatan gradien</a> (MAE = 10.013) ternyata sedikit lebih baik daripada "hutan acak" (10.014 MAE).  Meskipun hasil ini tidak dapat dianggap sepenuhnya jujur, karena untuk hyperparameter kami lebih banyak menggunakan nilai default.  Keefektifan model sangat tergantung pada pengaturan ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terutama dalam metode vektor dukungan</a> .  Namun demikian, berdasarkan hasil ini, kami akan memilih peningkatan gradien dan mulai mengoptimalkannya. <br><br><h2>  Optimalisasi model hyperparametric </h2><br>  Setelah memilih model, Anda dapat mengoptimalkannya agar tugas dapat diselesaikan dengan menyesuaikan parameter hiper. <br><br>  Tapi pertama-tama, mari kita pahami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa itu hyperparameters dan bagaimana mereka berbeda dari parameter biasa</a> ? <br><br><ul><li>  Hyperparameters model dapat dianggap sebagai pengaturan algoritma, yang kami atur sebelum dimulainya pelatihannya.  Misalnya, hyperparameter adalah jumlah pohon di "hutan acak", atau jumlah tetangga dalam metode tetangga k-terdekat. </li><li>  Parameter model - apa yang dia pelajari selama pelatihan, misalnya, bobot dalam regresi linier. </li></ul><br>  Dengan mengendalikan hiperparameter, kami memengaruhi hasil model, mengubah keseimbangan antara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pendidikan kurang dan pelatihan ulang</a> .  Under learning adalah situasi di mana modelnya tidak cukup kompleks (memiliki tingkat kebebasan yang terlalu sedikit) untuk mempelajari korespondensi tanda dan tujuan.  Model yang kurang terlatih memiliki bias yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tinggi</a> , yang dapat diperbaiki dengan menyulitkan model tersebut. <br><br>  Pelatihan ulang adalah situasi di mana model pada dasarnya mengingat data pelatihan.  Model yang dilatih ulang memiliki varian yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tinggi</a> , yang dapat disesuaikan dengan membatasi kompleksitas model melalui regularisasi.  Kedua model yang kurang terlatih dan dilatih ulang tidak akan dapat menggeneralisasikan data uji dengan baik. <br><br>  Kesulitan dalam memilih hyperparameters yang tepat adalah bahwa untuk setiap tugas akan ada satu set optimal yang unik.  Oleh karena itu, satu-satunya cara untuk memilih pengaturan terbaik adalah dengan mencoba berbagai kombinasi pada dataset baru.  Untungnya, Scikit-Learn memiliki sejumlah metode yang memungkinkan Anda mengevaluasi hiperparameter secara efektif.  Selain itu, proyek-proyek seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TPOT</a> berusaha untuk mengoptimalkan pencarian hyperparameter menggunakan pendekatan seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemrograman genetik</a> .  Dalam artikel ini, kami membatasi diri untuk menggunakan Scikit-Learn. <br><br><h4>  Periksa ulang pencarian acak </h4><br>  Mari kita terapkan metode penyetelan hyperparameter yang disebut pencarian lintas-validasi acak: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pencarian acak</a> - teknik untuk memilih hiperparameter.  Kami mendefinisikan kisi, dan kemudian secara acak memilih berbagai kombinasi darinya, berbeda dengan pencarian kisi, di mana kami berturut-turut mencoba setiap kombinasi.  Ngomong-ngomong, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencarian acak bekerja hampir seperti halnya pencarian grid</a> , tetapi jauh lebih cepat. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemeriksaan silang</a> adalah cara mengevaluasi kombinasi hyperparameter yang dipilih.  Alih-alih membagi data ke dalam set pelatihan dan tes, yang mengurangi jumlah data yang tersedia untuk pelatihan, kami akan menggunakan validasi silang k-block (K-Fold Cross Validation).  Untuk melakukan ini, kita akan membagi data pelatihan menjadi blok k, dan kemudian menjalankan proses iteratif, di mana kita pertama-tama melatih model pada blok k-1, dan kemudian membandingkan hasilnya ketika belajar di blok k-th.  Kami akan mengulangi proses k kali, dan pada akhirnya kami akan mendapatkan nilai kesalahan rata-rata untuk setiap iterasi.  Ini akan menjadi penilaian akhir. </li></ul><br>  Berikut ini adalah ilustrasi grafik validasi silang k-block pada k = 5: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e17/94b/51e/e1794b51eded0314afd9f594a8e9ee5e.png"><br><br>  Seluruh proses pencarian acak validasi silang terlihat seperti ini: <br><br><ol><li>  Kami menetapkan kotak hyperparameter. </li><li>  Pilih kombinasi hiperparameter secara acak. </li><li>  Buat model menggunakan kombinasi ini. </li><li>  Kami mengevaluasi hasil model menggunakan k-block cross-validation. </li><li>  Kami memutuskan hyperparameter mana yang memberikan hasil terbaik. </li></ol><br>  Tentu saja, semua ini dilakukan tidak secara manual, tetapi menggunakan <code>RandomizedSearchCV</code> dari Scikit-Learn! <br><br><h4>  Penyimpangan kecil: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode peningkatan gradien</a> </h4><br>  Kami akan menggunakan model regresi berbasis gradien boost.  Ini adalah metode kolektif, yaitu, model terdiri dari banyak "pelajar yang lemah", dalam hal ini, dari pohon keputusan yang terpisah.  Jika siswa belajar dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma</a> paralel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti "hutan acak"</a> , dan kemudian hasil prediksi dipilih dengan memilih, maka dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">meningkatkan algoritma</a> seperti meningkatkan gradien, siswa belajar secara berurutan, dan masing-masing dari mereka "berfokus" pada kesalahan yang dibuat oleh pendahulunya. <br><br>  Dalam beberapa tahun terakhir, meningkatkan algoritma telah menjadi populer dan sering menang dalam kompetisi pembelajaran mesin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gradient boosting</a> adalah salah satu implementasi dimana Gradient Descent digunakan untuk meminimalkan biaya fungsi.  Implementasi peningkatan gradien di Scikit-Learn dianggap tidak seefektif di perpustakaan lain, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XGBoost</a> , tetapi bekerja dengan baik pada dataset kecil dan memberikan perkiraan yang cukup akurat. <br><br><h4>  Kembali ke pengaturan hyperparametric </h4><br>  Dalam regresi menggunakan gradient boosting, ada banyak hiperparameter yang perlu dikonfigurasi, untuk detail saya merujuk Anda ke dokumentasi Scikit-Learn.  Kami akan mengoptimalkan: <br><br><ul><li>  <code>loss</code> : meminimalkan fungsi loss; </li><li>  <code>n_estimators</code> : jumlah pohon keputusan lemah yang digunakan (pohon keputusan); </li><li>  <code>max_depth</code> : kedalaman maksimum setiap pohon keputusan; </li><li>  <code>min_samples_leaf</code> : jumlah minimum contoh yang harus ada di simpul daun dari pohon keputusan; </li><li>  <code>min_samples_split</code> : jumlah minimum contoh yang diperlukan untuk membagi simpul pohon keputusan; </li><li>  <code>max_features</code> : Jumlah maksimum fitur yang digunakan untuk memisahkan node. </li></ul><br>  Tidak yakin apakah ada yang benar-benar mengerti cara kerjanya, dan satu-satunya cara untuk menemukan kombinasi terbaik adalah dengan mencoba berbagai opsi. <br><br>  Dalam kode ini, kami membuat kisi hiperparameter, lalu membuat objek <code>RandomizedSearchCV</code> dan mencari menggunakan 4-blok cross-validation untuk 25 kombinasi hiperparameter yang berbeda: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Loss function to be optimized loss = ['ls', 'lad', 'huber'] # Number of trees used in the boosting process n_estimators = [100, 500, 900, 1100, 1500] # Maximum depth of each tree max_depth = [2, 3, 5, 10, 15] # Minimum number of samples per leaf min_samples_leaf = [1, 2, 4, 6, 8] # Minimum number of samples to split a node min_samples_split = [2, 4, 6, 10] # Maximum number of features to consider for making splits max_features = ['auto', 'sqrt', 'log2', None] # Define the grid of hyperparameters to search hyperparameter_grid = {'loss': loss, 'n_estimators': n_estimators, 'max_depth': max_depth, 'min_samples_leaf': min_samples_leaf, 'min_samples_split': min_samples_split, 'max_features': max_features} # Create the model to use for hyperparameter tuning model = GradientBoostingRegressor(random_state = 42) # Set up the random search with 4-fold cross validation random_cv = RandomizedSearchCV(estimator=model, param_distributions=hyperparameter_grid, cv=4, n_iter=25, scoring = 'neg_mean_absolute_error', n_jobs = -1, verbose = 1, return_train_score = True, random_state=42) # Fit on the training data random_cv.fit(X, y) After performing the search, we can inspect the RandomizedSearchCV object to find the best model: # Find the best combination of settings random_cv.best_estimator_ GradientBoostingRegressor(loss='lad', max_depth=5, max_features=None, min_samples_leaf=6, min_samples_split=6, n_estimators=500)</span></span></code> </pre> <br>  Anda dapat menggunakan hasil ini untuk pencarian kisi dengan memilih parameter untuk kisi yang dekat dengan nilai optimal ini.  Tetapi penyempurnaan lebih lanjut tidak mungkin meningkatkan model secara signifikan.  Ada aturan umum: konstruksi fitur yang kompeten akan memiliki dampak yang jauh lebih besar pada keakuratan model daripada pengaturan hyperparameter yang paling mahal.  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hukum penurunan profitabilitas dalam kaitannya dengan pembelajaran mesin</a> : merancang atribut memberikan pengembalian tertinggi, dan penyetelan hyperparametric hanya membawa manfaat sederhana. <br><br>  Untuk mengubah jumlah estimator (pohon keputusan) sambil mempertahankan nilai-nilai hiperparameter lainnya, satu percobaan dapat dilakukan yang akan menunjukkan peran pengaturan ini.  Implementasinya diberikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , tetapi inilah hasilnya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aca/18e/d51/aca18ed519f22d26c6b78af3324b8614.png"><br><br>  Ketika jumlah pohon yang digunakan oleh model meningkat, tingkat kesalahan selama pelatihan dan pengujian menurun.  Tetapi kesalahan belajar berkurang jauh lebih cepat, dan sebagai hasilnya, model dilatih ulang: itu menunjukkan hasil yang sangat baik pada data pelatihan, tetapi bekerja lebih buruk pada data uji. <br><br>  Pada data uji, akurasi selalu menurun (karena model melihat jawaban yang benar untuk dataset pelatihan), tetapi penurunan yang signifikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menunjukkan pelatihan ulang</a> .  Masalah ini dapat diatasi dengan meningkatkan jumlah data pelatihan atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengurangi kompleksitas model menggunakan hyperparameters</a> .  Di sini kami tidak akan menyentuh hyperparameters, tetapi saya sarankan Anda selalu memperhatikan masalah pelatihan ulang. <br><br>  Untuk model akhir kami, kami akan mengambil 800 evaluator, karena ini akan memberi kami tingkat kesalahan terendah dalam validasi silang.  Sekarang coba modelnya! <br><br><h2>  Penilaian Menggunakan Data Uji </h2><br>  Sebagai orang yang bertanggung jawab, kami memastikan bahwa model kami sama sekali tidak mendapatkan akses ke data uji selama pelatihan.  Oleh karena itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kita dapat menggunakan keakuratan ketika bekerja dengan data uji sebagai indikator</a> kualitas model ketika dimasukkan ke tugas nyata. <br><br>  Kami memberi makan data uji model dan menghitung kesalahan.  Berikut ini adalah perbandingan hasil dari algoritma peningkatan gradien default dan model khusus kami: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Make predictions on the test set using default and final model default_pred = default_model.predict(X_test) final_pred = final_model.predict(X_test) Default model performance on the test set: MAE = 10.0118. Final model performance on the test set: MAE = 9.0446.</span></span></code> </pre> <br>  Tuning Hyperparametric membantu meningkatkan akurasi model sekitar 10%.  Bergantung pada situasinya, ini bisa menjadi peningkatan yang sangat signifikan, tetapi butuh banyak waktu. <br><br>  Anda dapat membandingkan waktu pelatihan untuk kedua model menggunakan perintah magic <code>%timeit</code> di Notebook Jupyter.  Pertama, ukur durasi default model: <br><br><pre> <code class="python hljs">%%timeit -n <span class="hljs-number"><span class="hljs-number">1</span></span> -r <span class="hljs-number"><span class="hljs-number">5</span></span> default_model.fit(X, y) <span class="hljs-number"><span class="hljs-number">1.09</span></span> s ± <span class="hljs-number"><span class="hljs-number">153</span></span> ms per loop (mean ± std. dev. of <span class="hljs-number"><span class="hljs-number">5</span></span> runs, <span class="hljs-number"><span class="hljs-number">1</span></span> loop each)</code> </pre> <br>  Satu detik untuk belajar sangat layak.  Tetapi model yang disetel tidak begitu cepat: <br><br><pre> <code class="python hljs">%%timeit -n <span class="hljs-number"><span class="hljs-number">1</span></span> -r <span class="hljs-number"><span class="hljs-number">5</span></span> final_model.fit(X, y) <span class="hljs-number"><span class="hljs-number">12.1</span></span> s ± <span class="hljs-number"><span class="hljs-number">1.33</span></span> s per loop (mean ± std. dev. of <span class="hljs-number"><span class="hljs-number">5</span></span> runs, <span class="hljs-number"><span class="hljs-number">1</span></span> loop each)</code> </pre> <br>  Situasi ini menggambarkan aspek mendasar dari pembelajaran mesin: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini semua tentang kompromi</a> .  Penting untuk memilih keseimbangan antara akurasi dan interpretabilitas, antara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpindahan dan dispersi</a> , antara akurasi dan waktu operasi, dan sebagainya.  Kombinasi yang tepat sepenuhnya ditentukan oleh tugas tertentu.  Dalam kasus kami, peningkatan 12 kali lipat dalam durasi kerja dalam hal relatif adalah besar, tetapi secara absolut tidak signifikan. <br><br>  Kami mendapatkan hasil peramalan akhir, sekarang mari kita menganalisisnya dan mencari tahu apakah ada penyimpangan yang nyata.  Di sebelah kiri adalah grafik kerapatan nilai yang diprediksi dan nyata, di sebelah kanan adalah histogram kesalahan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/817/ea7/f23/817ea7f2371b83ff0ae6ae5fa02b5a1e.png" width="350"><img src="https://habrastorage.org/getpro/habr/post_images/f49/f42/5cc/f49f425cc56d717a1e75b9478d1a24d1.png" width="340"><br><br>  Perkiraan model mengulangi distribusi nilai-nilai nyata dengan baik, sedangkan pada data pelatihan, puncak kepadatan terletak lebih dekat dengan nilai median (66) daripada ke puncak kepadatan nyata (sekitar 100).  Kesalahan memiliki distribusi yang hampir normal, meskipun ada beberapa nilai negatif besar ketika perkiraan model sangat berbeda dari data nyata.  Pada artikel selanjutnya, kita akan memeriksa interpretasi hasil secara lebih rinci. <br><br><h2>  Kesimpulan </h2><br>  Dalam artikel ini, kami memeriksa beberapa tahap pemecahan masalah pembelajaran mesin: <br><br><ul><li>  Mengisi nilai yang hilang dan fitur penskalaan. </li><li>  Evaluasi dan perbandingan hasil beberapa model. </li><li>  Tuning hiperparametrik menggunakan pencarian grid acak dan validasi silang. </li><li>  Evaluasi model terbaik menggunakan data uji. </li></ul><br>  Hasil menunjukkan bahwa kita dapat menggunakan pembelajaran mesin untuk memprediksi Skor Energy Star berdasarkan statistik yang tersedia.  Dengan bantuan peningkatan gradien, kesalahan 9,1 dicapai pada data uji.  Penyesuaian Hyperparametric dapat sangat meningkatkan hasil, tetapi dengan biaya perlambatan yang signifikan.  Ini adalah salah satu dari banyak trade-off untuk dipertimbangkan dalam pembelajaran mesin. <br><br>  Pada artikel selanjutnya, kami akan mencoba mencari tahu bagaimana model kami bekerja.  Kami juga akan melihat faktor-faktor utama yang mempengaruhi Skor Bintang Energi.  Jika kita tahu bahwa model itu akurat, maka kita akan mencoba memahami mengapa model itu memprediksi dengan cara ini dan apa yang dikatakannya tentang masalah itu sendiri. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425907/">https://habr.com/ru/post/id425907/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425897/index.html">Fitur menggunakan perpustakaan RxJs dalam sistem perbankan online</a></li>
<li><a href="../id425899/index.html">Bukit atau benteng semut? Saya sedang membangun rumah untuk harga sebuah apartemen. 1 bagian</a></li>
<li><a href="../id425901/index.html">Stasiun cuaca di Arduino dari A hingga Z. Bagian 1</a></li>
<li><a href="../id425903/index.html">Holiday datang kepada kami: SCRF menggandakan pita ISM 868 MHz</a></li>
<li><a href="../id425905/index.html">Cara menulis kode assembler dengan instruksi yang tumpang tindih (teknik lain untuk mengaburkan bytecode)</a></li>
<li><a href="../id425911/index.html">Transfer cloud CRM ke versi kotak</a></li>
<li><a href="../id425915/index.html">Bagaimana komunikasi lintas batas dapat menggantikan lampu lalu lintas dan mempersingkat cara bekerja</a></li>
<li><a href="../id425917/index.html">Justice fighter mencegah Waymo mematenkan teknologi kunci Lidar</a></li>
<li><a href="../id425919/index.html">Peta segi enam di Unity: menyimpan dan memuat, tekstur, jarak</a></li>
<li><a href="../id425921/index.html">Pertemuan komunitas .NET di CLRium # 4 + online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>