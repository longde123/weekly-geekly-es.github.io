<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏻 👨🏻‍🏫 👦🏼 “Kami bahkan tidak mencoba menjalankan kode lama, kami pada prinsipnya tidak memiliki tugas seperti itu” - Roman Elizarov tentang pengembangan Kotlin 😤 👨🏾‍🏭 👨🏼‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda ingin mengetahui sesuatu, pelajari yang terbaik dari yang terbaik. Hari ini, pertanyaan saya dijawab oleh dewa Corutin dan konkurensi, Roma ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>“Kami bahkan tidak mencoba menjalankan kode lama, kami pada prinsipnya tidak memiliki tugas seperti itu” - Roman Elizarov tentang pengembangan Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/421607/">  Jika Anda ingin mengetahui sesuatu, pelajari yang terbaik dari yang terbaik.  Hari ini, pertanyaan saya dijawab oleh dewa Corutin dan konkurensi, Roma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">elizarov</a> Elizarov.  Kami berbicara tidak hanya tentang Kotlin, seperti yang mungkin Anda pikirkan, tetapi juga tentang banyak topik terkait: <br><br><ul><li>  Golang dan goroutine; </li><li>  JavaScript dan penerapannya untuk proyek-proyek serius; </li><li>  Java dan Project Loom; </li><li>  pemrograman olimpiade di Kotlin; </li><li>  cara belajar pemrograman dengan benar; </li><li>  dan hal-hal menarik lainnya. </li></ul><br><img src="https://habrastorage.org/webt/xh/ux/9l/xhux9llonplkxeenzbn6dic-z6a.jpeg"><br><a name="habracut"></a><br><h1>  Kotlin - bagus! </h1><br><p>  <strong>Hai</strong>  <strong>Pertama, beberapa kata tentang diri Anda.</strong>  <strong>Apakah Anda sudah lama melakukan Kotlin?</strong> <br></p><br><p>  Saya memiliki sejarah panjang dengan Kotlin.  Pada 2010, Kotlin memulai sebagai proyek di JetBrains, tempat saya tidak bekerja saat itu.  Tetapi Max Shafirov (dia kemudian terlibat di Kotlin dan merupakan salah satu penggagas gerakan ini di dalam JetBrains) mengundang saya untuk menjadi ahli eksternal dan melihat desain dan komentar.  Awalnya, bahasa ini dirancang untuk menyelesaikan masalahnya, karena JetBrains memiliki basis kode Java sendiri yang besar, dengan masalah yang dapat dipahami yang selalu ada dalam kode tersebut, dan saya ingin membuat bahasa itu sendiri sehingga kode saya dapat ditulis dengan lebih menyenangkan, efisien, dengan lebih sedikit kesalahan.  Lakukan saja modernisasi.  Secara alami, ini dengan cepat tumbuh menjadi gagasan bahwa karena kita memiliki masalah seperti itu, itu berarti bahwa orang lain memiliki masalah seperti itu, dan mereka membutuhkan konfirmasi dari orang lain bahwa mereka berjalan dengan benar. <br><br>  Saya diundang sebagai ahli untuk melihat dan membandingkan apa yang terjadi dengan apa yang dibutuhkan.  Tentang nullability - saya bersikeras bahwa ini harus dilakukan, karena pada saat itu jelas bagi saya bahwa jika Anda menulis di Jawa, ada banyak masalah, tetapi nullability adalah masalah utama yang terus-menerus Anda temui. <br><br>  Saya tidak berpartisipasi dalam pekerjaan tim, saya hanya melirik secara berkala, berpartisipasi dalam kompetisi di Kotlin (Piala Kotlin).  Saya telah bersaing sepanjang hidup saya, tetapi bahkan kemudian saya tidak berpartisipasi secara aktif.  Misalnya, saya tidak akan mencapai final kompetisi seperti Facebook Hacker Cup, bentuknya tidak sama karena saya tidak lagi berpartisipasi dalam kompetisi secara berkelanjutan.  Dan saya ambil bagian dalam Piala Kotlin dan, karena tidak menarik banyak penonton, saya dengan mudah mencapai final. <br><br>  Pada waktu itu (2012-2013), Kotlin adalah pemandangan yang menyedihkan dari sudut pandang penyetelan, karena semuanya melambat di sana.  Sejak itu, tim telah melakukan pekerjaan dengan baik.  Saya bergabung dengan tim dua tahun lalu, tepat setelah rilis 1.0 dan sebelum Google secara resmi mengenali bahasa tersebut.  Sebagai sebuah tim, saya mengambil semua jenis asinkron dan coroutine, hanya karena ternyata saya memiliki pengalaman yang tepat, saya banyak bekerja di berbagai sistem perusahaan besar di DevExperts, dan ada banyak asinkron dan komunikasi.  Karena itu, saya membayangkan dengan baik bidang masalah - apa yang perlu diperbaiki dan apa yang menyakiti orang.  Ini sangat sesuai dengan kebutuhan Kotlin, karena tidak hanya menyakitkan bagi kita.  Itu menyakitkan semua orang.  Bahkan JVM memulai Project Loom, yang seolah mengisyaratkan bahwa itu menyakiti semua orang.  Saya masih berurusan dengan perpustakaan Kotlin, dan fokus utama kami adalah pada semua jenis aplikasi dan asinkron yang terhubung. <br></p><br><p>  <strong>Artinya, Anda terutama terlibat dalam perpustakaan, bukan kompiler, dan hanya itu untuk itu?</strong> <br></p><br><p>  Tidak, saya sedang melakukan compiler sejauh.  Saya berkomunikasi dengan teman-teman, dan tim perpustakaan kami mengatur semua yang mereka lakukan di kompiler.  Kami juga pelanggan, kami membuat banyak pencarian fitur ketika kami menemukan beberapa kekurangan, dan kami adalah penguji dari baris pertama dari segala sesuatu yang baru yang diluncurkan. <br></p><br><p>  <strong>Ternyata, jika Anda masuk ke YouTrack, menyaring dengan Anda, Anda dapat menemukan banyak hal menarik.</strong> <br></p><br><p>  Ya, Anda dapat menemukan banyak tugas, karena saya selalu menemukan sesuatu. <br></p><br><p>  <strong>Anda menyebutkan Project Loom.</strong>  <strong>Itu dibuat oleh orang yang membuat Quasar.</strong>  <strong>Dari samping terlihat sangat lucu, saya hanya ingin menulis artikel tentang Habra tentang Loom.</strong>  <strong>Bisakah Anda memberi tahu saya sesuatu tentang dia?</strong> <br></p><br><p>  Saya melihat presentasi, idenya jelas.  Semua orang membutuhkan coroutine dan pemrograman asinkron.  Sebagai contoh, di masa lalu di JPoint, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">orang</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">orang dari Alibaba</a> mengatakan bagaimana mereka meretas JVM dan mengacaukan hotspot, hanya menggulung di patch yang mereka bahkan tidak menulis, tetapi beberapa orang sebelum mereka.  Mereka kemudian menggergaji diri mereka sendiri.  Laporan yang bagus.  Saya sangat merekomendasikannya. <br></p><br><p>  <strong>Apakah Anda merekomendasikan melakukan ini?</strong> <br></p><br><p>  Jadi <strong>perlu</strong> dilakukan di perusahaan.  Setiap perusahaan besar, di atas ukuran tertentu, ketika beberapa ribu orang mulai bekerja untuk Anda (dan untuk orang yang kurang), pertahankan hack OpenJDK Anda.  Dan tentu saja, jika Anda memiliki kasus pengguna yang kritis terhadap bisnis, mengapa tidak meretas sesuatu untuk Anda sendiri, saya tidak melihat masalah besar dalam hal ini.  Bukannya saya merekomendasikannya, tetapi saya harus.  Jika tidak ada utas ringan di HotSpot, lalu apa yang harus saya lakukan?  Ini, pada kenyataannya, menunjukkan bahwa orang membutuhkan apa yang sudah matang.  Dan umpan balik yang kami dapatkan di coroutine juga mengatakan bahwa ya, sudah lewat waktu, orang-orang membutuhkan stream yang ringan, orang-orang membutuhkan kereta yuzkeys untuk stream yang ringan.  Fakta bahwa mereka seharusnya didukung di JDK sudah lama tertunda, dan dalam hal ini saya tidak ragu bahwa ketika Loom datang ke produksi cepat atau lambat, itu akan diminati.  Ada orang yang membutuhkannya.  Ada orang yang bahkan demi patch HotSpot ini. <br></p><br><p>  <strong>Saya melihat masalah umum - Anda memiliki semacam server web, banyak orang mengetuknya, dan mulai memblokir pada utas.</strong> <br></p><br><p>  Ini adalah masalah yang cukup umum.  Dan server web, dan server aplikasi, dan backend.  Jika Anda melihat presentasi yang sama dari Alibaba, mengapa hal ini diperlukan, maka mereka tidak memiliki server web, mereka memiliki arsitektur perusahaan klasik, mereka memiliki semua jenis layanan yang ditulis pada Java backend, layanan ini sedang dimuat.  Saya bekerja dengan DevExperts dengan cara yang sama: layanan sedang dimuat, Anda menerima permintaan yang sama sekali tidak Anda proses - di dunia modern Anda memiliki semua yang terhubung.  Dan Anda tidak memroses permintaan ini sendiri, tetapi Anda menghubungi 100500 semua layanan lain dan menunggu mereka merespons.  Dan jika layanan ini lambat, maka Anda memiliki banyak utas menunggu.  Anda tidak dapat memiliki puluhan ribu aliran tunggu ini.  Dan hanya karena beberapa omong kosong Anda mendapatkan yang berikut: satu layanan yang Anda gunakan melambat, dan banyak utas sedang berdiri dan menunggu.  Dan sekarang ini adalah masalah yang sangat besar. <br><br>  Salah satu alasan mengapa orang bermigrasi ke Go secara besar-besaran bukan karena bahasanya bagus, tetapi karena ada aliran yang ringan di luar kotak, dan tidak ada masalah seperti itu: goroutine dapat menunggu, dan mereka tidak mengeluarkan biaya.  Di Alibaba yang sama, solusi yang mereka implementasikan umumnya bodoh dari semua yang bodoh.  Mereka tidak terlalu ringan dalam arti bahwa mereka mengalokasikan satu tumpukan besar 2 megabyte untuk masing-masing coroutine, meretas HotSpot sehingga tumpukan ini dapat diaktifkan.  Mereka menghemat aliran fisik, tetapi tidak menyimpan tumpukan.  Dan bagi mereka, solusinya bekerja - omong-omong, sangat sederhana, mereka memiliki patch HotSpot, seperti yang saya pahami, tidak terlalu besar.  Orang-orang dari Loom memulai sesuatu yang lebih global.  Mereka memutuskan untuk menghemat tidak hanya pada stream fisik, tetapi juga pada stack, agar tidak menghabiskan 2 megabyte per stream.  Dalam prototipe, tumpukan saat ini melewati HotSpot, itu disalin ke dalam struktur pinggul kecil.  Dan mereka dapat menggunakan kembali tumpukan fisik ini untuk tujuan lain. <br></p><br><p>  <strong>Tetapi ada peretasan yang licik: ketika Anda kembali ke kinerja, mereka menyalinnya tidak semua, tetapi hanya yang paling atas.</strong> <br></p><br><p>  Ya, ada mobil peretasan dan optimisasi.  Apa yang akhirnya keluar dari itu sangat sulit untuk dikatakan.  Karena pada contoh pendekatan dengan penyalinan, masalah berikut segera muncul: apa yang harus dilakukan dengan panggilan asli?  Dari dalam panggilan asli, Anda tidak dapat lagi menyalin tumpukan panggilan asli.  Pendekatan Alibaba tidak memiliki masalah seperti itu.  Asli, bukan asli - apa bedanya, Anda baru saja melepaskan tumpukan itu dan meninggalkannya sendiri, mengambil tumpukan lain, semuanya berfungsi.  Dan masih terlalu dini untuk mengatakan apakah itu akan berhasil atau tidak, kadang-kadang Anda bisa hidup dengan tumpukan asli ini, kadang-kadang Anda tidak bisa - pada tahap ini terlalu dini untuk mengatakan.  Misalnya, cara penerapannya di Go adalah mekanisme yang sama sekali berbeda.  Saat Anda mengeksekusi kode gosh, tumpukan gosh kecil digunakan.  Dengan demikian, ketika sebuah gosh runtime memanggil suatu fungsi, ia akan melihat seberapa banyak kebutuhan stack.  Jika tumpukan saat ini tidak cukup, itu akan dialokasikan kembali - meningkatkan ukuran tumpukan yang dipilih.  Jika, karenanya, Anda membuat panggilan asli, maka mereka sudah mengambil beberapa tumpukan asli besar dari kumpulan tertentu dan menggunakannya. <br></p><br><p>  <strong>Dan untuk kode gosh juga?</strong> <br></p><br><p>  Itu tidak masalah.  Mereka hanya dapat beralih ke tumpukan asli yang besar jika Anda perlu memanggil beberapa fungsi eksternal, yang tidak jelas berapa banyak tumpukan yang dibutuhkan.  Dan ketika Anda mengeksekusi kode gosh, Anda tahu berapa banyak tumpukan yang dibutuhkan, sehingga kami dapat menjalankannya di tumpukan kecil.  Ini adalah pendekatan yang sangat berbeda.  Jangan menyalin, tetapi segera jalankan di tumpukan kecil.  Faktanya, tidak ada banyak perbedaan antara pendekatan-pendekatan ini sampai Anda sesekali tertidur. <br><br>  Kami terus-menerus ditanya pertanyaan: “Apa yang lebih cepat?  Apa yang cocok?  Bagaimana Anda melakukannya di coroutine? "  Kami di coroutine tidak meretas JVM.  Tujuan kami adalah agar ini bekerja di bawah JVM normal.  Dan agar Android bekerja juga.  Ada ART sendiri, yang juga tidak tahu apa-apa tentang coroutine.  Jadi, tentu saja, kita harus membuat byte dengan pena, yang melakukan sesuatu yang sangat mirip dengan menyalin tumpukan yang dilakukan Loom, hanya saja kita melakukannya dalam bytecode.  Kami mengambilnya ketika sudah terlambat.  Ambil setumpuk, bersantai, dan salin ke pinggul.  Kami tidak di runtime yang akan melakukan ini untuk kami, kami telah menghasilkan bytecode yang melakukan ini.  Ini mempertahankan dan mengembalikan keadaan coroutine.  Karena kami tidak menjalankan runtime, tentu saja, kami memiliki lebih banyak overhead dari ini.  Dalam runtime Anda dapat melakukan segalanya dengan lebih cepat.  Di sisi lain, jika Anda menggunakan coroutine untuk pemrograman asinkron, maka Anda harus tertidur, jika Anda pergi untuk menunggu respons dari beberapa layanan, dan mengirim permintaan ke beberapa layanan sangat mahal sehingga seluruh biaya overhead untuk menyalin tumpukan tidak mengganggu siapa pun - apakah itu lambat atau cepat, itu tidak masalah sama sekali.  Ya, jika Anda menggunakannya secara khusus untuk pemrograman asinkron.  Pada coroutine di Kotlin, sisiknya sangat besar, seperti yang ditunjukkan dalam prototipe Project Loom. <br><br>  Perbedaan lain adalah bahwa karena kita di Kotlin dipaksa untuk melakukan ini dalam bytecode, kita memiliki efek samping yang menarik.  Di satu sisi, tampaknya tidak berhasil, dan di sisi lain, sebaliknya.  Ini terdiri dari yang berikut: tidak mungkin untuk menidurkan fungsi sewenang-wenang.  Anda memerlukan fungsi yang dapat tertidur, menandai ditangguhkan dengan pengubah - perhatikan secara eksplisit bahwa fungsi tersebut dapat berhenti sementara dan menunggu sesuatu menjadi panjang.  Di satu sisi, Anda tidak perlu ini di Loom, karena runtime dapat membuat apa pun tidur.  Solusi Alibaba sama - Anda dapat mengambil setumpuk dari utas apa pun.  Atau di Go - semuanya dapat dikunci di sana, kode apa pun dapat tertidur.  Gorutin dan lakukan.  Di satu sisi, pendekatan ini sangat mirip dengan pemrograman dengan utas.  Seolah-olah Anda pemrograman seperti sebelumnya, hanya sekarang utas disebut serat dan menjadi sangat murah.  Jika Anda hati-hati melihat presentasi dari alat tenun yang sama, ternyata serat dan benang masih merupakan hal yang berbeda.  Cara memastikan bahwa kode lama yang ditulis dengan utas <em>sepenuhnya</em> keluar dari kotak serat - tidak jelas, dan apa yang akan berhasil - tidak ada yang tahu.  Masalah mulai di sana: apa yang harus dilakukan dengan deadlock, apa yang harus dilakukan dengan kode yang dioptimalkan untuk thread lokal, sekali lagi beberapa hash atau id thread lokal melakukan beberapa optimasi kinerja.  Dan Go memiliki masalah yang sama - ketika ID perangkat keras tidak diekspos, menulis semacam algoritma kinerja tinggi menjadi non-sepele. <br></p><br><p>  <strong>Tetapi di Kotlin ini bukan?</strong> <br></p><br><p>  Di Kotlin, kami tidak mencoba berpura-pura bahwa benang dan serat adalah hal yang sama.  Kami bahkan tidak mencoba menjalankan kode lama, pada prinsipnya kami tidak memiliki tugas seperti itu.  Kami mengatakan: "Maaf, karena kami tidak runtime, kami tidak dapat secara sewenang-wenang mengambil kode Java lama dan mulai beralih sesuatu di sana."  Dan kami bahkan tidak akan mencoba.  Kami memiliki tugas yang berbeda.  Kami mengatakan bahwa kami memiliki fitur bahasa, fungsi tertidur, Anda dapat menulis kode asinkron dengannya, dan ini adalah fitur baru dari bahasa tersebut.  Dan kami benar-benar menjauhkan diri dari masalah ini ("bagaimana menjalankan kode lama"), kami mengatakan: "Ada kode baru, bagus, Orthodox, Anda dapat membuatnya tidur."  Hingga taraf tertentu, ini membuat hidup lebih mudah, karena Anda tidak perlu melambung baik diri sendiri atau orang, tetapi apa yang terjadi jika beberapa govnokod tua yang tidak tahu bahwa mereka akan meluncurkannya pada serat akan tiba-tiba meluncurkan pada mereka. <br><br>  Dalam model kami, kami tidak memiliki kode lama, hanya kode baru, yang awalnya siap untuk fakta bahwa hari ini ada di satu utas, besok di yang lain, dan jika, misalnya, perlu mengetahui utas mana yang sekarang, ia akan mengetahuinya.  Ya, Anda perlu utas lokal, tetapi ia dapat mengenalinya.  Namun, ia harus siap untuk fakta bahwa hari ini utas lokal adalah satu, dan besok - yang lain.  Jika dia ingin tempat-tempat ini untuk bepergian bersamanya, ada mekanisme lain untuk ini, konteks coroutine di mana dia dapat menyimpan barang-barangnya, yang, bersama dengan coroutine, akan berjalan dari benang ke benang.  Ini, dalam arti tertentu, membuat hidup lebih mudah bagi kita, karena kita tidak berusaha mempertahankan kode lama. <br></p><br><p>  Dan di sisi lain, kami membuat seseorang secara eksplisit berpikir tentang API mereka, katakan: di sini saya menulis sebuah fungsi di Kotlin dengan coroutine.  Jika sebelumnya saya melihat beberapa metode dalam kode saya, <em>dapatkan apa yang</em> tidak jelas, metode ini bekerja dengan cepat dan segera kembali atau online dan dapat bekerja selama satu jam - saya hanya dapat membaca dokumentasi dan memahami seberapa cepat itu akan bekerja.  Atau mungkin dia bekerja cepat sekarang, dan besok programmer Vasya Pupkin akan datang dan membuatnya online sekarang.  Dengan Kotlin Coroutines, kami menyediakan mekanisme yang dijamin bahasa dengan pengubah <em>penangguhan</em> .  Ketika saya bekerja dengan coroutine sendiri, saya melihat beberapa fungsi, jika saya tidak melihat pengubah penangguhan, itu berarti ia bekerja dengan cepat, ia melakukan semuanya secara lokal.  Ada pengubah menangguhkan, yang berarti fungsi ini entah bagaimana tidak sinkron, itu akan pergi di jaringan untuk waktu yang lama.  Dan membantu untuk membuat API yang mendokumentasikan diri sendiri sehingga kita dapat segera melihat apa yang menunggu kita.  Ini membantu untuk segera menghindari kesalahan bodoh ketika saya lupa di suatu tempat dan di suatu tempat dalam kode yang saya sebut sesuatu yang panjang tanpa curiga. <br><br>  Dalam praktiknya, ini sangat bagus.  Ini perlu secara eksplisit menandai fungsi tertidur ini.  Dalam Go, misalnya, ini bukan, saya tidak harus menandai apa pun di luar sana.  Ternyata ini efek samping dari implementasi kami (yang harus ditandai dengan pengubah menangguhkan) membantu Anda untuk membuat arsitektur yang benar, membantu Anda untuk mengontrol bahwa Anda tidak akan menyebabkan beberapa permainan asinkron acak panjang liar di tempat di mana Anda awalnya mengharapkan semuanya terjadi dengan cepat. <br></p><br><p>  <strong>Tetapi ada beberapa hal yang sulit untuk dilarang, misalnya, semacam IO jaringan, file.</strong> <br></p><br><p>  Tidak, IO jaringan cukup mudah dilarang.  Berikut adalah file IO - rumit.  Tetapi di sini lagi, titik yang sulit: untuk sebagian besar aplikasi, file IO adalah hal yang cepat, dan oleh karena itu sangat normal bahwa ia bekerja secara serempak.  Aplikasi yang sangat jarang bekerja sangat banyak dengan IO sehingga menjadi masalah baginya untuk mengambil begitu lama.  Dan di sini kami memberi seseorang kesempatan untuk memilih: Anda dapat langsung membuat file IO dengan kami dan tidak mandi uap, karena itu akan memblokir apa yang terjadi (karena biasanya cepat).  Tetapi jika kasing khusus Anda memiliki perhitungan yang sangat panjang, sepertinya tidak sinkron, tetapi memakan banyak waktu CPU, dan Anda tidak ingin memblokir beberapa kumpulan utas lainnya, kami menyediakan mekanisme yang mudah dimengerti: Anda memulai terpisah thread pool untuk komputasi yang berat, dan alih-alih menulis fungsi reguler yang <em>menyenangkan menghitung ()</em> , dan menulis dalam dokumentasi “Dudes, hati-hati, fungsi ini dapat bekerja untuk waktu yang sangat lama, jadi <strong>perhatian</strong> - jangan menggunakannya di mana saja, jangan gunakan di mana saja, jangan gunakan UI ”, kami menawarkan metode yang lebih sederhana  Khanisme.  Anda cukup menulis fungsi ini sebagai <strong><em>menangguhkan menyenangkan computeSomething ()</em></strong> , dan untuk implementasinya Anda menggunakan fungsi perpustakaan khusus <em>denganContext</em> , yang melempar perhitungan ke kumpulan utas khusus yang Anda tentukan.  Ini sangat nyaman: pengguna tidak perlu lagi melambung ke otak: ia segera melihat penangguhan, tahu bahwa panggilan ini tidak memblokir utangnya, dan ia dapat dengan mudah menyebutnya dari aliran UI dan seterusnya. <br></p><br><p>  Ini akan beralih ke aliran yang diinginkan sudah di dalam, dan alirannya tidak akan diblokir.  Ini adalah pemisahan keprihatinan yang benar: pengguna tidak peduli bagaimana itu diterapkan, tetapi orang yang mengimplementasikan dapat mentransfer dengan benar ke kolam yang dibutuhkan dan mendistribusikan sumber daya komputasi dengan benar dalam aplikasinya.  Dalam praktiknya, ini terbukti sangat nyaman dalam hal gaya pemrograman.  Kita perlu menulis lebih sedikit dokumentasi, kompiler akan memeriksa dan memperbaiki lebih banyak. <br></p><br><p>  <strong>Saya pikir betapa amannya itu.</strong> <strong>  -  thread pool     ?</strong> <br></p><br><p> ,  .     . ,             ,    .   ,       .  ,      .     -   .    -   Java,    ,               .     ,    ,        .  ,  .    -.      . <br></p><br><p> <strong>    Kotlin,      .    ,          .</strong> <br></p><br><p>   ? <br></p><br><p> <strong>,     :     raw types?  .</strong> <br></p><br><p>      . <br></p><br><p> <strong>       Java?</strong> <br></p><br><p>  Ya <br></p><br><p> <strong>     -  ,   -  . List, .</strong> <br></p><br><p>       ,      List.  List   ,   .         .     raw List,       platform type,    , ,  List  .   raw type,  ,  Java     ,     .  Java,     ,   ,     ,            ,     , raw type.   ,     —     ,     .    ,     — .              —   ,        ,  raw types.    ,     migration story. <br></p><br><p> <strong>   platform type  ?</strong> <br></p><br><p>     flexible.      nullable-.      ,   String.   ,  String  nullable String —    .     ,  String     — nullable  -nullable.  Kotlin ,      ,  .        String,    nullable String.     ,    -    Java,             . <br></p><br><p> <strong>    ?</strong> <br></p><br><p>     ,    , , ,     . Flexible    ,   dynamic. Flexible    — ,    Java,       String,   nullable String,    int. <br></p><br><p> <strong> -  -   ,    .</strong> <br></p><br><p>      ,  ,   .     .      read only  mutable.    List  MutableList.   Java  List,   ,  Java-   ,     ,     -   List    MutableList.    ,  Java. ,    Java - ,        .      ,        ,       .  , , ,   List,    , ,     MutableList,   List .       List,  String,   . <br></p><br><p> <strong>     - ,   ?    -  ?</strong> <br></p><br><p> ,    .   ,      . It just works.  Java        .     nullability- ,    , nullable   .      , .  , ,  ,        . ,   ,      , ,     - .          ,     -.  - JavaFx,   -       ,     JavaFx   Java, ,   . ,       - ,     .        .      ,        ,     . <br></p><br><p> <strong>    ,    .</strong> <br></p><br><p>  Tentu saja      ,     .        Kotlin Native.   :    ,       seamless    C- ,             ,  - . <br></p><br><p> <strong>,      Native        ?</strong> <br></p><br><p> ,  ,     Kotlin JavaScript, -   - .      «Write once, run anywhere»,    ,    .    :     ,  Common Kotlin  Portable Kotlin,     ,     . ,      - - ,     ,   .      ,    ,       -    .       ,   . <br><br>  JVM   ,   Java,  JS      ,   JS,  Native  . ,   ,     ,     ,       .    -     JS,    .      -. -   :   double,   String.   JVM-   0    «0.0»,    JS   .  .     JS  ,           ,        —   ?     ,   .        ,     ,     JS- .    ,          -.  ,    . -     — , ,     —    .      ,  ,   ,       ,      JVM, JS, Native —     ,    ,  -   .   . <br></p><br><p> <strong>     ?</strong> <br></p><br><p>  Ya   ,   ,      . <br></p><br><p> <strong>    ,   …</strong> <br></p><br><p> ,     .       ,    .     Loom   .     -   JVM.   ,          . <br></p><br><p> <strong>        , ,  Java?</strong> <br></p><br><p>       ,   .       .   — <strong>    </strong> .        ,   .      ,     -  . ,  <em>for ( i in 0..10 )</em> ,      <em>for (int i = first</em>   .   ,    ,    .  . ,       . <br></p><br><p> <strong> -         ?</strong> <br></p><br><p> ,   …     ,   .    .    JVM  JS. <br></p><br><p> <strong>       Node.js?</strong> <br></p><br><p>   !   .    ,    JS-.    ,   ,  JS-   .        ,  .      ,     -    —     ,   JS-,      - — .    ,     .      . <br></p><br><p> <strong>     « ».         ,       ?</strong> <br></p><br><p>  Tentu saja ,      ,    .  JVM     ,  Java,      .      JVM   .     legacy, enterprise,    .     ,    ,     .      ,         JVM.    ,    —    ,     .     ,     .        , —    JVM    «   ».      .     API     ,     .   ,    .   ,    .  ,       ,        .     ,       ,    . <br></p><br><blockquote>        TechTrain   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">«     ?»</a>  .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> . ,  . <br></blockquote><br><h1>    </h1><br><p> <strong>      JS  ,    Kotlin   Java?</strong> <br></p><br><p>   Java        .      «Kotlin in Action»,  ,   Java-.  , Java-        ,  ,     Kotlin-.     ,  «by design».     ,  Java-      .   .      JPoint   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,   Kotlin .    ,     . ,  60-70%   Java.      Java,   ,      -  .     Java    . <br><br>      - —     ,     ,    -.     as-is.   ,   ,   .  Kotlin ,    ,   «»,     «».  ,   «» —   .    <em>while</em> —    .    100500     .  Tapi mengapa?  ,       Java-.    - , «  Kotlin»,      ,           . <br></p><br><p>  ,      .      .     ,       ,      .  ,    . <br></p><br><p> <strong>  ,  -,      ?</strong> <br></p><br><p> ,   .     .    Java-    . Android-  —  ,     .     .      ,    .       —       . <br></p><br><p> <strong>  - ,      ?</strong> <br></p><br><p>   ,    .     , , .   , ,     .     —   ,    ,    .     Kotlin  . ,     .       -   ,   , ,      .     :   ,       .     C++,    Java,   Python.      .   Java  -  ,          Java,           .    ,   , puiblic static void main…      -,   .  Java,    ,   .    ? <br><br> Kotlin       :  ,   ,    Python,   .    C++  ,   C++   .   ,      , .     ,     .   ,  ,         .  Kotlin —   .       —  Python.          .       .      ,     .   ,     .   .        — , , , ,  —      .      ,    . <br></p><br><p> <strong>   ,   —  ?</strong> <br></p><br><p>    ,   .  must have.       ,     —     .       .        ,       .   —  .      ,  ,   ,   . <br></p><br><p> <strong>   ?</strong> <br></p><br><p>   …  , ,   .   .  JS- —  .  —  .     JS,    ,  .   -      JS,     type checkers,  Flow  TypeScript. -    JS      .     Python.   -  DSL,  .    Django   ,      .   ,   .        , ,  , .     .       Django,     ,     CRUD-.       , -  —     .        -,  -  ,   ,        .  .      .     Kotlin,    ,  Java,   .  core belief   Kotlin,        . <br></p><br><p> <strong> ,    -   ,    Kotlin   ?</strong> <br></p><br><p>  Tentu saja!     , ,      - CRUD-.    :           ,    ,     — ,   .       -,      — ,   .  ,  TypeScript  Flow   —     JS. <br></p><br><p>  Kotlin   ,  Kotlin  JS    TypeScript  ,   .        TS  Kotlin/JS, , TS ,      JS-,     .  Kotlin/JS ,      .     ,   . <br></p><br><p> <strong>    ,     —   double…</strong> <br></p><br><p> ,        .      ,       ,   . <br></p><br><p> <strong>-      .</strong> <br></p><br><p>     . <br></p><br><p> <strong>   ?</strong> <br></p><br><p> Saya mengadakan olimpiade :-) Dan saya sendiri berpartisipasi, tetapi jarang. <br></p><br><p>  <strong>Saya hanya melihat bahwa di Olimpiade Java terkadang tersedia sebagai salah satu bahasa utama.</strong> <br></p><br><p>  Sekarang hampir selalu tersedia.  Dia muncul sekitar lima belas tahun yang lalu.  Java dan C ++ adalah dua bahasa standar yang semuanya mendukung, dan kemudian variasi, tergantung pada kompetisi. <br></p><br><p>  <strong>Apakah lebih sulit untuk menang di Jawa, apakah ada overhead yang tersembunyi?</strong> <br></p><br><p>  Tergantung kompetisi.  Dalam kompetisi normal, sama jika ada lebih banyak tugas dalam gagasan dan algoritma yang benar.  Tetapi ada beberapa jenis permainan ketika tugas melibatkan optimasi non-asimptotik, di mana Anda perlu mengoptimalkan segalanya sesuai keinginan - di sana, tentu saja, akan sulit di Jawa, Anda harus mencoba banyak.  Ditambah lagi ada lead time tes yang sangat singkat.  Secara kasar, jika Anda memiliki batas waktu beberapa detik, maka HotSpot melakukan pemanasan pada kode kecil dalam sedetik dan tidak peduli.  Dan jika Anda memiliki batasan untuk semuanya - satu detik, maka di Jawa Anda bisa kehilangan karena fakta bahwa ketika HotSpot sedang melakukan pemanasan dan kompilasi - satu detik telah berlalu. <br><br>  Ya, ada kompetisi liar di mana Jawa sulit.  Tetapi kompetisi normal (populer, didukung oleh orang-orang baik) - mereka mencoba melakukan tugas dan lingkungan sedemikian rupa sehingga Java dan plus memiliki peluang yang sama.  Dan alasannya jelas: meskipun Jawa tidak tumbuh dalam pendidikan, itu tidak menurun banyak di mana pun.  Di suatu tempat, beberapa universitas menolak untuk belajar Jawa dan beralih ke Python - dan karena ini, termasuk, sekarang banyak kompetisi telah belajar Python.  Ini adalah bahasa ketiga yang stabil yang didukung.  Kompetisi utamanya adalah siswa.  Ada kompetisi profesional, dan perusahaan besar melakukan sesuatu seperti Facebook Hacker Cup, di mana setiap orang dapat berpartisipasi, tetapi tetap saja, tema utama dalam pemrograman olahraga adalah sekolah dan siswa.  Di tahun sekolah dan siswa, orang akan terus melakukan dan melatih.  Tetapi setelah lulus, setelah pergi bekerja - sangat sedikit orang yang akan terus berpartisipasi.  Oleh karena itu, pilihan bahasa ditentukan oleh apa yang digunakan dalam pendidikan.  Jika mereka mengajar plus, Java dan python, maka mereka akan berada di kompetisi.  Bagi banyak programmer, Java adalah bahasa pertama, masing-masing, semua kompetisi mencoba mendukung Java.  Demi kompetisi untuk belajar C ++ - game.  Ini untuk pemrograman sistem, pemrograman tingkat rendah, Anda tidak perlu memiliki sejuta programmer C ++, itu tidak ada gunanya sama sekali. <br></p><br><p>  <strong>Bagaimana Anda menyukai gagasan menambahkan Kotlin ke daftar bahasa standar?</strong> <br></p><br><p>  Sebenarnya, kami secara aktif mempromosikan ide ini.  Ada ICPC, yang berlangsung setiap tahun, mengumpulkan ratusan ribu peserta di seluruh dunia, lebih dari seratus tim pergi ke putaran final.  Di ICPC, Kotlin didukung.  Sekarang ada daftar bahasa: C / C ++, Java, Python dan Kotlin.  Tetapi untuk saat ini, tentu saja, tidak ada yang benar-benar menulis tentangnya, karena masalah ini: penetrasi ke pendidikan pada tahap yang sangat awal.  Dalam kompetisi siswa, bahasa-bahasa tersebut digunakan agar siswa diajarkan. <br></p><br><p>  <strong>Apakah Kotlin sudah diajarkan di suatu tempat?</strong> <br></p><br><p>  Di suatu tempat tepatnya diajarkan.  Misalnya, di Politeknik St. Petersburg.  Tetapi kita berada pada tahap yang sangat awal, pada "langkah 0" dari proses ini. <br></p><br><p>  <strong>Tidak ada kekurangan fatal?</strong> <br></p><br><p>  Tidak, Kotlin lebih baik untuk pendidikan dasar daripada bahasa lain.  Pendidikan yang adil bersifat konservatif.  Orang-orang memiliki program yang sudah jadi, buku pelajaran.  Tidak ada yang suka berubah.  Mengapa seorang profesor yang mengajar pemrograman di tahun pertamanya mengubah bahasa bahasanya, apa bonusnya?  Ini dapat ditinjau setiap sepuluh tahun. <br></p><br><p>  <strong>Bonusnya, misalnya, adalah orang yang meninggalkannya akan lebih beradaptasi dengan kenyataan.</strong> <br></p><br><p>  Tidak.  Karena itu tidak begitu penting bahasa mana yang Anda pelajari terlebih dahulu.  Seorang programmer profesional dalam hidupnya telah mempelajari selusin bahasa dan menggunakan sekitar tiga bahasa secara aktif.  Plus semua ini terus berubah.  Apa yang Anda akan diajarkan untuk memprogram terlebih dahulu tidak begitu penting.  Penting berapa banyak bahasa yang Anda miliki saat lulus dari universitas - ini adalah topik lain, ini penting.  Dan di sini kita dihadapkan dengan masalah di pasar konservatif yang berfokus pada otoritas.  Misalnya, di China ada masalah yang diklarifikasi setelah berbicara dengan orang-orang dari sana.  Anda mengambil kantor besar di mana ada banyak programmer, Anda bertanya - mengapa Anda tidak menggunakan Kotlin?  Tetapi karena sekarang, mereka tidak mengajar Kotlin di universitas, dan mereka tidak ingin belajar sesuatu yang baru, tetapi mengapa mereka? <br></p><br><p>  <strong>Apakah tidak demikian halnya dengan kita?</strong> <br></p><br><p>  Ini ada di mana-mana, hanya pada skala yang berbeda.  Dalam budaya yang berbeda dengan cara yang berbeda.  Ada budaya di mana, seperti kata guru, atau seperti kata guru, Anda akan melakukannya.  Di suatu tempat orang lebih mandiri, lebih rentan terhadap eksperimen, inovasi.  Di suatu tempat orang akan pergi dan mempelajari semuanya sendiri.  Di suatu tempat mereka tidak akan mengangkat jari dan akan melakukan apa yang diajarkan kepada mereka.  Ada lebih banyak implementasi Kotlin di Rusia, tetapi ini juga karena kami berasal dari sini, kami berbicara lebih banyak di konferensi dan sebagainya. <br></p><br><p>  Ini adalah generasi saya, pemrogram telah menjadi penggemar.  Saya tumbuh ketika mereka yang menyukainya memprogram, mereka mempelajari semuanya sendiri, karena tidak ada apa-apa.  Dan sekarang ini adalah hal massal yang sedang diajarkan.  Ambil seorang programmer modern, kebanyakan melakukan ini bukan karena dia mencintai, tetapi karena mereka mengajarinya ini dan sekarang mereka membayar banyak uang.  Oleh karena itu, orang-orang tersebut tidak akan mempelajari teknologi yang baru saja dirilis.  Mengapa mereka membutuhkannya? <br></p><br><p>  <strong>Karena Anda akan mendapatkan banyak uang menggunakan fitur keren dari teknologi ini.</strong> <br></p><br><p>  Tentu tidak!  Di Kotlin, Anda lebih mungkin mendapatkan lebih banyak kesenangan. <br></p><br><p>  <strong>Ada hal-hal spesifik yang benar-benar memiliki nilai bisnis - kami berbicara tentang penggunaan kembali antara bagian depan dan belakang ...</strong> <br></p><br><p>  Tidak semua orang membutuhkannya.  Di sisi lain, dan kesenangan juga.  Tidak semua orang menikmati pekerjaan mereka sama sekali.  Mereka dibayar uang - mereka bekerja, tidak ada bedanya bagi mereka apakah mereka suka atau tidak.  Hari kerja berakhir - mereka menutup dan melupakannya, dan mulai melakukan hal-hal lain. <br></p><br><p>  <strong>Ini entah bagaimana sangat membosankan, jika tidak mengerikan.</strong> <br></p><br><p>  Sayangnya, inilah kebenaran kehidupan.  Tidak peduli seberapa buruknya dia.  Dan orang-orang seperti itu, tentu saja, tidak peduli.  Kotlin, bukan Kotlin. <br></p><br><p>  <strong>Sejauh yang saya mengerti, hanya banyak orang yang bekerja di JetBrains karena mereka suka bekerja.</strong> <br></p><br><p>  Tentu saja JetBrains dalam hal ini adalah sampel yang tidak representatif.  Orang yang dipilih secara khusus, termotivasi, yang sangat menyukai hal ini. <br></p><br><p>  <strong>Waktu kita perlahan-lahan akan segera berakhir, jadi pertanyaannya adalah: bisakah Anda menyampaikan sesuatu kepada pembaca kami di Habré?</strong>  <strong>Adakah kata perpisahan, wahyu?</strong> <br></p><br><p>  Saya bisa menyampaikan salam berapi-api :-) Tapi saya tidak akan mengatakan wahyu apa pun, wahyu macam apa itu?  Satu-satunya kesimpulan yang dapat diambil dari percakapan kami adalah bahwa siapa pun yang menikmati pekerjaan itu bahagia.  Saya membaca beberapa blog orang baik yang diprogram di Jawa, hanya bekerja tanpa kesenangan.  Dan kemudian, untuk beberapa alasan, mereka menjadi penasaran, kehidupan membuat mereka, mereka mencoba Kotlin, dan tiba-tiba menemukan sendiri bahwa Anda dapat menikmati pekerjaan.  Anda bisa mencintai apa yang Anda lakukan.  Apa yang Anda sukai dari bahasa pemrograman.  Dan bukan hanya digunakan, tanpa emosi, sebagai alat.  Tentu saja, bahasa adalah alat, tetapi Anda dapat mengaitkannya secara tidak langsung, atau Anda dapat menyukainya.  Ini adalah sikap yang berbeda, termasuk sikap berbeda untuk bekerja. <br><br>  Kotlin memiliki banyak orang yang memiliki perasaan hangat yang sebanding dengan cinta, justru karena Kotlin hanya baik untuk program, terutama setelah Jawa.  Mungkin tidak hanya setelah Jawa.  Mungkin tidak ada bahasa di mana itu sangat <strong>bagus</strong> (hanya kata seperti itu) untuk diprogram.  Ada bahasa dengan lebih banyak fungsi, dengan fitur yang lebih kuat, ada bahasa dengan sistem tipe yang lebih ketat, ada bahasa di mana semuanya murni, ada di mana semuanya sebaliknya - tidak aman.  Ambil dimensi apa pun dan Anda akan menemukan bahasa yang lebih baik daripada Kotlin di properti ini.  Tetapi Kotlin memiliki keseimbangan sehingga bukan kebetulan bahwa ia di StackOverflow dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jajak pendapat tahun ini</a> menempati urutan kedua dalam daftar bahasa yang paling dicintai.  Tampaknya, yang pertama adalah Rust.  Tetapi Rust bukan pesaing bagi kami, karena Rust adalah bahasa pemrograman sistem.  Kami tidak naik ke ceruk ini.  Sama sekali tidak menyebalkan bahwa Rust dalam hal ini menyalip Kotlin.  Kami berusaha menjadikan Kotlin bahasa utama untuk pemrograman aplikasi yang menyenangkan untuk menyelesaikan masalah aplikasi.  Kami tidak memiliki dan tidak akan pernah memiliki beberapa fitur Rust, karena mereka sama sekali tidak diperlukan oleh programmer aplikasi.  Dia seharusnya tidak mengelola memori secara manual atau memikirkan seluk-beluk kepemilikan, seorang programmer aplikasi harus menyelesaikan masalah bisnis.  Dia harus mengubah domainnya menjadi kode.  Dan ini harus menjadi transformasi yang paling langsung tanpa faktor yang mengganggu itu.  Kami berusaha menghilangkan faktor-faktor yang mengganggu ini.  Sehingga Anda mengubah tugas bisnis Anda secara langsung, tanpa air dan kode tambahan menjadi solusi. <br></p><br><p>  <strong>Nah, ini adalah kompetisi yang agak tidak adil - semua bahasa seperti Jawa diciptakan bertahun-tahun yang lalu, dan Anda baru saja melakukannya.</strong> <br></p><br><p>  Secara alami, Kotlin memperhitungkan pengalaman para pendahulunya.  Seperti bahasa modern lainnya.  Ini adalah kemajuan - ketika sesuatu yang baru dibuat dengan mempertimbangkan kekurangan lama.  Untuk alasan yang baik, jenis nullable dibuat di Kotlin.  Nah, pergi jauh, bawa perusahaan apa saja, pergi ke kantor besar mana saja, lihat log kerusakan mereka, dan Anda akan melihat bahwa pengecualian yang paling sering adalah NullPointerException.  Ini adalah fakta yang terkenal, dan jika Anda membuat bahasa baru, Anda harus menyelesaikannya.  Oleh karena itu, kami membayar banyak perhatian dalam bahasa untuk nullability.  Dan sebagainya.  Jika Anda tidak mendesain bahasa secara abstrak, bukan sebagai latihan akademis, tetapi mencoba menyelesaikan masalah orang yang sering mereka temui, maka bahasa tersebut ternyata baik.  Kenapa dia dicintai?  Karena dia menyelesaikan masalah mereka. <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421607/">https://habr.com/ru/post/id421607/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421593/index.html">SandboxEscaper / PoC-LPE: apa yang ada di dalamnya?</a></li>
<li><a href="../id421595/index.html">Bagaimana orang-orang IT menemukan pekerjaan di AS dan UE: 9 sumber daya terbaik</a></li>
<li><a href="../id421599/index.html">Intel Crimson Canyon - NUC dengan grafis diskrit dan prosesor 10nm</a></li>
<li><a href="../id421601/index.html">Ketika di gcc ada alamat 16-bit, dan tiba-tiba memori 256k</a></li>
<li><a href="../id421603/index.html">Google dan DevOps: dua buku tentang SRE</a></li>
<li><a href="../id421611/index.html">Bagaimana World of Warcraft diciptakan: pandangan ke dalam pada 20 tahun pembangunan</a></li>
<li><a href="../id421613/index.html">Bagaimana kami menulis artikel tentang Habr: pengalaman pengembang EastBanc Technologies</a></li>
<li><a href="../id421615/index.html">Solusi untuk kurangnya prevProps di getDerivedStateFromProps</a></li>
<li><a href="../id421619/index.html">Sistem otonom masa depan. Klasifikasi, fitur dan persyaratan</a></li>
<li><a href="../id421625/index.html">Asynchronous Python: berbagai bentuk kompetisi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>