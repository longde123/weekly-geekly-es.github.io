<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📽️ 👨🏽‍🚒 🤱🏾 Texturen für 64k Intro: wie es heute gemacht wird ✝️ 💆🏾 🏯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist Teil zwei unserer H - Immersion - Reihe . Der erste Teil kann hier gelesen werden: Eintauchen in Eintauchen . 

 Wenn Sie eine Anim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Texturen für 64k Intro: wie es heute gemacht wird</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419007/">  <i>Dieser Artikel ist Teil zwei unserer</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>H - Immersion -</i></a> <i>Reihe</i> <i>.</i>  <i>Der erste Teil kann hier gelesen werden:</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>Eintauchen in Eintauchen</i></a> <i>.</i> <br><br>  Wenn Sie eine Animation mit nur 64 KB erstellen, ist es schwierig, vorgefertigte Bilder zu verwenden.  Wir können sie nicht auf herkömmliche Weise speichern, da sie nicht effizient genug sind, selbst wenn Sie eine Komprimierung anwenden, z. B. JPEG.  Eine alternative Lösung ist die prozedurale Generierung, dh das Schreiben von Code, der die Erstellung von Bildern während der Programmausführung beschreibt.  Unsere Implementierung dieser Lösung war ein Texturgenerator - ein grundlegender Bestandteil unserer Toolchain.  In diesem Beitrag werden wir erklären, wie wir es in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>H - Immersion</i></a> entwickelt und verwendet haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a8/2ee/a7e/6a82eea7ea42a6ca5cf4b437545b3893.jpg"></div><br>  <i>U-Boot-Scheinwerfer beleuchten die Details des Meeresbodens.</i> <br><a name="habracut"></a><br><h2>  Frühe Version </h2><br>  Die Texturgenerierung war eines der allerersten Elemente unserer Codebasis: Prozedurale Texturen wurden bereits in unserem ersten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>B - Incubation -</i></a> Intro verwendet.  <a href="">Der Code</a> bestand aus einer Reihe von Funktionen zum Füllen, Filtern, Transformieren und Kombinieren von Texturen sowie einer großen Schleife, die alle Texturen umgeht.  Diese Funktionen wurden in reinem C ++ geschrieben, aber die C-API-Interaktion wurde später hinzugefügt, damit sie vom C <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PicoC-</a> Interpreter ausgewertet werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können</a> .  Zu dieser Zeit haben wir PicoC verwendet, um die Zeit zu reduzieren, die für jede Iteration benötigt wird. Auf diese Weise konnten wir Texturen während der Programmausführung ändern und neu laden.  Der Wechsel zur C-Teilmenge war ein kleines Opfer im Vergleich zu der Tatsache, dass wir jetzt den Code ändern und das Ergebnis sofort sehen konnten, ohne die gesamte Demo schließen, neu kompilieren und neu laden zu müssen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70d/88e/4c9/70d88e4c948bfbd24f7d003b5a92f6af.png"></div><br>  <i>Mit einem einfachen Muster, ein wenig Rauschen und Verformung können wir eine stilisierte Holzstruktur erhalten.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e28/a67/83b/e28a6783bd53715bb1514bc6aa2c655f.jpg"></div><br>  <i>In dieser Szene aus</i> F - Felix 'Werkstatt wurden <i>verschiedene Holzstrukturen verwendet.</i> <br><br>  Einige Zeit haben wir die Funktionen dieses Generators untersucht und ihn daher mit einem kleinen PHP-Skript und einer einfachen Weboberfläche auf einem Webserver veröffentlicht.  Wir konnten den Texturcode in ein Textfeld schreiben, und das Skript übergab ihn an den Generator, der das Ergebnis dann als PNG-Datei ausgab, um es auf der Seite anzuzeigen.  Sehr bald begannen wir während der Mittagspause direkt bei der Arbeit zu skizzieren und unsere kleinen Meisterwerke mit anderen Mitgliedern der Gruppe zu teilen.  Diese Interaktion motivierte uns zum kreativen Prozess. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f15/be6/722/f15be672247f38176102734d115a5001.png"></div><br>  <i>Webgalerie unseres alten Texturgenerators.</i>  <i>Alle Texturen können im Browser bearbeitet werden.</i> <br><br><h2>  Vollständige Neugestaltung </h2><br>  Der Texturgenerator blieb lange Zeit nahezu unverändert;  Wir fanden es gut und unsere Effektivität nahm nicht mehr zu.  Aber als wir herausfanden, dass es in den Internetforen viele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Künstler gibt,</a> die ihre vollständig prozedural erzeugten Texturen demonstrieren und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Herausforderungen</a> zu verschiedenen Themen arrangieren.  Der prozedurale Inhalt war einst ein Merkmal der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demoszene</a> , wurde jedoch von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allegorithmic</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ShaderToy</a> und ähnlichen Tools der Öffentlichkeit zugänglich gemacht.  Wir haben nicht darauf geachtet, und sie fingen an, uns leicht auf die Schulterblätter zu setzen.  Inakzeptabel! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12a/7cb/e33/12a7cbe33257454ca8e23c53dd84ef00.jpg"></div><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stoffcouch</a> .</i>  <i>Eine vollständig prozedurale Stoffstruktur, die in Substance Designer erstellt wurde.</i>  <i>Gepostet von: Imanol Delgado.</i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.artstation.com/imanoldelgado</a></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3e/25a/47e/b3e25a47ed73c407de4335f5e58cc87b.jpg" alt="Bild"></div><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Waldboden</a> .</i>  <i>Vollständig prozedurale Waldbodentextur, erstellt von Substance Designer.</i>  <i>Gepostet von Daniel Thiger.</i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.artstation.com/dete</a></i> <br><br>  Wir mussten unsere Werkzeuge lange überdenken.  Glücklicherweise konnten wir durch jahrelange Arbeit mit demselben Texturgenerator seine Mängel erkennen.  Darüber hinaus hat uns unser Generator für entstehende Netze mitgeteilt, wie die Pipeline für prozedurale Inhalte aussehen soll. <br><br>  Der wichtigste architektonische Fehler war die Implementierung der Generierung als eine Reihe von Operationen mit Texturobjekten.  Aus Sicht einer <b>übergeordneten</b> Perspektive mag dies der richtige Ansatz sein, aber aus Sicht der Implementierung haben Funktionen wie <b>Textur.DoSomething ()</b> oder <b>Combine (TexturA, TexturB)</b> schwerwiegende Nachteile. <br><br>  Erstens müssen Sie diese Funktionen für den OOP-Stil als Teil der API deklarieren, egal wie einfach sie sind.  Dies ist ein ernstes Problem, da es nicht gut skaliert werden kann und vor allem unnötige Reibung im kreativen Prozess verursacht.  Wir wollten die API nicht jedes Mal ändern, wenn wir etwas Neues ausprobieren mussten.  Dies erschwert das Experimentieren und schränkt die kreative Freiheit ein. <br><br>  Zweitens erfordert dieser Ansatz in Bezug auf die Leistung, dass Sie Texturdaten in Zyklen so oft verarbeiten, wie es Operationen gibt.  Dies wäre nicht besonders wichtig, wenn diese Vorgänge im Hinblick auf die Kosten für den Zugriff auf große Speicherfragmente kostspielig wären, dies ist jedoch normalerweise nicht der Fall.  Mit Ausnahme eines sehr kleinen Teils der Operationen, die beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perlin-Rauschen</a> erzeugen oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">füllen</a> , sind sie grundsätzlich sehr einfach und erfordern nur wenige Anweisungen zum Texturpunkt.  Das heißt, wir haben die Texturdaten umgangen, um triviale Operationen auszuführen, was unter dem Gesichtspunkt des Caching äußerst ineffizient ist. <br><br>  Die neue Struktur löst diese Probleme durch die Reorganisation der Logik.  Die meisten Funktionen in der Praxis führen unabhängig voneinander dieselbe Operation für jedes Texturelement aus.  Daher können wir anstelle einer <b>textur.DoSomething ()</b> -Funktion, die alle Elemente umgeht, die <b>textur.ApplyFunction (f)</b> schreiben, wobei <b>f (element)</b> nur für ein einzelnes Texturelement funktioniert.  Dann kann <b>f (Element)</b> gemäß einer bestimmten Textur geschrieben werden. <br><br>  Dies scheint eine geringfügige Änderung zu sein.  Diese Struktur vereinfacht jedoch die API, macht den Generierungscode flexibler und ausdrucksvoller, cachefreundlicher und ermöglicht eine einfache parallele Verarbeitung.  Viele der Leser haben bereits erkannt, dass dies im Wesentlichen ein Shader ist.  Die eigentliche Implementierung bleibt jedoch der auf dem Prozessor ausgeführte C ++ - Code.  Wir behalten uns weiterhin die Möglichkeit vor, Operationen außerhalb der Schleife auszuführen, verwenden diese Option jedoch nur, wenn dies beispielsweise durch Faltung erforderlich ist. <br><br><h3>  Es war: </h3><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     . // API . //    -  API. //      . class ProceduralTexture { void DoSomething(parameters) { for (int i = 0; i &lt; size; ++i) { //   . (*this)[i] = … } } void PerlinNoise(parameters) { … } void Voronoi(parameters) { … } void Filter(parameters) { … } void GenerateNormalMap() { … } }; void GenerateSomeTexture(texture t) { t.PerlinNoise(someParameter); t.Filter(someOtherParameter); … //  .. t.GenerateNormalMap(); }</span></span></code> </pre> <br><h3>  Es wurde: </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       . // API . //     . //      . class ProceduralTexture { void ApplyFunction(functionPointer f) { for (int i = 0; i &lt; size; ++i) { //    . (*this)[i] = f((*this)[i]); } } }; void GenerateNormalMap(ProceduralTexture t) { … } void SomeTextureGenerationPass(void* out, PixelInfo in) { result = PerlinNoise(in); result = Filter(result); … //  .. *out = result; } void GenerateSomeTexture(texture t) { t.ApplyFunction(SomeTextureGenerationPass); GenerateNormalMap(t); }</span></span></code> </pre> <br><h2>  Parallelisierung </h2><br>  Die Erzeugung von Texturen braucht Zeit, und ein offensichtlicher Kandidat für die Reduzierung dieser Zeit ist die parallele Codeausführung.  Zumindest können Sie lernen, wie Sie mehrere Texturen gleichzeitig generieren.  Genau das haben wir für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>die Werkstatt von F <em>-</em> Felix</i></a> getan, was die Ladezeit erheblich verkürzt hat. <br><br>  Dies spart jedoch keine Zeit dort, wo sie am meisten benötigt wird.  Es dauert immer noch viel Zeit, um eine Textur zu erzeugen.  Dies gilt für die Änderung, da wir die Textur vor jeder Änderung immer wieder neu laden.  Stattdessen ist es besser, den Code zur internen Texturgenerierung zu parallelisieren.  Da der Code jetzt im Wesentlichen aus einer großen Funktion besteht, die in einer Schleife auf jedes Texel angewendet wird, wird die Parallelisierung einfach und effizient.  Reduziert die Kosten für Experimente, Tuning und Entwürfe, was sich direkt auf den kreativen Prozess auswirkt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac9/cb7/21f/ac9cb721febdfc0b32300bb02f84fefe.jpg"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/191/c1e/a6d/191c1ea6de84670abe256fb67e7dc165.jpg"></div><br>  <i>Illustration einer Idee, die wir für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>H - Immersion</i></a> erforscht und verworfen haben: eine Mosaikdekoration mit Orichalconfutter.</i>  <i>Hier wird es in unserem interaktiven Bearbeitungswerkzeug angezeigt.</i> <br><br><h2>  GPU-seitige Generierung </h2><br>  Wenn dies immer noch nicht offensichtlich ist, werde ich sagen, dass die Texturgenerierung vollständig in der CPU durchgeführt wird.  Vielleicht lesen einige von Ihnen diese Zeilen jetzt und sind ratlos "aber warum ?!".  Es scheint, dass der offensichtliche Schritt die Texturgenerierung im Videoprozessor ist.  Zunächst wird die Erzeugungsrate um eine Größenordnung erhöht.  Warum benutzen wir es nicht? <br><br>  Der Hauptgrund ist, dass das Ziel unseres kleinen Redesigns darin bestand, auf der CPU zu bleiben.  Der Wechsel zu einer GPU würde viel mehr Arbeit bedeuten.  Wir müssten zusätzliche Probleme lösen, für die wir noch nicht genug Erfahrung haben.  Wenn wir mit der CPU arbeiten, haben wir ein klares Verständnis dafür, was wir wollen, und wir wissen, wie wir frühere Fehler beheben können. <br><br>  Die gute Nachricht ist jedoch, dass das Experimentieren mit der GPU dank der neuen Struktur jetzt ziemlich trivial erscheint.  Das Testen von Kombinationen beider Prozessortypen wird für die Zukunft ein interessantes Experiment sein. <br><br><h2>  Texturgenerierung und physikalisch genaue Schattierung </h2><br>  Eine weitere Einschränkung des alten Designs bestand darin, dass die Textur nur als RGB-Bild betrachtet wurde.  Wenn wir mehr Informationen generieren mussten, sagen wir die diffuse Textur und die Textur von Normalen für dieselbe Oberfläche, dann hinderte uns nichts daran, aber die API half nicht viel.  Dies ist im Zusammenhang mit Physically Based Shading (PBR) besonders wichtig geworden. <br><br>  In einer herkömmlichen Pipeline ohne PBR werden normalerweise Farbtexturen verwendet, in denen viele Informationen gebacken werden.  Solche Texturen stellen oft das endgültige Erscheinungsbild der Oberfläche dar: Sie haben bereits ein bestimmtes Volumen, Risse sind abgedunkelt und es kann sogar zu Reflexionen kommen.  Wenn mehrere Texturen gleichzeitig verwendet werden, werden große und kleine Details normalerweise kombiniert, um normale Karten oder Oberflächenreflexionsvermögen hinzuzufügen. <br><br>  Oberflächen-PBR-Förderer verwenden typischerweise mehrere Texturensätze, die physikalische Werte darstellen und nicht das gewünschte künstlerische Ergebnis.  Die diffuse Farbtextur, die der häufig als „Farbe“ der Oberfläche bezeichneten Farbe am nächsten kommt, ist normalerweise flach und uninteressant.  Der Farbspiegel wird durch den Brechungsindex der Oberfläche bestimmt.  Die meisten Details und Variabilitäten stammen aus den Texturen von Normalen und Rauheit (Rauheit) (die jemand als gleich betrachten kann, aber mit zwei verschiedenen Skalen).  Das wahrgenommene Reflexionsvermögen einer Oberfläche wird eine Folge ihres Rauheitsgrades.  In diesem Stadium wird es logischer sein, nicht in Materialien, sondern in Materialien zu denken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e6/ad2/e95/2e6ad2e9555afadc279ff0227d1ff54a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2d/3a4/71f/c2d3a471f7fb9a352db83454e0288a91.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/446/8d1/52c/4468d152ce8ba5b8a4f563c8cc428533.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/dad/d05/b58dadd05ca838c5fdc4ec5daec0855b.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a8/2ee/a7e/6a82eea7ea42a6ca5cf4b437545b3893.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/156/2a7/53f/1562a753fe3172e4add501ed110d3f7d.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f1e/91d/c4e/f1e91dc4ec162b76e1ba139f22e0e1d9.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf5/627/9e8/cf56279e8263eaea1411824f60d10503.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a9/525/b03/0a9525b03c6033b76587107f7a87a4bf.jpg"></div><br>  Die neue Struktur ermöglicht es uns, beliebige Pixelformate für Texturen zu deklarieren.  Nachdem wir es zu einem Teil der API gemacht haben, erlauben wir ihm, mit dem gesamten Boilerplate-Code umzugehen.  Nachdem wir das Pixelformat deklariert haben, können wir uns auf den Creative-Code konzentrieren, ohne zu viel Aufwand für die Verarbeitung dieser Daten aufzuwenden.  Zur Laufzeit werden mehrere Texturen generiert und transparent auf die GPU übertragen. <br><br>  In einigen PBR-Pipelines werden diffuse und spiegelnde Farben nicht direkt übertragen.  Stattdessen werden die Parameter "Grundfarbe" und "Metallizität" verwendet, was seine Vor- und Nachteile hat.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>H - Immersion verwenden</i></a> wir das diffuse + spiegelnde Modell, und das Material besteht normalerweise aus fünf Schichten: <br><br><ol><li>  Diffuse Farbe (RGB; 0: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vantablack</a> ; 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuschnee</a> ). </li><li>  Spiegelfarbe (RGB: Anteil des bei 90 ° reflektierten Lichts, auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>F0</i> oder <i>R0 bekannt</i></a> ). </li><li>  Rauheit (A; 0: perfekt glatt; 1: gummiartig). </li><li>  Normal (XYZ; Einheitsvektor). </li><li>  Geländehöhe (A; wird für die Parallaxenokklusionskartierung verwendet). </li></ol><br>  Bei Verwendung wurden Lichtemissionsinformationen direkt zum Shader hinzugefügt.  Wir fanden es nicht notwendig, Umgebungsokklusion zu haben, da in den meisten Szenen überhaupt keine Umgebungsbeleuchtung vorhanden ist.  Ich bin jedoch nicht überrascht, dass wir zusätzliche Ebenen oder andere Arten von Informationen haben werden, zum Beispiel Anisotropie oder Opazität. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b8/185/de9/8b8185de93298b085276109a8f30efef.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2c/6bb/876/a2c6bb876297e1b0a21fbe8463e19b66.jpg"></div><br>  Die obigen Bilder zeigen ein kürzlich durchgeführtes Experiment zur Erzeugung einer lokalen Umgebungsokklusion basierend auf der Höhe.  Für jede Richtung gehen wir eine vorgegebene Entfernung durch und behalten die größte Steigung bei (Höhenunterschied geteilt durch Entfernung).  Dann berechnen wir die Okklusion aus der durchschnittlichen Steigung. <br><br><h2>  Einschränkungen und zukünftige Arbeit </h2><br>  Wie Sie sehen, hat sich die neue Struktur gegenüber der alten Struktur erheblich verbessert.  Darüber hinaus fördert sie den kreativen Ausdruck.  Sie hat jedoch immer noch Einschränkungen, die wir in Zukunft beseitigen wollen. <br><br>  Obwohl es in diesem Intro keine Probleme gab, haben wir festgestellt, dass die Speicherzuweisung ein Hindernis sein kann.  Beim Generieren von Texturen wird ein Array von Float-Werten verwendet.  Bei großen Texturen mit vielen Ebenen können Sie schnell auf ein Problem mit der Speicherzuweisung stoßen.  Es gibt verschiedene Möglichkeiten, dies zu lösen, aber alle haben ihre Nachteile.  Zum Beispiel können wir Texturen Kachel für Kachel erzeugen, während die Skalierbarkeit besser ist. Die Implementierung einiger Operationen, wie z. B. der Faltung, wird jedoch weniger offensichtlich. <br><br>  Darüber hinaus haben wir in diesem Artikel trotz des verwendeten Wortes „Materialien“ nur über Texturen gesprochen, nicht aber über Shader.  Die Verwendung von Materialien sollte jedoch auch zu Shadern führen.  Dieser Widerspruch spiegelt die Einschränkungen der vorhandenen Struktur wider: Texturgenerierung und Schattierung sind zwei separate Teile, die durch eine Brücke getrennt sind.  Wir haben versucht, das Überqueren dieser Brücke zu vereinfachen, aber wir möchten, dass diese Teile eins werden.  Wenn ein Material beispielsweise sowohl statische als auch dynamische Parameter hat, möchten wir diese an einer Stelle beschreiben.  Dies ist ein komplexes Thema, und wir wissen noch nicht, ob es eine gute Lösung gibt, aber lassen Sie uns nicht weiterkommen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/ee7/42d/0a5ee742d8f5f83b3f0255176caa90c3.jpg" alt="Bild"></div><br>  <i>Ein Experiment zur Erzeugung einer Stoffstruktur ähnlich der oben gezeigten Arbeit von Imadol Delgado.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419007/">https://habr.com/ru/post/de419007/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418997/index.html">Echter Beitrag zu Real Open Source</a></li>
<li><a href="../de418999/index.html">[Ankündigung, Peter] JUG.ru-Treffen mit Andrei Belyaev und Alexei Stukalov - Troll unterdrückt KUBA: FAQ</a></li>
<li><a href="../de419001/index.html">5 „Super Skills“, die für die Arbeit der Zukunft notwendig sind</a></li>
<li><a href="../de419003/index.html">Blockchain News Digest</a></li>
<li><a href="../de419005/index.html">Ausflug zum Umspannwerk 220/110/20</a></li>
<li><a href="../de419009/index.html">Clang und IDE: Eine Geschichte über Freundschaft und Freundschaft</a></li>
<li><a href="../de419011/index.html">Jinja2 in der C ++ - Welt, Teil zwei. Rendern</a></li>
<li><a href="../de419013/index.html">Trichterbasierte Zuordnung für SaaS-B2B-Unternehmen - da wir den Wert aller Marketingbemühungen berücksichtigt haben</a></li>
<li><a href="../de419017/index.html">Was ist neu in ConstraintLayout 1.1?</a></li>
<li><a href="../de419019/index.html">AlterEgo: Ein Gerät, das (einige) Gedanken lesen kann</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>