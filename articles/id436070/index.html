<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🍳 🚏 ⚙️ Bagaimana cara menghadapi tes yang rapuh di komunitas opensource 🕚 🖕🏿 🧑🏿‍🤝‍🧑🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak proyek menghadapi masalah tes serpihan, dan topik ini telah diangkat lebih dari satu kali di Habré. Tes yang belum memutuskan kondisinya secara...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara menghadapi tes yang rapuh di komunitas opensource</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/436070/">  Banyak proyek menghadapi masalah tes serpihan, dan topik ini telah diangkat lebih dari satu kali di Habré.  Tes yang belum memutuskan kondisinya secara konstan tidak hanya memakan waktu mesin, tetapi juga waktu pengembang dan penguji.  Dan jika di perusahaan komersial Anda dapat mengalokasikan sumber daya tertentu untuk menyelesaikan masalah ini dan menunjuk orang yang bertanggung jawab, maka di komunitas opensource itu tidak begitu sederhana.  Terutama ketika menyangkut proyek besar - misalnya, seperti Apache Ignite, di mana ada hampir 60 ribu tes berbeda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f92/3f5/dd2/f923f5dd2d414a1737fb093c3e0ddac4.png"><br><br>  Dalam posting ini, kami, pada kenyataannya, akan memberi tahu Anda cara mengatasi masalah ini di Apache Ignite.  Kami adalah Dmitry Pavlov, insinyur perangkat lunak / manajer komunitas terkemuka di GridGain, dan Nikolai Kulagin, insinyur TI di Sberbank Technologies. <br><a name="habracut"></a><br>  <i>Segala sesuatu yang tertulis di bawah ini tidak mewakili posisi perusahaan mana pun, termasuk Sberbank.</i>  <i>Kisah ini secara eksklusif dari anggota komunitas Apache Ignite.</i> <br><br><h2>  Apache Menyalakan dan menguji </h2><br>  Kisah Apache Ignite dimulai pada 2014, ketika GridGain menyumbangkan versi pertama produk internal ke Apache Software Foundation.  Lebih dari 4 tahun telah berlalu sejak itu, dan selama ini jumlah tes mendekati tanda 60 ribu. <br><br>  Kami menggunakan JetBrains TeamCity sebagai server integrasi berkelanjutan - terima kasih kepada orang-orang dari JetBrains untuk mendukung pergerakan sumber terbuka.  Semua tes kami didistribusikan di antara suite-suite, yang jumlahnya untuk cabang master hampir mencapai 140. Di suite-suite tersebut, tes-tes tersebut dikelompokkan berdasarkan beberapa kriteria.  Ini dapat menguji hanya fungsionalitas Machine Learning [RunMl], hanya cache [RunCache], atau seluruh [RunAll].  Di masa depan, jangka waktu pengujian akan berarti persis [RunAll] - pemeriksaan lengkap.  Butuh sekitar 55 jam waktu mesin. <br><br>  Junit digunakan sebagai perpustakaan utama, tetapi ada beberapa tes unit.  Sebagian besar, semua tes kami adalah tes integrasi, karena berisi peluncuran satu atau lebih node (dan ini membutuhkan beberapa detik).  Tentu saja, tes integrasi nyaman karena satu tes tersebut mencakup banyak aspek dan interaksi, yang cukup sulit untuk dicapai dengan uji unit tunggal.  Tetapi ada juga kelemahannya: dalam kasus kami, ini adalah waktu yang cukup lama, serta kesulitan menemukan masalah. <br><br><h2>  Masalah dengan serpihan </h2><br>  Sebagian dari tes ini bersisik.  Sekarang, menurut klasifikasi TeamCity, sekitar 1.700 tes ditandai sebagai serpihan - yaitu, dengan perubahan status tanpa mengubah kode atau konfigurasi.  Tes semacam itu tidak dapat diabaikan, karena ada risiko mendapatkan bug dalam produksi.  Oleh karena itu, mereka harus diperiksa ulang dan dimulai kembali, kadang-kadang beberapa kali, untuk menganalisis hasil jatuh - dan ini membutuhkan waktu dan upaya yang berharga.  Dan jika anggota masyarakat yang ada mengatasi tugas ini, maka bagi kontributor baru ini dapat menjadi penghalang nyata.  Anda harus mengakui bahwa ketika Anda membuat perubahan pada Java Doc, Anda tidak berharap akan mengalami crash, tetapi tidak satu, tetapi beberapa lusin. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/723/db8/c6b/723db8c6b70264074788f6783717f2b6.png"><br><br><h2>  Siapa yang harus disalahkan? </h2><br>  Setengah dari masalah dengan tes bersisik muncul karena konfigurasi peralatan, karena ukuran instalasi.  Dan babak kedua terhubung langsung dengan orang-orang yang ketinggalan dan tidak memperbaiki bug mereka. <br><br>  Secara konvensional, semua anggota masyarakat dapat dibagi menjadi dua kelompok: <br><br><ul><li>  Penggemar yang memasuki komunitas atas kehendak bebas mereka sendiri dan berkontribusi pada waktu luang mereka. <br></li><li>  Kontributor penuh yang bekerja untuk perusahaan yang entah bagaimana menggunakan atau dikaitkan dengan produk sumber terbuka ini. <br></li></ul><br>  Kontributor dari grup pertama dapat membuat satu pengeditan dan meninggalkan komunitas.  Dan untuk mencapainya jika terdeteksi bug hampir tidak mungkin.  Lebih mudah untuk berinteraksi dengan orang-orang dari kelompok kedua, mereka lebih cenderung merespon tes yang mereka hancurkan.  Tetapi kebetulan sebuah perusahaan yang sebelumnya tertarik pada suatu produk tidak lagi membutuhkannya.  Dia meninggalkan komunitas, dan karyawannya yang berkontribusi ikut bersamanya.  Atau mungkin saja kontributor meninggalkan perusahaan, dan bersama komunitas.  Tentu saja, setelah perubahan tersebut, beberapa masih terus berpartisipasi dalam komunitas.  Tapi tidak semua. <br><br><h2>  Siapa yang akan memperbaikinya? </h2><br>  Jika kita berbicara tentang orang yang meninggalkan komunitas, maka bug mereka, tentu saja, pergi ke kontributor saat ini.  Perlu dicatat bahwa untuk revisi yang mengarah ke bug, peninjau juga bertanggung jawab, tetapi ia mungkin juga seorang penggila - yaitu, ia tidak akan selalu tersedia. <br><br>  Kebetulan menjangkau seseorang, katakan padanya: ini masalahnya.  Tapi dia berkata: tidak, ini bukan perbaikan saya memperkenalkan bug.  Karena menjalankan penuh cabang master secara otomatis dilakukan dengan antrian yang relatif bebas, ini paling sering terjadi pada malam hari.  Sebelum ini, beberapa komitmen dapat dicurahkan ke cabang sepanjang hari. <br><br>  Di TeamCity, modifikasi kode apa pun dianggap sebagai changelog.  Jika setelah tiga pengubah kami mengalami penurunan baru, maka tiga orang akan mengatakan bahwa ini bukan karena komitmen mereka.  Jika ada lima changer, maka kami akan mendengarnya dari lima orang. <br><br>  Masalah lain: untuk memberi tahu kontributor bahwa tes harus dijalankan sebelum setiap tinjauan.  Beberapa tidak tahu di mana, apa dan bagaimana menjalankannya.  Atau tes dijalankan, tetapi kontributor tidak menulis tentang itu di tiket.  Ada masalah pada tahap ini juga. <br><br>  Silakan.  Misalkan tes dijalankan, dan di tiket ada tautan ke hasilnya.  Tapi, ternyata, ini tidak memberikan jaminan analisis uji run-through.  Kontributor dapat melihat larinya, melihat beberapa tetes di sana, tetapi menulis "TeamCity Looks Good".  Peninjau - terutama jika ia akrab dengan kontributor atau telah berhasil memeriksanya sebelumnya - mungkin tidak benar-benar melihat hasilnya.  Dan kami mendapatkan "TeamCity Looks Good": <br><br><img src="https://habrastorage.org/getpro/habr/post_images/055/26c/db2/05526cdb20d19b264ac4750695e46dee.png"><br><br>  Di mana "Bagus" ada di sini tidak jelas.  Namun ternyata, penulis setidaknya tahu bahwa tes perlu dijalankan. <br><br><h2>  Bagaimana kami melawan ini </h2><br><h3>  Metode 1. Tes terpisah </h3><br>  Kami membagi tes menjadi dua kelompok.  Dalam yang pertama, "bersih" - tes stabil.  Di kedua - tidak stabil.  Pendekatannya cukup jelas, tetapi tidak berhasil meskipun dengan dua upaya.  Mengapa  Karena sebuah suite dengan tes yang tidak stabil berubah menjadi ghetto di mana sesuatu mulai tentu saja time out, crash, dll.  Akibatnya, semua orang mulai mengabaikan tes yang selalu bermasalah ini.  Secara umum, tidak ada gunanya membagi tes berdasarkan kelas. <br><br><h4>  Metode 2. Pemisahan dan pemberitahuan </h4><br>  Opsi kedua mirip dengan yang pertama - untuk mengalokasikan tes yang lebih stabil, dan menjalankan tes PR yang tersisa di malam hari.  Jika ada yang rusak dalam grup stabil, maka pesan dikirim ke kontributor dengan alat TeamCity standar yang mengatakan bahwa sesuatu perlu diperbaiki. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/321/7d1/7ba/3217d17ba4744bf932a498f8c2dcd63d.png"><br><br>  ... 0 orang bereaksi terhadap pesan-pesan ini.  Semua mengabaikan mereka. <br><br><h3>  Metode 3. Pemantauan Harian </h3><br>  Kami membagi suite menjadi beberapa "pengamat", anggota komunitas yang paling bertanggung jawab, dan menandatangani mereka untuk peringatan tentang jatuh.  Akibatnya, dalam praktiknya dikonfirmasi bahwa antusiasme cenderung berakhir.  Kontributor meninggalkan usaha ini dan berhenti memeriksa secara teratur.  Lalu saya melewatkannya, melihat ke sana - dan lagi-lagi sesuatu merangkak ke dalam tuan. <br><br><h3>  Metode 4. Otomatisasi </h3><br>  Setelah metode lain yang gagal, orang-orang dari GridGain ingat utilitas yang dikembangkan sebelumnya yang menambahkan fungsionalitas yang hilang pada saat itu di TeamCity.  Yaitu, kemampuan untuk melihat statistik umum tentang jumlah jatuh: berapa banyak dan apa yang jatuh, memburuk atau meningkatkan hasilnya pada hari berikutnya.  Utilitas ini dikembangkan secara bertahap, laporan ditambahkan, dan diganti namanya.  Kemudian mereka menambahkan notifikasi, diganti namanya lagi.  Jadi ternyata TeamCity Bot.  Sekarang ia memiliki hampir 500 komit dan 7 kontributor dan ia berada dalam repositori Apache tambahan. <br><br>  Apa yang dilakukan bot?  Kemampuannya dapat digabungkan menjadi dua kelompok: <br><br><ul><li>  Pemantauan proyek - pemantauan visual dengan melihat hasil lari, serta pemberitahuan otomatis dalam pesan instan (misalnya, kendur) <br></li><li>  Periksa cabang - analisis pengujian PR, serta mengeluarkan visa dalam tiket. <br></li></ul><br><h2>  Alur Kerja TeamCity Bot </h2><br>  Sebelum Apache Ignite Teamcity Bot, proses "berkontribusi" kepada komunitas adalah sebagai berikut: <br><br><ol><li>  Di JIRA, salah satu tiket dipilih dan diperbaiki; <br></li><li>  Permintaan penarikan dibuat; <br></li><li>  Menjalankan tes yang mungkin dipengaruhi oleh perubahan yang dilakukan; <br></li><li>  Jika tes lulus, permintaan tarik dapat dipratinjau dan dimatikan oleh pengendara. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/1b2/c5c/d81/1b2c5cd81a826ec8e761b8c12b62c7f4.png"><br><br>  Ini terlihat sederhana, tetapi pada kenyataannya poin ketiga dapat menjadi penghalang bagi beberapa kontributor.  Sebagai contoh: seorang pendatang baru di komunitas memutuskan untuk memberikan kontribusi pertamanya dengan memilih tiket paling sederhana.  Ini dapat mengedit Java Doc atau memperbarui versi ketergantungan maven.  Menganalisis hasil lari dalam perbaikan kecilnya, ia tiba-tiba menemukan bahwa sekitar 30 tes telah jatuh.  Dari mana datangnya sejumlah tes gagal dan bagaimana menganalisisnya - dia tidak tahu.  Mungkin diharapkan bahwa kontributor tidak akan pernah kembali ke sini lagi. <br><br>  Anggota masyarakat yang lebih berpengalaman juga menderita keripik - mereka menghabiskan waktu menganalisis tes yang jatuh secara kebetulan, dan dengan demikian menghambat pengembangan produk. <br><img src="https://habrastorage.org/getpro/habr/post_images/c42/290/ffb/c42290ffb3ead465704b6a3a990b09b2.png"><br>  <i>Skema kontribusi dengan TeamCity Bot</i> <br><br>  Dengan munculnya bot, langkah-langkah dalam counterplay meningkat, tetapi waktu yang dihabiskan untuk menganalisis tes jatuh menurun secara signifikan.  Sekarang cukup untuk menjalankan tes dan setelah lulus, lihat halaman bot yang sesuai.  Jika ada kemungkinan pemblokir (tes yang dibatalkan yang tidak dianggap serpihan), cukup untuk melakukan pemeriksaan ganda, yang akan menghasilkan visa dalam bentuk komentar di JIRA dengan hasil tes. <br><br><h2>  Ikhtisar Fitur </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/07c/a1b/a0e/07ca1ba0eb4d07a1537e75062eda2dd5.png"><br><br>  <i>Periksa Kontribusi - daftar semua PR yang tidak tertutup dengan ringkasan setiap informasi: tanggal pembaruan terakhir, nomor PR, nama, penulis, dan tiket di JIRA</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d9/7ec/2f8/6d97ec2f8eba182718d88d291edfa58d.png"><br>  <i>Untuk setiap permintaan tarik, tersedia tab dengan informasi yang lebih terperinci: nama PR yang benar, tanpanya bot tidak akan dapat menemukan tiket yang diinginkan di JIRA;</i>  <i>apakah tes dijalankan;</i>  <i>apakah hasil tes siap;</i>  <i>meninggalkan komentar di JIRA.</i> <br><br>  Analisis hasil tes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed8/104/3c2/ed81043c26693ca7f40f3f9379797b7a.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/c42/a79/22c/c42a7922ce4b4163c9561bfaa4964ea9.png"><br><br>  Berikut adalah dua laporan tentang pengujian PR yang sama.  Yang pertama adalah dari bot.  Yang kedua adalah laporan standar tentang Teamcity.  Perbedaan dalam jumlah informasi jelas, dan ini tidak memperhitungkan fakta bahwa untuk melihat riwayat uji coba TC, perlu juga untuk membuat beberapa transisi ke halaman yang berdekatan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c66/7d5/24d/c667d524d85a956b5aca555343056563.png"><br><br>  Mari kita kembali ke laporan bot.  Laporan ini secara visual dibagi menjadi dua tabel: kemungkinan blocker dan semua crash.  Blocker termasuk tes yang: <br><br><ul><li>  memiliki tingkat kegagalan dalam master kurang dari 4% (kurang dari 4 mulai dari 100 tidak berhasil); <br></li><li>  tidak serpihan menurut klasifikasi TeamCity; <br></li><li>  jatuh karena batas waktu, kehabisan memori, kode keluar, kegagalan JVM. <br></li></ul><br>  Misalnya, pada tangkapan layar di atas, dua suite diindikasikan sebagai kemungkinan pemblokir - yang pertama, tes jatuh, dan yang kedua, timeout terjadi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/867/ba7/53b/867ba753b7fee200ae041c36c30fc136.png"><br><br>  Untuk akhirnya memahami apa itu tes serpihan, dan apa itu bug, perhatikan gambar di atas.  Bilah horizontal 100 berjalan.  Bilah hijau vertikal - berhasil melewati tes, red-drop.  Dalam kasus bug, run history tampak alami: bilah hijau polos pada akhirnya berubah warna menjadi merah.  Ini berarti bahwa di tempat inilah bug muncul dan tes mulai turun terus-menerus.  Jika kita memiliki tes serpihan di hadapan kita, maka riwayat larinya adalah pergantian terus menerus warna hijau dan merah. <br><br>  Analisis Hasil Uji <br><br><img src="https://habrastorage.org/getpro/habr/post_images/faa/050/154/faa050154f92d1cd4cb388efa59f461d.png"><br><br>  Sebagai contoh, kami menganalisis hasil lulus tes dalam tangkapan layar di atas.  Menurut versi bot, mungkin ada dua crash karena bug - mereka terdaftar di tabel Kemungkinan Pemblokir.  Tapi itu mungkin tes yang rapuh dengan tingkat kegagalan yang rendah.  Untuk mengecualikan opsi ini, cukup klik tombol Jalankan kembali kemungkinan blocker, dan dua suite ini akan pergi untuk memeriksa ulang.  Untuk membuat tugas lebih mudah, Anda dapat mengklik Jalankan kembali kemungkinan pemblokir &amp; komentar JIRA, dan dapatkan komentar (dan dengan itu pemberitahuan melalui email) dari bot setelah pemeriksaan selesai.  Lalu masuk dan lihat apakah ada masalah atau tidak. <br><br>  Untuk pengulas, ini sangat keren.  Anda bisa lupa tentang pengeditan yang tidak lulus pemeriksaan, tetapi cukup klik pada sejumlah pengeditan, klik tombol Re-run hijau besar dan tunggu suratnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb0/352/de5/eb0352de55fe68f17e69139426ac4474.png"><br>  <i>Laporan sempurna: tidak ada pemblokir yang terdeteksi</i> <i><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce9/8aa/303/ce98aa3034b0b39391aa1fe4db081375.png"><br></i>  <i>Visa hijau (komentar) bot.</i>  <i>Tidak ada pemblokir yang ditemukan.</i> <i><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c5/be4/802/9c5be48026aad0175d690636ea5d14d9.png"><br></i>  <i>Diperlukan visa merah - memeriksa ulang dan / atau mengedit bug</i> <br><br>  Kebetulan beberapa bug masih bocor ke "master".  Seperti yang kami katakan, sebelum ini diperjuangkan melalui pemberitahuan pribadi.  Atau seseorang memastikan tidak ada yang jatuh.  Sekarang kami menggunakan solusi yang lebih sederhana: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/57d/c82/90f/57dc8290f1643362d93ff95e497ce36c.png"><br><br>  Ketika bug baru terdeteksi, sebuah pesan dikirim ke dev-list, yang mengindikasikan kontributor dan penggantinya, yang mungkin menjadi penyebab kesalahan.  Jadi seluruh komunitas akan mencari tahu siapa yang menyebabkan semuanya terjadi. <br><br>  Dengan demikian, kami dapat meningkatkan jumlah perbaikan panas dan sangat mengurangi waktu yang diperlukan untuk memperbaiki masalah. <br><br>  Memantau status penyihir <br>  Fungsi bot lainnya adalah memantau keadaan wizard dengan statistik pada peluncuran terbaru. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce6/3da/e80/ce63dae8033464df004d8a168e75c9c1.png"><br><br>  Tren master <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/d34/ecc/ab4d34ecc348552b4de5804a1b66a7a6.png"><br><br>  Halaman tren Master membandingkan dua pilihan "master" untuk periode waktu tertentu.  Untuk setiap item dalam tabel menampilkan nilai maksimum, minimum, dan median. <br><img src="https://habrastorage.org/getpro/habr/post_images/564/8c5/fd1/5648c5fd1dd4080a736856bf2d9afbd3.png"><br><br>  Selain hasil umum untuk seluruh sampel, tabel berisi grafik untuk setiap indikator dengan tampilan nilai masing-masing bangunan.  Dengan mengklik suatu titik, Anda dapat pergi ke hasil lari di TeamCity.  Selain itu, dimungkinkan untuk menghapus hasil dari statistik.  Ini berguna ketika nilai abnormal terjadi karena gangguan serius, yang mungkin tidak disalahkan oleh kontributor.  Hasil tersebut harus dikecualikan sehingga mereka tidak diperhitungkan saat menghitung tes serpihan yang sama.  Selain itu, build juga dapat dibedakan untuk melacak hasil untuk setiap indikator. <br><br>  Apache Ignite Teamcity Bot sekarang memiliki lebih dari 65 anggota terdaftar.  Selama seluruh periode penggunaan bot, visa menerima lebih dari 400 permintaan tarik, dan rata-rata lima visa dikeluarkan per hari. <br><br><h2>  Struktur Bot TeamCity </h2><br>  Bot di-host di server terpisah, menuju ke ignite.apache.org untuk data, secara publik memberi tahu semua orang di daftar-dev - ini adalah platform utama kami untuk pengembang Ignite - dan menulis visa untuk tiket melalui API JIRA. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/609/73e/734/60973e7345a076dbabedb9ef35921b7e.png"><br><br>  Ia menggunakan server Jetty, servlets Jersey, sejumlah layanan dengan logika bisnis yang kompleks dari bot itu sendiri, termasuk layanan Teamcity, JIRA dan GitHub yang mengakses layanan Ignited Integration.  Di atas Integrasi Murni ini untuk permintaan http.  Sebagai penyimpanan - produk Apache Ignite sendiri dalam mode tertanam konfigurasi Node Tunggal dengan kegigihan aktif.  Selain keuntungan nyata menggunakan Ignite sebagai basis data, ini juga membantu kami menemukan berbagai area penerapan Ignite dan memahami apa yang nyaman dan apa yang tidak. <br><br>  Versi pertama dari implementasi bot terinspirasi oleh satu artikel tentang cache REST dan merupakan cache REST dan layanan GitHub dan Teamcity.  Teamcity xml dan json yang dikembalikan dari server diuraikan oleh Pure Java Objects, yang kemudian di-cache.  Pada awalnya itu berhasil, dan cukup cepat.  Tetapi dengan peningkatan jumlah data, hasilnya mulai memburuk. <br><br>  Perlu dicatat bahwa TeamCity menghapus cerita yang lebih tua dari ~ 2 minggu, tetapi bot tidak melakukannya.  Pada akhirnya, dengan pendekatan ini, banyak data muncul yang sangat sulit dikelola. <br><br><h2>  Pengembangan Bot TeamCity </h2><br>  Pendekatan baru mengimplementasikan opsi penyimpanan data yang ringkas dan memilih sejumlah kecil partisi cache.  Sejumlah besar partisi pada satu node secara negatif mempengaruhi kecepatan sinkronisasi data ke disk dan meningkatkan waktu mulai cluster. <br><br>  Semua pembaruan data utama dilakukan secara tidak sinkron, karena jika tidak, kami berisiko mendapatkan UX yang buruk karena lambatnya pengembalian data TeamCity. <br><br>  Untuk string yang jarang mengubah nilainya (misalnya, nama tes), pemetaan sederhana dilakukan dalam id, yang dihasilkan oleh Urutan Atom.  Berikut adalah contoh Entri tersebut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/408/1f8/1f5/4081f81f553eb5b318799e11ea847043.png"><br><br>  Nama uji panjang sesuai dengan nomor int, yang disimpan di semua build.  Ini menghemat banyak sumber daya.  Di atas metode yang mengembalikan baris ini adalah pencegat cache dalam-memori Guava.  Berkat penjelasan cache, bahkan di heap kami tidak memilih baris dengan membacanya dari Ignite by id.  Dan dengan id kita selalu mendapatkan baris yang sama, yang bagus untuk kinerja. <br><br>  Untuk garis "yang tidak dapat diprediksi", misalnya, log jejak tumpukan, berbagai jenis kompresi digunakan - kompresi gzip, kompresi tajam atau tidak terkompresi, tergantung mana yang lebih baik.  Semua metode ini membantu menyesuaikan data maksimum dalam memori dan dengan cepat memberikan respons kepada klien. <br><br><h2>  Mengapa TeamCity Bot Lebih Baik </h2><br>  Ini bukan untuk mengatakan bahwa TeamCity tidak memiliki fitur yang tercantum di atas.  Mereka, tetapi tersebar di tumpukan tempat yang berbeda.  Di bot, semuanya dikumpulkan pada satu halaman dan Anda dapat dengan cepat memahami apa masalahnya. <br><br>  Tambahan yang bagus adalah surat yang dikirimkan bot pada lembar dev ketika mendeteksi masalah.  Segera di komunitas ada kesempatan untuk memulai diskusi: "Ayo, mungkin, sekarang kita akan mundur?".  Ini menambah kepercayaan bagi pengulas. <br><br>  Dengan bot, jauh lebih mudah bagi kontributor baru untuk bergabung dalam proses pengembangan.  Membuat perbaikan pertama Anda, Anda tidak selalu tahu apa perubahan yang mungkin terjadi.  Dan terjun langsung ke analisis hasil pengujian pada TeamCity, Anda dapat dengan mudah kehilangan antusiasme untuk pengembangan lebih lanjut.  Apache Ignite TeamCity Bot akan membantu Anda dengan cepat memahami jika ada masalah dan mempertahankan antusiasme. <br><br>  Kami berharap bot akan menyederhanakan kehidupan kontributor saat ini dan menarik orang baru ke komunitas.  Akhirnya, kami menyarankan, tentu saja, untuk mencegah kemunculan sejumlah besar tes yang tidak pasti, karena sulit untuk mengatasinya.  Dan robot kepercayaan - mereka tidak memiliki preferensi dan mereka tidak mengambil kata-kata orang untuk itu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436070/">https://habr.com/ru/post/id436070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436060/index.html">Solusi arsitektur untuk gim seluler. Bagian 3: Lihat di dorongan jet</a></li>
<li><a href="../id436062/index.html">Sistem arbitrasi untuk pemula, bagian 1</a></li>
<li><a href="../id436064/index.html">Kecerdasan buatan untuk semua orang</a></li>
<li><a href="../id436066/index.html">Matematika Kiamat: Teori Permainan dan Krisis Nuklir Karibia</a></li>
<li><a href="../id436068/index.html">C ++ Russia Conference 2019</a></li>
<li><a href="../id436072/index.html">Bersih, mark up: bagaimana kami mengajar chatbot untuk membedakan masalah klien</a></li>
<li><a href="../id436076/index.html">Analisis Serangan Cowrie Hanipot</a></li>
<li><a href="../id436080/index.html">Minggu Keamanan 03: 2019 - Tahun Privasi</a></li>
<li><a href="../id436082/index.html">Bagaimana UEBA Membantu Meningkatkan Keamanan Siber</a></li>
<li><a href="../id436086/index.html">Gambaran Umum Pembaruan 4 untuk Veeam Cloud Connect</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>