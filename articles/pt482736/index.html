<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õëÔ∏è üëú üèÇüèø Usando o TSDuck para monitorar fluxos de IP (TS) ‚ò†Ô∏è üë¶üèΩ ‚õÖÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje, existem solu√ß√µes prontas (propriet√°rias) para monitorar fluxos de IP (TS), por exemplo, VB e iQ , elas t√™m um conjunto bastante rico de fun√ß√µes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usando o TSDuck para monitorar fluxos de IP (TS)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482736/"><p>  Hoje, existem solu√ß√µes prontas (propriet√°rias) para monitorar fluxos de IP (TS), por exemplo, <a href="https://bridgetech.tv/all-products/" rel="nofollow">VB</a> e <a href="https://www.telestream.net/pdfs/iq/productsheets/Surveyor_TS_New.pdf" rel="nofollow">iQ</a> , elas t√™m um conjunto bastante rico de fun√ß√µes e geralmente essas solu√ß√µes est√£o dispon√≠veis para grandes operadoras que lidam com servi√ßos de TV.  Este artigo descreve uma solu√ß√£o baseada no projeto de c√≥digo aberto <a href="https://tsduck.io/" rel="nofollow">TSDuck</a> , projetado para controle m√≠nimo de fluxos de IP (TS) pelo contador CC (contador de continuidade) e taxa de bits.  Uma aplica√ß√£o poss√≠vel √© controlar a perda de pacotes ou o fluxo inteiro atrav√©s de um canal L2 alugado (que n√£o pode ser monitorado normalmente, por exemplo, lendo os contadores de perda nas filas). </p><br><h2 id="ochen-kratko-o-tsduck">  Muito breve sobre o TSDuck </h2><br><p> O TSDuck √© um software de c√≥digo aberto (licen√ßa BSD de 2 cl√°usulas) (um conjunto de utilit√°rios de console e uma biblioteca para desenvolver seus utilit√°rios ou plug-ins) para manipular fluxos de TS.  Como entrada, ele pode trabalhar com IP (multicast / unicast), http, hls, sintonizadores dvb, demodec dvb-asi demodulador, existe um gerador interno de fluxo TS e leitura de arquivos.  A sa√≠da pode ser um arquivo, IP (multicast / unicast), hls, dektec dvb-asi e moduladores HiDes, players (mplayer, vlc, xine) e drop.  Entre a entrada e a sa√≠da, voc√™ pode ativar v√°rios processadores de tr√°fego, por exemplo, remapeamento do PID, embaralhamento / desembaralhamento, an√°lise de contadores CC, c√°lculo de taxa de bits e outras opera√ß√µes t√≠picas de fluxos TS. </p><a name="habracut"></a><br><p>  Neste artigo, os fluxos IP (multicast) ser√£o usados ‚Äã‚Äãcomo entrada, os processadores bitrate_monitor ser√£o usados ‚Äã‚Äã(a partir do nome fica claro o que √©) e a continuidade (an√°lise dos contadores CC).  Sem problemas, voc√™ pode substituir o multicast IP por outro tipo de entrada suportado pelo TSDuck. </p><br><p>  Existem <a href="https://tsduck.io/download/tsduck/" rel="nofollow">compila√ß√µes / pacotes oficiais do</a> TSDuck para a maioria dos sistemas operacionais atuais.  Para o Debian, eles n√£o s√£o, mas foi poss√≠vel montar sem problemas no debian 8 e no debian 10. </p><br><p>  Em seguida, √© usada a vers√£o TSDuck 3.19-1520, o Linux √© usado como sistema operacional (o debian 10 foi usado para preparar a solu√ß√£o, o CentOS 7 foi usado para uso real) </p><br><h2 id="podgotovka-tsduck-i-os">  Preparando TSDuck e OS </h2><br><p>  Antes de monitorar os fluxos reais, √© necess√°rio garantir que o TSDuck esteja funcionando corretamente e que n√£o haja quedas no n√≠vel da placa de rede ou do SO (soquete).  Isso √© necess√°rio para n√£o adivinhar mais tarde onde as quedas ocorreram - na rede ou "dentro do servidor".  Voc√™ pode verificar as quedas no n√≠vel da placa de rede com o comando ethtool -S ethX, o ajuste √© feito com o mesmo ethtool (geralmente, voc√™ precisa aumentar o buffer RX (-G) e √†s vezes desativar algumas descargas (-K)).  Como recomenda√ß√£o geral, voc√™ pode recomendar o uso de uma porta separada para receber o tr√°fego analisado, se poss√≠vel, isso minimiza os falsos positivos associados ao fato de que a queda ocorreu de forma coerente na porta do analisador devido √† presen√ßa de outro tr√°fego.  Se isso n√£o for poss√≠vel (um mini computador / NUC com uma √∫nica porta √© usado), √© altamente desej√°vel priorizar o tr√°fego analisado em rela√ß√£o ao restante no dispositivo no qual o analisador est√° conectado.  Em rela√ß√£o aos ambientes virtuais, aqui voc√™ precisa ter cuidado e encontrar quedas de pacotes come√ßando na porta f√≠sica e terminando com o aplicativo dentro da m√°quina virtual. </p><br><h3 id="generaciya-i-priyom-potoka-vnutri-hosta">  Gera√ß√£o e recep√ß√£o de um fluxo dentro do host </h3><br><p>  Como primeiro passo na prepara√ß√£o do TSDuck, geraremos e receberemos tr√°fego dentro do mesmo host usando netns. </p><br><p>  Ambiente de cozimento: </p><br><pre><code class="bash hljs">ip netns add P <span class="hljs-comment"><span class="hljs-comment"># netns P,       ip link add type veth # veth- - veth0   netns   (     ) ip link set dev veth1 netns P #veth1 -   netns P (     ) ip netns exec P ifconfig veth1 192.0.2.1/30 up # IP  veth1,      ip netns exec P ip ro add default via 192.0.2.2 #     nents P sysctl net.ipv6.conf.veth0.disable_ipv6=1 # IPv6  veth0 -    ,    TX     ifconfig veth0 up #  veth0 ip route add 239.0.0.1 dev veth0 # ,      239.0.0.1   veth0</span></span></code> </pre> <br><p>  O ambiente est√° pronto.  Iniciamos o analisador de tr√°fego: </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> P tsp --realtime -t \ -I ip 239.0.0.1:1234 \ -P continuity \ -P bitrate_monitor -p 1 -t 1 \ -O drop</code> </pre> <br><p>  onde "-p 1 -t 1" significa que voc√™ precisa calcular a taxa de bits a cada segundo e exibir informa√ß√µes sobre a taxa de bits a cada segundo <br>  Iniciamos o gerador de tr√°fego com uma velocidade de 10 Mbps: </p><br><pre> <code class="bash hljs">tsp -I craft \ -P regulate -b 10000000 \ -O ip -p 7 -e --<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>-port 6000 239.0.0.1:1234</code> </pre> <br><p>  onde "-p 7 -e" significa que voc√™ precisa compactar 7 pacotes TS em 1 pacote IP e faz√™-lo com for√ßa (-e), ou seja,  sempre aguarde 7 pacotes TS do √∫ltimo processador antes de enviar um pacote IP. </p><br><p>  O analisador come√ßa a exibir as mensagens esperadas: </p><br><pre> <code class="plaintext hljs">* 2020/01/03 14:55:44 - bitrate_monitor: 2020/01/03 14:55:44, TS bitrate: 9,970,016 bits/s * 2020/01/03 14:55:45 - bitrate_monitor: 2020/01/03 14:55:45, TS bitrate: 10,022,656 bits/s * 2020/01/03 14:55:46 - bitrate_monitor: 2020/01/03 14:55:46, TS bitrate: 9,980,544 bits/s</code> </pre> <br><p>  Agora adicione algumas gotas: </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> P iptables -I INPUT -d 239.0.0.1 -m statistic --mode random --probability 0.001 -j DROP</code> </pre> <br><p>  e mensagens como estas aparecem: </p><br><pre> <code class="plaintext hljs">* 2020/01/03 14:57:11 - continuity: packet index: 80,745, PID: 0x0000, missing 7 packets * 2020/01/03 14:57:11 - continuity: packet index: 83,342, PID: 0x0000, missing 7 packets</code> </pre> <br><p>  o que √© esperado.  Desative a perda de pacotes (exec netns ip Ptables-F) e tente aumentar a taxa de bits do gerador para 100 Mbps.  O analisador relata v√°rios erros de CC e cerca de 75 Mbit / s em vez de 100. Tentamos descobrir quem √© o culpado - o gerador n√£o tem tempo ou o problema n√£o existe, por isso come√ßamos a gerar um n√∫mero fixo de pacotes (700.000 pacotes TS = 100.000 pacotes IP): </p><br><pre> <code class="plaintext hljs"># ifconfig veth0 | grep TX TX packets 151825460 bytes 205725459268 (191.5 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 # tsp -I craft -c 700000 -P regulate -b 100000000 -P count -O ip -p 7 -e --local-port 6000 239.0.0.1:1234 * count: PID 0 (0x0000): 700,000 packets # ifconfig veth0 | grep TX TX packets 151925460 bytes 205861259268 (191.7 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</code> </pre> <br><p>  Como voc√™ pode ver, exatamente 100.000 pacotes IP foram gerados (151925460-151825460).  Ent√£o, entendemos o que acontece com o analisador; para isso, verificamos com o contador RX no veth1, √© estritamente igual ao contador TX no veth0, e depois examinamos o que acontece no n√≠vel do soquete: </p><br><pre> <code class="plaintext hljs"># ip netns exec P cat /proc/net/udp sl local_address rem_address st tx_queue rx_queue tr tm-&gt;when retrnsmt uid timeout inode ref pointer drops 133: 010000EF:04D2 00000000:0000 07 00000000:00000000 00:00000000 00000000 0 0 72338 2 00000000e0a441df 24355</code> </pre> <br><p>  Aqui voc√™ pode ver o n√∫mero de quedas = 24355. Nos pacotes TS, √© 170485 ou 24,36% de 700000; portanto, vemos que os 25% da taxa de bits perdida s√£o quedas no soquete udp.  As quedas em um soquete UDP geralmente ocorrem devido √† falta de um buffer, observe qual √© o tamanho do buffer de soquete padr√£o e o tamanho m√°ximo do buffer de soquete: </p><br><pre> <code class="plaintext hljs"># sysctl net.core.rmem_default net.core.rmem_default = 212992 # sysctl net.core.rmem_max net.core.rmem_max = 212992</code> </pre> <br><p>  Portanto, se os aplicativos n√£o solicitarem explicitamente o tamanho do buffer, os soquetes ser√£o criados com um buffer de 208 KB, mas se solicitarem mais, ainda assim n√£o receber√£o o que √© solicitado.  Como no tsp voc√™ pode definir o tamanho do buffer (--buffer-size) para a entrada IP, n√£o tocaremos no tamanho do soquete por padr√£o, apenas configuramos o tamanho m√°ximo do buffer do soquete e especificamos o tamanho do buffer explicitamente atrav√©s dos argumentos tsp: </p><br><pre> <code class="plaintext hljs">sysctl net.core.rmem_max=8388608 ip netns exec P tsp --realtime -t -I ip 239.0.0.1:1234 -b 8388608 -P continuity -P bitrate_monitor -p 1 -t 1 -O drop</code> </pre> <br><p>  Com esse ajuste do buffer de soquete, a taxa de bits agora relatada √© de aproximadamente 100 Mbit / s, n√£o h√° erros de CC. </p><br><p>  Pelo consumo de CPU pelo pr√≥prio aplicativo TSP.  Em rela√ß√£o a um n√∫cleo da CPU i5-4260U a 1.40GHz, a an√°lise de um fluxo de 10Mbit / s requer 3-4% de CPU, 100Mbit / s - 25%, 200Mbit / s - 46%.  Ao definir% de perda de pacotes, a carga na CPU praticamente n√£o aumenta (mas pode diminuir). </p><br><p>  Em um hardware mais produtivo, foi poss√≠vel gerar e analisar fluxos de mais de 1 Gb / s sem problemas. </p><br><h3 id="testirovanie-na-realnyh-setevyh-kartah">  Teste em placas de rede reais </h3><br><p>  Ap√≥s o teste em um par veth, √© necess√°rio pegar dois hosts ou duas portas de um host, conectar as portas uma √† outra, executar o gerador em uma e o analisador na segunda.  N√£o houve surpresas, mas, na realidade, tudo depende do ferro, quanto mais fraco, mais interessante ser√°. </p><br><h2 id="ispolzovanie-poluchaemyh-dannyh-sistemoy-monitoringa-zabbix">  Uso dos dados recebidos pelo sistema de monitoramento (Zabbix) </h2><br><p>  O Tsp n√£o possui uma API leg√≠vel por m√°quina, como SNMP ou similar.  As mensagens CC precisam ser agregadas por pelo menos 1 segundo (com uma alta porcentagem de perda de pacotes, pode haver centenas / milhares / dezenas de milhares por segundo, dependendo da taxa de bits). </p><br><p>  Assim, para salvar informa√ß√µes e desenhar gr√°ficos de erros de CC e taxa de bits e causar algum tipo de acidente, as seguintes op√ß√µes podem ser ainda mais: </p><br><ol><li>  Analise e agregue (de acordo com CC) a sa√≠da de TSP, ou seja,  converta-o para a forma desejada. </li><li>  Adicione TSP e / ou plugins de processador bitrate_monitor e a continuidade em si para que o resultado seja exibido em um formato leg√≠vel por m√°quina adequado para um sistema de monitoramento. </li><li>  Escreva seu aplicativo na parte superior da biblioteca tsduck. </li></ol><br><p>  Obviamente, do ponto de vista dos custos de m√£o-de-obra, a op√ß√£o 1 √© a mais simples, especialmente considerando que o pr√≥prio tsduck √© escrito em uma linguagem de baixo n√≠vel (pelos padr√µes modernos) (C ++) </p><br><p>  Um prot√≥tipo simples do analisador + agregador no bash mostrou que, em um fluxo de 10 Mbits / s e 50% de perda de pacotes (o pior caso), o processo do bash consumia 3-4 vezes mais CPU que o pr√≥prio processo de TSP.  Este cen√°rio √© inaceit√°vel.  Na verdade, um peda√ßo deste prot√≥tipo abaixo </p><br><div class="spoiler">  <b class="spoiler_title">Macarr√£o na festan√ßa</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash missingPackets=0 ccErrorSeconds=0 regexMissPackets='^\*\ (.+) - continuity:.*missing ([0-9]+) packets$' missingPacketsTime="" ip netns exec P tsp --realtime -t -I ip -b 8388608 "239.0.0.1:1234" -O drop -P bitrate_monitor -p 1 -t 1 -P continuity 2&gt;&amp;1 | \ while read i do #line example:* 2019/12/28 23:41:14 - continuity: packet index: 6,078, PID: 0x0100, missing 5 packets #line example 2: * 2019/12/28 23:55:11 - bitrate_monitor: 2019/12/28 23:55:11, TS bitrate: 4,272,864 bits/s if [[ "$i" == *continuity:* ]] then if [[ "$i" =~ $regexMissPackets ]] then missingPacketsTimeNew="${BASH_REMATCH[1]}" #timestamp (seconds) if [[ "$missingPacketsTime" != "$missingPacketsTimeNew" ]] #new second with CC error then ((ccErrorSeconds += 1)) fi missingPacketsTime=$missingPacketsTimeNew packets=${BASH_REMATCH[2]} #TS missing packets ((missingPackets += packets)) fi elif [[ "$i" == *bitrate_monitor:* ]] then : #... fi done</span></span></code> </pre> </div></div><br><p>  Al√©m do fato de funcionar inaceitavelmente devagar, n√£o h√° threads normais no bash, os trabalhos do bash s√£o processos independentes e eu tive que registrar o valor dePackets ausentes no efeito colateral uma vez por segundo (quando recebo mensagens de taxa de bits que aparecem a cada segundo).  Como resultado, o bash foi deixado sozinho e foi decidido escrever um wrapper (analisador + agregador) no golang.  O consumo de CPU de c√≥digo golang semelhante √© 4-5 vezes menor que o pr√≥prio processo de colher de ch√°.  Acelerar o wrapper substituindo bash por golang resultou em cerca de 16 vezes e, em geral, o resultado √© aceit√°vel (sobrecarga na CPU em 25% no pior caso).  O arquivo de origem no golang est√° <a href="https://github.com/inheb/tsduck-stat/tree/master/tsduck-stat" rel="nofollow">aqui</a> . </p><br><h3 id="zapusk-obyortki">  Lan√ßamento do Wrapper </h3><br><p>  Para executar o wrapper, foi criado o modelo de servi√ßo mais simples para systemd ( <a href="https://github.com/inheb/tsduck-stat/tree/master/systemd" rel="nofollow">aqui</a> ).  Sup√µe-se que o pr√≥prio wrapper seja compilado em um arquivo bin√°rio (v√° compilar tsduck-stat.go), localizado em / opt / tsduck-stat /.  Sup√µe-se que o golang seja usado com suporte ao rel√≥gio monot√¥nico (&gt; = 1.9). </p><br><p>  Para criar uma inst√¢ncia do servi√ßo, voc√™ precisa executar o comando systemctl enable tsduck-stat@239.0.0.1: 1234 e come√ßar a usar systemctl start tsduck-stat@239.0.0.1: 1234. </p><br><h3 id="discovery-iz-zabbix">  Descoberta do Zabbix </h3><br><p>  Para que o zabbix possa descobrir servi√ßos em execu√ß√£o, foi criado um <a href="https://github.com/inheb/tsduck-stat/tree/master/tsduck-stat" rel="nofollow">gerador de lista de grupos</a> (discovery.sh), no formato necess√°rio para a descoberta do Zabbix, presume-se que ele esteja localizado l√° - em / opt / tsduck-stat.  Para iniciar a descoberta via zabbix-agent, voc√™ precisa adicionar o <a href="" rel="nofollow">arquivo .conf</a> ao diret√≥rio com as configura√ß√µes do zabbix-agent para adicionar o par√¢metro do usu√°rio. </p><br><h3 id="shablon-zabbix">  Zabbix Template </h3><br><p>  <a href="https://github.com/inheb/tsduck-stat/tree/master/zabbix_templates" rel="nofollow">O modelo criado</a> (tsduck_stat_template.xml) cont√©m a regra de descoberta autom√°tica, prot√≥tipos de elementos de dados, gr√°ficos e acionadores. </p><br><h2 id="kratkiy-cheklist-nu-a-vdrug-kto-to-reshit-vospolzovatsya">  Uma lista curta (bem, e se algu√©m decidir us√°-la) </h2><br><ol><li>  Verifique se o TSP n√£o descarta pacotes nas condi√ß√µes "ideais" (o gerador e o analisador est√£o conectados diretamente); se houver descargas, consulte a se√ß√£o 2 ou o texto do artigo sobre este assunto. </li><li>  Fa√ßa o ajuste do buffer m√°ximo de soquete (net.core.rmem_max = 8388608). </li><li>  Compile tsduck-stat.go (v√° para compilar tsduck-stat.go). </li><li>  Coloque o modelo de servi√ßo em / lib / systemd / system. </li><li>  Inicie os servi√ßos usando systemctl, verifique se os contadores come√ßaram a aparecer (grep "" / dev / shm / tsduck-stat / *).  N√∫mero de servi√ßos pelo n√∫mero de fluxos multicast.  Aqui voc√™ pode precisar criar uma rota para o grupo multicast, talvez desativar o rp_filter ou criar uma rota para o IP de origem. </li><li>  Execute o discovery.sh, verifique se ele gera json. </li><li>  Anexe a configura√ß√£o do agente zabbix, reinicie o agente zabbix. </li><li>  Fa√ßa o download do modelo no zabbix, aplique-o no host no qual o zabbix-agent √© monitorado e instalado, aguarde cerca de 5 minutos, veja se novos elementos de dados, gr√°ficos e gatilhos apareceram. </li></ol><br><h2 id="rezultat">  Resultado </h2><br><p><img src="https://habrastorage.org/webt/ug/rc/5c/ugrc5c87ctd6rylequ7kdha5lze.png" alt="Gr√°ficos com taxa de bits e erros de CC"></p><br><p>  Para a tarefa de detectar a perda de pacotes √© quase suficiente, pelo menos √© melhor do que a falta de monitoramento. </p><br><p>  De fato, podem ocorrer ‚Äúperdas‚Äù de CC ao colar clipes de v√≠deo (at√© onde eu sei, inser√ß√µes s√£o feitas em telecentros locais na Federa√ß√£o Russa, isto √©, sem contar o contador de CC), isso deve ser lembrado.  Em solu√ß√µes propriet√°rias, esse problema √© parcialmente contornado pela detec√ß√£o de r√≥tulos de etiqueta SCTE-35 (se eles forem adicionados pelo gerador de fluxo). <br>  <strong>UPD:</strong> suporte adicionado para tags SCTE-35 no modelo wrapper e zabbix </p><br><p>  Do ponto de vista do monitoramento da qualidade do transporte, n√£o h√° jitter de monitoramento (IAT) suficiente, porque  O equipamento de TV (moduladores ou dispositivos finais) possui requisitos para esse par√¢metro e nem sempre √© poss√≠vel inflar o jitbuffer ao infinito.  E o jitter pode flutuar quando equipamentos com buffers grandes s√£o usados ‚Äã‚Äãem tr√¢nsito e a QoS n√£o est√° configurada ou n√£o est√° bem configurada para transmitir esse tr√°fego em tempo real. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt482736/">https://habr.com/ru/post/pt482736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt482722/index.html">Hist√≥ria fant√°stica "Projeto C. Vaidade das vaidades" (10 min.)</a></li>
<li><a href="../pt482726/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel # 328 (23 a 29 de dezembro)</a></li>
<li><a href="../pt482728/index.html">JPEG. Algoritmo de compress√£o</a></li>
<li><a href="../pt482730/index.html">Enquete de f√©rias</a></li>
<li><a href="../pt482734/index.html">Ofuscar tempo de compila√ß√£o usando NAND / NOR</a></li>
<li><a href="../pt482740/index.html">Entrevista para a posi√ß√£o de um poeta</a></li>
<li><a href="../pt482742/index.html">Entrando no mercado ocidental: como interagir com os clientes</a></li>
<li><a href="../pt482744/index.html">Encontrando uma bala de prata: muni√ß√£o incomum</a></li>
<li><a href="../pt482748/index.html">Criando um neg√≥cio de reserva de t√°xi em Dubai: como iniciar um aplicativo de t√°xi centrado no cliente como Careem & Hala?</a></li>
<li><a href="../pt482752/index.html">"Novas √©picas". N√≥s comemos o elefante em partes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>