<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🍳 ☝🏻 😋 Python中的字典实现 ⌨️ 🤘 👨🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好，4月30日，“ 面向开发人员的算法”课程从OTUS开始，今天的材料专门为此出版。 让我们开始吧。 



 在本文中，您将学习如何在Python中实现字典。 
 使用键对字典进行索引，并且可以将它们视为关联的数组。 让我们在字典中添加3个键/值对： 



>>> d = {'a': 1, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python中的字典实现</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/448350/"> 大家好，4月30日，“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">面向开发人员</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">算法”</a>课程从OTUS开始，今天的材料专门为此出版。 让我们开始吧。 <br><br><img src="https://habrastorage.org/webt/hq/5t/r4/hq5tr4-0h1wb2kxrkaggtq_fatm.png"><br><br> 在本文中，您将学习如何在Python中实现字典。 <br> 使用键对字典进行索引，并且可以将它们视为关联的数组。 让我们在字典中添加3个键/值对： <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d = {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>} &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'c'</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; d {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}</code> </pre> <a name="habracut"></a><br> 可以按以下方式访问值： <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d[<span class="hljs-string"><span class="hljs-string">'a'</span></span>] <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'b'</span></span>] <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'c'</span></span>] <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'d'</span></span>] Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; KeyError: <span class="hljs-string"><span class="hljs-string">'d'</span></span></code> </pre> <br> 键<code>“d”</code>不存在，因此会发生KeyError错误。 <br><br>  <b>哈希表</b> <br><br>  Python中的字典是使用哈希表实现的。 它们是其索引是使用哈希函数计算的数组。 哈希函数的目标是将键均匀分布在数组中。 良好的哈希函数可最大程度地减少冲突次数，即 不同键具有相同哈希值的可能性。  Python中没有此类哈希函数。 在一般情况下，其最重要的哈希函数（对于字符串和整数值）会产生相似的值： <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>map(hash, (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; map(hash, (<span class="hljs-string"><span class="hljs-string">"namea"</span></span>, <span class="hljs-string"><span class="hljs-string">"nameb"</span></span>, <span class="hljs-string"><span class="hljs-string">"namec"</span></span>, <span class="hljs-string"><span class="hljs-string">"named"</span></span>)) [<span class="hljs-number"><span class="hljs-number">-1658398457</span></span>, <span class="hljs-number"><span class="hljs-number">-1658398460</span></span>, <span class="hljs-number"><span class="hljs-number">-1658398459</span></span>, <span class="hljs-number"><span class="hljs-number">-1658398462</span></span>]</code> </pre> <br> 我们假定直到本文结束之前，我们将使用字符串作为键。  Python中用于字符串的哈希函数定义如下： <br><br><pre> <code class="python hljs">arguments: string object returns: hash function string_hash: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hash cached: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it set len to string<span class="hljs-string"><span class="hljs-string">'s length initialize var p pointing to 1st char of string object set x to value pointed by p left shifted by 7 bits while len &gt;= 0: set var x to (1000003 * x) xor value pointed by p increment pointer p set x to x xor length of string object cache x as the hash so we don'</span></span>t need to calculate it again <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> the hash</code> </pre> <br> 如果您在Python中执行<code>hash('a')</code> ，它将<code>12416037344</code> <code>string_hash()</code>并返回<code>12416037344</code> 。 在这里，我们默认使用64位计算机。 <br><br> 如果使用大小为<code></code>的数组存储值/键对，则将使用掩码来计算数组中该单元格的单元格的索引，该索引的计算值为<code>-1</code> 。 这种方法可以快速计算单元格索引。 由于调整大小的机制，找到一个空单元的可能性很高，这将在下面进行描述。 这意味着在大多数情况下，简单的计算就很有意义。 数组的大小为8， <code>'a'</code>的索引为： <code>hash('a') &amp; 7 = 0</code> 。 就像<code>'b'</code>一样， <code>'b'</code>的索引是2， <code>'c'</code>的索引是3， <code>'z'</code>的索引是3，这就是我们发生碰撞的地方。 <br><br><img src="https://habrastorage.org/webt/m0/uu/ie/m0uuieays-qf4xbaurxripjwdi8.png"><br><br> 正如我们所看到的，当键是顺序的时，Python中的哈希函数可以很好地完成其工作，这很好，因为您经常必须使用此类数据。 但是，一旦添加<code>'z'</code>键，就会发生冲突，因为它与先前的不一致。 <br><br> 我们可以使用链表来存储对，同时具有相同的哈希值，但这会增加搜索时间，并且平均不等于O（1）。 下一节描述了Python中字典使用的冲突解决方法。 <br><br>  <b>开放式寻址</b> <br><br> 开放寻址是一种使用探测的冲突解决技术。 在<code>'z'</code>的情况下，数组中已经使用了单元3的索引，因此我们需要寻找另一个尚未使用的索引。 添加键/值对的操作以及搜索操作平均要花费O（1）。 <br><br> 为了搜索自由细胞，使用了二次探测序列。 它的实现如下： <br><br><pre> <code class="python hljs">j = (<span class="hljs-number"><span class="hljs-number">5</span></span>*j) + <span class="hljs-number"><span class="hljs-number">1</span></span> + perturb; perturb &gt;&gt;= PERTURB_SHIFT; use j % <span class="hljs-number"><span class="hljs-number">2</span></span>**i <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> the next table index;</code> </pre> <br>  （5 * j）+1处的递归迅速增加了不影响原始索引的较大位差异。 在这种情况下，变量<code>"perturb"</code>接收哈希码的其他位。 <br><br> 出于好奇，让我们看看如果我们有一个表大小为32且j = 3的样本序列会发生什么。 <br><br>  3-&gt; 11-&gt; 19-&gt; 29-&gt; 5-&gt; 6-&gt; 16-&gt; 31-&gt; 28-&gt; 13-&gt; 2 ... <br><br> 您可以通过参考源代码<a href="">dictobject.c</a>了解有关此<a href="">探测</a>序列的更多信息。 探测机制的详细说明可以在文件顶部找到。 <br><br><img src="https://habrastorage.org/webt/jq/vo/l3/jqvol3q4ekq8yullsftv4ylm-p4.png"><br><br> 让我们用这个例子看一下Python源代码。 <br><br>  <b>C字典结构</b> <br><br> 以下C结构用于将条目存储在字典中：键/值对。 哈希，键和值被存储。  <code>PyObject</code>是Python中对象的基类。 <br><br><pre> <code class="python hljs">typedef struct { Py_ssize_t me_hash; PyObject *me_key; PyObject *me_value; } PyDictEntry;</code> </pre> <br> 以下结构是一个字典。  <code>ma_fill</code>是已使用和无效的单元格总数。 当删除密钥对时，单元被认为是不活动的。  <code>ma_used</code>是已使用（活动）单元的数量。  <code>ma_mask</code>等于-1数组的大小，用于计算单元<code>ma_mask</code>引。  <code>ma_table</code>是一个数组， <code>ma_smalltable</code>是大小为8的原始数组。 <br><br><pre> <code class="python hljs">typedef struct _dictobject PyDictObject; struct _dictobject { PyObject_HEAD Py_ssize_t ma_fill; Py_ssize_t ma_used; Py_ssize_t ma_mask; PyDictEntry *ma_table; PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash); PyDictEntry ma_smalltable[PyDict_MINSIZE]; };</code> </pre> <br>  <b>词汇初始化</b> <br><br> 当您仅创建字典时，将<code>PyDict_New()</code>函数。 我删除了几行，然后将C代码转换为伪代码以关注关键概念。 <br><br>  <code>PyDict_New()</code>函数： <br><br><ul><li> 返回字典对象； </li><li> 分配一个新的字典对象； </li><li> 清除字典表； </li><li> 将已使用的字典单元格和未使用的单元格数（ <code>ma_fill</code> ）设置为0； </li><li> 将活动单元数（ <code>ma_used</code> ）设置为0； <code>ma_used</code>将其设置为0。 </li><li> 将字典掩码（ <code>ma_value</code> ）设置为等于字典大小的值-1 = 7; </li><li> 设置字典搜索功能<code>lookdict_string</code> ; </li><li> 返回分配的字典对象。 </li></ul><br>  <b>新增项目</b> <br><br> 添加新的键/值对时， <code>PyDict_SetItem()</code>调用<code>PyDict_SetItem()</code> 。 此函数接受指向字典对象的指针和键/值对作为输入。 它检查键是否为字符串，并评估哈希值或重用缓存（如果存在）。 如果使用和未使用的单元格数大于数组大小的2/3，则将调用<code>insertdict()</code>以添加新的键/值对，并且字典大小也会更改。 <br><br> 为什么是2/3？ 这是确保探针序列可以足够快地找到游离细胞所必需的。 稍后我们将考虑调整大小的功能。 <br><br><pre> <code class="python hljs">arguments: dictionary, key, value returns: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> OK <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> function PyDict_SetItem: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key<span class="hljs-string"><span class="hljs-string">'s hash cached: use hash else: calculate hash call insertdict with dictionary object, key, hash and value if key/value pair added successfully and capacity over 2/3: call dictresize to resize dictionary'</span></span>s table</code> </pre> <br>  <code>inserdict()</code>使用<code>lookdict_string()</code>搜索功能查找空闲单元。 使用相同的功能搜索关键字。 <br><br>  <code>lookdict_string()</code>使用哈希值和掩码值计算单元<code>lookdict_string()</code>引。 如果无法通过单元索引=哈希和掩码（插槽索引=哈希和掩码）的值找到密钥，则她将使用上述循环开始探测，直到找到空闲的单元。 在第一次尝试进行探测时，如果键为<code>null</code> ，则如果在第一次搜索期间找到了未使用的单元格，它将返回一个未使用的单元格。 这样可以确保重用先前删除的单元格的优先级。 <br> 我们要添加以下键/值对： <code>{'a': 1, 'b': 2′, 'z': 26, 'y': 25, 'c': 5, 'x': 24}</code> 。 将会发生以下情况： <br><br> 分配给字典结构的表大小为8。 <br><br><ul><li>  PyDict_SetItem：键='a'，值= 1 <br><ul><li> 哈希=哈希（'a'）= 12416037344 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li> 广告位索引=哈希和掩码= 12416037344＆7 = 0 </li><li> 未使用插槽0，请返回此单元格 </li></ul></li><li> 使用键，值和哈希值对索引0处的条目进行初始化 </li><li>  ma_used = 1，ma_fill = 1 </li></ul></li></ul></li><li>  PyDict_SetItem：键='b'，值= 2 <br><ul><li> 哈希=哈希（'b'）= 12544037731 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li> 广告位索引=哈希和掩码= 12544037731＆7 = 3 </li><li> 未使用插槽3，请返回此单元格 </li></ul></li><li> 使用键，值和哈希值对索引3处的条目进行初始化 </li><li>  ma_used = 2，ma_fill = 2 <br></li></ul></li></ul></li><li>  PyDict_SetItem：键='z'，值= 26 <br><ul><li> 哈希=哈希（'z'）= 15616046971 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li> 广告位索引=哈希和掩码= 15616046971＆7 = 3 </li><li> 使用了插槽3，请尝试另一个单元：5是空闲的 <br></li></ul><br> 使用键，值和哈希值对索引5处的条目进行初始化 <br>  ma_used = 3，ma_fill = 3 <br></li></ul></li></ul></li><li>  PyDict_SetItem：键='y'，值= 25 <br><ul><li> 哈希=哈希（'y'）= 15488046584 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li> 广告位索引=哈希和掩码= 15488046584＆7 = 0 </li><li> 使用了插槽0，请尝试其他单元：1空闲 </li></ul></li><li> 使用键，值和哈希值对索引1处的条目进行初始化 </li><li>  ma_used = 4，ma_fill = 4 </li></ul></li></ul></li></ul><br>  PyDict_SetItem：键='c'，值= 3 <br><ul><li> 哈希=哈希（'c'）= 12672038114 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li> 广告位索引=哈希和掩码= 12672038114＆7 = 2 </li><li> 未使用插槽2，请返回此单元格 </li></ul></li><li> 使用键，值和哈希值对索引2处的条目进行初始化 </li><li>  ma_used = 5，ma_fill = 5 </li></ul></li></ul><br>  PyDict_SetItem：键='x'，值= 24 <br><ul><li> 哈希=哈希（'x'）= 15360046201 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li> 插槽索引=哈希和掩码= 15360046201＆7 = 1 </li><li> 使用了插槽1，请尝试另一个单元：7是空闲的 </li></ul></li><li> 使用键，值和哈希值对索引7处的条目进行初始化 </li><li>  ma_used = 6，ma_fill = 6 </li></ul></li></ul><br> 这是我们得到的： <br><br><img src="https://habrastorage.org/webt/f9/wa/hf/f9wahfryuhllv1zykzjmwjcqllk.png"><br><br> 现在使用了8个单元中的6个，占据了阵列容量的2/3以上。  <code>dictresize()</code>分配更大的数组。 此功能还将记录从旧表复制到新表。 <br><br> 在本例中， <code>dictresize ()</code>值<code>minused</code> = 24，其中4 * <code>ma_used</code> 。 当使用的单元数非常大（大于50,000）时，将使用2 * <code>ma_used</code> 。 为什么细胞增加4倍？ 这减少了实现调整大小的步骤数量，并增加了稀疏性。 <br><br> 该表的新大小应大于24，它是通过将当前大小向左移动1位直到表的大小变得大于24来计算的。结果，它将是32，例如8-&gt; 16-&gt; 32。 <br><br> 调整大小时，我们的表发生了什么：突出显示了一个大小为32的新表，使用新的掩码值31将旧表项插入到新表中，结果如下： <br><br><img src="https://habrastorage.org/webt/qy/ue/ke/qyueke3baeooxaxzskg8dphcpli.png"><br><br>  <b>删除项目</b> <br><br>  <code>PyDict_DelItem()</code>删除记录。 计算记录键的哈希值，然后调用搜索函数以返回记录。 现在该单元为空。 <br><br> 我们要从字典中删除c键。 结果，我们得到以下数组： <br><br><img src="https://habrastorage.org/webt/sw/x1/l1/swx1l1efqzzelggasprbesixdqw.png"><br><br> 请注意，如果使用的单元格数量远小于其总数，则删除元素的操作不会更改数组的大小。 但是，当添加键/值对时，是否需要调整大小取决于使用和未使用的单元格的数量，因此添加操作还可以减少数组。 <br><br> 该出版物已经结束，我们通常会等待您的评论，并邀请所有人参加将于4月18日举行的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">公开课</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN448350/">https://habr.com/ru/post/zh-CN448350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN448336/index.html">研讨会“混合云-利弊：为业务和IT做好准备”-4月25日，莫斯科</a></li>
<li><a href="../zh-CN448338/index.html">分解C＃的基础知识：为堆栈上的引用类型分配内存</a></li>
<li><a href="../zh-CN448340/index.html">创作35MM游戏。 俄罗斯的世界末日</a></li>
<li><a href="../zh-CN448342/index.html">MyDrops-具有良好声音和可靠蓝牙的低成本TWS</a></li>
<li><a href="../zh-CN448346/index.html">从GNU到毁灭战士：TechTrain 2019宣布</a></li>
<li><a href="../zh-CN448352/index.html">无聊公司将在拉斯维加斯挖隧道</a></li>
<li><a href="../zh-CN448354/index.html">GraphQL Voyager作为查找漏洞的工具</a></li>
<li><a href="../zh-CN448358/index.html">我们使用锁定的智能手机屏幕收听YouTube上的音乐和讲座，而没有使用Telegram播放广告</a></li>
<li><a href="../zh-CN448360/index.html">Flask上的小型后门或如何在本地网络上控制计算机</a></li>
<li><a href="../zh-CN448362/index.html">我认为我需要派设计师去...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>