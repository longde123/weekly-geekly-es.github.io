<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>™️ 💢 🤴🏿 Tutup kontak ADL 🌇 🦊 🧘🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagaimana cara menuliskan nama Anda dalam sejarah selamanya? Yang pertama terbang ke bulan? Yang pertama bertemu orang asing? Kami memiliki cara yang ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tutup kontak ADL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/447900/"><p><img src="https://habrastorage.org/webt/zb/i1/7h/zbi17hhfyu9_oqqmwgpzijon0d8.jpeg"></p><br><p>  Bagaimana cara menuliskan nama Anda dalam sejarah selamanya?  Yang pertama terbang ke bulan?  Yang pertama bertemu orang asing?  Kami memiliki cara yang lebih sederhana - Anda dapat menyesuaikan diri dengan standar bahasa C ++. </p><br><p>  Eric Nibler, penulis C ++ Ranges, memberikan contoh yang baik.  "Ingat ini.  19 Februari 2019 adalah hari istilah "nibloid" pertama kali diucapkan pada pertemuan WG21, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tulisnya</a> di Twitter. </p><br><p>  Memang, jika Anda pergi ke CppReference, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian cpp / algoritme / rentangcpp / algoritme / rentang</a> , Anda akan menemukan banyak referensi di sana (niebloid).  Untuk ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">templat</a> wiki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dsc_niebloid</a> terpisah bahkan telah dibuat. </p><br><p>  Sayangnya, saya tidak menemukan artikel resmi lengkap mengenai hal ini dan memutuskan untuk menulis sendiri.  Ini adalah perjalanan kecil tapi menarik ke dalam jurang astronot arsitektur, di mana kita bisa terjun ke dalam jurang kegilaan ADL dan berkenalan dengan nibloid. </p><br><p>  Penting: Saya bukan tukang las sungguhan, tetapi seorang javist yang terkadang memperbaiki kesalahan dalam kode C ++ sebagaimana diperlukan.  Jika Anda mengambil sedikit waktu untuk membantu menemukan kesalahan dalam bernalar, itu akan baik.  "Bantu Dasha si pelancong mengumpulkan sesuatu yang masuk akal." </p><a name="habracut"></a><br><h2 id="lookup">  Cari </h2><br><p>  Pertama, Anda perlu memutuskan persyaratan.  Ini adalah hal-hal yang terkenal, tetapi "yang eksplisit lebih baik daripada yang implisit," jadi kami akan membahasnya secara terpisah.  Saya tidak menggunakan terminologi nyata berbahasa Rusia, tetapi sebaliknya menggunakan bahasa Inggris.  Ini perlu karena bahkan kata "pembatasan" dalam konteks artikel ini dapat dikaitkan dengan setidaknya tiga versi bahasa Inggris, perbedaan antara yang penting untuk dipahami. </p><br><p>  Misalnya, dalam C ++ ada konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencarian nama</a> atau, dengan kata lain, pencarian: ketika sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nama</a> ditemukan dalam sebuah program, ia mengkompilasi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deklarasi</a> selama kompilasi. </p><br><p> Pencarian dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dikualifikasikan</a> (jika namanya ada di sebelah kanan operator izin lingkup <code>::</code> :), dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak terampil</a> dalam kasus lain.  Jika pencarian memenuhi syarat, maka kami mengabaikan anggota kelas, namespace atau enumerasi yang sesuai.  Orang bisa menyebut ini versi "lengkap" dari catatan (seperti yang tampaknya dilakukan dalam terjemahan Straustrup), tetapi lebih baik meninggalkan ejaan aslinya, karena ini merujuk pada jenis kelengkapan yang sangat spesifik. </p><br><h2 id="adl">  ADL </h2><br><p>  Jika pencarian tidak memenuhi syarat, maka kita perlu memahami persis di mana mencari nama.  Dan di sini fitur khusus yang disebut ADL disertakan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencarian yang bergantung pada argumen</a> , atau yang lain - pencarian untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Koenig</a> (orang yang menciptakan istilah "anti-pola", yang sedikit simbolis dalam terang dari teks berikut).  Nicolai Josuttis dalam bukunya "The C ++ Standard Library: A Tutorial and Reference" menggambarkannya sebagai berikut: "Intinya adalah Anda tidak perlu memenuhi syarat namespace dari fungsi jika setidaknya salah satu tipe argumen didefinisikan dalam namespace dari fungsi ini." </p><br><p>  Seperti apa bentuknya? </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { //  . //   , operator&lt;&lt;    ,  ADL , //    std    std::operator&lt;&lt;(std::ostream&amp;, const char*) std::cout &lt;&lt; "Test\n"; //    .      -     . operator&lt;&lt;(std::cout, "Test\n"); // same, using function call notation //    : // Error: 'endl' is not declared in this namespace. //      endl(),  ADL  . std::cout &lt;&lt; endl; //  . //    ,       ADL. //     std,   endl      std. endl(std::cout); //    : // Error: 'endl' is not declared in this namespace. //  ,  - (endl) -     . (endl)(std::cout); }</span></span></span></span></code> </pre> <br><h2 id="spuskaemsya-v-ad-s-adl">  Turun ke neraka dengan ADL </h2><br><p>  Tampaknya sederhana.  Atau tidak?  Pertama, tergantung pada jenis argumen, ADL bekerja dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sembilan cara berbeda</a> , untuk membunuh dengan sapu. </p><br><p>  Kedua, sangat praktis, bayangkan kita memiliki semacam fungsi swap.  Ternyata <code>std::swap(obj1,obj2);</code>  dan <code>using std::swap; swap(obj1, obj2);</code> <code>using std::swap; swap(obj1, obj2);</code>  dapat berperilaku sangat berbeda.  Jika ADL diaktifkan, maka dari beberapa swap yang berbeda, yang Anda butuhkan sudah dipilih berdasarkan ruang nama argumen!  Bergantung pada sudut pandangnya, idiom ini dapat dianggap sebagai contoh positif dan negatif :-) </p><br><p>  Jika menurut Anda ini tidak cukup, Anda bisa memasukkan kayu bakar ke dalam oven topi.  Ini baru-baru ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditulis dengan</a> baik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oleh Arthur O'Dwyer</a> .  Saya harap dia tidak menghukum saya karena menggunakan teladannya. </p><br><p>  Bayangkan Anda memiliki program semacam ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } int main() { call(f); }</span></span></span></span></code> </pre> <br><p>  Tentu saja, itu tidak dikompilasi dengan kesalahan: </p><br><pre> <code class="plaintext hljs">error: use of undeclared identifier 'call'; did you mean 'A::call'? call(f); ^~~~ A::call</code> </pre> <br><p>  Tetapi jika Anda menambahkan <strong>kelebihan</strong> fungsi yang <strong>sama sekali tidak terpakai di</strong> <code>f</code> , maka semuanya akan berfungsi! </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } void f(A::A); // UNUSED int main() { call(f); }</span></span></span></span></code> </pre> <br><p>  Di Visual Studio masih akan pecah, tetapi nasibnya seperti itu, tidak bekerja. </p><br><p>  Bagaimana ini bisa terjadi?  Mari kita mempelajari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">standar</a> (tanpa terjemahan, karena terjemahan seperti itu akan menjadi kesalahan besar dari kata kunci): </p><br><blockquote>  Jika argumen adalah nama atau alamat dari satu set fungsi yang kelebihan beban dan / atau templat fungsi, entitas dan ruang namanya yang terkait adalah gabungan dari yang terkait dengan masing-masing anggota set, yaitu entitas dan ruang nama yang terkait dengan parameternya jenis dan jenis kembali.  [...] Selain itu, jika rangkaian fungsi kelebihan beban yang disebutkan di atas diberi nama dengan templat-id, entitas dan ruang namanya yang terkait juga menyertakan argumen tipe-templat dan templat-templat templat. </blockquote><p>  Sekarang ambil kode seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace B { struct B {}; void call(void (*f)()) { f(); } } template&lt;class T&gt; void f() { puts("Hello world"); } int main() { call(f&lt;B::B&gt;); }</span></span></span></span></code> </pre> <br><p>  Dalam kedua kasus, argumen diperoleh yang tidak memiliki tipe.  <code>f</code> dan <code>f&lt;B::B&gt;</code> adalah nama-nama himpunan fungsi yang kelebihan beban (dari definisi di atas), dan himpunan tersebut tidak memiliki tipe.  Untuk memecah kelebihan beban menjadi satu fungsi, Anda perlu memahami jenis penunjuk fungsi apa yang paling cocok untuk overload <code>call</code> terbaik.  Jadi, Anda perlu mengumpulkan satu set kandidat untuk <code>call</code> , yang berarti untuk meluncurkan pencarian nama <code>call</code> .  Dan untuk ini ADL akan dimulai! </p><br><p>  Tetapi biasanya untuk ADL kita harus tahu jenis-jenis argumen!  Dan di sini Dentang, ICC, dan MSVC secara keliru pecah sebagai berikut (tetapi GCC tidak): </p><br><pre> <code class="cpp hljs">[build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>): error: use of undeclared identifier <span class="hljs-string"><span class="hljs-string">'call'</span></span>; did you mean <span class="hljs-string"><span class="hljs-string">'B::call'</span></span>? [build] call(f&lt;B::B&gt;); [build] ^~~~ [build] B::call [build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>): note: <span class="hljs-string"><span class="hljs-string">'B::call'</span></span> declared here [build] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*f)())</span></span></span><span class="hljs-function"> </span></span>{ [build] ^</code> </pre> <br><p>  Bahkan pencipta kompiler dengan ADL memiliki hubungan yang sedikit tegang. </p><br><p>  Nah, apakah ADL masih tampak seperti ide yang bagus?  Di satu sisi, kita tidak perlu lagi menulis kode yang begitu sopan: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>), <span class="hljs-string"><span class="hljs-string">"\n"</span></span>);</code> </pre> <br><p>  Di sisi lain, kami berdagang untuk singkatnya fakta bahwa sekarang ada sistem yang bekerja dengan cara yang sama sekali tidak manusiawi.  Kisah tragis dan agung tentang bagaimana kemudahan menulis Halloworld dapat memengaruhi seluruh bahasa dalam skala puluhan tahun. </p><br><h2 id="renzhi-i-koncepty">  Rentang dan konsep </h2><br><p>  Jika Anda membuka deskripsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan Nibler Rangers</a> , maka bahkan sebelum penyebutan nibloid, Anda akan menemukan banyak marker lain yang disebut <strong>(konsep)</strong> .  Ini sudah merupakan hal yang cantik, tetapi untuk berjaga-jaga (untuk orang tua dan javist) saya akan mengingatkan Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa itu</a> . </p><br><p>  Konsep disebut set himpunan kendala yang berlaku untuk argumen templat untuk memilih kelebihan fungsi terbaik dan spesialisasi templat yang paling cocok. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasStringFunc = requires(T a) { { to_string(a) } -&gt; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HasStringFunc a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; to_string(a) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Di sini kami telah memberlakukan batasan bahwa argumen harus memiliki fungsi <code>to_string</code> yang mengembalikan string.  Jika kami mencoba memasukkan permainan ke dalam <code>print</code> yang tidak termasuk dalam batasan, maka kode seperti itu tidak akan dikompilasi. </p><br><p>  Ini sangat menyederhanakan kode.  Misalnya, lihat bagaimana Nibler melakukan <a href="">pengurutan dalam rentang-v3</a> , yang bekerja di C ++ 11/14/17.  Ada kode yang luar biasa seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT_(X, Y) X ## Y #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT(X, Y) CONCEPT_PP_CAT_(X, Y) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/// \addtogroup group-concepts /// @{ #define CONCEPT_REQUIRES_(...) \ int CONCEPT_PP_CAT(_concept_requires_, __LINE__) = 42, \ typename std::enable_if&lt; \ (CONCEPT_PP_CAT(_concept_requires_, __LINE__) == 43) || (__VA_ARGS__), \ int \ &gt;::type = 0 \ /**/</span></span></span></span></code> </pre> <br><p>  Sehingga nanti bisa Anda lakukan: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sortable_</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> I = <span class="hljs-keyword"><span class="hljs-keyword">iterator_t</span></span>&lt;Rng&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> requires_() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( concepts::valid_expr( concepts::model_of&lt;concepts::ForwardRange, Rng&gt;(), concepts::is_true(ranges::Sortable&lt;I, C, P&gt;()) )); }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Sortable = concepts::models&lt;Sortable_, Rng, C, P&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, CONCEPT_REQUIRES_(!Sortable&lt;Rng, C, P&gt;())&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(Rng &amp;&amp;, C &amp;&amp; = C{}, P &amp;&amp; = P{}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ...</code> </pre> <br><p>  Saya harap Anda sudah ingin melihat semua ini dan hanya menggunakan konsep yang sudah disiapkan dalam kompiler baru. </p><br><h2 id="tochki-kastomizacii">  Poin Kustomisasi </h2><br><p>  Hal menarik berikutnya yang dapat ditemukan dalam standar adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">customization.point.object</a> .  Mereka secara aktif digunakan di perpustakaan Nibler Ranges. </p><br><p>  Titik kustomisasi adalah fungsi yang digunakan oleh pustaka standar sehingga dapat kelebihan beban untuk tipe pengguna di namespace pengguna, dan kelebihan ini dapat ditemukan menggunakan ADL. </p><br><p>  Poin kustomisasi dirancang dengan mempertimbangkan prinsip arsitektur berikut ( <code>cust</code> adalah nama untuk beberapa titik kustomisasi imajiner): </p><br><ul><li>  Kode yang memanggil <code>cust</code> ditulis dalam bentuk <code>std::cust(a)</code> memenuhi syarat atau yang tidak memenuhi syarat: <code>using std::cust; cust(a);</code> <code>using std::cust; cust(a);</code>  .  Kedua entri harus berperilaku identik.  Secara khusus, mereka harus menemukan kelebihan pengguna di namespace yang terkait dengan argumen. </li><li>  Kode yang menggunakan <code>cust</code> dalam bentuk <code>std::cust; cust(a);</code> <code>std::cust; cust(a);</code>  seharusnya tidak dapat menghindari pembatasan yang diberlakukan pada <code>std::cust</code> . </li><li>  Panggilan titik khusus harus bekerja secara efisien dan optimal pada setiap kompiler yang cukup modern. </li><li>  Keputusan tidak boleh membuat pelanggaran baru terhadap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aturan Definisi Tunggal (ODR)</a> . </li></ul><br><p>  Untuk memahami apa itu, Anda dapat melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">N4381</a> .  Pada pandangan pertama, mereka tampak seperti cara untuk menulis versi <code>begin</code> Anda sendiri, <code>swap</code> , <code>data</code> , dan sejenisnya, dan perpustakaan standar mengambilnya menggunakan ADL. </p><br><p>  Pertanyaannya adalah, bagaimana hal ini berbeda dari praktik lama, ketika pengguna menulis overload untuk beberapa orang <code>begin</code> untuk tipe dan namespace sendiri?  Dan mengapa mereka bahkan menolak? </p><br><p>  Bahkan, ini adalah contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">objek fungsional</a> di <code>std</code> .  Tujuan mereka adalah untuk pertama-tama menarik cek tipe (dirancang sebagai konsep) pada semua argumen berturut-turut, dan kemudian mengirimkan panggilan ke fungsi yang benar di <code>std</code> atau menyerah untuk dijual di ADL. </p><br><p>  Sebenarnya, ini bukan hal yang akan Anda gunakan dalam program non-perpustakaan biasa.  Ini adalah fitur dari perpustakaan standar, yang akan memungkinkan Anda untuk menambahkan pemeriksaan konsep pada titik ekstensi di masa depan, yang pada gilirannya akan mengarah pada tampilan kesalahan yang lebih indah dan dapat dimengerti jika Anda mengacaukan sesuatu di templat. </p><br><p>  Pendekatan saat ini untuk poin penyesuaian memiliki beberapa masalah.  Pertama, sangat mudah untuk menghancurkan segalanya.  Bayangkan kode ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap(t1, t2); }</code> </pre> <br><p>  Jika kita secara tidak sengaja membuat panggilan yang memenuhi syarat ke <code>std::swap(t1, t2)</code> maka versi <code>swap</code> kita sendiri tidak akan pernah mulai, tidak peduli apa yang kita masukkan di sana.  Tetapi yang lebih penting, tidak ada cara untuk melampirkan konsep secara terpusat untuk implementasi fungsi kustom tersebut.  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">N4381 mereka</a> menulis: </p><br><p>  “Bayangkan suatu hari nanti, <code>std::begin</code> akan mengharuskan argumennya dimodelkan sebagai konsep <code>Range</code> .  Menambahkan batasan seperti itu tidak akan berdampak pada kode secara idiomatis menggunakan <code>std::begin</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin; begin(a);</code> </pre> <br><p>  Lagipula, jika panggilan <code>begin</code> dikirim ke versi overload yang dibuat oleh pengguna, maka pembatasan <code>std::begin</code> diabaikan saja. " </p><br><p>  Solusi yang dijelaskan dalam propozal memecahkan kedua masalah, untuk ini kami menggunakan pendekatan dari implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spd stul</a> <code>std::begin</code> (Anda dapat melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">godbolt</a> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;utility&gt; namespace my_std { namespace detail { struct begin_fn { /*   ,         begin(arg)  arg.begin().  -   . */ template &lt;class T&gt; auto operator()(T&amp;&amp; arg) const { return impl(arg, 1L); } template &lt;class T&gt; auto impl(T&amp;&amp; arg, int) const requires requires { begin(std::declval&lt;T&gt;()); } { return begin(arg); } // ADL template &lt;class T&gt; auto impl(T&amp;&amp; arg, long) const requires requires { std::declval&lt;T&gt;().begin(); } { return arg.begin(); } // ... }; } //        inline constexpr detail::begin_fn begin{}; }</span></span></span></span></code> </pre> <br><p>  Panggilan berkualitas dari beberapa <code>my_std::begin(someObject)</code> selalu melewati <code>my_std::detail::begin_fn</code> - dan itu bagus.  Apa yang terjadi pada panggilan yang tidak memenuhi syarat?  Mari kita baca makalah kita lagi: </p><br><p>  “Dalam kasus ketika mulai dipanggil tanpa kualifikasi segera setelah penampilan <code>my_std::begin</code> di dalam lingkup, situasinya agak berubah.  Pada tahap pertama pencarian, nama <code>begin</code> menyelesaikan ke objek global <code>my_std::begin</code> .  Karena pencarian menemukan objek, bukan fungsi, fase kedua pencarian tidak dilakukan.  Dengan kata lain, jika <code>my_std::begin</code> adalah sebuah objek, maka menggunakan konstruksi <code>my_std::detail::begin_fn begin; begin(a);</code> <code>my_std::detail::begin_fn begin; begin(a);</code>  sederajat dengan <code>std::begin(a);</code>  "Dan seperti yang telah kita lihat, ini meluncurkan ADL kustom." </p><br><p>  Itulah sebabnya validasi konsep dapat dilakukan dalam objek fungsi di <code>std</code> sebelum ADL memanggil fungsi yang disediakan oleh pengguna.  Tidak ada cara untuk mengelabui perilaku ini. </p><br><h2 id="kak-kastomiziruyut-tochki-kastomizacii">  Bagaimana titik kustomisasi menyesuaikan? </h2><br><p>  Bahkan, "objek titik kustomisasi" (CPO) bukan nama yang baik.  Dari namanya tidak jelas bagaimana mereka berkembang, mekanisme apa yang ada di bawah tenda, fungsi apa yang mereka sukai ... </p><br><p>  Yang mengarahkan kita pada istilah "nibloid."  Nibloid adalah CPO yang memanggil fungsi X jika didefinisikan di kelas, jika tidak maka akan memanggil fungsi X jika ada fungsi bebas yang sesuai, jika tidak ia mencoba untuk menjalankan beberapa fallback dari fungsi X. </p><br><p>  Jadi misalnya, <code>ranges::swap</code> nibloid <code>ranges::swap</code> ketika memanggil <code>ranges::swap(a, b)</code> pertama-tama akan mencoba memanggil <code>a.swap(b)</code> .  Jika tidak ada metode seperti itu, ia akan mencoba memanggil <code>swap(a, b)</code> menggunakan ADL.  Jika ini tidak berhasil, coba <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code>  <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> . </p><br><h1 id="itogi">  Ringkasan </h1><br><p>  Seperti yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dibicarakan</a> Matt di Twitter, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dave</a> pernah menyarankan agar objek fungsional "berfungsi" dengan ADL seperti fungsi biasa, karena alasan konsistensi.  Ironinya adalah kemampuan mereka untuk menonaktifkan ADL dan tidak terlihat olehnya kini telah menjadi keuntungan utama mereka. </p><br><p>  Seluruh artikel ini adalah persiapan untuk ini. </p><br><p>  " <i><b>Aku hanya mengerti segalanya, itu saja. Maukah kamu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendengarkan</a> ?</b></i> </p><br><p>  <i><b>Pernahkah Anda melihat sesuatu, dan itu tampak gila, dan kemudian dalam cahaya yang berbeda menyala</b></i> <i><b><br></b></i>  <i><b>hal-hal gila melihat mereka normal?</b></i> </p><br><p><img src="https://habrastorage.org/webt/-f/us/rh/-fusrhpdssngql8nlfx2qn0gdd8.jpeg"></p><br><p>  <i><b>Jangan takut.</b></i>  <i><b>Jangan takut.</b></i>  <i><b>Saya merasa sangat baik hati.</b></i>  <i><b>Semuanya akan baik-baik saja.</b></i>  <i><b>Saya merasa tidak enak selama bertahun-tahun.</b></i>  <i><b>Semuanya akan baik-baik saja.</b></i> </p><br><p><img src="https://habrastorage.org/webt/pe/ca/az/pecaazhixdkr6dsdxv67ewlvte8.jpeg"></p><br><blockquote>  Menit periklanan.  Sudah <b>minggu ini</b> , 19-20 April, C ++ Russia 2019 akan diadakan - sebuah konferensi yang diisi dengan presentasi hardcore baik pada bahasanya sendiri maupun pada isu-isu praktis seperti multithreading dan kinerja.  Omong-omong, konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dibuka oleh</a> Nicolai Josuttis, penulis The C ++ Standard Library: A Tutorial and Reference <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> disebutkan dalam artikel.  Anda dapat membiasakan diri dengan program ini dan membeli tiket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs web resmi</a> .  Hanya ada sedikit waktu tersisa, ini adalah kesempatan terakhir. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447900/">https://habr.com/ru/post/id447900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447890/index.html">Terima kasih Tuhan aku bukan manajer</a></li>
<li><a href="../id447892/index.html">Dua kontes PHDays baru: bypass IDS dan peretasan pabrik</a></li>
<li><a href="../id447894/index.html">MODX Digest # 3 (25 Maret - 8 April 2019)</a></li>
<li><a href="../id447896/index.html">Gambar dari sketsa kasar: bagaimana tepatnya jaringan saraf NVIDIA GauGAN bekerja</a></li>
<li><a href="../id447898/index.html">Filsuf cukup makan atau pemrograman .NET kompetitif</a></li>
<li><a href="../id447902/index.html">GitHub sepenuhnya "menghapus" repositori utilitas kunci dan seluruh akun pembuat</a></li>
<li><a href="../id447904/index.html">Pakar Teknologi Positif mengidentifikasi upaya untuk mengeksploitasi kerentanan kritis dalam Confluence secara massal</a></li>
<li><a href="../id447906/index.html">Inovasi aktual: apa yang diharapkan dari pasar pusat data pada tahun 2019?</a></li>
<li><a href="../id447908/index.html">Dua cara untuk mengumpulkan hadiah untuk beriklan di game mobile, atau robot harus bekerja</a></li>
<li><a href="../id447910/index.html">"Minyak" ekonomi modern dan perang untuk personel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>