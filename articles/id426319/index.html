<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍵 👩‍👩‍👦‍👦 😈 Uji server untuk tim pengembangan 👩‍⚕️ 🙌🏾 🍐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Pada artikel ini saya ingin berbagi pengalaman menggunakan server uji untuk tim pengembangan. Secara singkat inti dari masalah - ada tim p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uji server untuk tim pengembangan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426319/">  Halo, Habr!  Pada artikel ini saya ingin berbagi pengalaman menggunakan server uji untuk tim pengembangan.  Secara singkat inti dari masalah - ada tim pengembangan dan beberapa proyek di php.  Meskipun ada beberapa dari kami dan proyek itu pada dasarnya adalah satu, kami menggunakan 1 server uji dan untuk menunjukkan tugas kepada pelanggan, pengembang “membuat kolom” server untuk waktu tertentu.  Jika tidak ada "jendela" pada waktunya, maka kami harus menunggu.  Seiring waktu, tim dan kompleksitas tugas tumbuh, masing-masing, waktu verifikasi dan kesibukan server uji meningkat, yang secara negatif mempengaruhi waktu dan bonus.  Karena itu, saya harus mencari solusi dan itu ada di bawah jalan pintas. <br><a name="habracut"></a><br><h3>  Pendahuluan </h3><br>  Apa itu: <br><br><ol><li>  Satu server uji </li><li>  Gitlab dan redmine di server lain </li><li>  Keinginan untuk menyelesaikan masalah </li></ol><br>  Semua server berada di jaringan lokal kami, server uji tidak dapat diakses dari luar. <br><br>  Apa yang dibutuhkan: <br><br><ol><li>  Kemampuan untuk menguji beberapa proyek / cabang secara bersamaan </li><li>  Pengembang dapat pergi ke server, mengaturnya dan tidak merusak apa pun dari orang lain </li><li>  Semuanya harus senyaman mungkin dan dilakukan pada 1 tombol, lebih disukai dari gitlab (CI / CD). </li></ol><br><h3>  Opsi keputusan </h3><br><h4>  1. Satu server, banyak host </h4><br>  Opsi termudah.  Kami menggunakan server pengujian yang sama, hanya pengembang yang perlu membuat host untuk setiap cabang / proyek dan menambahkannya ke konfigurasi nginx / apache2. <br><br>  Pro: <br><br><ol><li>  Dengan cepat dan semua orang mengerti </li><li>  Dapat mengotomatisasi </li></ol><br>  Cons: <br><br><ol><li>  Ayat 2 dari persyaratan tidak terpenuhi - pengembang dapat mulai memperbarui database dan, dalam beberapa keadaan, memasukkan semuanya ke dalam (Hai Andrew!) </li><li>  Otomasi yang cukup kompleks dengan banyak file konfigurasi </li></ol><br><h4>  2. Kepada setiap pengembang di server! </h4><br>  Mengalokasikan ke setiap server dan pengembang bertanggung jawab atas ekonominya. <br><br>  Pro: <br><br><ol><li>  Pengembang dapat sepenuhnya menyesuaikan server untuk proyek Anda </li></ol><br>  Cons: <br><br><ol><li>  Ayat 2 dari persyaratan tidak terpenuhi </li><li>  Mahal dan sumber daya bisa diam saat pengembangan sedang berlangsung, bukan pengujian </li><li>  Otomasi bahkan lebih rumit daripada di poin 1 karena server yang berbeda </li></ol><br><h4>  3. Kontainerisasi - buruh pelabuhan, kubernetes </h4><br>  Teknologi ini semakin merambah kehidupan kita.  Di rumah, saya telah menggunakan buruh pelabuhan untuk proyek saya sejak lama. <br><blockquote>  Docker adalah perangkat lunak untuk mengotomatiskan penyebaran dan pengelolaan aplikasi dalam lingkungan virtualisasi di tingkat sistem operasi.  Memungkinkan Anda untuk "mengemas" aplikasi dengan semua lingkungan dan dependensinya ke dalam wadah yang dapat porting ke sistem Linux apa pun dengan dukungan cgroup di kernel, dan juga menyediakan lingkungan manajemen wadah. </blockquote>  Pro: <br><br><ol><li>  Satu server digunakan </li><li>  Semua persyaratan terpenuhi. </li></ol><br>  Cons: <br><br><ol><li>  Gambar dan wadah terkadang memakan banyak ruang, Anda harus membersihkan mahkota yang sudah usang untuk membebaskan ruang. </li></ol><br><h3>  Implementasi Docker </h3><br>  Saat menggunakan gitlab, AutoDevOps, pengaturan kubernetes sangat sering menarik perhatian saya.  Plus, pria berjanggut di berbagai pertemuan memberi tahu betapa kerennya mereka bekerja dengan kubernet.  Oleh karena itu, diputuskan untuk mencoba menggunakan cluster di fasilitasnya, server diminta (dan Anda tidak dapat menyentuh tes, orang menguji di sana) dan itu dimulai! <br><br>  Karena saya memiliki pengalaman dengan kubernetes 0, semuanya dilakukan sesuai dengan manual dengan upaya untuk memahami bagaimana semua cluster ini bekerja.  Setelah beberapa waktu, saya berhasil meningkatkan cluster, tetapi kemudian ada masalah dengan sertifikat, kunci, dan memang dengan kesulitan penyebaran.  Saya membutuhkan solusi yang lebih sederhana untuk mengajari kolega saya cara bekerja dengan ini (misalnya, saya tidak ingin menghabiskan liburan yang sama dengan duduk di Skype dan membantu pengaturan).  Karena itu kubernet dibiarkan sendiri.  Docker sendiri tetap ada dan itu perlu untuk menemukan solusi untuk perutean kontainer.  Karena mereka dapat diambil pada port yang berbeda, nginx yang sama dapat digunakan untuk pengalihan internal.  Ini disebut server proxy terbalik. <br><blockquote>  Server proxy terbalik adalah jenis server proxy yang menyampaikan permintaan klien dari jaringan eksternal ke satu atau lebih server yang secara logis terletak di jaringan internal.  Pada saat yang sama, tampak ke klien seolah-olah sumber daya yang diminta terletak langsung di server proxy. </blockquote><h4>  Membalikkan proxy </h4><br>  Agar tidak menemukan kembali roda, saya mulai mencari solusi yang sudah jadi.  Dan ditemukan - ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">traefik</a> . <br><br>  Træfik adalah proksi reverse HTTP modern dan penyeimbang beban yang menyederhanakan penyebaran layanan microser.  Træfik terintegrasi dengan komponen infrastruktur yang ada (Docker, mode Swarm, Kubernetes, Marathon, Consul, Etcd, Rancher, Amazon ECS, ...) dan dikonfigurasi secara otomatis dan dinamis.  Untuk bekerja dengan buruh pelabuhan, Anda hanya perlu menentukan soketnya dan itu saja, kemudian Træfik sendiri menemukan semua kontainer dan merutekaninya (untuk lebih jelasnya, lihat “Mengemas aplikasi di buruh pelabuhan”). <br><br><div class="spoiler">  <b class="spoiler_title">Konfigurasi Wadah Træfik</b> <div class="spoiler_text">  Saya meluncurkannya melalui docker-compose.yml <br><br><pre><code class="hljs delphi">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: traefik: image: traefik:latest # The official Traefik docker image command: --api --docker # Enables the web UI <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tells Træfik <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> listen <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> docker ports: - <span class="hljs-number"><span class="hljs-number">443</span></span>:<span class="hljs-number"><span class="hljs-number">443</span></span> - <span class="hljs-number"><span class="hljs-number">80</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> # The HTTP port - <span class="hljs-number"><span class="hljs-number">8080</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> # The Web UI (enabled by --api) volumes: - /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/run/docker.sock:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/run/docker.sock # So that Traefik can listen <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the Docker events - /opt/traefik/traefik.toml:/traefik.toml - /opt/traefik/certs/:/certs/ networks: - proxy container_name: traefik restart: always networks: proxy: <span class="hljs-keyword"><span class="hljs-keyword">external</span></span>: true</code> </pre> <br></div></div><br>  Di sini kami memberi tahu proxy bahwa kami perlu mendengarkan port 80.443 dan 8080 (permukaan web proxy), pasang soket docker, file konfigurasi, dan folder sertifikat.  Untuk kenyamanan penamaan situs pengujian, kami memutuskan untuk membuat zona domain lokal * .test.  Saat mengakses situs mana pun di dalamnya, pengguna masuk ke server pengujian kami.  Oleh karena itu, sertifikat di folder traefik ditandatangani sendiri, tetapi sangat mendukung Let's Encrypt. <br><br>  Pembuatan Sertifikat <br><br><pre> <code class="bash hljs">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout domain.key -out domain.crt</code> </pre> <br>  Sebelum memulai, Anda perlu membuat jaringan proxy di buruh pelabuhan (Anda dapat menamainya sendiri). <br><br><pre> <code class="bash hljs">docker network create proxy</code> </pre> <br>  Ini akan menjadi jaringan untuk menghubungkan traefik dengan wadah situs php.  Oleh karena itu, kami menentukannya di parameter jaringan layanan dan di jaringan seluruh file dengan menentukan parameter eksternal: true. <br><br><div class="spoiler">  <b class="spoiler_title">File Traefik.toml</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> logLevel = "DEBUG" defaultEntryPoints = ["https","http"] #  insecureSkipVerify = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> #   [entryPoints] [entryPoints.http] address = ":80" [entryPoints.https] address = ":443" [entryPoints.https.tls] [docker] endpoint = "unix:///var/run/docker.sock" <span class="hljs-keyword"><span class="hljs-keyword">domain</span></span> = "docker.localhost" watch = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> exposedbydefault = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br></div></div><br>  Semuanya cukup sederhana di sini - kami menentukan titik masuk lalu lintas http dan https, jangan lupa untuk mengatur insecureSkipVerify = true jika sertifikat lokal.  Di bagian entryPoints.https.tls, Anda tidak dapat menentukan sertifikat, lalu traefik akan mengganti sertifikatnya. <br><br>  Anda dapat memulai layanan <br><br><pre> <code class="bash hljs">docker-compose up -d</code> </pre> <br>  Jika Anda pergi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">site.test</a> , Anda akan mendapatkan kesalahan 404, karena domain ini tidak terikat ke wadah apa pun. <br><br><h4>  Kami mengemas aplikasi di buruh pelabuhan </h4><br>  Sekarang Anda perlu mengkonfigurasi wadah dengan aplikasi, yaitu: <br><br>  1. tentukan jaringan proxy di jaringan <br>  2. tambahkan label dengan konfigurasi traefik <br><br>  Di bawah ini adalah konfigurasi dari salah satu aplikasi <br><br><div class="spoiler">  <b class="spoiler_title">aplikasi docker-compose.yml</b> <div class="spoiler_text"><pre> <code class="hljs kotlin">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: app: build: <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/docker/php #   restart: always working_dir: /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> volumes: - ./:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html #    - /home/develop/site-files/f:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/<span class="hljs-keyword"><span class="hljs-keyword">public</span></span>/f #       links: - mailcatcher - memcached - mysql labels: - traefik.enabled=<span class="hljs-literal"><span class="hljs-literal">true</span></span> - traefik.frontend.rule=Host:TEST_DOMAIN,crm.TEST_DOMAIN,bonus.TEST_DOMAIN - traefik.docker.network=proxy - traefik.port=<span class="hljs-number"><span class="hljs-number">443</span></span> - traefik.protocol=https networks: - proxy - <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> mailcatcher: image: schickling/mailcatcher:latest restart: always memcached: image: memcached restart: always mysql: image: mysql:<span class="hljs-number"><span class="hljs-number">5.7</span></span> restart: always command: --max_allowed_packet=<span class="hljs-number"><span class="hljs-number">902505856</span></span> --sql-mode=<span class="hljs-string"><span class="hljs-string">""</span></span> environment: MYSQL_ROOT_PASSWORD: <span class="hljs-number"><span class="hljs-number">12345</span></span> MYSQL_DATABASE: site volumes: - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/cache/mysql-db:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/mysql #      phpmyadmin: image: phpmyadmin/phpmyadmin restart: always links: - mysql environment: MYSQL_USERNAME: root MYSQL_ROOT_PASSWORD: <span class="hljs-number"><span class="hljs-number">12345</span></span> PMA_ARBITRARY: <span class="hljs-number"><span class="hljs-number">1</span></span> PMA_HOST: mysql_1 labels: - traefik.enabled=<span class="hljs-literal"><span class="hljs-literal">true</span></span> - traefik.frontend.rule=Host:pma.TEST_DOMAIN - traefik.docker.network=proxy - traefik.port=<span class="hljs-number"><span class="hljs-number">80</span></span> - traefik.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.protocol=http networks: - proxy - <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> networks: proxy: <span class="hljs-keyword"><span class="hljs-keyword">external</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br></div></div><br>  Di layanan aplikasi, di bagian jaringan, Anda perlu menentukan proxy dan default, yang berarti akan tersedia di dua jaringan, seperti yang dapat dilihat dari konfigurasi, saya tidak meneruskan port di luar, semuanya berjalan di jaringan. <br><br>  Selanjutnya, konfigurasikan label <br><br><pre> <code class="hljs 1c"> - traefik.enabled=true <span class="hljs-meta"><span class="hljs-meta"># traefik </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   - traefik.frontend.rule=Host:TEST_DOMAIN,crm.TEST_DOMAIN,bonus.TEST_DOMAIN #  </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  traefik     - traefik.docker.network=proxy # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  - traefik.port=443 #, </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">    ssl   80   http - traefik.protocol=https #  #  phpmyadmin   http </span></span></code> </pre><br>  Di bagian jaringan umum, tentukan eksternal: true <br><br>  Konstanta TEST_DOMAIN harus diganti dengan domain, misalnya, site.test <br><br>  Luncurkan aplikasi <br><br><pre> <code class="bash hljs">docker-compose up -d</code> </pre> <br>  Sekarang jika Anda pergi ke domain site.test, crm.site.test, bonus.site.test, Anda dapat melihat situs yang berfungsi.  Dan pada domain pma.site.test akan ada phpmyadmin untuk pekerjaan yang mudah dengan database. <br><br><h4>  Konfigurasikan GitLab </h4><br>  Kami membuat penangan tugas, untuk ini kami jalankan <br><br><pre> <code class="bash hljs">gitlab-runner register</code> </pre> <br>  Kami menentukan url gitlab, token, dan melalui mana tugas akan dieksekusi (pelaksana).  Karena tes dan gitlab saya ada di server yang berbeda, saya memilih ssh executor.  Anda perlu menentukan alamat server dan login / kata sandi untuk menghubungkan melalui ssh. <br><br>  Runner dapat dilampirkan ke satu atau lebih proyek.  Karena logika pekerjaan saya sama di mana-mana, pelari bersama dibuat (umum untuk semua proyek). <br>  Dan sentuhan terakhir adalah membuat file konfigurasi CI <br><br><div class="spoiler">  <b class="spoiler_title">.gitlab-ci.yml</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk">stages: - build - clear #  develop build_develop: stage: build #   build tags: #     - ssh-develop environment: # ,       -   name: review/<span class="hljs-string"><span class="hljs-string">$C</span></span>I_BUILD_REF_NAME #  url: https://site<span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID.test <span class="hljs-symbol"><span class="hljs-symbol">#url</span></span>     on_stop: clear when: manual script: - cd ../ &amp;&amp; cp -r <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PROJECT_NAME <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID &amp;&amp; cd <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID #     - cp -r /home/develop/site-files/.ssh data/docker/php/.ssh #  ssh - sed -i -e <span class="hljs-comment"><span class="hljs-comment">"s/TEST_DOMAIN/site$CI_PIPELINE_ID.test/g"</span></span> docker-compose.yml #   - docker-compose down #   - docker-compose up -d --build #  - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar install --prefer-dist \<span class="hljs-comment"><span class="hljs-comment">""</span></span> #   - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar first-install <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID\<span class="hljs-comment"><span class="hljs-comment">""</span></span> #     #  production build_prod: stage: build tags: - ssh-develop environment: name: review/<span class="hljs-string"><span class="hljs-string">$C</span></span>I_BUILD_REF_NAME url: https://site<span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID.test on_stop: clear when: manual script: - cd ../ &amp;&amp; cp -r <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PROJECT_NAME <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID &amp;&amp; cd <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID - cp -r /home/develop/site-files/.ssh data/docker/php/.ssh #  ssh - docker-compose down - docker-compose up -d --build - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar install --prefer-dist --no-dev\<span class="hljs-comment"><span class="hljs-comment">""</span></span> - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar first-install <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID\<span class="hljs-comment"><span class="hljs-comment">""</span></span> clear: stage: clear tags: - ssh-develop environment: name: review/<span class="hljs-string"><span class="hljs-string">$C</span></span>I_BUILD_REF_NAME action: stop script: - cd ../ &amp;&amp; cd <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID &amp;&amp; docker-compose down &amp;&amp; cd ../ &amp;&amp; echo password | sudo -<span class="hljs-type"><span class="hljs-type">S</span></span> rm -rf <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID #       when: manual</code> </pre><br></div></div><br>  Dalam konfigurasi ini, 2 tahapan dijelaskan - build dan clear.  Fase build memiliki 2 opsi - build_develop dan build_prod <br><br><img src="https://habrastorage.org/webt/yz/ut/dy/yzutdyyknwjgwbcg4-kj2ssv-f8.png"><br><br>  Gitlab membangun diagram alur proses yang dapat dimengerti.  Dalam contoh saya, semua proses dimulai secara manual (ketika: parameter manual).  Hal ini dilakukan agar pengembang, setelah menyebarkan situs pengujian, dapat menarik suntingannya ke dalam wadah tanpa membangun kembali seluruh wadah.  Alasan lain adalah nama domain - situs $ CI_PIPELINE_ID.test, di mana CI_PIPELINE_ID adalah jumlah proses yang memulai perakitan.  Artinya, mereka mengirimkan situs dengan domain site123.test untuk verifikasi, dan untuk melakukan pengeditan, pengembang segera menuangkan perubahan ke dalam wadah. <br><br>  Fitur kecil pelaksana ssh.  Saat terhubung ke server, folder formulir dibuat. <br><br><pre> <code class="bash hljs">/home//builds/_runner/0/_/_</code> </pre> <br>  Oleh karena itu, garis ditambahkan <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../ &amp;&amp; cp -r <span class="hljs-variable"><span class="hljs-variable">$CI_PROJECT_NAME</span></span> <span class="hljs-variable"><span class="hljs-variable">$CI_PIPELINE_ID</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">$CI_PIPELINE_ID</span></span></code> </pre> <br>  Di dalamnya, kita naik ke folder di atas dan menyalin proyek ke folder dengan nomor proses.  Jadi, Anda dapat menggunakan beberapa cabang dari satu proyek.  Tetapi dalam pengaturan pawang, Anda perlu memeriksa Kunci untuk proyek saat ini, sehingga pawang tidak akan mencoba untuk memperluas beberapa cabang secara bersamaan. <br><br>  Tahap yang jelas menghentikan wadah dan menghapus folder, Anda mungkin memerlukan hak akses root, jadi kami menggunakan kata sandi gema |  sudo -S rm di mana kata sandi adalah kata sandi Anda. <br><br><h4>  Pengumpulan sampah </h4><br>  Dari waktu ke waktu, Anda perlu menghapus wadah yang tidak digunakan agar tidak memakan ruang, untuk ini skrip dengan konten seperti itu menggantung di mahkota <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #   : docker ps --filter status=dead --filter status=exited -aq | xargs -r docker rm -v #   : yes | docker container prune #    : yes | docker image prune #    : yes | docker volume prune</span></span></code> </pre> <br>  dilakukan sekali sehari. <br><br><h3>  Kesimpulan </h3><br>  Solusi ini membantu kami mengoptimalkan pengujian dan pelepasan fitur baru secara signifikan.  Siap menjawab pertanyaan, kritik konstruktif diterima. <br><br><h3>  Bonus </h3><br>  Agar tidak mengumpulkan gambar dari Dockerfile setiap kali, Anda dapat menyimpannya di registri buruh pelabuhan lokal. <br><br><div class="spoiler">  <b class="spoiler_title">File docker-compose.yml</b> <div class="spoiler_text"><pre> <code class="hljs powershell">registry: restart: always image: registry:<span class="hljs-number"><span class="hljs-number">2</span></span> ports: - <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">5000</span></span> volumes: - /opt/docker<span class="hljs-literal"><span class="hljs-literal">-registry</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>:/var/lib/registry <span class="hljs-comment"><span class="hljs-comment">#    </span></span></code> </pre><br></div></div><br>  Opsi ini tidak menggunakan otentikasi, ini bukan cara yang aman (!!!), tetapi cocok untuk menyimpan gambar yang tidak penting. <br><br>  Anda dapat mengkonfigurasi gitlab untuk melihatnya <br><br><pre> <code class="bash hljs"> gitlab_rails[<span class="hljs-string"><span class="hljs-string">'registry_enabled'</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span> gitlab_rails[<span class="hljs-string"><span class="hljs-string">'registry_host'</span></span>] = <span class="hljs-string"><span class="hljs-string">"registry.test"</span></span> gitlab_rails[<span class="hljs-string"><span class="hljs-string">'registry_port'</span></span>] = <span class="hljs-string"><span class="hljs-string">"5000"</span></span></code> </pre><br>  Setelah itu, daftar gambar muncul di gitlab <br><br><img src="https://habrastorage.org/webt/lu/hn/8i/luhn8ilow44doqm5btrtafgv-hq.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426319/">https://habr.com/ru/post/id426319/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426305/index.html">Bekerja dengan status karakter. Eksperimen Persatuan</a></li>
<li><a href="../id426311/index.html">Konferensi BLACK HAT USA. Botnet dari sejuta browser. Bagian 2</a></li>
<li><a href="../id426313/index.html">Belajar Microsoft Baru</a></li>
<li><a href="../id426315/index.html">Bagaimana cara berteman python dengan Internet Tak Terlihat? Dasar-dasar pengembangan aplikasi I2P dalam Python dan asyncio</a></li>
<li><a href="../id426317/index.html">1155 vs 2011. Beberapa orang tua pergi berperang</a></li>
<li><a href="../id426323/index.html">Upaya membuat case robot dengan anggaran terbatas. Keset kaca dan epoksi</a></li>
<li><a href="../id426325/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 12: Keamanan Jaringan, Bagian 1</a></li>
<li><a href="../id426327/index.html">Apa yang Baru dalam Pembaruan Windows 10 Oktober 2018</a></li>
<li><a href="../id426331/index.html">Kerentanan dalam PlayStation 4 - karakter yang diatur dalam pesan untuk pengguna mengubah konsol menjadi hampir "batu bata"</a></li>
<li><a href="../id426333/index.html">Microsoft telah merilis kode MS-DOS 1.25 dan 2.0 di bawah lisensi MIT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>