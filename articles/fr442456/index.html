<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍⚖️ 🎃 🧠 Comment économiser des ressources dans le navigateur et ne pas casser le Web. Rapport Yandex 👨🏽‍🏭 🚣🏽 🐬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Malgré la croissance des performances des appareils, le Web devient de plus en plus exigeant en mémoire et en processeur. Un rendu correct et une allo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment économiser des ressources dans le navigateur et ne pas casser le Web. Rapport Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/442456/"> Malgré la croissance des performances des appareils, le Web devient de plus en plus exigeant en mémoire et en processeur.  Un rendu correct et une allocation intelligente des ressources entre les onglets est un élément important pour résoudre ce problème.  Konstantin Kramlih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">PurplePowder a</a> consacré son discours à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conférence</a> «I Frontend» aux algorithmes qui améliorent la productivité et économisent des ressources à la fois dans le projet Chromium et dans Yandex.Browser. <br><br>  Certains d'entre eux - par exemple, la technologie Hibernate - nous les avons déjà triés dans un article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">séparé</a> .  Le rapport Bones couvre le problème plus largement: non seulement du point de vue de la commutation des onglets, mais également en tenant compte des méthodes de rendu du contenu, des tuiles et des couches de page. <br><br>  Vers la fin, les développeurs d'interfaces Web peuvent apprendre à identifier et à résoudre les problèmes de performances des sites Web. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6OLVN_gprow" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Je m'appelle Kostya, je suis le chef du groupe de développement des composants internes de l'équipe Yandex.Browser.  Dans le navigateur, je fais différentes choses depuis un peu plus de cinq ans: du décodage dans le navigateur, de toutes les vidéos HTML5 au rendu, au rendu et à d'autres processus similaires. <br><br><a name="habracut"></a>  Depuis un an et demi à deux ans, je participe à des projets d'économie de ressources dans le navigateur: CPU, mémoire, batterie. <br><br>  Vous dites - Kostya, dans la cour en 2019, où sont les problèmes de ressources?  Vous pouvez acheter n'importe quel appareil que vous voulez avec toutes les ressources.  Mais si nous nous tournons vers les statistiques ouvertes de Mozilla, nous verrons que la moitié des utilisateurs ont 4 Go de mémoire ou moins.  Et de nombreux utilisateurs qui ont un ou deux cœurs physiques, ils constituent une proportion considérable de votre audience.  Dans ce monde, nous vivons. <br><br><img src="https://habrastorage.org/webt/vr/cx/q0/vrcxq0duik8iaocs9q0v7xbkcqs.jpeg"><br><br>  Combien d'entre vous voient souvent cet onglet?  C'est exactement ce qui se passe dans le cas des utilisateurs ordinaires qui ont peu de RAM et de vieux ordinateurs. <br><br><img src="https://habrastorage.org/webt/kd/kq/db/kdkqdbilt2lzsmz5q5p5xgizgci.jpeg"><br><br>  Que faire  Le problème n'est un secret pour personne, ils ont commencé à lutter activement contre lui il y a environ trois ans.  Depuis lors, les écrous ont été progressivement resserrés de diverses manières.  Permettez-moi de vous montrer un exemple qui a contourné Stack Overflow vers 2016.  Voici un extrait assez simple.  Cette chose met à jour le titre et définit le temps écoulé depuis le dernier lancement de cette fonction.  Que faut-il obtenir idéalement?  Toutes les 100 ms dans le titre doivent être écrites + -100.  Quelle chance. <br><br><img src="https://habrastorage.org/webt/eh/fs/3h/ehfs3hfvws_8dd1t_fxe29qgdui.jpeg"><br><br>  Mais que faire si nous ouvrons et faisons cela?  Quelqu'un a-t-il rencontré cela?  La question est allée à Stack Overflow: qu'est-ce qui fait que Cookie Clicker cesse de fonctionner dans mes onglets d'arrière-plan?  Ce fut l'une des premières initiatives Chromium visant à réduire l'utilisation du processeur dans le navigateur.  L'idée était que si l'utilisateur n'utilisait pas l'onglet maintenant, il n'en avait pas besoin maintenant - mettons JS dessus. <br><br>  Le navigateur essaie de maintenir la charge du processeur sur cet onglet à environ 1% - il commence à suspendre toutes sortes de minuteries, l'exécution de JS, etc. C'est l'une des premières étapes d'un avenir radieux. <br><br><img src="https://habrastorage.org/webt/qf/vu/_c/qfvu_cyufv3gab9rsell45yv-6g.jpeg"><br><br>  Après un certain temps dans le navigateur, vous obtiendrez une situation où les onglets d'arrière-plan cesseront de fonctionner.  C'est le brillant avenir dont je parle.  Selon les plans de Chromium, qu'ils ont exprimés lors du dernier BlinkOn, en 2020, ils prévoient de le faire: laissez l'onglet se charger et s'il est en arrière-plan, il ne fera rien.  Vous devez toujours vous y préparer. <br><br><img src="https://habrastorage.org/webt/u2/_i/gx/u2_igx67m7vxehtknn_-juntdjs.jpeg"><br><br>  Dans Yandex.Browser, nous avons également pris soin d'un tel problème, mais nous l'avons résolu de manière moins catégorique et n'avons pas cassé l'ensemble du Web.  Nous avons créé un mode d'économie d'énergie qui désactive le décodage sur le processeur et ne laisse que le décodage sur la carte vidéo, et réduit également le FPS et désactive certaines animations qui ne sont pas nécessaires pour le moment et au lieu desquelles l'utilisateur doit économiser la batterie.  Cela nous a donné environ une heure d'autonomie supplémentaire.  Tout le monde peut vérifier, ixbt, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vérifié</a> . <br><br><img src="https://habrastorage.org/webt/vi/jx/kb/vijxkbmraau6ziqjhlswbz_u-t4.jpeg"><br><br>  Je pense que certains diront: Kostya, vous avez «cassé» le Web, aidé certains utilisateurs, mais n’avez rien trouvé de plus intelligent.  Ajoutez du hardcore!  Comment les navigateurs dessinent-ils des pages? <br><br><img src="https://habrastorage.org/webt/u4/2j/hy/u42jhyxml4ljdmmd6iu69azgl4g.jpeg"><br><br>  Le concept de couches, en bref, est lorsque le navigateur essaie de diviser la page en couches et de les dessiner séparément.  Ceci est fait pour que certaines animations soient effectuées et ne forcent pas à redessiner ce qui est statique.  Le navigateur le fait sur différentes heuristiques.  Par exemple - essayer de sélectionner un élément vidéo dans un calque séparé, qui, évidemment, se redessine rapidement et souvent.  Et s'il est affiché quelque part, vous n'avez pas besoin de tout redessiner en dessous. <br><br>  De plus, chaque couche est divisée en de telles tuiles - des rectangles de 256 par 256. Dans l'inspecteur, vous pouvez voir quelque chose comme ça.  Il y a un cadre qui est divisé en un tas de tuiles. <br><br><img src="https://habrastorage.org/webt/li/g7/ft/lig7ftmhfrgn3r_rlppouwefs8w.jpeg"><br><br><img src="https://habrastorage.org/webt/ip/1e/ud/ip1eudzb0uatttxq7-ydfb-aqe0.jpeg"><br><br>  Qu'est-ce que c'est et pourquoi est-il nécessaire?  Tout d'abord, pour prioriser le rendu.  Si nous avons une énorme saucisse, sur laquelle nous dessinons tous, alors pourquoi devons-nous dessiner tout cela si maintenant l'utilisateur ne voit que ce qu'il a maintenant dans ViewPort? <br><br><img src="https://habrastorage.org/webt/4q/nf/5o/4qnf5oxbb4j3ta9jfxca9urof3c.jpeg"><br><br>  En utilisant cette approche, nous dessinons d'abord uniquement ce que l'utilisateur voit en ce moment dans ViewPort, puis une tuile autour, puis dans le sens du défilement.  Si l'utilisateur fait défiler vers le bas - tirer vers le bas, si vers le haut.  Tout le reste ne sera dessiné que si nous avons un quota pour ces tuiles et que nous pouvons les dessiner, après quoi l'utilisateur les verra jamais.  Ou peut-être jamais. <br><br><img src="https://habrastorage.org/webt/vt/vd/uw/vtvduwiv5swz_ogt7vkpwr8_rjc.jpeg"><br><br>  Cela aide également beaucoup de personnes handicapées.  Supposons qu'un utilisateur ouvre une page, sélectionne un morceau et que nous n'ayons pas besoin de tout redessiner.  Nous pouvons laisser la plupart du rendu précédent.  Nous redessinerons six tuiles ici, et tout ira bien. <br><br><img src="https://habrastorage.org/webt/5z/4p/uw/5z4puwbbmkpqcdqbip5yh1lstew.jpeg"><br><br>  Juste à ce niveau, plusieurs optimisations très réussies ont été faites.  Par exemple, Chromium a réalisé une telle optimisation vers 2017. <br><br><img src="https://habrastorage.org/webt/vc/lk/gy/vclkgyedfjzyc5wreb-q4t52pv0.jpeg"><br><br>  Si nous n'avons qu'un petit rendu, nous le faisons seulement.  Ensuite, le curseur clignote et nous redessinons uniquement la zone du curseur, mais pas toute la zone de cette tuile.  Nous économisons beaucoup de CPU pour ne pas tout redessiner. <br><br><img src="https://habrastorage.org/webt/ax/-a/cv/ax-acv5ypcljlc7jkheipeut6ek.jpeg"><br><br>  Cela permet également d'économiser de la mémoire.  Quel est le problème ici?  Rectangles blancs entiers.  Imaginez que ce soit une texture de 256 x 256, quatre octets par pixel.  Bien qu'il semble que cette zone puisse être codée avec seulement cinq chiffres: coordonnées, largeur, hauteur et couleur. <br><br><img src="https://habrastorage.org/webt/ho/kx/kt/hokxktfgpxja01guodvgtxdhv6q.jpeg"><br><br>  Dans Chrome, l'optimisation des zones monochromes a été effectuée.  Si le navigateur comprend qu'il n'y a pas de rendu dans ce rectangle, qu'il est complètement monochrome, non transparent et remplit d'autres conditions, alors nous disons simplement à la carte vidéo - dessinez un rectangle blanc, ne sélectionnez pas la texture entière. <br><br>  Quoi d'autre peut être optimisé ici?  Si vous regardez les tuiles restantes - elles ont un peu de contenu et une énorme zone de couleur blanche.  Chez Yandex.Browser, nous y avons réfléchi et créé un mécanisme que nous avons appelé le carrelage adaptatif. <br><br><img src="https://habrastorage.org/webt/xr/vc/9j/xrvc9j8bqm5fpslcp1jbkvjzqpy.jpeg"><br><br>  Il y a un petit rectangle, une tuile.  Il y a peu de contenu au milieu de la tuile.  Nous le sélectionnons et - seulement en dessous - la texture.  Tout le reste est également divisé en plusieurs zones, dont nous parlons de la carte vidéo: il suffit de dessiner en blanc ici cette taille. <br><br><img src="https://habrastorage.org/webt/jh/ow/c7/jhowc7oh1nxm6-ofebqgzznnaya.jpeg"><br><br>  La page commence également à enregistrer tout ce qui est surligné en rouge.  Sur des pages plus complexes, cela ressemble à ceci. <br><br><img src="https://habrastorage.org/webt/of/pu/lz/ofpulzw2yanibpfx7vrweogcsr8.jpeg"><br><br>  Il est important de comprendre qu'il existe encore un tas de couches et que chaque couche est dessinée comme ceci.  Sur chaque couche, vous pouvez économiser une certaine quantité de mémoire.  Cette approche nous a permis d'économiser environ 40% de mémoire vidéo en moyenne pour tous les utilisateurs. <br><br>  Plus hardcore!  Ils ont sauvé un peu de mémoire ici, ils ont «cassé» le Web - pourquoi ne pas «briser» encore le Web? <br><br>  Dans Chromium, il y a quelque chose comme une politique: si l'utilisateur n'utilise pas d'onglets d'arrière-plan, s'il les a laissés, alors il n'en a pas besoin.  Si nous sommes maintenant sans mémoire et que le navigateur est en train de perdre du temps, prenons l'onglet le plus ancien que l'utilisateur n'a pas utilisé depuis longtemps et supprimons-le.  Elle restera dans l'interface, mais le processus ne sera plus là, tous les JS mourront.  Est-ce que ça va ou pas?  Il est étrange de poser une telle question à la partie frontale et d'attendre une réponse autre que "Que faites-vous?" <br><br><img src="https://habrastorage.org/webt/ui/5j/nq/ui5jnqtbegu672hy2tzbfiglhrk.jpeg"><br><br>  Ensuite, cela ne s'est pas beaucoup passé.  Voici les vrais commentaires du blog Chromium: vous avez cassé toutes mes applications pour moi, il y avait une sorte de jeu - et hop, il n'a pas d'état.  Il est important de comprendre que le gestionnaire de déchargement n'a pas fonctionné, comme si nous avions simplement mis cet onglet.  L'utilisateur y revient ensuite, et nous le rechargeons depuis le réseau, comme si de rien n'était. <br><br>  Ensuite, cette approche a été temporairement abandonnée et a proposé une idée sérieuse plus réfléchie.  Ils l'ont appelée défausse. <br><br><img src="https://habrastorage.org/webt/x2/7w/zq/x27wzq5kw55gtlcsduajusa3yoi.jpeg"><br><br>  À quoi ça sert?  Il s'agit du même abattage d'onglets, uniquement contrôlé.  C'est ce qu'on appelle le mot intelligent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Page Lifecycle API</a> .  Si vous avez un onglet et que l'utilisateur ne l'a pas vu depuis longtemps, il peut passer à l'état figé.  Le navigateur dit à travers l'événement: je vais vous geler maintenant.  Après le traitement de l'événement, rien ne sera effectué du tout.  Faites ce dont vous avez besoin, préparez-vous. <br><br>  Ensuite, il peut soit quitter l'état gelé via l'événement de reprise, mais rien ne s'est passé.  Ou, si le navigateur a vraiment besoin de libérer de la mémoire maintenant, il suffit de le tuer.  Mais si l'utilisateur revient dans cet onglet, nous le rechargerons et définirons le champ a été ignoré pour le document. <br><br><img src="https://habrastorage.org/webt/8c/-i/wu/8c-iwuqbmjxvsrdksgcjwvenew4.jpeg"><br><br>  En ce moment, vous pouvez déjà vous abonner à ces événements et les attraper, en quelque sorte les traiter.  Si l'onglet est vraiment détruit, vous pouvez vérifier le champ a été supprimé.  Cela signifie que vous avez été restauré après une défausse.  Vous pouvez restaurer l'état précédent. <br><br><img src="https://habrastorage.org/webt/as/ny/b1/asnyb16w13ubi3k1dfi_04nicik.jpeg"><br><br>  Chez Yandex.Browser, nous avons pensé il y a quelques années: pourquoi ne pas utiliser une approche cardinale complexe.  Ils l'ont appelé Hibernate. <br><br><img src="https://habrastorage.org/webt/ce/7-/gn/ce7-gngt24kb9ikzc4nzdxbjspu.jpeg"><br><br>  À quoi ça sert?  Il existe plusieurs onglets, une sorte de JS est en cours d'exécution, une sorte d'état.  Un processus distinct est créé pour chaque onglet: ici une vidéo peut être lue, ici vous laissez quelque chose dans le formulaire.  Hibernate arrive - et il n'y a aucun processus.  Nous les avons tous.  Mais si nous revenons maintenant à ces onglets, le processus reprendra et tout l'état sera en place, la vidéo continuera à jouer au bon moment, tout le texte dans les champs restera en place. <br><br><img src="https://habrastorage.org/webt/oy/ks/ug/oyksug04glkeh-amu4dyqfrryyc.jpeg"><br><br>  Qu'avons-nous fait?  Trois choses les plus importantes vivent à l'intérieur de chaque rendu: V8, qui exécute l'intégralité du JS, Blink, qui stocke l'intégralité du DOM, et une sorte de liaison de navigateur, qui aide à tout connecter ensemble, avec des onglets et tout le reste. <br><br><img src="https://habrastorage.org/webt/pz/hj/h4/pzhjh4pmyn-yz5afmas6omozx6g.jpeg"><br><br>  Par exemple, considérons un échantillon.  Ici, nous attendons que l'onload se produise et ajoutons un nouvel élément div à l'arborescence DOM.  Pour le navigateur, cela ressemble à ceci. <br><br><img src="https://habrastorage.org/webt/ic/cu/vy/iccuvyjbkmkyjhbgfb5de8uqxpc.jpeg"><br><br>  Naturellement, il y a un arbre DOM, il a des champs, des objets associés et il y a une telle entité. <br><br><img src="https://habrastorage.org/webt/ng/tj/ki/ngtjkiwdv6raldvffqgnoils7ge.jpeg"><br><br>  Dans V8, l'état de chaque nœud est stocké et ces nœuds sont associés à des objets clignotants via une couche de liants.  Qu'avons-nous fait?  Nous avons pris le sérialiseur de la V8, sérialisé la totalité de l'état du V8, trouvé tous les objets associés dans Blink, écrit plus des sérialiseurs qui enregistrent la totalité de l'arborescence DOM, la sérialisent, puis écrivent sur le disque, compressés et chiffrés.  Et nous avons appris au navigateur à récupérer à partir d'un tel instantané.  Autrement dit, lorsque l'utilisateur accède à un tel onglet, nous le développons, le déchiffrons et le montrons à l'utilisateur, le restaurons complètement.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un article séparé sur Hibernate</a> - environ.) <br><br>  À l'heure actuelle, Hibernate est publié pour tout le monde dans stable et permet à chaque utilisateur d'enregistrer en moyenne un ou deux onglets.  Autrement dit, il a en moyenne un onglet toujours enregistré, ou peut-être deux.  Cela économise de la mémoire pour les utilisateurs qui ont plus de 10 onglets - comme nous le faisons avec vous, mais nous ne sommes pas représentatifs. <br><br>  J'ai expliqué comment le navigateur essayait d'aider, mais maintenant chacun de vous peut faire quelque chose pour accélérer le site, améliorer ses performances.  Vous pouvez venir bien faire aujourd'hui. <br><br>  Vous devez d'abord comprendre s'il y a des problèmes de mémoire. <br><br><img src="https://habrastorage.org/webt/xu/l4/nv/xul4nvtip2nc_mr93zrevltkmye.jpeg"><br><br>  Il existe certains symptômes: soit le site commence à se dégrader, soit une décoloration apparaît.  Habituellement, cela signifie que le garbage collector est déclenché, le monde entier est gelé et rien n'est dessiné.  Ou que le site ralentit tout simplement constamment - cela arrive aussi. <br><br>  Vous devez comprendre s'il y a un problème.  Nous regardons ce qui se passe avec la mémoire JS. <br><br><img src="https://habrastorage.org/webt/ui/g4/kz/uig4kzofjrymuq0egjmk-cdt36o.jpeg"><br><br>  Si elle saute d'avant en arrière ou croît continuellement, ce n'est pas un bon symptôme.  Ou en croissance continue. <br><br><img src="https://habrastorage.org/webt/dt/to/ek/dttoekpmiceh7_6693-n6vrtsjk.jpeg"><br><br>  Dans ce cas, vous pouvez toujours prendre un instantané via DevTools.  Quelqu'un a-t-il même dérangé des fuites dans JS?  Si quelqu'un ne sait pas, dans JS, il est tout à fait possible de faire une fuite. <br><br><img src="https://habrastorage.org/webt/da/n_/yh/dan_yhjbdvvilgwgovgzzf6tpgu.jpeg"><br><br>  Par exemple, vous avez une variable globale dans laquelle vous ajoutez des nœuds qui ne sont pas insérés dans l'arborescence.  Vous les oubliez, puis il s'avère qu'ils mangent des centaines de kilo-octets, voire des mégaoctets. <br><br><img src="https://habrastorage.org/webt/vq/au/ia/vqauia5ylxx_u0xu8arw5ycuvta.jpeg"><br><br>  À strictement parler, on ne sait pas quoi faire avec ces nœuds détachés.  Vous pouvez les retirer de l'arbre, puis les réinsérer.  Parce que généralement l'état de l'image ou quelque chose d'autre leur reste.  Ainsi, vous pouvez les trouver et traiter le problème. <br><br><img src="https://habrastorage.org/webt/w7/a6/cy/w7a6cyfk_5iroc0ybpdk21gym5k.jpeg"><br><br>  Vous pouvez également consulter l'allocation de mémoire sur la chronologie.  Si vous avez une décharge systématique et ne nettoyez jamais, c'est aussi un mauvais signe, je pense que tout le monde le comprend. <br><br><img src="https://habrastorage.org/webt/0m/ol/4w/0mol4w_xotmiebkvvheldcrnokq.jpeg"><br><br>  Et vous pouvez jouer avec les calques de votre onglet.  Le navigateur fonctionne généralement avec des heuristiques à cet égard - il essaie de séparer les objets qu'il considère fréquemment changer en couches distinctes.  Mais parfois, cela ne fonctionne pas très bien, et il s'avère que vous avez beaucoup de couches qui consomment beaucoup de mémoire.  Vous pouvez toujours voir si vous avez une telle situation, éliminer certaines couches et savoir combien de mémoire cette couche occupe. <br><br><img src="https://habrastorage.org/webt/rc/w6/il/rcw6ilo68vshxkgqzq82esab_1y.jpeg"><br><br>  Une autre couche de problèmes est la performance.  setTimeout est une mauvaise idée pour l'animation.  Cela ne fonctionne pas comme le navigateur souhaite afficher la page.  Cela peut ne pas fonctionner en phase: le navigateur a demandé une image, mais il n'y a pas encore d'animation, car setTimeout n'a pas fonctionné.  Ou cela peut fonctionner même lorsque vous n'avez pas besoin de dessiner quoi que ce soit.  L'utilisateur est parti, il reste encore un peu de travail en arrière-plan, mais nous travaillerons avec lui via setTimeout. <br><br>  Voici l'approche correcte que votre rappel n'appellera que lorsque le navigateur devra dessiner cette page. <br><br><img src="https://habrastorage.org/webt/st/nr/dv/stnrdvev7a9sricvyvwivcufg4k.jpeg"><br><br>  Je tiens également à vous rappeler que si le navigateur souhaite dessiner 60 images par seconde, cela signifie que pour chaque image, il lui faut environ 16 ms. <br><br><img src="https://habrastorage.org/webt/zo/fy/es/zofyesewo-ck8wl-z_jlsb6u7ak.jpeg"><br><br>  Et si vous occupez le flux principal plus de 16 ms, vous avez alors un saut de trame garanti, ce qui est plutôt désagréable pour l'utilisateur: le site commence à se branler.  Par conséquent, tout le travail acharné correctement mis dans les threads d'arrière-plan, dont vous retournez simplement le résultat. <br><br><img src="https://habrastorage.org/webt/mp/rk/ry/mprkryexbai19rd-vhbj_tlbeb4.jpeg"><br><br>  Ou une autre approche consiste à utiliser le microtâche.  Créez une file d'attente de tâches, traitez-la après un certain temps, jusqu'à ce que le quota soit dépassé, et laissez le navigateur dessiner calmement la page. <br><br><img src="https://habrastorage.org/webt/-0/jr/bn/-0jrbntves41mkelcd56bmgu6uc.jpeg"><br><br>  Naturellement, vous pouvez ajouter de nouveaux calques.  Le navigateur fonctionne sur l'heuristique et essaie de sélectionner la couche où il le juge nécessaire.  Mais si vous savez qu'en ce moment cet élément sera animé, il est préférable de dire explicitement au navigateur que vous devez sélectionner cet élément dans un calque séparé.  Ensuite, il sera dessiné plus efficacement. <br><br><img src="https://habrastorage.org/webt/t9/pf/mr/t9pfmrqa0mhyszxphlkmvxafsag.jpeg"><br><br>  La dernière approche intéressante - se plaindre.  Si vous avez des problèmes, il est toujours utile de venir parler.  Peut-être que ce problème peut être facilement traité, et nous nous entraiderons. <br><br>  Un peu de fond.  Cette fonctionnalité est en cours d'élaboration.  Nous avons une équipe de pages de développement de moteurs de recherche.  Ils ont une métrique telle que le moment du rendu du premier extrait.  Si l'utilisateur voit précédemment le premier lien sur lequel vous devez cliquer et qui lui donne probablement la bonne réponse, il est préférable de le dessiner le plus rapidement possible.  Ils sont venus et ont demandé s'il était possible d'accélérer d'une manière ou d'une autre cette fois, car ils s'étaient tous évincés. <br><br>  Nous avons enquêté, effectué des tests de performance, réalisé un prototype et il s'est avéré que nous pouvons le faire si le site nous dit quoi dessiner en premier.  Nous avons testé et constatons que cela améliore nos performances.  Maintenant, nous testons cela en production pour un petit public.  Nous regardons ce qui en sortira.  Restez à l'écoute. <br><br>  Le monde ne reste pas immobile.  L'utilisateur commence à en vouloir de plus en plus, les navigateurs changent, le web change.  C'est normal.  Nous essayons non seulement de créer des fonctionnalités d'épicerie, mais aussi d'aider l'utilisateur de toutes les manières possibles à obtenir la meilleure expérience en termes de consommation de contenu.  Et vous devez toujours être préparé aux changements dans n'importe quel navigateur populaire.  Naturellement, s'il y a des problèmes - venez, nous sommes prêts à discuter et à nous entraider. <br><br>  Ici, j'ai rassemblé divers liens utiles: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hibernation sur le navigateur Yandex</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Languette jetable en chrome</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Page Lifecycle API</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mesurer les performances avec le modèle RAIL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Économie d'énergie dans Yandex.Browser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Statistiques du matériel Steam</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le rapport sur les données publiques de Firefox</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442456/">https://habr.com/ru/post/fr442456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442446/index.html">Transformation numérique à l'exemple du centre d'appels de toute entreprise</a></li>
<li><a href="../fr442448/index.html">Modèles de concurrence et d'erreur masqués dans le code: blocage</a></li>
<li><a href="../fr442450/index.html">Blockchain et données médicales: comment ça marche</a></li>
<li><a href="../fr442452/index.html">Comment se connecter à NodeJS pour que les garçons dans la cour respectent</a></li>
<li><a href="../fr442454/index.html">Magic Leap prévoit de compléter le monde réel avec des couches numériques</a></li>
<li><a href="../fr442458/index.html">Abîme ou chemin créé par l'homme d'un pilote RPA à une mise en œuvre à l'échelle de l'entreprise</a></li>
<li><a href="../fr442460/index.html">Aider le fournisseur de requêtes à trier les chaînes interpolées</a></li>
<li><a href="../fr442462/index.html">Erreurs typiques lors de l'utilisation de PostgreSQL. Partie 1</a></li>
<li><a href="../fr442464/index.html">Comment le "Dragon" habité a-t-il grandi</a></li>
<li><a href="../fr442466/index.html">Comment promouvoir un jeu incrémental? Gratuit, rapide et efficace *</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>