<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏼 🧜🏾 🤦🏼 Bagaimana Typcript mengecewakan saya dan apakah itu layak? 👨🏻‍🎨 🌩️ 🐞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebelum memulai, saya ingin menyebutkan bahwa saya adalah penggemar TypeScript. Ini adalah bahasa pemrograman utama saya untuk proyek front-end pada B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana Typcript mengecewakan saya dan apakah itu layak?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vdsina/blog/485206/"><img src="https://habrastorage.org/webt/3w/bb/rv/3wbbrvcbnytxte0qcz54gsibk10.png"><br><br>  Sebelum memulai, saya ingin menyebutkan bahwa saya adalah penggemar TypeScript.  Ini adalah bahasa pemrograman utama saya untuk proyek front-end pada Bereaksi dan untuk setiap pekerjaan backend yang saya lakukan di Node.  Saya sepenuhnya untuk naskah, tetapi ada saat-saat yang mengganggu saya dan yang ingin saya ceritakan artikel ini. <br><a name="habracut"></a><br>  Saya menulis secara eksklusif pada TypeScript selama tiga tahun terakhir untuk banyak perusahaan yang berbeda, jadi menurut saya, TypeScript setidaknya melakukan sesuatu dengan benar atau menutup kebutuhan tertentu. <br><br>  Terlepas dari ketidaksempurnaannya, TypeScript memasuki frontend pengembangan arus utama dan menempati urutan ketujuh dalam daftar bahasa pemrograman paling populer menurut <a href="https://research.hackerrank.com/developer-skills/2019">laporan keterampilan pengembang HackerRank</a> . <br><br>  Setiap tim pengembang, baik besar maupun kecil, menulis dalam TypeScript atau tidak, selalu layak untuk keamanan: <br><br><ul><li>  Pastikan bahwa unit test yang ditulis dengan baik mencakup kode sebanyak mungkin dalam produksi. </li><li>  Gunakan pemrograman pasangan: sepasang mata ekstra akan membantu menangkap hal-hal yang lebih serius daripada hanya kesalahan sintaksis </li><li>  Secara kualitatif membangun proses peninjauan kode dan mengidentifikasi kesalahan yang tidak dapat ditemukan mesin </li><li>  Gunakan linter - seperti eslint </li></ul><br>  Meskipun TypeScript menambahkan tingkat keamanan tambahan di atas semua ini, tetapi menurut saya, sangat jauh di belakang bahasa lain dalam hal ini.  Saya akan menjelaskan alasannya. <br><br><h2>  TypeScript bukan sistem tipe yang dapat diandalkan </h2><br>  Saya pikir ini mungkin masalah utama dengan TypeScript, tapi pertama-tama izinkan saya menentukan apa <i>jenis sistem yang dapat diandalkan</i> dan <i>tidak dapat diandalkan</i> . <br><br><h3>  Sistem Tipe Kuat </h3><br>  <i>Sistem</i> tipe yang <i>andal</i> memastikan bahwa program Anda tidak berakhir dalam keadaan tidak valid.  Misalnya, jika tipe statis dari ekspresi adalah <i>string</i> , ketika dievaluasi pada saat run, Anda dijamin hanya akan mendapatkan <i>string</i> . <br><br>  Dalam sistem tipe yang andal, Anda tidak akan pernah berada dalam situasi di mana ekspresi tidak cocok dengan tipe yang diharapkan, baik pada waktu kompilasi atau pada saat run time. <br><br>  Tentu saja, ada berbagai tingkat keandalan, serta berbagai interpretasi keandalan.  TypeScript agak dapat diandalkan dan menangkap kesalahan tipe: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Type 'string' is not assignable to type 'number' const increment = (i: number): number =&gt; { return i + "1"; } // Argument of type '"98765432"' is not assignable to parameter of type 'number'. const countdown: number = increment("98765432");</span></span></code> </pre> <br><h3>  Sistem Jenis Tidak Aman </h3><br>  Typescript benar-benar secara terbuka melaporkan bahwa keandalan 100% bukan tujuannya.  Bahkan "non-target" nomor 3 pada <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals">daftar</a> "non-target" <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals">TypeScript</a> dengan jelas menyatakan: <br><blockquote>  Memiliki sistem tipe yang andal atau "terbukti benar" bukanlah tujuan kami.  Alih-alih, kami berusaha untuk mencapai keseimbangan antara akurasi dan kinerja. </blockquote><br>  Ini berarti bahwa tidak ada jaminan bahwa variabel adalah tipe tertentu pada saat dijalankan.  Saya dapat menggambarkan ini dengan contoh yang agak dibuat-buat berikut: <br><br><pre> <code class="javascript hljs">interface A { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: number; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: A = {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b: {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: number | string} = a; bx = <span class="hljs-string"><span class="hljs-string">"unsound"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: number = ax; <span class="hljs-comment"><span class="hljs-comment">// unsound axtoFixed(0); // WTF is it?</span></span></code> </pre> <br>  Kode di atas tidak berfungsi, karena diketahui bahwa <i>kapak</i> adalah angka dari antarmuka <i>A.</i>  Sayangnya, setelah beberapa tipuan dengan penugasan kembali, itu berubah menjadi string dan kode ini dikompilasi, tetapi dengan kesalahan saat runtime. <br><br>  Sayangnya, ungkapan ini dikompilasi tanpa kesalahan: <br><br><pre> <code class="javascript hljs">axtoFixed(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Keandalan itu bukan tujuan bahasa mungkin salah satu masalah terbesar TypeScript.  Saya terus mendapatkan banyak kesalahan runtime error saat runtime yang tidak ditangkap oleh compiler <i>tsc</i> , tetapi kompiler itu akan memperhatikan jika TypeScript memiliki sistem tipe yang kuat.  TypeScript sekarang satu kaki di kamp bahasa "dapat diandalkan", dan yang lainnya di "tidak dapat diandalkan."  Pendekatan setengah-setengah ini didasarkan pada jenis <i>apa pun</i> , yang akan saya bahas nanti. <br><br>  Saya frustrasi dengan kenyataan bahwa jumlah tes yang saya tulis tidak berkurang sama sekali dengan transisi ke TypeScript.  Ketika saya baru mulai, saya keliru memutuskan bahwa saya dapat mengurangi rutinitas yang berat dalam menulis sejumlah besar unit test. <br><br>  TypeScript menantang keadaan saat ini dengan berpendapat bahwa menurunkan biaya kognitif saat menggunakan jenis lebih penting daripada keandalan. <br><br>  Saya mengerti mengapa TypeScript telah memilih jalur seperti itu dan ada pendapat bahwa TypeScript tidak akan begitu populer jika keandalan sistem tipe dijamin 100%.  Pendapat ini tidak tahan uji - <a href="https://dart.dev/">bahasa Dart</a> dengan cepat mendapatkan popularitas, seiring dengan meluasnya penggunaan Flutter.  Dan <a href="https://dart.dev/guides/language/sound-dart">dikatakan</a> bahwa reliabilitas tipe adalah tujuan Dart. <br><br>  Ketidakamanan dan berbagai cara yang diberikan oleh TypeScript sebagai "pintu darurat" dari pengetikan yang kuat membuatnya kurang efisien dan, sayangnya, menjadikannya <b>"lebih baik daripada tidak</b> sama <b>sekali"</b> saat ini.  Saya akan senang jika TypeScript semakin populer, lebih banyak opsi kompiler tersedia, memungkinkan pengguna berpengalaman untuk mengusahakan keandalan 100%. <br><br><h2>  TypeScript tidak menjamin semua tipe memeriksa pada saat runtime </h2><br>  Pengecekan tipe saat runtime bukan tujuan dari TypeScript, jadi keinginan saya mungkin tidak akan pernah menjadi kenyataan.  Pemeriksaan jenis run-time berguna, misalnya, ketika bekerja dengan data JSON yang dikembalikan dari panggilan API.  Adalah mungkin untuk menyingkirkan seluruh kategori kesalahan dan banyak unit test, jika kita bisa mengendalikan proses-proses ini pada level sistem tipe. <br><br>  Karena kami tidak dapat menjamin apa pun pada saat runtime, ini dapat dengan mudah terjadi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFullName = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (): <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person: AxiosResponse = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> api(); <span class="hljs-comment"><span class="hljs-comment">//response.name.fullName may result in undefined at runtime return response.name.fullName }</span></span></code> </pre><br>  Ada beberapa perpustakaan pembantu seperti <a href="https://github.com/gcanti/io-ts">io-ts</a> , yang bagus, tetapi itu mungkin berarti Anda harus menduplikasi model Anda. <br><br><h2>  Jenis menakutkan opsi apa pun dan ketat </h2><br>  Tipe any berarti "any", dan kompiler memungkinkan operasi atau penugasan variabel apa pun dari tipe ini. <br><br>  TypeScript bekerja dengan baik untuk hal-hal kecil, tetapi orang-orang cenderung menempatkan jenis apa pun pada apa pun yang membutuhkan waktu lebih dari satu menit.  Saya baru-baru ini mengerjakan proyek Angular dan melihat banyak kode seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ public _id: any; public name: any; public icon: any;</code> </pre> <br>  TypeScript memungkinkan Anda melupakan sistem tipe. <br><br>  Anda dapat merusak jenis apa pun dengan: <br><br><pre> <code class="javascript hljs">(<span class="hljs-string"><span class="hljs-string">"oh my goodness"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any).ToFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// remember what I said about soundness?</span></span></code> </pre> <br>  Opsi <i>ketat</i> mencakup opsi kompiler berikut, yang membuat semuanya lebih dapat diandalkan: <br><br><ul><li>  --strictNullChecks </li><li>  --noImplicitAny </li><li>  --tidak terapkan Ini </li><li>  --selalu ketat </li></ul><br>  Ada juga aturan eslint <a href="">@ typescript-eslint / no-eksplisit-apa pun</a> . <br><br>  Mendistribusikan <i>apa pun</i> dapat merusak keandalan kode Anda. <br><br><h2>  Kesimpulan </h2><br>  Saya harus mengulang bahwa saya adalah penggemar TypeScript dan menggunakannya dalam pekerjaan sehari-hari saya, tetapi saya merasa itu tidak sempurna dan hype di sekitarnya tidak sepenuhnya dibenarkan.  Airbnb <a href="https://www.reddit.com/r/typescript/comments/aofcik/38_of_bugs_at_airbnb_could_have_been_prevented_by/">mengklaim TypeScript membantu mencegah 38% kesalahan</a> .  Saya sangat skeptis tentang persentase yang dinyatakan secara akurat.  TypeScript tidak meningkatkan atau menggabungkan semua praktik kode baik yang ada.  Saya masih harus menulis banyak tes.  Anda bisa berpendapat bahwa saya menulis lebih banyak kode, jadi saya harus menulis begitu banyak tes.  Saya terus mendapatkan banyak kesalahan runtime yang tidak terduga. <br><br>  TypeScript hanya menawarkan pengecekan tipe dasar, dan fakta bahwa reliabilitas dan pengecekan tipe pada saat runtime bukan tujuannya meninggalkan TypeScript di dunia setengah-setengah, di tengah-tengah antara dunia terbaik dan dunia di mana kita kode sekarang. <br><br>  TypeScript sangat bagus berkat dukungan baik dari IDE seperti vscode, di mana kami mendapatkan umpan balik visual selama proses pencetakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3y/r3/j7/3yr3j7emqikwnbmhj97et9c2wpk.png"></div><br>  <i>Kesalahan ketikScript dalam vscode</i> <br><br>  TypeScript juga meningkatkan perubahan refactoring dan pemecahan kode (seperti perubahan dalam tanda tangan metode) yang secara instan diidentifikasi ketika kompiler TypeScript dimulai. <br>  TypeScript menyediakan pemeriksaan jenis yang baik dan jelas lebih baik daripada tidak ada pemeriksaan jenis atau eslint sederhana, tetapi saya merasa bahwa TypeScript bisa jauh lebih baik dan opsi kompiler yang diperlukan dapat menyenangkan mereka yang menginginkan lebih dari bahasa. <br><br> <a href="https://vdsina.ru/%3Fpartner%3D7d159c89hz"><img src="https://habrastorage.org/webt/ud/xv/wf/udxvwfcz80j3nug11rxaguqelww.png"><br></a> <br><h3>  Berlangganan pengembang Instagram kami </h3><br> <a href="http://bit.ly/34w4T9B"><img src="https://habrastorage.org/webt/e5/as/-l/e5as-ltfnotkemk2dsqngygimra.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485206/">https://habr.com/ru/post/id485206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485196/index.html">AvitoTech On Tour: Pergi dan berhadapan rapat di Kazan</a></li>
<li><a href="../id485198/index.html">Cara lain untuk mengukur kinerja metode aplikasi .NET</a></li>
<li><a href="../id485200/index.html">Mess pada awalnya: post-mortem pada kecepatan peluncuran aplikasi iOS</a></li>
<li><a href="../id485202/index.html">Sistem Penindasan</a></li>
<li><a href="../id485204/index.html">Kembali ke atas: mengapa kapitalisasi Amazon akan segera melebihi $ 1 triliun</a></li>
<li><a href="../id485208/index.html">Pembuatan infrastruktur TI yang toleran terhadap kesalahan. Bagian 2. Memasang dan mengonfigurasi kluster oVirt 4.3</a></li>
<li><a href="../id485210/index.html">Penembak zombie sederhana di Unity</a></li>
<li><a href="../id485214/index.html">CLRium # 7: Praktis. Seminar, pekerjaan rumah dengan verifikasi, pendampingan</a></li>
<li><a href="../id485218/index.html">Cadangan konstanta dan kait Git dalam C #</a></li>
<li><a href="../id485220/index.html">Evolusi Firewall Aplikasi Web: dari firewall ke sistem keamanan berbasis cloud pembelajaran mesin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>