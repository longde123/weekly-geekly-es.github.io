<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍✈️ 🧑🏽‍🤝‍🧑🏻 🕕 A quoi ressemblent les réseaux de neurones profonds et pourquoi ils nécessitent autant de mémoire 👩🏾‍🤝‍👨🏻 👨🏽‍🌾 🧞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, le graphique est l'un des moyens les plus acceptables pour décrire les modèles créés dans le système d'apprentissage automatique. Ces gra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A quoi ressemblent les réseaux de neurones profonds et pourquoi ils nécessitent autant de mémoire</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402641/"><img src="https://habrastorage.org/getpro/geektimes/post_images/802/6f4/eab/8026f4eab4ee028d6894159b00421c56.jpg" alt="image"><br><br>  Aujourd'hui, le graphique est l'un des moyens les plus acceptables pour décrire les modèles créés dans le système d'apprentissage automatique.  Ces graphiques de calcul sont composés de sommets de neurones reliés par des bords de synapse qui décrivent les connexions entre les sommets. <br><br>  Contrairement à un processeur graphique central ou vectoriel scalaire, IPU - un nouveau type de processeur conçu pour l'apprentissage automatique, vous permet de construire de tels graphiques.  Un ordinateur conçu pour la gestion des graphes est une machine idéale pour les modèles de graphes informatiques créés dans le cadre de l'apprentissage automatique. <br><br>  L'une des façons les plus simples de décrire le fonctionnement de l'intelligence artificielle est de la visualiser.  L'équipe de développement de Graphcore a créé une collection de ces images affichées sur l'UIP.  La base était le logiciel Poplar, qui visualise le travail de l'intelligence artificielle.  Les chercheurs de cette entreprise ont également découvert pourquoi les réseaux profonds nécessitent autant de mémoire et quelles solutions existent. <a name="habracut"></a><br><br>  Poplar inclut un compilateur graphique qui a été créé à partir de zéro pour traduire les opérations standard utilisées dans le cadre de l'apprentissage automatique en code d'application hautement optimisé pour les IPU.  Il vous permet de rassembler ces graphiques ensemble sur le même principe que les POPNN sont assemblés.  La bibliothèque contient un ensemble de différents types de sommets pour les primitives généralisées. <br><br>  Les graphiques sont le paradigme sur lequel tous les logiciels sont basés.  Dans Poplar, les graphiques vous permettent de définir le processus de calcul, où les sommets effectuent des opérations et les arêtes décrivent la relation entre eux.  Par exemple, si vous souhaitez ajouter deux nombres ensemble, vous pouvez définir un sommet avec deux entrées (les nombres que vous souhaitez ajouter), quelques calculs (la fonction d'ajouter deux nombres) et la sortie (résultat). <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/708/107/2ad/7081072ad3e33d401cabae1f3914bccb.jpg" alt="image"><br><br>  Habituellement, les opérations de sommet sont beaucoup plus compliquées que dans l'exemple décrit ci-dessus.  Ils sont souvent définis par de petits programmes appelés codelets (noms de code).  L'abstraction graphique est intéressante car elle ne fait aucune hypothèse sur la structure des calculs et décompose le calcul en composants que le processeur IPU peut utiliser pour fonctionner. <br><br>  Poplar utilise cette abstraction simple pour construire de très grands graphiques qui sont représentés sous forme d'images.  La génération programmatique du graphique signifie que nous pouvons l'adapter aux calculs spécifiques nécessaires pour assurer l'utilisation la plus efficace des ressources de l'UIP. <br><br>  Le compilateur traduit les opérations standard utilisées dans les systèmes d'apprentissage automatique en un code d'application hautement optimisé pour les IPU.  Un compilateur de graphiques crée une image intermédiaire d'un graphique de calcul qui est déployé sur un ou plusieurs périphériques IPU.  Le compilateur peut afficher ce graphe de calcul, donc une application écrite au niveau de la structure du réseau neuronal affiche une image du graphe de calcul qui s'exécute sur l'UIP. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/45a/eb2/4b8/45aeb24b80e244c6c16c6fc584d99678.jpg" alt="image"><br>  <i>Graphique d'apprentissage complet AlexNet en avant et en arrière</i> <br><br>  Le compilateur graphique Poplar a transformé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la</a> description <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'AlexNet</a> en un graphe de calcul de 18,7 millions de sommets et 115,8 millions d'arêtes.  Le clustering clairement visible est le résultat d'une forte connexion entre les processus dans chaque couche du réseau avec une connexion plus facile entre les niveaux. <br><br>  Un autre exemple est un réseau simple avec une connectivité complète, formé au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MNIST</a> - un simple ensemble de données pour la vision par ordinateur, une sorte de «Bonjour, monde» dans l'apprentissage automatique.  Un réseau simple pour explorer cet ensemble de données permet de comprendre les graphiques contrôlés par les applications Poplar.  En intégrant des bibliothèques de graphes à des environnements tels que TensorFlow, la société fournit l'un des moyens les plus simples d'utiliser les IPU dans les applications d'apprentissage automatique. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/f07/3bd/4e3/f073bd4e334225380ae51b16fb2e94b6.jpg" alt="image"><br><br>  Une fois le graphique construit à l'aide du compilateur, il doit être exécuté.  Cela est possible en utilisant le moteur graphique.  En utilisant ResNet-50 comme exemple, son fonctionnement est démontré. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/5d7/cb1/ce5/5d7cb1ce55a80f2b8e4ebefe38681710.jpg" alt="image"><br>  <i>Count ResNet-50</i> <br><br>  L'architecture ResNet-50 vous permet de créer des réseaux profonds à partir de partitions répétitives.  Le processeur n'a besoin de déterminer ces partitions qu'une seule fois et de les rappeler.  Par exemple, un cluster de niveau conv4 est exécuté six fois, mais une seule fois appliqué au graphique.  L'image montre également la variété des formes des couches convolutives, car chacune d'elles a un graphique construit conformément à la forme naturelle de calcul. <br><br>  Le moteur crée et contrôle l'exécution d'un modèle d'apprentissage automatique à l'aide d'un graphique créé par le compilateur.  Une fois déployé, Graph Engine surveille et répond aux IPU ou aux périphériques utilisés par les applications. <br><br>  L'image ResNet-50 montre l'ensemble du modèle.  À ce niveau, il est difficile de faire la distinction entre les sommets individuels, il est donc intéressant de regarder des images agrandies.  Voici quelques exemples de sections à l'intérieur des couches d'un réseau neuronal. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/dbf/166/408/dbf166408a0b1626a4bd720e1be1dbe9.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/d69/9c1/fb6/d699c1fb6f2e43b9f4d03b405c543186.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/802/6f4/eab/8026f4eab4ee028d6894159b00421c56.jpg" alt="image"><br><br><h3>  Pourquoi les réseaux profonds ont-ils besoin de tant de mémoire? </h3><br>  De grandes quantités de mémoire occupée sont l'un des plus gros problèmes des réseaux de neurones profonds.  Les chercheurs tentent de gérer la bande passante limitée des périphériques DRAM, qui devrait être utilisée par les systèmes modernes pour stocker un grand nombre de poids et d'activations dans un réseau neuronal profond. <br><br>  Les architectures ont été développées à l'aide de puces de processeur conçues pour le traitement séquentiel et l'optimisation de la DRAM pour la mémoire haute densité.  L'interface entre les deux appareils est un goulot d'étranglement qui introduit des limitations de bande passante et ajoute une surcharge importante à la consommation d'énergie. <br><br>  Bien que nous n'ayons toujours pas une image complète du cerveau humain et de son fonctionnement, il est généralement clair qu'il n'y a pas de grande installation de stockage séparée pour la mémoire.  On pense que la fonction de la mémoire à long terme et à court terme dans le cerveau humain est intégrée dans la structure des neurones + synapses.  Même des organismes simples comme les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vers</a> avec une structure neuronale du cerveau, composée d'un peu plus de 300 neurones, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ont un</a> certain degré de fonction de mémoire. <br><br>  Construire de la mémoire dans des processeurs conventionnels est un moyen de contourner les goulots d'étranglement de la mémoire en ouvrant une bande passante énorme avec une consommation d'énergie beaucoup moins élevée.  Néanmoins, la mémoire sur une puce est une chose coûteuse qui n'est pas conçue pour de très grandes quantités de mémoire, qui sont connectées aux processeurs centraux et graphiques actuellement utilisés pour la préparation et le déploiement de réseaux de neurones profonds. <br><br>  Par conséquent, il est utile d'examiner comment la mémoire est utilisée aujourd'hui dans les unités centrales de traitement et les systèmes d'apprentissage en profondeur sur les accélérateurs graphiques et de se demander: pourquoi ont-ils besoin de si grands dispositifs de stockage de mémoire alors que le cerveau humain fonctionne bien sans eux? <br><br>  Les réseaux de neurones ont besoin de mémoire pour stocker les données d'entrée, les paramètres de poids et les fonctions d'activation, car l'entrée est distribuée à travers le réseau.  En formation, l'activation en entrée doit être conservée jusqu'à ce qu'elle puisse être utilisée pour calculer les erreurs des gradients en sortie. <br><br>  Par exemple, un réseau ResNet à 50 couches a environ 26 millions de paramètres de pondération et calcule 16 millions d'activations directes.  Si vous utilisez un nombre à virgule flottante 32 bits pour stocker chaque poids et activation, cela nécessitera environ 168 Mo d'espace.  En utilisant une valeur de précision inférieure pour stocker ces échelles et activations, nous pourrions diviser par deux, voire quadrupler, cette exigence de stockage. <br><br>  Un grave problème de mémoire provient du fait que les GPU s'appuient sur des données représentées comme des vecteurs denses.  Par conséquent, ils peuvent utiliser un seul flux d'instructions (SIMD) pour obtenir un calcul haute densité.  Le processeur central utilise des blocs vectoriels similaires pour un calcul haute performance. <br><br>  Dans les GPU, la synapse a une largeur de 1024 bits, ils utilisent donc des données à virgule flottante 32 bits, donc ils les décomposent souvent en mini-lot parallèle de 32 échantillons pour créer des vecteurs de données 1024 bits.  Cette approche de l'organisation du parallélisme vectoriel augmente le nombre d'activations de 32 fois et le besoin de stockage local d'une capacité supérieure à 2 Go. <br><br>  Les GPU et autres machines conçues pour l'algèbre matricielle sont également soumis à une charge mémoire due aux poids ou aux activations du réseau neuronal.  Les GPU ne peuvent pas effectuer efficacement de petites convolutions utilisées dans les réseaux de neurones profonds.  Par conséquent, une transformation appelée «rétrogradation» est utilisée pour convertir ces convolutions en multiplications matrice-matrice (GEMM), que les accélérateurs graphiques peuvent gérer efficacement. <br><br>  De la mémoire supplémentaire est également requise pour stocker les données d'entrée, les valeurs de temps et les instructions de programme.  La mesure de l'utilisation de la mémoire lors de la formation de ResNet-50 sur un GPU hautes performances a montré qu'il nécessite plus de 7,5 Go de DRAM locale. <br><br>  Peut-être que quelqu'un décidera qu'une précision moindre peut réduire la quantité de mémoire nécessaire, mais ce n'est pas le cas.  Lorsque vous passez les valeurs des données à la moitié de la précision des pondérations et des activations, vous ne remplissez que la moitié de la largeur vectorielle du SIMD, en dépensant la moitié des ressources informatiques disponibles.  Pour compenser cela, lorsque vous passez de la précision totale à la demi-précision sur le GPU, vous devrez doubler la taille du mini-lot pour provoquer un parallélisme de données suffisant pour utiliser tous les calculs disponibles.  Ainsi, la transition vers des échelles de précision et des activations plus faibles sur le GPU nécessite toujours plus de 7,5 Go de mémoire dynamique en accès libre. <br><br>  Avec autant de données à stocker, il est tout simplement impossible de tout intégrer dans le GPU.  Sur chaque couche du réseau neuronal convolutif, il est nécessaire de sauvegarder l'état de la DRAM externe, de charger la couche de réseau suivante puis de charger les données dans le système.  En conséquence, l'interface de mémoire externe, déjà limitée par la bande passante mémoire, souffre de la charge supplémentaire de recharger constamment la balance, ainsi que de sauvegarder et de récupérer les fonctions d'activation.  Cela ralentit considérablement le temps d'entraînement et augmente considérablement la consommation d'énergie. <br><br>  Il existe plusieurs solutions à ce problème.  Tout d'abord, des opérations telles que les fonctions d'activation peuvent être effectuées «sur place», ce qui vous permet d'écraser l'entrée directement sur la sortie.  Ainsi, la mémoire existante peut être réutilisée.  Deuxièmement, l'opportunité de réutilisation de la mémoire peut être obtenue en analysant la dépendance des données entre les opérations sur le réseau et la répartition de la même mémoire pour les opérations qui ne l'utilisent pas à ce moment. <br><br>  La deuxième approche est particulièrement efficace lorsque l'ensemble du réseau neuronal peut être analysé au stade de la compilation afin de créer une mémoire allouée fixe, car les coûts de gestion de la mémoire sont réduits à presque zéro.  Il s'est avéré qu'une combinaison de ces méthodes réduit l'utilisation de la mémoire du réseau neuronal de deux à trois fois. <br>  Une troisième approche significative a été récemment découverte par l'équipe Baidu Deep Speech.  Ils ont appliqué diverses méthodes d'économie de mémoire pour obtenir une réduction de 16 fois de la consommation de mémoire par les fonctions d'activation, ce qui leur a permis de former des réseaux avec 100 couches.  Auparavant, avec la même quantité de mémoire, ils pouvaient former des réseaux à neuf couches. <br><br>  La combinaison de la mémoire et des ressources de traitement dans un seul appareil a un potentiel important pour augmenter la productivité et l'efficacité des réseaux de neurones convolutifs, ainsi que d'autres formes d'apprentissage automatique.  Vous pouvez faire un compromis entre la mémoire et les ressources informatiques afin d'équilibrer les capacités et les performances du système. <br><br>  Les réseaux de neurones et les modèles de connaissances dans d'autres méthodes d'apprentissage automatique peuvent être considérés comme des graphiques mathématiques.  Dans ces graphiques, une énorme quantité de parallélisme est concentrée.  Un processeur parallèle conçu pour utiliser la concurrence dans les graphiques ne repose pas sur un mini-lot et peut réduire considérablement la quantité de stockage local requise. <br><br>  Les résultats de la recherche moderne ont montré que toutes ces méthodes peuvent améliorer considérablement les performances des réseaux de neurones.  Les graphiques modernes et les unités centrales de traitement ont une mémoire interne très limitée, seulement quelques mégaoctets au total.  De nouvelles architectures de processeur spécialement conçues pour l'apprentissage automatique offrent un équilibre entre la mémoire et l'informatique sur puce, offrant une augmentation significative des performances et de l'efficacité par rapport aux unités centrales de traitement modernes et aux accélérateurs graphiques. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr402641/">https://habr.com/ru/post/fr402641/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr402629/index.html">Mes petits relais: l'ordinateur Brainfuck est magique</a></li>
<li><a href="../fr402631/index.html">Quel moniteur de fréquence cardiaque choisir pour la nouvelle saison: des solutions de compromis entre trois et quatre mille roubles</a></li>
<li><a href="../fr402633/index.html">Le conte de Battlefield 1 en Full HD sur les graphismes intégrés dans le processeur et l'assemblage de la console pour "impérissable"</a></li>
<li><a href="../fr402637/index.html">Un étudiant de 17 ans corrige une erreur de la NASA</a></li>
<li><a href="../fr402639/index.html">Peter Watts à propos de SOMA</a></li>
<li><a href="../fr402643/index.html">"Monde mince." Chapitre 10</a></li>
<li><a href="../fr402645/index.html">En utilisant le programme ServoStudio 12 et la carte Arduino, vous pouvez créer votre propre robot sans écrire une seule ligne de code</a></li>
<li><a href="../fr402649/index.html">Les plus précis au monde: les cardiofréquencemètres Valencell pour Jabra, Suunto, Atlas, Sony et autres</a></li>
<li><a href="../fr402651/index.html">Implant en polyéthylène de très haut poids moléculaire ayant remplacé le tissu osseux ou le polymère de fer</a></li>
<li><a href="../fr402653/index.html">Les motos ont des problèmes avec les cyclistes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>