<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•© üôÜüèø üë®üèº‚Äçüé§ Cara mempercepat kerja dengan R-language API menggunakan komputasi paralel, menggunakan contoh Yandex.Direct API (Bagian 2) üöà üí¨ ‚ñ´Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel terakhir , saya berbicara tentang apa itu multithreading dan memberikan contoh penerapannya dalam bahasa R ketika bekerja dengan Yandex.D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara mempercepat kerja dengan R-language API menggunakan komputasi paralel, menggunakan contoh Yandex.Direct API (Bagian 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448404/"><p> Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> terakhir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> saya berbicara tentang apa itu multithreading dan memberikan contoh penerapannya dalam bahasa R ketika bekerja dengan Yandex.Direct API menggunakan <code>doSNOW</code> , <code>doParallel</code> dan konstruksi <code>foreach</code> . </p><br><p>  Artikel ini merupakan kelanjutan, tetapi dapat dianggap sebagai panduan offline untuk multithreading di R. Saya diminta untuk menulisnya dengan komentar yang diterima di bagian pertama (di sini terima kasih khusus kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Alexey_mosc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">SatCat</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Ananiev_Genrih</a> ), di mana saya diberi sejumlah paket yang mewakili pendekatan yang lebih modern untuk implementasi multithreading di R, kita akan membicarakannya nanti. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/302/1a1/570/3021a15709dae984b328e3af5364d1de.png" alt="Multithreading"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Isi </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tantangan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Persiapan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh solusi pemrosesan serial, fungsi sapply dan paket purrr</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi safly</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paket Purrr</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Opsi multithreaded untuk menyelesaikan tugas mengumpulkan kata kunci dari Yandex.Direct</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paket paralel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paket masa depan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembungkus masa depan</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paket Future.apply</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paket Furrr</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes kecepatan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> </li><li>  Polling </li></ul><br><h1 id="zadacha">  Tantangan </h1><br><p>  Sebagai contoh, kami mengambil masalah yang dipertimbangkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi sebelumnya</a> , yaitu  dalam mode multi-utas, kumpulkan daftar kata kunci dari 4 akun iklan Yandex.Direct. </p><br><p>  Untuk bekerja dengan Yandex.Direct API, kami akan menggunakan paket <code>ryandexdirect</code> .  Dokumentasi resmi untuk itu ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> , tetapi untuk implementasi tugas yang dijelaskan, kita hanya perlu 2 fungsi: </p><br><ul><li>  <code>yadirAuth</code> - otorisasi di Yandex.Direct API; </li><li>  <code>yadirGetKeyWords</code> - Unduh daftar kata kunci dari akun iklan. </li></ul><br><p>  Bukan saja saya memilih proses mengunduh kata kunci, faktanya adalah ini adalah salah satu operasi yang paling panjang di Yandex.Direct API.  Kedua, di semua akun jumlah kata kunci berbeda, oleh karena itu, waktu untuk menyelesaikan operasi ini untuk setiap akun akan sangat berbeda, dalam kasus kami dari 1 hingga 20 detik. </p><br><h1 id="podgotovka">  Persiapan </h1><br><p>  Awalnya, Anda perlu menginstal semua paket yang dibahas dalam artikel ini, untuk ini Anda dapat menggunakan kode di bawah ini. </p><br><div class="spoiler">  <b class="spoiler_title">Kode 1: Instalasi Paket</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#    install.packages("ryandexdirect") install.packages("tictoc") install.packages("rbenchmark") install.packages("dplyr") install.packages("purrr") install.packages("future") install.packages("promises") install.packages("furrr") install.packages("future.apply")</code> </pre> </div></div><br><p>  Agar fungsi-fungsi paket tersedia untuk Anda, Anda harus menghubungkannya menggunakan perintah <code>library</code> .  Untuk kenyamanan, saya akan secara terpisah menghubungkan semua paket yang diperlukan dalam setiap contoh kode yang diberikan. </p><br><p>  Kami membuat vektor yang terdiri dari login Yandex.Direct, dari mana nanti kami akan meminta kata kunci: </p><br><div class="spoiler">  <b class="spoiler_title">Kode 2: Membuat Vektor Login</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">logins &lt;- c("login1", "login2", "login3", "login4")</code> </pre> </div></div><br><p>  Untuk bekerja dengan Yandex.Direct API, Anda harus terlebih dahulu melalui otorisasi di bawah setiap akun, untuk ini Anda dapat menggunakan desain berikut: </p><br><div class="spoiler">  <b class="spoiler_title">Kode 3: Otorisasi di Yandex.Direct API</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">lapply(logins, function(l) { yadirAuth(Login = l)})</code> </pre> </div></div><br><p>  Setelah menjalankan kode di atas, browser akan terbuka untuk otorisasi di bawah setiap akun.  Anda mengonfirmasi izin untuk <code>ryandexdirect</code> untuk mengakses materi iklan Anda.  Anda akan diarahkan ke halaman tempat Anda perlu menyalin kode verifikasi.  Dengan memasukkannya ke konsol R, selesaikan proses otorisasi.  Operasi ini diulangi untuk setiap login yang Anda tentukan saat membuat login vektor. </p><br><p>  Beberapa pengguna, selama proses otorisasi, mungkin bingung dengan fakta pengalihan ke sumber daya pihak ketiga, tetapi tidak ada bahaya pada akun Anda dalam hal ini, saya menjelaskan topik ini secara lebih rinci dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Seberapa Aman Menggunakan Paket R untuk Bekerja dengan API Sistem Periklanan"</a> . </p><br><p>  Selanjutnya, kami akan mempertimbangkan beberapa contoh implementasi tugas yang dijelaskan.  Masing-masing akan dimulai dengan kode contoh, dan penjelasan selanjutnya.  Saya pikir opsi ini akan paling nyaman untuk persepsi. </p><br><h1 id="primer-resheniya-v-posledovatelnom-rezhime-obrabotki-funkciya-sapply-i-paket-purrr">  Contoh solusi pemrosesan serial, fungsi sapply dan paket purrr </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/369/72e/9d8/36972e9d8707c1c508d2e43b8721778c.jpg"><br>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terakhir</a> , saya mengutip solusi menggunakan <code>for</code> sebagai contoh.  Karena kami menganggap multithreading menggunakan paket <code>foreach</code> , yang sintaksisnya menyerupai loop, contoh ini sesuai di sana, meskipun penggunaan loop tidak disambut oleh pengguna R. </p><br><p>  Paket-paket yang akan kita bahas dalam artikel ini lebih mengingatkan pada fungsi-fungsi keluarga yang berlaku dalam sintaksis, oleh karena itu, saya akan memberikan contoh solusi dalam mode serial menggunakannya. </p><br><h3 id="funkciya-sapply">  Fungsi <code>sapply</code> </h3><br><blockquote>  Untuk memperkirakan waktu eksekusi perintah, dalam setiap pendekatan yang dipertimbangkan, kami akan menggunakan paket <code>tictoc</code> . </blockquote><br><div class="spoiler">  <b class="spoiler_title">Kode 4: Contoh solusi dalam mode berurutan menggunakan fungsi sapply</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(tictoc) library(dplyr) tic() #   kw.sapply &lt;- sapply( logins, #  ,     function(x) #        #     { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE #     ) toc() #   #       result.sapply &lt;- do.call("rbind", kw.sapply)</code> </pre> </div></div><br><p>  Waktu <code>39.36 sec elapsed</code> : <code>39.36 sec elapsed</code> </p><br><p>  Pada awalnya, sintaks fungsi dari keluarga yang <code>apply</code> tidak semudah dibaca sebagai sintaks dari loop, tetapi pada kenyataannya semuanya cukup sederhana. </p><br><p> <code>sapply(X, FUN)</code> </p> <br><p>  Dimana: </p><br><ul><li>  <em>X</em> - Objek yang elemen-elemennya akan kita iterate dan gunakan secara bergantian pada setiap iterasi, dalam <code>for</code> loop terlihat seperti ini: <code>for(i in X)</code> ; </li><li>  <em>FUN</em> - Fungsi di mana kita akan mengganti setiap elemen dari objek <em>X</em> secara bergantian, jika kita menggambar analogi dengan <code>for</code> , maka ini adalah tubuh loop. </li></ul><br><p>  Dalam Contoh <strong>Kode 4</strong> , vektor <em>login yang</em> dibuat sebelumnya diteruskan ke argumen <em>X.</em>  Setiap elemen vektor <em>login</em> diteruskan sebagai satu-satunya argumen ke fungsi <code>function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }</code> anonim <code>function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }</code> yang diteruskan ke argumen <em>FUN</em> . </p><br><p>  Yaitu  <code>sapply</code> akan menjalankan fungsi yang ditentukan dalam <em>FUN</em> 4 kali, mengganti loginnya satu per satu, dan mengembalikan hasilnya dalam bentuk daftar (objek <em>daftar</em> kelas) yang terdiri dari 4 elemen.  Setiap elemen adalah tabel dengan daftar kata kunci yang diterima dari akun pada setiap iterasi. </p><br><ol><li> <code>yadirGetKeyWords(Login = "login1") %&gt;% mutate(login = "login1")</code> </li> <li> <code>yadirGetKeyWords(Login = "login2") %&gt;% mutate(login = "login2")</code> </li> <li> <code>yadirGetKeyWords(Login = "login3") %&gt;% mutate(login = "login3")</code> </li> <li> <code>yadirGetKeyWords(Login = "login4") %&gt;% mutate(login = "login4")</code> </li> </ol><br><p>  Objek yang diperoleh menggunakan <code>sapply</code> memiliki struktur sebagai berikut: </p><br><pre> <code class="plaintext hljs">summary(kw.sapply)</code> </pre> <br><pre> <code class="plaintext hljs"> Length Class Mode login1 19 data.frame list login2 19 data.frame list login3 19 data.frame list login4 19 data.frame list</code> </pre> <br><p>  Pada akhir contoh ini, perintah <code>result.sapply &lt;- do.call("rbind", kw.sapply)</code> menggabungkan semua 4 elemen dari daftar <em>kw.sapply</em> ke dalam satu frame <em>result.sapply</em> . </p><br><pre> <code class="plaintext hljs"># A tibble: 6,804 x 1 result.sapply$Id $Keyword $AdGroupId $CampaignId $ServingStatus $State &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; 1 15164230566 ~ 3597453985 39351725 ELIGIBLE ON 2 15164230567  ~ 3597453985 39351725 ELIGIBLE ON 3 15164230568  ~ 3597453985 39351725 ELIGIBLE ON 4 15164230569 ~ 3597453985 39351725 ELIGIBLE ON 5 15164230570 ~ 3597453985 39351725 ELIGIBLE ON 6 15164230571  ~ 3597453985 39351725 ELIGIBLE ON 7 15164230572 ~ 3597453985 39351725 ELIGIBLE ON 8 15164230573  ~ 3597453985 39351725 ELIGIBLE ON 9 15164230574 ~ 3597453985 39351725 ELIGIBLE ON 10 15164230575 ~ 3597453985 39351725 ELIGIBLE ON # ... with 6,794 more rows, and 13 more variables: $Status &lt;fct&gt;, # $StrategyPriority &lt;fct&gt;, $StatisticsSearchImpressions &lt;int&gt;, # $StatisticsSearchClicks &lt;int&gt;, $StatisticsNetworkImpressions &lt;int&gt;, # $StatisticsNetworkClicks &lt;lgl&gt;, $UserParam1 &lt;chr&gt;, $UserParam2 &lt;chr&gt;, # $ProductivityValue &lt;lgl&gt;, $ProductivityReferences &lt;lgl&gt;, $Bid &lt;dbl&gt;, # $ContextBid &lt;dbl&gt;, $login &lt;chr&gt;</code> </pre> <br><p>  Selain <code>sapply</code> , keluarga <code>*apply</code> fungsi meliputi: <code>apply</code> , <code>lapply</code> , <code>vapply</code> , <code>mapply</code> , dan lainnya. </p><br><h3 id="paket-purrr">  Paket <code>purrr</code> </h3><br><div class="spoiler">  <b class="spoiler_title">Kode 5: Contoh solusi menggunakan fungsi paket purrr</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) library(dplyr) library(tictoc) tic() #   result.purrr &lt;- map_df( logins, #  ,     ~ #   function(.x) { yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x) } ) toc() #  </code> </pre> </div></div><br><p>  Waktu <code>35.46 sec elapsed</code> : <code>35.46 sec elapsed</code> </p><br><p>  Paket <code>purrr</code> adalah bagian dari inti dari perpustakaan <code>tidyverse</code> , ditulis oleh Headley Wickham. </p><br><p>  Dalam hal makna dan sintaksis, fungsi utama dari paket sangat mirip dengan <code>sapply</code> , keuntungan utamanya adalah sebagai berikut: </p><br><ul><li>  Fungsi dibagi menjadi <code>map</code> keluarga, <code>map2</code> , <code>pmap</code> , <code>walk</code> dan sebagainya, fungsi terpisah yang termasuk dalam keluarga yang sama mengembalikan hasilnya dalam format yang berbeda: <em>chr</em> , <em>dbl</em> , <em>int</em> , <em>df</em> , dll; </li><li>  Fungsi keluarga <code>map2</code> Anda untuk <code>map2</code> elemen (iterate) secara bersamaan dari dua objek; </li><li>  Fungsi keluarga <code>pmap</code> Anda untuk secara bersamaan <code>pmap</code> ke elemen dari sejumlah objek.  Anda dapat mengirimkan tabel ke input ke argumen <em>.l</em> <em>(analog dari argumen X dengan sapply)</em> , yang masing-masing kolomnya akan berisi nilai-nilai yang Anda <em>gunakan</em> untuk mengulangi, dan yang nantinya akan diganti menjadi argumen dengan fungsi yang sama dengan yang dilewatkan <em>.f</em> <em>(analog FUN dari sapply)</em> . </li></ul><br><p>  Dalam situasi apa kita perlu mengulangi elemen dari beberapa objek.  Misalnya, Anda bekerja dengan beberapa akun agen, dan akun iklan tempat Anda ingin mendapatkan daftar kata kunci tersebar di antara mereka.  Dalam hal ini, Anda dapat membuat vektor dari nama akun agen, dan beralih di atasnya, bersamaan dengan cara Anda menyortir login akun iklan. </p><br><div class="spoiler">  <b class="spoiler_title">Kode 6: Contoh bekerja dengan banyak akun agen</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) #      agencies &lt;- c("agency1", NA, "agency2", "agency1") #      #         result.pmap2 &lt;- map2_df(.x = logins, .y = agencies, ~ { yadirGetKeyWords(Login = .x, AgencyAccount = .y) %&gt;% mutate(login = .x) })</code> </pre> </div></div><br><p>  Sekarang bayangkan situasi ketika Anda login di bawah akun yang berbeda, Anda menyimpan file dengan kredensial di folder yang berbeda, maka Anda harus segera beralih pada tiga objek: login akun iklan, login akun agen, jalur di mana file dengan kredensial disimpan.  Ini bisa dilakukan dengan bantuan.  <code>pmap</code> keluarga <code>pmap</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Kode 7: contoh fungsi pmap</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) #  ,       #      TokenPath &lt;- c("C:\\proj1\\tokens", "C:\\yandex\\token", "C:\\yandex\\token", "C:\\my_yandex_acoount") #   pmap.result &lt;- pmap_df(list(Login = logins, AgencyAccount = agencies, TokenPath = TokenPath), yadirGetKeyWords)</code> </pre> </div></div><br><p>  Dengan demikian, hasil dari mengeksekusi fungsi <code>map_df</code> , <code>map2_df</code> dan <code>pmap_df</code> adalah bingkai tanggal, dan ketika menggunakannya, langkah terakhir dari contoh dengan <code>sapply</code> ( <code>do.call("rbind", kw.sapply)</code> ) tidak diperlukan. </p><br><p>  Kode tersebut menjadi lebih ringkas dan dieksekusi sedikit lebih cepat, namun demikian, baik pendekatan yang diuraikan, <code>sapply</code> dan <code>purrr</code> , mengumpulkan kata kunci dari setiap akun secara berurutan.  Oleh karena itu, total waktu pelaksanaan operasi ini sama dengan jumlah durasi pengumpulan data dari keempat akun. </p><br><p>  <strong>Waktu [total]</strong> = <em>Waktu [login1] + Waktu [login2] + Waktu [login3] + Waktu [login4]</em> </p><br><h1 id="mnogopotochnye-varianty-resheniya-zadachi-po-sboru-klyuchevyh-slov-iz-yandeksdirekt">  Opsi multithreaded untuk menyelesaikan tugas mengumpulkan kata kunci dari Yandex.Direct </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/53c/cf5/ab353ccf566421eaaa6ec3d6445399a1.jpg"></p><br><p>  Jadi, jika Anda sudah membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama</a> , maka Anda tahu bahwa mode operasi multithreaded memiliki beberapa fitur: </p><br><ul><li>  Setiap utas dimulai dalam sesi R yang terpisah dengan lingkungan kerja yang bersih. </li><li>  Untuk alasan yang sama, dalam proses berjalan yang terpisah, paket yang terhubung sebelumnya tidak dikirimkan secara default. </li></ul><br><p>  Mengekspor objek yang dibuat dalam lingkungan kerja, dan menghubungkan paket dalam setiap pendekatan diimplementasikan secara berbeda, maka kami akan mempertimbangkannya secara lebih rinci. </p><br><h3 id="paket-parallel">  Paket <code>parallel</code> </h3><br><p>  Paket ini pertama kali dimasukkan dalam paket R dalam versi 2.14.0 dan hingga hari ini hadir dengan R itu sendiri. </p><br><div class="spoiler">  <b class="spoiler_title">Kode 8: Contoh solusi untuk masalah melalui paket paralel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(parallel) library(tictoc) #   cl &lt;- makeCluster(4) #      clusterExport(cl = cl, varlist = "logins") #  ,      #  ,       ryandexdirect clusterEvalQ(cl = cl, { library(ryandexdirect) library(dplyr) } ) tic() #   parallel.kw &lt;- parSapplyLB(cl = cl, #   X = logins, # ,     FUN = function(x) { #      #      X yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = F) #    toc() #     #   stopCluster(cl) #      result.parallel &lt;- dplyr::bind_rows(parallel.kw)</code> </pre> </div></div><br><p>  <code>16.75 sec elapsed</code> Time: <code>16.75 sec elapsed</code> </p><br><p>  Mari kita coba menguraikan <strong>Kode 8</strong> .  Fungsi <code>makeCluster</code> membuat sekelompok 4 proses.  Kita dapat mengekspor objek dari lingkungan kerja utama kita ke cluster yang dibuat menggunakan fungsi <code>clusterExport</code> , untuk ini kita perlu menggunakan argumennya: </p><br><ul><li>  <em>cl</em> - Cluster dimana kita akan mengekspor objek </li><li>  <em>varlist</em> - Vektor teks yang berisi nama-nama objek yang akan diekspor ke setiap proses cluster. </li></ul><br><p>  Salah satu cara untuk menghubungkan paket yang tepat pada setiap node cluster adalah dengan menggunakan fungsi <code>clusterEvalQ</code> .  Dalam contoh kami, kami menggunakannya untuk menghubungkan paket, tetapi Anda dapat menulis kode R apa pun di dalam <code>clusterEvalQ</code> , dan itu akan diluncurkan pada awal setiap node cluster.  Argumen untuk fungsi ini cukup jelas, Anda perlu menentukan cluster dan perintah yang akan dieksekusi di dalamnya. </p><br><p>  <code>parSapplyLB</code> adalah versi paralel dari fungsi <code>sapply</code> dengan load balancing antara node cluster, mereka juga menggunakannya, tetapi Anda perlu menentukan cluster dengan argumen <em>cl</em> . </p><br><p>  Juga secara <code>parallel</code> ada versi paralel lain dari <code>*apply</code> fungsi keluarga: <code>parLapply</code> , <code>parSapply</code> , <code>parApply</code> , dll. </p><br><p>  <code>parSapply</code> berbeda dari <code>parSapplyLB</code> hanya karena <code>parSapplyLB</code> tidak memiliki load balancing pada node cluster. </p><br><p>  Fungsi <code>stopCluster</code> digunakan untuk menghentikan cluster yang dibuat. </p><br><p>  Perintah terakhir, <code>dplyr::bind_rows(parallel.kw)</code> kami menggabungkan objek <em>parallel.kw yang</em> diperoleh dengan menggunakan <code>parSapplyLB</code> menjadi satu tabel. </p><br><p>  Untuk Linux, <code>parallel</code> memiliki fungsi terpisah: <code>mclapply</code> , <code>mcmapply</code> , <code>mcMap</code> .  Seringkali dalam sistem operasi ini, perintah dieksekusi lebih cepat, dan kode menjadi lebih kompak. </p><br><div class="spoiler">  <b class="spoiler_title">Kode 9: Solusi menggunakan mclapply untuk Linux</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(parallel) library(tictic) library(dplyr) library(ryandexdirect) tic() mclapply.kw &lt;- mclapply(logins, FUN = function(x) { #      #      X yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, mc.cores = 4) toc()</code> </pre> </div></div><br><p>  Saat menggunakan fungsi-fungsi ini, tidak perlu memulai cluster menggunakan <code>makeCluster</code> .  jumlah node yang Anda <em>tentukan</em> menggunakan argumen <em>mc.cores</em> .  Juga tidak perlu menghubungkan paket dan mengekspor objek, operasi ini dilakukan secara otomatis. </p><br><h3 id="paket-future">  Paket <code>future</code> </h3><br><p>  Salah satu pendekatan paling modern untuk pemrograman asinkron dalam R. </p><br><p>  Kode yang secara paralel akan menyelesaikan masalah kita dengan bantuan <code>future</code> cukup rumit untuk dipahami.  Karena itu, mari kita menganalisis kerjanya pada contoh yang lebih sederhana, kami akan meminta daftar kata kunci dari satu akun. </p><br><div class="spoiler">  <b class="spoiler_title">Kode 10: Contoh paling sederhana untuk menggunakan paket yang akan datang</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) #    plan(multiprocess) #      #    future.kw &lt;- future({yadirGetKeyWords(Login = logins[4])}, packages = "ryandexdirect", globals = "logins") #     resolved(future.kw) #     future.result.1 &lt;- value(future.kw)</code> </pre> </div></div><br><p>  Mari kita coba mencari tahu contoh <strong>kode 10</strong> .  Fungsi <code>plan</code> memungkinkan Anda untuk mengatur dan mengubah mode eksekusi dari ekspresi yang diberikan, berikut adalah yang utama: </p><br><ul><li>  <em>sequential</em> - Ini adalah mode operasi R yang biasa; perintah dieksekusi berurutan di sesi saat ini; </li><li>  <em>multisession</em> - Mode paralel, perintah akan dieksekusi dalam sesi berjalan di latar belakang pada mesin saat ini, sementara sesi kerja Anda tidak akan diblokir; </li><li>  <em>cluster</em> - Mode paralel, perintah akan dieksekusi pada mesin saat ini atau jarak jauh, mirip dengan bagaimana itu diterapkan dalam paket <code>parallel</code> . </li></ul><br><p>  Seluruh paket <code>future</code> didasarkan pada mengeksekusi perintah dalam proses latar belakang tanpa memblokir sesi saat ini.  Jalankan eksekusi perintah mengikuti fungsi nama yang sama di <code>future</code> , jadi ketika kita menjalankan perintah: </p><br><pre> <code class="plaintext hljs">future({yadirGetKeyWords(Login = logins[4])}, packages = "ryandexdirect", globals = "logins")</code> </pre> <br><p>  Sesi kami saat ini di R tidak diblokir, dan perintah dijalankan di latar belakang, menjalankan sesi R lainnya. </p><br><p>  Anda dapat memeriksa status saat ini dari proses eksekusi dari ekspresi yang diberikan menggunakan fungsi yang <code>resolved</code> .  Akhirnya, fungsi <code>value</code> digunakan untuk mendapatkan hasil eksekusi di <code>future</code> .  Jika Anda menjalankan fungsi <code>value</code> lebih awal dari menjalankan <code>future</code> Anda dalam sesi berjalan paralel, maka sesi kerja saat ini akan diblokir sampai ekspresi sesi paralel selesai. </p><br><p>  Contoh pekerjaan yang paling maju adalah penggunaan <code>future</code> hubungannya dengan <code>promises</code> - <code>promises</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Kode 11: Contoh berbagi paket `masa depan` dan` janji`</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) library(promises) #    plan(multiprocess) #      #    future.kw &lt;- future({suppressMessages( yadirGetKeyWords(Login = logins[4]))}, packages = "ryandexdirect", globals = "logins") %...&gt;% #     future, #      nrow() %...&gt;% paste("words loaded") %...&gt;% print()</code> </pre> </div></div><br><p>  Paket <code>promises</code> memberikan satu set operator pipa yang sempurna melengkapi fungsionalitas <code>future</code> . </p><br><p>  Pada contoh <strong>Kode 11</strong> , di latar belakang, kami memulai proses mengunduh kata kunci dari satu akun iklan.  Selanjutnya, operator pipa <code>%...&gt;%</code> tanpa memblokir sesi kerja menunggu <code>future</code> , dan melakukan operasi yang tersisa.  Sebagai hasil dari eksekusi kode, setelah menyelesaikan pekerjaan di <code>future</code> , jumlah kata kunci dari akun yang ditentukan akan ditampilkan di konsol: </p><br><pre> <code class="plaintext hljs">[1] "1855 words loaded"</code> </pre> <br><blockquote>  Di akhir artikel, contoh yang lebih ilustratif tentang sekelompok <code>future</code> dan <code>promises</code> akan ditunjukkan. </blockquote><p>  Secara default, paket yang <code>future</code> itu sendiri mengekspor seluruh ruang kerja ke setiap sesi berjalan paralel, tetapi Anda sendiri dapat menentukan daftar objek untuk diekspor menggunakan argumen <em>global</em> . </p><br><p>  Untuk menghubungkan paket ke <code>future</code> harus melewati vektor yang berisi nama mereka ke argumen <em>paket</em> . </p><br><p>  Sekarang kembali ke tugas kita, contoh kode berikut dalam mode paralel akan memuat daftar kata kunci dari 4 akun: </p><br><div class="spoiler">  <b class="spoiler_title">Kode 12: Contoh pemecahan masalah dengan menggunakan paket yang akan datang</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) library(tictoc) #   plan("multisession", workers = 4) tic() #   futs &lt;- lapply(logins, #      function(i) #        #   future({ yadirGetKeyWords(Login = i) %&gt;% mutate(login = i) }, packages = c("ryandexdirect", "dplyr"))) completed &lt;- sapply(futs, resolved) #    kw &lt;- lapply(futs, value) #    toc() #    #     result.future &lt;- dplyr::bind_rows(kw)</code> </pre> </div></div><br><p>  Waktu Pimpin: <code>14.83 sec elapsed</code> </p><br><p>  Untuk mengunduh daftar kata kunci dalam mode multi-utas dari semua akun iklan yang tercantum dalam <em>login</em> vektor <em>,</em> Anda harus menjalankan <code>future</code> terpisah di latar belakang.  Dalam Contoh <strong>Kode 12,</strong> kami menerapkan ini menggunakan fungsi <code>lapply</code> . </p><br><p>  Hasil dari kerja <code>lapply</code> adalah daftar peluncuran di <code>future</code> .  Anda dapat memeriksa status masing-masing menggunakan perintah <code>sapply(futs, resolved)</code> , yang akan mengembalikan vektor logis tempat <em>TRUE</em> akan berarti <code>future</code> terpenuhi, dan <em>SALAH</em> bahwa <code>future</code> sedang berlangsung. </p><br><p>  Untuk mendapatkan hasil dari setiap <code>future</code> , setelah pekerjaan mereka selesai, kami menggunakan perintah <code>lapply(futs, value)</code> . </p><br><p>          : <code>result.future &lt;- dplyr::bind_rows(kw)</code> . </p><br><h3 id="obyortki-nad-future">   <code>future</code> </h3><br><p>      ,      (   <br> <code>future</code> ),      . </p><br><h6 id="paket-futureapply">  <code>future.apply</code> </h6><br><p> <code>future.apply</code>     <code>future</code> ,  . </p><br><div class="spoiler"> <b class="spoiler_title"> 13:       future.apply</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future.apply) library(tictoc) #    plan("multisession", workers = 4) tic() #   kw.future.apply &lt;- future_sapply(logins, #    ,   function(x) { #     yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE, #    #   future.packages = c("ryandexdirect", "dplyr"), future.globals = TRUE ) toc() #   </code> </pre> </div></div><br><p>  : <code>17.28 sec elapsed</code> </p><br><p>   <strong> 13</strong> ,  <code>future.apply</code>         <code>future</code> ,         . </p><br><p>         4 : <code>plan("multisession", workers = 4)</code> . </p><br><p> <code>future_sapply</code>      <em>logins</em>    .  Yaitu   ,  ,        <code>sapply</code> ,    . </p><br><p>      <code>future_sapply</code>    <em>future.packages</em> .             <em>future.globals</em> .       ,              . </p><br><h4 id="paket-furrr">  <code>furrr</code> </h4><br><p>     <code>future</code> .          <code>purrr</code> ,   <code>furrr</code>     . </p><br><div class="spoiler"> <b class="spoiler_title"> 14:      furrr</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(furrr) library(tictoc) #   cl &lt;- parallel::makeCluster(4) plan(cluster, workers = cl) tic() #   furrr.kw &lt;- future_map(logins, ~ #   function(.x) yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x), .options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())) toc() #    #      result.furrr &lt;-dplyr::bind_rows(furrr.kw)</code> </pre> </div></div><br><p>  : <code>15.45 sec elapsed</code> </p><br><p> <code>furrr</code>          <code>purrr</code> .     <code>purrr</code>  ,          . </p><br><p>           <em>.options</em> .     <em>.options</em>  <code>future_options</code>     ,         . </p><br><p>   <strong> 14</strong>    <em>packages</em>  <em>globals</em>    : </p><br><pre> <code class="plaintext hljs">.options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())</code> </pre> <br><h1 id="test-skorosti">   </h1><br><p>           <code>rbenchmark</code> . </p><br><p>    ,          <code>future</code>  <code>promises</code> .                . </p><br><p>   ,     20       4     () . </p><br><p>    = (T[1] * 20) + (T[2] * 20) + (T[N] * 20) </p><br><div class="spoiler"> <b class="spoiler_title"> 15:        future  promises</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(furrr) library(parallel) library(dplyr) library(future) library(ryandexdirect) library(tictoc) library(rbenchmark) #   logins &lt;- c("login1", "login2", "login3", "login4") #        #        par par.furrr &lt;- function(logins) { cl &lt;- parallel::makeCluster(4) plan(cluster, workers = cl) furrr.kw &lt;- future_map(logins, ~ yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x), .options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())) result.furrr &lt;-dplyr::bind_rows(furrr.kw) } par.future &lt;- function(logins) { plan("multisession", workers = 4) futs &lt;- lapply(logins, function(i) future({ yadirGetKeyWords(Login = i) %&gt;% mutate(login = i) }, packages = c("ryandexdirect", "dplyr"))) completed &lt;- sapply(futs, resolved) kw &lt;- lapply(futs, value) result.future &lt;- dplyr::bind_rows(kw) } par.future.apply &lt;- function(logins) { plan("multisession", workers = 4) kw.future.apply &lt;- future_sapply(logins, function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE, future.packages = c("ryandexdirect", "dplyr"), future.globals = TRUE ) result.future.apply &lt;- dplyr::bind_rows(kw.future.apply) } par.parallel &lt;- function(logins) { cl &lt;- parallel::makeCluster(4) clusterExport(cl = cl, varlist = "logins") clusterEvalQ(cl = cl, { library(ryandexdirect) library(dplyr) } ) parallel.kw &lt;- parSapplyLB(cl = cl, X = logins, FUN = function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = F) stopCluster(cl) result.parallel &lt;- dplyr::bind_rows(parallel.kw) } #          seq seq.apply &lt;- function(logins) { kw.sapply &lt;- sapply( logins, function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE ) result.sapply &lt;- do.call("rbind", kw.sapply) } seq.purrr &lt;- function(logins) { kw.purrr &lt;- map_df( logins, ~ { yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x) } ) result.purrr &lt;- do.call("rbind", kw.purrr) } #       rbenchmark #   future + promises #  ,       #          plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4))) tic() speed.test &lt;- future({ #          within(benchmark(furrr = par.furrr(logins), future = par.future(logins), future.apply = par.future.apply(logins), parallel = par.parallel(logins), apply = seq.apply(logins), purrr = seq.purrr(logins), replications = c(20), columns = c('test', 'replications', 'elapsed'), order = c('elapsed', 'test')), { average = round(elapsed/replications, 2) }) }, packages = c("dplyr", "ryandexdirect", "rbenchmark", "parallel", "purrr", "future", "promises", "furrr", "future.apply"), globals = c("logins", "par.furrr", "par.future", "par.future.apply", "par.parallel", "seq.apply", "seq.purrr")) %...&gt;% print() %...T&gt;% toc() message("My Session is not blocked")</code> </pre> </div></div><br><p>       3370 , ..   . </p><br><p>           .  ,               <code>future</code>   ,       <code>promises</code>    ,                  . </p><br><p>        ,       .         "My Session is not blocked",       ,       , ..      . </p><br><p>  <code>promises</code>   : </p><br><ul><li> <code>%...&gt;%</code> ‚Äî     <code>%&gt;%</code> ,     .  Yaitu   ,       <code>resolved</code> ,     <code>future</code> ,          <code>value</code>          .       ,         <code>print</code> . </li><li> <code>%...T&gt;%</code> ‚Äî  <code>%T&gt;%</code> ,  ,          .    ,          ,     , ..    ..  <code>print</code>       ,   ,    . </li><li> %...T!% ‚Äî      . </li></ul><br><p>  <strong> 15</strong>  <code>plan</code>    <code>tweak</code> ( <code>plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4)))</code> ),      ,    2 ,   <code>future</code>       4 . </p><br><p>       : </p><br><pre> <code class="plaintext hljs">My Session is not blocked test replications elapsed average 4 parallel 20 393.02 19.65 1 furrr 20 402.09 20.10 2 future 20 431.19 21.56 3 future.apply 20 432.29 21.61 5 apply 20 847.77 42.39 6 purrr 20 864.19 43.21 3370.55 sec elapsed</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/16e/906/831/16e90683145df442ca830a6758734cbe.png" alt="gambar"></p><br><p>   ,        <code>parallel</code> ,        .    <code>furrr</code> ,     <code>future</code>  <code>future.apply</code> . </p><br><p>     1 ,           ,   .         ,      API .     . </p><br><p>   ,     4        ,          . </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>               R,             API. </p><br><p>   ,     API    .              <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">" R    ,  1"</a> . </p><br><p>          : </p><br><ul><li> doSNOW / doParallel + foreach </li><li> future + promises </li><li> future.apply / furrr </li><li> parallel </li></ul><br><p>         ,   ,        . </p><br><p>         ,          R  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448404/">https://habr.com/ru/post/id448404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448392/index.html">Dua Pendekatan untuk Menyusun Bagan Kegiatan</a></li>
<li><a href="../id448394/index.html">Peluncuran Versi 12 Hari Ini! (Dan Ini Lompatan Besar untuk Bahasa Wolfram dan Mathematica)</a></li>
<li><a href="../id448396/index.html">Bersiap-siap untuk Layanan Runtime dan Notaris Hardened di macOS Mojave</a></li>
<li><a href="../id448400/index.html">Netplan dan cara memasaknya dengan benar</a></li>
<li><a href="../id448402/index.html">Migrasi sertifikat otoritas (CA) gagal dari Windows 2008R ke Windows 2012 R2</a></li>
<li><a href="../id448408/index.html">DCIM - Kunci Pengelolaan Pusat Data</a></li>
<li><a href="../id448410/index.html">Pelacak dari Google dibangun ke sejumlah sumber daya elektronik resmi Rusia</a></li>
<li><a href="../id448414/index.html">Laboratorium rumah untuk kontrol diri, atau apa yang harus dibeli dalam kit geek</a></li>
<li><a href="../id448416/index.html">Cara termudah untuk mengobrol di aplikasi iOS</a></li>
<li><a href="../id448420/index.html">Dari kehidupan dengan Kubernetes: Bagaimana server HTTP Spanyol tidak mengeluh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>