<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüöí ü§© ü•î Die ganze Wahrheit √ºber RTOS. Artikel 30. Initialisierungs- und Startverfahren f√ºr Nucleus SE üåµ üë®üèº‚Äçü§ù‚Äçüë®üèª üë©üèª‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jedes Betriebssystem verf√ºgt √ºber einen bestimmten Startmechanismus. Das Funktionsprinzip dieses Mechanismus ist f√ºr jedes System unterschiedlich. Nor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel 30. Initialisierungs- und Startverfahren f√ºr Nucleus SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460617/"><img src="https://habrastorage.org/webt/nr/me/cz/nrmeczn3tg-kdwyme6qgmd7ily4.jpeg"><br><br>  Jedes Betriebssystem verf√ºgt √ºber einen bestimmten Startmechanismus.  Das Funktionsprinzip dieses Mechanismus ist f√ºr jedes System unterschiedlich.  Normalerweise sagen sie, dass das System bootet (Eng. Boot), dies ist eine Abk√ºrzung f√ºr "Bootstrap", was sich auf den Ausdruck "sich mit den Bootstraps √ºber einen Zaun ziehen" bezieht. wie das System unabh√§ngig von einem Zustand, in dem der Speicher voller Leere ist ( <i>Anmerkung</i> des <i>√úbersetzers: wenn absolut genau, dann M√ºll</i> ), zu einer stabilen Programmausf√ºhrung √ºbergeht.  Traditionell wird ein kleiner Teil des Programms in den Speicher geladen und kann im ROM gespeichert werden.  In der Vergangenheit konnte die Eingabe √ºber die Schalter an der Vorderseite des Computers erfolgen.  Dieser Bootloader hat ein komplexeres Bootprogramm gelesen, das das Betriebssystem bereits geladen hat.  Heute startet der Desktop-Computer wie folgt: Der BIOS-Code sucht nach Ger√§ten (Festplatten, CD-ROMs, USB-Sticks), von denen Sie booten k√∂nnen, und anschlie√üend startet das Betriebssystem. <br><br>  Auf √§hnliche Weise kann auch das Betriebssystem f√ºr eingebettete Systeme initialisiert werden.  Tats√§chlich werden eingebettete Betriebssysteme geladen, die auf der Basis von Desktop-Betriebssystemen entwickelt wurden.  In den meisten "klassischen" RTOS wird jedoch eine viel einfachere (und daher schnellere) Methode verwendet. <br><a name="habracut"></a><br>  Das Betriebssystem ist Teil der Software.  Wenn sich diese Software bereits im Speicher befindet (z. B. in der einen oder anderen Form des ROM), m√ºssen Sie nur sicherstellen, dass die Folge der CPU-Befehle nach dem Zur√ºcksetzen mit der Ausf√ºhrung des Betriebssysteminitialisierungscodes endet.  So funktionieren die meisten RTOS, einschlie√ülich Nucleus SE ( <i>Anmerkung des √úbersetzers: Dies gilt auch f√ºr unser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS MAX</a></i> ). <br><br>  Die meisten eingebetteten Softwareentwicklungstools enthalten den erforderlichen Startcode f√ºr das Zur√ºcksetzen der CPU und die √úbertragung der Steuerung an die Entry Point-Funktion in der <b>main ()</b> -Funktion.  Der weiterverteilbare Nucleus SE-Code behandelt diesen Prozess nicht, da er so portabel wie m√∂glich sein muss.  Stattdessen enth√§lt es die Funktion <b>main ()</b> , die die Steuerung der CPU √ºbernimmt und das Betriebssystem initialisiert und startet.  Diese Funktion wird nachstehend ausf√ºhrlich erl√§utert. <br><br><div class="spoiler">  <b class="spoiler_title">Fr√ºhere Artikel in der Reihe:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 29.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterbrechungen in Nucleus SE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Software-Timer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemzeit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kan√§le: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenkan√§le: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterst√ºtzte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen f√ºr die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einf√ºhrung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <br></div></div><br><h3>  Speicherinitialisierung </h3><br>  Deklarationen aller statischen Variablen im Nucleus SE-Code beginnen mit dem <b>ROM-</b> oder <b>RAM-</b> Pr√§fix, um anzugeben, wo sie sich befinden sollen.  Diese beiden Direktiven <b>#define</b> sind in der Datei <b>nuse_types.h</b> definiert und m√ºssen unter Ber√ºcksichtigung der Besonderheiten der verwendeten Entwicklungstools (Compiler und Linker) konfiguriert werden.  Normalerweise sollte das <b>ROM</b> vom Typ <b>const sein</b> ( <i>Anmerkung</i> des <i>√úbersetzers: <b>Nach</b> meiner Erfahrung ist <b>const</b> nicht immer genug, <b>statisch</b> ist besser</i> ) und <b>RAM</b> ist ein leerer Wert. <br><br>  Alle <b>ROM-</b> Variablen werden statisch initialisiert, was logisch ist.  <b>RAM-</b> Variablen werden nicht statisch initialisiert (da dies nur mit bestimmten Toolboxen funktioniert, die so konfiguriert sind, dass sie automatisch vom ROM in den RAM kopieren).  Ein expliziter Initialisierungscode ist in der Anwendung enthalten und wird nachstehend ausf√ºhrlich beschrieben. <br><br>  Nucleus SE speichert keine ‚Äûkonstanten‚Äú Daten im RAM, was in kleinen Systemen normalerweise Mangelware ist.  Anstatt komplexe Datenstrukturen zur Beschreibung von Kernelobjekten zu verwenden, werden Tabellens√§tze (Arrays) verwendet, die je nach Bedarf leicht in ROM oder RAM abgelegt werden k√∂nnen. <br><br><h2>  Main () Funktion </h2><br>  Das Folgende ist der vollst√§ndige Code f√ºr die <b>main () -</b> Funktion von Nucleus SE: <br><br><pre><code class="plaintext hljs">void main(void) { NUSE_Init(); /* initialize kernel data */ /* user initialization code here */ NUSE_Scheduler(); /* start tasks */ }</code> </pre> <br>  Die Reihenfolge der Operationen ist recht einfach: <br><br><ul><li>  Zun√§chst wird die Funktion <b>NUSE_Init () aufgerufen</b> .  Es initialisiert alle Nucleus SE-Datenstrukturen und wird nachstehend ausf√ºhrlich beschrieben. </li><li>  Anschlie√üend kann der Benutzer einen beliebigen Anwendungsinitialisierungscode einf√ºgen, der ausgef√ºhrt wird, bevor der Taskplaner gestartet wird.  Weitere Informationen dar√ºber, was mit diesem Code erreicht werden kann, finden Sie weiter unten in diesem Artikel. </li><li>  Schlie√ülich wird der Nucleus SE-Scheduler ( <b>NUSE_Scheduler ()</b> ) <b>gestartet</b> .  Dies wird sp√§ter in diesem Artikel ebenfalls ausf√ºhrlich erl√§utert. </li></ul><br><h2>  NUSE_Init () Funktion </h2><br>  Diese Funktion initialisiert alle Nucleus SE-Kernelvariablen und Datenstrukturen. <br><br><div class="spoiler">  <b class="spoiler_title">Unten finden Sie den vollst√§ndigen Funktionscode:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void NUSE_Init(void) { U8 index; /* global data */ NUSE_Task_Active = 0; NUSE_Task_State = NUSE_STARTUP_CONTEXT; #if NUSE_SYSTEM_TIME_SUPPORT NUSE_Tick_Clock = 0; #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER NUSE_Time_Slice_Ticks = NUSE_TIME_SLICE_TICKS; #endif /* tasks */ #if ((NUSE_SCHEDULER_TYPE != NUSE_RUN_TO_COMPLETION_SCHEDULER) || NUSE_SIGNAL_SUPPORT || NUSE_TASK_SLEEP || NUSE_SUSPEND_ENABLE || NUSE_SCHEDULE_COUNT_SUPPORT) for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { NUSE_Init_Task(index); } #endif /* partition pools */ #if NUSE_PARTITION_POOL_NUMBER != 0 for (index=0; index&lt;NUSE_PARTITION_POOL_NUMBER; index++) { NUSE_Init_Partition_Pool(index); } #endif /* mailboxes */ #if NUSE_MAILBOX_NUMBER != 0 for (index=0; index&lt;NUSE_MAILBOX_NUMBER; index++) { NUSE_Init_Mailbox(index); } #endif /* queues */ #if NUSE_QUEUE_NUMBER != 0 for (index=0; index&lt;NUSE_QUEUE_NUMBER; index++) { NUSE_Init_Queue(index); } #endif /* pipes */ #if NUSE_PIPE_NUMBER != 0 for (index=0; index&lt;NUSE_PIPE_NUMBER; index++) { NUSE_Init_Pipe(index); } #endif /* semaphores */ #if NUSE_SEMAPHORE_NUMBER != 0 for (index=0; index&lt;NUSE_SEMAPHORE_NUMBER; index++) { NUSE_Init_Semaphore(index); } #endif /* event groups */ #if NUSE_EVENT_GROUP_NUMBER != 0 for (index=0; index&lt;NUSE_EVENT_GROUP_NUMBER; index++) { NUSE_Init_Event_Group(index); } #endif /* timers */ #if NUSE_TIMER_NUMBER != 0 for (index=0; index&lt;NUSE_TIMER_NUMBER; index++) { NUSE_Init_Timer(index); } #endif }</code> </pre><br></div></div><br>  Zun√§chst werden globale Variablen initialisiert: <br><ul><li>  <b>NUSE_Task_Active</b> - Index der aktiven Aufgabe, initialisiert auf Null;  sp√§ter kann dies den Scheduler √§ndern. </li><li>  <b>NUSE_Task_State</b> - wird mit dem Wert <b>NUSE_STARTUP_CONTEXT</b> initialisiert, wodurch die Funktionalit√§t der API f√ºr jeden nachfolgenden Anwendungsinitialisierungscode eingeschr√§nkt wird. </li><li>  Wenn die Systemzeitunterst√ºtzung aktiviert ist, wird <b>NUSE_Tick_Clock</b> auf Null gesetzt. </li><li>  Wenn der Time Slice Scheduler aktiviert ist, wird <b>NUSE_Time_Slice_Ticks</b> der konfigurierte Wert <b>NUSE_TIME_SLICE_TICKS zugewiesen</b> . </li></ul><br>  Dann werden die Funktionen aufgerufen, um die Kernelobjekte zu initialisieren: <br><br><ul><li>  <b>NUSE_Init_Task ()</b> wird aufgerufen, um die Datenstrukturen jeder Aufgabe zu initialisieren.  Dieser Aufruf wird nur √ºbersprungen, wenn der Scheduler "Run to Completion" verwendet wird und die Signale, die Taskpause und der Planungsz√§hler nicht konfiguriert sind (da diese Funktionskombination dazu f√ºhrt, dass diese Taskstrukturen im RAM nicht vorhanden sind, wird keine Initialisierung durchgef√ºhrt). </li><li>  <b>NUSE_Init_Partition_Pool ()</b> wird aufgerufen, um jedes Partitionspoolobjekt zu initialisieren.  Diese Aufrufe werden √ºbersprungen, wenn keine Partitionspools konfiguriert sind. </li><li>  <b>NUSE_Init_Mailbox ()</b> wird aufgerufen, um jedes Postfachobjekt zu initialisieren.  Diese Anrufe werden √ºbersprungen, wenn keine Postf√§cher konfiguriert sind. </li><li>  <b>NUSE_Init_Queue ()</b> wird aufgerufen, um jedes Warteschlangenobjekt zu initialisieren.  Diese Anrufe werden √ºbersprungen, wenn keine Warteschlangen konfiguriert sind. </li><li>  <b>NUSE_Init_Pipe ()</b> wird aufgerufen, um jedes <b>Kanalobjekt</b> zu initialisieren.  Diese Anrufe werden √ºbersprungen, wenn keine Kan√§le konfiguriert sind. </li><li>  <b>NUSE_Init_Semaphore ()</b> wird aufgerufen, um jedes Semaphorobjekt zu initialisieren.  Diese Aufrufe werden √ºbersprungen, wenn keine Semaphoren konfiguriert sind. </li><li>  <b>NUSE_Init_Event_Group ()</b> wird aufgerufen, um jedes Ereignisgruppenobjekt zu initialisieren.  Diese Aufrufe werden √ºbersprungen, wenn keine Ereignisgruppen konfiguriert sind. </li><li>  <b>NUSE_Init_Timer ()</b> wird aufgerufen, um jedes Timer-Objekt zu initialisieren.  Diese Anrufe werden √ºbersprungen, wenn keine Timer konfiguriert sind. </li></ul><br><h3>  Aufgabeninitialisierung </h3><br><div class="spoiler">  <b class="spoiler_title">Das Folgende ist der vollst√§ndige Code f√ºr die Funktion NUSE_Init_Task ():</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void NUSE_Init_Task(NUSE_TASK task) { #if NUSE_SCHEDULER_TYPE != NUSE_RUN_TO_COMPLETION_SCHEDULER NUSE_Task_Context[task][15] = /* SR */ NUSE_STATUS_REGISTER; NUSE_Task_Context[task][16] = /* PC */ NUSE_Task_Start_Address[task]; NUSE_Task_Context[task][17] = /* SP */ (U32 *)NUSE_Task_Stack_Base[task] + NUSE_Task_Stack_Size[task]; #endif #if NUSE_SIGNAL_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Signal_Flags[task] = 0; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING NUSE_Task_Timeout_Counter[task] = 0; #endif #if NUSE_SUSPEND_ENABLE || NUSE_INCLUDE_EVERYTHING #if NUSE_INITIAL_TASK_STATE_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Status[task] = NUSE_Task_Initial_State[task]; #else NUSE_Task_Status[task] = NUSE_READY; #endif #endif #if NUSE_SCHEDULE_COUNT_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Schedule_Count[task] = 0; #endif }</code> </pre><br></div></div><br>  Wenn der Run to Completion-Scheduler nicht konfiguriert wurde, wird der Kontextblock f√ºr die <b>Task NUSE_Task_Context [task] []</b> initialisiert.  Den meisten Elementen werden keine Werte zugewiesen, da sie allgemeine Maschinenregister darstellen, die beim Starten einer Aufgabe einen Zwischenwert haben sollten.  Im Beispiel (Freescale ColdFire) der Nucleus SE-Implementierung (bei anderen Prozessoren ist der Mechanismus jedoch √§hnlich) werden die letzten drei Eintr√§ge explizit festgelegt: <br><br><ul><li>  <b>NUSE_Task_Context [task] [15]</b> enth√§lt das Statusregister ( <b>SR</b> , Statusregister) und hat den Wert der Anweisung <b>#define NUSE_STATUS_REGISTER</b> . </li><li>  <b>NUSE_Task_Context [Aufgabe] [16]</b> enth√§lt den Programmz√§hler ( <b>PC</b> , Programmz√§hler) und hat den Adresswert des Eingabepunkts des Aufgabencodes: <b>NUSE_Task_Start_Address [Aufgabe]</b> . </li><li>  <b>NUSE_Task_Context [Aufgabe] [17]</b> enth√§lt den Stapelzeiger ( <b>SP</b> , Stapelzeiger) und wird mit dem Wert initialisiert, der als Summe aus der Adresse des Aufgabenstapels ( <b>NUSE_Task_Stack_Base [Aufgabe]</b> ) und der Gr√∂√üe des Aufgabenstapels ( <b>NUSE_Task_Stack_Size [Aufgabe]</b> ) <b>berechnet wird</b> . </li></ul><br>  Wenn die Signalunterst√ºtzung aktiviert ist, werden Task-Signal-Flags ( <b>NUSE_Task_Signal_Flags [Task]</b> ) auf Null gesetzt. <br><br>  Wenn die Task-Suspendierung aktiviert ist ( <b>dh der</b> API-Serviceaufruf <b>NUSE_Task_Sleep ()</b> ), wird der Task-Timeout-Z√§hler ( <b>NUSE_Task_Timeout_Counter [Task]</b> ) auf Null gesetzt. <br><br>  Wenn der Task-Suspend-Status aktiviert ist, wird der Task-Status ( <b>NUSE_Task_Status [Task]</b> ) initialisiert.  Dieser Anfangswert wird vom Benutzer festgelegt (in <b>NUSE_Task_Initial_State [Aufgabe]</b> ), wenn die Unterst√ºtzung f√ºr den Anfangszustand der Aufgabe aktiviert ist.  Andernfalls wird der Status <b>NUSE_READY</b> zugewiesen. <br><br>  Wenn der Planungsz√§hler aktiviert ist, wird der Aufgabenz√§hler ( <b>NUSE_Task_Schedule_Count [Aufgabe]</b> ) auf Null gesetzt. <br><br><h3>  Partitionspools initialisieren </h3><br>  Das Folgende ist der vollst√§ndige Code f√ºr die Funktion <b>NUSE_Init_Partition_Pool ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Partition_Pool(NUSE_PARTITION_POOL pool) { NUSE_Partition_Pool_Partition_Used[pool] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Partition_Pool_Blocking_Count[pool] = 0; #endif }</code> </pre><br>  Der "verwendete" Partitionspoolz√§hler ( <b>NUSE_Partition_Pool__Partition_Used [Pool]</b> ) wird auf Null gesetzt. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Z√§hler f√ºr blockierte Aufgaben von Partitionspools ( <b>NUSE_Partition_Pool_Blocking_Count [Pool])</b> auf Null gesetzt. <br><br><h3>  Postf√§cher initialisieren </h3><br>  Unten finden Sie den vollst√§ndigen Code f√ºr <b>NUSE_Init_Mailbox ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Mailbox(NUSE_MAILBOX mailbox) { NUSE_Mailbox_Data[mailbox] = 0; NUSE_Mailbox_Status[mailbox] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Mailbox_Blocking_Count[mailbox] = 0; #endif }</code> </pre><br>  Der Postfachdatenspeicher ( <b>NUSE_Mailbox_Data [Postfach]</b> ) wird auf Null gesetzt, und der Status ( <b>NUSE_Mailbox_Status [Postfach]</b> ) wird "nicht verwendet" (dh Null). <br><br>  Wenn die Aufgabensperre aktiviert ist, wird der Z√§hler f√ºr blockierte Postfachaufgaben ( <b>NUSE_Mailbox_Blocking_Count [Postfach]</b> ) auf Null gesetzt. <br><br><h3>  Initialisierung der Warteschlange </h3><br>  Das Folgende ist der vollst√§ndige Code f√ºr die Funktion <b>NUSE_Init_Queue ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Queue(NUSE_QUEUE queue) { NUSE_Queue_Head[queue] = 0; NUSE_Queue_Tail[queue] = 0; NUSE_Queue_Items[queue] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Queue_Blocking_Count[queue] = 0; #endif }</code> </pre><br>  Zeiger auf den Anfang und das Ende der Warteschlange (tats√§chlich sind dies die Indizes <b>NUSE_Queue_Head [Warteschlange</b> ] und <b>NUSE_Queue_Tail [Warteschlange]</b> ) werden Werte zugewiesen, die den Beginn des Datenbereichs der Warteschlangen angeben ( <b>dh</b> einen Wert von Null annehmen).  Der Z√§hler in der Warteschlange ( <b>NUSE_Queue_Items [Warteschlange]</b> ) wird ebenfalls auf Null gesetzt. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Z√§hler f√ºr blockierte Warteschlangen-Tasks ( <b>NUSE_Queue_Blocking_Count [Warteschlange]</b> ) auf Null gesetzt. <br><br><h3>  Kanalinitialisierung </h3><br>  Das Folgende ist der vollst√§ndige Code f√ºr die Funktion <b>NUSE_Init_Pipe ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Pipe(NUSE_PIPE pipe) { NUSE_Pipe_Head[pipe] = 0; NUSE_Pipe_Tail[pipe] = 0; NUSE_Pipe_Items[pipe] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Pipe_Blocking_Count[pipe] = 0; #endif }</code> </pre><br>  Zeigern auf den Anfang und das Ende des Kanals (tats√§chlich sind dies die Indizes - <b>NUSE_Pipe_Head [Pipe]</b> und <b>NUSE_Pipe_Tail [Pipe]</b> ) wird ein Wert zugewiesen, der den Beginn des <b>Kanaldatenbereichs angibt (dh</b> einen Nullwert annimmt).  Der <b>Kanalz√§hler</b> ( <b>NUSE_Pipe_Items [Pipe]</b> ) wird ebenfalls auf Null gesetzt. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Z√§hler f√ºr blockierte Task des Kanals ( <b>NUSE_Pipe_Blocking_Count [Pipe]</b> ) auf Null gesetzt. <br><br><h3>  Semaphorinitialisierung </h3><br>  Das Folgende ist der vollst√§ndige Code f√ºr die Funktion <b>NUSE_Init_Semaphore ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Semaphore(NUSE_SEMAPHORE semaphore) { NUSE_Semaphore_Counter[semaphore] = NUSE_Semaphore_Initial_Value[semaphore]; #if NUSE_BLOCKING_ENABLE NUSE_Semaphore_Blocking_Count[semaphore] = 0; #endif }</code> </pre><br>  Der Semaphorz√§hler ( <b>NUSE_Semaphore_Counter [Semaphor]</b> ) wird mit dem vom Benutzer <b>festgelegten</b> Wert ( <b>NUSE_Semaphore_Initial_Value [Semaphor]</b> ) initialisiert. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Task-Z√§hler f√ºr gesperrte Semaphore ( <b>NUSE_Semaphore_Blocking_Count [Semaphor]</b> ) auf Null gesetzt. <br><br><h3>  Ereignisgruppen initialisieren </h3><br>  Das Folgende ist der vollst√§ndige Code f√ºr die Funktion <b>NUSE_Init_Event_Group ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Event_Group(NUSE_EVENT_GROUP group) { NUSE_Event_Group_Data[group] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Event_Group_Blocking_Count[group] = 0; #endif }</code> </pre><br>  Die Flags der Ereignisgruppe werden zur√ºckgesetzt, d.h.  <b>NUSE_Event_Group_Data [Gruppe] wird</b> ein Nullwert zugewiesen. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Z√§hler f√ºr blockierte Tasks der Ereignisflag-Gruppe ( <b>NUSE_Event_Group_Blocking_Count [Gruppe]</b> ) auf Null gesetzt. <br><br><h3>  Timer-Initialisierung </h3><br>  Unten finden Sie den vollst√§ndigen Code von <b>NUSE_Init_Timer ()</b> . <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Timer(NUSE_TIMER timer) { NUSE_Timer_Status[timer] = FALSE; NUSE_Timer_Value[timer] = NUSE_Timer_Initial_Time[timer]; NUSE_Timer_Expirations_Counter[timer] = 0; }</code> </pre><br>  Der Status des Timers ( <b>NUSE_Timer_Status [Timer]</b> ) wird auf "nicht verwendet" gesetzt, d. H.  <b>FALSCH</b> <br><br>  Der Countdown-Wert ( <b>NUSE_Timer_Value [Timer</b> ]) wird durch den vom Benutzer <b>festgelegten</b> Wert ( <b>NUSE_Timer_Initial_Time [Timer</b> ]) initialisiert. <br><br>  Der Abschlussz√§hler ( <b>NUSE_Timer_Expirations_Counter [Timer]</b> ) wird auf Null gesetzt. <br><br><h2>  Anwendungscode initialisieren </h2><br>  Nachdem die Nucleus SE-Datenstrukturen initialisiert wurden, kann der f√ºr die Initialisierung der Anwendung verantwortliche Code ausgef√ºhrt werden, bevor die Aufgabe gestartet wird.  Diese Funktion kann f√ºr die folgenden Aufgaben hilfreich sein: <br><br><ul><li>  Initialisierung von Anwendungsdatenstrukturen.  Das explizite F√ºllen von Datenstrukturen ist im Vergleich zur automatischen Initialisierung statischer Variablen einfacher zu verstehen und zu debuggen. </li><li>  Zuweisung von Kernelobjekten.  Da alle Kernelobjekte in der Erstellungsphase statisch erstellt und anhand von Indexwerten identifiziert werden, kann es hilfreich sein, einen ‚ÄûEigent√ºmer‚Äú zuzuweisen oder die Verwendung dieser Objekte zu bestimmen.  Dies kann mit der Direktive #define erfolgen. Wenn jedoch mehrere Instanzen von Aufgaben vorhanden sind, ist es besser, Objektindizes √ºber globale Arrays zuzuweisen (indiziert nach Aufgaben-ID). </li><li>  Ger√§teinitialisierung.  Dies kann bei der Erstinstallation von Peripherieger√§ten hilfreich sein. </li></ul><br>  Nat√ºrlich k√∂nnen viele dieser Ziele vor der Initialisierung von Nucleus SE erreicht werden, aber der Vorteil am Speicherort des Anwendungscodes besteht darin, dass Sie jetzt die Kerneldienste (API-Aufrufe) verwenden k√∂nnen.  Beispielsweise kann eine Warteschlange oder ein Postfach mit Daten gef√ºllt sein, die beim Start der Aufgabe verarbeitet werden m√ºssen. <br><br>  API-Aufrufe haben eine Einschr√§nkung: Alle Aktionen, die normalerweise zur Aktivierung des Schedulers f√ºhren, sind verboten (z. B. Pausen- / Blockierungsaufgaben).  Die globale Variable <b>NUSE_Task_State wurde</b> auf <b>NUSE_STARTUP_CONTEXT gesetzt</b> , <b>um</b> diese Einschr√§nkung <b>anzuzeigen</b> . <br><br><h2>  Starten Sie den Scheduler </h2><br>  Nach Abschluss der Initialisierung muss nur noch der Scheduler ausgef√ºhrt werden, um die Ausf√ºhrung der Anwendungscode-Tasks zu starten.  Die Konfiguration des Schedulers und die Arbeit verschiedener Schedulertypen wurde in einem der vorherigen Artikel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 9</a> ) ausf√ºhrlich beschrieben, sodass hier nur eine kurze Zusammenfassung erforderlich ist. <br>  Die Reihenfolge der Schl√ºsselschritte ist wie folgt: <br><br><ul><li>  <b>Setzen der</b> globalen Variablen <b>NUSE_Task_State auf</b> <b>NUSE_TASK_CONTEXT</b> . </li><li>  W√§hlen Sie den Index der ersten auszuf√ºhrenden Aufgabe aus.  Wenn die Unterst√ºtzung f√ºr die erste Aufgabe aktiviert ist, wird die Suche nach der ersten abgeschlossenen Aufgabe ausgef√ºhrt, andernfalls wird ein Nullwert verwendet. </li><li>  Der Scheduler <b>hei√üt</b> - <b>NUSE_Scheduler ()</b> . </li></ul><br>  Was genau im letzten Schritt passiert, h√§ngt davon ab, welcher Scheduler ausgew√§hlt ist.  Bei Verwendung des Schedulers "Run to Completion" wird ein Planungszyklus gestartet und Aufgaben werden nacheinander aufgerufen.  Bei Verwendung anderer Scheduler wird der Kontext der ersten Aufgabe geladen und die Steuerung auf die Aufgabe √ºbertragen. <br><br>  Der folgende Artikel beschreibt die Diagnose und Fehlerpr√ºfung. <br><br>  <b>√úber den Autor:</b> Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware.  Lebt in Gro√übritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460617/">https://habr.com/ru/post/de460617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460603/index.html">V2G. Elektroautos werden dazu beitragen, die Produktion und den Verbrauch von Strom auszugleichen</a></li>
<li><a href="../de460605/index.html">Automatisches Fotostudio, Teil 1</a></li>
<li><a href="../de460607/index.html">Offensive Security App Store mit Hacking-Tools von Android</a></li>
<li><a href="../de460611/index.html">Failover: Perfektionismus ruiniert uns und ... Faulheit</a></li>
<li><a href="../de460615/index.html">Im Gefolge von Industrial Ninja: Wie PLC an den Positive Hack Days 9 gehackt wurde</a></li>
<li><a href="../de460621/index.html">Tic Tac Toe Teil 4: Interaktion mit dem Flask Backend √ºber HTTP</a></li>
<li><a href="../de460623/index.html">√úber die Folter von Julian Assange</a></li>
<li><a href="../de460625/index.html">Da ich im Wettbewerb um JavaScript-Entwickler von Telegram nicht den ersten Platz belegt habe</a></li>
<li><a href="../de460627/index.html">vGPU - Verwendung kann nicht ignoriert werden</a></li>
<li><a href="../de460629/index.html">Die Wahrscheinlichkeit, dass 2 Bergleute dieselbe Welt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>