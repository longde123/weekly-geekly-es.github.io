<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🚒 🤩 🥔 Die ganze Wahrheit über RTOS. Artikel 30. Initialisierungs- und Startverfahren für Nucleus SE 🌵 👨🏼‍🤝‍👨🏻 👩🏻‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jedes Betriebssystem verfügt über einen bestimmten Startmechanismus. Das Funktionsprinzip dieses Mechanismus ist für jedes System unterschiedlich. Nor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über RTOS. Artikel 30. Initialisierungs- und Startverfahren für Nucleus SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460617/"><img src="https://habrastorage.org/webt/nr/me/cz/nrmeczn3tg-kdwyme6qgmd7ily4.jpeg"><br><br>  Jedes Betriebssystem verfügt über einen bestimmten Startmechanismus.  Das Funktionsprinzip dieses Mechanismus ist für jedes System unterschiedlich.  Normalerweise sagen sie, dass das System bootet (Eng. Boot), dies ist eine Abkürzung für "Bootstrap", was sich auf den Ausdruck "sich mit den Bootstraps über einen Zaun ziehen" bezieht. wie das System unabhängig von einem Zustand, in dem der Speicher voller Leere ist ( <i>Anmerkung</i> des <i>Übersetzers: wenn absolut genau, dann Müll</i> ), zu einer stabilen Programmausführung übergeht.  Traditionell wird ein kleiner Teil des Programms in den Speicher geladen und kann im ROM gespeichert werden.  In der Vergangenheit konnte die Eingabe über die Schalter an der Vorderseite des Computers erfolgen.  Dieser Bootloader hat ein komplexeres Bootprogramm gelesen, das das Betriebssystem bereits geladen hat.  Heute startet der Desktop-Computer wie folgt: Der BIOS-Code sucht nach Geräten (Festplatten, CD-ROMs, USB-Sticks), von denen Sie booten können, und anschließend startet das Betriebssystem. <br><br>  Auf ähnliche Weise kann auch das Betriebssystem für eingebettete Systeme initialisiert werden.  Tatsächlich werden eingebettete Betriebssysteme geladen, die auf der Basis von Desktop-Betriebssystemen entwickelt wurden.  In den meisten "klassischen" RTOS wird jedoch eine viel einfachere (und daher schnellere) Methode verwendet. <br><a name="habracut"></a><br>  Das Betriebssystem ist Teil der Software.  Wenn sich diese Software bereits im Speicher befindet (z. B. in der einen oder anderen Form des ROM), müssen Sie nur sicherstellen, dass die Folge der CPU-Befehle nach dem Zurücksetzen mit der Ausführung des Betriebssysteminitialisierungscodes endet.  So funktionieren die meisten RTOS, einschließlich Nucleus SE ( <i>Anmerkung des Übersetzers: Dies gilt auch für unser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS MAX</a></i> ). <br><br>  Die meisten eingebetteten Softwareentwicklungstools enthalten den erforderlichen Startcode für das Zurücksetzen der CPU und die Übertragung der Steuerung an die Entry Point-Funktion in der <b>main ()</b> -Funktion.  Der weiterverteilbare Nucleus SE-Code behandelt diesen Prozess nicht, da er so portabel wie möglich sein muss.  Stattdessen enthält es die Funktion <b>main ()</b> , die die Steuerung der CPU übernimmt und das Betriebssystem initialisiert und startet.  Diese Funktion wird nachstehend ausführlich erläutert. <br><br><div class="spoiler">  <b class="spoiler_title">Frühere Artikel in der Reihe:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 29.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterbrechungen in Nucleus SE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Software-Timer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemzeit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kanäle: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenkanäle: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen für die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einführung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einführung.</a> <br></div></div><br><h3>  Speicherinitialisierung </h3><br>  Deklarationen aller statischen Variablen im Nucleus SE-Code beginnen mit dem <b>ROM-</b> oder <b>RAM-</b> Präfix, um anzugeben, wo sie sich befinden sollen.  Diese beiden Direktiven <b>#define</b> sind in der Datei <b>nuse_types.h</b> definiert und müssen unter Berücksichtigung der Besonderheiten der verwendeten Entwicklungstools (Compiler und Linker) konfiguriert werden.  Normalerweise sollte das <b>ROM</b> vom Typ <b>const sein</b> ( <i>Anmerkung</i> des <i>Übersetzers: <b>Nach</b> meiner Erfahrung ist <b>const</b> nicht immer genug, <b>statisch</b> ist besser</i> ) und <b>RAM</b> ist ein leerer Wert. <br><br>  Alle <b>ROM-</b> Variablen werden statisch initialisiert, was logisch ist.  <b>RAM-</b> Variablen werden nicht statisch initialisiert (da dies nur mit bestimmten Toolboxen funktioniert, die so konfiguriert sind, dass sie automatisch vom ROM in den RAM kopieren).  Ein expliziter Initialisierungscode ist in der Anwendung enthalten und wird nachstehend ausführlich beschrieben. <br><br>  Nucleus SE speichert keine „konstanten“ Daten im RAM, was in kleinen Systemen normalerweise Mangelware ist.  Anstatt komplexe Datenstrukturen zur Beschreibung von Kernelobjekten zu verwenden, werden Tabellensätze (Arrays) verwendet, die je nach Bedarf leicht in ROM oder RAM abgelegt werden können. <br><br><h2>  Main () Funktion </h2><br>  Das Folgende ist der vollständige Code für die <b>main () -</b> Funktion von Nucleus SE: <br><br><pre><code class="plaintext hljs">void main(void) { NUSE_Init(); /* initialize kernel data */ /* user initialization code here */ NUSE_Scheduler(); /* start tasks */ }</code> </pre> <br>  Die Reihenfolge der Operationen ist recht einfach: <br><br><ul><li>  Zunächst wird die Funktion <b>NUSE_Init () aufgerufen</b> .  Es initialisiert alle Nucleus SE-Datenstrukturen und wird nachstehend ausführlich beschrieben. </li><li>  Anschließend kann der Benutzer einen beliebigen Anwendungsinitialisierungscode einfügen, der ausgeführt wird, bevor der Taskplaner gestartet wird.  Weitere Informationen darüber, was mit diesem Code erreicht werden kann, finden Sie weiter unten in diesem Artikel. </li><li>  Schließlich wird der Nucleus SE-Scheduler ( <b>NUSE_Scheduler ()</b> ) <b>gestartet</b> .  Dies wird später in diesem Artikel ebenfalls ausführlich erläutert. </li></ul><br><h2>  NUSE_Init () Funktion </h2><br>  Diese Funktion initialisiert alle Nucleus SE-Kernelvariablen und Datenstrukturen. <br><br><div class="spoiler">  <b class="spoiler_title">Unten finden Sie den vollständigen Funktionscode:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void NUSE_Init(void) { U8 index; /* global data */ NUSE_Task_Active = 0; NUSE_Task_State = NUSE_STARTUP_CONTEXT; #if NUSE_SYSTEM_TIME_SUPPORT NUSE_Tick_Clock = 0; #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER NUSE_Time_Slice_Ticks = NUSE_TIME_SLICE_TICKS; #endif /* tasks */ #if ((NUSE_SCHEDULER_TYPE != NUSE_RUN_TO_COMPLETION_SCHEDULER) || NUSE_SIGNAL_SUPPORT || NUSE_TASK_SLEEP || NUSE_SUSPEND_ENABLE || NUSE_SCHEDULE_COUNT_SUPPORT) for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { NUSE_Init_Task(index); } #endif /* partition pools */ #if NUSE_PARTITION_POOL_NUMBER != 0 for (index=0; index&lt;NUSE_PARTITION_POOL_NUMBER; index++) { NUSE_Init_Partition_Pool(index); } #endif /* mailboxes */ #if NUSE_MAILBOX_NUMBER != 0 for (index=0; index&lt;NUSE_MAILBOX_NUMBER; index++) { NUSE_Init_Mailbox(index); } #endif /* queues */ #if NUSE_QUEUE_NUMBER != 0 for (index=0; index&lt;NUSE_QUEUE_NUMBER; index++) { NUSE_Init_Queue(index); } #endif /* pipes */ #if NUSE_PIPE_NUMBER != 0 for (index=0; index&lt;NUSE_PIPE_NUMBER; index++) { NUSE_Init_Pipe(index); } #endif /* semaphores */ #if NUSE_SEMAPHORE_NUMBER != 0 for (index=0; index&lt;NUSE_SEMAPHORE_NUMBER; index++) { NUSE_Init_Semaphore(index); } #endif /* event groups */ #if NUSE_EVENT_GROUP_NUMBER != 0 for (index=0; index&lt;NUSE_EVENT_GROUP_NUMBER; index++) { NUSE_Init_Event_Group(index); } #endif /* timers */ #if NUSE_TIMER_NUMBER != 0 for (index=0; index&lt;NUSE_TIMER_NUMBER; index++) { NUSE_Init_Timer(index); } #endif }</code> </pre><br></div></div><br>  Zunächst werden globale Variablen initialisiert: <br><ul><li>  <b>NUSE_Task_Active</b> - Index der aktiven Aufgabe, initialisiert auf Null;  später kann dies den Scheduler ändern. </li><li>  <b>NUSE_Task_State</b> - wird mit dem Wert <b>NUSE_STARTUP_CONTEXT</b> initialisiert, wodurch die Funktionalität der API für jeden nachfolgenden Anwendungsinitialisierungscode eingeschränkt wird. </li><li>  Wenn die Systemzeitunterstützung aktiviert ist, wird <b>NUSE_Tick_Clock</b> auf Null gesetzt. </li><li>  Wenn der Time Slice Scheduler aktiviert ist, wird <b>NUSE_Time_Slice_Ticks</b> der konfigurierte Wert <b>NUSE_TIME_SLICE_TICKS zugewiesen</b> . </li></ul><br>  Dann werden die Funktionen aufgerufen, um die Kernelobjekte zu initialisieren: <br><br><ul><li>  <b>NUSE_Init_Task ()</b> wird aufgerufen, um die Datenstrukturen jeder Aufgabe zu initialisieren.  Dieser Aufruf wird nur übersprungen, wenn der Scheduler "Run to Completion" verwendet wird und die Signale, die Taskpause und der Planungszähler nicht konfiguriert sind (da diese Funktionskombination dazu führt, dass diese Taskstrukturen im RAM nicht vorhanden sind, wird keine Initialisierung durchgeführt). </li><li>  <b>NUSE_Init_Partition_Pool ()</b> wird aufgerufen, um jedes Partitionspoolobjekt zu initialisieren.  Diese Aufrufe werden übersprungen, wenn keine Partitionspools konfiguriert sind. </li><li>  <b>NUSE_Init_Mailbox ()</b> wird aufgerufen, um jedes Postfachobjekt zu initialisieren.  Diese Anrufe werden übersprungen, wenn keine Postfächer konfiguriert sind. </li><li>  <b>NUSE_Init_Queue ()</b> wird aufgerufen, um jedes Warteschlangenobjekt zu initialisieren.  Diese Anrufe werden übersprungen, wenn keine Warteschlangen konfiguriert sind. </li><li>  <b>NUSE_Init_Pipe ()</b> wird aufgerufen, um jedes <b>Kanalobjekt</b> zu initialisieren.  Diese Anrufe werden übersprungen, wenn keine Kanäle konfiguriert sind. </li><li>  <b>NUSE_Init_Semaphore ()</b> wird aufgerufen, um jedes Semaphorobjekt zu initialisieren.  Diese Aufrufe werden übersprungen, wenn keine Semaphoren konfiguriert sind. </li><li>  <b>NUSE_Init_Event_Group ()</b> wird aufgerufen, um jedes Ereignisgruppenobjekt zu initialisieren.  Diese Aufrufe werden übersprungen, wenn keine Ereignisgruppen konfiguriert sind. </li><li>  <b>NUSE_Init_Timer ()</b> wird aufgerufen, um jedes Timer-Objekt zu initialisieren.  Diese Anrufe werden übersprungen, wenn keine Timer konfiguriert sind. </li></ul><br><h3>  Aufgabeninitialisierung </h3><br><div class="spoiler">  <b class="spoiler_title">Das Folgende ist der vollständige Code für die Funktion NUSE_Init_Task ():</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void NUSE_Init_Task(NUSE_TASK task) { #if NUSE_SCHEDULER_TYPE != NUSE_RUN_TO_COMPLETION_SCHEDULER NUSE_Task_Context[task][15] = /* SR */ NUSE_STATUS_REGISTER; NUSE_Task_Context[task][16] = /* PC */ NUSE_Task_Start_Address[task]; NUSE_Task_Context[task][17] = /* SP */ (U32 *)NUSE_Task_Stack_Base[task] + NUSE_Task_Stack_Size[task]; #endif #if NUSE_SIGNAL_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Signal_Flags[task] = 0; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING NUSE_Task_Timeout_Counter[task] = 0; #endif #if NUSE_SUSPEND_ENABLE || NUSE_INCLUDE_EVERYTHING #if NUSE_INITIAL_TASK_STATE_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Status[task] = NUSE_Task_Initial_State[task]; #else NUSE_Task_Status[task] = NUSE_READY; #endif #endif #if NUSE_SCHEDULE_COUNT_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Schedule_Count[task] = 0; #endif }</code> </pre><br></div></div><br>  Wenn der Run to Completion-Scheduler nicht konfiguriert wurde, wird der Kontextblock für die <b>Task NUSE_Task_Context [task] []</b> initialisiert.  Den meisten Elementen werden keine Werte zugewiesen, da sie allgemeine Maschinenregister darstellen, die beim Starten einer Aufgabe einen Zwischenwert haben sollten.  Im Beispiel (Freescale ColdFire) der Nucleus SE-Implementierung (bei anderen Prozessoren ist der Mechanismus jedoch ähnlich) werden die letzten drei Einträge explizit festgelegt: <br><br><ul><li>  <b>NUSE_Task_Context [task] [15]</b> enthält das Statusregister ( <b>SR</b> , Statusregister) und hat den Wert der Anweisung <b>#define NUSE_STATUS_REGISTER</b> . </li><li>  <b>NUSE_Task_Context [Aufgabe] [16]</b> enthält den Programmzähler ( <b>PC</b> , Programmzähler) und hat den Adresswert des Eingabepunkts des Aufgabencodes: <b>NUSE_Task_Start_Address [Aufgabe]</b> . </li><li>  <b>NUSE_Task_Context [Aufgabe] [17]</b> enthält den Stapelzeiger ( <b>SP</b> , Stapelzeiger) und wird mit dem Wert initialisiert, der als Summe aus der Adresse des Aufgabenstapels ( <b>NUSE_Task_Stack_Base [Aufgabe]</b> ) und der Größe des Aufgabenstapels ( <b>NUSE_Task_Stack_Size [Aufgabe]</b> ) <b>berechnet wird</b> . </li></ul><br>  Wenn die Signalunterstützung aktiviert ist, werden Task-Signal-Flags ( <b>NUSE_Task_Signal_Flags [Task]</b> ) auf Null gesetzt. <br><br>  Wenn die Task-Suspendierung aktiviert ist ( <b>dh der</b> API-Serviceaufruf <b>NUSE_Task_Sleep ()</b> ), wird der Task-Timeout-Zähler ( <b>NUSE_Task_Timeout_Counter [Task]</b> ) auf Null gesetzt. <br><br>  Wenn der Task-Suspend-Status aktiviert ist, wird der Task-Status ( <b>NUSE_Task_Status [Task]</b> ) initialisiert.  Dieser Anfangswert wird vom Benutzer festgelegt (in <b>NUSE_Task_Initial_State [Aufgabe]</b> ), wenn die Unterstützung für den Anfangszustand der Aufgabe aktiviert ist.  Andernfalls wird der Status <b>NUSE_READY</b> zugewiesen. <br><br>  Wenn der Planungszähler aktiviert ist, wird der Aufgabenzähler ( <b>NUSE_Task_Schedule_Count [Aufgabe]</b> ) auf Null gesetzt. <br><br><h3>  Partitionspools initialisieren </h3><br>  Das Folgende ist der vollständige Code für die Funktion <b>NUSE_Init_Partition_Pool ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Partition_Pool(NUSE_PARTITION_POOL pool) { NUSE_Partition_Pool_Partition_Used[pool] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Partition_Pool_Blocking_Count[pool] = 0; #endif }</code> </pre><br>  Der "verwendete" Partitionspoolzähler ( <b>NUSE_Partition_Pool__Partition_Used [Pool]</b> ) wird auf Null gesetzt. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Zähler für blockierte Aufgaben von Partitionspools ( <b>NUSE_Partition_Pool_Blocking_Count [Pool])</b> auf Null gesetzt. <br><br><h3>  Postfächer initialisieren </h3><br>  Unten finden Sie den vollständigen Code für <b>NUSE_Init_Mailbox ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Mailbox(NUSE_MAILBOX mailbox) { NUSE_Mailbox_Data[mailbox] = 0; NUSE_Mailbox_Status[mailbox] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Mailbox_Blocking_Count[mailbox] = 0; #endif }</code> </pre><br>  Der Postfachdatenspeicher ( <b>NUSE_Mailbox_Data [Postfach]</b> ) wird auf Null gesetzt, und der Status ( <b>NUSE_Mailbox_Status [Postfach]</b> ) wird "nicht verwendet" (dh Null). <br><br>  Wenn die Aufgabensperre aktiviert ist, wird der Zähler für blockierte Postfachaufgaben ( <b>NUSE_Mailbox_Blocking_Count [Postfach]</b> ) auf Null gesetzt. <br><br><h3>  Initialisierung der Warteschlange </h3><br>  Das Folgende ist der vollständige Code für die Funktion <b>NUSE_Init_Queue ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Queue(NUSE_QUEUE queue) { NUSE_Queue_Head[queue] = 0; NUSE_Queue_Tail[queue] = 0; NUSE_Queue_Items[queue] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Queue_Blocking_Count[queue] = 0; #endif }</code> </pre><br>  Zeiger auf den Anfang und das Ende der Warteschlange (tatsächlich sind dies die Indizes <b>NUSE_Queue_Head [Warteschlange</b> ] und <b>NUSE_Queue_Tail [Warteschlange]</b> ) werden Werte zugewiesen, die den Beginn des Datenbereichs der Warteschlangen angeben ( <b>dh</b> einen Wert von Null annehmen).  Der Zähler in der Warteschlange ( <b>NUSE_Queue_Items [Warteschlange]</b> ) wird ebenfalls auf Null gesetzt. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Zähler für blockierte Warteschlangen-Tasks ( <b>NUSE_Queue_Blocking_Count [Warteschlange]</b> ) auf Null gesetzt. <br><br><h3>  Kanalinitialisierung </h3><br>  Das Folgende ist der vollständige Code für die Funktion <b>NUSE_Init_Pipe ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Pipe(NUSE_PIPE pipe) { NUSE_Pipe_Head[pipe] = 0; NUSE_Pipe_Tail[pipe] = 0; NUSE_Pipe_Items[pipe] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Pipe_Blocking_Count[pipe] = 0; #endif }</code> </pre><br>  Zeigern auf den Anfang und das Ende des Kanals (tatsächlich sind dies die Indizes - <b>NUSE_Pipe_Head [Pipe]</b> und <b>NUSE_Pipe_Tail [Pipe]</b> ) wird ein Wert zugewiesen, der den Beginn des <b>Kanaldatenbereichs angibt (dh</b> einen Nullwert annimmt).  Der <b>Kanalzähler</b> ( <b>NUSE_Pipe_Items [Pipe]</b> ) wird ebenfalls auf Null gesetzt. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Zähler für blockierte Task des Kanals ( <b>NUSE_Pipe_Blocking_Count [Pipe]</b> ) auf Null gesetzt. <br><br><h3>  Semaphorinitialisierung </h3><br>  Das Folgende ist der vollständige Code für die Funktion <b>NUSE_Init_Semaphore ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Semaphore(NUSE_SEMAPHORE semaphore) { NUSE_Semaphore_Counter[semaphore] = NUSE_Semaphore_Initial_Value[semaphore]; #if NUSE_BLOCKING_ENABLE NUSE_Semaphore_Blocking_Count[semaphore] = 0; #endif }</code> </pre><br>  Der Semaphorzähler ( <b>NUSE_Semaphore_Counter [Semaphor]</b> ) wird mit dem vom Benutzer <b>festgelegten</b> Wert ( <b>NUSE_Semaphore_Initial_Value [Semaphor]</b> ) initialisiert. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Task-Zähler für gesperrte Semaphore ( <b>NUSE_Semaphore_Blocking_Count [Semaphor]</b> ) auf Null gesetzt. <br><br><h3>  Ereignisgruppen initialisieren </h3><br>  Das Folgende ist der vollständige Code für die Funktion <b>NUSE_Init_Event_Group ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Event_Group(NUSE_EVENT_GROUP group) { NUSE_Event_Group_Data[group] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Event_Group_Blocking_Count[group] = 0; #endif }</code> </pre><br>  Die Flags der Ereignisgruppe werden zurückgesetzt, d.h.  <b>NUSE_Event_Group_Data [Gruppe] wird</b> ein Nullwert zugewiesen. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Zähler für blockierte Tasks der Ereignisflag-Gruppe ( <b>NUSE_Event_Group_Blocking_Count [Gruppe]</b> ) auf Null gesetzt. <br><br><h3>  Timer-Initialisierung </h3><br>  Unten finden Sie den vollständigen Code von <b>NUSE_Init_Timer ()</b> . <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Timer(NUSE_TIMER timer) { NUSE_Timer_Status[timer] = FALSE; NUSE_Timer_Value[timer] = NUSE_Timer_Initial_Time[timer]; NUSE_Timer_Expirations_Counter[timer] = 0; }</code> </pre><br>  Der Status des Timers ( <b>NUSE_Timer_Status [Timer]</b> ) wird auf "nicht verwendet" gesetzt, d. H.  <b>FALSCH</b> <br><br>  Der Countdown-Wert ( <b>NUSE_Timer_Value [Timer</b> ]) wird durch den vom Benutzer <b>festgelegten</b> Wert ( <b>NUSE_Timer_Initial_Time [Timer</b> ]) initialisiert. <br><br>  Der Abschlusszähler ( <b>NUSE_Timer_Expirations_Counter [Timer]</b> ) wird auf Null gesetzt. <br><br><h2>  Anwendungscode initialisieren </h2><br>  Nachdem die Nucleus SE-Datenstrukturen initialisiert wurden, kann der für die Initialisierung der Anwendung verantwortliche Code ausgeführt werden, bevor die Aufgabe gestartet wird.  Diese Funktion kann für die folgenden Aufgaben hilfreich sein: <br><br><ul><li>  Initialisierung von Anwendungsdatenstrukturen.  Das explizite Füllen von Datenstrukturen ist im Vergleich zur automatischen Initialisierung statischer Variablen einfacher zu verstehen und zu debuggen. </li><li>  Zuweisung von Kernelobjekten.  Da alle Kernelobjekte in der Erstellungsphase statisch erstellt und anhand von Indexwerten identifiziert werden, kann es hilfreich sein, einen „Eigentümer“ zuzuweisen oder die Verwendung dieser Objekte zu bestimmen.  Dies kann mit der Direktive #define erfolgen. Wenn jedoch mehrere Instanzen von Aufgaben vorhanden sind, ist es besser, Objektindizes über globale Arrays zuzuweisen (indiziert nach Aufgaben-ID). </li><li>  Geräteinitialisierung.  Dies kann bei der Erstinstallation von Peripheriegeräten hilfreich sein. </li></ul><br>  Natürlich können viele dieser Ziele vor der Initialisierung von Nucleus SE erreicht werden, aber der Vorteil am Speicherort des Anwendungscodes besteht darin, dass Sie jetzt die Kerneldienste (API-Aufrufe) verwenden können.  Beispielsweise kann eine Warteschlange oder ein Postfach mit Daten gefüllt sein, die beim Start der Aufgabe verarbeitet werden müssen. <br><br>  API-Aufrufe haben eine Einschränkung: Alle Aktionen, die normalerweise zur Aktivierung des Schedulers führen, sind verboten (z. B. Pausen- / Blockierungsaufgaben).  Die globale Variable <b>NUSE_Task_State wurde</b> auf <b>NUSE_STARTUP_CONTEXT gesetzt</b> , <b>um</b> diese Einschränkung <b>anzuzeigen</b> . <br><br><h2>  Starten Sie den Scheduler </h2><br>  Nach Abschluss der Initialisierung muss nur noch der Scheduler ausgeführt werden, um die Ausführung der Anwendungscode-Tasks zu starten.  Die Konfiguration des Schedulers und die Arbeit verschiedener Schedulertypen wurde in einem der vorherigen Artikel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 9</a> ) ausführlich beschrieben, sodass hier nur eine kurze Zusammenfassung erforderlich ist. <br>  Die Reihenfolge der Schlüsselschritte ist wie folgt: <br><br><ul><li>  <b>Setzen der</b> globalen Variablen <b>NUSE_Task_State auf</b> <b>NUSE_TASK_CONTEXT</b> . </li><li>  Wählen Sie den Index der ersten auszuführenden Aufgabe aus.  Wenn die Unterstützung für die erste Aufgabe aktiviert ist, wird die Suche nach der ersten abgeschlossenen Aufgabe ausgeführt, andernfalls wird ein Nullwert verwendet. </li><li>  Der Scheduler <b>heißt</b> - <b>NUSE_Scheduler ()</b> . </li></ul><br>  Was genau im letzten Schritt passiert, hängt davon ab, welcher Scheduler ausgewählt ist.  Bei Verwendung des Schedulers "Run to Completion" wird ein Planungszyklus gestartet und Aufgaben werden nacheinander aufgerufen.  Bei Verwendung anderer Scheduler wird der Kontext der ersten Aufgabe geladen und die Steuerung auf die Aufgabe übertragen. <br><br>  Der folgende Artikel beschreibt die Diagnose und Fehlerprüfung. <br><br>  <b>Über den Autor:</b> Colin Walls ist seit über dreißig Jahren in der Elektronikindustrie tätig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht häufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier Bücher über Firmware.  Lebt in Großbritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460617/">https://habr.com/ru/post/de460617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460603/index.html">V2G. Elektroautos werden dazu beitragen, die Produktion und den Verbrauch von Strom auszugleichen</a></li>
<li><a href="../de460605/index.html">Automatisches Fotostudio, Teil 1</a></li>
<li><a href="../de460607/index.html">Offensive Security App Store mit Hacking-Tools von Android</a></li>
<li><a href="../de460611/index.html">Failover: Perfektionismus ruiniert uns und ... Faulheit</a></li>
<li><a href="../de460615/index.html">Im Gefolge von Industrial Ninja: Wie PLC an den Positive Hack Days 9 gehackt wurde</a></li>
<li><a href="../de460621/index.html">Tic Tac Toe Teil 4: Interaktion mit dem Flask Backend über HTTP</a></li>
<li><a href="../de460623/index.html">Über die Folter von Julian Assange</a></li>
<li><a href="../de460625/index.html">Da ich im Wettbewerb um JavaScript-Entwickler von Telegram nicht den ersten Platz belegt habe</a></li>
<li><a href="../de460627/index.html">vGPU - Verwendung kann nicht ignoriert werden</a></li>
<li><a href="../de460629/index.html">Die Wahrscheinlichkeit, dass 2 Bergleute dieselbe Welt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>