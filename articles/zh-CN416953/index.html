<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌨️ ♌️ 🕔 为网络创建卡通水着色器。 第一部分 🎷 🐋 🌟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在我的教程“ Creating Shaders”中，我主要研究了片段着色器，这些片段着色器足以在ShaderToy上实现任何2D效果和示例。 但是有一整类技术需要使用顶点着色器。 在本教程中，我将讨论创建风格化的卡通水着色器，并向您介绍顶点着色器。 我还将讨论深度缓冲以及如何使用它来获取有关场景的更...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>为网络创建卡通水着色器。 第一部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416953/">在我的教程<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Creating Shaders”中，</a>我主要研究了片段着色器，这些片段着色器足以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">ShaderToy</a>上实现任何2D效果和示例。 但是有一整类技术需要使用顶点着色器。 在本教程中，我将讨论创建风格化的卡通水着色器，并向您介绍顶点着色器。 我还将讨论深度缓冲以及如何使用它来获取有关场景的更多信息并创建海泡沫线。 <br><br> 这就是完成的效果。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">此处</a>看到一个交互式演示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/58d/814/c3858d814aa8ca99c2c0c58535503482.jpg"></div><br> 此效果包含以下元素： <br><br><ol><li> 一个半透明的水网格，具有细分的多边形和偏移的顶点，以创建波浪。 </li><li> 表面上有静水管线。 </li><li> 模拟船浮力。 </li><li> 水中物体周围的动态泡沫线。 </li><li> 后处理会造成水下一切变形。 </li></ol><br> 在这种效果下，我喜欢它涉及计算机图形学的许多不同概念的事实，因此它将使我们能够使用以前教程中的思想，以及开发可应用于新效果的技术。 <br><a name="habracut"></a><br> 在本教程中，我将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">PlayCanvas</a> ，只是因为它是一个方便的免费Web-IDE，但是所有内容都可以应用于任何其他WebGL环境，而不会出现任何问题。 在本文的结尾，将提供Three.js的源代码版本。 我们将假定您已经精通片段着色器和PlayCanvas界面。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>刷新有关着色器的知识，并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>熟悉PlayCanvas。 <br><br><h2> 环境设定 </h2><br> 本部分的目的是配置我们的PlayCanvas项目，并将几个会影响水的环境对象插入其中。 <br><br> 如果您没有PlayCanvas帐户，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">注册它</a>并创建一个新的<strong>空白项目</strong> 。 默认情况下，场景中应该有几个对象，一个摄像头和一个光源。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f57/00e/57f/f5700e57f7434006e48831c30378d0df.png"></div><br><h3> 插入模型 </h3><br>  Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">Poly</a>专案是寻找网路3D模型的绝佳资源。 我从那里拿<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">船模型</a> 。 下载并解压缩存档后，您将在其中找到<code>.obj</code>和<code>.png</code>文件。 <br><br><ol><li> 将两个文件都拖到PlayCanvas项目的Assets窗口中。 </li><li> 选择自动生成的材质，然后选择<code>.png</code>文件作为其漫反射贴图。 </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b60/499/7cc/b604997ccaad7c5d0d97a81f6da3be98.png"></div><br> 现在，您可以将<strong>Tugboat.json</strong>拖到场景中并删除Box和Plane对象。 如果船看起来太小，则可以增加其比例（我将值设置为50）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4c/307/250/c4c30725001beeacf4a2149735f95a1b.png"></div><br> 同样，您可以将任何其他模型添加到场景中。 <br><br><h3> 绕行摄像机 </h3><br> 要配置在轨道上飞行的摄像机，我们将复制<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">此PlayCanvas示例中</a>的脚本。 单击链接，然后单击“ <strong>编辑器”</strong>以打开项目。 <br><br><ol><li> 将本教程项目中的<code>mouse-input.js</code>和<code>orbit-camera.js</code>的内容复制到项目中具有相同名称的文件中。 </li><li> 将<strong>脚本</strong>组件添加到相机。 </li><li> 将两个脚本附加到相机。 </li></ol><br><blockquote>  <em>提示：要组织项目，可以在“资产”窗口中创建文件夹。</em>  <em>我将这两个相机脚本放置在Scripts / Camera /文件夹中，将模型放置在Models /中，并将材质放置在Materials /文件夹中。</em> </blockquote><br> 现在，当您开始游戏时（场景窗口右上角的启动按钮），您应该会看到一条船，您可以通过用鼠标将其在轨道上移动来用摄像机检查。 <br><br><h2> 水面多边形划分 </h2><br> 本部分的目的是创建一个细分的网格，该网格将用作水面。 <br><br> 为了创建水面，我们改编了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">地势生成教程中的</a>部分代码。 创建一个新的<code>Water.js</code>脚本<code>Water.js</code> 。 打开此脚本进行编辑，并创建一个新的<code>GeneratePlaneMesh</code>函数，如下所示： <br><br><pre> <code class="javascript hljs">Water.prototype.GeneratePlaneMesh = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 -    ,     if(options === undefined) options = {subdivisions:100, width:10, height:10}; // 2 -  , UV   var positions = []; var uvs = []; var indices = []; var row, col; var normals; for (row = 0; row &lt;= options.subdivisions; row++) { for (col = 0; col &lt;= options.subdivisions; col++) { var position = new pc.Vec3((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0)); positions.push(position.x, position.y, position.z); uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions); } } for (row = 0; row &lt; options.subdivisions; row++) { for (col = 0; col &lt; options.subdivisions; col++) { indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + (row + 1) * (options.subdivisions + 1)); } } //   normals = pc.calculateNormals(positions, indices); //    var node = new pc.GraphNode(); var material = new pc.StandardMaterial(); //   var mesh = pc.createMesh(this.app.graphicsDevice, positions, { normals: normals, uvs: uvs, indices: indices }); var meshInstance = new pc.MeshInstance(node, mesh, material); //      var model = new pc.Model(); model.graph = node; model.meshInstances.push(meshInstance); this.entity.addComponent('model'); this.entity.model.model = model; this.entity.model.castShadows = false; //   ,       };</span></span></code> </pre> <br> 现在我们可以在<code>initialize</code>函数中调用它： <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GeneratePlaneMesh({<span class="hljs-attr"><span class="hljs-attr">subdivisions</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">width</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">height</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}); };</code> </pre> <br> 现在，当您开始游戏时，您应该只会看到一个平坦的表面。 但这不仅是平坦的表面，而且是由数千个峰组成的网格。 作为练习，尝试自己验证一下（这是研究刚刚复制的代码的一个很好的理由）。 <br><br><blockquote>  <em>问题1：将每个顶点的Y坐标移动一个随机值，以使平面如下图所示。</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/397/111/391/397111391bbb4e1cafd0e658005ed1cc.jpg"></div><br><h2> 海浪 </h2><br> 本部分的目的是指定您自己的材料的水面并创建动画波浪。 <br><br> 为了获得我们需要的效果，您需要配置自己的材料。 大多数3D引擎都有一组用于渲染对象的预定义着色器，以及一种重新定义它们的方法。 这是有关如何在PlayCanvas中执行此操作的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">良好链接</a> 。 <br><br><h3> 着色器附件 </h3><br> 让我们创建一个新的<code>CreateWaterMaterial</code>函数，该函数<code>CreateWaterMaterial</code>具有更改的着色器<code>CreateWaterMaterial</code>新材质并返回它： <br><br><pre> <code class="javascript hljs">Water.prototype.CreateWaterMaterial = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     var material = new pc.Material(); //    ,       material.name = "DynamicWater_Material"; //    //        . var gd = this.app.graphicsDevice; var fragmentShader = "precision " + gd.precision + " float;\n"; fragmentShader = fragmentShader + this.fs.resource; var vertexShader = this.vs.resource; //       . var shaderDefinition = { attributes: { aPosition: pc.gfx.SEMANTIC_POSITION, aUv0: pc.SEMANTIC_TEXCOORD0, }, vshader: vertexShader, fshader: fragmentShader }; //     this.shader = new pc.Shader(gd, shaderDefinition); //      material.setShader(this.shader); return material; };</span></span></code> </pre> <br> 此函数从脚本属性中获取顶点和片段着色器代码。 因此，让我们在文件顶部（在<code>pc.createScript</code>行之后）定义它们： <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'vs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Vertex Shader'</span></span> }); Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Fragment Shader'</span></span> });</code> </pre> <br> 现在，我们可以创建这些着色器文件并将其附加到脚本中。 返回编辑器并创建两个着色器文件： <strong>Water.frag</strong>和<strong>Water.vert</strong> 。 如下图所示，将这些着色器附加到脚本。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/fa4/d8a/0a2fa4d8a998e8abe1fc63da301f0ad9.png"></div><br> 如果新属性未在编辑器中显示，请单击“ <strong>解析”</strong>按钮以更新脚本。 <br><br> 现在，将此基本着色器粘贴到<strong>Water.frag中</strong> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); gl_FragColor = color; }</code> </pre> <br> 这是在<strong>Water.vert中</strong> ： <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br> 最后，返回<strong>Water.js</strong>以使用我们的新材料代替标准材料。 即，代替： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pc.StandardMaterial();</code> </pre> <br> 插入： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CreateWaterMaterial();</code> </pre> <br> 现在，开始游戏后，飞机应该是蓝色的。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e79/797/8ff/e797978ff286ff2f15b3b8465debf767.png"></div><br><h3> 热重启 </h3><br> 现在，我们只是为新材料设置着色器毛坯。 在开始编写真实效果之前，我想设置自动代码重新加载。 <br><br> 在任何脚本文件（例如，Water.js）中取消注释掉<code>swap</code>功能后，我们将启用热重装。 稍后，即使实时更新代码，我们也会看到如何使用它来维护状态。 但是现在，我们只想在进行更改后重新应用着色器。 在WebGL中运行之前，先对着色器进行编译，因此要进行此操作，我们需要重新创建材质。 <br><br> 我们将检查着色器代码的内容是否已更改，如果已更改，请再次创建材质。 首先，将当前着色器保存在<strong>initialize中</strong> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  initialize,       Water.prototype.initialize = function() { this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br> 在<strong>更新中，</strong>我们检查是否发生了任何更改： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  update,     Water.prototype.update = function(dt) { if(this.savedFS != this.fs.resource || this.savedVS != this.vs.resource){ //   ,      var newMaterial = this.CreateWaterMaterial(); //     var model = this.entity.model.model; model.meshInstances[0].material = newMaterial; //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; } };</span></span></code> </pre> <br> 现在，要确保能正常工作，请开始游戏，并将<strong>Water.frag中</strong>飞机的颜色更改为更令人愉悦的蓝色。 保存文件后，即使没有重新启动也应重新启动它！ 这是我选择的颜色： <br><br><pre> <code class="javascript hljs">vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>);</code> </pre> <br><h4> 顶点着色器 </h4><br> 要创建波浪，我们必须在每一帧中移动网格的每个顶点。 似乎效率很低，但是每个模型的每个顶点已经在每个渲染帧中进行了变换。 这就是顶点着色器的作用。 <br><br> 如果我们认为片段着色器是针对每个像素执行的函数，获取其位置并返回颜色，则<em>顶点着色器是</em>针对每个像素运行，获取其位置并返回<em>其position的函数</em> 。 <br><br> 默认情况下，顶点着色器<em>在</em>模型<em>世界中</em>获得一个<em>位置，</em>并<em>在屏幕上</em>返回其<em>位置</em> 。 我们的3D场景设置为x，y和z坐标，但是监视器是平面二维平面，因此我们将3D世界投影到2D屏幕上。 这种投影涉及类型，投影和模型的矩阵，因此在本教程中我们将不考虑它。 但是，如果您想了解每个阶段到底发生了什么，那么这里有个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">很好的指南</a> 。 <br><br> 也就是说，这一行： <br><br><pre> <code class="javascript hljs">gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br> 接收<code>aPosition</code>作为特定顶点在3D世界中的位置，并将其转换为<code>gl_Position</code> ，即转换为2D屏幕上的最终位置。  aPosition中的前缀“ a”表示此值是一个<em>属性</em> 。 不要忘了变量<em>Uniform</em>是我们可以在CPU中定义并将其传递给着色器的值。 对于所有像素/顶点，它保持相同的值。 另一方面，该属性值是从指定的CPU <em>array</em>获得的。 为此属性数组的每个值调用一个顶点着色器。 <br><br> 您可以看到这些属性是在我们在Water.js中设置的着色器定义中配置的： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shaderDefinition = { <span class="hljs-attr"><span class="hljs-attr">attributes</span></span>: { <span class="hljs-attr"><span class="hljs-attr">aPosition</span></span>: pc.gfx.SEMANTIC_POSITION, <span class="hljs-attr"><span class="hljs-attr">aUv0</span></span>: pc.SEMANTIC_TEXCOORD0, }, <span class="hljs-attr"><span class="hljs-attr">vshader</span></span>: vertexShader, <span class="hljs-attr"><span class="hljs-attr">fshader</span></span>: fragmentShader };</code> </pre> <br> 在传递此枚举时，PlayCanvas会为<code>aPosition</code>设置并传输一组顶点位置，但是在一般情况下，我们可以将任何数据数组传递给顶点着色器。 <br><br><h3> 顶点运动 </h3><br> 假设我们要通过将所有<code>x</code>值乘以0.5来压缩整个平面。 我们需要更改<code>aPosition</code>或<code>gl_Position</code>吗？ <br><br> 让我们先尝试一个位置。 我们不能直接更改属性，但可以创建一个副本： <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; pos.x *= <span class="hljs-number"><span class="hljs-number">0.5</span></span>; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br> 现在，平面应该看起来更像一个矩形。 也没有什么奇怪的。 但是，如果我们尝试更改<code>gl_Position</code>会发生什么呢？ <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; <span class="hljs-comment"><span class="hljs-comment">//pos.x *= 0.5; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, 1.0); gl_Position.x *= 0.5; }</span></span></code> </pre> <br> 在开始移动相机之前，它可能看起来相同。 我们更改屏幕空间的坐标，也就是说，图片将取决于<em>我们如何看待它</em> 。 <br><br> 因此我们可以移动顶点，同时区分世界和屏幕空间中的作品也很重要。 <br><br><blockquote>  <em>任务2：是否可以在顶点着色器中将平面的整个表面（沿Y轴）向上移动几个单位而不会扭曲其形状？</em> </blockquote><br><blockquote>  <em>任务3：我说过gl_Position是二维的，但是gl_Position.z也存在。</em>  <em>您可以检查此值是否影响某些东西，如果有影响，它的作用是什么？</em> </blockquote><br><h3> 加时间 </h3><br> 开始创建移动波之前，我们需要做的最后一件事是可用作时间的统一变量。 在顶点着色器中声明统一： <br><br><pre> <code class="javascript hljs">uniform float uTime;</code> </pre> <br> 现在，将其传递给着色器， <strong>让我们</strong>回到<strong>Water.js</strong>并在initialize中定义时间变量： <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/////     this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br> 现在，要将变量传输到着色器，我们使用<code>material.setParameter</code> 。 首先，我们在<code>CreateWaterMaterial</code>函数的末尾设置初始值： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     this.shader = new pc.Shader(gd, shaderDefinition); //////////////   material.setParameter('uTime',this.time); this.material = material; //      //////////////// //      material.setShader(this.shader); return material;</span></span></code> </pre> <br> 现在，在<code>update</code>功能中，我们可以增加时间并使用为此创建的链接来访问资料： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.material.setParameter(<span class="hljs-string"><span class="hljs-string">'uTime'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time);</code> </pre> <br> 最后，在交换功能中，我们复制了旧时间值，以便即使更改代码后，它仍会继续增加而不会重置为0。 <br><br><pre> <code class="javascript hljs">Water.prototype.swap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">old</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = old.time; };</code> </pre> <br> 现在一切就绪。 运行游戏以确保没有错误。 现在，使用<code>Water.vert</code>的时间函数移动飞机： <br><br><pre> <code class="javascript hljs">pos.y += cos(uTime)</code> </pre> <br> 而且我们的飞机应该开始上下移动！ 由于我们现在有了交换功能，因此我们也可以更新Water.js，而无需重新启动。 为确保此方法有效，请尝试更改时间增量。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/9fe/64a/ae99fe64ab5d40e47e3760ac1dae1dd7.gif"></div><br><blockquote>  <em>任务4：是否可以移动顶点，使其看起来像下图中的波浪？</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1be/c55/056/1bec55056dc955769178773c2d58fe7c.gif"></div><br> 让我告诉你，我在这里详细研究了各种创建波浪的方法的主题。 本文与2D有关，但数学计算适用于我们的案例。 如果您只想查看解决方案，那么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">这里就是要点</a> 。 <br><br><h2> 半透明 </h2><br> 本部分的目的是创建半透明的水表面。 <br><br> 您可能会注意到，返回到Water.frag的颜色的alpha通道值为0.5，但是表面仍然保持不透明。 在许多情况下，透明度仍然是计算机图形学中尚未解决的问题。 解决该问题的一种低成本方法是使用混合。 <br><br> 通常，在绘制像素之前，它会检查<em>深度缓冲区中</em>的值，并将其与自己的深度值（其在Z轴上的位置）进行比较，以确定是否重绘屏幕的当前像素。 这样一来，您就可以正确渲染场景，而不必将对象放回到最前面。 <br><br> 混合时，我们可以将已经渲染的像素（目标）的颜色与将要绘制的像素（源）组合在一起，而不是简单地拒绝像素或覆盖。 可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">此处</a>找到WebGL中所有可用混合功能的列表。 <br><br> 为了使Alpha通道能够按照我们的期望工作，我们希望结果的组合颜色是源乘以Alpha通道再加上目标像素乘以一个负Alpha。 换句话说，如果alpha = 0.4，则最终颜色应具有一个值： <br><br><pre> <code class="javascript hljs">finalColor = source * <span class="hljs-number"><span class="hljs-number">0.4</span></span> + destination * <span class="hljs-number"><span class="hljs-number">0.6</span></span>;</code> </pre> <br> 在PlayCanvas中，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">pc.BLEND_NORMAL执行</a>的操作。 <br><br> 要启用它，只需在<code>CreateWaterMaterial</code>设置material属性： <br><br><pre> <code class="javascript hljs">material.blendType = pc.BLEND_NORMAL;</code> </pre> <br> 如果您现在开始游戏，那么水将变得半透明！ 但是，它仍然是不完善的。 如下图所示，当半透明表面叠加在其自身上时会出现问题。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/6b0/653/6df6b0653c6a86a4cd5d8b0500e22f04.png"></div><br> 我们可以通过使用<em>alpha覆盖率</em> （一种用于透明度的多重采样技术）代替混合来消除它： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//material.blendType = pc.BLEND_NORMAL; material.alphaToCoverage = true;</span></span></code> </pre> <br> 但是它仅在WebGL 2中可用。在本教程的其余部分中，为了简单起见，我将使用混合。 <br><br><h2> 总结一下 </h2><br> 我们设置环境，并使用来自顶点着色器的动画波创建水的半透明表面。 在本教程的第二部分中，我们将考虑对象的浮力，在水表面添加线条，并沿着与该表面相交的对象边界创建泡沫线。 <br><br> 在第三部分（最后）中，我们将考虑水下扭曲的后处理效果的应用，并考虑进一步改进的思路。 <br><br><h2> 源代码 </h2><br> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">这里</a>找到完成的PlayCanvas项目。 我们的存储库还在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">Three.js下</a>有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external">项目端口</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN416953/">https://habr.com/ru/post/zh-CN416953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN416943/index.html">设计语音接口的有用材料</a></li>
<li><a href="../zh-CN416945/index.html">正如我们做的BelAZ。 第1部分-铁</a></li>
<li><a href="../zh-CN416947/index.html">在奥运会之前玩游戏：电子竞技成为正式比赛</a></li>
<li><a href="../zh-CN416949/index.html">史蒂文先生的大规模升级安装了四倍的大型狩猎网络，现已完成</a></li>
<li><a href="../zh-CN416951/index.html">VPC服务中的Kubernetes集群</a></li>
<li><a href="../zh-CN416955/index.html">Elasticsearch的小技巧</a></li>
<li><a href="../zh-CN416959/index.html">苹果推出新的iOS防盗功能</a></li>
<li><a href="../zh-CN416961/index.html">使用操作转换自动解决冲突</a></li>
<li><a href="../zh-CN416963/index.html">正如我们做的BelAZ。 第2部分-实验室测试</a></li>
<li><a href="../zh-CN416967/index.html">正如我们做的BelAZ。 第3部分-分段调试</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>