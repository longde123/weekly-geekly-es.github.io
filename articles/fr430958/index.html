<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôãüèΩ üìé üåú Nous lan√ßons le conteneur avec des tests unitaires dans Azure DevOps (VSTS) üßëüèº‚Äçü§ù‚Äçüßëüèª üíÉüèº ü§∏üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avec l'av√®nement de .Net Core, nous avons une excellente occasion non seulement d'ex√©cuter notre code sur diff√©rents syst√®mes d'exploitation, mais aus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous lan√ßons le conteneur avec des tests unitaires dans Azure DevOps (VSTS)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430958/"> Avec l'av√®nement de .Net Core, nous avons une excellente occasion non seulement d'ex√©cuter notre code sur diff√©rents syst√®mes d'exploitation, mais aussi de le tester sur diff√©rents syst√®mes d'exploitation.  Et quoi de mieux que Docker lorsque vous travaillez avec diff√©rents syst√®mes d'exploitation? <br><img src="https://habrastorage.org/webt/uw/fg/nb/uwfgnb_uo5qtahy1y9xyxof4dpu.png"><a name="habracut"></a><br>  Les tests sont plus utiles lorsque vous n'avez aucune diff√©rence entre l'environnement de test et les environnements cibles.  Imaginez que vous preniez en charge votre application sur plusieurs syst√®mes d'exploitation ou versions d'un syst√®me d'exploitation.  Avec Docker, vous pouvez tester votre application dans chacun d'eux. <br><br>  Dans cet article, nous verrons comment cr√©er une image distincte dans laquelle les tests unitaires de votre application seront lanc√©s et configurer pour tout ce pipeline CI / CD dans VSTS qui est Azure DevOps r√©cemment. <cut></cut><br><br>  Si vous travaillez avec Docker, vous utilisez probablement des builds en plusieurs √©tapes pour construire vos conteneurs.  Dans ce cas, vous combinez la cr√©ation de binaires (en utilisant l'image de construction) et la cr√©ation de l'image finale (en utilisant l'image d'ex√©cution) dans le m√™me fichier Docker. <br><br>  Si votre syst√®me se compose d'un seul conteneur, dans ce cas, l'approche la plus courante peut √™tre d'ex√©cuter des tests dans le cadre du processus de cr√©ation de l'image finale.  Autrement dit, ex√©cuter des tests dans le Dockerfile. <br><br>  Pour ce faire dans un processus en plusieurs √©tapes, lorsque vous lancez la <code>docker build</code> vous ex√©cutez les tests comme une autre √©tape de la cr√©ation de l'image finale.  Regardons un exemple simple.  Disons que nous avons deux projets: les applications web et les tests unitaires: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jw/h6/uy/jwh6uyqb747mhfueifnwdlkirvm.png"></div><cut></cut><br>  Pour l'instant, ne nous inqui√©tons pas de ce que fait l'application Web.  D'un autre c√¥t√©, nous avons le seul test qui v√©rifie le comportement de <code>GuidProvider</code> et ressemble √† ceci: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Never_return_a_empty_guid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Arrange &amp; Act var provider = new GuidProvider(); var id = provider.Id; // Assert Assert.NotEqual(Guid.Empty, id); }</span></span></code> </pre> <br>  Cr√©ez maintenant un Dockerfile qui cr√©era l'image WebApplication et ex√©cutera les tests en m√™me temps: <br><br><pre> <code class="plaintext hljs">FROM microsoft/dotnet:2.1-aspnetcore-runtime AS base WORKDIR /app EXPOSE 80 FROM microsoft/dotnet:2.1-sdk AS build WORKDIR /src COPY CiCd.sln . COPY WebApplication/WebApplication.csproj WebApplication/ COPY WebApplication.Test/WebApplication.Test.csproj WebApplication.Test/ RUN dotnet restore COPY . . WORKDIR /src/WebApplication RUN dotnet build --no-restore -c Release -o /app FROM build as test WORKDIR /src/WebApplication.Test RUN dotnet test FROM build AS publish WORKDIR /src/WebApplication RUN dotnet publish --no-build -c Release -o /app FROM base AS final WORKDIR /app COPY --from=publish /app . ENTRYPOINT ["dotnet", "WebApplication.dll"]</code> </pre><br>  Ce Dockerfile doit √™tre plac√© dans un r√©pertoire avec un fichier de solution (iCd.sln).  Pour cr√©er une image, utilisez la commande: <br><br><pre> <code class="bash hljs">docker build -t webapplication .</code> </pre> <cut></cut><br>  Notre test √©choue (une erreur dans <code>GuidProvider</code> qui renvoie toujours <code>Guid.Empty</code> ), donc la construction de l'image √©chouera: <br><br><div class="spoiler">  <b class="spoiler_title">sortie</b> <div class="spoiler_text"><pre> <code class="bash hljs">Step 15/22 : RUN dotnet <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ---&gt; Running <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 423c27696356 Build started, please <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span>... Build completed. Test run <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> /src/WebApplication.Test/bin/Debug/netcoreapp2.1/WebApplication.Test.dll(.NETCoreApp,Version=v2.1) Microsoft (R) Test Execution Command Line Tool Version 15.9.0 Copyright (c) Microsoft Corporation. All rights reserved. Starting <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> execution, please <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span>... [xUnit.net 00:00:00.96] WebApplication.Test.GuidProviderTests.Never_return_a_empty_guid [FAIL] Failed WebApplication.Test.GuidProviderTests.Never_return_a_empty_guid Error Message: Assert.NotEqual() Failure Expected: Not 00000000-0000-0000-0000-000000000000 Actual: 00000000-0000-0000-0000-000000000000 Stack Trace: at WebApplication.Test.GuidProviderTests.Never_return_a_empty_guid() <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> /src/WebApplication.Test/GuidProviderTests.cs:line 17 Test Run Failed. Total tests: 1. Passed: 0. Failed: 1. Skipped: 0. Test execution time: 2.8166 Seconds The <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> <span class="hljs-string"><span class="hljs-string">'/bin/sh -c dotnet test'</span></span> returned a non-zero code: 1</code> </pre> </div></div><cut></cut><br>  Voyons maintenant comment d√©marrer ce processus dans Azure DevOps. <br><br>  Notre d√©finition de build pour le moment est une t√¢che de type Docker: <br><br><img src="https://habrastorage.org/webt/nc/ef/pf/ncefpfgqxsbt6pewrknrer6iqg4.png"><br><br>  √Ä la suite du lancement, la version √©choue car notre test √©choue.  De plus, nous n'avons pas de r√©sultats de test (l'onglet "Test" est vide), car le test n'est pas effectu√© dans la compr√©hension de VSTS: <br><br><img src="https://habrastorage.org/webt/vf/_u/bi/vf_ubic9-ecav4qtz0zhp9ylpz0.png"><br><br>  L'ex√©cution de tests dans le cadre d'un assemblage d'images n'est pas enti√®rement mauvaise, mais elle emp√™chera VSTS de savoir quel a √©t√© le r√©sultat.  Cela est d√ª √† la ¬´limitation¬ª de Docker, qui ne permet pas de cr√©er des volumes pendant la <code>docker build</code> , par cons√©quent, nous ne pouvons pas fournir un fichier avec les r√©sultats des tests (qui peuvent √™tre g√©n√©r√©s √† l'aide <code>dotnet test</code> ), ce fichier reste dans un conteneur interm√©diaire, et nous ne pouvons pas facilement l'obtenir lui de l√†. <cut></cut><br><br>  Nous adopterons une approche diff√©rente et utiliserons une excellente alternative √† la <code>docker run</code> .  Tout d'abord, levons un conteneur s√©par√© et ex√©cutons les tests qu'il contient.  Pour les deux conteneurs, nous pouvons utiliser le m√™me Dockerfile.  Tout d'abord, nous devons supprimer la ligne qui ex√©cute le <code>dotnet test</code> du Dockerfile, car nous allons maintenant les ex√©cuter s√©par√©ment.  Ok, utilisons maintenant la <code>docker run</code> , qui vous permet d'ex√©cuter le Dockerfile √† un point sp√©cifique.  Dans notre cas, c'est la phase de test: <br><br><pre> <code class="bash hljs">docker build -t webapplication-tests . --target <span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre> <br>  Le param√®tre <code>-target</code> indique quelle √©tape assembler.  Veuillez noter que l'image g√©n√©r√©e sera appel√©e " <b>webapplication-tests</b> ".  Nous pouvons maintenant ex√©cuter nos tests et enregistrer le fichier " <b>test-results.trx</b> " avec les r√©sultats de leur ex√©cution dans le r√©pertoire " <b>tests</b> " du conteneur: <br><br><pre> <code class="bash hljs">docker run -v/c/tests:/tests webapplication-tests --entrypoint <span class="hljs-string"><span class="hljs-string">"dotnet test --logger trx;LogFileName=/tests/test-results.trx"</span></span></code> </pre> <br>  Ici, nous ex√©cutons l'image cr√©√©e √† l'√©tape pr√©c√©dente, et √† travers cela, nous mappons le r√©pertoire " <b>tests</b> " du conteneur vers le r√©pertoire h√¥te (dans mon cas D: \ CiCD \ tests).  Par cons√©quent, j'ai obtenu les r√©sultats des tests dans D: \ CiCD \ tests. <br><br>  Afin de construire l'image finale, ex√©cutez: <br><br><pre> <code class="bash hljs">docker build -t webapplication .</code> </pre> <br>  L'avantage est que gr√¢ce au mod√®le de niveau Docker, il n'est pas n√©cessaire de r√©ex√©cuter toutes les autres √©tapes (c'est-√†-dire qu'il n'est pas n√©cessaire de recompiler l'application). <br><br>  Eh bien, appliquons maintenant tout cela aux pipelines Azure DevOps.  Pour simplifier l'assemblage et √©viter un grand nombre de param√®tres, nous utiliserons docker-compose.  Notre docker-compose.yml a le contenu suivant: <br><br><pre> <code class="plaintext hljs">version: '3.5' services: webapplication: image: webapplication build: context: . dockerfile: Dockerfile webapplication-tests: image: webapplication-tests build: context: . dockerfile: Dockerfile target: test</code> </pre><cut></cut><br>  Nous d√©finissons ici deux images (webapplication et webapplication-tests).  Pour que tout soit conforme au canon, ajoutons le fichier docker-compose.override.yml: <br><br><pre> <code class="plaintext hljs">version: '3.5' services: webapplication: environment: - ASPNETCORE_ENVIRONMENT=Development ports: - "8080:80" webapplication-tests: entrypoint: - dotnet - test - --logger - trx;LogFileName=/tests/test-results.trx volumes: - ${BUILD_ARTIFACTSTAGINGDIRECTORY:-./tests/}:/tests</code> </pre><br>  G√©nial, maintenant, pour ex√©cuter les tests, il nous suffit de: <br><br><pre> <code class="bash hljs">docker-compose run webapplication-tests</code> </pre> <br>  Cette commande ex√©cute les tests et cr√©e le fichier trx de sortie dans le r√©pertoire sp√©cifi√© par la variable d'environnement <code>BUILD_ARTIFACTSTAGINGDIRECTORY</code> ou la valeur par d√©faut <code>./tests</code> .  L'image finale se fait comme ceci: <br><br><pre> <code class="bash hljs">docker-compose build webapplication</code> </pre> <br>  Vous pouvez maintenant modifier notre processus CI dans Azure DevOps.  Pour ce faire, nous d√©finissons les √©tapes suivantes: <br><br><ol><li>  Collectionnez toutes les images [build] </li><li>  Ex√©cuter des tests unitaires [ex√©cuter] </li><li>  Publier le r√©sultat du test [publier] </li><li>  Ex√©cuter des images dans le r√©f√©rentiel (registre) [push] </li></ol><br>  Commen√ßons par la premi√®re √©tape, qui est la t√¢che Docker Compose (t√¢che) dans Azure: <br><br><img src="https://habrastorage.org/webt/c5/yj/gm/c5yjgmookbcql36fwe6k4xc_waw.png"><br><br>  Nous avons mis <code>Action: Build service images</code> et sp√©cifier le chemin d'acc√®s √† docker-compose.yml. <br><br>  Ensuite, ex√©cutez le conteneur avec des tests unitaires: <br><br><img src="https://habrastorage.org/webt/ls/fh/e4/lsfhe4ghplqn3acy6da7zk4j3sc.png"><br><br>  Ici, vous devez s√©lectionner <code>Action: Run a specific service image</code> et sp√©cifier le nom du conteneur Nom du <code>Service Name: webapplication-tests</code> .  N'oubliez pas non plus le chemin d'acc√®s √† docker-compose.yml et docker-compose.override.yml.  La valeur de <code>Run in Background</code> ne doit pas √™tre d√©finie, sinon le conteneur d√©marrera en "mode d√©tach√©" et la t√¢che n'attendra pas les r√©sultats des tests et passera √† l'√©tape suivante.  La t√¢che de publication des r√©sultats de test tentera de publier des r√©sultats qui ne sont peut-√™tre pas encore disponibles, car l'ex√©cution des tests prend du temps. <cut></cut><br><br>  La troisi√®me √©tape est ¬´Publier les r√©sultats des tests¬ª: <br><br><img src="https://habrastorage.org/webt/nz/qb/uy/nzqbuyet5qaksri-jy2wqeqrjxk.png"><br><br>  <b>Il est important</b> de sp√©cifier <code>Run this task: Even if a previous task has failed, unless the build was canceled</code> .  Cette option est importante car sinon les r√©sultats ne seront jamais publi√©s si les tests √©chouent. <code>Search folder: $(Build.ArtifactStagingDirectory)</code> <br><br>  La derni√®re √©tape consistera √† pousser les images dans le stockage.  Pour ce faire, sp√©cifiez l'abonnement Azure, ainsi que le registre de conteneurs Azure.  Tout est pr√™t pour cr√©er une nouvelle construction.  Enregistrez.  Nous commen√ßons.  Si les tests √©chouent, la construction √©chouera, mais maintenant nous voyons les r√©sultats dans VSTS: <br><br><img src="https://habrastorage.org/webt/l8/cm/yj/l8cmyj0fl-sjayqh1t4lxncg-ps.png"><br><br>  J'esp√®re que ce mat√©riel a √©t√© utile.  Vous pouvez trouver mon fichier yml de configuration d'assemblage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430958/">https://habr.com/ru/post/fr430958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430948/index.html">Le minist√®re des Communications propose de renforcer le contr√¥le des donn√©es personnelles</a></li>
<li><a href="../fr430950/index.html">Faire une construction moderne</a></li>
<li><a href="../fr430952/index.html">Les voitures √©lectriques et les voitures hybrides devront √©mettre des sons suppl√©mentaires: pourquoi est-ce n√©cessaire</a></li>
<li><a href="../fr430954/index.html">Qt Everywhere: WebAssembly et WebGL Streaming</a></li>
<li><a href="../fr430956/index.html">Nous apprenons √† un cochon sur les mono√Ødes √† croire en lui et √† voler</a></li>
<li><a href="../fr430960/index.html">√Ä propos de gamedev √† partir d'une exposition sur ordinateur</a></li>
<li><a href="../fr430962/index.html">Prise en charge de Razor dans Visual Studio Code</a></li>
<li><a href="../fr430964/index.html">Pens√©e d√©clarative</a></li>
<li><a href="../fr430966/index.html">Sprints g√©n√©raux chez Atlassian Jira Software</a></li>
<li><a href="../fr430968/index.html">"L'esprit est en ligne." Les drones sont partout</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>