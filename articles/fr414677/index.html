<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∂üèº üçÅ üë©üèæ‚Äçü§ù‚Äçüë®üèø Commandes rapides Siri ‚úçüèº üö∂üèø ‚ú°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'une des fonctionnalit√©s utiles (√† mon avis) d'iOS 12 introduites lors de la WWDC 2018 est Siri Shortcuts . 


 Raccourci ( raccourci ) - une command...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Commandes rapides Siri</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/414677/"><p><img src="https://habrastorage.org/webt/ge/mr/un/gemrunsbwx7gf07v5htwy9lytpu.png"></p><br><p>  L'une des fonctionnalit√©s utiles (√† mon avis) d'iOS 12 introduites lors de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://">WWDC 2018</a> est <strong>Siri Shortcuts</strong> . </p><br><p>  Raccourci ( <em>raccourci</em> ) - une commande rapide, un moyen rapide d'effectuer toute action en contournant le script standard. </p><br><p>  Dans vos applications, vous pouvez cr√©er des raccourcis pour certaines actions.  Apprenant comment et quand l'utilisateur les met en ≈ìuvre, Siri commence intelligemment, au bon moment et au bon endroit, pour lui offrir ces raccourcis et, mieux encore, l'utilisateur peut les appeler avec des phrases qu'il leur attachera!  Sous le chat plus. </p><a name="habracut"></a><br><h2 id="kak-eto-rabotaet">  Comment √ßa marche </h2><br><p>  Nous utilisons des applications qui, avec certaines actions, cr√©ent et fournissent des raccourcis au syst√®me. </p><br><p>  Vous pouvez afficher ces raccourcis dans <strong>Param√®tres ‚Üí Siri et Rechercher</strong> . <br><img src="https://habrastorage.org/webt/vp/z2/fd/vpz2fdo_rakpjpl-imiuvzkbyly.png"><br>  La capture d'√©cran ci-dessus montre les trois derniers raccourcis que le syst√®me a d√©tect√©s dans diff√©rentes applications.  Si nous cliquons sur le bouton ¬´Plus de raccourcis¬ª, nous verrons tous les raccourcis fournis au syst√®me par chaque application. </p><br><p>  Avec certains param√®tres dans le code de cr√©ation de raccourci, Siri offrira ces raccourcis √† l'utilisateur sur l'√©cran verrouill√©, dans le centre de notification et de recherche, en se concentrant sur la fr√©quence √† laquelle nous utilisons ces actions, √† quelle heure, sur quels jours de la semaine et o√π √† d'autres facteurs. </p><br><p>  Par exemple, si le vendredi soir vous cherchez habituellement des distributeurs automatiques de billets, apr√®s vous √™tre entra√Æn√©, Siri vous proposera un raccourci avec cette action le vendredi soir. </p><br><p><img src="https://habrastorage.org/webt/ef/my/gu/efmyguxaczsetehquug_nyp7vnc.png"></p><br><p>  Nous pouvons ajouter notre commande vocale √† chaque raccourci en cliquant sur l'ic√¥ne " <strong>+</strong> ". </p><br><p>  Nous disons une commande vocale, appuyez sur "Termin√©", et maintenant nous pouvons effectuer l'action derri√®re le raccourci en utilisant la voix via Siri.  <em>Il s'av√®re que l'utilisateur pourra ex√©cuter les fonctionnalit√©s de votre application via Siri sans ouvrir l'application elle-m√™me.</em>  Le raccourci avec la phrase est conserv√© dans "Mes raccourcis". </p><br><h2 id="sozdanie-shortkatov">  Cr√©ation de raccourcis </h2><br><p> Pour le d√©veloppement, nous aurons besoin de Xcode 10 et iOS 12. Au moment de la r√©daction, les deux sont au stade <strong>b√™ta</strong> . </p><br><p> Un raccourci peut √™tre cr√©√© via <code>NSUserActivity</code> ou via <code>Intent</code> . </p><br><p>  Le premier cas: </p><br><p>  L'utilisateur clique sur le raccourci, qui transmet la commande avec les param√®tres ( <code>NSUserActivity</code> ) √† notre application, et il d√©cide comment cette commande doit √™tre trait√©e (ouvrez la fen√™tre du taux USD actuel, ou la fen√™tre de commande de notre pizza pr√©f√©r√©e).  C'est le bon vieux raccourci Spotlight que nous connaissons tous, mais intelligemment propos√© par Siri. </p><br><p>  Deuxi√®me cas: </p><br><p>  Les raccourcis cr√©√©s via <code>Intent</code> plus int√©ressants - ils vous permettent d'ex√©cuter une commande imm√©diatement dans l'interface Siri sans lancer votre application.  Auparavant, l'ensemble des <code>Intent</code> √©tait difficile pour Apple: transf√©rer de l'argent, envoyer des messages et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autres</a> .  Maintenant, nous, les d√©veloppeurs, avons la possibilit√© de cr√©er nos <code>Intent</code> ! </p><br><p>  Quelle que soit la fa√ßon dont le raccourci a √©t√© cr√©√©, il passe par 3 √©tapes du cycle de vie: </p><br><ol><li>  Annonce ( <strong><em>d√©finir</em></strong> ) </li><li>  Livraison au syst√®me ( <strong><em>Faire un don</em></strong> ) </li><li>  Traitement par application ( <strong><em>Handle</em></strong> ) </li></ol><br><p><img src="https://habrastorage.org/webt/ie/7b/6z/ie7b6zoy5fd9mkx5ivjddp0agxc.png"></p><br><p>  Mes recherches ont montr√© qu'une application ne peut pas fournir plus de 20 raccourcis au syst√®me. </p><br><p>  De plus, nous examinerons comment donner √† notre application la possibilit√© de cr√©er des raccourcis et comment travailler avec eux √† l'int√©rieur. </p><br><h2 id="sozdanie-shortkatov-cherez-nsuseractivity">  Cr√©ation de raccourcis via <code>NSUserActivity</code> </h2><br><p>  Analysons le premier type simple de raccourcis qui s'ouvrent via <code>NSUserActivity</code> . </p><br><p>  Par exemple, dans l'application de banque mobile, nous avons un √©cran de recherche de guichets automatiques et je les cherche souvent.  Pour acc√©der √† l'√©cran avec une carte ATM, je dois lancer l'application, aller dans l'onglet ¬´Plus¬ª de l'onglet, s√©lectionner la section ¬´Info¬ª et cliquer sur le bouton ¬´ATM¬ª. <br>  Si nous cr√©ons un raccourci qui m√®ne imm√©diatement √† cet √©cran, l'utilisateur pourra y acc√©der d'une seule touche lorsque Siri le lui proposera, par exemple, sur un √©cran verrouill√©. </p><br><h3 id="obyavlyaem-shortkat-declare">  D√©clarer un raccourci </h3><br><p>  La premi√®re √©tape consiste √† d√©clarer un type comme notre <code>NSUserActivity</code> (on peut dire que c'est son identifiant) dans <em>info.playlist</em> : </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSUserActivityTypes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>ru.tinkoff.demo.show-cashMachine<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Annonc√©. </p><br><h3 id="dostavlyaem-shortkat-v-sistemu-donate">  Fournir le raccourci vers le syst√®me (faire un don) </h3><br><p>  Apr√®s la d√©claration, nous pouvons cr√©er <code>NSUserActivity</code> dans le code de notre application avec le type que nous avons d√©fini ci-dessus dans <strong>info.playlist</strong> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> activity = NSUserActivity(activityType: <span class="hljs-string"><span class="hljs-string">"ru.tinkoff.demo.show-cashMachine"</span></span>)</code> </pre> <br><p>  Pour que l'activit√© entre dans la liste des raccourcis du syst√®me, elle doit √™tre d√©finie sur <code>title</code> et d√©finir la propri√©t√© <code>isEligibleForSearch</code> sur <code>true</code> .  D'autres propri√©t√©s ne sont pas n√©cessaires pour l'ajout aux raccourcis, mais leur pr√©sence rend le raccourci plus lisible et convivial. </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   (     ,   ) activity.title = " " if #available(iOS 12.0, *) { // ,             activity.suggestedInvocationPhrase = "  " //           activity.isEligibleForPrediction = true // (     ,   ) activity.isEligibleForSearch = true } //       let attributes = CSSearchableItemAttributeSet(itemContentType: "NSUserActivity.searchableItemContentType") ///    if let image = UIImage(named: "siriAtmIcon") { attributes.thumbnailData = UIImagePNGRepresentation(image) } ///   attributes.contentDescription = "     " ///     activity.contentAttributeSet = attributes</span></span></code> </pre> <br><p>  Feu!  <code>NSUserActivity</code> est, pour le livrer au syst√®me, il reste √† faire la derni√®re √©tape. </p><br><p>  <code>ViewConroller</code> poss√®de une propri√©t√© <code>userActivity</code> , √† laquelle nous devons affecter l' <code>activity</code> cr√©√©e ci-dessus: </p><br><pre> <code class="javascript hljs">self.userActivity = activity</code> </pre> <br><p>  D√®s que cette ligne est ex√©cut√©e, un raccourci sera cr√©√© √† partir de cette activit√©.  Il sera livr√© au syst√®me et affich√© dans les param√®tres Siri ( <strong>Param√®tres ‚Üí Siri et Rechercher</strong> ).  Siri pourra alors l'offrir √† l'utilisateur, et l'utilisateur pourra lui attribuer sa commande vocale. </p><br><p>  <em><strong>Remarque</strong> : la documentation Apple indique qu'au lieu d'affecter une activit√© au contr√¥leur de vue, il suffit d'appeler la m√©thode <code>becomeCurrent()</code> sur l' <code>becomeCurrent()</code> .</em>  <em>Cependant, cette action n'a pas fourni d'activit√© √† mon syst√®me et le raccourci n'apparaissait pas dans la liste</em> </p><br><blockquote>  Ensuite, appelez la m√©thode <code>becomeCurrent()</code> sur l'objet d'activit√© utilisateur pour le marquer comme courant, ce qui donne l'activit√© √† Siri.  Vous pouvez √©galement attacher l'objet √† un objet UIViewController ou UIResponder, qui marque √©galement l'activit√© comme actuelle. </blockquote><p>  Pour v√©rifier que tout a fonctionn√©, ouvrez <strong>Param√®tres&gt; Siri et recherchez</strong> - le raccourci bas√© sur notre activit√© devrait √™tre dans la liste. </p><br><h3 id="obrabotka-shortkata-prilozheniem-handle">  Traitement des raccourcis par application (poign√©e) </h3><br><p>  Lorsqu'un utilisateur navigue dans le raccourci depuis le centre de notifications ou l'active par la voix, l'application d√©marre et nous devons traiter ce raccourci. </p><br><p>  <code>activity</code> lanc√©e dans <code>AppDelegate</code> 'une m√©thode: </p><br><pre> <code class="javascript hljs">func application(_ application: UIApplication, <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> userActivity: NSUserActivity, <span class="hljs-attr"><span class="hljs-attr">restorationHandler</span></span>: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> userActivity.activityType == <span class="hljs-string"><span class="hljs-string">"ru.tinkoff.demo.show-cashMachine"</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,     handleShowCashMachineActivity() return true } return false }</span></span></code> </pre> <br><h3 id="itogo">  Total </h3><br><p>  Un <code>NSUserActivity</code> NSUserActivity est cr√©√© comme suit: </p><br><ol><li>  D√©clarez le type (identifiant) de <code>NSUserActivity</code> dans <code>NSUserActivity</code> . </li><li>  Nous cr√©ons <code>NSUserActivity</code> dans le code et nous configurons </li><li>  <code>viewController'</code> . </li></ol><br><h2 id="sozdanie-golosovyh-komand-iz-prilozheniya">  Cr√©ation de commandes vocales √† partir d'une application </h2><br><p>  Ainsi, si l'utilisateur ouvre <strong>Param√®tres&gt; Siri et recherche</strong> , il verra une liste de ses raccourcis, qui ont √©t√© cr√©√©s par diverses applications, dont la n√¥tre.  En cliquant sur le ¬´ <strong>+</strong> ¬ª, l'utilisateur peut cr√©er n'importe quelle commande vocale et l'associer au raccourci s√©lectionn√©.  Cependant, chaque fois que la saisie des param√®tres est g√™nante pour l'utilisateur, beaucoup ne r√©alisent m√™me pas cette possibilit√©. </p><br><p>  C'est cool que vous puissiez attacher une commande vocale √† une action sp√©cifique directement dans l'application. </p><br><p>  Supposons qu'un utilisateur effectue une action, qu'elle soit livr√©e au syst√®me, il veut la sauvegarder.  Nous pouvons ajouter le bouton ¬´ <em>ajouter une action √† Siri</em> ¬ª (vous pouvez nommer et dessiner le bouton comme vous le souhaitez) sur l'√©cran de notre application, puis l'utilisateur, en cliquant dessus, pourra associer cette action √† une commande vocale depuis l'application sans entrer dans les param√®tres. </p><br><p>  En cliquant sur le bouton, vous devez ouvrir de fa√ßon modale l'√©cran pour ajouter une commande vocale √† un raccourci dans Siri <code>INUIAddVoiceShortcutViewController</code> , ou l'√©cran pour modifier une commande vocale <code>INUIEditVoiceShortcutViewController</code> , s'il en a d√©j√† √©t√© cr√©√© un.  L' <code>action</code> n'ayant pas r√©agi <code>action</code> un tel bouton sera approximativement la suivante: </p><br><pre> <code class="hljs julia"> <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> func addToSiriAction() { // <span class="hljs-number"><span class="hljs-number">1.</span></span>   ,       INVoiceShortcutCenter.shared.getAllVoiceShortcuts { (shortcuts, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> guard error == nil, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcuts = shortcuts <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // TODO: Handle error <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } // <span class="hljs-number"><span class="hljs-number">2.</span></span>     ,      <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> donatedShortcut: INVoiceShortcut? = shortcuts.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { (shorcut) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shorcut.__shortcut.userActivity?.activityType == <span class="hljs-string"><span class="hljs-string">"com.ba"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcut = donatedShortcut { // <span class="hljs-number"><span class="hljs-number">3.</span></span>     -     . //         <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> editVoiceShortcutViewController = INUIEditVoiceShortcutViewController(voiceShortcut: shortcut) editVoiceShortcutViewController.delegate = self self.present(editVoiceShortcutViewController, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: nil) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // <span class="hljs-number"><span class="hljs-number">4.</span></span>         <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcut = INShortcut(userActivity: self.userActivity!) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> addVoiceShortcutViewController = INUIAddVoiceShortcutViewController(shortcut: shortcut) addVoiceShortcutViewController.delegate = self } } }</code> </pre> <br><p>  Ainsi, les √©crans pour ajouter et modifier une commande vocale pour le raccourci Siri ressemblent: </p><br><p><img src="https://habrastorage.org/webt/ez/lk/ai/ezlkaihh3q9gvj4syqkizbwqy4c.png"></p><br><p>  Nous devons √©galement impl√©menter les m√©thodes d√©l√©gu√©es de ces viewControllers, dans lesquelles ils doivent masquer le <code>dismiss(animated: true, completion: nil)</code> et, si n√©cessaire, mettre √† jour l'√©cran actuel.  Par exemple, s'il y avait un bouton ¬´ajouter une commande vocale¬ª sur l'√©cran plus t√¥t, alors apr√®s avoir ajout√© une commande vocale, ce bouton devrait soit dispara√Ætre, soit passer √† ¬´modifier la commande vocale¬ª. </p><br><h2 id="shortkaty-sozdannye-pri-pomoschi-intent">  Raccourcis d'intention </h2><br><p>  Jusqu'√† pr√©sent, nous n'avons parl√© que de raccourcis qui ouvrent une application et y transmettent <code>NSUserActivity</code> donn√©es √† <code>NSUserActivity</code> . </p><br><p>  Mais revenons aux raccourcis cr√©√©s via <code>Intent</code> , qui vous permettent d'effectuer certaines actions sans ouvrir l'application.  Ici, le plaisir commence. </p><br><p>  Imaginez qu'un utilisateur commande sa pizza pr√©f√©r√©e.  Il le commandera plusieurs fois quand il le voudra, et il a m√™me ajout√© une commande vocale au raccourci de cette pizza - et cela lui simplifie la vie.  Mais nous pouvons faire plus pour lui - nous pouvons nous assurer qu'en donnant la commande vocale Siri, le syst√®me ne la jette pas dans l'application, mais affiche imm√©diatement les informations de commande et les commandes de pizza dans l'interface Siri!  C'est juste le cas lorsque l'utilisateur n'a pas besoin d'ouvrir l'application elle-m√™me pour effectuer une action. </p><br><p>  Tout d'abord, acc√©dez aux param√®tres du projet, s√©lectionnez la cible principale, l'onglet <code>Capabilities</code> et activez l'acc√®s √† Siri. </p><br><p>  Notre application peut interagir avec Siri, mais cela ne se produit pas dans le code principal de l'application, mais dans une extension cible distincte <strong>Intents Extensions</strong> </p><br><p>  Pour commencer, cette cible doit √™tre cr√©√©e: <strong>Fichier ‚Üí Nouveau ‚Üí Cible</strong> , s√©lectionnez <strong>Intentions Extensions</strong> .  Xcode vous proposera de cr√©er une autre extension cible pour la fen√™tre affichant vos actions dans Siri, si cela est n√©cessaire, nous sommes d'accord. </p><br><p><img src="https://habrastorage.org/webt/ia/o_/pp/iao_pphchyfpr33hj6jluyy-ozc.jpeg"></p><br><h3 id="obyavlyaem-shortkat-declare-1">  D√©clarer un raccourci </h3><br><p>  La principale innovation de SiriKit dans iOS 12 est la possibilit√© de cr√©er vos <code>Inetnts</code> , √† ceux qui √©taient plus t√¥t. </p><br><p><img src="https://habrastorage.org/webt/5a/66/6m/5a666mqkcm0li-cujpl7yexzrgm.png"></p><br><p>  Pour ce faire, cr√©ez un nouveau fichier: <strong>Fichier ‚Üí Nouveau ‚Üí Fichier</strong> , en s√©lectionnant <strong>Fichier</strong> de <strong>d√©finition d'intention SiriKit</strong> dans la section <strong>Ressources</strong> . </p><br><p><img src="https://habrastorage.org/webt/qz/8l/lx/qz8llxznc1o05palhxxxcskrcbq.png"></p><br><p>  En cons√©quence, un fichier avec l'extension <em>.intentdefinition appara√Æt</em> , dans lequel vous pouvez cr√©er vos propres <code>Intents</code> .  Nous ouvrons le fichier, et l√† o√π il est dit " <strong>Pas d'intention</strong> " en bas, il y a une ic√¥ne " <strong>+</strong> " - cliquez dessus.  " <strong>Nouvelle intention</strong> ".  Une intention appara√Ætra dans la liste √† laquelle vous pouvez ajouter des param√®tres.  Dans le cas d'une commande de pizza, vous pouvez ajouter le nombre de pizzas et le type de pizza √† commander comme param√®tres.  Pour la quantit√©, nous choisissons le type <code>Integer</code> et pour le type de pizza, nous s√©lectionnons le type <code>Custom</code> , qui dans le code sera repr√©sent√© par la classe <code>INObject</code> . </p><br><p>  Maintenant quelques lignes de frustration: </p><br><p>  <strong>L'utilisateur ne pourra pas transmettre diff√©rents param√®tres √† la m√™me commande vocale enregistr√©e.</strong>  <strong>H√©las!</strong> </p><br><p><img src="https://habrastorage.org/webt/kn/z4/y-/knz4y-oo1kns8ehvzoojslxqycq.jpeg"></p><br><p>  Quels sont les param√®tres pour: </p><br><p>  Supposons que vous cr√©ez une entit√© "Show rate <code>%currency</code> ", o√π la <code>currency</code> est un param√®tre d'entit√©.  Cela ne signifie pas que l'utilisateur peut dire les phrases "Afficher le taux de change du dollar", "Afficher le taux de change Bitcoin", etc.  Hors de la bo√Æte, cela ne fonctionnera pas comme √ßa.  Mais cela signifie que si l'utilisateur a regard√© le taux de change du dollar, le raccourci "Afficher le taux USD" a √©t√© cr√©√©, puis lorsqu'il a regard√© le taux de change Bitcoin, le raccourci "Afficher le taux BTC" a √©t√© cr√©√©, etc.  En d'autres termes, il peut avoir plusieurs shorkatas bas√©s sur la m√™me intention, mais avec des param√®tres diff√©rents.  Chacun des raccourcis, l'utilisateur pourra demander sa commande vocale. </p><br><p>  Eh bien, en cr√©ant une intention dans le fichier <em>.intentdefinition</em> , <em>Xcode</em> g√©n√©rera automatiquement une classe pour cette intention (remarque: elle n'appara√Ætra pas dans les fichiers de projet, mais sera disponible pour utilisation). Ce fichier g√©n√©r√© automatiquement ne se trouvera que dans les cibles qui ont le fichier <em>.intentdefinition</em> . </p><br><p>  Apr√®s avoir cr√©√© l'intention dans le fichier .intentdefinition <em>,</em> nous pouvons cr√©er nos intentions dans le code. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intent = <span class="hljs-type"><span class="hljs-type">OrderPizzaIntent</span></span>()</code> </pre> <br><h3 id="dostavlyaem-shortkat-v-sistemu-donate-1">  Fournir le raccourci vers le syst√®me (faire un don) </h3><br><p>  Pour que cette entit√© soit incluse dans la liste des raccourcis, vous devez l'int√©grer.  Pour ce faire, un objet <code>INInteraction</code> est cr√©√© avec une instance de votre intention et la m√©thode .donate est appel√©e sur cette <code>.donate</code> </p><br><pre> <code class="hljs lua">let intent = OrderPizzaIntentf() // ...   let interaction = INInteraction(intent: intent, response: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) interaction.donate { (<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> // ...   /  }</code> </pre> <br><p>  Apr√®s avoir ex√©cut√© ce code, le raccourci bas√© sur l'intention sera fourni au syst√®me et affich√© dans les param√®tres Siri. </p><br><h3 id="obrabatyvaem-shortkat-prilozheniem-handle">  Nous traitons l'application de raccourci (Handle) </h3><br><p>  L'√©tape suivante consiste √† traiter l'intention lorsque l'utilisateur clique dessus dans le sirjest du Siri ou l'appelle avec une commande vocale. </p><br><p>  Nous avons d√©j√† cr√©√© une extension cible pour Siri et elle a une classe IntentHandler pr√©-cr√©√©e, qui a une seule m√©thode - `` g√©rer (pour l'intention) '' </p><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntentHandler</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INExtension</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> intent: INIntent)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Any</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> intent <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">OrderPizzaIntent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Unhandled intent type: \(intent)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">OrderPizzaIntentHandler</span></span>() } }</code> </pre> <br><blockquote>  Remarque: Si le compilateur ne voit pas la classe de votre intention, vous n'avez pas ajout√© le fichier d'extension cible <em>.intentdefinition</em> pour Siri. </blockquote><p>  Dans cette m√©thode, nous d√©terminons le type d'intention entrante et pour chaque type, nous cr√©ons un objet gestionnaire qui traitera cette intention.  Cr√©ez un gestionnaire pour notre <code>OrderPizzaIntent</code> et impl√©mentez-y le protocole <code>OrderPizzaIntentHandling</code> , qui est d√©j√† g√©n√©r√© automatiquement apr√®s la cr√©ation de votre intention dans <em>.intentdefinition</em> . </p><br><p>  Le protocole contient deux m√©thodes de <code>confirm</code> et de <code>handle</code> .  Tout d'abord, <code>confirm</code> est appel√© o√π toutes les donn√©es sont v√©rifi√©es et la disponibilit√© de l'action est v√©rifi√©e.  Ensuite, la <code>handle</code> fonctionnera en une courte action √† effectuer. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderPizzaIntentHandler</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderPizzaIntentHandling</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">confirm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(intent: OrderPizzaIntent, completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(OrderPizzaIntentResponse)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      // ... completion(OrderPizzaIntentResponse(code: OrderPizzaIntentResponseCode.ready, userActivity: nil)) } public func handle(intent: OrderPizzaIntent, completion: @escaping (OrderPizzaIntentResponse) -&gt; Void) { //     // ... completion(OrderPizzaIntentResponse(code: OrderPizzaIntentResponseCode.success, userActivity: nil)) } }</span></span></code> </pre> <br><p>  Ces deux m√©thodes doivent d√©finitivement appeler la <code>completion</code> avec la r√©ponse <code>OrderPizzaIntentResponse</code> (elle est √©galement g√©n√©r√©e automatiquement), sinon Siri attendra juste longtemps et donnera une erreur. </p><br><h3 id="bolee-podrobnye-otvety-ot-siri">  Des r√©ponses plus d√©taill√©es de Siri </h3><br><p>  Il existe un ensemble standard de codes de r√©ponse g√©n√©r√©s automatiquement - <code>enum OrderPizzaIntentResponseCode</code> , mais ils peuvent ne pas √™tre suffisants pour une interface conviviale.  Par exemple, au stade de la <code>confirm</code> , plusieurs erreurs diff√©rentes peuvent se produire - la pizza est √©puis√©e, la pizzeria ne fonctionne pas pour le moment, etc.  et l'utilisateur doit se renseigner sur ces faits, au lieu du message standard "Erreur d'application".  N'oubliez pas que nous avons cr√©√© <code>Intent</code> dans le fichier <em>.intentdefinition</em> ?  Avec l'intention elle-m√™me, sa <code>Response</code> dans laquelle vous pouvez ajouter vos propres options d'erreurs et de r√©ponses r√©ussies, et les configurer avec les param√®tres: </p><br><p><img src="https://habrastorage.org/webt/xz/zg/fa/xzzgfawljagfnruxp_zjjdeug2m.png"></p><br><p>  Maintenant, nous pouvons dire √† l'utilisateur des erreurs et des r√©ponses plus informatives: </p><br><pre> <code class="hljs lua">public func confirm(intent: OrderPizzaIntent, completion: @escaping (OrderPizzaIntentResponse) -&gt; Void) { guard let pizzaKindId = intent.kind?.identifier <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //         -     completion(OrderPizzaIntentResponse(code: .failure, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pizzeriaManager.isPizzeriaClosed == <span class="hljs-literal"><span class="hljs-literal">true</span></span> { ///     -     completion(OrderPizzaIntentResponse(code: .failurePizzeriaClosed, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pizzeriaManager.menu.isPizzaUnavailable(identifier: pizzaKindId) { ///      -     completion(OrderPizzaIntentResponse(code: .failurePizzaUnavailable(kind: intent.kind), userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } //     -    completion(OrderPizzaIntentResponse(code: .ready, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) }</code> </pre> <br><h3 id="otrisovka-intenta">  Rendu <code>Intent</code> </h3><br><p>  Si nous avons cr√©√© une <strong>extension</strong> cible d' <strong>interface utilisateur d'extension d'intention</strong> , nous pouvons dessiner une vue personnalis√©e dans Siri pour les intentions dont nous avons besoin.  Nous avons <code>MainInterface.storyboard</code> et <code>IntentViewController</code> dans lesquels nous pouvons esquisser leur conception.  Ce contr√¥leur de vue impl√©mente le protocole INUIHostedViewControlling et la vue est <code>configureView</code> dans la m√©thode <code>configureView</code> </p><br><pre> <code class="hljs sql">// <span class="hljs-keyword"><span class="hljs-keyword">Prepare</span></span> your <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controller <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the interaction <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> handle. func configureView(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parameters</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;INParameter&gt;, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> interaction: INInteraction, interactiveBehavior: INUIInteractiveBehavior, <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>: INUIHostedViewContext, completion: @escaping (<span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;INParameter&gt;, CGSize) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Void</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> configuration here, <span class="hljs-keyword"><span class="hljs-keyword">including</span></span> preparing views <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> calculating a desired <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> presentation. completion(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameters</span></span>, self.desiredSize) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> desiredSize: CGSize { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.extensionContext!.hostedViewMaximumAllowedSize }</code> </pre> <br><p>  Pour que cette m√©thode soit appel√©e, vous devez ajouter le nom de notre intention au tableau <code>NSExtension</code> -&gt; <code>NSExtensionAttributes</code> -&gt; <code>IntentsSupported</code> , qui fait r√©f√©rence √† l'interface utilisateur Intents cible de l'extension </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSExtension<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSExtensionAttributes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>IntentsSupported<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>OrderPizzaIntent<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Selon la conception de votre vue dans Siri et l' <code>interaction.intent</code> qui a √©t√© int√©gr√©e √† la m√©thode, vous pouvez dessiner cette vue comme vous le souhaitez.  Voici des captures d'√©cran de l'apparence de notre intention dans Siri, dans la recherche et sur un √©cran verrouill√©. </p><br><p><img src="https://habrastorage.org/webt/wr/gh/sa/wrghsafmpp3qz3fiih1afdkrrou.png"></p><br><p>  Il convient de noter que l'utilisateur ne pourra pas interagir avec les boutons, le d√©filement et d'autres contr√¥les de votre vue, car la m√©thode est appel√©e avec le param√®tre <code>interactiveBehavior = .none</code> , cela impose certainement un certain nombre de limitations. </p><br><h3 id="itogo-1">  Total </h3><br><p>  Un raccourci bas√© sur l' <code>Intent</code> peut s'afficher dans l'interface siri ou dans le centre de notifications et effectuer une action sans ouvrir l'application.  Pour le cr√©er, vous avez besoin de: </p><br><ol><li>  Activer les <strong>capacit√©s</strong> pour utiliser Siri </li><li>  Cr√©er des <strong>extensions d'</strong> <strong>intentions</strong> et <strong>une interface d'extensions d'intentions</strong> </li><li>  Cr√©er <strong>un fichier de d√©finition d'intention SiriKit</strong> </li><li>  Nous cr√©ons notre <code>Intent</code> dans ce fichier et nous lui attribuons des param√®tres. </li><li>  Cr√©er un <code>IntentHandler</code> dans lequel nous impl√©mentons les <code>hanlde</code> et <code>hanlde</code> </li></ol><br><h2 id="rekomendacii">  Recommandations </h2><br><h3 id="obschiy-kod-v-targete-rasshirenii-siri-i-v-osnovnom-prilozhenii">  Code g√©n√©rique dans la cible d'extension Siri et l'application principale </h3><br><p>  Si vous avez du code utilis√© √† la fois dans la cible pour Siri et dans la cible du projet principal - il existe 2 fa√ßons de r√©soudre ce probl√®me: </p><br><ol><li>  Mettez en surbrillance les classes communes et ajoutez-les aux deux cibles.  ( <strong>Affichage ‚Üí Utilitaires ‚Üí Afficher l'inspecteur de fichiers</strong> ', dans la section <strong>Appartenance</strong> √† la <strong>cible</strong> , ajoutez des coches aux cibles qui ont besoin d'acc√©der au fichier s√©lectionn√©) </li><li>  Cr√©ez un ou plusieurs frameworks cibles et prenez le code g√©n√©ral l√†-bas. </li></ol><br><p>  Cette derni√®re m√©thode est pr√©f√©rable, car vous pouvez ensuite utiliser ces cadres dans d'autres extensions et projets.  Il convient √©galement de noter que pour ces frameworks, il est conseill√© de d√©finir l'indicateur <code>Allow app extension API only</code> , puis, lors du d√©veloppement du framework, le compilateur jurera si vous essayez d'utiliser une API qui est ill√©gale dans le d√©veloppement d'extensions (par exemple, <code>UIApplication</code> ). </p><br><p>  Les ressources partag√©es peuvent √™tre recherch√©es entre les cibles via des <strong>groupes d'applications</strong> </p><br><h3 id="otladka">  D√©bogage </h3><br><p>  Tester les raccourcis vous aidera √†: </p><br><ol><li>  <strong>Param√®tres du</strong> t√©l√©phone <strong>Param√®tres ‚Üí D√©veloppeur</strong> : <strong>afficher les raccourcis r√©cents</strong> et <strong>afficher les dons sur les</strong> commutateurs de l' <strong>√©cran de verrouillage</strong> : </li></ol><br><p><img src="https://habrastorage.org/webt/lv/0s/v8/lv0sv8rxfrdw7tgeqaql7p9yyhy.png"></p><br><ol><li>  Pour tester Intens, vous pouvez imm√©diatement lancer l'extension cible en sp√©cifiant dans Xcode la phrase avec laquelle Siri s'ouvre.  Pour ce faire, s√©lectionnez le sch√©ma de l'extension cible Siri </li></ol><br><p><img src="https://habrastorage.org/webt/lc/lf/vj/lclfvj0e18-jx73zrxkf0tasnyq.png"></p><br><p>  Cliquez sur cette cible, cliquez sur <strong>Modifier le sch√©ma ...</strong> </p><br><p><img src="https://habrastorage.org/webt/de/fq/8n/defq8nu0ptzrcaib4bcbwrpfa0k.png"></p><br><p>  Dans le champ <strong>Siri Intent Query</strong> , entrez une phrase avec laquelle Siri commencera d√©j√†, comme si vous l'aviez d√©j√† dit. </p><br><h2 id="itogo-2">  Total </h2><br><p>  Je propose d'arr√™ter et de r√©sumer ce que nous avons fait: </p><br><ol><li>  Les raccourcis peuvent √™tre cr√©√©s via <code>NSUserActivity</code> ou via <code>INIntent</code> </li><li>  Les raccourcis doivent √™tre d√©clar√©s (d√©clarer), signal√©s au syst√®me (don) et trait√©s (g√©rer). </li><li>  Vous pouvez ajouter le bouton " <em>Ajouter √† Siri</em> " √† l'application, en cliquant sur lequel l'utilisateur peut ajouter une phrase pour l'action et l'appeler ensuite avec sa voix. </li><li>  Vous pouvez cr√©er vos propres <code>Intents</code> en plus de la fonction int√©gr√©e. </li><li>  Gr√¢ce aux <code>Intents</code> bas√©s sur Intents <code>Intents</code> vous pouvez cr√©er des actions qui seront effectu√©es via l'interface Siri (sur un √©cran verrouill√© ou en recherche) sans avoir √† ouvrir l'application elle-m√™me. </li></ol><br><p>  Dans la documentation Apple, il y a un lien vers le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet Demo</a> , qui est utile pour le t√©l√©charger et se concentrer dessus pendant le d√©veloppement. </p><br><p>  Je tiens √† souligner qu'au moment de la r√©daction de cet article, il s'agit d'une API au stade <code>beta</code> .  Et j'attrape souvent des probl√®mes et des bugs.  Pendant le travail, je rencontrais p√©riodiquement les √©l√©ments suivants: </p><br><ul><li>  ,  Intent  Siri,  . </li><li>   Siri     . </li><li>        Siri. </li></ul><br><h2 id="ssylki">  Les r√©f√©rences </h2><br><ol><li> WWDC 2018, session 211: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction to Siri Shortcuts</a> </li><li> WWDC 2018, session 214: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Building for Voice with Siri Shortcuts</a> </li><li> Apple Developer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SiriKit</a> </li><li> Apple Developer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">INUIHostedViewControlling</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Demo  <strong><em>Soup Chef</em></strong>  Apple</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414677/">https://habr.com/ru/post/fr414677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414663/index.html">√âpuisement professionnel: un mot aux experts</a></li>
<li><a href="../fr414667/index.html">[Th√®me mini fan] Table des championnats de la FIFA dans le terminal</a></li>
<li><a href="../fr414669/index.html">D√©veloppement d'un nouvel analyseur statique: PVS-Studio Java</a></li>
<li><a href="../fr414673/index.html">Abibas n'est plus: le miracle technologique de la Chine</a></li>
<li><a href="../fr414675/index.html">Carri√®re de responsable informatique: de la ligne de commande au travail d'√©quipe</a></li>
<li><a href="../fr414679/index.html">Box-shadows.css</a></li>
<li><a href="../fr414683/index.html">L'histoire de la cr√©ation d'une application mobile pour enfants qui vous permet de gagner de l'argent avec votre esprit. Continuation</a></li>
<li><a href="../fr414687/index.html">Comment g√©rer une √©quipe et vous-m√™me: 15 livres pour un chef de projet</a></li>
<li><a href="../fr414689/index.html">Le√ßon ouverte "Applications Web et microservices sur Spring Boot 2.0"</a></li>
<li><a href="../fr414691/index.html">Contexte. YouTube Music et YouTube Premium: de quoi s'agit-il et en quoi ils diff√®rent</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>