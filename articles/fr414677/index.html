<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏼 🍁 👩🏾‍🤝‍👨🏿 Commandes rapides Siri ✍🏼 🚶🏿 ✡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'une des fonctionnalités utiles (à mon avis) d'iOS 12 introduites lors de la WWDC 2018 est Siri Shortcuts . 


 Raccourci ( raccourci ) - une command...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Commandes rapides Siri</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/414677/"><p><img src="https://habrastorage.org/webt/ge/mr/un/gemrunsbwx7gf07v5htwy9lytpu.png"></p><br><p>  L'une des fonctionnalités utiles (à mon avis) d'iOS 12 introduites lors de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://">WWDC 2018</a> est <strong>Siri Shortcuts</strong> . </p><br><p>  Raccourci ( <em>raccourci</em> ) - une commande rapide, un moyen rapide d'effectuer toute action en contournant le script standard. </p><br><p>  Dans vos applications, vous pouvez créer des raccourcis pour certaines actions.  Apprenant comment et quand l'utilisateur les met en œuvre, Siri commence intelligemment, au bon moment et au bon endroit, pour lui offrir ces raccourcis et, mieux encore, l'utilisateur peut les appeler avec des phrases qu'il leur attachera!  Sous le chat plus. </p><a name="habracut"></a><br><h2 id="kak-eto-rabotaet">  Comment ça marche </h2><br><p>  Nous utilisons des applications qui, avec certaines actions, créent et fournissent des raccourcis au système. </p><br><p>  Vous pouvez afficher ces raccourcis dans <strong>Paramètres → Siri et Rechercher</strong> . <br><img src="https://habrastorage.org/webt/vp/z2/fd/vpz2fdo_rakpjpl-imiuvzkbyly.png"><br>  La capture d'écran ci-dessus montre les trois derniers raccourcis que le système a détectés dans différentes applications.  Si nous cliquons sur le bouton «Plus de raccourcis», nous verrons tous les raccourcis fournis au système par chaque application. </p><br><p>  Avec certains paramètres dans le code de création de raccourci, Siri offrira ces raccourcis à l'utilisateur sur l'écran verrouillé, dans le centre de notification et de recherche, en se concentrant sur la fréquence à laquelle nous utilisons ces actions, à quelle heure, sur quels jours de la semaine et où à d'autres facteurs. </p><br><p>  Par exemple, si le vendredi soir vous cherchez habituellement des distributeurs automatiques de billets, après vous être entraîné, Siri vous proposera un raccourci avec cette action le vendredi soir. </p><br><p><img src="https://habrastorage.org/webt/ef/my/gu/efmyguxaczsetehquug_nyp7vnc.png"></p><br><p>  Nous pouvons ajouter notre commande vocale à chaque raccourci en cliquant sur l'icône " <strong>+</strong> ". </p><br><p>  Nous disons une commande vocale, appuyez sur "Terminé", et maintenant nous pouvons effectuer l'action derrière le raccourci en utilisant la voix via Siri.  <em>Il s'avère que l'utilisateur pourra exécuter les fonctionnalités de votre application via Siri sans ouvrir l'application elle-même.</em>  Le raccourci avec la phrase est conservé dans "Mes raccourcis". </p><br><h2 id="sozdanie-shortkatov">  Création de raccourcis </h2><br><p> Pour le développement, nous aurons besoin de Xcode 10 et iOS 12. Au moment de la rédaction, les deux sont au stade <strong>bêta</strong> . </p><br><p> Un raccourci peut être créé via <code>NSUserActivity</code> ou via <code>Intent</code> . </p><br><p>  Le premier cas: </p><br><p>  L'utilisateur clique sur le raccourci, qui transmet la commande avec les paramètres ( <code>NSUserActivity</code> ) à notre application, et il décide comment cette commande doit être traitée (ouvrez la fenêtre du taux USD actuel, ou la fenêtre de commande de notre pizza préférée).  C'est le bon vieux raccourci Spotlight que nous connaissons tous, mais intelligemment proposé par Siri. </p><br><p>  Deuxième cas: </p><br><p>  Les raccourcis créés via <code>Intent</code> plus intéressants - ils vous permettent d'exécuter une commande immédiatement dans l'interface Siri sans lancer votre application.  Auparavant, l'ensemble des <code>Intent</code> était difficile pour Apple: transférer de l'argent, envoyer des messages et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autres</a> .  Maintenant, nous, les développeurs, avons la possibilité de créer nos <code>Intent</code> ! </p><br><p>  Quelle que soit la façon dont le raccourci a été créé, il passe par 3 étapes du cycle de vie: </p><br><ol><li>  Annonce ( <strong><em>définir</em></strong> ) </li><li>  Livraison au système ( <strong><em>Faire un don</em></strong> ) </li><li>  Traitement par application ( <strong><em>Handle</em></strong> ) </li></ol><br><p><img src="https://habrastorage.org/webt/ie/7b/6z/ie7b6zoy5fd9mkx5ivjddp0agxc.png"></p><br><p>  Mes recherches ont montré qu'une application ne peut pas fournir plus de 20 raccourcis au système. </p><br><p>  De plus, nous examinerons comment donner à notre application la possibilité de créer des raccourcis et comment travailler avec eux à l'intérieur. </p><br><h2 id="sozdanie-shortkatov-cherez-nsuseractivity">  Création de raccourcis via <code>NSUserActivity</code> </h2><br><p>  Analysons le premier type simple de raccourcis qui s'ouvrent via <code>NSUserActivity</code> . </p><br><p>  Par exemple, dans l'application de banque mobile, nous avons un écran de recherche de guichets automatiques et je les cherche souvent.  Pour accéder à l'écran avec une carte ATM, je dois lancer l'application, aller dans l'onglet «Plus» de l'onglet, sélectionner la section «Info» et cliquer sur le bouton «ATM». <br>  Si nous créons un raccourci qui mène immédiatement à cet écran, l'utilisateur pourra y accéder d'une seule touche lorsque Siri le lui proposera, par exemple, sur un écran verrouillé. </p><br><h3 id="obyavlyaem-shortkat-declare">  Déclarer un raccourci </h3><br><p>  La première étape consiste à déclarer un type comme notre <code>NSUserActivity</code> (on peut dire que c'est son identifiant) dans <em>info.playlist</em> : </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSUserActivityTypes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>ru.tinkoff.demo.show-cashMachine<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Annoncé. </p><br><h3 id="dostavlyaem-shortkat-v-sistemu-donate">  Fournir le raccourci vers le système (faire un don) </h3><br><p>  Après la déclaration, nous pouvons créer <code>NSUserActivity</code> dans le code de notre application avec le type que nous avons défini ci-dessus dans <strong>info.playlist</strong> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> activity = NSUserActivity(activityType: <span class="hljs-string"><span class="hljs-string">"ru.tinkoff.demo.show-cashMachine"</span></span>)</code> </pre> <br><p>  Pour que l'activité entre dans la liste des raccourcis du système, elle doit être définie sur <code>title</code> et définir la propriété <code>isEligibleForSearch</code> sur <code>true</code> .  D'autres propriétés ne sont pas nécessaires pour l'ajout aux raccourcis, mais leur présence rend le raccourci plus lisible et convivial. </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   (     ,   ) activity.title = " " if #available(iOS 12.0, *) { // ,             activity.suggestedInvocationPhrase = "  " //           activity.isEligibleForPrediction = true // (     ,   ) activity.isEligibleForSearch = true } //       let attributes = CSSearchableItemAttributeSet(itemContentType: "NSUserActivity.searchableItemContentType") ///    if let image = UIImage(named: "siriAtmIcon") { attributes.thumbnailData = UIImagePNGRepresentation(image) } ///   attributes.contentDescription = "     " ///     activity.contentAttributeSet = attributes</span></span></code> </pre> <br><p>  Feu!  <code>NSUserActivity</code> est, pour le livrer au système, il reste à faire la dernière étape. </p><br><p>  <code>ViewConroller</code> possède une propriété <code>userActivity</code> , à laquelle nous devons affecter l' <code>activity</code> créée ci-dessus: </p><br><pre> <code class="javascript hljs">self.userActivity = activity</code> </pre> <br><p>  Dès que cette ligne est exécutée, un raccourci sera créé à partir de cette activité.  Il sera livré au système et affiché dans les paramètres Siri ( <strong>Paramètres → Siri et Rechercher</strong> ).  Siri pourra alors l'offrir à l'utilisateur, et l'utilisateur pourra lui attribuer sa commande vocale. </p><br><p>  <em><strong>Remarque</strong> : la documentation Apple indique qu'au lieu d'affecter une activité au contrôleur de vue, il suffit d'appeler la méthode <code>becomeCurrent()</code> sur l' <code>becomeCurrent()</code> .</em>  <em>Cependant, cette action n'a pas fourni d'activité à mon système et le raccourci n'apparaissait pas dans la liste</em> </p><br><blockquote>  Ensuite, appelez la méthode <code>becomeCurrent()</code> sur l'objet d'activité utilisateur pour le marquer comme courant, ce qui donne l'activité à Siri.  Vous pouvez également attacher l'objet à un objet UIViewController ou UIResponder, qui marque également l'activité comme actuelle. </blockquote><p>  Pour vérifier que tout a fonctionné, ouvrez <strong>Paramètres&gt; Siri et recherchez</strong> - le raccourci basé sur notre activité devrait être dans la liste. </p><br><h3 id="obrabotka-shortkata-prilozheniem-handle">  Traitement des raccourcis par application (poignée) </h3><br><p>  Lorsqu'un utilisateur navigue dans le raccourci depuis le centre de notifications ou l'active par la voix, l'application démarre et nous devons traiter ce raccourci. </p><br><p>  <code>activity</code> lancée dans <code>AppDelegate</code> 'une méthode: </p><br><pre> <code class="javascript hljs">func application(_ application: UIApplication, <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> userActivity: NSUserActivity, <span class="hljs-attr"><span class="hljs-attr">restorationHandler</span></span>: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> userActivity.activityType == <span class="hljs-string"><span class="hljs-string">"ru.tinkoff.demo.show-cashMachine"</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,     handleShowCashMachineActivity() return true } return false }</span></span></code> </pre> <br><h3 id="itogo">  Total </h3><br><p>  Un <code>NSUserActivity</code> NSUserActivity est créé comme suit: </p><br><ol><li>  Déclarez le type (identifiant) de <code>NSUserActivity</code> dans <code>NSUserActivity</code> . </li><li>  Nous créons <code>NSUserActivity</code> dans le code et nous configurons </li><li>  <code>viewController'</code> . </li></ol><br><h2 id="sozdanie-golosovyh-komand-iz-prilozheniya">  Création de commandes vocales à partir d'une application </h2><br><p>  Ainsi, si l'utilisateur ouvre <strong>Paramètres&gt; Siri et recherche</strong> , il verra une liste de ses raccourcis, qui ont été créés par diverses applications, dont la nôtre.  En cliquant sur le « <strong>+</strong> », l'utilisateur peut créer n'importe quelle commande vocale et l'associer au raccourci sélectionné.  Cependant, chaque fois que la saisie des paramètres est gênante pour l'utilisateur, beaucoup ne réalisent même pas cette possibilité. </p><br><p>  C'est cool que vous puissiez attacher une commande vocale à une action spécifique directement dans l'application. </p><br><p>  Supposons qu'un utilisateur effectue une action, qu'elle soit livrée au système, il veut la sauvegarder.  Nous pouvons ajouter le bouton « <em>ajouter une action à Siri</em> » (vous pouvez nommer et dessiner le bouton comme vous le souhaitez) sur l'écran de notre application, puis l'utilisateur, en cliquant dessus, pourra associer cette action à une commande vocale depuis l'application sans entrer dans les paramètres. </p><br><p>  En cliquant sur le bouton, vous devez ouvrir de façon modale l'écran pour ajouter une commande vocale à un raccourci dans Siri <code>INUIAddVoiceShortcutViewController</code> , ou l'écran pour modifier une commande vocale <code>INUIEditVoiceShortcutViewController</code> , s'il en a déjà été créé un.  L' <code>action</code> n'ayant pas réagi <code>action</code> un tel bouton sera approximativement la suivante: </p><br><pre> <code class="hljs julia"> <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> func addToSiriAction() { // <span class="hljs-number"><span class="hljs-number">1.</span></span>   ,       INVoiceShortcutCenter.shared.getAllVoiceShortcuts { (shortcuts, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> guard error == nil, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcuts = shortcuts <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // TODO: Handle error <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } // <span class="hljs-number"><span class="hljs-number">2.</span></span>     ,      <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> donatedShortcut: INVoiceShortcut? = shortcuts.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { (shorcut) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shorcut.__shortcut.userActivity?.activityType == <span class="hljs-string"><span class="hljs-string">"com.ba"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcut = donatedShortcut { // <span class="hljs-number"><span class="hljs-number">3.</span></span>     -     . //         <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> editVoiceShortcutViewController = INUIEditVoiceShortcutViewController(voiceShortcut: shortcut) editVoiceShortcutViewController.delegate = self self.present(editVoiceShortcutViewController, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: nil) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // <span class="hljs-number"><span class="hljs-number">4.</span></span>         <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcut = INShortcut(userActivity: self.userActivity!) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> addVoiceShortcutViewController = INUIAddVoiceShortcutViewController(shortcut: shortcut) addVoiceShortcutViewController.delegate = self } } }</code> </pre> <br><p>  Ainsi, les écrans pour ajouter et modifier une commande vocale pour le raccourci Siri ressemblent: </p><br><p><img src="https://habrastorage.org/webt/ez/lk/ai/ezlkaihh3q9gvj4syqkizbwqy4c.png"></p><br><p>  Nous devons également implémenter les méthodes déléguées de ces viewControllers, dans lesquelles ils doivent masquer le <code>dismiss(animated: true, completion: nil)</code> et, si nécessaire, mettre à jour l'écran actuel.  Par exemple, s'il y avait un bouton «ajouter une commande vocale» sur l'écran plus tôt, alors après avoir ajouté une commande vocale, ce bouton devrait soit disparaître, soit passer à «modifier la commande vocale». </p><br><h2 id="shortkaty-sozdannye-pri-pomoschi-intent">  Raccourcis d'intention </h2><br><p>  Jusqu'à présent, nous n'avons parlé que de raccourcis qui ouvrent une application et y transmettent <code>NSUserActivity</code> données à <code>NSUserActivity</code> . </p><br><p>  Mais revenons aux raccourcis créés via <code>Intent</code> , qui vous permettent d'effectuer certaines actions sans ouvrir l'application.  Ici, le plaisir commence. </p><br><p>  Imaginez qu'un utilisateur commande sa pizza préférée.  Il le commandera plusieurs fois quand il le voudra, et il a même ajouté une commande vocale au raccourci de cette pizza - et cela lui simplifie la vie.  Mais nous pouvons faire plus pour lui - nous pouvons nous assurer qu'en donnant la commande vocale Siri, le système ne la jette pas dans l'application, mais affiche immédiatement les informations de commande et les commandes de pizza dans l'interface Siri!  C'est juste le cas lorsque l'utilisateur n'a pas besoin d'ouvrir l'application elle-même pour effectuer une action. </p><br><p>  Tout d'abord, accédez aux paramètres du projet, sélectionnez la cible principale, l'onglet <code>Capabilities</code> et activez l'accès à Siri. </p><br><p>  Notre application peut interagir avec Siri, mais cela ne se produit pas dans le code principal de l'application, mais dans une extension cible distincte <strong>Intents Extensions</strong> </p><br><p>  Pour commencer, cette cible doit être créée: <strong>Fichier → Nouveau → Cible</strong> , sélectionnez <strong>Intentions Extensions</strong> .  Xcode vous proposera de créer une autre extension cible pour la fenêtre affichant vos actions dans Siri, si cela est nécessaire, nous sommes d'accord. </p><br><p><img src="https://habrastorage.org/webt/ia/o_/pp/iao_pphchyfpr33hj6jluyy-ozc.jpeg"></p><br><h3 id="obyavlyaem-shortkat-declare-1">  Déclarer un raccourci </h3><br><p>  La principale innovation de SiriKit dans iOS 12 est la possibilité de créer vos <code>Inetnts</code> , à ceux qui étaient plus tôt. </p><br><p><img src="https://habrastorage.org/webt/5a/66/6m/5a666mqkcm0li-cujpl7yexzrgm.png"></p><br><p>  Pour ce faire, créez un nouveau fichier: <strong>Fichier → Nouveau → Fichier</strong> , en sélectionnant <strong>Fichier</strong> de <strong>définition d'intention SiriKit</strong> dans la section <strong>Ressources</strong> . </p><br><p><img src="https://habrastorage.org/webt/qz/8l/lx/qz8llxznc1o05palhxxxcskrcbq.png"></p><br><p>  En conséquence, un fichier avec l'extension <em>.intentdefinition apparaît</em> , dans lequel vous pouvez créer vos propres <code>Intents</code> .  Nous ouvrons le fichier, et là où il est dit " <strong>Pas d'intention</strong> " en bas, il y a une icône " <strong>+</strong> " - cliquez dessus.  " <strong>Nouvelle intention</strong> ".  Une intention apparaîtra dans la liste à laquelle vous pouvez ajouter des paramètres.  Dans le cas d'une commande de pizza, vous pouvez ajouter le nombre de pizzas et le type de pizza à commander comme paramètres.  Pour la quantité, nous choisissons le type <code>Integer</code> et pour le type de pizza, nous sélectionnons le type <code>Custom</code> , qui dans le code sera représenté par la classe <code>INObject</code> . </p><br><p>  Maintenant quelques lignes de frustration: </p><br><p>  <strong>L'utilisateur ne pourra pas transmettre différents paramètres à la même commande vocale enregistrée.</strong>  <strong>Hélas!</strong> </p><br><p><img src="https://habrastorage.org/webt/kn/z4/y-/knz4y-oo1kns8ehvzoojslxqycq.jpeg"></p><br><p>  Quels sont les paramètres pour: </p><br><p>  Supposons que vous créez une entité "Show rate <code>%currency</code> ", où la <code>currency</code> est un paramètre d'entité.  Cela ne signifie pas que l'utilisateur peut dire les phrases "Afficher le taux de change du dollar", "Afficher le taux de change Bitcoin", etc.  Hors de la boîte, cela ne fonctionnera pas comme ça.  Mais cela signifie que si l'utilisateur a regardé le taux de change du dollar, le raccourci "Afficher le taux USD" a été créé, puis lorsqu'il a regardé le taux de change Bitcoin, le raccourci "Afficher le taux BTC" a été créé, etc.  En d'autres termes, il peut avoir plusieurs shorkatas basés sur la même intention, mais avec des paramètres différents.  Chacun des raccourcis, l'utilisateur pourra demander sa commande vocale. </p><br><p>  Eh bien, en créant une intention dans le fichier <em>.intentdefinition</em> , <em>Xcode</em> générera automatiquement une classe pour cette intention (remarque: elle n'apparaîtra pas dans les fichiers de projet, mais sera disponible pour utilisation). Ce fichier généré automatiquement ne se trouvera que dans les cibles qui ont le fichier <em>.intentdefinition</em> . </p><br><p>  Après avoir créé l'intention dans le fichier .intentdefinition <em>,</em> nous pouvons créer nos intentions dans le code. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intent = <span class="hljs-type"><span class="hljs-type">OrderPizzaIntent</span></span>()</code> </pre> <br><h3 id="dostavlyaem-shortkat-v-sistemu-donate-1">  Fournir le raccourci vers le système (faire un don) </h3><br><p>  Pour que cette entité soit incluse dans la liste des raccourcis, vous devez l'intégrer.  Pour ce faire, un objet <code>INInteraction</code> est créé avec une instance de votre intention et la méthode .donate est appelée sur cette <code>.donate</code> </p><br><pre> <code class="hljs lua">let intent = OrderPizzaIntentf() // ...   let interaction = INInteraction(intent: intent, response: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) interaction.donate { (<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> // ...   /  }</code> </pre> <br><p>  Après avoir exécuté ce code, le raccourci basé sur l'intention sera fourni au système et affiché dans les paramètres Siri. </p><br><h3 id="obrabatyvaem-shortkat-prilozheniem-handle">  Nous traitons l'application de raccourci (Handle) </h3><br><p>  L'étape suivante consiste à traiter l'intention lorsque l'utilisateur clique dessus dans le sirjest du Siri ou l'appelle avec une commande vocale. </p><br><p>  Nous avons déjà créé une extension cible pour Siri et elle a une classe IntentHandler pré-créée, qui a une seule méthode - `` gérer (pour l'intention) '' </p><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntentHandler</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INExtension</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> intent: INIntent)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Any</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> intent <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">OrderPizzaIntent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Unhandled intent type: \(intent)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">OrderPizzaIntentHandler</span></span>() } }</code> </pre> <br><blockquote>  Remarque: Si le compilateur ne voit pas la classe de votre intention, vous n'avez pas ajouté le fichier d'extension cible <em>.intentdefinition</em> pour Siri. </blockquote><p>  Dans cette méthode, nous déterminons le type d'intention entrante et pour chaque type, nous créons un objet gestionnaire qui traitera cette intention.  Créez un gestionnaire pour notre <code>OrderPizzaIntent</code> et implémentez-y le protocole <code>OrderPizzaIntentHandling</code> , qui est déjà généré automatiquement après la création de votre intention dans <em>.intentdefinition</em> . </p><br><p>  Le protocole contient deux méthodes de <code>confirm</code> et de <code>handle</code> .  Tout d'abord, <code>confirm</code> est appelé où toutes les données sont vérifiées et la disponibilité de l'action est vérifiée.  Ensuite, la <code>handle</code> fonctionnera en une courte action à effectuer. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderPizzaIntentHandler</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderPizzaIntentHandling</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">confirm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(intent: OrderPizzaIntent, completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(OrderPizzaIntentResponse)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      // ... completion(OrderPizzaIntentResponse(code: OrderPizzaIntentResponseCode.ready, userActivity: nil)) } public func handle(intent: OrderPizzaIntent, completion: @escaping (OrderPizzaIntentResponse) -&gt; Void) { //     // ... completion(OrderPizzaIntentResponse(code: OrderPizzaIntentResponseCode.success, userActivity: nil)) } }</span></span></code> </pre> <br><p>  Ces deux méthodes doivent définitivement appeler la <code>completion</code> avec la réponse <code>OrderPizzaIntentResponse</code> (elle est également générée automatiquement), sinon Siri attendra juste longtemps et donnera une erreur. </p><br><h3 id="bolee-podrobnye-otvety-ot-siri">  Des réponses plus détaillées de Siri </h3><br><p>  Il existe un ensemble standard de codes de réponse générés automatiquement - <code>enum OrderPizzaIntentResponseCode</code> , mais ils peuvent ne pas être suffisants pour une interface conviviale.  Par exemple, au stade de la <code>confirm</code> , plusieurs erreurs différentes peuvent se produire - la pizza est épuisée, la pizzeria ne fonctionne pas pour le moment, etc.  et l'utilisateur doit se renseigner sur ces faits, au lieu du message standard "Erreur d'application".  N'oubliez pas que nous avons créé <code>Intent</code> dans le fichier <em>.intentdefinition</em> ?  Avec l'intention elle-même, sa <code>Response</code> dans laquelle vous pouvez ajouter vos propres options d'erreurs et de réponses réussies, et les configurer avec les paramètres: </p><br><p><img src="https://habrastorage.org/webt/xz/zg/fa/xzzgfawljagfnruxp_zjjdeug2m.png"></p><br><p>  Maintenant, nous pouvons dire à l'utilisateur des erreurs et des réponses plus informatives: </p><br><pre> <code class="hljs lua">public func confirm(intent: OrderPizzaIntent, completion: @escaping (OrderPizzaIntentResponse) -&gt; Void) { guard let pizzaKindId = intent.kind?.identifier <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //         -     completion(OrderPizzaIntentResponse(code: .failure, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pizzeriaManager.isPizzeriaClosed == <span class="hljs-literal"><span class="hljs-literal">true</span></span> { ///     -     completion(OrderPizzaIntentResponse(code: .failurePizzeriaClosed, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pizzeriaManager.menu.isPizzaUnavailable(identifier: pizzaKindId) { ///      -     completion(OrderPizzaIntentResponse(code: .failurePizzaUnavailable(kind: intent.kind), userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } //     -    completion(OrderPizzaIntentResponse(code: .ready, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) }</code> </pre> <br><h3 id="otrisovka-intenta">  Rendu <code>Intent</code> </h3><br><p>  Si nous avons créé une <strong>extension</strong> cible d' <strong>interface utilisateur d'extension d'intention</strong> , nous pouvons dessiner une vue personnalisée dans Siri pour les intentions dont nous avons besoin.  Nous avons <code>MainInterface.storyboard</code> et <code>IntentViewController</code> dans lesquels nous pouvons esquisser leur conception.  Ce contrôleur de vue implémente le protocole INUIHostedViewControlling et la vue est <code>configureView</code> dans la méthode <code>configureView</code> </p><br><pre> <code class="hljs sql">// <span class="hljs-keyword"><span class="hljs-keyword">Prepare</span></span> your <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controller <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the interaction <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> handle. func configureView(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parameters</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;INParameter&gt;, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> interaction: INInteraction, interactiveBehavior: INUIInteractiveBehavior, <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>: INUIHostedViewContext, completion: @escaping (<span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;INParameter&gt;, CGSize) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Void</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> configuration here, <span class="hljs-keyword"><span class="hljs-keyword">including</span></span> preparing views <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> calculating a desired <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> presentation. completion(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameters</span></span>, self.desiredSize) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> desiredSize: CGSize { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.extensionContext!.hostedViewMaximumAllowedSize }</code> </pre> <br><p>  Pour que cette méthode soit appelée, vous devez ajouter le nom de notre intention au tableau <code>NSExtension</code> -&gt; <code>NSExtensionAttributes</code> -&gt; <code>IntentsSupported</code> , qui fait référence à l'interface utilisateur Intents cible de l'extension </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSExtension<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSExtensionAttributes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>IntentsSupported<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>OrderPizzaIntent<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Selon la conception de votre vue dans Siri et l' <code>interaction.intent</code> qui a été intégrée à la méthode, vous pouvez dessiner cette vue comme vous le souhaitez.  Voici des captures d'écran de l'apparence de notre intention dans Siri, dans la recherche et sur un écran verrouillé. </p><br><p><img src="https://habrastorage.org/webt/wr/gh/sa/wrghsafmpp3qz3fiih1afdkrrou.png"></p><br><p>  Il convient de noter que l'utilisateur ne pourra pas interagir avec les boutons, le défilement et d'autres contrôles de votre vue, car la méthode est appelée avec le paramètre <code>interactiveBehavior = .none</code> , cela impose certainement un certain nombre de limitations. </p><br><h3 id="itogo-1">  Total </h3><br><p>  Un raccourci basé sur l' <code>Intent</code> peut s'afficher dans l'interface siri ou dans le centre de notifications et effectuer une action sans ouvrir l'application.  Pour le créer, vous avez besoin de: </p><br><ol><li>  Activer les <strong>capacités</strong> pour utiliser Siri </li><li>  Créer des <strong>extensions d'</strong> <strong>intentions</strong> et <strong>une interface d'extensions d'intentions</strong> </li><li>  Créer <strong>un fichier de définition d'intention SiriKit</strong> </li><li>  Nous créons notre <code>Intent</code> dans ce fichier et nous lui attribuons des paramètres. </li><li>  Créer un <code>IntentHandler</code> dans lequel nous implémentons les <code>hanlde</code> et <code>hanlde</code> </li></ol><br><h2 id="rekomendacii">  Recommandations </h2><br><h3 id="obschiy-kod-v-targete-rasshirenii-siri-i-v-osnovnom-prilozhenii">  Code générique dans la cible d'extension Siri et l'application principale </h3><br><p>  Si vous avez du code utilisé à la fois dans la cible pour Siri et dans la cible du projet principal - il existe 2 façons de résoudre ce problème: </p><br><ol><li>  Mettez en surbrillance les classes communes et ajoutez-les aux deux cibles.  ( <strong>Affichage → Utilitaires → Afficher l'inspecteur de fichiers</strong> ', dans la section <strong>Appartenance</strong> à la <strong>cible</strong> , ajoutez des coches aux cibles qui ont besoin d'accéder au fichier sélectionné) </li><li>  Créez un ou plusieurs frameworks cibles et prenez le code général là-bas. </li></ol><br><p>  Cette dernière méthode est préférable, car vous pouvez ensuite utiliser ces cadres dans d'autres extensions et projets.  Il convient également de noter que pour ces frameworks, il est conseillé de définir l'indicateur <code>Allow app extension API only</code> , puis, lors du développement du framework, le compilateur jurera si vous essayez d'utiliser une API qui est illégale dans le développement d'extensions (par exemple, <code>UIApplication</code> ). </p><br><p>  Les ressources partagées peuvent être recherchées entre les cibles via des <strong>groupes d'applications</strong> </p><br><h3 id="otladka">  Débogage </h3><br><p>  Tester les raccourcis vous aidera à: </p><br><ol><li>  <strong>Paramètres du</strong> téléphone <strong>Paramètres → Développeur</strong> : <strong>afficher les raccourcis récents</strong> et <strong>afficher les dons sur les</strong> commutateurs de l' <strong>écran de verrouillage</strong> : </li></ol><br><p><img src="https://habrastorage.org/webt/lv/0s/v8/lv0sv8rxfrdw7tgeqaql7p9yyhy.png"></p><br><ol><li>  Pour tester Intens, vous pouvez immédiatement lancer l'extension cible en spécifiant dans Xcode la phrase avec laquelle Siri s'ouvre.  Pour ce faire, sélectionnez le schéma de l'extension cible Siri </li></ol><br><p><img src="https://habrastorage.org/webt/lc/lf/vj/lclfvj0e18-jx73zrxkf0tasnyq.png"></p><br><p>  Cliquez sur cette cible, cliquez sur <strong>Modifier le schéma ...</strong> </p><br><p><img src="https://habrastorage.org/webt/de/fq/8n/defq8nu0ptzrcaib4bcbwrpfa0k.png"></p><br><p>  Dans le champ <strong>Siri Intent Query</strong> , entrez une phrase avec laquelle Siri commencera déjà, comme si vous l'aviez déjà dit. </p><br><h2 id="itogo-2">  Total </h2><br><p>  Je propose d'arrêter et de résumer ce que nous avons fait: </p><br><ol><li>  Les raccourcis peuvent être créés via <code>NSUserActivity</code> ou via <code>INIntent</code> </li><li>  Les raccourcis doivent être déclarés (déclarer), signalés au système (don) et traités (gérer). </li><li>  Vous pouvez ajouter le bouton " <em>Ajouter à Siri</em> " à l'application, en cliquant sur lequel l'utilisateur peut ajouter une phrase pour l'action et l'appeler ensuite avec sa voix. </li><li>  Vous pouvez créer vos propres <code>Intents</code> en plus de la fonction intégrée. </li><li>  Grâce aux <code>Intents</code> basés sur Intents <code>Intents</code> vous pouvez créer des actions qui seront effectuées via l'interface Siri (sur un écran verrouillé ou en recherche) sans avoir à ouvrir l'application elle-même. </li></ol><br><p>  Dans la documentation Apple, il y a un lien vers le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet Demo</a> , qui est utile pour le télécharger et se concentrer dessus pendant le développement. </p><br><p>  Je tiens à souligner qu'au moment de la rédaction de cet article, il s'agit d'une API au stade <code>beta</code> .  Et j'attrape souvent des problèmes et des bugs.  Pendant le travail, je rencontrais périodiquement les éléments suivants: </p><br><ul><li>  ,  Intent  Siri,  . </li><li>   Siri     . </li><li>        Siri. </li></ul><br><h2 id="ssylki">  Les références </h2><br><ol><li> WWDC 2018, session 211: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction to Siri Shortcuts</a> </li><li> WWDC 2018, session 214: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Building for Voice with Siri Shortcuts</a> </li><li> Apple Developer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SiriKit</a> </li><li> Apple Developer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">INUIHostedViewControlling</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Demo  <strong><em>Soup Chef</em></strong>  Apple</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414677/">https://habr.com/ru/post/fr414677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414663/index.html">Épuisement professionnel: un mot aux experts</a></li>
<li><a href="../fr414667/index.html">[Thème mini fan] Table des championnats de la FIFA dans le terminal</a></li>
<li><a href="../fr414669/index.html">Développement d'un nouvel analyseur statique: PVS-Studio Java</a></li>
<li><a href="../fr414673/index.html">Abibas n'est plus: le miracle technologique de la Chine</a></li>
<li><a href="../fr414675/index.html">Carrière de responsable informatique: de la ligne de commande au travail d'équipe</a></li>
<li><a href="../fr414679/index.html">Box-shadows.css</a></li>
<li><a href="../fr414683/index.html">L'histoire de la création d'une application mobile pour enfants qui vous permet de gagner de l'argent avec votre esprit. Continuation</a></li>
<li><a href="../fr414687/index.html">Comment gérer une équipe et vous-même: 15 livres pour un chef de projet</a></li>
<li><a href="../fr414689/index.html">Leçon ouverte "Applications Web et microservices sur Spring Boot 2.0"</a></li>
<li><a href="../fr414691/index.html">Contexte. YouTube Music et YouTube Premium: de quoi s'agit-il et en quoi ils diffèrent</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>