<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚öñÔ∏è üï∫üèø üë©üèΩ‚Äçü§ù‚Äçüë®üèø Mise en ≈ìuvre de Verilog Cache üë®üèº‚Äçüéì üíÇ üè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article d√©crit l'impl√©mentation la plus simple de la RAM dans Verilog. 

 Avant de proc√©der √† l'analyse de code, il est recommand√© d'apprendre la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mise en ≈ìuvre de Verilog Cache</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461611/"> Cet article d√©crit l'impl√©mentation la plus simple de la RAM dans Verilog. <br><br>  Avant de proc√©der √† l'analyse de code, il est recommand√© d'apprendre la syntaxe de base de Verilog. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vous trouverez ici du mat√©riel de formation</a> . <br><a name="habracut"></a><br><h3>  RAM </h3><br><h4>  √âtape 1: d√©claration du module avec les signaux d'entr√©e / sortie correspondants </h4><br><pre><code class="plaintext hljs">module ram ( input [word_size - 1:0] data, input [word_size - 1:0] addr, input wr, input clk, output response, output [word_size - 1:0] out ); parameter word_size = 32;</code> </pre> <br><ul><li>  <b>donn√©es</b> - donn√©es √† √©crire. </li><li>  <b>addr</b> - adresse de la m√©moire en RAM. </li><li>  <b>wr</b> - √©tat (lecture / √©criture). </li><li>  <b>clk</b> - syst√®me de cycle d'horloge. </li><li>  <b>r√©ponse</b> - √©tat de pr√©paration de la RAM (1 - si la RAM a trait√© la demande de lecture / √©criture, 0 - sinon). </li><li>  <b>out</b> - donn√©es lues dans la RAM. </li></ul><br>  Cette impl√©mentation a √©t√© int√©gr√©e dans Altera Max 10 FPGA, qui a une architecture 32 bits, et donc la taille des donn√©es et de l'adresse (word_size) est de 32 bits. <br><br><h4>  √âtape 2: d√©clarer les registres √† l'int√©rieur du module </h4><br>  Une d√©claration de tableau pour stocker des donn√©es: <br><br><pre> <code class="plaintext hljs">parameter size = 1&lt;&lt;32; reg [word_size-1:0] ram [size-1:0];</code> </pre><br>  Nous devons √©galement stocker les param√®tres d'entr√©e pr√©c√©dents afin de suivre leurs modifications dans le bloc Always: <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] data_reg; reg [word_size-1:0] addr_reg; reg wr_reg;</code> </pre><br>  Et les deux derniers registres pour mettre √† jour les signaux de sortie apr√®s les calculs dans le bloc toujours: <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] out_reg; reg response_reg;</code> </pre><br>  Nous initialisons les registres: <br><br><pre> <code class="plaintext hljs">initial begin response_reg = 1; data_reg = 0; addr_reg = 0; wr_reg = 0; end</code> </pre><br><h4>  √âtape 3: impl√©menter la logique toujours du bloc </h4><br><pre> <code class="plaintext hljs">always @(negedge clk) begin if ((data != data_reg) || (addr%size != addr_reg)|| (wr != wr_reg)) begin response_reg = 0; data_reg = data; addr_reg = addr%size; wr_reg = wr; end else begin if (response_reg == 0) begin if (wr) ram[addr] = data; else out_reg = ram[addr]; response_reg = 1; end end end</code> </pre><br>  Toujours bloquer est d√©clench√© par negedje, c.-√†-d.  au moment o√π l'horloge passe de 1 √† 0. Ceci est fait pour synchroniser correctement la RAM avec le cache.  Sinon, il peut y avoir des cas o√π la RAM n'a pas le temps de r√©initialiser l'√©tat pr√™t de 1 √† 0 et √† l'horloge suivante, le cache d√©cide que la RAM a trait√© avec succ√®s sa demande, ce qui est fondamentalement faux. <br><br>  La logique de l'algorithme toujours du bloc est la suivante: si les donn√©es sont mises √† jour, remettre l'√©tat de pr√©paration √† 0 et √©crire / lire les donn√©es, si l'√©criture / lecture est termin√©e, nous mettons √† jour l'√©tat de pr√©paration √† 1. <br><br>  √Ä la fin, ajoutez la section de code suivante: <br><br><pre> <code class="plaintext hljs">assign out = out_reg; assign response = response_reg;</code> </pre><br>  Le type de signaux de sortie de notre module est filaire.  La seule fa√ßon de modifier les signaux de ce type est l'affectation √† long terme, qui est interdite √† l'int√©rieur du bloc Always.  Pour cette raison, le bloc Always utilise des registres, qui sont ensuite affect√©s aux signaux de sortie. <br><br><h3>  Cache de mappage direct </h3><br>  Le cache de mappage direct est l'un des types de cache les plus simples.  Dans cette impl√©mentation, le cache se compose de n √©l√©ments, et la RAM est conditionnellement divis√©e en blocs par n, puis le i-√®me √©l√©ment dans le cache correspond √† tous ces k-√®mes √©l√©ments en RAM qui satisfont la condition i = k% n. <br><br>  L'image ci-dessous montre un cache de taille 4 et une m√©moire RAM de taille 16. <br><br><img src="https://habrastorage.org/webt/k9/a-/_4/k9a-_4tdp2uqa6jmzqtcx7p5tfm.png"><br><br>  Chaque √©l√©ment de cache contient les informations suivantes: <br><br><ul><li>  <b>bit de validit√©</b> - si les informations dans le cache sont pertinentes. </li><li>  <b>tag</b> est le num√©ro de bloc dans la RAM o√π se trouve cet √©l√©ment. </li><li>  <b>donn√©es</b> - informations que nous √©crivons / lisons. </li></ul><br>  Lorsqu'on lui demande de lire, le cache divise l'adresse d'entr√©e en deux parties - une balise et un index.  La taille de l'index est log (n), o√π n est la taille du cache. <br><br><h4>  √âtape 1: d√©claration du module avec les signaux d'entr√©e / sortie correspondants </h4><br><pre> <code class="plaintext hljs">module direct_mapping_cache ( input [word_size-1:0] data, input [word_size-1:0] addr, input wr, input clk, output response, output is_missrate, output [word_size-1:0] out ); parameter word_size = 32;</code> </pre><br>  La d√©claration du module de cache est identique √† la RAM, √† l'exception du nouveau signal de sortie is_missrate.  Cette sortie stocke des informations indiquant si la derni√®re demande de lecture a √©t√© un taux d'erreur. <br><br><h4>  √âtape 2: d√©claration des registres et de la RAM </h4><br>  Avant de d√©clarer les registres, nous d√©terminons la taille du cache et de l'index: <br><br><pre> <code class="plaintext hljs">parameter size = 64; parameter index_size = 6;</code> </pre><br>  Ensuite, nous d√©clarons un tableau dans lequel les donn√©es que nous √©crivons et lisons seront stock√©es: <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] data_array [size-1:0];</code> </pre><br>  Nous devons √©galement stocker des bits de validit√© et des balises pour chaque √©l√©ment dans le cache: <br><br><pre> <code class="plaintext hljs">reg validity_array [size-1:0]; reg [word_size-index_size-1:0] tag_array [size-1:0]; reg [index_size-1:0] index_array [size-1:0];</code> </pre><br>  Registres dans lesquels l'adresse d'entr√©e sera divis√©e: <br><br><pre> <code class="plaintext hljs">reg [word_size-index_size-1:0] tag; reg [index_size-1:0] index;</code> </pre><br>  Registres qui stockent les valeurs d'entr√©e sur l'horloge pr√©c√©dente (pour suivre les changements dans les donn√©es d'entr√©e): <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] data_reg; reg [word_size-1:0] addr_reg; reg wr_reg;</code> </pre><br>  Registres pour la mise √† jour des signaux de sortie apr√®s les calculs dans le bloc toujours: <br><br><pre> <code class="plaintext hljs">reg response_reg; reg is_missrate_reg; reg [word_size-1:0] out_reg;</code> </pre><br>  Valeurs d'entr√©e pour la RAM: <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] ram_data; reg [word_size-1:0] ram_addr; reg ram_wr;</code> </pre><br>  Valeurs de sortie pour la RAM: <br><br><pre> <code class="plaintext hljs">wire ram_response; wire [word_size-1:0] ram_out;</code> </pre><br>  D√©claration d'un module RAM et connexion des signaux d'entr√©e et de sortie: <br><br><pre> <code class="plaintext hljs">ram ram( .data(ram_data), .addr(ram_addr), .wr(ram_wr), .clk(clk), .response(ram_response), .out(ram_out));</code> </pre><br>  Initialisation du registre: <br><br><pre> <code class="plaintext hljs">initial integer i initial begin data_reg = 0; addr_reg = 0; wr_reg = 0; for (i = 0; i &lt; size; i=i+1) begin data_array[i] = 0; tag_array[i] = 0; validity_array[i] = 0; end end</code> </pre><br><h4>  √âtape 3: impl√©menter la logique toujours du bloc </h4><br>  Pour commencer, pour chaque horloge, nous avons deux √©tats - les donn√©es d'entr√©e sont modifi√©es ou non.  Sur cette base, nous avons la condition suivante: <br><br><pre> <code class="plaintext hljs">always @(posedge clk) begin if (data_reg != data || addr_reg != addr || wr_reg != wr) begin end // 1:    else begin // 2:     end end</code> </pre><br>  <b>Bloc 1.</b> Dans le cas o√π les donn√©es d'entr√©e sont modifi√©es, la premi√®re chose que nous faisons est de r√©initialiser l'√©tat de pr√©paration √† 0: <br><br><pre> <code class="plaintext hljs">response_reg = 0;</code> </pre><br>  Ensuite, nous mettons √† jour les registres qui stockaient les valeurs d'entr√©e de l'horloge pr√©c√©dente: <br><br><pre> <code class="plaintext hljs">data_reg = data; addr_reg = addr; wr_reg = wr;</code> </pre><br>  Nous divisons l'adresse d'entr√©e en une balise et un index: <br><br><pre> <code class="plaintext hljs">tag = addr &gt;&gt; index_size; index = addr;</code> </pre><br>  Pour calculer la balise, un d√©calage bit √† droite est utilis√©, pour l'index, il suffit de simplement l'affecter, car  Les bits suppl√©mentaires de l'adresse ne sont pas pris en compte. <br><br>  L'√©tape suivante consiste √† choisir entre l'√©criture et la lecture: <br><br><pre> <code class="plaintext hljs">if (wr) begin //  data_array[index] = data; tag_array[index] = tag; validity_array[index] = 1; ram_data = data; ram_addr = addr; ram_wr = wr; end else begin //  if ((validity_array[index]) &amp;&amp; (tag == tag_array[index])) begin //    is_missrate_reg = 0; out_reg = data_array[index]; response_reg = 1; end else begin //     is_missrate_reg = 1; ram_data = data; ram_addr = addr; ram_wr = wr; end end</code> </pre><br>  Dans le cas de l'enregistrement, nous modifions d'abord les donn√©es dans le cache, puis mettons √† jour les donn√©es d'entr√©e pour la RAM.  Dans le cas de la lecture, on v√©rifie la pr√©sence de cet √©l√©ment dans le cache et, s'il existe, on l'√©crit dans out_reg, sinon on acc√®de √† la RAM. <br><br>  <b>Bloc 2.</b> Si les donn√©es n'ont pas √©t√© modifi√©es depuis l'ex√©cution de l'horloge pr√©c√©dente, nous avons alors le code suivant: <br><br><pre> <code class="plaintext hljs">if ((ram_response) &amp;&amp; (!response_reg)) begin if (wr == 0) begin validity_array [index] = 1; data_array [index] = ram_out; tag_array[index] = tag; out_reg = ram_out; end response_reg = 1; end</code> </pre><br>  Ici, nous attendons la fin de l'acc√®s √† la RAM (s'il n'y avait pas d'acc√®s, ram_response est 1), mettons √† jour les donn√©es s'il y avait une commande de lecture et d√©finissons la pr√©paration du cache √† 1. <br><br>  Et enfin, mettez √† jour les valeurs de sortie: <br><br><pre> <code class="plaintext hljs">assign out = out_reg; assign is_missrate = is_missrate_reg; assign response = response_reg;</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461611/">https://habr.com/ru/post/fr461611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461593/index.html">API sur F #. Acc√©der aux modules d'application bas√©s sur les r√¥les</a></li>
<li><a href="../fr461595/index.html">De la th√©orie √† la pratique: comment les √©tudiants de premier cycle de la facult√© de photonique et d'optoinformatique √©tudient et travaillent</a></li>
<li><a href="../fr461601/index.html">Ce qu'un fondateur non technique devrait savoir sur le d√©veloppement de logiciels</a></li>
<li><a href="../fr461605/index.html">Cr√©ation de Tower Defense dans Unity: balistique</a></li>
<li><a href="../fr461607/index.html">Fonctionnement de l'adaptateur vid√©o Apple Lightning</a></li>
<li><a href="../fr461613/index.html">Etude de l'autod√©charge de la batterie</a></li>
<li><a href="../fr461615/index.html">4 p√©ch√©s capitaux des √©couteurs TWS: pourquoi True Wireless n'est toujours pas un g√¢chis?</a></li>
<li><a href="../fr461617/index.html">Th√©orie d'un d√©marrage r√©ussi</a></li>
<li><a href="../fr461621/index.html">Est-il difficile d'√©crire votre premier programme VHDL?</a></li>
<li><a href="../fr461623/index.html">Comment nous avons cr√©√© le moteur et le jeu pendant un an et demi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>