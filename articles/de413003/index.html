<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🍳 🧠 🏳️‍🌈 Der Steam-Client beseitigte eine gefährliche Sicherheitslücke, die sich dort seit zehn Jahren versteckt hatte 👨‍✈️ 👩🏻‍🚒 🤹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der leitende Forscher Tom Court of Context, ein Unternehmen für Informationssicherheit, spricht darüber, wie er es geschafft hat, einen potenziell gef...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Der Steam-Client beseitigte eine gefährliche Sicherheitslücke, die sich dort seit zehn Jahren versteckt hatte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413003/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5e/654/14d/b5e65414d10ab23ed9f334c7490b5b41.jpg" alt="Bild"></div><br>  <i>Der leitende Forscher Tom Court of Context, ein Unternehmen für Informationssicherheit, spricht darüber, wie er es geschafft hat, einen potenziell gefährlichen Fehler im Steam-Clientcode zu erkennen.</i> <br><br>  Sicherheitsbewusste PC-Spieler haben festgestellt, dass Valve kürzlich ein neues Steam-Client-Update veröffentlicht hat. <br><br>  In diesem Beitrag möchte ich mich <s>für das Spielen von Spielen bei der Arbeit entschuldigen,</s> um die Geschichte eines verwandten Fehlers <s>zu</s> erzählen, der mindestens zehn Jahre lang im Steam-Client aufgetreten ist und bis Juli letzten Jahres zur Ausführung von Remotecode führen kann (Remotecode-Ausführung, RCE). Insgesamt 15 Millionen aktive Kunden. <br><br>  Seit Juli, als Valve (endlich) seinen Code mit aktiviertem modernen Exploit-Schutz kompilierte, konnte dies nur zu einem Clientfehler führen, und RCE war nur in Kombination mit einer separaten Sicherheitslücke in Bezug auf Informationslecks möglich. <br><br>  Wir haben Valve am 20. Februar 2018 als Sicherheitslücke deklariert und es, wie das Unternehmen zu verdanken hat, weniger als 12 Stunden später in der Beta-Filiale behoben.  Der Fix wurde am 22. März 2018 in die stabile Filiale verschoben. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e75/1aa/558/e751aa55836f621b240641f85adbde62.jpg" alt="Bild"></div><br><h2>  Kurzer Rückblick </h2><br>  Die Grundlage der Sicherheitsanfälligkeit war eine Beschädigung des Heapspeichers in der Steam-Clientbibliothek, die remote aufgerufen werden konnte, in dem Teil des Codes, der an der Wiederherstellung des fragmentierten Datagramms aus mehreren empfangenen UDP-Paketen beteiligt war. <br><br>  Der Steam-Client tauscht Daten über sein eigenes Protokoll (Steam-Protokoll) aus, das über UDP implementiert ist.  Es gibt zwei Bereiche in diesem Protokoll, die aufgrund der Sicherheitsanfälligkeit besonders interessant sind: <br><br><ul><li>  Paketlänge </li><li>  Die Gesamtlänge des rekonstruierten Datagramms </li></ul><br>  Der Fehler wurde durch das Fehlen einer einfachen Überprüfung verursacht.  Der Code hat nicht überprüft, ob die Länge des ersten fragmentierten Datagramms kleiner oder gleich der Gesamtlänge des Datagramms ist.  Dies scheint ein allgemeines Versehen zu sein, da für alle nachfolgenden Pakete, die Fragmente des Datagramms übertragen, die Überprüfung durchgeführt wird. <br><br>  Ohne zusätzliche Datenleckfehler ist der Heap-Schaden auf modernen Betriebssystemen sehr schwer zu kontrollieren, sodass die Remote-Codeausführung schwierig zu implementieren ist.  In diesem Fall könnte dieser Fehler jedoch dank des Steam-eigenen Speicherzuweisers und der ASLR, die in der Binärdatei steamclient.dll fehlten (bis zum letzten Juli), als Grundlage für einen sehr zuverlässigen Exploit verwendet werden. <br><br>  Nachfolgend finden Sie eine technische Beschreibung der Sicherheitsanfälligkeit und des damit verbundenen Exploits bis <br>  Implementierungen der Codeausführung. <br><br><h2>  Sicherheitslücken Details </h2><br><h3>  Informationen, die zum Verständnis notwendig sind </h3><br><h4>  Protokoll </h4><br>  Dritte (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://imfreedom.org/wiki/Steam_Friends</a> ) führten basierend auf der Analyse des vom Steam-Client generierten Datenverkehrs ein Reverse Engineering durch und erstellten eine detaillierte Dokumentation des Steam-Protokolls.  Das Protokoll wurde ursprünglich 2008 dokumentiert und hat sich seitdem kaum verändert. <br><br>  Das Protokoll wird als Übertragungsprotokoll mit dem Aufbau einer Verbindung über einen Strom von UDP-Datagrammen implementiert.  Pakete haben gemäß der Dokumentation unter dem obigen Link die folgende Struktur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/d59/e25/94bd59e25c5dfac228e3a63b62192717.jpg" alt="Bild"></div><br>  Wichtige Aspekte: <br><br><ul><li>  Alle Pakete beginnen mit 4 Bytes " <em>VS01</em> " </li><li>  <em>packet_len</em> beschreibt die Länge nützlicher Informationen (bei unfragmentierten Datagrammen entspricht der Wert der Länge der Daten) </li><li>  <em>Typ</em> beschreibt den Pakettyp, der die folgenden Werte haben kann: <br><ul><li>  0x2 Anrufauthentifizierung </li><li>  0x4 Verbindung akzeptieren </li><li>  0x5 Verbindung zurücksetzen </li><li>  0x6 Ein Paket ist ein Fragment eines Datagramms </li><li>  Das 0x7-Paket ist ein separates Datagramm </li></ul></li><li>  Die <em>Quell-</em> und <em>Zielfelder</em> sind Bezeichner, die zugewiesen sind, um Pakete auf mehreren Verbindungen innerhalb des Steam-Clients korrekt weiterzuleiten </li><li>  Falls das Paket ein Fragment eines Datagramms ist: <br><ul><li>  <em>split_count</em> gibt die Anzahl der Fragmente an, in die das Datagramm aufgeteilt ist </li><li>  <em>data_len</em> gibt die Gesamtlänge des wiederhergestellten Datagramms an </li></ul></li><li>  Die <em>Erstverarbeitung</em> dieser UDP-Pakete erfolgt in der Funktion <em>CUDPConnection :: UDPRecvPkt</em> in steamclient.dll </li></ul><br><h4>  Verschlüsselung </h4><br>  Nützliche Informationen des Datagrammpakets werden von AES-256 mithilfe eines Schlüssels verschlüsselt, der in jeder Sitzung zwischen Client und Server ausgehandelt wird.  Die Schlüsselverhandlung wird wie folgt durchgeführt: <br><br><ul><li>  Der Client generiert einen 32-Byte-AES-Zufallsschlüssel und RSA verschlüsselt ihn mit dem öffentlichen Valve-Schlüssel, bevor er an den Server gesendet wird. </li><li>  Der Server mit einem privaten Schlüssel kann diesen Wert entschlüsseln und als AES-256-Schlüssel akzeptieren, der in der Sitzung verwendet wird </li><li>  Nachdem der Schlüssel vereinbart wurde, werden alle nützlichen Informationen in der aktuellen Sitzung mit diesem Schlüssel verschlüsselt. </li></ul><br><h3>  Sicherheitslücke </h3><br>  Die <em>RecvFragment-</em> Methode der <em>CUDPConnection-</em> Klasse <em>weist eine Sicherheitsanfälligkeit</em> auf.  In der Release-Version der Steamclient-Bibliothek gibt es keine Symbole. Beim Durchsuchen von Binärzeilen in einer für uns interessanten Funktion wird jedoch ein Link zu " <em>CUDPConnection :: RecvFragment</em> " gefunden.  Die Eingabe dieser Funktion erfolgt, wenn der Client ein UDP-Paket empfängt, das ein Steam-Datagramm vom Typ 0x6 (ein „Fragment eines Datagramms“) enthält. <br><br>  1. Die Funktion überprüft zunächst den Verbindungsstatus, um sicherzustellen, dass er sich im Status „ <em>Verbunden</em> “ befindet. <br>  2. Anschließend wird das Feld <em>data_len</em> im Steam-Datagramm überprüft, um sicherzustellen, dass es weniger als <em>0x20000060</em> Byte enthält (anscheinend wird dieser Wert willkürlich ausgewählt). <br>  3. Wenn der Test erfolgreich ist, prüft die Funktion, ob die Verbindung Fragmente eines Datagramms sammelt oder ob es sich um das erste Paket des Streams handelt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb3/19b/451/cb319b451e64f08c718a78f0f2c5995c.jpg" alt="Bild"></div><br>  4. Wenn dies das erste Paket im Stream ist, wird das Feld <em>split_count überprüft</em> , um <em>festzustellen</em> , wie viele Pakete dieser Stream strecken wird <br>  5. Wenn der Stream in mehrere Pakete unterteilt ist, wird das Feld <em>seq_no_of_first_pkt überprüft</em> , um sicherzustellen, dass es mit der Seriennummer des aktuellen Pakets übereinstimmt.  Dies stellt sicher, dass das Paket das erste im Stream ist. <br>  6. Das Feld <em>data_len</em> wird erneut gegen das Limit von <em>0x20000060</em> Bytes <em>geprüft</em> .  Außerdem wird überprüft, <em>ob split_count</em> weniger als <em>0x709b-</em> Pakete enthält. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e6/19b/250/7e619b25083dc91558888ef6ca1b6ef4.jpg" alt="Bild"></div><br>  7. Wenn diese Bedingungen erfüllt sind, wird ein Boolescher Wert festgelegt, der angibt, dass jetzt Fragmente gesammelt werden.  Es wird auch überprüft, ob noch kein Puffer zum Speichern von Fragmenten zugewiesen ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69a/8b2/8c4/69a8b28c40e56f3de825d6a6c8c483c0.jpg" alt="Bild"></div><br>  8. Wenn der Zeiger auf den Fragmentauflistungspuffer nicht Null ist, wird der aktuelle Fragmentauflistungspuffer freigegeben und ein neuer Puffer zugewiesen (siehe das gelbe Rechteck in der folgenden Abbildung).  Hier tritt der Fehler auf.  Es wird erwartet, dass der Fragmentauflistungspuffer in der Größe von <em>data_len</em> Bytes <em>zugewiesen wird</em> .  Wenn alles erfolgreich war (und der Code nicht überprüft - ein kleiner Fehler), werden die nützlichen Informationen des Datagramms mit <em>memmove</em> in diesen Puffer kopiert, wobei <em>darauf</em> vertraut wird, dass die Anzahl der zu kopierenden Bytes in <em>packet_len angegeben ist</em> . <br><br>  <strong>Das wichtigste Versehen des Entwicklers war, dass die Prüfung " <em>packet_len ist</em> kleiner oder gleich <em>data_len</em> " nicht durchgeführt wird.</strong>  <strong>Dies bedeutet, dass es möglich ist, <em>data_len</em> weniger als <em>packet_len zu übertragen</em> und bis zu 64 KB Daten (da das Feld <em>packet_len</em> 2 Byte breit ist) in einen sehr kleinen Puffer kopiert zu haben, wodurch die Heap-Beschädigung ausgenutzt werden kann.</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/6ae/a31/d4c6aea31e05f0479552817bbc95a1e3.jpg" alt="Bild"></div><br><h2>  Ausnutzung der Verwundbarkeit </h2><br>  In diesem Abschnitt wird davon ausgegangen, dass es eine Problemumgehung für ASLR gibt.  Dies führt dazu, dass vor dem Start des Betriebs die Startadresse von steamclient.dll bekannt ist. <br><br><h3>  Paket-Spoofing </h3><br>  Damit die angreifenden UDP-Pakete vom Client empfangen werden können, muss er das ausgehende Datagramm (Client -&gt; Server) untersuchen, das gesendet wird, um die Kennungen der Client / Server-Verbindung sowie die Seriennummer herauszufinden.  Anschließend muss der Angreifer die IP-Adressen und Quell- / Zielports zusammen mit den Client / Server-IDs fälschen und die gelernte Seriennummer um eins erhöhen. <br><br><h3>  Speicherverwaltung </h3><br>  Um mehr als 1024 (0x400) Bytes Speicher zuzuweisen, wird ein Standard-Systemzuweiser verwendet.  Um Speicher mit weniger als oder gleich 1024 Byte zuzuweisen, verwendet Steam einen eigenen Allokator, der auf allen unterstützten Plattformen gleich funktioniert.  In diesem Artikel wird dieser Distributor mit Ausnahme der folgenden Schlüsselaspekte nicht im Detail erläutert: <br><br><ol><li>  Vom Systemzuweiser werden große Speicherblöcke angefordert, die dann zur Verwendung unter Steam-Client-Speicherzuweisungsanforderungen in Fragmente fester Größe unterteilt werden. </li><li>  Die Auswahl erfolgt nacheinander, zwischen den verwendeten Fragmenten gibt es keine Metadaten, die sie trennen. </li><li>  Jeder große Block speichert seine eigene freie Speicherliste, die als einfach verknüpfte Liste implementiert ist. </li><li>  Der obere Rand der Liste des freien Speichers zeigt das erste freie Fragment im Speicher an, und die ersten 4 Bytes dieses Fragments geben das nächste freie Fragment an (falls vorhanden). </li></ol><br><h4>  Speicherzuordnung </h4><br>  Beim Zuweisen von Speicher wird der erste freie Block vom Anfang der Liste des freien Speichers getrennt, und die ersten 4 Bytes dieses Blocks, die <em>next_free_block</em> entsprechen, werden in die Mitgliedsvariable <em>freelist_head</em> innerhalb der <em>Allokatorklasse</em> kopiert. <br><br><h4>  Freier Speicher </h4><br>  Wenn ein Block freigegeben wird, wird das Feld <em>freelist_head</em> in die ersten 4 Bytes des freigegebenen Blocks ( <em>next_free_block</em> ) <em>kopiert</em> , und die Adresse des freigegebenen Blocks wird in die Mitgliedsvariable <em>freelist_head</em> der Verteilerklasse kopiert. <br><br><h3>  So erhalten Sie ein Aufnahmeprimitiv </h3><br>  Auf dem Heap tritt ein Pufferüberlauf auf. Abhängig von der Größe der Pakete, die die Beschädigung verursacht haben, kann die Speicherzuweisung entweder durch den Standard-Windows-Allokator (bei Speicherzuweisung von mehr als 0 x 400 Byte) oder durch den Steam-eigenen Zuweiser (bei Zuweisung von Speicher unter 0x400 Byte) gesteuert werden.  Aufgrund des Mangels an Sicherheitsmaßnahmen in meinem eigenen Steam-Distributor entschied ich, dass es einfacher war, es für einen Exploit zu verwenden. <br><br>  Kehren wir zum Abschnitt über die Speicherverwaltung zurück: Es ist bekannt, dass der Anfang der Liste der freien Speicher von Blöcken einer bestimmten Größe als Mitgliedsvariable der Verteilerklasse gespeichert wird und der Zeiger auf den nächsten freien Block in der Liste als die ersten 4 Bytes jedes freien Blocks der Liste gespeichert wird. <br><br>  Wenn sich neben dem Block, in dem der Überlauf aufgetreten ist, ein freier Block befindet, können wir durch Beschädigung des Heaps den Zeiger <em>next_free_block</em> überschreiben.  Wenn Sie der Meinung sind, dass ein Bündel dafür vorbereitet werden kann, kann der neu <em>geschriebene</em> Zeiger <em>next_free_block</em> auf eine Adresse zum Schreiben gesetzt werden, wonach die nachfolgende Speicherzuweisung an diese Stelle geschrieben wird. <br><br><h3>  Was zu verwenden ist: Datagramme oder Fragmente </h3><br>  Ein Fehler mit Speicherbeschädigung tritt im Code auf, der für die Verarbeitung von Fragmenten von Datagrammen (Paketen vom Typ 6) verantwortlich ist.  Nach dem Auftreten eines Schadens befindet sich die <em>RecvFragment ()</em> -Funktion in einem Zustand, in dem weitere Fragmente erwartet werden.  Wenn sie jedoch ankommen, wird eine Überprüfung durchgeführt: <br><br> <code>fragment_size + num_bytes_already_received &lt; sizeof(collection_buffer)</code> <br> <br>  Dies ist jedoch offensichtlich nicht der Fall, da unser erstes Paket bereits gegen diese Regel verstoßen hat (das Vorhandensein eines Fehlers kann diese Prüfung überspringen) und ein Fehler auftritt.  Um dies zu vermeiden, müssen Sie die <em>CUDPConnection :: RecvFragment ()</em> -Methode nach einer Speicherbeschädigung vermeiden. <br><br>  Glücklicherweise kann <em>CUDPConnection :: RecvDatagram ()</em> weiterhin gesendete Pakete vom Typ 7 (Datagramme) empfangen und verarbeiten, bis <em>RecvFragment ()</em> gültig ist, und dies kann zum Starten des Aufzeichnungsprimitivs verwendet werden. <br><br><h3>  Verschlüsselungsprobleme </h3><br>  Es wird erwartet, dass die von <em>RecvDatagram ()</em> und <em>RecvFragment ()</em> empfangenen Pakete verschlüsselt werden.  Bei <em>RecvDatagram () erfolgt die</em> Entschlüsselung fast unmittelbar nach dem Empfang.  Im Fall von <em>RecvFragment () tritt</em> es nach dem Empfang des letzten Fragments in der Sitzung auf. <br><br>  Das Problem der Ausnutzung der Sicherheitsanfälligkeit tritt auf, weil wir den in jeder Sitzung erstellten Verschlüsselungsschlüssel nicht kennen.  Dies bedeutet, dass jeder OP-Code / Shell-Code, den wir senden, mit AES256 „entschlüsselt“ wird, wodurch unsere Daten in Müll umgewandelt werden.  Daher ist es notwendig, eine Betriebsmethode zu finden, die fast unmittelbar nach dem Empfang des Pakets möglich ist, bevor die Entschlüsselungsprozeduren die im Paketpuffer enthaltenen nützlichen Informationen verarbeiten können. <br><br><h3>  So erreichen Sie die Codeausführung </h3><br>  Angesichts der oben beschriebenen Entschlüsselungsbeschränkung sollte die Operation vor der Entschlüsselung der eingehenden Daten durchgeführt werden.  Dies führt zu zusätzlichen Einschränkungen, aber die Aufgabe ist noch möglich: Sie können den Zeiger so umschreiben, dass er auf das <em>CWorkThreadPool-</em> Objekt verweist, das an einer vorhersehbaren Stelle im <em>Datenabschnitt</em> der Binärdatei gespeichert ist.  Obwohl die Details und internen Funktionen dieser Klasse unbekannt sind, kann anhand ihres Namens angenommen werden, dass sie einen Thread-Pool unterstützt, den Sie verwenden können, wenn Sie "arbeiten" müssen.  Nachdem Sie mehrere Debugging-Zeilen in einer Binärdatei untersucht haben, können Sie verstehen, dass unter solchen Arbeiten Verschlüsselung und Entschlüsselung ( <em>CWorkItemNetFilterEncrypt</em> , <em>CWorkItemNetFilterDecrypt</em> ) vorhanden sind. Wenn diese Aufgaben in die Warteschlange gestellt werden, wird die <em>CWorkThreadPool-</em> Klasse <em>verwendet</em> .  Indem wir diesen Zeiger überschreiben und die gewünschte Stelle darin schreiben, können wir den vtable-Zeiger und die damit verbundene vtable simulieren, wodurch wir beispielsweise Code ausführen können, wenn <em>CWorkThreadPool :: AddWorkItem ()</em> aufgerufen wird, was vor Entschlüsselungsprozessen geschehen muss. <br><br>  Die folgende Abbildung zeigt die erfolgreiche Ausnutzung der Sicherheitsanfälligkeit bis zur Erlangung der Kontrolle über das EIP-Register. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/383/537/4a83835371112599ca429941e449e734.jpg" alt="Bild"></div><br>  Von nun an können Sie eine ROP-Kette erstellen, die zur Ausführung von beliebigem Code führt.  Das folgende Video zeigt, wie ein Angreifer einen Windows-Rechner in einer vollständig gepatchten Version von Windows 10 remote startet. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0QaozC8S0Aw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Zusammenfassend </h2><br>  Wenn Sie zu diesem Teil des Artikels gelangen, vielen Dank für Ihre Beharrlichkeit!  Ich hoffe, Sie verstehen, dass dies ein sehr einfacher Fehler ist, der aufgrund des Mangels an modernen Mitteln zum Schutz vor Exploits recht einfach auszunutzen war.  Der anfällige Code war wahrscheinlich sehr alt, aber ansonsten funktionierte er gut, sodass die Entwickler nicht die Notwendigkeit sahen, ihn zu untersuchen oder seine Build-Skripte zu aktualisieren.  Die Lehre hier ist, dass es für Entwickler wichtig ist, alten Code regelmäßig zu überprüfen und Systeme zu erstellen, um sicherzustellen, dass sie den modernen Sicherheitsstandards entsprechen, auch wenn die Funktionalität des Codes selbst unverändert bleibt.  Es war erstaunlich, 2018 einen so einfachen Fehler mit so schwerwiegenden Folgen auf einer sehr beliebten Softwareplattform zu finden.  Dies sollte ein Anreiz sein, für alle Forscher nach solchen Schwachstellen zu suchen! <br><br>  Schließlich lohnt es sich, über den Prozess der verantwortungsvollen Offenlegung von Informationen zu sprechen.  Wir haben Valve diesen Fehler in einem Brief an ihr Sicherheitsteam ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">security@valvesoftware.com</a> ) gegen 16 Uhr GMT gemeldet. Nur 8 Stunden später wurde ein Fix erstellt und im Beta-Client Steam gestartet.  Dank dessen steht Valve nun an erster Stelle in unserer (imaginären) Tabelle des Wettbewerbs „Wer wird die Sicherheitsanfälligkeit schneller beheben?“ - eine angenehme Ausnahme im Vergleich zur Offenlegung von Fehlern gegenüber anderen Unternehmen, was häufig zu einem langen Genehmigungsprozess führt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine Seite, die die Details aller Client-Updates beschreibt</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413003/">https://habr.com/ru/post/de413003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412993/index.html">Infrastruktur für öffentliche Schlüssel: Dienstprogramm zur Generierung qualifizierter Zertifikatsanforderungen</a></li>
<li><a href="../de412995/index.html">SAP schnell</a></li>
<li><a href="../de412997/index.html">Verstecken oder das erste Botnetz, das keinen Neustart befürchtet</a></li>
<li><a href="../de412999/index.html">Vom Summen der Giraffen bis zu den Geräuschen mimetischer Vögel - gemeinsam der Natur lauschen</a></li>
<li><a href="../de413001/index.html">SamsPcbGuide, Teil 5: Verfolgen von Signallinien. Leitungsverzerrung und Impedanzanpassung</a></li>
<li><a href="../de413005/index.html">Blockchain - ein Heilmittel gegen die Hauptkrankheiten der modernen Bildung</a></li>
<li><a href="../de413007/index.html">Seltsame Synthese bei der Arbeit mit FPGA</a></li>
<li><a href="../de413009/index.html">Python-Umgebungsverwaltung mit Pipenv</a></li>
<li><a href="../de413011/index.html">Keller des Todes</a></li>
<li><a href="../de413013/index.html">Der Wunsch nach Transparenz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>