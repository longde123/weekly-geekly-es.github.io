<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüç≥ üß† üè≥Ô∏è‚Äçüåà Der Steam-Client beseitigte eine gef√§hrliche Sicherheitsl√ºcke, die sich dort seit zehn Jahren versteckt hatte üë®‚Äç‚úàÔ∏è üë©üèª‚Äçüöí ü§π</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der leitende Forscher Tom Court of Context, ein Unternehmen f√ºr Informationssicherheit, spricht dar√ºber, wie er es geschafft hat, einen potenziell gef...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Der Steam-Client beseitigte eine gef√§hrliche Sicherheitsl√ºcke, die sich dort seit zehn Jahren versteckt hatte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413003/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5e/654/14d/b5e65414d10ab23ed9f334c7490b5b41.jpg" alt="Bild"></div><br>  <i>Der leitende Forscher Tom Court of Context, ein Unternehmen f√ºr Informationssicherheit, spricht dar√ºber, wie er es geschafft hat, einen potenziell gef√§hrlichen Fehler im Steam-Clientcode zu erkennen.</i> <br><br>  Sicherheitsbewusste PC-Spieler haben festgestellt, dass Valve k√ºrzlich ein neues Steam-Client-Update ver√∂ffentlicht hat. <br><br>  In diesem Beitrag m√∂chte ich mich <s>f√ºr das Spielen von Spielen bei der Arbeit entschuldigen,</s> um die Geschichte eines verwandten Fehlers <s>zu</s> erz√§hlen, der mindestens zehn Jahre lang im Steam-Client aufgetreten ist und bis Juli letzten Jahres zur Ausf√ºhrung von Remotecode f√ºhren kann (Remotecode-Ausf√ºhrung, RCE). Insgesamt 15 Millionen aktive Kunden. <br><br>  Seit Juli, als Valve (endlich) seinen Code mit aktiviertem modernen Exploit-Schutz kompilierte, konnte dies nur zu einem Clientfehler f√ºhren, und RCE war nur in Kombination mit einer separaten Sicherheitsl√ºcke in Bezug auf Informationslecks m√∂glich. <br><br>  Wir haben Valve am 20. Februar 2018 als Sicherheitsl√ºcke deklariert und es, wie das Unternehmen zu verdanken hat, weniger als 12 Stunden sp√§ter in der Beta-Filiale behoben.  Der Fix wurde am 22. M√§rz 2018 in die stabile Filiale verschoben. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e75/1aa/558/e751aa55836f621b240641f85adbde62.jpg" alt="Bild"></div><br><h2>  Kurzer R√ºckblick </h2><br>  Die Grundlage der Sicherheitsanf√§lligkeit war eine Besch√§digung des Heapspeichers in der Steam-Clientbibliothek, die remote aufgerufen werden konnte, in dem Teil des Codes, der an der Wiederherstellung des fragmentierten Datagramms aus mehreren empfangenen UDP-Paketen beteiligt war. <br><br>  Der Steam-Client tauscht Daten √ºber sein eigenes Protokoll (Steam-Protokoll) aus, das √ºber UDP implementiert ist.  Es gibt zwei Bereiche in diesem Protokoll, die aufgrund der Sicherheitsanf√§lligkeit besonders interessant sind: <br><br><ul><li>  Paketl√§nge </li><li>  Die Gesamtl√§nge des rekonstruierten Datagramms </li></ul><br>  Der Fehler wurde durch das Fehlen einer einfachen √úberpr√ºfung verursacht.  Der Code hat nicht √ºberpr√ºft, ob die L√§nge des ersten fragmentierten Datagramms kleiner oder gleich der Gesamtl√§nge des Datagramms ist.  Dies scheint ein allgemeines Versehen zu sein, da f√ºr alle nachfolgenden Pakete, die Fragmente des Datagramms √ºbertragen, die √úberpr√ºfung durchgef√ºhrt wird. <br><br>  Ohne zus√§tzliche Datenleckfehler ist der Heap-Schaden auf modernen Betriebssystemen sehr schwer zu kontrollieren, sodass die Remote-Codeausf√ºhrung schwierig zu implementieren ist.  In diesem Fall k√∂nnte dieser Fehler jedoch dank des Steam-eigenen Speicherzuweisers und der ASLR, die in der Bin√§rdatei steamclient.dll fehlten (bis zum letzten Juli), als Grundlage f√ºr einen sehr zuverl√§ssigen Exploit verwendet werden. <br><br>  Nachfolgend finden Sie eine technische Beschreibung der Sicherheitsanf√§lligkeit und des damit verbundenen Exploits bis <br>  Implementierungen der Codeausf√ºhrung. <br><br><h2>  Sicherheitsl√ºcken Details </h2><br><h3>  Informationen, die zum Verst√§ndnis notwendig sind </h3><br><h4>  Protokoll </h4><br>  Dritte (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://imfreedom.org/wiki/Steam_Friends</a> ) f√ºhrten basierend auf der Analyse des vom Steam-Client generierten Datenverkehrs ein Reverse Engineering durch und erstellten eine detaillierte Dokumentation des Steam-Protokolls.  Das Protokoll wurde urspr√ºnglich 2008 dokumentiert und hat sich seitdem kaum ver√§ndert. <br><br>  Das Protokoll wird als √úbertragungsprotokoll mit dem Aufbau einer Verbindung √ºber einen Strom von UDP-Datagrammen implementiert.  Pakete haben gem√§√ü der Dokumentation unter dem obigen Link die folgende Struktur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/d59/e25/94bd59e25c5dfac228e3a63b62192717.jpg" alt="Bild"></div><br>  Wichtige Aspekte: <br><br><ul><li>  Alle Pakete beginnen mit 4 Bytes " <em>VS01</em> " </li><li>  <em>packet_len</em> beschreibt die L√§nge n√ºtzlicher Informationen (bei unfragmentierten Datagrammen entspricht der Wert der L√§nge der Daten) </li><li>  <em>Typ</em> beschreibt den Pakettyp, der die folgenden Werte haben kann: <br><ul><li>  0x2 Anrufauthentifizierung </li><li>  0x4 Verbindung akzeptieren </li><li>  0x5 Verbindung zur√ºcksetzen </li><li>  0x6 Ein Paket ist ein Fragment eines Datagramms </li><li>  Das 0x7-Paket ist ein separates Datagramm </li></ul></li><li>  Die <em>Quell-</em> und <em>Zielfelder</em> sind Bezeichner, die zugewiesen sind, um Pakete auf mehreren Verbindungen innerhalb des Steam-Clients korrekt weiterzuleiten </li><li>  Falls das Paket ein Fragment eines Datagramms ist: <br><ul><li>  <em>split_count</em> gibt die Anzahl der Fragmente an, in die das Datagramm aufgeteilt ist </li><li>  <em>data_len</em> gibt die Gesamtl√§nge des wiederhergestellten Datagramms an </li></ul></li><li>  Die <em>Erstverarbeitung</em> dieser UDP-Pakete erfolgt in der Funktion <em>CUDPConnection :: UDPRecvPkt</em> in steamclient.dll </li></ul><br><h4>  Verschl√ºsselung </h4><br>  N√ºtzliche Informationen des Datagrammpakets werden von AES-256 mithilfe eines Schl√ºssels verschl√ºsselt, der in jeder Sitzung zwischen Client und Server ausgehandelt wird.  Die Schl√ºsselverhandlung wird wie folgt durchgef√ºhrt: <br><br><ul><li>  Der Client generiert einen 32-Byte-AES-Zufallsschl√ºssel und RSA verschl√ºsselt ihn mit dem √∂ffentlichen Valve-Schl√ºssel, bevor er an den Server gesendet wird. </li><li>  Der Server mit einem privaten Schl√ºssel kann diesen Wert entschl√ºsseln und als AES-256-Schl√ºssel akzeptieren, der in der Sitzung verwendet wird </li><li>  Nachdem der Schl√ºssel vereinbart wurde, werden alle n√ºtzlichen Informationen in der aktuellen Sitzung mit diesem Schl√ºssel verschl√ºsselt. </li></ul><br><h3>  Sicherheitsl√ºcke </h3><br>  Die <em>RecvFragment-</em> Methode der <em>CUDPConnection-</em> Klasse <em>weist eine Sicherheitsanf√§lligkeit</em> auf.  In der Release-Version der Steamclient-Bibliothek gibt es keine Symbole. Beim Durchsuchen von Bin√§rzeilen in einer f√ºr uns interessanten Funktion wird jedoch ein Link zu " <em>CUDPConnection :: RecvFragment</em> " gefunden.  Die Eingabe dieser Funktion erfolgt, wenn der Client ein UDP-Paket empf√§ngt, das ein Steam-Datagramm vom Typ 0x6 (ein ‚ÄûFragment eines Datagramms‚Äú) enth√§lt. <br><br>  1. Die Funktion √ºberpr√ºft zun√§chst den Verbindungsstatus, um sicherzustellen, dass er sich im Status ‚Äû <em>Verbunden</em> ‚Äú befindet. <br>  2. Anschlie√üend wird das Feld <em>data_len</em> im Steam-Datagramm √ºberpr√ºft, um sicherzustellen, dass es weniger als <em>0x20000060</em> Byte enth√§lt (anscheinend wird dieser Wert willk√ºrlich ausgew√§hlt). <br>  3. Wenn der Test erfolgreich ist, pr√ºft die Funktion, ob die Verbindung Fragmente eines Datagramms sammelt oder ob es sich um das erste Paket des Streams handelt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb3/19b/451/cb319b451e64f08c718a78f0f2c5995c.jpg" alt="Bild"></div><br>  4. Wenn dies das erste Paket im Stream ist, wird das Feld <em>split_count √ºberpr√ºft</em> , um <em>festzustellen</em> , wie viele Pakete dieser Stream strecken wird <br>  5. Wenn der Stream in mehrere Pakete unterteilt ist, wird das Feld <em>seq_no_of_first_pkt √ºberpr√ºft</em> , um sicherzustellen, dass es mit der Seriennummer des aktuellen Pakets √ºbereinstimmt.  Dies stellt sicher, dass das Paket das erste im Stream ist. <br>  6. Das Feld <em>data_len</em> wird erneut gegen das Limit von <em>0x20000060</em> Bytes <em>gepr√ºft</em> .  Au√üerdem wird √ºberpr√ºft, <em>ob split_count</em> weniger als <em>0x709b-</em> Pakete enth√§lt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e6/19b/250/7e619b25083dc91558888ef6ca1b6ef4.jpg" alt="Bild"></div><br>  7. Wenn diese Bedingungen erf√ºllt sind, wird ein Boolescher Wert festgelegt, der angibt, dass jetzt Fragmente gesammelt werden.  Es wird auch √ºberpr√ºft, ob noch kein Puffer zum Speichern von Fragmenten zugewiesen ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69a/8b2/8c4/69a8b28c40e56f3de825d6a6c8c483c0.jpg" alt="Bild"></div><br>  8. Wenn der Zeiger auf den Fragmentauflistungspuffer nicht Null ist, wird der aktuelle Fragmentauflistungspuffer freigegeben und ein neuer Puffer zugewiesen (siehe das gelbe Rechteck in der folgenden Abbildung).  Hier tritt der Fehler auf.  Es wird erwartet, dass der Fragmentauflistungspuffer in der Gr√∂√üe von <em>data_len</em> Bytes <em>zugewiesen wird</em> .  Wenn alles erfolgreich war (und der Code nicht √ºberpr√ºft - ein kleiner Fehler), werden die n√ºtzlichen Informationen des Datagramms mit <em>memmove</em> in diesen Puffer kopiert, wobei <em>darauf</em> vertraut wird, dass die Anzahl der zu kopierenden Bytes in <em>packet_len angegeben ist</em> . <br><br>  <strong>Das wichtigste Versehen des Entwicklers war, dass die Pr√ºfung " <em>packet_len ist</em> kleiner oder gleich <em>data_len</em> " nicht durchgef√ºhrt wird.</strong>  <strong>Dies bedeutet, dass es m√∂glich ist, <em>data_len</em> weniger als <em>packet_len zu √ºbertragen</em> und bis zu 64 KB Daten (da das Feld <em>packet_len</em> 2 Byte breit ist) in einen sehr kleinen Puffer kopiert zu haben, wodurch die Heap-Besch√§digung ausgenutzt werden kann.</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/6ae/a31/d4c6aea31e05f0479552817bbc95a1e3.jpg" alt="Bild"></div><br><h2>  Ausnutzung der Verwundbarkeit </h2><br>  In diesem Abschnitt wird davon ausgegangen, dass es eine Problemumgehung f√ºr ASLR gibt.  Dies f√ºhrt dazu, dass vor dem Start des Betriebs die Startadresse von steamclient.dll bekannt ist. <br><br><h3>  Paket-Spoofing </h3><br>  Damit die angreifenden UDP-Pakete vom Client empfangen werden k√∂nnen, muss er das ausgehende Datagramm (Client -&gt; Server) untersuchen, das gesendet wird, um die Kennungen der Client / Server-Verbindung sowie die Seriennummer herauszufinden.  Anschlie√üend muss der Angreifer die IP-Adressen und Quell- / Zielports zusammen mit den Client / Server-IDs f√§lschen und die gelernte Seriennummer um eins erh√∂hen. <br><br><h3>  Speicherverwaltung </h3><br>  Um mehr als 1024 (0x400) Bytes Speicher zuzuweisen, wird ein Standard-Systemzuweiser verwendet.  Um Speicher mit weniger als oder gleich 1024 Byte zuzuweisen, verwendet Steam einen eigenen Allokator, der auf allen unterst√ºtzten Plattformen gleich funktioniert.  In diesem Artikel wird dieser Distributor mit Ausnahme der folgenden Schl√ºsselaspekte nicht im Detail erl√§utert: <br><br><ol><li>  Vom Systemzuweiser werden gro√üe Speicherbl√∂cke angefordert, die dann zur Verwendung unter Steam-Client-Speicherzuweisungsanforderungen in Fragmente fester Gr√∂√üe unterteilt werden. </li><li>  Die Auswahl erfolgt nacheinander, zwischen den verwendeten Fragmenten gibt es keine Metadaten, die sie trennen. </li><li>  Jeder gro√üe Block speichert seine eigene freie Speicherliste, die als einfach verkn√ºpfte Liste implementiert ist. </li><li>  Der obere Rand der Liste des freien Speichers zeigt das erste freie Fragment im Speicher an, und die ersten 4 Bytes dieses Fragments geben das n√§chste freie Fragment an (falls vorhanden). </li></ol><br><h4>  Speicherzuordnung </h4><br>  Beim Zuweisen von Speicher wird der erste freie Block vom Anfang der Liste des freien Speichers getrennt, und die ersten 4 Bytes dieses Blocks, die <em>next_free_block</em> entsprechen, werden in die Mitgliedsvariable <em>freelist_head</em> innerhalb der <em>Allokatorklasse</em> kopiert. <br><br><h4>  Freier Speicher </h4><br>  Wenn ein Block freigegeben wird, wird das Feld <em>freelist_head</em> in die ersten 4 Bytes des freigegebenen Blocks ( <em>next_free_block</em> ) <em>kopiert</em> , und die Adresse des freigegebenen Blocks wird in die Mitgliedsvariable <em>freelist_head</em> der Verteilerklasse kopiert. <br><br><h3>  So erhalten Sie ein Aufnahmeprimitiv </h3><br>  Auf dem Heap tritt ein Puffer√ºberlauf auf. Abh√§ngig von der Gr√∂√üe der Pakete, die die Besch√§digung verursacht haben, kann die Speicherzuweisung entweder durch den Standard-Windows-Allokator (bei Speicherzuweisung von mehr als 0 x 400 Byte) oder durch den Steam-eigenen Zuweiser (bei Zuweisung von Speicher unter 0x400 Byte) gesteuert werden.  Aufgrund des Mangels an Sicherheitsma√ünahmen in meinem eigenen Steam-Distributor entschied ich, dass es einfacher war, es f√ºr einen Exploit zu verwenden. <br><br>  Kehren wir zum Abschnitt √ºber die Speicherverwaltung zur√ºck: Es ist bekannt, dass der Anfang der Liste der freien Speicher von Bl√∂cken einer bestimmten Gr√∂√üe als Mitgliedsvariable der Verteilerklasse gespeichert wird und der Zeiger auf den n√§chsten freien Block in der Liste als die ersten 4 Bytes jedes freien Blocks der Liste gespeichert wird. <br><br>  Wenn sich neben dem Block, in dem der √úberlauf aufgetreten ist, ein freier Block befindet, k√∂nnen wir durch Besch√§digung des Heaps den Zeiger <em>next_free_block</em> √ºberschreiben.  Wenn Sie der Meinung sind, dass ein B√ºndel daf√ºr vorbereitet werden kann, kann der neu <em>geschriebene</em> Zeiger <em>next_free_block</em> auf eine Adresse zum Schreiben gesetzt werden, wonach die nachfolgende Speicherzuweisung an diese Stelle geschrieben wird. <br><br><h3>  Was zu verwenden ist: Datagramme oder Fragmente </h3><br>  Ein Fehler mit Speicherbesch√§digung tritt im Code auf, der f√ºr die Verarbeitung von Fragmenten von Datagrammen (Paketen vom Typ 6) verantwortlich ist.  Nach dem Auftreten eines Schadens befindet sich die <em>RecvFragment ()</em> -Funktion in einem Zustand, in dem weitere Fragmente erwartet werden.  Wenn sie jedoch ankommen, wird eine √úberpr√ºfung durchgef√ºhrt: <br><br> <code>fragment_size + num_bytes_already_received &lt; sizeof(collection_buffer)</code> <br> <br>  Dies ist jedoch offensichtlich nicht der Fall, da unser erstes Paket bereits gegen diese Regel versto√üen hat (das Vorhandensein eines Fehlers kann diese Pr√ºfung √ºberspringen) und ein Fehler auftritt.  Um dies zu vermeiden, m√ºssen Sie die <em>CUDPConnection :: RecvFragment ()</em> -Methode nach einer Speicherbesch√§digung vermeiden. <br><br>  Gl√ºcklicherweise kann <em>CUDPConnection :: RecvDatagram ()</em> weiterhin gesendete Pakete vom Typ 7 (Datagramme) empfangen und verarbeiten, bis <em>RecvFragment ()</em> g√ºltig ist, und dies kann zum Starten des Aufzeichnungsprimitivs verwendet werden. <br><br><h3>  Verschl√ºsselungsprobleme </h3><br>  Es wird erwartet, dass die von <em>RecvDatagram ()</em> und <em>RecvFragment ()</em> empfangenen Pakete verschl√ºsselt werden.  Bei <em>RecvDatagram () erfolgt die</em> Entschl√ºsselung fast unmittelbar nach dem Empfang.  Im Fall von <em>RecvFragment () tritt</em> es nach dem Empfang des letzten Fragments in der Sitzung auf. <br><br>  Das Problem der Ausnutzung der Sicherheitsanf√§lligkeit tritt auf, weil wir den in jeder Sitzung erstellten Verschl√ºsselungsschl√ºssel nicht kennen.  Dies bedeutet, dass jeder OP-Code / Shell-Code, den wir senden, mit AES256 ‚Äûentschl√ºsselt‚Äú wird, wodurch unsere Daten in M√ºll umgewandelt werden.  Daher ist es notwendig, eine Betriebsmethode zu finden, die fast unmittelbar nach dem Empfang des Pakets m√∂glich ist, bevor die Entschl√ºsselungsprozeduren die im Paketpuffer enthaltenen n√ºtzlichen Informationen verarbeiten k√∂nnen. <br><br><h3>  So erreichen Sie die Codeausf√ºhrung </h3><br>  Angesichts der oben beschriebenen Entschl√ºsselungsbeschr√§nkung sollte die Operation vor der Entschl√ºsselung der eingehenden Daten durchgef√ºhrt werden.  Dies f√ºhrt zu zus√§tzlichen Einschr√§nkungen, aber die Aufgabe ist noch m√∂glich: Sie k√∂nnen den Zeiger so umschreiben, dass er auf das <em>CWorkThreadPool-</em> Objekt verweist, das an einer vorhersehbaren Stelle im <em>Datenabschnitt</em> der Bin√§rdatei gespeichert ist.  Obwohl die Details und internen Funktionen dieser Klasse unbekannt sind, kann anhand ihres Namens angenommen werden, dass sie einen Thread-Pool unterst√ºtzt, den Sie verwenden k√∂nnen, wenn Sie "arbeiten" m√ºssen.  Nachdem Sie mehrere Debugging-Zeilen in einer Bin√§rdatei untersucht haben, k√∂nnen Sie verstehen, dass unter solchen Arbeiten Verschl√ºsselung und Entschl√ºsselung ( <em>CWorkItemNetFilterEncrypt</em> , <em>CWorkItemNetFilterDecrypt</em> ) vorhanden sind. Wenn diese Aufgaben in die Warteschlange gestellt werden, wird die <em>CWorkThreadPool-</em> Klasse <em>verwendet</em> .  Indem wir diesen Zeiger √ºberschreiben und die gew√ºnschte Stelle darin schreiben, k√∂nnen wir den vtable-Zeiger und die damit verbundene vtable simulieren, wodurch wir beispielsweise Code ausf√ºhren k√∂nnen, wenn <em>CWorkThreadPool :: AddWorkItem ()</em> aufgerufen wird, was vor Entschl√ºsselungsprozessen geschehen muss. <br><br>  Die folgende Abbildung zeigt die erfolgreiche Ausnutzung der Sicherheitsanf√§lligkeit bis zur Erlangung der Kontrolle √ºber das EIP-Register. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/383/537/4a83835371112599ca429941e449e734.jpg" alt="Bild"></div><br>  Von nun an k√∂nnen Sie eine ROP-Kette erstellen, die zur Ausf√ºhrung von beliebigem Code f√ºhrt.  Das folgende Video zeigt, wie ein Angreifer einen Windows-Rechner in einer vollst√§ndig gepatchten Version von Windows 10 remote startet. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0QaozC8S0Aw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Zusammenfassend </h2><br>  Wenn Sie zu diesem Teil des Artikels gelangen, vielen Dank f√ºr Ihre Beharrlichkeit!  Ich hoffe, Sie verstehen, dass dies ein sehr einfacher Fehler ist, der aufgrund des Mangels an modernen Mitteln zum Schutz vor Exploits recht einfach auszunutzen war.  Der anf√§llige Code war wahrscheinlich sehr alt, aber ansonsten funktionierte er gut, sodass die Entwickler nicht die Notwendigkeit sahen, ihn zu untersuchen oder seine Build-Skripte zu aktualisieren.  Die Lehre hier ist, dass es f√ºr Entwickler wichtig ist, alten Code regelm√§√üig zu √ºberpr√ºfen und Systeme zu erstellen, um sicherzustellen, dass sie den modernen Sicherheitsstandards entsprechen, auch wenn die Funktionalit√§t des Codes selbst unver√§ndert bleibt.  Es war erstaunlich, 2018 einen so einfachen Fehler mit so schwerwiegenden Folgen auf einer sehr beliebten Softwareplattform zu finden.  Dies sollte ein Anreiz sein, f√ºr alle Forscher nach solchen Schwachstellen zu suchen! <br><br>  Schlie√ülich lohnt es sich, √ºber den Prozess der verantwortungsvollen Offenlegung von Informationen zu sprechen.  Wir haben Valve diesen Fehler in einem Brief an ihr Sicherheitsteam ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">security@valvesoftware.com</a> ) gegen 16 Uhr GMT gemeldet. Nur 8 Stunden sp√§ter wurde ein Fix erstellt und im Beta-Client Steam gestartet.  Dank dessen steht Valve nun an erster Stelle in unserer (imagin√§ren) Tabelle des Wettbewerbs ‚ÄûWer wird die Sicherheitsanf√§lligkeit schneller beheben?‚Äú - eine angenehme Ausnahme im Vergleich zur Offenlegung von Fehlern gegen√ºber anderen Unternehmen, was h√§ufig zu einem langen Genehmigungsprozess f√ºhrt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine Seite, die die Details aller Client-Updates beschreibt</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413003/">https://habr.com/ru/post/de413003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412993/index.html">Infrastruktur f√ºr √∂ffentliche Schl√ºssel: Dienstprogramm zur Generierung qualifizierter Zertifikatsanforderungen</a></li>
<li><a href="../de412995/index.html">SAP schnell</a></li>
<li><a href="../de412997/index.html">Verstecken oder das erste Botnetz, das keinen Neustart bef√ºrchtet</a></li>
<li><a href="../de412999/index.html">Vom Summen der Giraffen bis zu den Ger√§uschen mimetischer V√∂gel - gemeinsam der Natur lauschen</a></li>
<li><a href="../de413001/index.html">SamsPcbGuide, Teil 5: Verfolgen von Signallinien. Leitungsverzerrung und Impedanzanpassung</a></li>
<li><a href="../de413005/index.html">Blockchain - ein Heilmittel gegen die Hauptkrankheiten der modernen Bildung</a></li>
<li><a href="../de413007/index.html">Seltsame Synthese bei der Arbeit mit FPGA</a></li>
<li><a href="../de413009/index.html">Python-Umgebungsverwaltung mit Pipenv</a></li>
<li><a href="../de413011/index.html">Keller des Todes</a></li>
<li><a href="../de413013/index.html">Der Wunsch nach Transparenz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>