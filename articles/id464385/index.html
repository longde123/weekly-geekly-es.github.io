<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏡 😈 ⛹🏾 Python sebagai kasus akhir C ++. Bagian 1/2 🚛 🏹 🅿️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari penerjemah 

 Brandon Rhodes adalah orang yang sangat sederhana yang menampilkan dirinya di Twitter sebagai "seorang programmer Python yang memba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python sebagai kasus akhir C ++. Bagian 1/2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464385/"><div class="spoiler">  <b class="spoiler_title">Dari penerjemah</b> <div class="spoiler_text"><p>  Brandon Rhodes adalah orang yang sangat sederhana yang menampilkan dirinya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twitter</a> sebagai "seorang programmer Python yang membayar pinjaman kepada komunitas dalam bentuk laporan atau esai."  Jumlah "laporan dan esai" ini mengesankan, seperti juga jumlah proyek gratis yang menjadi kontributor Brandon.  Dan Brandon telah menerbitkan dua buku dan sedang menulis buku ketiga. </p><br><p>  Saya sering menemukan dalam komentar tentang Habré kesalahpahaman mendasar atau penolakan terhadap bahasa dinamis, pengetikan dinamis, pemrograman umum dan paradigma lainnya.  Saya menerbitkan terjemahan (transkrip) resmi dari salah satu laporan Brandon ini dengan harapan akan membantu programmer yang ada dalam paradigma bahasa statis untuk lebih memahami bahasa dinamis, khususnya Python. </p><br><p>  Seperti biasa dengan saya, saya meminta Anda untuk memberi tahu saya di PM tentang kesalahan dan kesalahan ketik saya. </p></div></div><br><p> Apa arti frasa "kasus marginal" dalam judul laporan saya?  Kasing pembatas muncul ketika Anda mengulangi urutan opsi hingga Anda mencapai nilai ekstrem.  Misalnya, poligon bersisi-n.  Jika n = 3, maka ini adalah segitiga, n = 4 adalah segi empat, n = 5 adalah segi lima, dll. Saat n mendekati tak terhingga, sisi-sisinya menjadi lebih kecil dan lebih besar, dan garis besar poligon menjadi seperti lingkaran.  Jadi, lingkaran adalah pembatas untuk poligon reguler.  Inilah yang terjadi ketika ide tertentu dibawa ke batas. </p><br><p>  Saya ingin berbicara tentang Python sebagai kasus ekstrim untuk C ++.  Jika Anda mengambil semua ide bagus dari C ++ dan membersihkannya hingga kesimpulan logisnya, saya yakin Anda akan berakhir dengan Python secara alami ketika serangkaian poligon muncul ke lingkaran. </p><a name="habracut"></a><br><h1>  Aset non-inti </h1><br><p> Saya menjadi tertarik pada Python di tahun 90-an: itu adalah periode dalam hidup saya ketika saya menyingkirkan "aset non-inti", demikian saya menyebutnya.  Banyak hal mulai membuatku bosan.  Gangguan, misalnya.  Ingat, dulu di banyak papan komputer ada kontak dengan jumper?  Dan Anda mengatur jumper ini pada manual sehingga kartu video menerima interupsi prioritas yang lebih tinggi, sehingga game Anda berjalan lebih cepat?  Jadi, saya bosan mengalokasikan dan membebaskan memori menggunakan <code>malloc()</code> dan <code>free()</code> sekitar waktu yang sama ketika saya berhenti menyesuaikan kinerja komputer saya dengan jumper.  Itu sekitar tahun 1997. </p><br><p>  Maksudku, ketika kita mempelajari suatu proses, kita biasanya berusaha untuk mendapatkan kontrol penuh atas itu, untuk memiliki semua tuas dan tombol yang mungkin.  Kemudian beberapa orang masih terpesona dengan kemungkinan kontrol ini.  Tetapi karakter saya adalah bahwa begitu saya terbiasa dengan manajemen dan mengerti apa itu, saya segera mulai mencari kesempatan untuk mengundurkan diri dari kekuatan saya, mentransfer tuas dan tombol ke beberapa mesin sehingga memberikan gangguan bagi saya. </p><br><p>  Oleh karena itu, di akhir tahun 90-an, saya mencari bahasa pemrograman yang memungkinkan saya untuk fokus pada area subjek dan pemodelan tugas, daripada mengkhawatirkan area memori komputer saya yang disimpan.  Bagaimana kita bisa menyederhanakan C ++ tanpa mengulangi dosa bahasa scripting terkenal? </p><br><p>  Misalnya, saya tidak bisa menggunakan Perl, dan Anda tahu mengapa?  Tanda dolar ini!  Dia segera menjelaskan bahwa pencipta Perl tidak mengerti bagaimana bahasa pemrograman bekerja.  Anda menggunakan dolar dalam Bash untuk memisahkan nama variabel dari sisa string, karena program Bash terdiri dari perintah yang dirasakan secara harfiah dan parameternya.  Tetapi setelah Anda mengetahui bahasa pemrograman ini, di mana string ditempatkan di antara pasangan karakter kecil yang disebut tanda kutip, dan tidak di seluruh teks program, Anda mulai menganggap <code>$</code> sebagai sampah visual.  Tanda dolar itu tidak berguna, itu jelek, itu harus pergi!  Jika Anda ingin merancang bahasa untuk pemrograman serius, Anda tidak boleh menggunakan karakter khusus untuk menunjukkan variabel. </p><br><h1>  Sintaks </h1><br><p>  Bagaimana dengan sintaks?  Ambil C sebagai basis!  Ini bekerja dengan cukup baik.  Biarkan penugasan dilambangkan dengan tanda sama dengan.  Penunjukan ini tidak diterima dalam semua bahasa, tetapi, dengan satu atau lain cara, banyak yang terbiasa dengannya.  Tapi jangan membuat tugas ekspresi.  Pengguna bahasa kami tidak hanya akan programmer profesional, tetapi juga anak sekolah, ilmuwan, atau ilmuwan data (jika Anda tidak mengetahui kategori pengguna mana yang menulis kode terburuk, maka saya akan mengisyaratkan bahwa ini bukan anak sekolah).  Kami tidak akan memberi pengguna kesempatan untuk mengubah keadaan variabel di tempat yang tidak terduga, dan kami akan menjadikan penugasan sebagai operator. </p><br><p>  Lalu apa yang harus digunakan untuk menunjukkan kesetaraan jika tanda yang sama telah digunakan untuk penugasan?  Tentu saja, tugas ganda, seperti yang dilakukan di C!  Banyak yang sudah terbiasa.  Kami juga akan meminjam dari C notasi untuk semua operasi aritmatika dan bitwise, karena notasi ini bekerja, dan banyak yang cukup senang dengannya. </p><br><p>  Tentu saja, kita dapat meningkatkan sesuatu.  Apa yang Anda pikirkan ketika Anda melihat tanda persen dalam teks program?  Tentang interpolasi string, tentu saja!  Meskipun <code>%</code> terutama merupakan operator penangkap modul, itu hanya tidak terdefinisi untuk string.  Dan jika demikian, mengapa tidak menggunakannya kembali? </p><br><p>  Numerik dan string literal yang mengontrol urutan dengan garis miring terbalik - semua ini akan terlihat seperti di C. </p><br><p>  Kontrol aliran eksekusi?  Sama <code>if</code> , yang <code>else</code> , <code>while</code> , <code>break</code> dan <code>continue</code> .  Tentu saja, kami akan menambahkan sedikit kesenangan dengan mengkooptasi yang lama yang baik <code>for</code> beralih pada struktur data dan rentang nilai.  Ini akan diusulkan nanti dalam C ++ 11, tetapi dalam Python, operator <code>for</code> awalnya merangkum semua operasi untuk menghitung ukuran, melintasi tautan, menambah penghitung, dll., Dengan kata lain, melakukan segala sesuatu yang diperlukan untuk menyediakan elemen struktur data kepada pengguna.  Jenis struktur apa?  Tidak masalah, cukup berikan saja, itu akan dipecahkan. </p><br><p>  Kami juga akan meminjam pengecualian dari C ++, tetapi kami akan membuatnya sangat murah dalam hal konsumsi sumber daya sehingga dapat digunakan tidak hanya untuk menangani kesalahan, tetapi juga untuk mengontrol aliran eksekusi.  Kami akan membuat pengindeksan lebih menarik dengan menambahkan slicing - kemampuan untuk mengindeks tidak hanya elemen individu dari struktur data sekuensial, tetapi juga rentangnya. </p><br><p>  Oh ya!  Kami akan memperbaiki cacat desain asli di C - tambahkan koma menggantung! </p><br><p>  Kisah ini dimulai dengan Pascal, bahasa yang mengerikan di mana tanda titik koma digunakan sebagai <em>pembatas</em> ekspresi.  Ini berarti bahwa pengguna harus meletakkan titik koma di akhir <em>setiap</em> ekspresi di blok <em>kecuali yang terakhir</em> .  Oleh karena itu, setiap kali Anda mengubah urutan ekspresi dalam sebuah program di Pascal, Anda berisiko menerima kesalahan sintaksis jika Anda tidak memastikan untuk menghapus titik koma dari baris terakhir dan menambahkannya ke akhir baris yang dulunya adalah yang terakhir. </p><br><pre> <code class="plaintext hljs">If (n = 0) then begin writeln('N is now zero'); func := 1 end</code> </pre> <br><p>  Kernigan dan Ritchie melakukan hal yang benar ketika mereka mendefinisikan titik koma dalam C sebagai <em>terminator</em> ekspresi, bukan pembatas, menciptakan simetri yang indah ketika setiap baris dalam program, termasuk yang terakhir, berakhir sama dan dapat dipertukarkan secara bebas.  Sayangnya, di masa depan, rasa harmoni berubah untuk mereka, dan mereka menjadikan koma sebagai <em>pemisah</em> dalam inisialisasi statis.  Ini terlihat bagus ketika ekspresi cocok pada satu baris: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[] = {<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>};</code> </pre> <br><p>  tetapi ketika inisialisasi Anda menjadi lebih lama dan Anda mengaturnya secara vertikal, Anda mendapatkan asimetri tidak nyaman yang sama seperti di Pascal: </p><br><pre> <code class="plaintext hljs">int a[] = { 4, 5, 6 };</code> </pre> <br><p>  Pada tahap awal pengembangannya, Python membuat koma menggantung dalam struktur data sepenuhnya opsional, terlepas dari bagaimana elemen-elemen struktur ini disusun: horizontal atau vertikal.  By the way, ini sangat nyaman untuk pembuatan kode otomatis: Anda tidak perlu memperlakukan elemen terakhir sebagai kasus khusus. </p><br><p>  Kemudian, standar C99 dan C ++ 11 juga mengoreksi kesalahpahaman awal, memungkinkan Anda untuk menambahkan koma setelah literal terakhir di penginisialisasi. </p><br><h1>  Ruang nama </h1><br><p>  Kita juga perlu mengimplementasikan dalam bahasa pemrograman kita seperti ruang nama atau ruang nama.  Ini adalah bagian penting dari bahasa yang seharusnya menyelamatkan kita dari kesalahan seperti konflik nama.  Kami akan melakukannya lebih mudah daripada C ++: alih-alih memberikan pengguna kemampuan untuk secara acak menamai namespace, kami akan membuat satu namespace per modul (file) dan menunjuknya dengan nama file.  Misalnya, jika Anda membuat modul <code>foo.py</code> , modul tersebut akan diberi nama namespace <code>foo</code> . </p><br><p>  Untuk bekerja dengan model ruang nama yang disederhanakan, pengguna hanya perlu satu operator. </p><br><p>  Buat direktori <code>my_package</code> , letakkan file <code>my_module.py</code> , dan deklarasikan kelas dalam file: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> READ = <span class="hljs-number"><span class="hljs-number">1</span></span> WRITE = <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  maka akses ke atribut kelas adalah sebagai berikut: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> my_package.my_module my_package.my_module.C.READ</code> </pre> <br><p>  Jangan khawatir, kami tidak akan memaksa pengguna untuk mencetak nama lengkap setiap kali.  Kami akan memberinya kesempatan untuk menggunakan beberapa versi pernyataan <code>import</code> untuk memvariasikan tingkat "kedekatan" ruang nama: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> my_package.my_module my_package.my_module.C.READ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_package <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> my_module my_module.C.READ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_package.my_module <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> C C.READ</code> </pre> <br><p>  Dengan demikian, nama yang sama yang diberikan dalam paket berbeda tidak akan pernah konflik: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json j = json.load(file) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle p = pickle.load(file)</code> </pre> <br><p>  Fakta bahwa setiap modul memiliki namespace sendiri juga berarti bahwa kita tidak memerlukan pengubah <code>static</code> .  Namun, kami mengingat satu fungsi yang dilakukan <code>static</code> - merangkum variabel internal.  Untuk menunjukkan kepada kolega bahwa nama yang diberikan (variabel, kelas, atau modul) bukan publik, kami memulainya dengan garis bawah, misalnya, <code>_ignore_this</code> .  Ini juga bisa menjadi sinyal bagi IDE untuk tidak menggunakan nama ini dalam penyelesaian otomatis. </p><br><h1>  Kelebihan fungsi </h1><br><p>  Kami tidak akan menerapkan fungsi kelebihan muatan dalam bahasa kami.  Mekanisme kelebihan beban terlalu rumit.  Sebagai gantinya, kami akan menggunakan argumen opsional dengan nilai default yang dapat dihilangkan dari panggilan, serta argumen bernama untuk "melompati" argumen opsional dengan default yang valid dan hanya menetapkan nilai-nilai yang berbeda dari yang default.  Yang penting, kurangnya kelebihan akan menyelamatkan kita dari kebutuhan untuk menentukan fungsi mana dari set fungsi kelebihan beban baru saja dipanggil, bagaimana manajer panggilan bekerja: fungsi selalu satu dalam modul ini, mudah untuk menemukan namanya. </p><br><h1>  API Sistem </h1><br><p>  Kami akan memberikan pengguna akses penuh ke banyak API sistem, termasuk soket.  Saya tidak mengerti mengapa penulis bahasa scripting selalu menawarkan cara cerdik mereka sendiri untuk membuka soket.  Namun, mereka tidak pernah mewujudkan API Unix Socket penuh.  Mereka menerapkan 5-6 fungsi yang mereka pahami, dan membuang yang lainnya.  Python, tidak seperti mereka, memiliki modul standar untuk berinteraksi dengan OS yang mengimplementasikan setiap panggilan sistem standar.  Itu berarti Anda dapat membuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku Stevens</a> sekarang dan mulai menulis kode.  Dan semua soket, proses, dan garpu Anda akan bekerja persis seperti yang dikatakan.  Ya, mungkin Guido atau kontributor Python awal melakukan hal itu, karena mereka terlalu malas untuk menulis implementasi perpustakaan sistem mereka, terlalu malas untuk menjelaskan kepada pengguna lagi bagaimana soket bekerja.  Tetapi sebagai hasilnya, mereka mencapai efek yang luar biasa: Anda dapat mentransfer semua pengetahuan UNIX yang Anda peroleh dalam C dan C ++ ke lingkungan Python. </p><br><p>  Jadi, kami memutuskan fitur apa yang akan kami "pinjam" dari C ++ untuk membuat bahasa skrip sederhana kami.  Sekarang kita perlu memutuskan apa yang ingin kita perbaiki. </p><br><h1>  Perilaku tidak terdefinisi </h1><br><p>  Perilaku tidak dikenal, perilaku tidak terdefinisi, perilaku yang didefinisikan oleh implementasi ... Ini semua adalah ide buruk untuk bahasa yang akan digunakan oleh anak sekolah, ilmuwan, dan ilmuwan data.  Dan perolehan kinerja yang memungkinkan hal-hal seperti itu sering diabaikan dibandingkan dengan ketidaknyamanan.  Sebagai gantinya, kami akan mengumumkan bahwa setiap program yang benar secara sintaksis menghasilkan hasil yang sama pada platform apa pun.  Kami akan menjelaskan standar bahasa dengan frasa seperti "Python mengevaluasi semua ekspresi dari kiri ke kanan" alih-alih mencoba menyusun ulang perhitungan tergantung pada prosesor, OS, atau fase bulan.  Jika pengguna yakin bahwa urutan perhitungan itu penting, ia memiliki hak untuk menulis ulang kode dengan benar: pada akhirnya, pengguna adalah yang utama. </p><br><h1>  Prioritas Operasi </h1><br><p>  Anda pasti mengalami kesalahan serupa: ekspresi </p><br><pre> <code class="cpp hljs">oflags &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span> == nflags &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br><p>  selalu mengembalikan 0, karena perbandingan dalam C didahulukan dari operasi bitwise.  Dengan kata lain, ungkapan ini dievaluasi menjadi </p><br><pre> <code class="cpp hljs">oflags &amp; (<span class="hljs-number"><span class="hljs-number">0x80</span></span> == nflags) &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br><p>  Oh, itu C! </p><br><p>  Kami akan menghilangkan kemungkinan penyebab kesalahan tersebut dalam bahasa scripting sederhana kami, menempatkan prioritas operasi perbandingan di belakang aritmatika dan manipulasi bit, sehingga ekspresi dari contoh kami dihitung lebih intuitif: </p><br><pre> <code class="cpp hljs">(oflags &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span>) == (nflags &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span>)</code> </pre> <br><h1>  Perbaikan lainnya </h1><br><p>  Keterbacaan kode penting bagi kami.  Jika operasi aritmatika bahasa C akrab bagi pengguna bahkan oleh aritmatika sekolah, maka kebingungan antara operasi logis dan bitwise merupakan sumber kesalahan yang jelas.  Kami akan mengganti ampersand ganda dengan kata <code>and</code> , dan garis vertikal ganda dengan kata <code>or</code> , sehingga bahasa kita lebih mirip ucapan manusia daripada piket karakter "komputer". </p><br><p>  Kami akan menyerahkan kemungkinan perhitungan yang disingkat ke operator logis kami ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://en.wikipedia.org/wiki/Short-circuit_evaluation</a> ), tetapi juga memberi mereka kemampuan untuk mengembalikan nilai akhir dari jenis apa pun, bukan hanya Boolean.  Maka ungkapan suka </p><br><pre> <code class="python hljs">s = error.message <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'Error'</span></span></code> </pre> <br><p>  Dalam contoh ini, variabel akan diatur ke <code>error.message</code> jika tidak kosong, jika tidak maka string 'Kesalahan'. </p><br><p>  Kami memperluas gagasan C bahwa 0 sama dengan false untuk objek selain bilangan bulat.  Misalnya, pada garis dan wadah kosong. </p><br><p>  Kami akan menghancurkan integer overflow.  Bahasa kami akan konsisten dalam implementasi dan mudah digunakan, sehingga pengguna kami tidak perlu mengingat nilai khusus yang mencurigakan mendekati dua miliar, setelah itu keseluruhan, bertambah satu, tiba-tiba berubah tanda.  Kami menerapkan bilangan bulat seperti itu yang akan berperilaku seperti bilangan bulat sampai menghabiskan semua memori yang tersedia. </p><br><h1>  Mengetik dengan ketat vs lemah </h1><br><p>  Masalah penting lainnya dalam desain bahasa scripting: ketegaran mengetik.  Banyak di antara hadirin yang akrab dengan JavaScript?  Apa yang terjadi jika angka 3 dikurangi dari string '4'? </p><br><pre> <code class="javascript hljs">js&gt; <span class="hljs-string"><span class="hljs-string">'4'</span></span> - <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Hebat!  Dan jika Anda menambahkan angka 3 ke string '4'? </p><br><pre> <code class="javascript hljs">js&gt; <span class="hljs-string"><span class="hljs-string">'4'</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-string"><span class="hljs-string">"43"</span></span></code> </pre> <br><p>  Ini disebut mengetik lemah (atau lemah).  Ini adalah sesuatu seperti inferiority complex ketika sebuah bahasa pemrograman berpikir bahwa seorang programmer akan mengutuknya jika ia tidak dapat mengembalikan hasil dari ekspresi apa pun, bahkan jelas tidak berarti, dengan berulang kali mengetikkan tipe.  Masalahnya adalah konversi jenis, yang dihasilkan bahasa yang diketik dengan lemah secara otomatis, sangat jarang mengarah pada hasil yang bermakna.  Mari kita coba konversi yang sedikit lebih rumit: </p><br><pre> <code class="javascript hljs">js&gt; [] + [] <span class="hljs-string"><span class="hljs-string">""</span></span> js&gt; [] + {} <span class="hljs-string"><span class="hljs-string">"[object Object]"</span></span></code> </pre> <br><p>  Kami berharap bahwa operasi penambahan bersifat komutatif, tetapi apa yang terjadi jika kami mengubah ketentuan dalam kasus yang terakhir? </p><br><pre> <code class="javascript hljs">js&gt; {} + [] <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  JavaScript tidak sendirian dalam masalahnya.  Perl dalam situasi yang sama juga mencoba mengembalikan setidaknya sesuatu: </p><br><pre> <code class="perl hljs">perl&gt; <span class="hljs-string"><span class="hljs-string">"3"</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  Dan awk akan melakukan sesuatu seperti itu: </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> | awk <span class="hljs-string"><span class="hljs-string">'{print "3" + 1}'</span></span> 4</code> </pre> <br><p>  Pembuat bahasa scripting secara tradisional percaya bahwa pengetikan yang longgar itu <em>nyaman</em> .  Mereka salah: mengetik longgar itu <em>mengerikan</em> !  Itu melanggar prinsip lokalitas.  Jika ada kesalahan dalam kode, maka bahasa pemrograman harus memberitahu pengguna tentang hal itu, menyebabkan pengecualian sedekat mungkin ke tempat bermasalah dalam kode.  Tetapi dalam semua bahasa ini, yang tanpa henti mengetik jenis, sampai sesuatu beres, kontrol biasanya sampai pada akhirnya, dan kami mendapatkan hasilnya, menilai dimana, dalam program kami, ada sesuatu yang salah di suatu tempat.  Dan kita harus men-debug seluruh program kita, satu demi satu baris, untuk menemukan kesalahan ini. </p><br><p>  Pengetikan yang longgar juga menurunkan pembacaan kode, karena meskipun kita dengan benar menggunakan casting tipe implisit dalam suatu program, hal ini terjadi secara tak terduga untuk programmer lain. </p><br><p>  Dalam Python, seperti dalam C ++, ekspresi seperti itu akan mengembalikan kesalahan. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">'4'</span></span> - <span class="hljs-number"><span class="hljs-number">3</span></span> TypeError &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">'4'</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> TypeError</code> </pre> <br><p>  Karena tipe casting, jika benar-benar diperlukan, mudah untuk menulis secara eksplisit: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>int(<span class="hljs-string"><span class="hljs-string">'4'</span></span>) + <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">'4'</span></span> + str(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-string"><span class="hljs-string">'43'</span></span></code> </pre> <br><p>  Kode ini mudah dibaca dan dipelihara, memperjelas apa yang sebenarnya terjadi dalam program, yang mengarah ke hasil ini.  Ini karena programmer Python percaya bahwa eksplisit lebih baik daripada implisit, dan kesalahan tidak boleh tidak diketahui. </p><br><p>  Python adalah bahasa yang diketik dengan kuat, dan satu-satunya konversi tipe implisit di dalamnya terjadi selama operasi aritmatika pada bilangan bulat, yang hasilnya harus dinyatakan sebagai angka pecahan.  Mungkin ini juga tidak boleh diizinkan dalam program, tetapi dalam kasus ini terlalu banyak pengguna harus segera menjelaskan perbedaan antara bilangan bulat dan angka floating point, yang akan mempersulit langkah pertama mereka dengan Python. </p><br><p>  Lanjutan: “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Python sebagai kasus akhir C ++.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2/2</a> . " </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464385/">https://habr.com/ru/post/id464385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464373/index.html">Edge-to-edge di Android: melakukannya dengan benar</a></li>
<li><a href="../id464375/index.html">Cara kerja mesin pencari</a></li>
<li><a href="../id464377/index.html">Hacker assembler kotor 6502</a></li>
<li><a href="../id464381/index.html">Perjalanan ke Alaska, atau KDD'19 melalui mata seorang saksi mata</a></li>
<li><a href="../id464383/index.html">Bagaimana saya menertibkan suatu proyek di mana ada hutan langsung (pengaturan tslint, lebih cantik, dll)</a></li>
<li><a href="../id464387/index.html">Jejak Rusia di saga video game Skandinavia, berakhir</a></li>
<li><a href="../id464391/index.html">10 laporan menarik dari konferensi peretas</a></li>
<li><a href="../id464393/index.html">Bagaimana menemukan kursus pemrograman dan apa saja jaminan pekerjaan</a></li>
<li><a href="../id464395/index.html">Blockchain RSA berbasis acak</a></li>
<li><a href="../id464399/index.html">Pengikisan web di R, Bagian 2. Mempercepat proses dengan komputasi paralel dan menggunakan paket Rcrawler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>