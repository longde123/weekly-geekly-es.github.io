<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏾 ❄️ 🔟 Wir verwenden Voronois Mosaik-, Pixel- und geometrische Masken in Shadern, um die Site zu dekorieren 😘 🙌🏽 🤔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist eine logische Fortsetzung der Einführung von Programmier-Shadern für Layout-Designer . Darin haben wir eine Vorlage zum Erstellen v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir verwenden Voronois Mosaik-, Pixel- und geometrische Masken in Shadern, um die Site zu dekorieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421821/"><img src="https://habrastorage.org/webt/tw/dv/y5/twdvy5bonlmr47omgfhgmi9rjqu.jpeg" alt="Bild"><br><br><p> Dieser Artikel ist eine logische Fortsetzung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung von Programmier-Shadern für Layout-Designer</a> .  Darin haben wir eine Vorlage zum Erstellen verschiedener zweidimensionaler Effekte mit Fotos mithilfe von Shadern erstellt und einige Beispiele betrachtet.  In diesem Artikel werden wir einige weitere Texturen hinzufügen, die Voronoi-Aufteilung in der Praxis anwenden, um Mosaike daraus zu erstellen, über das Erstellen verschiedener Masken in Shadern und über die Pixelung sprechen und auch einige Probleme der alten GLSL-Syntax ansprechen, die in unseren Browsern noch vorhanden sind. </p><br><p>  Genau wie beim letzten Mal wird es ein Minimum an Theorie und ein Maximum an Übung und Argumentation in einer alltäglichen Sprache geben.  Anfänger finden hier eine Abfolge von Aktionen mit Tipps und nützlichen Hinweisen, und erfahrene Front-End-Anbieter finden möglicherweise einige Ideen zur Inspiration. </p><a name="habracut"></a><br><p>  <em>Eine Umfrage in einem früheren Artikel hat gezeigt, dass das Thema WebGL-Effekte für Websites nicht nur für Schriftsetzer, sondern auch für unsere Kollegen aus anderen Spezialisierungen von Interesse sein kann.</em>  <em>Um sie nicht mit den neuesten ES-Funktionen zu verwirren, beschränken wir uns bewusst auf traditionellere Syntaxkonstrukte, die jeder versteht.</em>  <em>Und wieder mache ich die Leser darauf aufmerksam, dass die eingebauten Editoren von CodePen die Leistung dessen beeinflussen, was in ihnen getan wird.</em> </p><br><p>  Aber fangen wir an ... </p><br><h2 id="shablon-dlya-raboty-s-sheyderami">  Vorlage für die Arbeit mit Shadern </h2><br><p>  Für diejenigen, die den vorherigen Artikel nicht gelesen haben, haben wir diese Vorlage für die Arbeit mit Shadern erstellt: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/ZMBMPJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Darin wird eine Ebene erzeugt (in unserem Fall ein Quadrat), auf die die Bildtextur "gezeichnet" wird.  Keine unnötigen Abhängigkeiten und ein sehr einfacher Vertex-Shader.  Dann haben wir diese Vorlage entwickelt, aber jetzt beginnen wir mit dem Moment, in dem der Fragment-Shader noch keine Logik enthält. </p><br><h2 id="mozaika">  Mosaik </h2><br><p>  Mosaik ist eine Ebene, die in kleine Bereiche unterteilt ist, in denen jeder Bereich mit einer bestimmten Farbe oder, wie in unserem Fall, Textur gefüllt ist.  Wie können wir unser Flugzeug überhaupt in Stücke zerbrechen?  Natürlich können Sie es in Rechtecke aufteilen.  Mit Hilfe von SVG ist dies jedoch bereits so einfach, WebGL auf diese Aufgabe zu ziehen und alles aus heiterem Himmel ohne jeden Zweck zu erledigen. </p><br><p>  Damit das Mosaik interessant ist, muss es unterschiedliche Fragmente aufweisen, sowohl in Form als auch in Größe.  Es gibt einen sehr einfachen, aber gleichzeitig sehr unterhaltsamen Ansatz zum Aufbau einer solchen Partition.  Es ist bekannt als Voronois Mosaik oder Dirichlets Trennwand, und auf Wikipedia schreiben sie, dass Descartes im fernen 17. Jahrhundert etwas Ähnliches verwendet hat.  Die Idee ist ungefähr so: </p><br><ul><li>  Nehmen Sie eine Reihe von Punkten im Flugzeug. </li><li>  Suchen Sie für jeden Punkt in der Ebene aus dieser Menge den Punkt, der ihm am nächsten liegt. </li><li>  Das ist alles  Die Ebene ist in polygonale Bereiche unterteilt, von denen jeder durch einen der Punkte in der Menge bestimmt wird. </li></ul><br><p>  Es ist wahrscheinlich besser, diesen Prozess anhand eines praktischen Beispiels zu zeigen.  Es gibt verschiedene Algorithmen zum Generieren dieser Partition, aber wir werden in der Stirn agieren, da die Berechnung für jeden Punkt in der Ebene nur die Aufgabe des Shaders ist.  Zuerst müssen wir eine Reihe von zufälligen Punkten machen.  Um den Code der Beispiele nicht zu laden, erstellen wir eine globale Variable für sie. </p><br><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { POINTS.push([<span class="hljs-type"><span class="hljs-type">Math.random</span></span>(), <span class="hljs-type"><span class="hljs-type">Math.random</span></span>()]); } }</code> </pre> <br><p>  Jetzt müssen wir sie an die Shader weitergeben.  Die Daten sind global, daher verwenden wir den <code>uniform</code> Modifikator.  Aber es gibt einen subtilen Punkt: Wir können nicht einfach ein Array übergeben.  Es scheint, dass das 21. Jahrhundert auf dem Hof ​​liegt, aber es wird nichts daraus.  Infolgedessen müssen Sie eine Reihe von Punkten einzeln übertragen. </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { GL.uniform2fv(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_points['</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-string"><span class="hljs-string">']'</span></span>), POINTS[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); }</code> </pre> <br><p>  Heutzutage werden wir häufig auf ähnliche Probleme der Inkonsistenz zwischen dem, was erwartet wird, und dem, was in echten Browsern ist, stoßen.  Normalerweise verwenden WebGL-Tutorials THREE.js und diese Bibliothek verbirgt einen Teil des Schmutzes in sich selbst, wie es jQuery einmal bei seinen Aufgaben getan hat. Wenn Sie ihn jedoch entfernen, tut dies Ihrem Gehirn wirklich weh. </p><br><p>  Im Fragment-Shader haben wir eine Array-Variable für Punkte.  Wir können nur Arrays mit fester Länge erstellen.  Beginnen wir mit 10 Punkten: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUMBER_OF_POINTS 10 uniform vec2 u_points[NUMBER_OF_POINTS];</span></span></code> </pre> <br><p>  Stellen Sie sicher, dass dies alles funktioniert, indem Sie an den Stellen der Punkte Kreise zeichnen.  Eine solche Zeichnung verschiedener geometrischer Grundelemente wird häufig beim Debuggen verwendet - sie sind deutlich sichtbar und Sie können sofort verstehen, was sich befindet und wo es sich bewegt. </p><br><blockquote>  Verwenden Sie das "Zeichnen" von Kreisen, Linien und anderen Orientierungspunkten für die unsichtbaren Objekte, auf denen Animationen erstellt werden.  Dies gibt offensichtliche Hinweise darauf, wie sie funktionieren, insbesondere wenn die Algorithmen komplex sind und ohne vorherige Vorbereitung schnell verstanden werden können.  Dann kann das alles auskommentiert und den Kollegen überlassen werden - sie werden sich bedanken. </blockquote><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt; <span class="hljs-number"><span class="hljs-number">0.02</span></span>) { gl_FragColor = WHITE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/pONOme" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Gut.  Fügen wir den Punkten auch etwas Bewegung hinzu.  Lassen Sie sie sich zunächst in einem Kreis bewegen, dann werden wir später auf dieses Thema zurückkommen.  Die Koeffizienten werden auch auf das Auge gelegt, um ihre Bewegung etwas zu verlangsamen und die Amplitude der Schwingungen zu verringern. </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movePoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeStamp)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timeStamp) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] += Math.sin(i * timeStamp / <span class="hljs-number"><span class="hljs-number">5000.0</span></span>) / <span class="hljs-number"><span class="hljs-number">500.0</span></span>; POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] += Math.cos(i * timeStamp / <span class="hljs-number"><span class="hljs-number">5000.0</span></span>) / <span class="hljs-number"><span class="hljs-number">500.0</span></span>; } } }</code> </pre> <br><p>  Gehe zurück zum Shader.  Für zukünftige Experimente werden wir eine nützliche Anzahl von Bereichen finden, in die alles unterteilt wird.  Wir finden also den Punkt, der dem aktuellen Pixel am nächsten liegt, aus der Menge und speichern die Nummer dieses Punkts - es ist die Bereichsnummer. </p><br><pre> <code class="hljs matlab">float min_distance = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; int area_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { float current_distance = distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current_distance &lt; min_distance) { min_distance = current_distance; area_index = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } }</code> </pre> <br><p>  Um die Leistung zu testen, malen wir wieder alles in leuchtenden Farben: </p><br><pre> <code class="hljs pgsql">gl_FragColor = texture2D(u_texture, texture_coord); gl_FragColor.g = abs(sin(<span class="hljs-type"><span class="hljs-type">float</span></span>(area_index))); gl_FragColor.b = abs(sin(<span class="hljs-type"><span class="hljs-type">float</span></span>(area_index)));</code> </pre> <br><blockquote>  Die Kombination von Modul (abs) und eingeschränkten Funktionen (insbesondere sin und cos) wird häufig verwendet, wenn mit ähnlichen Effekten gearbeitet wird.  Dies fügt einerseits ein wenig Zufälligkeit hinzu und andererseits ergibt sich sofort ein normalisiertes Ergebnis von 0 bis 1, was sehr praktisch ist - wir haben sehr viele Werte, die genau innerhalb dieser Grenzen liegen. </blockquote><p>  Wir werden auch Punkte finden, die mehr oder weniger gleich weit von mehreren Punkten aus der Menge entfernt sind, und sie färben.  Diese Aktion enthält keine spezielle Nutzlast, aber das Ergebnis zu betrachten ist immer noch interessant. </p><br><pre> <code class="hljs matlab">int number_of_near_points = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt; min_distance + EPSILON) { number_of_near_points++; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number_of_near_points &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { gl_FragColor.rgb = vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Sie sollten so etwas bekommen: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/xaRavJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Dies ist immer noch ein Entwurf, wir werden ihn noch fertigstellen.  Aber jetzt ist das allgemeine Konzept einer solchen Trennung der Ebene klar. </p><br><h2 id="mozaika-iz-fotografiy">  Mosaik von Fotos </h2><br><p>  Es ist klar, dass eine solche Partition in ihrer reinen Form nicht viel bringt.  Um Ihren Horizont zu erweitern und nur zum Spaß, können Sie mit ihm spielen, aber auf einer realen Website lohnt es sich, ein paar weitere Fotos hinzuzufügen und ein Mosaik daraus zu machen.  Lassen Sie uns die Funktion zum Erstellen von Texturen ein wenig wiederholen, sodass es mehr als eine gibt. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTextures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(let i = 0; i &lt; URLS.textures.length; i++)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crossOrigin</span></span></span><span class="hljs-function"> = '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anonymous</span></span></span><span class="hljs-function">'; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onload</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt; { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texture</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activeTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL['TEXTURE' + index])</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, texture)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pixelStorei</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.UNPACK_FLIP_Y_WEBGL, true)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texImage2D</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, 0, GL.RGB, GL.RGB, GL.UNSIGNED_BYTE, image)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uniform1i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.getUniformLocation(PROGRAM, 'u_textures[' + index + ']')</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-function">); }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">src</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLS</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[index]</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><p>  Es ist nichts Ungewöhnliches passiert. Wir haben nur die Nullen durch den <code>index</code> und den vorhandenen Code zum Laden der drei Texturen wiederverwendet.  Im Shader haben wir jetzt eine Reihe von Texturen: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUMBER_OF_TEXTURES 3 uniform sampler2D u_textures[NUMBER_OF_TEXTURES];</span></span></code> </pre> <br><p>  Jetzt können wir die zuvor gespeicherte Bereichsnummer verwenden, um eine der drei Texturen auszuwählen.  Aber ... </p><br><p>  Aber vorher möchte ich einen kleinen Exkurs machen.  Über wund.  Über die Syntax.  Modernes Javascript (bedingt ES6 +) ist eine schöne Sprache.  Es ermöglicht Ihnen, Ihre Gedanken so auszudrücken, wie sie entstehen, beschränkt das Framework nicht auf ein bestimmtes Programmierparadigma, vervollständigt einige Punkte für uns und ermöglicht es Ihnen, sich mehr auf die Idee als auf deren Umsetzung zu konzentrieren.  Für den Schöpfer - das war's.  Einige Leute glauben, dass es zu viel Freiheit gibt und wechseln zum Beispiel zu TypeScript.  Pure C ist eine strengere Sprache.  Es erlaubt auch viel, man kann alles darauf locken, aber nach JS wird es als etwas umständlich, altmodisch oder so empfunden.  Trotzdem ist er immer noch gut.  GLSL, wie es in Browsern existiert, ist nur etwas.  Es ist nicht nur eine Größenordnung strenger als C, es fehlen auch noch viele bekannte Operatoren und Syntaxkonstrukte.  Dies ist wahrscheinlich das größte Problem beim Schreiben von mehr oder weniger komplexen Shadern für WebGL.  Hinter dem Horror, in den sich der Code verwandelt, kann es sehr schwierig sein, einen Blick auf den ursprünglichen Algorithmus zu werfen.  Einige Programmierer denken, dass der Weg zu den Shadern für sie geschlossen ist, bis sie C lernen.  Also: Kenntnisse in C helfen hier nicht besonders.  Hier ist eine Art eigene Welt.  Die Welt des Wahnsinns, der Dinosaurier und Krücken. </p><br><p>  Wie kann ich eine von drei Texturen mit einer Nummer auswählen - der Bereichsnummer?  Der Rest ergibt sich aus der Division der Anzahl durch die Anzahl der Texturen.  Eine super Idee.  Nur der <code>%</code> -Operator, den die Hände selbst bereits schreiben, ist nicht hier.  Der Eindruck, diese Tatsache zu verstehen, wird durch das Bild gut beschrieben: </p><br><p><img src="https://habrastorage.org/webt/3j/w3/on/3jw3on4pazjczkana82degd6gcc.png" alt="Bild"></p><br><p>  Natürlich sagst du: "Ja, kein Problem, es gibt eine <code>mod</code> Funktion - lass es uns nehmen!".  Es stellt sich jedoch heraus, dass sie keine zwei ganzen Zahlen akzeptiert, sondern nur gebrochene.  Ok, nun, mach einen <code>float</code> aus ihnen.  Wir bekommen auch einen <code>float</code> , aber wir brauchen einen <code>int</code> .  Sie müssen alles zurückkonvertieren, sonst besteht die Möglichkeit, dass ein Kompilierungsfehler auftritt. </p><br><pre> <code class="hljs lisp">int texture_index = int(<span class="hljs-name"><span class="hljs-name">mod</span></span>(<span class="hljs-name"><span class="hljs-name">float</span></span>(<span class="hljs-name"><span class="hljs-name">area_index</span></span>), float(<span class="hljs-name"><span class="hljs-name">NUMBER_OF_TEXTURES</span></span>)))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Und hier ist eine rhetorische Frage: Vielleicht ist es einfacher, die Funktion des Restes der Ganzzahldivision zu realisieren, als zu versuchen, sie aus Standardmethoden zusammenzusetzen?  Und dies ist immer noch eine einfache Funktion, und es kommt vor, dass sehr tief eingebettete Sequenzen solcher Transformationen erhalten werden, in denen nicht mehr klar ist, was passiert. </p><br><p>  Okay, lassen wir es so wie es ist.  Nehmen Sie einfach die Farbe des gewünschten Pixels aus der ausgewählten Textur und weisen Sie sie der Variablen <code>gl_FragColor</code> .  Also?  Haben wir das schon gemacht?  Und dann erscheint diese Katze wieder.  Sie können beim Zugriff auf ein Array keine Nichtkonstante verwenden.  Und alles, was wir berechnet haben, ist keine Konstante mehr.  Ba-dum-tsss !!! </p><br><p>  Sie müssen so etwas tun: </p><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">0</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">1</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">2</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">2</span></span>], texture_coord); }</code> </pre> <br><p>  Stimmen Sie zu, ein solcher Code ist ein direkter Weg zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">govnokod.ru</a> , aber er unterscheidet sich in jeder Hinsicht.  Selbst die <code>switch-case</code> ist nicht hier, um diese Schande zumindest irgendwie zu veredeln.  Es gibt wirklich eine andere, weniger offensichtliche Krücke, die das gleiche Problem löst: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>], texture_coord); } }</code> </pre> <br><p>  Zykluszähler, die sich um eins erhöhen, kann der Compiler als Konstante zählen.  Dies funktionierte jedoch nicht mit einer Reihe von Texturen. Im letzten Chrome trat ein Fehler auf, der besagte, dass dies mit einer Reihe von Texturen nicht möglich war.  Mit einer Reihe von Zahlen hat es funktioniert.  Ratet mal, warum es mit einem Array funktioniert, aber nicht mit einem anderen?  Wenn Sie dachten, dass das Typgusssystem in JS voller Magie ist, sortieren Sie das System "Konstante - nicht Konstante" in GLSL aus.  Das Lustige ist, dass die Ergebnisse auch von der verwendeten Grafikkarte abhängen, sodass die kniffligen Krücken, die auf der NVIDIA-Grafikkarte funktionierten, bei AMD sehr gut ausfallen können. </p><br><blockquote>  Es ist besser, solche Entscheidungen zu vermeiden, die auf Annahmen über den Compiler beruhen.  Sie neigen dazu zu brechen und sind schwer zu testen. </blockquote><p>  Traurigkeit ist Traurigkeit.  Aber wenn wir interessante Dinge tun wollen, müssen wir von all dem abstrahieren und weitermachen. </p><br><p>  Im Moment haben wir ein Mosaik von Fotos.  Aber es gibt ein Detail: Wenn die Punkte sehr nahe beieinander liegen, gibt es einen schnellen Übergang von zwei Bereichen.  Es ist nicht sehr hübsch.  Sie müssen einen Algorithmus hinzufügen, der nicht zulässt, dass die Punkte nahe kommen.  Sie können eine einfache Option auswählen, bei der die Abstände zwischen Punkten überprüft werden. Wenn sie unter einem bestimmten Wert liegen, schieben wir sie auseinander.  Diese Option ist nicht ohne Nachteile, insbesondere führt sie manchmal zu einem leichten Zucken der Punkte, kann aber in vielen Fällen ausreichen, zumal es hier nicht sehr viele Berechnungen gibt.  Fortgeschrittenere Optionen wären ein System bewegter Ladungen und ein "Spinnennetz", in dem Punktpaare durch unsichtbare Federn verbunden sind.  Wenn Sie daran interessiert sind, sie zu implementieren, finden Sie leicht alle Formeln im Physik-Nachschlagewerk für die High School. </p><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let j = i; j &lt; NUMBER_OF_POINTS; j++) { let deltaX = POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] - POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; let deltaY = POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] - POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>]; let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) { POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaX); POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] += <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaY); POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] -= <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaX); POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] -= <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaY); } } }</code> </pre> <br><p>  Das Hauptproblem bei diesem und dem im Shader verwendeten Ansatz besteht darin, alle Punkte mit allen zu vergleichen.  Sie müssen kein guter Mathematiker sein, um zu verstehen, dass die Anzahl der Entfernungsberechnungen unglaublich ist, wenn wir nicht 10 Punkte, sondern 1000 machen. Ja, sogar 100 reichen aus, damit sich alles verlangsamt.  Daher ist es sinnvoll, es nur für eine kleine Anzahl von Punkten anzuwenden. </p><br><p>  Wenn wir ein solches Mosaik für eine große Anzahl von Punkten erstellen möchten, können wir die bekannte Unterteilung der Ebene in identische Quadrate verwenden.  Die Idee ist, einen Punkt in jedes Quadrat zu setzen und dann alle Vergleiche nur mit Punkten von benachbarten Quadraten durchzuführen.  Eine gute Idee, aber Experimente haben gezeigt, dass preiswerte Laptops mit integrierten Grafikkarten mit einer großen Anzahl von Punkten immer noch nicht zurechtkommen.  Es lohnt sich daher, zehn Mal darüber nachzudenken, bevor Sie sich entscheiden, aus einer großen Anzahl von Fragmenten ein solches Mosaik auf Ihrer Website zu erstellen. </p><br><blockquote>  Seien Sie keine Radieschen, überprüfen Sie die Leistung Ihres Handwerks nicht nur auf Ihrem Bergbauernhof, sondern auch auf normalen Laptops.  Benutzer werden im Grunde diejenigen sein. </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/VGmEYN" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="razbienie-ploskosti-na-chasti-po-grafiku-funkcii">  Partitionieren einer Ebene gemäß einem Funktionsgraphen </h2><br><p>  Sehen wir uns eine weitere Option zum Teilen einer Ebene in Teile an.  Es wird keine große Rechenleistung mehr benötigt.  Die Hauptidee ist, eine mathematische Funktion zu übernehmen und ihren Graphen zu erstellen.  Die resultierende Linie teilt die Ebene nur in zwei Teile.  Wenn wir eine Funktion der Form <code>y = f(x)</code> , erhalten wir eine Division in Form eines Schnitts.  Wenn Sie X durch Y ersetzen, können Sie den horizontalen Abschnitt in vertikal ändern.  Wenn Sie die Funktion in Polarkoordinaten übernehmen, müssen Sie alles ins Kartesische übersetzen und umgekehrt, aber das Wesentliche der Berechnungen ändert sich nicht.  In diesem Fall ist das Ergebnis kein Schnitt in zwei Teile, sondern ein Lochschnitt.  Aber wir werden die erste Option sehen. </p><br><p>  Für jedes Y berechnen wir den Wert von X, um einen vertikalen Schnitt zu erstellen.  Wir könnten zum Beispiel eine Sinuswelle für diese Zwecke nehmen, aber es ist zu langweilig.  Es ist besser, ein paar Stücke auf einmal zu nehmen und sie zu falten. </p><br><p>  Wir nehmen mehrere Sinuskurven, von denen jede an eine Koordinate entlang Y und an die Zeit gebunden ist, und addieren sie.  Physiker würden diese Addition Überlagerung nennen.  Wenn wir das gesamte Ergebnis mit einer Zahl multiplizieren, ändern wir natürlich die Amplitude.  Nehmen Sie es in einem separaten Makro heraus.  Wenn Sie die Koordinate - den Sinusparameter - multiplizieren, ändert sich die Frequenz.  Wir haben dies bereits in einem früheren Artikel gesehen.  Wir entfernen auch den Frequenzmodifikator, der allen Sinuskurven gemeinsam ist, aus der Formel.  Es ist nicht überflüssig, mit der Zeit zu spielen. Ein negatives Vorzeichen bewirkt, dass die Linie in die entgegengesetzte Richtung bewegt wird. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span> = u_time * SPEED; <span class="hljs-type"><span class="hljs-type">float</span></span> x = (sin(texture_coord.y * FREQUENCY) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">2.1</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">1.72</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">1.121</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">2.221</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">0.437</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">3.1122</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">4.269</span></span>)) * AMPLITUDE;</code> </pre> <br><p>  Nachdem wir solche globalen Einstellungen für unsere Funktion vorgenommen haben, werden wir vor dem Problem stehen, dieselbe Bewegung in relativ kurzen Intervallen zu wiederholen.  Um dieses Problem zu lösen, müssen wir alles mit Koeffizienten multiplizieren, für die das kleinste gemeinsame Vielfache sehr groß ist.  Ähnliches wird auch im Zufallszahlengenerator verwendet, erinnerst du dich?  In diesem Fall haben wir nicht nachgedacht und vorgefertigte Zahlen aus einem Beispiel aus dem Internet genommen, aber niemand stört sich daran, mit unseren Werten zu experimentieren. </p><br><p>  Es bleibt nur eine der beiden Texturen für Punkte über unserem Funktionsdiagramm und die zweite für Punkte darunter zu wählen.  Genauer nach links und rechts drehten wir uns alle um: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (texture_coord.x - <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> &gt; x) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord); }</code> </pre> <br><p>  Was wir erhalten haben, ähnelt Schallwellen.  Genauer gesagt, ihr Bild auf dem Oszilloskop.  In der Tat könnten wir anstelle unserer Sinuskurven Daten aus einer Art Audiodatei übertragen.  Die Arbeit mit Ton ist jedoch ein Thema für einen separaten Artikel. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/VGmEeO" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="maski">  Masken </h2><br><p>  Die vorherigen Beispiele sollten zu einer ganz logischen Bemerkung führen: All dies sieht aus wie die Arbeit von Masken in SVG (wenn Sie nicht mit ihnen gearbeitet haben, lesen Sie Beispiele aus dem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SVG-Masken und Wow-Effekte</a> ).  Es ist nur so, dass wir sie hier etwas anders machen.  Und das Ergebnis ist das gleiche - einige Bereiche werden mit einer Textur übermalt, andere mit einer anderen.  Nur reibungslose Übergänge gab es noch nicht.  Also lass uns eins machen. </p><br><p>  Wir entfernen alle unnötigen und geben die Koordinaten der Maus zurück.  Erstellen Sie einen radialen Verlauf mit der Mitte an der Cursorposition und verwenden Sie ihn als Maske.  In diesem Beispiel ähnelt das Shader-Verhalten der Logik von Masken in SVG stärker als in den vorherigen Beispielen.  Wir brauchen eine <code>mix</code> und eine Funktion der Distanz.  Der erste mischt die Pixelfarbwerte aus beiden Texturen und verwendet als dritten Parameter einen Koeffizienten (von 0 bis 1), der bestimmt, welcher der Werte als Ergebnis vorherrscht.  Wir nehmen den Sinusmodul als Funktion der Entfernung - er ergibt nur eine sanfte Änderung des Wertes zwischen 0 und 1. </p><br><pre> <code class="hljs lisp">gl_FragColor = mix( <span class="hljs-name"><span class="hljs-name">texture2D</span></span>(<span class="hljs-name"><span class="hljs-name">u_textures</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord), texture2D(<span class="hljs-name"><span class="hljs-name">u_textures</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord), abs(<span class="hljs-name"><span class="hljs-name">sin</span></span>(<span class="hljs-name"><span class="hljs-name">length</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span> - u_mouse_position / u_canvas_size))))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Das ist alles  Schauen wir uns das Ergebnis an: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/bxBmwB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Der Hauptvorteil gegenüber SVG liegt auf der Hand: </p><br><blockquote>  Im Gegensatz zu SVG können wir hier leicht glatte Verläufe für verschiedene mathematische Funktionen erstellen und diese nicht aus vielen linearen Verläufen erfassen. </blockquote><p>  Wenn Sie eine einfachere Aufgabe haben, für die keine so reibungslosen Übergänge oder komplexen Formulare erforderlich sind, die im Prozess berechnet werden, ist die Implementierung höchstwahrscheinlich ohne die Verwendung von Shadern einfacher.  Ja, und die Leistung auf schwacher Hardware ist wahrscheinlich besser.  Wählen Sie ein Werkzeug basierend auf Ihren Aufgaben. </p><br><p>  Schauen wir uns zu Bildungszwecken ein anderes Beispiel an.  Erstellen Sie zunächst einen Kreis, in dem die Textur unverändert bleibt: </p><br><pre> <code class="hljs objectivec">gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = distance(texture_coord, u_mouse_position / u_canvas_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dist &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  Und füllen Sie den Rest mit diagonalen Streifen: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = sin((texture_coord.y - texture_coord.x) * <span class="hljs-number"><span class="hljs-number">200.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { gl_FragColor.rgb *= dist; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gl_FragColor.rgb *= dist / <span class="hljs-number"><span class="hljs-number">10.0</span></span>; }</code> </pre> <br><p>  Die Akzeptanzen sind die gleichen - wir multiplizieren den Parameter für den Sinus, um die Frequenz der Streifen zu erhöhen;  Teilen Sie die erhaltenen Werte in zwei Teile.  Für jede der Hälften transformieren wir die Farbe der Pixel auf unsere eigene Weise.  Es ist nützlich, sich daran zu erinnern, dass das Zeichnen diagonaler Linien normalerweise mit dem Hinzufügen von Koordinaten in X und Y verbunden ist. Beachten Sie, dass wir beim Ändern der Farben auch den Abstand zum Mauszeiger verwenden, um so eine Art Schatten zu erzeugen.  Auf die gleiche Weise können Sie es mit geometrischen Transformationen verwenden. Wir werden dies bald am Beispiel der Pixelierung sehen.  Schauen Sie sich in der Zwischenzeit das Ergebnis dieses Shaders an: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/rZWqyK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Einfach und hübsch. </p><br><blockquote>  Und ja, wenn Sie ein wenig verwirrt sind, können Sie Texturen nicht aus Bildern, sondern aus Bildern erstellen (es gibt viele Beispiele im Netzwerk, Sie können sie leicht herausfinden) und alle unsere Effekte auf sie anwenden.  Viele Verzeichnisseiten wie Awwwards verwenden diese Effekte in Verbindung mit Video. </blockquote><p>  Es lohnt sich, sich an einen weiteren Gedanken zu erinnern: </p><br><blockquote>  Niemand stört es, eine der Texturen als Maske zu verwenden.  Wir können ein Bild aufnehmen und die Farbwerte seiner Pixel in unseren Transformationen verwenden, unabhängig davon, ob es sich um Änderungen in anderen Farben, Verschiebungen zu den Seiten oder etwas anderes handelt, das Ihnen in den Sinn kommt. </blockquote><p>  Aber zurück zum Teilen des Flugzeugs in Teile. </p><br><h2 id="pikselizaciya">  Pixelisierung </h2><br><p>  Dieser Effekt ist etwas offensichtlich, aber gleichzeitig ist er so häufig, dass es falsch wäre, daran vorbeizukommen.  Teilen Sie unsere Ebene auf die gleiche Weise wie im Beispiel mit dem Rauschgenerator in Quadrate, und setzen Sie dann für alle Pixel in jedem Quadrat die gleiche Farbe.  Es wird durch Mischen von Werten aus den Ecken eines Quadrats erhalten, wir haben bereits etwas Ähnliches gemacht.  Für diesen Effekt benötigen wir keine komplexen Formeln. Addieren Sie einfach alle Werte und dividieren Sie durch 4 - die Anzahl der Winkel des Quadrats. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> block_size = abs(sin(u_time)) / <span class="hljs-number"><span class="hljs-number">20.0</span></span>; vec2 block_position = floor(texture_coord / block_size) * block_size; gl_FragColor = ( texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>) * block_size) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * block_size) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * block_size) ) / <span class="hljs-number"><span class="hljs-number">4.0</span></span>;</code> </pre> <br><p>  Wir haben erneut einen der Parameter durch das Sinusmodul an die Zeit gebunden, um visuell zu sehen, was passiert, wenn es sich ändert. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/eLBPej" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="pikselnye-volny">  Pixelwellen </h2><br><p>            ,       . </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> block_size = abs(sin( length(texture_coord - u_mouse_position / u_canvas_size) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - u_time)) / <span class="hljs-number"><span class="hljs-number">100.0</span></span> + <span class="hljs-number"><span class="hljs-number">0.001</span></span>;</code> </pre> <br><p>   ,       0  1;        , ,    ,     .       ,      . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/EeNdEr" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>    "" ,              ,    -.     .       " ",     ,         .     .      —  .       . </p><br><h2 id="itogi">  Zusammenfassung </h2><br><p>         ,     ,  ,    ,           .                    -.     -       -  .          .          .    ,      ,      ,      . </p><br><hr><br><p> <em>PS:  ,   WebGL (      )          ?     ,   ,   .          ?</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421821/">https://habr.com/ru/post/de421821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421809/index.html">Java EE Concurrency API</a></li>
<li><a href="../de421811/index.html">Die IETF hat einen neuen Standard für Messaging vorgeschlagen - was Sie wissen müssen</a></li>
<li><a href="../de421815/index.html">Sechs Monate später flüssiges Metall in einem Laptop</a></li>
<li><a href="../de421817/index.html">Arbeiten mit Formularen in React.js mit grundlegenden Tools</a></li>
<li><a href="../de421819/index.html">ELK-Stapel zum Speichern von Django-Anwendungsprotokollen</a></li>
<li><a href="../de421823/index.html">Wie wir X-Ray x64 eingeführt haben</a></li>
<li><a href="../de421827/index.html">Was kann man jetzt über Java lesen?</a></li>
<li><a href="../de421829/index.html">Frangos Anomalie - eine fantastische Romanze mit echten IT-Leuten</a></li>
<li><a href="../de421833/index.html">Wir schreiben unser einfachstes Programm für ARM Cortex-M3</a></li>
<li><a href="../de421835/index.html">Die Interagency Commission entwickelt neue Technologien zur Blockierung von Telegrammen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>