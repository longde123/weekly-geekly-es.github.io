<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèæ ‚ùÑÔ∏è üîü Wir verwenden Voronois Mosaik-, Pixel- und geometrische Masken in Shadern, um die Site zu dekorieren üòò üôåüèΩ ü§î</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist eine logische Fortsetzung der Einf√ºhrung von Programmier-Shadern f√ºr Layout-Designer . Darin haben wir eine Vorlage zum Erstellen v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir verwenden Voronois Mosaik-, Pixel- und geometrische Masken in Shadern, um die Site zu dekorieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421821/"><img src="https://habrastorage.org/webt/tw/dv/y5/twdvy5bonlmr47omgfhgmi9rjqu.jpeg" alt="Bild"><br><br><p> Dieser Artikel ist eine logische Fortsetzung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung von Programmier-Shadern f√ºr Layout-Designer</a> .  Darin haben wir eine Vorlage zum Erstellen verschiedener zweidimensionaler Effekte mit Fotos mithilfe von Shadern erstellt und einige Beispiele betrachtet.  In diesem Artikel werden wir einige weitere Texturen hinzuf√ºgen, die Voronoi-Aufteilung in der Praxis anwenden, um Mosaike daraus zu erstellen, √ºber das Erstellen verschiedener Masken in Shadern und √ºber die Pixelung sprechen und auch einige Probleme der alten GLSL-Syntax ansprechen, die in unseren Browsern noch vorhanden sind. </p><br><p>  Genau wie beim letzten Mal wird es ein Minimum an Theorie und ein Maximum an √úbung und Argumentation in einer allt√§glichen Sprache geben.  Anf√§nger finden hier eine Abfolge von Aktionen mit Tipps und n√ºtzlichen Hinweisen, und erfahrene Front-End-Anbieter finden m√∂glicherweise einige Ideen zur Inspiration. </p><a name="habracut"></a><br><p>  <em>Eine Umfrage in einem fr√ºheren Artikel hat gezeigt, dass das Thema WebGL-Effekte f√ºr Websites nicht nur f√ºr Schriftsetzer, sondern auch f√ºr unsere Kollegen aus anderen Spezialisierungen von Interesse sein kann.</em>  <em>Um sie nicht mit den neuesten ES-Funktionen zu verwirren, beschr√§nken wir uns bewusst auf traditionellere Syntaxkonstrukte, die jeder versteht.</em>  <em>Und wieder mache ich die Leser darauf aufmerksam, dass die eingebauten Editoren von CodePen die Leistung dessen beeinflussen, was in ihnen getan wird.</em> </p><br><p>  Aber fangen wir an ... </p><br><h2 id="shablon-dlya-raboty-s-sheyderami">  Vorlage f√ºr die Arbeit mit Shadern </h2><br><p>  F√ºr diejenigen, die den vorherigen Artikel nicht gelesen haben, haben wir diese Vorlage f√ºr die Arbeit mit Shadern erstellt: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/ZMBMPJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Darin wird eine Ebene erzeugt (in unserem Fall ein Quadrat), auf die die Bildtextur "gezeichnet" wird.  Keine unn√∂tigen Abh√§ngigkeiten und ein sehr einfacher Vertex-Shader.  Dann haben wir diese Vorlage entwickelt, aber jetzt beginnen wir mit dem Moment, in dem der Fragment-Shader noch keine Logik enth√§lt. </p><br><h2 id="mozaika">  Mosaik </h2><br><p>  Mosaik ist eine Ebene, die in kleine Bereiche unterteilt ist, in denen jeder Bereich mit einer bestimmten Farbe oder, wie in unserem Fall, Textur gef√ºllt ist.  Wie k√∂nnen wir unser Flugzeug √ºberhaupt in St√ºcke zerbrechen?  Nat√ºrlich k√∂nnen Sie es in Rechtecke aufteilen.  Mit Hilfe von SVG ist dies jedoch bereits so einfach, WebGL auf diese Aufgabe zu ziehen und alles aus heiterem Himmel ohne jeden Zweck zu erledigen. </p><br><p>  Damit das Mosaik interessant ist, muss es unterschiedliche Fragmente aufweisen, sowohl in Form als auch in Gr√∂√üe.  Es gibt einen sehr einfachen, aber gleichzeitig sehr unterhaltsamen Ansatz zum Aufbau einer solchen Partition.  Es ist bekannt als Voronois Mosaik oder Dirichlets Trennwand, und auf Wikipedia schreiben sie, dass Descartes im fernen 17. Jahrhundert etwas √Ñhnliches verwendet hat.  Die Idee ist ungef√§hr so: </p><br><ul><li>  Nehmen Sie eine Reihe von Punkten im Flugzeug. </li><li>  Suchen Sie f√ºr jeden Punkt in der Ebene aus dieser Menge den Punkt, der ihm am n√§chsten liegt. </li><li>  Das ist alles  Die Ebene ist in polygonale Bereiche unterteilt, von denen jeder durch einen der Punkte in der Menge bestimmt wird. </li></ul><br><p>  Es ist wahrscheinlich besser, diesen Prozess anhand eines praktischen Beispiels zu zeigen.  Es gibt verschiedene Algorithmen zum Generieren dieser Partition, aber wir werden in der Stirn agieren, da die Berechnung f√ºr jeden Punkt in der Ebene nur die Aufgabe des Shaders ist.  Zuerst m√ºssen wir eine Reihe von zuf√§lligen Punkten machen.  Um den Code der Beispiele nicht zu laden, erstellen wir eine globale Variable f√ºr sie. </p><br><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { POINTS.push([<span class="hljs-type"><span class="hljs-type">Math.random</span></span>(), <span class="hljs-type"><span class="hljs-type">Math.random</span></span>()]); } }</code> </pre> <br><p>  Jetzt m√ºssen wir sie an die Shader weitergeben.  Die Daten sind global, daher verwenden wir den <code>uniform</code> Modifikator.  Aber es gibt einen subtilen Punkt: Wir k√∂nnen nicht einfach ein Array √ºbergeben.  Es scheint, dass das 21. Jahrhundert auf dem Hof ‚Äã‚Äãliegt, aber es wird nichts daraus.  Infolgedessen m√ºssen Sie eine Reihe von Punkten einzeln √ºbertragen. </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { GL.uniform2fv(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_points['</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-string"><span class="hljs-string">']'</span></span>), POINTS[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); }</code> </pre> <br><p>  Heutzutage werden wir h√§ufig auf √§hnliche Probleme der Inkonsistenz zwischen dem, was erwartet wird, und dem, was in echten Browsern ist, sto√üen.  Normalerweise verwenden WebGL-Tutorials THREE.js und diese Bibliothek verbirgt einen Teil des Schmutzes in sich selbst, wie es jQuery einmal bei seinen Aufgaben getan hat. Wenn Sie ihn jedoch entfernen, tut dies Ihrem Gehirn wirklich weh. </p><br><p>  Im Fragment-Shader haben wir eine Array-Variable f√ºr Punkte.  Wir k√∂nnen nur Arrays mit fester L√§nge erstellen.  Beginnen wir mit 10 Punkten: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUMBER_OF_POINTS 10 uniform vec2 u_points[NUMBER_OF_POINTS];</span></span></code> </pre> <br><p>  Stellen Sie sicher, dass dies alles funktioniert, indem Sie an den Stellen der Punkte Kreise zeichnen.  Eine solche Zeichnung verschiedener geometrischer Grundelemente wird h√§ufig beim Debuggen verwendet - sie sind deutlich sichtbar und Sie k√∂nnen sofort verstehen, was sich befindet und wo es sich bewegt. </p><br><blockquote>  Verwenden Sie das "Zeichnen" von Kreisen, Linien und anderen Orientierungspunkten f√ºr die unsichtbaren Objekte, auf denen Animationen erstellt werden.  Dies gibt offensichtliche Hinweise darauf, wie sie funktionieren, insbesondere wenn die Algorithmen komplex sind und ohne vorherige Vorbereitung schnell verstanden werden k√∂nnen.  Dann kann das alles auskommentiert und den Kollegen √ºberlassen werden - sie werden sich bedanken. </blockquote><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt; <span class="hljs-number"><span class="hljs-number">0.02</span></span>) { gl_FragColor = WHITE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/pONOme" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Gut.  F√ºgen wir den Punkten auch etwas Bewegung hinzu.  Lassen Sie sie sich zun√§chst in einem Kreis bewegen, dann werden wir sp√§ter auf dieses Thema zur√ºckkommen.  Die Koeffizienten werden auch auf das Auge gelegt, um ihre Bewegung etwas zu verlangsamen und die Amplitude der Schwingungen zu verringern. </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movePoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeStamp)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timeStamp) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] += Math.sin(i * timeStamp / <span class="hljs-number"><span class="hljs-number">5000.0</span></span>) / <span class="hljs-number"><span class="hljs-number">500.0</span></span>; POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] += Math.cos(i * timeStamp / <span class="hljs-number"><span class="hljs-number">5000.0</span></span>) / <span class="hljs-number"><span class="hljs-number">500.0</span></span>; } } }</code> </pre> <br><p>  Gehe zur√ºck zum Shader.  F√ºr zuk√ºnftige Experimente werden wir eine n√ºtzliche Anzahl von Bereichen finden, in die alles unterteilt wird.  Wir finden also den Punkt, der dem aktuellen Pixel am n√§chsten liegt, aus der Menge und speichern die Nummer dieses Punkts - es ist die Bereichsnummer. </p><br><pre> <code class="hljs matlab">float min_distance = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; int area_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { float current_distance = distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current_distance &lt; min_distance) { min_distance = current_distance; area_index = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } }</code> </pre> <br><p>  Um die Leistung zu testen, malen wir wieder alles in leuchtenden Farben: </p><br><pre> <code class="hljs pgsql">gl_FragColor = texture2D(u_texture, texture_coord); gl_FragColor.g = abs(sin(<span class="hljs-type"><span class="hljs-type">float</span></span>(area_index))); gl_FragColor.b = abs(sin(<span class="hljs-type"><span class="hljs-type">float</span></span>(area_index)));</code> </pre> <br><blockquote>  Die Kombination von Modul (abs) und eingeschr√§nkten Funktionen (insbesondere sin und cos) wird h√§ufig verwendet, wenn mit √§hnlichen Effekten gearbeitet wird.  Dies f√ºgt einerseits ein wenig Zuf√§lligkeit hinzu und andererseits ergibt sich sofort ein normalisiertes Ergebnis von 0 bis 1, was sehr praktisch ist - wir haben sehr viele Werte, die genau innerhalb dieser Grenzen liegen. </blockquote><p>  Wir werden auch Punkte finden, die mehr oder weniger gleich weit von mehreren Punkten aus der Menge entfernt sind, und sie f√§rben.  Diese Aktion enth√§lt keine spezielle Nutzlast, aber das Ergebnis zu betrachten ist immer noch interessant. </p><br><pre> <code class="hljs matlab">int number_of_near_points = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt; min_distance + EPSILON) { number_of_near_points++; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number_of_near_points &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { gl_FragColor.rgb = vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Sie sollten so etwas bekommen: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/xaRavJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Dies ist immer noch ein Entwurf, wir werden ihn noch fertigstellen.  Aber jetzt ist das allgemeine Konzept einer solchen Trennung der Ebene klar. </p><br><h2 id="mozaika-iz-fotografiy">  Mosaik von Fotos </h2><br><p>  Es ist klar, dass eine solche Partition in ihrer reinen Form nicht viel bringt.  Um Ihren Horizont zu erweitern und nur zum Spa√ü, k√∂nnen Sie mit ihm spielen, aber auf einer realen Website lohnt es sich, ein paar weitere Fotos hinzuzuf√ºgen und ein Mosaik daraus zu machen.  Lassen Sie uns die Funktion zum Erstellen von Texturen ein wenig wiederholen, sodass es mehr als eine gibt. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTextures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(let i = 0; i &lt; URLS.textures.length; i++)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crossOrigin</span></span></span><span class="hljs-function"> = '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anonymous</span></span></span><span class="hljs-function">'; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onload</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt; { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texture</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activeTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL['TEXTURE' + index])</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, texture)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pixelStorei</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.UNPACK_FLIP_Y_WEBGL, true)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texImage2D</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, 0, GL.RGB, GL.RGB, GL.UNSIGNED_BYTE, image)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uniform1i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.getUniformLocation(PROGRAM, 'u_textures[' + index + ']')</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-function">); }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">src</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLS</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[index]</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><p>  Es ist nichts Ungew√∂hnliches passiert. Wir haben nur die Nullen durch den <code>index</code> und den vorhandenen Code zum Laden der drei Texturen wiederverwendet.  Im Shader haben wir jetzt eine Reihe von Texturen: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUMBER_OF_TEXTURES 3 uniform sampler2D u_textures[NUMBER_OF_TEXTURES];</span></span></code> </pre> <br><p>  Jetzt k√∂nnen wir die zuvor gespeicherte Bereichsnummer verwenden, um eine der drei Texturen auszuw√§hlen.  Aber ... </p><br><p>  Aber vorher m√∂chte ich einen kleinen Exkurs machen.  √úber wund.  √úber die Syntax.  Modernes Javascript (bedingt ES6 +) ist eine sch√∂ne Sprache.  Es erm√∂glicht Ihnen, Ihre Gedanken so auszudr√ºcken, wie sie entstehen, beschr√§nkt das Framework nicht auf ein bestimmtes Programmierparadigma, vervollst√§ndigt einige Punkte f√ºr uns und erm√∂glicht es Ihnen, sich mehr auf die Idee als auf deren Umsetzung zu konzentrieren.  F√ºr den Sch√∂pfer - das war's.  Einige Leute glauben, dass es zu viel Freiheit gibt und wechseln zum Beispiel zu TypeScript.  Pure C ist eine strengere Sprache.  Es erlaubt auch viel, man kann alles darauf locken, aber nach JS wird es als etwas umst√§ndlich, altmodisch oder so empfunden.  Trotzdem ist er immer noch gut.  GLSL, wie es in Browsern existiert, ist nur etwas.  Es ist nicht nur eine Gr√∂√üenordnung strenger als C, es fehlen auch noch viele bekannte Operatoren und Syntaxkonstrukte.  Dies ist wahrscheinlich das gr√∂√üte Problem beim Schreiben von mehr oder weniger komplexen Shadern f√ºr WebGL.  Hinter dem Horror, in den sich der Code verwandelt, kann es sehr schwierig sein, einen Blick auf den urspr√ºnglichen Algorithmus zu werfen.  Einige Programmierer denken, dass der Weg zu den Shadern f√ºr sie geschlossen ist, bis sie C lernen.  Also: Kenntnisse in C helfen hier nicht besonders.  Hier ist eine Art eigene Welt.  Die Welt des Wahnsinns, der Dinosaurier und Kr√ºcken. </p><br><p>  Wie kann ich eine von drei Texturen mit einer Nummer ausw√§hlen - der Bereichsnummer?  Der Rest ergibt sich aus der Division der Anzahl durch die Anzahl der Texturen.  Eine super Idee.  Nur der <code>%</code> -Operator, den die H√§nde selbst bereits schreiben, ist nicht hier.  Der Eindruck, diese Tatsache zu verstehen, wird durch das Bild gut beschrieben: </p><br><p><img src="https://habrastorage.org/webt/3j/w3/on/3jw3on4pazjczkana82degd6gcc.png" alt="Bild"></p><br><p>  Nat√ºrlich sagst du: "Ja, kein Problem, es gibt eine <code>mod</code> Funktion - lass es uns nehmen!".  Es stellt sich jedoch heraus, dass sie keine zwei ganzen Zahlen akzeptiert, sondern nur gebrochene.  Ok, nun, mach einen <code>float</code> aus ihnen.  Wir bekommen auch einen <code>float</code> , aber wir brauchen einen <code>int</code> .  Sie m√ºssen alles zur√ºckkonvertieren, sonst besteht die M√∂glichkeit, dass ein Kompilierungsfehler auftritt. </p><br><pre> <code class="hljs lisp">int texture_index = int(<span class="hljs-name"><span class="hljs-name">mod</span></span>(<span class="hljs-name"><span class="hljs-name">float</span></span>(<span class="hljs-name"><span class="hljs-name">area_index</span></span>), float(<span class="hljs-name"><span class="hljs-name">NUMBER_OF_TEXTURES</span></span>)))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Und hier ist eine rhetorische Frage: Vielleicht ist es einfacher, die Funktion des Restes der Ganzzahldivision zu realisieren, als zu versuchen, sie aus Standardmethoden zusammenzusetzen?  Und dies ist immer noch eine einfache Funktion, und es kommt vor, dass sehr tief eingebettete Sequenzen solcher Transformationen erhalten werden, in denen nicht mehr klar ist, was passiert. </p><br><p>  Okay, lassen wir es so wie es ist.  Nehmen Sie einfach die Farbe des gew√ºnschten Pixels aus der ausgew√§hlten Textur und weisen Sie sie der Variablen <code>gl_FragColor</code> .  Also?  Haben wir das schon gemacht?  Und dann erscheint diese Katze wieder.  Sie k√∂nnen beim Zugriff auf ein Array keine Nichtkonstante verwenden.  Und alles, was wir berechnet haben, ist keine Konstante mehr.  Ba-dum-tsss !!! </p><br><p>  Sie m√ºssen so etwas tun: </p><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">0</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">1</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">2</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">2</span></span>], texture_coord); }</code> </pre> <br><p>  Stimmen Sie zu, ein solcher Code ist ein direkter Weg zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">govnokod.ru</a> , aber er unterscheidet sich in jeder Hinsicht.  Selbst die <code>switch-case</code> ist nicht hier, um diese Schande zumindest irgendwie zu veredeln.  Es gibt wirklich eine andere, weniger offensichtliche Kr√ºcke, die das gleiche Problem l√∂st: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>], texture_coord); } }</code> </pre> <br><p>  Zyklusz√§hler, die sich um eins erh√∂hen, kann der Compiler als Konstante z√§hlen.  Dies funktionierte jedoch nicht mit einer Reihe von Texturen. Im letzten Chrome trat ein Fehler auf, der besagte, dass dies mit einer Reihe von Texturen nicht m√∂glich war.  Mit einer Reihe von Zahlen hat es funktioniert.  Ratet mal, warum es mit einem Array funktioniert, aber nicht mit einem anderen?  Wenn Sie dachten, dass das Typgusssystem in JS voller Magie ist, sortieren Sie das System "Konstante - nicht Konstante" in GLSL aus.  Das Lustige ist, dass die Ergebnisse auch von der verwendeten Grafikkarte abh√§ngen, sodass die kniffligen Kr√ºcken, die auf der NVIDIA-Grafikkarte funktionierten, bei AMD sehr gut ausfallen k√∂nnen. </p><br><blockquote>  Es ist besser, solche Entscheidungen zu vermeiden, die auf Annahmen √ºber den Compiler beruhen.  Sie neigen dazu zu brechen und sind schwer zu testen. </blockquote><p>  Traurigkeit ist Traurigkeit.  Aber wenn wir interessante Dinge tun wollen, m√ºssen wir von all dem abstrahieren und weitermachen. </p><br><p>  Im Moment haben wir ein Mosaik von Fotos.  Aber es gibt ein Detail: Wenn die Punkte sehr nahe beieinander liegen, gibt es einen schnellen √úbergang von zwei Bereichen.  Es ist nicht sehr h√ºbsch.  Sie m√ºssen einen Algorithmus hinzuf√ºgen, der nicht zul√§sst, dass die Punkte nahe kommen.  Sie k√∂nnen eine einfache Option ausw√§hlen, bei der die Abst√§nde zwischen Punkten √ºberpr√ºft werden. Wenn sie unter einem bestimmten Wert liegen, schieben wir sie auseinander.  Diese Option ist nicht ohne Nachteile, insbesondere f√ºhrt sie manchmal zu einem leichten Zucken der Punkte, kann aber in vielen F√§llen ausreichen, zumal es hier nicht sehr viele Berechnungen gibt.  Fortgeschrittenere Optionen w√§ren ein System bewegter Ladungen und ein "Spinnennetz", in dem Punktpaare durch unsichtbare Federn verbunden sind.  Wenn Sie daran interessiert sind, sie zu implementieren, finden Sie leicht alle Formeln im Physik-Nachschlagewerk f√ºr die High School. </p><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let j = i; j &lt; NUMBER_OF_POINTS; j++) { let deltaX = POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] - POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; let deltaY = POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] - POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>]; let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) { POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaX); POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] += <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaY); POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] -= <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaX); POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] -= <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaY); } } }</code> </pre> <br><p>  Das Hauptproblem bei diesem und dem im Shader verwendeten Ansatz besteht darin, alle Punkte mit allen zu vergleichen.  Sie m√ºssen kein guter Mathematiker sein, um zu verstehen, dass die Anzahl der Entfernungsberechnungen unglaublich ist, wenn wir nicht 10 Punkte, sondern 1000 machen. Ja, sogar 100 reichen aus, damit sich alles verlangsamt.  Daher ist es sinnvoll, es nur f√ºr eine kleine Anzahl von Punkten anzuwenden. </p><br><p>  Wenn wir ein solches Mosaik f√ºr eine gro√üe Anzahl von Punkten erstellen m√∂chten, k√∂nnen wir die bekannte Unterteilung der Ebene in identische Quadrate verwenden.  Die Idee ist, einen Punkt in jedes Quadrat zu setzen und dann alle Vergleiche nur mit Punkten von benachbarten Quadraten durchzuf√ºhren.  Eine gute Idee, aber Experimente haben gezeigt, dass preiswerte Laptops mit integrierten Grafikkarten mit einer gro√üen Anzahl von Punkten immer noch nicht zurechtkommen.  Es lohnt sich daher, zehn Mal dar√ºber nachzudenken, bevor Sie sich entscheiden, aus einer gro√üen Anzahl von Fragmenten ein solches Mosaik auf Ihrer Website zu erstellen. </p><br><blockquote>  Seien Sie keine Radieschen, √ºberpr√ºfen Sie die Leistung Ihres Handwerks nicht nur auf Ihrem Bergbauernhof, sondern auch auf normalen Laptops.  Benutzer werden im Grunde diejenigen sein. </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/VGmEYN" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="razbienie-ploskosti-na-chasti-po-grafiku-funkcii">  Partitionieren einer Ebene gem√§√ü einem Funktionsgraphen </h2><br><p>  Sehen wir uns eine weitere Option zum Teilen einer Ebene in Teile an.  Es wird keine gro√üe Rechenleistung mehr ben√∂tigt.  Die Hauptidee ist, eine mathematische Funktion zu √ºbernehmen und ihren Graphen zu erstellen.  Die resultierende Linie teilt die Ebene nur in zwei Teile.  Wenn wir eine Funktion der Form <code>y = f(x)</code> , erhalten wir eine Division in Form eines Schnitts.  Wenn Sie X durch Y ersetzen, k√∂nnen Sie den horizontalen Abschnitt in vertikal √§ndern.  Wenn Sie die Funktion in Polarkoordinaten √ºbernehmen, m√ºssen Sie alles ins Kartesische √ºbersetzen und umgekehrt, aber das Wesentliche der Berechnungen √§ndert sich nicht.  In diesem Fall ist das Ergebnis kein Schnitt in zwei Teile, sondern ein Lochschnitt.  Aber wir werden die erste Option sehen. </p><br><p>  F√ºr jedes Y berechnen wir den Wert von X, um einen vertikalen Schnitt zu erstellen.  Wir k√∂nnten zum Beispiel eine Sinuswelle f√ºr diese Zwecke nehmen, aber es ist zu langweilig.  Es ist besser, ein paar St√ºcke auf einmal zu nehmen und sie zu falten. </p><br><p>  Wir nehmen mehrere Sinuskurven, von denen jede an eine Koordinate entlang Y und an die Zeit gebunden ist, und addieren sie.  Physiker w√ºrden diese Addition √úberlagerung nennen.  Wenn wir das gesamte Ergebnis mit einer Zahl multiplizieren, √§ndern wir nat√ºrlich die Amplitude.  Nehmen Sie es in einem separaten Makro heraus.  Wenn Sie die Koordinate - den Sinusparameter - multiplizieren, √§ndert sich die Frequenz.  Wir haben dies bereits in einem fr√ºheren Artikel gesehen.  Wir entfernen auch den Frequenzmodifikator, der allen Sinuskurven gemeinsam ist, aus der Formel.  Es ist nicht √ºberfl√ºssig, mit der Zeit zu spielen. Ein negatives Vorzeichen bewirkt, dass die Linie in die entgegengesetzte Richtung bewegt wird. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span> = u_time * SPEED; <span class="hljs-type"><span class="hljs-type">float</span></span> x = (sin(texture_coord.y * FREQUENCY) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">2.1</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">1.72</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">1.121</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">2.221</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">0.437</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">3.1122</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">4.269</span></span>)) * AMPLITUDE;</code> </pre> <br><p>  Nachdem wir solche globalen Einstellungen f√ºr unsere Funktion vorgenommen haben, werden wir vor dem Problem stehen, dieselbe Bewegung in relativ kurzen Intervallen zu wiederholen.  Um dieses Problem zu l√∂sen, m√ºssen wir alles mit Koeffizienten multiplizieren, f√ºr die das kleinste gemeinsame Vielfache sehr gro√ü ist.  √Ñhnliches wird auch im Zufallszahlengenerator verwendet, erinnerst du dich?  In diesem Fall haben wir nicht nachgedacht und vorgefertigte Zahlen aus einem Beispiel aus dem Internet genommen, aber niemand st√∂rt sich daran, mit unseren Werten zu experimentieren. </p><br><p>  Es bleibt nur eine der beiden Texturen f√ºr Punkte √ºber unserem Funktionsdiagramm und die zweite f√ºr Punkte darunter zu w√§hlen.  Genauer nach links und rechts drehten wir uns alle um: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (texture_coord.x - <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> &gt; x) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord); }</code> </pre> <br><p>  Was wir erhalten haben, √§hnelt Schallwellen.  Genauer gesagt, ihr Bild auf dem Oszilloskop.  In der Tat k√∂nnten wir anstelle unserer Sinuskurven Daten aus einer Art Audiodatei √ºbertragen.  Die Arbeit mit Ton ist jedoch ein Thema f√ºr einen separaten Artikel. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/VGmEeO" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="maski">  Masken </h2><br><p>  Die vorherigen Beispiele sollten zu einer ganz logischen Bemerkung f√ºhren: All dies sieht aus wie die Arbeit von Masken in SVG (wenn Sie nicht mit ihnen gearbeitet haben, lesen Sie Beispiele aus dem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SVG-Masken und Wow-Effekte</a> ).  Es ist nur so, dass wir sie hier etwas anders machen.  Und das Ergebnis ist das gleiche - einige Bereiche werden mit einer Textur √ºbermalt, andere mit einer anderen.  Nur reibungslose √úberg√§nge gab es noch nicht.  Also lass uns eins machen. </p><br><p>  Wir entfernen alle unn√∂tigen und geben die Koordinaten der Maus zur√ºck.  Erstellen Sie einen radialen Verlauf mit der Mitte an der Cursorposition und verwenden Sie ihn als Maske.  In diesem Beispiel √§hnelt das Shader-Verhalten der Logik von Masken in SVG st√§rker als in den vorherigen Beispielen.  Wir brauchen eine <code>mix</code> und eine Funktion der Distanz.  Der erste mischt die Pixelfarbwerte aus beiden Texturen und verwendet als dritten Parameter einen Koeffizienten (von 0 bis 1), der bestimmt, welcher der Werte als Ergebnis vorherrscht.  Wir nehmen den Sinusmodul als Funktion der Entfernung - er ergibt nur eine sanfte √Ñnderung des Wertes zwischen 0 und 1. </p><br><pre> <code class="hljs lisp">gl_FragColor = mix( <span class="hljs-name"><span class="hljs-name">texture2D</span></span>(<span class="hljs-name"><span class="hljs-name">u_textures</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord), texture2D(<span class="hljs-name"><span class="hljs-name">u_textures</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord), abs(<span class="hljs-name"><span class="hljs-name">sin</span></span>(<span class="hljs-name"><span class="hljs-name">length</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span> - u_mouse_position / u_canvas_size))))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Das ist alles  Schauen wir uns das Ergebnis an: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/bxBmwB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Der Hauptvorteil gegen√ºber SVG liegt auf der Hand: </p><br><blockquote>  Im Gegensatz zu SVG k√∂nnen wir hier leicht glatte Verl√§ufe f√ºr verschiedene mathematische Funktionen erstellen und diese nicht aus vielen linearen Verl√§ufen erfassen. </blockquote><p>  Wenn Sie eine einfachere Aufgabe haben, f√ºr die keine so reibungslosen √úberg√§nge oder komplexen Formulare erforderlich sind, die im Prozess berechnet werden, ist die Implementierung h√∂chstwahrscheinlich ohne die Verwendung von Shadern einfacher.  Ja, und die Leistung auf schwacher Hardware ist wahrscheinlich besser.  W√§hlen Sie ein Werkzeug basierend auf Ihren Aufgaben. </p><br><p>  Schauen wir uns zu Bildungszwecken ein anderes Beispiel an.  Erstellen Sie zun√§chst einen Kreis, in dem die Textur unver√§ndert bleibt: </p><br><pre> <code class="hljs objectivec">gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = distance(texture_coord, u_mouse_position / u_canvas_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dist &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  Und f√ºllen Sie den Rest mit diagonalen Streifen: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = sin((texture_coord.y - texture_coord.x) * <span class="hljs-number"><span class="hljs-number">200.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { gl_FragColor.rgb *= dist; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gl_FragColor.rgb *= dist / <span class="hljs-number"><span class="hljs-number">10.0</span></span>; }</code> </pre> <br><p>  Die Akzeptanzen sind die gleichen - wir multiplizieren den Parameter f√ºr den Sinus, um die Frequenz der Streifen zu erh√∂hen;  Teilen Sie die erhaltenen Werte in zwei Teile.  F√ºr jede der H√§lften transformieren wir die Farbe der Pixel auf unsere eigene Weise.  Es ist n√ºtzlich, sich daran zu erinnern, dass das Zeichnen diagonaler Linien normalerweise mit dem Hinzuf√ºgen von Koordinaten in X und Y verbunden ist. Beachten Sie, dass wir beim √Ñndern der Farben auch den Abstand zum Mauszeiger verwenden, um so eine Art Schatten zu erzeugen.  Auf die gleiche Weise k√∂nnen Sie es mit geometrischen Transformationen verwenden. Wir werden dies bald am Beispiel der Pixelierung sehen.  Schauen Sie sich in der Zwischenzeit das Ergebnis dieses Shaders an: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/rZWqyK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Einfach und h√ºbsch. </p><br><blockquote>  Und ja, wenn Sie ein wenig verwirrt sind, k√∂nnen Sie Texturen nicht aus Bildern, sondern aus Bildern erstellen (es gibt viele Beispiele im Netzwerk, Sie k√∂nnen sie leicht herausfinden) und alle unsere Effekte auf sie anwenden.  Viele Verzeichnisseiten wie Awwwards verwenden diese Effekte in Verbindung mit Video. </blockquote><p>  Es lohnt sich, sich an einen weiteren Gedanken zu erinnern: </p><br><blockquote>  Niemand st√∂rt es, eine der Texturen als Maske zu verwenden.  Wir k√∂nnen ein Bild aufnehmen und die Farbwerte seiner Pixel in unseren Transformationen verwenden, unabh√§ngig davon, ob es sich um √Ñnderungen in anderen Farben, Verschiebungen zu den Seiten oder etwas anderes handelt, das Ihnen in den Sinn kommt. </blockquote><p>  Aber zur√ºck zum Teilen des Flugzeugs in Teile. </p><br><h2 id="pikselizaciya">  Pixelisierung </h2><br><p>  Dieser Effekt ist etwas offensichtlich, aber gleichzeitig ist er so h√§ufig, dass es falsch w√§re, daran vorbeizukommen.  Teilen Sie unsere Ebene auf die gleiche Weise wie im Beispiel mit dem Rauschgenerator in Quadrate, und setzen Sie dann f√ºr alle Pixel in jedem Quadrat die gleiche Farbe.  Es wird durch Mischen von Werten aus den Ecken eines Quadrats erhalten, wir haben bereits etwas √Ñhnliches gemacht.  F√ºr diesen Effekt ben√∂tigen wir keine komplexen Formeln. Addieren Sie einfach alle Werte und dividieren Sie durch 4 - die Anzahl der Winkel des Quadrats. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> block_size = abs(sin(u_time)) / <span class="hljs-number"><span class="hljs-number">20.0</span></span>; vec2 block_position = floor(texture_coord / block_size) * block_size; gl_FragColor = ( texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>) * block_size) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * block_size) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * block_size) ) / <span class="hljs-number"><span class="hljs-number">4.0</span></span>;</code> </pre> <br><p>  Wir haben erneut einen der Parameter durch das Sinusmodul an die Zeit gebunden, um visuell zu sehen, was passiert, wenn es sich √§ndert. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/eLBPej" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="pikselnye-volny">  Pixelwellen </h2><br><p>            ,       . </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> block_size = abs(sin( length(texture_coord - u_mouse_position / u_canvas_size) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - u_time)) / <span class="hljs-number"><span class="hljs-number">100.0</span></span> + <span class="hljs-number"><span class="hljs-number">0.001</span></span>;</code> </pre> <br><p>   ,       0  1;        , ,    ,     .       ,      . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/EeNdEr" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>    "" ,              ,    -.     .       " ",     ,         .     .      ‚Äî  .       . </p><br><h2 id="itogi">  Zusammenfassung </h2><br><p>         ,     ,  ,    ,           .                    -.     -       -  .          .          .    ,      ,      ,      . </p><br><hr><br><p> <em>PS:  ,   WebGL (      )          ?     ,   ,   .          ?</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421821/">https://habr.com/ru/post/de421821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421809/index.html">Java EE Concurrency API</a></li>
<li><a href="../de421811/index.html">Die IETF hat einen neuen Standard f√ºr Messaging vorgeschlagen - was Sie wissen m√ºssen</a></li>
<li><a href="../de421815/index.html">Sechs Monate sp√§ter fl√ºssiges Metall in einem Laptop</a></li>
<li><a href="../de421817/index.html">Arbeiten mit Formularen in React.js mit grundlegenden Tools</a></li>
<li><a href="../de421819/index.html">ELK-Stapel zum Speichern von Django-Anwendungsprotokollen</a></li>
<li><a href="../de421823/index.html">Wie wir X-Ray x64 eingef√ºhrt haben</a></li>
<li><a href="../de421827/index.html">Was kann man jetzt √ºber Java lesen?</a></li>
<li><a href="../de421829/index.html">Frangos Anomalie - eine fantastische Romanze mit echten IT-Leuten</a></li>
<li><a href="../de421833/index.html">Wir schreiben unser einfachstes Programm f√ºr ARM Cortex-M3</a></li>
<li><a href="../de421835/index.html">Die Interagency Commission entwickelt neue Technologien zur Blockierung von Telegrammen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>