<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😣 🐲 👍🏿 Java插件轻松自如 🤘🏻 🎁 🛀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我想告诉您如何快速轻松地创建一个支持动态加载插件的Java应用程序框架。 读者可能会立即认为这样的任务已经解决了很长时间，您可以简单地使用现成的框架或编写您的类加载器，但是我建议的解决方案不需要这些： 



- 我们不需要特殊的库或框架（ OSGi ，Guice等） 
- 我们不会将字节...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java插件轻松自如</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479478/"> 在本文中，我想告诉您如何快速轻松地创建一个支持动态加载插件的Java应用程序框架。 读者可能会立即认为这样的任务已经解决了很长时间，您可以简单地使用现成的框架或编写您的类加载器，但是我建议的解决方案不需要这些： <br><br><ul><li> 我们不需要特殊的库或框架（ <a href="https://www.youtube.com/watch%3Fv%3DE3A6Z02TIjg">OSGi</a> ，Guice等） </li><li> 我们不会将字节码解析与ASM和类似的库一起使用。 </li><li> 我们不会编写我们的类加载器。 </li><li> 我们将不使用反射和注释。 </li><li> 无需大惊小怪的类路径来查找插件。 我们根本不会碰到类路径。 </li><li>另外，我们将不会使用XML，YAML或任何其他声明性语言来描述扩展点（插件中的扩展点）。 </li></ul><br> 但是，仍然有一个要求-这样的解决方案仅适用于Java 9或更高版本。 因为它将基于<a href="https://www.youtube.com/watch%3Fv%3DJ1fHBhFvmco">模块和服务</a> 。 <br><a name="habracut"></a><br> 因此，让我们开始吧。 我们更具体地提出问题： <br><blockquote>您需要实现一个最小的应用程序框架，该框架在启动时会从<code>plugins</code>文件夹加载用户插件。 </blockquote><br> 也就是说，组装后的应用程序应如下所示： <br><br><pre> <code class="bash hljs">plugin-app/ plugins/ plugin1.jar plugin2.jar ... core.jar …</code> </pre> <br> 让我们从<code>core</code>模块开始。 这个模块是我们应用程序的核心，实际上是我们的框架。 <br><br><div class="spoiler">  <b class="spoiler_title">对于那些珍惜时间的人，可以在GitHub上找到完成的项目。</b>  <b class="spoiler_title">组装说明。</b> <div class="spoiler_text">  <a href="https://github.com/orionll/plugin-app">友情链接</a> <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/orionll/plugin-app <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> plugin-app mvn verify <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> core/target java --module-path core-1.0-SNAPSHOT.jar --module core</code> </pre> </div></div><br> 在模块中创建以下4个Java文件： <br><br><pre> <code class="bash hljs">core/ src/main/java/ org/example/pluginapp/core/ IService.java BasicService.java Main.java module-info.java</code> </pre> <br> 第一个文件<code>IService.java</code>是描述我们的扩展点的文件。 然后，其他插件将能够为该扩展点做出贡献（“贡献”）。 这是构建插件应用程序的标准原理，称为<a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">依赖关系反转</a> （Dependency Inversion） <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">原理</a> 。 该原理基于以下事实：内核不依赖于特定的类，而是依赖于接口。 <br><br> 我给扩展点一个抽象名称<code>IService</code> ，因为我现在仅演示一个概念。 实际上，它可以是任何特定的扩展点，例如，如果您正在编写图形编辑器，则可以是图像处理的效果，例如<code>IEffectProvider</code> ， <code>IEffectContribution</code>或其他，这取决于您更喜欢如何命名扩展点。 同时，应用程序本身将包含一些基本的效果集，第三方开发人员将能够编写其他更复杂的效果并以插件形式提供。 用户只需要将这些效果放入<code>plugins</code>文件夹中，然后重新启动应用程序即可。 <br><br>  <code>IService.java</code>文件如下： <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;IService&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getServices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModuleLayer layer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ServiceLoader .load(layer, IService.class) .stream() .map(Provider::get) .collect(Collectors.toList()); } }</code> </pre> <br> 因此， <code>IService</code>只是做一些抽象的<code>doJob()</code>的接口（我再说一遍，细节并不重要，实际上这将是具体的）。 <br><br> 还要注意第二个<code>getServices()</code>方法。 此方法返回在此模块层及其父级中找到的<code>IService</code>接口的所有实现。 稍后我们将详细讨论。 <br><br> 第二个文件<code>BasicService.java</code>是<code>IService</code>接口的基本实现。 即使应用程序中没有插件，它也将始终存在。 换句话说， <code>core</code>不仅是核心，而且同时是一个插件，它将始终被加载。  <code>BasicService.java</code>文件如下所示： <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasicService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Basic service"</span></span>); } }</code> </pre> <br> 为简单起见， <code>doJob()</code>仅显示字符串<code>"Basic service"</code> ，仅此而已。 <br><br> 因此，目前我们有以下图片： <br><br><img src="https://habrastorage.org/webt/du/0f/fd/du0ffdkzy6bqmyc6rvqj6p-jw7w.png"><br><br> 第三个文件<code>Main.java</code>是<code>main()</code>方法的实现位置。 要了解哪些内容，您需要了解什么是模块层。 <br><br><h2> 关于模块层 </h2><br>  Java启动应用程序时，参数<code>--module-path</code> （以及<code>classpath</code> （如果有））中列出的所有平台模块+模块都位于所谓的<code>Boot</code>层中。 在我们的例子中，如果我们编译core.jar模块并从命令行运行<code>java --module-path core.jar --module core</code> ，那么至少<code>java.base</code>和<code>core</code>模块将位于<code>Boot</code>层： <br><br><img src="https://habrastorage.org/webt/z5/ar/n-/z5arn-jtfurxwqjja-fxrbdfjbu.png"><br><br>  <code>Boot</code>层始终存在于任何Java应用程序中，这是最小的配置。 大多数应用程序存在于模块的单个层中。 但是，在我们的情况下，我们想从<code>plugins</code>文件夹中动态加载<code>plugins</code> 。 我们可以强迫用户更正应用程序启动行，以便他自己将必需的插件添加到<code>--module-path</code> ，但这不是最佳解决方案。 尤其是那些不是程序员并且不了解为什么他们需要爬到某个地方并为这样简单的事情解决问题的人。 <br><br> 幸运的是，有一个解决方案：Java允许您在运行时创建自己的模块层，这将从我们需要的位置加载模块。 就我们的目的而言，一个新的插件层就足够了，它将有一个<code>Boot</code>层作为父层（任何一层都必须有一个父层）： <br><br><img src="https://habrastorage.org/webt/1-/yd/5i/1-yd5ikax42qfadybbu1uqbnkgo.png"><br><br> 插件层具有<code>Boot</code>层作为父层的事实意味着，插件层中的模块可以引用<code>Boot</code>层中的模块，反之亦然。 <br><br> 因此，现在知道什么是模块层，您终于可以看一下<code>Main.java</code>文件的内容： <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Path pluginsDir = Paths.get(<span class="hljs-string"><span class="hljs-string">"plugins"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      plugins ModuleFinder pluginsFinder = ModuleFinder.of(pluginsDir); //  ModuleFinder      plugins       List&lt;String&gt; plugins = pluginsFinder .findAll() .stream() .map(ModuleReference::descriptor) .map(ModuleDescriptor::name) .collect(Collectors.toList()); //  ,      (   ) Configuration pluginsConfiguration = ModuleLayer .boot() .configuration() .resolve(pluginsFinder, ModuleFinder.of(), plugins); //      ModuleLayer layer = ModuleLayer .boot() .defineModulesWithOneLoader(pluginsConfiguration, ClassLoader.getSystemClassLoader()); //     IService       Boot List&lt;IService&gt; services = IService.getServices(layer); for (IService service : services) { service.doJob(); } } }</span></span></code> </pre> <br> 如果这是您第一次查看此代码，它可能看起来很复杂，但是由于存在大量新的未知类，因此这是一种错误的感觉。 如果您对<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/ModuleFinder.html">ModuleFinder</a> ， <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/Configuration.html">Configuration</a>和<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ModuleLayer.html">ModuleLayer类</a>的含义有所了解，那么一切都准备就绪。 而且，只有几十行！ 这就是一次编写的所有逻辑。 <br><br><h2> 模块描述符 </h2><br> 还有一个我们没有考虑的文件（第四个）： <code>module-info.java</code> 。 这是最短的文件，包含我们模块的声明和服务描述（扩展点）： <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> core { <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> org.example.pluginapp.core; uses IService; provides IService with BasicService; }</code> </pre> <br> 该文件各行的含义应该很明显： <br><br><ul><li> 首先，该模块导出<code>org.example.pluginapp.core</code>包， <code>org.example.pluginapp.core</code>插件可以从<code>IService</code>接口继承（否则，在<code>core</code>模块外部将无法访问<code>IService</code> ）。 </li><li> 其次，他宣布他正在使用<code>IService</code> 。 </li><li> 第三，他说他通过<code>BasicService</code>类提供了<code>IService</code>服务的<code>BasicService</code> 。 </li></ul><br> 由于模块声明是用Java编写的，因此我们获得了非常重要的优势： <i>编译器检查和静态保证</i> 。 例如，如果我们在类型名称上输入错误或指示不存在的程序包，我们将立即得到它。 对于某些OSGi，由于扩展点的声明将以XML编写，因此在编译时我们不会进行任何检查。 <br><br> 因此，框架已准备就绪。 让我们尝试运行它： <br><br><pre> <code class="bash hljs">&gt; java --module-path core.jar --module core Basic service</code> </pre> <br> 发生什么事了 <br><br><ol><li>  Java尝试在<code>plugins</code>文件夹中找到模块，但未找到任何模块。 </li><li> 空层已创建。 </li><li>  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html">ServiceLoader</a>开始搜索所有<code>IService</code>实现。 </li><li> 在空层中，他没有找到任何服务实现，因为那里没有模块。 </li><li> 在这一层之后，他继续在父层（即<code>Boot</code>层）中搜索，并在<code>core</code>模块中找到<code>BasicService</code>一种实现。 </li><li> 找到的所有实现都调用了<code>doJob()</code>方法。 由于仅找到一种实现，因此仅打印<code>"Basic service"</code> 。 </li></ol><br><h2> 编写插件 </h2><br> 编写了应用程序的核心之后，现在该尝试为其编写插件了。 让我们编写两个插件<code>plugin1</code>和<code>plugin2</code> ：让第一个打印<code>"Service 1"</code> ，第二个打印<code>"Service 2"</code> 。 为此，您需要分别在<code>plugin1</code>和<code>plugin2</code>提供两个<code>IService</code>实现： <br><br><img src="https://habrastorage.org/webt/-o/3n/4v/-o3n4vlwhx-vwqxn7jpkunlamjq.png"><br><br> 用两个文件创建第一个插件： <br><br><pre> <code class="bash hljs">plugin1/ src/main/java/ org/example/pluginapp/plugin1/ Service1.java module-info.java</code> </pre> <br>  <code>Service1.java</code>文件： <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Service 1"</span></span>); } }</code> </pre> <br>  <code>module-info.java</code>文件： <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> plugin1 { <span class="hljs-keyword"><span class="hljs-keyword">requires</span></span> core; provides IService with Service1; }</code> </pre> <br> 请注意， <code>plugin1</code>是<code>core</code>相关的。 这就是我之前提到的依赖关系反转原理：内核不依赖于插件，反之亦然。 <br><br> 第二个插件与第一个插件完全相似，因此在此不再赘述。 <br><br> 现在，让我们收集插件，将其放入<code>plugins</code>文件夹中并运行应用程序： <br><br><pre> <code class="bash hljs">&gt; java --module-path core.jar --module core Service 1 Service 2 Basic service</code> </pre> <br> 万岁，插件被选中！ 这是怎么发生的： <br><br><ol><li>  Java在<code>plugins</code>文件夹中找到了两个模块。 </li><li> 使用两个模块<code>plugins1</code>和<code>plugins2</code>创建了一个层。 </li><li>  ServiceLoader开始搜索所有<code>IService</code>实现。 </li><li> 在插件层，他找到了<code>IService</code>服务的两个实现。 </li><li> 之后，他继续在父层（即<code>Boot</code>层）中搜索，并在<code>core</code>模块中找到<code>BasicService</code>一种实现。 </li><li> 找到的所有实现都调用了<code>doJob()</code>方法。 </li></ol><br> 请注意，正是因为对服务提供者的搜索从子层开始，然后到父层，所以先打印<code>"Service 1"</code>和<code>"Service 2"</code> ，然后打印<code>"Basic Service"</code> 。 如果您希望对服务进行排序，以便先对基本服务进行排序，然后对插件进行排序，则可以通过添加排序来调整<code>IService.getServices()</code>方法（您可能需要向<code>IService</code>接口添加<code>int getOrdering()</code>方法）。 <br><br><h2> 总结 </h2><br> 因此，我展示了如何快速有效地组织具有以下属性的插件Java应用程序： <br><br><ul><li>  <b>简便性：</b>对于扩展点及其绑定，仅使用基本的Java功能（接口，类和<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html">ServiceLoader</a> ），而没有框架，反射，注释和类加载器。 </li><li>  <b>可声明性：</b>扩展点在模块描述符中描述。 只需查看<code>module-info.java</code>并了解存在哪些扩展点以及哪些插件有助于这些点。 </li><li>  <b>静态保证：</b>如果模块描述符中的错误，程序将无法编译。 另外，作为奖励，如果您使用IntelliJ IDEA，则会收到其他警告（例如，如果您忘记<code>uses</code>并使用<code>ServiceLoader.load()</code> ）。 </li><li>  <b>安全性：</b>模块化Java系统在启动时检查模块的配置是否正确，并在出现错误的情况下拒绝执行程序。 </li></ul><br> 我再说一次，我只展示了这个主意。 在实际的插件应用程序中，将有数十至数百个模块和数百至数千个扩展点。 <br><br> 我之所以决定提出这个主题，是因为在过去的7年中，我一直在使用Eclipse RCP编写模块化应用程序，其中臭名昭著的OSGi用作插件系统，并且插件描述符用XML编写。 我们有一百多个插件，我们仍然使用Java8。但是，即使我们切换到新版本的Java，我们也不大可能使用Java模块，因为它们与OSGi紧密相关。 <br><br> 但是，如果您是从头开始编写插件应用程序，那么Java模块是其实现的可能选择之一。 请记住，模块只是工具，而不是目标。 <br><br><h2> 简要介绍一下我 </h2><br> 我已经编程了10多年（其中有8年使用Java），我对<a href="https://stackoverflow.com/users/706317/zhekakozlov">StackOverflow</a>做出了回应，并<a href="https://t.me/miniJUG">在Telegram中</a>运行了自己的专门用于Java的<a href="https://t.me/miniJUG">频道</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN479478/">https://habr.com/ru/post/zh-CN479478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN479462/index.html">C ++中的序列化</a></li>
<li><a href="../zh-CN479464/index.html">管道和过滤器。 使用Spring的示例应用程序和实现</a></li>
<li><a href="../zh-CN479466/index.html">Habraiting 2019：2019年最佳文章的统计数据和排名</a></li>
<li><a href="../zh-CN479468/index.html">诚实的边缘和约翰·杜</a></li>
<li><a href="../zh-CN479474/index.html">为什么团队的自组织在Scrum中如此重要，为什么其中没有经理</a></li>
<li><a href="../zh-CN479480/index.html">SARIF SDK及其错误</a></li>
<li><a href="../zh-CN479482/index.html">SARIF SDK及其错误</a></li>
<li><a href="../zh-CN479486/index.html">异构编程和oneAPI工具包。 英特尔专家即兴演讲回答您的问题</a></li>
<li><a href="../zh-CN479488/index.html">从笔记本电脑-具有冗余电源的家庭服务器到Mikrotik路由器</a></li>
<li><a href="../zh-CN479492/index.html">基于OpenWhisk的无服务器计算，第3部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>