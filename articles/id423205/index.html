<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§“ğŸ¿ ğŸ§¡ ğŸ‘¨ğŸ»â€âš–ï¸ Proyek penyimpanan pada MS SQL Server, integrasi dengan 1C 7.7 dan otomatisasi pengembangan dalam SSDT ğŸ‘ğŸ¿ ğŸˆ¸ â­•ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Waktu hampir habis dan segera akan hampir tidak ada yang tersisa dari perkembangan ini, tetapi saya masih tidak punya waktu untuk menggambarkannya. 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proyek penyimpanan pada MS SQL Server, integrasi dengan 1C 7.7 dan otomatisasi pengembangan dalam SSDT</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423205/">  Waktu hampir habis dan segera akan hampir tidak ada yang tersisa dari perkembangan ini, tetapi saya masih tidak punya waktu untuk menggambarkannya. <br><br><img src="https://habrastorage.org/webt/fi/5s/if/fi5siftwc5fvceqqsjgxfnqubum.png"><br><br>  Ini akan menjadi tentang perusahaan di tingkat federal dengan sejumlah besar cabang dan cabang pembantu.  Tapi, seperti biasa, semuanya dimulai sejak dulu dengan satu toko kecil.  Selama bertahun-tahun, perkembangan yang cukup cepat dan spontan terjadi, cabang, divisi dan kantor lainnya muncul, dan infrastruktur TI tidak mendapat perhatian pada masa itu, dan ini juga sering terjadi.  Tentu saja, 1C77 digunakan di mana-mana, tanpa cadangan untuk replikasi dan penskalaan, oleh karena itu, Anda tahu, pada akhirnya kami sampai pada kesimpulan bahwa Sprut-Frankenstein dihasilkan dengan tentakel yang diikat dengan pita listrik - di setiap cabang ada mutan otonom yang ditukar dengan basis pusat dalam mode "setinggi lutut", hanya beberapa buku referensi, yang tanpanya, yah, itu tidak mungkin sama sekali, dan sisanya adalah otonom.  Untuk beberapa waktu mereka puas dengan salinan (lusinan dari mereka!) Dari kantor cabang di kantor pusat, tetapi data di dalamnya tertinggal selama beberapa hari. <br><br>  Kenyataannya, bagaimanapun, memerlukan memperoleh informasi lebih cepat dan fleksibel, dan sesuatu yang lain harus dilakukan dengan ini.  Perpindahan dari satu sistem akuntansi ke sistem akuntansi lainnya dalam skala seperti itu masih merupakan rawa.  Oleh karena itu, diputuskan untuk membuat data warehouse (DX), di mana informasi akan mengalir dari database yang berbeda, sehingga nantinya layanan lain dan sistem analitik dalam bentuk kubus, laporan SSR, dan kebocoran dapat menerima data dari CD ini. <br><br>  Ke depan, saya akan mengatakan bahwa transisi ke sistem akuntansi baru hampir terjadi dan sebagian besar proyek yang dijelaskan di sini akan dipotong dalam waktu dekat sebagai tidak perlu.  Maaf, tentu saja, tetapi tidak ada yang bisa dilakukan. <br><br>  Berikut ini adalah artikel yang panjang, tetapi sebelum Anda mulai membaca, izinkan saya mencatat bahwa dalam kasus apa pun saya tidak lulus keputusan ini sebagai standar, tetapi mungkin seseorang akan menemukan sesuatu yang berguna di dalamnya. <br><a name="habracut"></a><br>  Saya akan mulai dengan pendekatan umum untuk proyek, yang mana SSDT dipilih sebagai lingkungan pengembangan, dengan publikasi proyek selanjutnya di Git.  Saya pikir hari ini ada cukup banyak artikel dan tutorial yang menggambarkan kekuatan alat ini.  Tetapi ada beberapa poin yang masalahnya terletak di luar lingkungan ini. <br><br><h4>  Penyimpanan enumerasi dan versi database </h4><br>  Mengenai versi dan enumerasi, persyaratan untuk proyek berarti: <br><br><ul><li>  Kemudahan mengedit dan melacak perubahan dalam versi database dalam proyek </li><li>  Kenyamanan melihat versi database melalui SSMS untuk admin </li><li>  Menyimpan riwayat perubahan versi dalam database itu sendiri (siapa dan kapan penyebarannya) </li><li>  Menyimpan enumerasi dalam suatu proyek </li><li>  Kemudahan mengedit dan melacak perubahan dalam transfer </li><li>  Kunci penyebaran basis data di atas yang sudah ada jika tidak ada versi kenaikan </li><li>  Memasang versi baru, mencatat riwayat, transfer, dan restrukturisasi harus dilakukan dalam satu transaksi dan sepenuhnya dibatalkan jika terjadi kegagalan pada tahap apa pun </li></ul><br>  Karena  transfer sering mengandung logika dan merupakan nilai dasar, yang tanpanya menambahkan catatan ke tabel lain menjadi tidak mungkin (karena kunci asing FK), pada dasarnya mereka adalah bagian dari struktur database, bersama dengan metadata.  Oleh karena itu, perubahan dalam setiap elemen enumerasi mengarah ke peningkatan versi database dan, bersama dengan versi ini, catatan harus dijamin akan diperbarui selama penyebaran. <br><br>  Saya pikir semua keuntungan dari memblokir penyebaran tanpa menambah versi jelas, salah satunya adalah ketidakmampuan untuk menjalankan kembali skrip publikasi jika sudah berhasil dieksekusi sebelumnya. <br><br>  Meskipun jaringan database sering diusulkan untuk hanya menggunakan versi utama (tanpa fraksi), kami memutuskan untuk menggunakan versi dalam format XY, di mana Y adalah tambalan ketika salah ketik dikoreksi dalam deskripsi tabel, kolom, nama elemen daftar, atau sesuatu yang kecil, seperti menambahkan komentar ke prosedur tersimpan, dll.  Dalam semua kasus lain, versi utama menumpuk. <br><br>  Mungkin bagi seseorang tidak ada yang <i>seperti itu</i> dan semuanya jelas.  Tapi saya, pada waktunya, mengambil cukup banyak keberanian dan energi pada perselisihan internal tentang bagaimana menyimpan transfer dalam proyek database, sehingga itu adalah feng shui ( <i>sesuai dengan ide saya tentang itu</i> ) dan bahwa nyaman untuk bekerja dengan mereka, sambil meminimalkan kemungkinan kesalahan. <br><br>  Dengan transfer, secara umum, semuanya sederhana - kami membuat file PostDeploy di proyek dan menulis kode di dalamnya untuk mengisi tabel.  Dengan penggabungan atau trankat - ini adalah bagaimana Anda menyukainya.  Kami lebih suka berkedip, memeriksa dulu apakah jumlah catatan dalam tabel target melebihi jumlah catatan yang ada di sumber (proyek).  Jika melebihi, maka pengecualian dilemparkan untuk menarik perhatian padanya, karena itu aneh.  Mengapa ada lebih sedikit catatan di sumbernya?  Karena seseorang tidak berguna?  Kenapa tiba-tiba?  Dan jika database sudah memiliki tautan ke sana?  Meskipun kami menggunakan kunci asing (FK), yang tidak akan memungkinkan Anda untuk menghapus catatan, jika ada tautan ke sana, kami masih memilih untuk meninggalkan opsi ini.  Akibatnya, PostDeploy berubah menjadi lembar yang tidak dapat dibaca, karena untuk setiap tabel yang akan diisi, selain nilai-nilai itu sendiri, ada juga kode verifikasi, gabungan, dan sebagainya. <br><br>  Namun, jika Anda menggunakan PostDeploy dalam mode SQLCMD, menjadi mungkin untuk mengekstrak blok kode ke file yang terpisah, sebagai hasilnya, hanya daftar nama file terstruktur yang tersisa untuk mengisi enumerasi di PostDeploy. <br><br>  Ada beberapa nuansa dengan versi database.  Internet telah lama berdebat tentang di mana menyimpan versi database, seperti apa tampilannya, dan secara umum, apakah perlu disimpan di suatu tempat?  Misalkan kita memutuskan bahwa kita membutuhkannya, di mana proyek menyimpannya?  Di suatu tempat di belantara skrip PostDeploy, atau letakkan di variabel yang dideklarasikan di baris pertama skrip? <br><br>  Menurut pendapat saya, tidak satu atau yang lain.  Lebih nyaman bila disimpan dalam file terpisah dan tidak ada lagi di sana. <br><br>  Seseorang akan berkata - ada dacpac di properti proyek dan Anda dapat mengatur versi di dalamnya.  Tentu saja, Anda bahkan dapat menarik versi ini ke dalam skrip Anda, seperti dijelaskan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , tetapi ini merepotkan - untuk mengubah versi database, Anda harus pergi ke suatu tempat yang jauh, klik banyak tombol.  Saya tidak mengerti logika Microsoft - mereka menyembunyikannya di sudut yang jauh, bersama dengan parameter basis data seperti pengurutan, tingkat kompatibilitas, dll., Karena versi basis data berubah "sering" sebagai parameter pengurutan, bukan?  Ketika ada pengembangan konstan, versi dibangun dengan setiap penyebaran baru, well, kenyamanan pelacakan perubahan juga memainkan peran penting, karena ketika file yang diubah dengan nama yang ramah menyala, ini adalah satu hal, dan ketika file proyek .sqlproj menyala, di mana ada banyak baris dalam format XML , dan di antara mereka di suatu tempat di tengah garis satu digit yang diubah disorot, entah bagaimana tidak terlalu. <br><br><img src="https://habrastorage.org/webt/bg/i3/48/bgi3485rgezdefuaami2weappqy.png"><br><br>  Itu lebih baik <br><br><img src="https://habrastorage.org/webt/ro/9y/ld/ro9yldaaeoqcmubpi42adq-so50.png"><br><br>  Namun, mungkin ini hanya kecoak saya dan Anda tidak harus memperhatikannya. <br><br>  Sekarang pertanyaannya adalah: di mana menyimpan versi ini sudah dalam database yang digunakan.  Sekali lagi, tampaknya dacpac melakukannya dengan indah - ia menulis segalanya ke pelat sistem, tetapi untuk melihat versinya, Anda perlu menjalankan permintaan (atau bisakah sebaliknya, tetapi saya tidak tahu cara memasaknya? Tampaknya di versi SSMS yang lebih lama ada antarmuka untuk ini, dan sekarang tidak) <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> msdb.dbo.sysdac_instances_internal</code> </pre> <br>  untuk administrator (dan tidak hanya) sangat tidak nyaman.  Jauh lebih logis bahwa versi tersebut akan ditampilkan secara langsung di properti dari database itu sendiri. <br><br><img src="https://habrastorage.org/webt/ed/ax/le/edaxle3ic1lfwvaeuhhhphmrulo.png"><br><br>  Atau tidak? <br><br>  Untuk melakukan ini, Anda perlu menambahkan file ke proyek, termasuk dalam build, yang menggambarkan properti tingkat lanjut <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_addextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DeployerName'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; GO <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_addextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DeploymentDate'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; GO <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_addextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DBVersion'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>;</code> </pre> <br>  Ya, mereka kosong, dan terlihat jelek dalam skrip publikasi, tetapi Anda tidak dapat melakukannya tanpa mereka.  Jika mereka tidak dijelaskan dalam proyek, dan mereka akan berada di database, maka studio akan mencoba untuk menghapusnya setiap kali dikerahkan.  (Ada banyak upaya untuk menyiasati hal ini secara ringkas dan tanpa opsi penyebaran yang tidak perlu, tetapi tidak berhasil) <br><br>  Kami akan menetapkan nilai untuknya dalam skrip PostDeploy. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> @username <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>) = suser_sname() ,@curdatetime <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">getdate</span></span>(),<span class="hljs-string"><span class="hljs-string">'dd.MM.yyyy HH:mm:ss'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_updateextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DeployerName'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = @username; <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_updateextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DBVersion'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = [$(DBVersion)]; <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_updateextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DeploymentDate'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = @curdatetime;</code> </pre> <br>  <code>sp_updateextendedproperty</code> tanpa pemeriksaan apa pun, karena pada saat blok dimulai dari PostDeploy, semua properti sudah dibuat jika tidak ada di sana. <br><br>  Yah, akan menyenangkan untuk menyimpan sejarah, tentang siapa dan kapan menyebarkan database. <br><br>  Penerapan perubahan metadata dapat dilakukan dalam transaksi menggunakan alat standar dengan mencentang kotak <b>Aktifkan skrip transaksi</b> di jendela <b>Opsi penerbitan lanjutan</b> .  Tetapi flag ini tidak mempengaruhi penyebaran skrip (Pra / Pasca) dan mereka terus berjalan tanpa transaksi.  Tentu saja, tidak ada yang mencegah transaksi dimulai pada awal skrip PostDeploy, tetapi itu akan menjadi transaksi yang terpisah dari metadata, dan kami memiliki tugas untuk mengembalikan perubahan metadata jika pengecualian terjadi di PostDeploy. <br><br>  Solusinya sederhana - mulai transaksi di PreDeploy, dan komit di PostDeploy, dan jangan gunakan tanda centang apa pun dalam pengaturan publikasi untuk tujuan ini. <br><br>  Untuk menyimpan versi database dalam proyek dan mendaftarkannya di tempat yang diinginkan selama penerapan, Anda dapat menggunakan variabel SQLCMD.  Namun, saya tidak ingin menyimpan versi di suatu tempat di belantara kode, saya ingin itu ada di permukaan. <br><br><img src="https://habrastorage.org/webt/yg/qm/o9/ygqmo9wf5pnwnyx7kfnumsflps8.png"><br><br>  Untuk menempatkan versi database dalam file terpisah dan mengelola versi dari sana di tingkat proyek, kami menambahkan blok berikut ke .sqlproj: <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Target</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"BeforeBuild"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ReadLinesFromFile</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">File</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$(ProjectDir)\Properties\DBVersion"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Output</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TaskParameter</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Lines"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">PropertyName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ExtDBVersion"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ReadLinesFromFile</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">WriteLinesToFile</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">File</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$(ProjectDir)\\SetPreDepVarsTmp.sql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Lines</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">":setvar DBVersion $(ExtDBVersion)"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Overwrite</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Target</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Target</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Ini adalah instruksi untuk MSBuild untuk membaca baris dari file sebelum membangun dan membuat file sementara berdasarkan data yang dibaca.  MSBuild akan membuat file <code>SetPreDepVarsTmp.sql</code> sementara, yang akan <code>:setvar DBVersion $(ExtDBVersion)</code> baris <code>:setvar DBVersion $(ExtDBVersion)</code> , di mana <code>$(ExtDBVersion)</code> adalah nilai yang dibaca dari file kami yang menyimpan versi database. <br><br>  Setelah manipulasi seperti itu, Anda dapat merujuk ke file sementara ini dari skrip PreDeploy dan memulai transaksi global di dalamnya: <br><br><pre> <code class="sql hljs">:r .\SetPreDepVarsTmp.sql go :r ".\BeginTransaction.sql"</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Versi menengah</b> <div class="spoiler_text">  Awalnya, file ExtendedProperties.sql diberikan bukan nilai kosong, tetapi nilai dari variabel <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_addextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DeployerName'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = [$(DeployerName)]; GO <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_addextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DeploymentDate'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = [$(DeploymentDate)]; GO <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_addextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DBVersion'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = [$(DBVersion)];</code> </pre> <br>  Variabel, pada gilirannya, didaftarkan dalam file SetPreDepVarsTmp.sql secara otomatis oleh MSBuild seperti ini: <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">CurrentDateTime</span></span></span><span class="hljs-tag">&gt;</span></span>$([System.DateTime]::Now.ToString(dd.MM.yyyy HH:mm:ss))<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">CurrentDateTime</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">NewLine</span></span></span><span class="hljs-tag">&gt;</span></span> -- <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">NewLine</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Target</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"BeforeBuild"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ReadLinesFromFile</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">File</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$(ProjectDir)\DBVersion"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Output</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TaskParameter</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Lines"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">PropertyName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ExtDBVersion"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ReadLinesFromFile</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">WriteLinesToFile</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">File</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$(ProjectDir)\SetPreDepVarsTmp.sql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Lines</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">":setvar DBVersion $(ExtDBVersion)$(NewLine):setvar DeploymentDate "</span></span></span><span class="hljs-tag">$(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">CurrentDateTime</span></span></span><span class="hljs-tag">)"$(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">NewLine</span></span></span><span class="hljs-tag">)</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">:setvar</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">DeploymentUser</span></span></span><span class="hljs-tag"> $(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">UserDomain</span></span></span><span class="hljs-tag">)\$(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">UserName</span></span></span><span class="hljs-tag">)" </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Overwrite</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Target</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Dengan pendekatan ini, Anda tidak perlu menginstal ulang properti ini di PostDeploy, tetapi masalahnya adalah bahwa SetPreDepVarsTmp.sql berisi nilai statis dan jika skrip publikasi dibuat sekarang, tetapi digunakan dalam satu jam, atau, lebih buruk lagi, pada hari berikutnya (pengembang memeriksanya untuk waktu yang lama) misalnya secara visual), tanggal publikasi yang ditentukan dalam properti akan berbeda dari tanggal publikasi aktual dan tidak sesuai dengan tanggal dalam sejarah. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Isi file BeginTransaction.sql</b> <div class="spoiler_text">  Pada dasarnya, ini hanya salin-tempel dari blok awal transaksi standar yang dihasilkan oleh studio ketika kotak centang <b>Aktifkan skrip transaksi dipilih</b> , tetapi kami menggunakannya dengan cara kami sendiri.  Dalam skrip, hanya nama tabel sementara yang telah diubah dari <code>#tmpErrors</code> menjadi <code>#tmpErrorsManual</code> sehingga tidak ada konflik nama jika seseorang mengaktifkan kotak centang. <br><br><pre> <code class="sql hljs">IF (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> OBJECT_ID(<span class="hljs-string"><span class="hljs-string">'tempdb..#tmpErrors'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpErrorsManual GO CREATE TABLE #tmpErrorsManual (Error int) GO SET XACT_ABORT ON GO SET TRANSACTION ISOLATION LEVEL READ COMMITTED GO BEGIN TRANSACTION GO</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Script PostDeploy</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> @TableName <span class="hljs-built_in"><span class="hljs-built_in">VarChar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-comment"><span class="hljs-comment">--        if $(SkipEnumDeploy) = 0 begin PRINT N' ...' :r ..\\EnumTable1.sql end --   PRINT N'  ...'; declare @username varchar(256) = suser_sname() , @curdatetime varchar(20) = format(getdate(),'dd.MM.yyyy HH:mm:ss') if $(DBVersion) &gt; (select isnull( MAX( DBVersion),0) from zDBVersionHistory) begin insert into zDBVersionHistory( DBVersion, DeploymentDate, DeployerName) values ($(DBVersion),@curdatetime,@username) EXECUTE sp_updateextendedproperty @name = N'DeployerName', @value = @username; EXECUTE sp_updateextendedproperty @name = N'DBVersion', @value = [$(DBVersion)]; EXECUTE sp_updateextendedproperty @name = N'DeploymentDate', @value = @curdatetime; end else begin RaisError ( N':          ,  .      ,        DBVersion          .' , 16 , 1 ) WITH SETERROR; end GO :r ".\CaptureTransactionError.sql" :r ".\CommitTransaction.sql"</span></span></code> </pre> <br>  Variabel SkipEnumDeploy, seperti yang telah menjadi jelas, memungkinkan Anda untuk melewati tahap memperbarui daftar, ini dapat berguna untuk perubahan kosmetik kecil.  Meskipun, dari sudut pandang agama, ini mungkin tidak benar, namun, itu pasti berguna pada tahap pengembangan. <br></div></div><br>  File <code>CaptureTransactionError.sql</code> dan <code>CommitTransaction.sql</code> juga <code>CommitTransaction.sql</code> salin-tempel (dengan koreksi kecil) dari algoritma transaksi standar yang dihasilkan oleh studio ketika flag di atas diatur, dan yang sekarang kami mainkan sendiri. <br><br><div class="spoiler">  <b class="spoiler_title">Content CaptureTransactionError.sql</b> <div class="spoiler_text"><pre> <code class="sql hljs">IF @@ERROR &lt;&gt; 0 AND @@TRANCOUNT &gt; 0 <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @@TRANCOUNT = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpErrorsManual (Error) VALUES (1); BEGIN TRANSACTION; END</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Konten CommitTransaction.sql</b> <div class="spoiler_text"><pre> <code class="sql hljs">IF EXISTS (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpErrorsManual) ROLLBACK TRANSACTION GO DROP TABLE #tmpErrorsManual GO IF @@TRANCOUNT&gt;0 BEGIN PRINT N'     .' COMMIT TRANSACTION END ELSE RaisError ( N'    .' , 16 , 1 );</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konten EnumTable1.sql</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span> @TableName = N<span class="hljs-string"><span class="hljs-string">'Table1'</span></span> PRINT N<span class="hljs-string"><span class="hljs-string">'  '</span></span>+@TableName+<span class="hljs-string"><span class="hljs-string">'...'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> try <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> nocount <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpEnums; select * into #tmpEnums from (values ( 0, ' 1') , ( 1, ' 2') , ( 2, ' 3') ) as tmp ( Id , Title ) set nocount off --         If ((select count(*) from Table1) &gt; (select count(*) from #tmpEnums)) begin RaisError ( N':      ,   .' , 0 , 1 ) WITH SETERROR; end set Identity_insert Table1 on Merge Table1 as target Using ( select * from #tmpEnums except select * from dbo.Table1 ) as source on target.Id = source.Id when matched then update set target.Title = source.Title when not matched by target then insert ( Id , Title ) values ( source.Id , source.Title ); set Identity_insert Table1 off drop table if exists #tmpEnums; END TRY begin catch IF @@trancount &gt; 0 ROLLBACK TRANSACTION set @Error_Message = Error_Message(); RaisError ( N': %s.' , 0 , 1 , @Error_Message ) WITH SETERROR; end catch :r "..\\CaptureTransactionError.sql"</span></span></code> </pre> <br></div></div><br>  Saat menggunakan <code>Publish</code> skrip akan memiliki struktur berikut <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- PreDeploy ----:setvar DBVersion "10.6" --   ,     DBVersion ----   --    ,           -- PostDeploy ----  ----   ----  </span></span></code> </pre> <br><br>  Idealnya, tentu saja, saya ingin versi ditampilkan pada saat publikasi <br><img src="https://habrastorage.org/webt/8a/9w/o2/8a9wo2o5lemfglm1ru1kt5yntdm.png"><br><br>  Tetapi Anda tidak dapat menarik nilai dari file ke jendela ini, meskipun MSBuild membacanya dan memasukkannya ke properti ExtDBVersion dengan bantuan instruksi tambahan dalam file .sqlproj, seperti pada contoh di atas, tetapi konstruksinya <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SqlCmdVariable</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"DBVersion"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DefaultValue</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DefaultValue</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Value</span></span></span><span class="hljs-tag">&gt;</span></span>$(ExtDBVersion)<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SqlCmdVariable</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  tidak menggulung. <br><br>  Pengembang sekuel di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku harian web</a> mereka menulis bagaimana ini dilakukan.  Menurut versi mereka, keajaiban terletak pada instruksi <code>SqlCommandVariableOverride</code> , yang sederhana - tambahkan beberapa baris ke file proyek .sqlproj <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SqlCommandVariableOverride</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"DBVersion=$(ExtDBVersion)"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  dan dilakukan.  Usaha yang bagus, tetapi tidak.  Mungkin ketika posting blog ini diterbitkan, semuanya bekerja, tetapi sejak itu di Amerika ini Anda telah melakukan tiga pemilihan presiden dan tidak ada yang tahu instruksi apa yang mungkin berhenti bekerja besok. <br><br><img src="https://habrastorage.org/webt/xv/d9/li/xvd9liiwyjicnv5icr9d1utjnxs.jpeg"><br><br>  Dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> seorang kawan mencoba semua opsi, tetapi tidak ada yang lepas landas. <br><br>  Karena itu, ambil versi dari dacpac, atau simpan di PostDeploy, atau dalam file terpisah, atau _________ (masukkan versi Anda). <br><br><h4>  Integrasi dengan 1C </h4><br>  Masalah pertama adalah bahwa 1C77 tidak memiliki server aplikasi atau daemon lain yang memungkinkannya berinteraksi dengannya tanpa meluncurkan platform.  Mereka yang bekerja dengan 1C77 tahu bahwa dia tidak memiliki mode konsol penuh.  Anda dapat menjalankan platform dengan parameter dan bahkan melakukan sesuatu berdasarkan pada mereka, tetapi ada beberapa parameter konsol dan tujuannya berbeda.  Tetapi bahkan dengan bantuan mereka, Anda dapat nakolkhozit keseluruhan.  Namun, ia dapat terbang keluar secara tidak terduga, dapat memunculkan jendela modal dan menunggu seseorang mengklik OK dan pesona lainnya.  Dan, mungkin, masalah terbesar - kecepatan platform meninggalkan banyak yang harus diinginkan ... Oleh karena itu, hanya ada satu solusi - pertanyaan langsung ke database 1C.  Mengingat strukturnya, Anda tidak bisa hanya mengambil dan menulis pertanyaan ini, tetapi manfaatnya adalah ada seluruh komunitas yang pada suatu waktu mengembangkan alat yang luar biasa - 1C ++ (1cpp.dll), yang luar biasa bagi mereka TERIMA KASIH!  Perpustakaan memungkinkan Anda untuk menulis kueri dalam hal 1C, yang kemudian berubah menjadi nama sebenarnya dari tabel dan bidang.  Jika ada yang tidak tahu, maka permintaan dapat ditulis menggunakan nama semu dan akan terlihat seperti ini <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> $.</code> </pre> <br>  Permintaan seperti itu dapat dimengerti oleh manusia, tetapi tidak ada tabel dan bidang pada server, ada nama lain, jadi 1C ++ akan mengubahnya menjadi <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> SP5278 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> SC2235</code> </pre> <br>  dan permintaan semacam itu sudah dipahami oleh server.  Semua orang senang, tidak ada yang bersumpah - baik orang, maupun server.  Di sini, tampaknya, masalah telah teratasi. <br><br>  Masalah kedua terletak pada bidang konfigurasi: satu konfigurasi digunakan di cabang, yang lain di kantor pusat, dan yang ketiga di cabang!  Kelas? !! â€‹â€‹1 Aku juga berpikir begitu.  Selain itu, mereka tidak khas dan bahkan bukan warisan khas, tetapi benar-benar ditulis dari awal selama Viking dan, sayangnya, bukan arsitek terbaik meletakkan dasar konfigurasi ini ... Implementasi Dokumen, misalnya, dalam setiap konfigurasi memiliki serangkaian detail yang berbeda.  Tetapi tidak hanya nama-nama dari beberapa bidang berbeda, yang jauh lebih menyenangkan ketika nama-nama rinciannya sama, tetapi arti dari data yang disimpan di dalamnya adalah BERBEDA. <br><br><img src="https://habrastorage.org/webt/hs/jx/sv/hsjxsv_f7qy4xlgpwjiw7uir0ko.jpeg"><br><br>  Dalam konfigurasi hampir tidak ada register yang digunakan, semuanya dibangun di atas kerumitan dokumen.  Oleh karena itu, kadang-kadang saya harus menulis seluruh lembar pada transaksi bersih, dengan banyak kasus dan bergabung, untuk mengulangi logika beberapa prosedur dari konfigurasi, yang menampilkan beberapa informasi di bidang teks pada formulir. <br><br>  Kita harus membayar upeti kepada tim pengembangan, yang selama ini mendukung apa yang mereka warisi dari "pelaksana", itu adalah pekerjaan besar - untuk mendukung ini dan bahkan mengoptimalkan sesuatu.  Sampai Anda melihat - Anda tidak mengerti, saya sendiri pada awalnya tidak percaya bahwa semuanya bisa begitu rumit.  Tanyakan - mengapa tidak menulis ulang dari awal?  Banal kekurangan sumber daya.  Perusahaan itu berkembang begitu cepat sehingga, meskipun ada tim programmer yang besar, mereka tidak bisa mengikuti kebutuhan bisnis, belum lagi menulis ulang seluruh konsep. <br><br>  Kami melanjutkan kisah permintaan.  Jelas, semua blok untuk ekstraksi data berubah menjadi penyimpanan sehingga nantinya mereka dapat diluncurkan di sisi server melewati platform 1C.  Aturannya adalah ini: satu penyimpanan bertanggung jawab untuk mengambil satu entitas.  Karena  Wishlist pada tahap awal sudah banyak terakumulasi, karena telah menjadi menyakitkan selama bertahun-tahun, maka puluhan file penyimpanan telah berubah. <br><br>  Masalah ketiga adalah bagaimana cara meningkatkan kecepatan dan kualitas pengembangan, dan bagaimana cara mendukung semua monster ini?  Tulis permintaan untuk 1C ++ dan salin-tempel hasil konversi ke penyimpanan?  Sangat tidak nyaman dan membosankan, selain itu, ada kemungkinan kesalahan yang tinggi - salin yang salah atau yang salah atau tidak pilih baris terakhir dari permintaan dan salin tanpa itu.  Ini terutama benar ketika datang ke permintaan 1C langsung, karena tidak ada nama pseudo seperti <i>Direktori.</i> Nomenklatur. Artikel, hanya nama asli <i>SC2235.SP5278</i> dan karenanya menyalin permintaan dari bawah direktori barang ke toko yang mengambil pelanggan sangat sederhana.  Tentu saja, permintaan kemungkinan besar akan jatuh karena ketidakcocokan jenis dan jumlah bidang dalam tabel tujuan, tetapi ada pelat yang identik, seperti enumerasi, di mana hanya dua kolom yaitu ID dan Nama.  Secara umum, itu hanya berlaku untuk beberapa jenis otomasi.  Cukup lirik, mari kita mulai bisnis! <br><br>  Saya ingin proses pengembangan penyimpanan turun ke sesuatu seperti ini: <br><br><ol><li>  Kami memperbaiki query SQL dengan pseudo-names dan menyimpannya </li><li>  Kami menekan <b>tombol ajaib</b> dan di pintu keluar kami menerima prosedur tersimpan terkoreksi pada SQL dikonversi, jelas ke server </li></ol><br><h4>  Beberapa detail </h4><br>  Untuk mengatasi masalah ketiga, pemrosesan eksternal (.ert) ditulis.  Ada sejumlah prosedur dalam pemrosesan, yang masing-masing berisi teks permintaan untuk mengekstraksi satu entitas menggunakan nama semu, seperti <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> $.</code> </pre> <br>  Pada formulir pemrosesan, ada bidang untuk menampilkan hasil dari prosedur tertentu, yaitu  permintaan dikonversi ke formulir yang dapat dimengerti oleh server sehingga Anda dapat dengan cepat mencobanya.  Plus, <b>blok debug</b> selalu ditambahkan ke permintaan ini, dengan deklarasi variabel, nama-nama database pengujian, server, dan banyak lagi.  Tetap hanya menyalin-menempel di SSMS dan tekan F5.  Anda dapat, tentu saja, menjalankan permintaan ini dari pemrosesan itu sendiri, tetapi rencana permintaan dan semua itu, well, Anda mengerti ... Secara umum, ini adalah bagaimana debugging dilakukan.  Karena  Ada beberapa konfigurasi, dalam pemrosesan, dimungkinkan untuk mengonversi teks kueri yang sama dengan nama-nama pseudo objek ke permintaan akhir untuk konfigurasi yang berbeda.  Memang, dalam satu referensi Referensi tata nama adalah SC123, dan di lain - SC321.  Tetapi 1C ++ memungkinkan Anda untuk memuat konfigurasi yang berbeda dalam runtime dan menghasilkan output individual untuk masing-masing sesuai dengan kamus. <br><br>  Selanjutnya, mode batch run ditambahkan ke pemrosesan, ketika secara otomatis memulai setiap prosedur untuk setiap konfigurasi, dan output dari masing-masing ditulis ke file .sql (selanjutnya file-file dasar).  Dengan demikian, kami mendapatkan banyak kombinasi file dasar, yang kemudian secara otomatis berubah menjadi prosedur tersimpan menggunakan VS.  Perlu dicatat bahwa file dasar termasuk <b>blok debug</b> . <br><br>  Tampaknya, mengapa tidak membuat kesimpulan segera ke file akhir dari prosedur tersimpan dan menyimpan semuanya dalam pemrosesan ini?  Faktanya adalah bahwa untuk beberapa tes perlu untuk menjalankan versi debug permintaan dalam batch di mana semua variabel dideklarasikan, ditambah saya ingin nama prosedur tersimpan dikelola dari VS, melewati 1C, karena ini logis, bukan? <br><br>  Omong-omong, file-file dasar juga disimpan dalam proyek, tentu saja, file-file dari prosedur tersimpan yang sudah jadi, tentu saja.  Kapan saja, tanpa memulai 1C, Anda dapat membuka file dasar di SSMS dan menjalankannya tanpa repot dengan deklarasi variabel. <br><br>  Dalam pemrosesan, semua prosedur dengan permintaan juga merupakan templat, memiliki set parameter yang sama, tetapi dalam prosedur ini atau itu hanya parameter yang diperlukan yang digunakan.  Dalam beberapa, semuanya terlibat, dan dalam beberapa, dua sudah cukup.  Oleh karena itu, menambahkan prosedur baru dilakukan untuk menyalin templat dan mengisi parameter dengan kueri itu sendiri. <br><br>  Kode salah satu prosedur pemrosesan, yang nantinya akan berubah menjadi prosedur tersimpan <br><img src="https://habrastorage.org/webt/ci/ev/sb/cievsb9urq5miainrvoqu9mkig0.png"><br><br>  Kueri terakhir adalah sesuatu seperti ini: <br><pre> <code class="1c hljs">++<span class="hljs-string"><span class="hljs-string">"("</span></span>+OPENQUERY()+<span class="hljs-string"><span class="hljs-string">")"</span></span>+ </code> </pre> <br>  Penampilan pemrosesan <br><img src="https://habrastorage.org/webt/yv/n4/in/yvn4injz09-m8ljnqhbediqvmqy.png"><br><br>  Saat mengalihkan konfigurasi, daftar item yang tersedia (perlu) untuk membongkar item dalam daftar Data berubah.  Jika memungkinkan, kode prosedur dalam 1C sebanyak mungkin disatukan.  Jika rekanan diekstraksi dan direktori ini tidak konsisten dalam konfigurasi yang berbeda, maka di dalam prosedur pembuatan ada beberapa kasus yang berbeda, seperti: blok ini diperbaiki untuk semua orang, ini ditambahkan ke permintaan akhir hanya untuk conf seperti itu, dan ada satu untuk yang lain.  Ternyata dalam prosedur tersimpan untuk satu entitas tetapi konfigurasi yang berbeda mereka dapat berbeda tidak hanya dengan nama tabel, tetapi dengan seluruh blok gabungan hadir dalam satu dan tidak ada di yang lain.  Himpunan bidang output, tentu saja, sama dan sesuai dengan tabel penerima atau wadah paket SSIS, beberapa bidang tersumbat dengan bertopik untuk konfigurasi di mana rincian ini tidak pada prinsipnya. <br><br>  <b>Tombol ajaib</b> <br><br>  Visual Studio memiliki alat seperti MSbuild dan templat T4 yang mengagumkan.  Oleh karena itu, sebagai tombol ajaib, skrip ditulis dalam C # untuk T4, yang: <br><br><ol><li>  Mendaftarkan konfigurasi kosong di registri (jika tidak 1C akan menampilkan jendela modal dengan saran untuk mendaftarkan conf dan menunggu tindakan pengguna) </li><li>  Membuat database kosong untuk konf ini di SQL server, karena tanpa itu 1C akan memberikan kesalahan </li><li>  Meluncurkan 1C dan melalui OLE memberitahu untuk menjalankan pemrosesan (.ert yang sama), juga mentransfer GUID unik ke 1C </li><li>  Outputnya adalah serangkaian file dengan permintaan yang siap pakai (dikonversi) dan file marker, yang menjadi tujuan penulisan GUID saat startup </li><li>  Pendaftaran conf dihapus dari registri dan database kosong sementara dihapus dari server </li><li>  Memeriksa konten file token.  Jika file penanda berisi GUID yang kami sampaikan ke 1C saat dimulai, itu berarti ia bekerja sampai akhir, tidak macet, dll., Kemudian pergi ke langkah berikutnya, atau kami menampilkan kesalahan </li><li>  Kami membuat penyimpanan. </li><li>  Kami mendekompilasi file .ert dengan gcomp untuk mendapatkan teks modul dan formulir pemrosesan, yah, kami mengonversi ke Unicode, untuk pengiriman berikutnya ke Git dan menampilkannya dengan benar di sana.  Bagi mereka yang tidak bekerja dengan 1C: file .ert adalah biner dan studio, bersama dengan git, berhembus bahwa file .ert telah diubah, tetapi tidak jelas apa yang sebenarnya telah berubah di dalamnya, mungkin hanya seseorang yang memindahkan tombol satu piksel ke kiri (yang tidak dapat diterima tanpa pembenaran) </li></ol><br><br>     T4       ,     (   ,    )        .      ,          .         ,     ,       ,      ,         - â€”   1. <br><br>  ,  ,    ,        ,        ,          .      â€”   1,     1,  -   . <br><br>      :       ? <br><br><ol><li>     / ; </li><li>    VS     ,     ; </li><li>   4; </li><li> <s>.</s>  Selesai </li></ol><br><div class="spoiler"> <b class="spoiler_title">?</b> <div class="spoiler_text">  Karena               ,       ,    .sqlproj,  <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">None</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">" \1.sql"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">None</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">" \2.sql"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">None</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">" \3.sql"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Content</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">" \*.sql"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>       Â«     Â».   ,  ,   ,     :) <br><br>     , ,    (, )     .           ( ),         , -   - -       ,             . <br></div></div><br>         ,      .      . , ,      ,      ,       ,       (    ),      . ,    (   ,      )  ,        ,  ,          .           ,   . ,     ,      ,     ,   ,     (   ,          1, ,    MD ). <br><br>      ,         <i>OPENQUERY</i> ,     1   ,     ,       ,       ,         <i>EXEC</i> . <i>OPENQUERY</i>    ,      ,   ,   . <br><br>  177 (  )   SQL2000,   varchar(max)  ,  varchar(8000),     9, â€¦ ,          EXEC(@SQL1+@SQL2).    ,       SQL2016,     SQL2000.     ,     ,    . <br><br><div class="spoiler"> <b class="spoiler_title">      </b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> @<span class="hljs-number"><span class="hljs-number">1</span></span>CDBName.dbo.$. <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> @<span class="hljs-number"><span class="hljs-number">1</span></span>CDBName.dbo.$. <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> xxx = <span class="hljs-string"><span class="hljs-string">'hello!'</span></span> ^<span class="hljs-comment"><span class="hljs-comment">--       8 , ,        ,       ,   .          ,             .. ... join ... ) join ...</span></span></code> </pre> </div></div><br><br><div class="spoiler"> <b class="spoiler_title">     </b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [dbo].[SP1] @LinkedServerName <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">24</span></span>) ,@<span class="hljs-number"><span class="hljs-number">1</span></span>CDBName <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">24</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Declare</span></span> @TSQL0 <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">8000</span></span>), @TSQL1 <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">8000</span></span>), @TSQL2 <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">8000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> @TSQL0=<span class="hljs-string"><span class="hljs-string">' select ... from OPENQUERY('</span></span>+@LinkedName+<span class="hljs-string"><span class="hljs-string">','' select ... from '</span></span>+@<span class="hljs-number"><span class="hljs-number">1</span></span>CDBName+<span class="hljs-string"><span class="hljs-string">'.dbo.DH123. join '</span></span>+@<span class="hljs-number"><span class="hljs-number">1</span></span>CDBName+<span class="hljs-string"><span class="hljs-string">'.SC123. ... where '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> @TSQL1=<span class="hljs-string"><span class="hljs-string">' xxx = ''''hello!'''' join ... join ... )'' join ... '''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> @TSQL2=<span class="hljs-string"><span class="hljs-string">' ... EXEC(@TSQL0+@TSQL1+@TSQL2) END</span></span></code> </pre> <br></div></div><br>     â€”     .       (, )   ,       , ,     ,      ,      ,   OPENQUERY  8 . <br><br> .ert             ,        ..  ,     . <br><br>          ,    . <br><br><h4> ETL </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin, di bagian ini tidak ada yang spesial (menurut saya). Skema klasik dengan database perantara (Tahap). Hanya dapat dicatat bahwa ETL diimplementasikan menggunakan paket SSIS, yang, pada gilirannya, melakukan prosedur tersimpan yang sama yang dibahas pada bagian sebelumnya. Ada paket utama dan beberapa anak. Untuk mengaktifkan eksekusi multi-utas, paket utama secara bersamaan meluncurkan beberapa instance dari paket turunan yang sama dengan parameter yang berbeda (untuk cabang yang berbeda), sebagai akibatnya, dimungkinkan untuk mendapatkan data dari server yang terhubung dalam waktu sesingkat mungkin.</font></font><br><br>                 ,     (   ) ,   ,        (..   ),            ,        . <br><br>          ,     ,      . ,     .     zabbix. <br><br>             . <br><br>  Karena    1     ,        ,            .      ,   ,   <code>truncate</code>  . <br><br> ,       (  )       -,  Â« 1-Â»     . <br><br>     SSIS  <br><br><img src="https://habrastorage.org/webt/al/nl/u_/alnlu_3yriilaxfcwlhq_mcf_ce.png"><br><br>      <br><br><img src="https://habrastorage.org/webt/rh/eh/c8/rhehc8b9jtn6qf6polrfqjiduuk.png"><br><br><h4>  ,   </h4><br>         SSIS     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> SQL Server</a> (SQL Server Destination),     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> OLE DB</a> (OLE DB Destination). <br><br>      ,       ,     ,             .    ,        ,   . (,     ) <br><br>       .           ,    ,      ,        (/  ). <br>                      . <br><br>          ,         (  ).  Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">skrip tidak hanya membuat perubahan pada data, tetapi juga mencatat fakta peluncurannya dalam log. Masuk akal tidak hanya untuk mendaftarkan peluncuran, tetapi juga untuk memblokir restart jika log sudah berisi informasi tentang proses sebelumnya. Dan jika karena alasan tertentu Anda perlu menjalankan skrip yang sama lagi - buat salinannya dan berikan tanggal dan nomor baru. Ini akan sangat memudahkan hidup dan menghilangkan klaim yang tidak perlu selama pembekalan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapkan string dan jalur koneksi selain jalur dan nama produktif sebagai pengaturan default untuk penyebaran, sehingga untuk publikasi dalam produk Anda harus dengan sengaja (mis. Secara sadar) memilih pengaturan tertentu.</font></font><br><br>       ,     ,          . <br><br><h4>  PS </h4><br>     ,     ,      ,    ,   .   â€”   ,    .           -  ,       ,   . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423205/">https://habr.com/ru/post/id423205/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423191/index.html">Peluncuran elemen platform lepas pantai. Bagian 1</a></li>
<li><a href="../id423193/index.html">Konfigurasikan Pemberitahuan Dorong Web menggunakan pywebpush langkah demi langkah</a></li>
<li><a href="../id423195/index.html">Apa yang Baru di JPA 2.2</a></li>
<li><a href="../id423197/index.html">LOLWUT: sebuah karya seni dalam tim db</a></li>
<li><a href="../id423203/index.html">Pemimpin tim yang keren akan bertanggung jawab atas layanan ini</a></li>
<li><a href="../id423207/index.html">Cara membuat pembaruan otomatis dari klien game online</a></li>
<li><a href="../id423209/index.html">Killer Form 2? Tinjauan Umum tentang Printer 3D MoonRay S100</a></li>
<li><a href="../id423211/index.html">Komite Duma Negara: suka dan repost akan tetap bertanggung jawab secara pidana</a></li>
<li><a href="../id423213/index.html">Seperti di Rusia Lama akan ada "ini ujian"</a></li>
<li><a href="../id423215/index.html">Di mana uang saya, Bung: apa yang diam tentang Steam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>