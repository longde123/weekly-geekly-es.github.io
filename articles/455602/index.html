<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏻 👼🏿 👨🏽‍🏭 Provocar bloqueos del navegador con fuzzing conductual 🙅🏼 🧑🏿‍🤝‍🧑🏻 🐻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este artículo, te contaré cómo usé fuzzing para encontrar varios bloqueos en Firefox. Por lo general, el propósito del fuzzing es encontrar una fal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Provocar bloqueos del navegador con fuzzing conductual</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vds/blog/455602/"><img src="https://habrastorage.org/getpro/habr/post_images/de5/60c/9c4/de560c9c4bd1bb90f65f35ecacdbc310.jpg" alt="imagen"><br><br>  En este artículo, te contaré cómo usé fuzzing para encontrar varios bloqueos en Firefox.  Por lo general, el propósito del fuzzing es encontrar una falla que indique daños en la memoria, pero mi objetivo es diferente: quiero detectar una reacción inesperada del navegador.  Estos pueden ser caracteres que abren o cierran una etiqueta inusual, o posiblemente caracteres que el analizador de JavaScript ignora.  Esta reacción inesperada a menudo se puede utilizar para realizar ataques XSS, evitando los filtros de seguridad y evitando el entorno limitado de JavaScript. <a name="habracut"></a><br><br>  El primer error del que quiero hablar es cómo cerrar el comentario HTML de una manera diferente.  Si lee la especificación HTML, sabe que un comentario puede cerrarse con -&gt; o -!&gt;.  ¿Pero cómo hacerlo de manera diferente?  ¡Gran pregunta para comenzar a difuminar!  Solo necesita generar el código que dará la respuesta. <br><br>  En 2008, cuando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ensamblé Shazzer</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">confundir el</a> comportamiento del navegador, estaba limitado a aproximadamente 10,000 direcciones por página.  Hoy, en 2019, todo funciona más rápido, por lo que podemos difuminar mucho más a menudo.  Además, el uso del DOM acelera el difuminado porque ya no necesita agregar cada dirección al documento actual.  Vale la pena señalar que este es un enfoque poco confiable, ya que puede obtener resultados diferentes.  De hecho, he encontrado casos en los que el DOM permite valores nulos en argumentos de atributos como href, pero el analizador HTML no.  Estas siguen siendo fallas no críticas, pero no siempre se puede confiar en los resultados para obtener una imagen completa de lo que hará el analizador HTML.  Sin embargo, en la mayoría de los casos funciona, y es mucho más rápido que la salida HTML desde el lado del servidor. <br><br>  El primer paso ya se ha dado: tenemos una pregunta: "¿Qué caracteres pueden cerrar el comentario HTML?".  Para responderlo, necesitamos usar caracteres existentes que cerrarán el comentario HTML y los caracteres difusos que no conocemos.  El siguiente paso es usar el software de fuzzing apropiado.  En mi caso, uso mi herramienta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hackvertor</a> , pero usando el servidor web local puedo lograr los mismos resultados.  La idea de esta herramienta es poner la entrada en el campo de entrada, convertir las etiquetas un poco y hacer algo con la salida.  Como no tenemos nada que convertir, podemos poner nuestro código directamente en el campo de salida.  Por lo tanto, haga clic en el área de salida de texto y cree una matriz para almacenar caracteres difusos y un elemento div para probar HTML: <br><br><pre><code class="javascript hljs">log = []; div=<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>);</code> </pre> <br>  Luego, necesitamos eliminar más de 1,000,000 de caracteres Unicode o, más precisamente, 0x10ffff.  Un simple bucle for es todo lo que necesitamos: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;=<span class="hljs-number"><span class="hljs-number">0x10ffff</span></span>;i++){</code> </pre> <br>  Luego, reutilizamos el elemento div que creamos para cada personaje.  ¡En este caso, pruebo la posición después !, ¡para que se ingrese el carácter después! .. Luego uso el elemento img para ver si el borrado fue exitoso.  Si este elemento existe, entonces el comentario HTML se ha cerrado, ¡y tenemos algunos caracteres interesantes! <br><br><pre> <code class="javascript hljs">div.innerHTML = <span class="hljs-string"><span class="hljs-string">'&lt;!-- --!'</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.fromCodePoint(i)+<span class="hljs-string"><span class="hljs-string">'&gt;&lt;img&gt;--&gt;'</span></span>;</code> </pre> <br>  Finalmente, con querySelector verificamos si existe img y agregamos caracteres a los registros.  Luego cierro la declaración if y el bucle for.  Finalmente, ingreso los resultados en el campo de entrada a la izquierda: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(div.querySelector(<span class="hljs-string"><span class="hljs-string">'img'</span></span>)){ log.push(i); } } input.value=log</code> </pre> <br>  Aquí está la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versión completa del</a> código.  Debe abrir la URL en Firefox, y luego poner los caracteres de entrada en el campo de salida y hacer clic en el botón "Ejecutar JS" para borrar los caracteres.  Después de completar el borrado, debería ver los números en el campo de entrada, corresponden a los códigos de caracteres que tuvieron éxito.  Al momento de escribir, Firefox (versión 67) todavía permite caracteres de nueva línea - \ n y \ r - después!, Para cerrar el comentario.  Me informaron que esto se ha solucionado en futuras versiones de Firefox.  Entonces, la última etapa de fuzzing es construir su carga útil, es bastante simple.  Debe reemplazar el código de carácter con el carácter y agregar la carga útil XSS: <br><br><pre> <code class="javascript hljs">&lt;!-- --! &gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">1</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onerror</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">alert(1)</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> --&gt;</span></span></code> </pre> <br>  Puede usar Hackvertor nuevamente para probar su funcionamiento pegando lo anterior en el campo de salida y luego haciendo clic en "Probar HTML".  Debería aparecer una ventana de advertencia porque Firefox (versión 67) permite una nueva línea como parte del comentario final. <br><br>  Esto nos permitió encontrar un error no crítico en el analizador HTML de Firefox.  ¡Busquemos otro!  Necesitamos una nueva pregunta: "¿Qué caracteres pueden abrir un comentario HTML?".  En lugar de ir más allá del comentario HTML existente, ahora utilizaremos el comentario HTML para ir más allá del atributo HTML existente.  Como estoy seguro, todos saben que pueden abrir un comentario HTML con &lt;!  -.  ¿Eso está bien?  Usaremos el mismo código nuevamente, pero esta vez cambie el propósito de innerHTML para verificar si el comentario está abierto: <br><br><img src="https://habrastorage.org/webt/nb/ji/du/nbjidu5mobde5mgiiojvfnumiwi.png"><br><br>  Por lo tanto, el símbolo que difuminaremos será después del primer guión.  Si el personaje crea con éxito un comentario HTML de apertura, comentará el elemento div y, por lo tanto, saldrá del atributo de título.  Esta vez, cuando ejecutamos "Ejecutar JS", obtenemos dos resultados en Firefox (versión 67): "0.45".  Se espera el código 45 porque es un guión, ¡pero 0 es un carácter NULO!  Esto significa que Firefox interpreta la secuencia &lt;! - NULL- como un comentario abierto.  ¡Algún tipo de juego!  (Creo que los proveedores de navegadores necesitan más fuzzing de comportamiento =)).  Para terminar este caso de prueba, ahora necesitamos crear nuestra dirección.  Hagamos lo mismo: de nuevo, reemplace la función String.fromCodePoint con el símbolo NULL y XSS con la dirección: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerHTML = <span class="hljs-string"><span class="hljs-string">'&lt;!-\x00- &gt;&lt;div title="--&gt;&lt;img src=1 onerror=alert(1)&gt;"&gt;&lt;/div&gt;'</span></span>;</code> </pre> <br>  Cambiemos a JavaScript en lugar de HTML.  Probé todos los navegadores y lo siento, Mozilla, pero Firefox está haciendo algún tipo de juego nuevamente.  Me inspiró el hecho de que la difuminación del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tweet</a> jinmo123 utiliza nuevas e interesantes características de ES6 para llamar a funciones sin paréntesis.  La pregunta que se me ocurrió para hacer fuzzing fue: "¿qué caracteres están permitidos después de los operadores in o instanceof?"  Luego, nuevamente creamos el código en Hackvertor, sigue un patrón similar, pero esta vez no usa el DOM.  Primero, cree una matriz y un bucle for: <br><br><pre> <code class="javascript hljs">log = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;=<span class="hljs-number"><span class="hljs-number">0x10ffff</span></span>;i++){</code> </pre><br>  Luego usaremos eval en lugar de innerHTML para difuminar nuestros valores.  Primero debemos usar un bloque try catch para detectar cualquier excepción causada por caracteres no válidos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">"/a/"</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.fromCodePoint(i)+<span class="hljs-string"><span class="hljs-string">"instanceof function(){}"</span></span>);</code> </pre> <br>  La función eval se usa para ver si nuestro JavaScript es válido.  Si es así, irá a la siguiente línea; de lo contrario, lanzará una excepción que se notará y luego pasará al siguiente personaje.  La siguiente línea simplemente registra el carácter y luego cierra el bloque try catch y el bucle for.  La función luego muestra los resultados en el campo de entrada. <br><br><pre> <code class="javascript hljs">log.push(i); }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e){} } input.value=log</code> </pre> <br>  Si ejecuta este código usando "Ejecutar JS", obtendrá muchos resultados.  Firefox ignora muchos caracteres.  Si prueba el código en Chrome, obtendrá resultados más razonables.  Encuentre el código de caracteres en el campo de entrada que desea usar, en mi caso fue "1114110" o "0x10fffe" en hexadecimal.  Ahora crearemos nuestro vector JavaScript: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">"1337"</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.fromCodePoint(<span class="hljs-number"><span class="hljs-number">1114110</span></span>)+<span class="hljs-string"><span class="hljs-string">"in"</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.fromCodePoint(<span class="hljs-number"><span class="hljs-number">1114110</span></span>)+<span class="hljs-string"><span class="hljs-string">"alert(1337)"</span></span>);</code> </pre> <br>  También puedes imaginarlo dentro de un script SVG: <br><br><img src="https://habrastorage.org/webt/hv/92/k2/hv92k2ivxpvq3-2faoms6akr9hg.png"><br><br>  Las últimas configuraciones de doble procesador de servidores dedicados con procesadores escalables Intel 2019 están disponibles en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>DEDIC.SH</b></a> : <br><ul><li>  2x Xeon Silver 4214: un total de 24 núcleos </li><li>  2x Xeon Gold 5218 - un total de 32 núcleos </li><li>  2x Xeon Gold 6240 - configuración con 36 núcleos. </li></ul><br>  El costo de un servidor con dos Xeon Silver 4214 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>desde 15210 rublos / mes</b></a> <br>  También estamos listos para recopilar <b>cualquier configuración</b> para usted, ¡ <b><a href="">escríbanos</a></b> ! <br><br>  Si no se requieren grandes potencias de un servidor dedicado, ¡ <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VDS desde 150 rublos / mes</a></b> es lo que necesita! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455602/">https://habr.com/ru/post/455602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455592/index.html">Virus que atacan a empresas industriales como una amenaza para la seguridad física</a></li>
<li><a href="../455594/index.html">Microsoft Edge de CVE a RCE en Windows 10</a></li>
<li><a href="../455596/index.html">DevConfX :: Gestión - informes de gerentes en palabras simples</a></li>
<li><a href="../455598/index.html">Actualice urgentemente Exim a 4.92: hay una infección activa</a></li>
<li><a href="../455600/index.html">La plataforma 3DEXPERIENCE ayuda a crear el transporte público del futuro</a></li>
<li><a href="../455604/index.html">Ansible para administrar la configuración de Windows. Historia de éxito</a></li>
<li><a href="../455606/index.html">Aprendizaje automático y análisis de datos: programa de maestría en la Escuela Superior de Economía de San Petersburgo</a></li>
<li><a href="../455608/index.html">Índices de mapa de bits en Go: velocidad de búsqueda increíble</a></li>
<li><a href="../455610/index.html">El legendario Intel Core i7-2600K: prueba de Sandy Bridge en 2019 (parte 1)</a></li>
<li><a href="../455612/index.html">Pensamos a través de los personajes de los juegos y los diálogos siguiendo los consejos de los escritores y el ejemplo de los partidarios de la teoría de una Tierra plana.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>