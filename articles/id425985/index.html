<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌤️ 🔬 💎 Eksekusi Kode Kustom di GO 👸🏿 👨🏻‍🚒 👨🏿‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini sebenarnya semua tentang kontrak pintar. 
 Tetapi jika Anda tidak cukup membayangkan apa itu kontrak pintar, dan secara umum jauh dari crypto, mak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eksekusi Kode Kustom di GO</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425985/"><h2>  Ini sebenarnya semua tentang kontrak pintar. </h2><br>  Tetapi jika Anda tidak cukup membayangkan apa itu kontrak pintar, dan secara umum jauh dari crypto, maka apa itu prosedur tersimpan dalam database, Anda bisa bayangkan sepenuhnya.  Pengguna membuat potongan kode yang kemudian berfungsi di server kami.  Adalah nyaman bagi pengguna untuk menulis dan menerbitkannya, dan aman bagi kami untuk mengeksekusinya. <br><a name="habracut"></a><br>  Sayangnya, kami belum mengembangkan keamanan, jadi sekarang saya tidak akan menjelaskannya, tetapi saya akan memberikan beberapa petunjuk. <br><br>  Kami juga menulis di Go, dan runtime-nya memberlakukan beberapa batasan yang sangat spesifik, yang utamanya adalah, pada umumnya, kami tidak dapat menautkan ke proyek lain yang ditulis tidak dalam perjalanan, ini akan menghentikan runtime kami setiap kali kami mengeksekusi kode pihak ketiga.  Secara umum, kami memiliki opsi untuk menggunakan semacam juru bahasa, yang kami temukan Lua yang benar-benar waras dan WASM yang benar-benar waras, tetapi entah bagaimana saya tidak ingin menambahkan klien ke Lua, tetapi dengan WASM sekarang ada lebih banyak masalah daripada manfaat, itu dalam rancangan negara , yang diperbarui setiap bulan, jadi kami akan menunggu hingga spesifikasi selesai.  Kami menggunakannya sebagai mesin kedua. <br><br>  Sebagai hasil dari pertempuran panjang dengan hati nuraninya sendiri, diputuskan untuk menulis kontrak pintar di GO.  Faktanya adalah bahwa jika Anda membangun arsitektur untuk mengeksekusi kode GO yang dikompilasi, Anda harus mentransfer eksekusi ini ke proses terpisah, seperti yang Anda ingat, untuk keamanan, dan mentransfer ke proses terpisah adalah hilangnya kinerja pada IPC, meskipun nanti, ketika kami memahami volume yang dapat dieksekusi kode, itu entah bagaimana menyenangkan bahwa kami memilih solusi ini.  Masalahnya adalah itu dapat diskalakan, meskipun ia menambahkan penundaan untuk setiap panggilan individu.  Kami dapat meningkatkan banyak runtimes jarak jauh. <br><br>  Sedikit lagi tentang keputusan yang dibuat sehingga menjadi jelas.  Setiap kontrak pintar terdiri dari dua bagian, satu bagian adalah kode kelas, dan yang kedua adalah data objek, jadi pada kode yang sama kita dapat, begitu kita menerbitkan kode, membuat banyak kontrak yang pada dasarnya akan berperilaku sama, tetapi dengan pengaturan berbeda , dan dengan status berbeda.  Jika kita berbicara lebih jauh, maka ini sudah tentang blockchain dan bukan topik cerita ini. <br><br><h2>  Jadi, kami menjalankan GO </h2><br>  Kami memutuskan untuk menggunakan mekanisme plugin, yang tidak hanya siap dan bagus.  Dia melakukan yang berikut, kita mengkompilasi apa yang akan menjadi plugin dengan cara khusus ke perpustakaan bersama, dan kemudian memuatnya, menemukan simbol di dalamnya dan meneruskan eksekusi di sana.  Tetapi yang menarik adalah bahwa GO memiliki runtime, dan ini hampir satu megabyte kode, dan secara default runtime ini juga pergi ke perpustakaan ini, dan kami memiliki runtime raznipipenny di mana-mana.  Tetapi sekarang kami memutuskan untuk melakukannya, yakin bahwa kami dapat mengalahkannya di masa depan. <br><br>  Semuanya sederhana ketika Anda membangun perpustakaan Anda, Anda membangunnya dengan kunci - buildmode = plugin dan mendapatkan file .so, yang kemudian Anda buka. <br><br><pre><code class="go hljs">p, err := plugin.Open(path)</code> </pre> <br>  Mencari karakter yang Anda minati: <br><br><pre> <code class="go hljs">symbol, err := p.Lookup(Method)</code> </pre> <br>  Dan sekarang, tergantung pada apakah variabel itu fungsi atau fungsi, Anda bisa memanggilnya atau menggunakannya sebagai variabel. <br><br>  Di bawah kap mekanisme ini adalah dlopen sederhana (3), kami memuat pustaka, memeriksa apakah itu plugin dan memberikan pembungkus di atasnya, saat membuat pembungkus, semua karakter yang diekspor dibungkus dengan antarmuka {} dan disimpan.  Jika itu adalah fungsi, maka itu harus direduksi menjadi jenis fungsi yang benar dan cukup dipanggil, jika variabel - maka berfungsi seperti variabel. <br><br>  Hal utama yang perlu diingat adalah bahwa jika simbol adalah variabel, maka simbol bersifat global selama seluruh proses dan Anda tidak dapat menggunakannya tanpa berpikir. <br><br>  Jika suatu tipe telah dideklarasikan dalam plugin, maka masuk akal untuk meletakkan tipe ini dalam paket terpisah sehingga proses utama dapat bekerja dengannya, misalnya, meneruskan sebagai argumen ke fungsi-fungsi plugin.  Ini opsional, Anda tidak dapat mengukus dan menggunakan refleksi. <br><br>  Kontrak kami adalah objek dari "kelas" yang sesuai, dan pada awalnya instance dari objek ini disimpan dalam variabel yang diekspor, sehingga kami dapat membuat variabel yang sama: <br><br><pre> <code class="go hljs">export, err := p.Lookup(<span class="hljs-string"><span class="hljs-string">"EXPORT"</span></span>) obj := reflect.New(reflect.ValueOf(export).Elem().Type()).Interface()</code> </pre> <br>  Dan sudah di dalam variabel lokal ini dari jenis yang benar, deserialize keadaan objek.  Setelah objek dipulihkan, kita dapat memanggil metode di atasnya.  Setelah objek serial dan ditambahkan kembali ke toko, sorak-sorai kami memanggil metode pada kontrak. <br><br>  Jika Anda tertarik dengan caranya, tetapi terlalu malas untuk membaca dokumentasinya, maka: <br><br><pre> <code class="go hljs">method := reflect.ValueOf(obj).MethodByName(Method) res:= method.Call(in)</code> </pre> <br>  Di tengah, Anda masih perlu mengisi array dengan antarmuka kosong yang berisi jenis argumen yang benar, jika Anda tertarik, lihat sendiri bagaimana hal itu dilakukan, sumbernya terbuka, meskipun menemukan tempat ini dalam <a href="">sejarah</a> akan sulit. <br><br>  Secara umum, semuanya bekerja untuk kami, Anda dapat menulis kode dengan sesuatu seperti kelas, meletakkannya di blockchain, membuat kontrak kelas ini lagi di blockchain, membuat panggilan metode di atasnya dan keadaan kontrak yang baru ditulis kembali ke blockchain.  Hebat!  Bagaimana cara membuat kontrak baru dengan kode di tangan?  Sangat sederhana, kami memiliki fungsi konstruktor yang mengembalikan objek yang baru dibuat, yang merupakan kontrak baru.  Sejauh ini, semuanya bekerja melalui refleksi dan pengguna harus menulis: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> EXPORT ContractType</code> </pre> <br>  Sehingga kita tahu simbol apa yang merupakan representasi dari kontrak, dan benar-benar menggunakannya sebagai templat. <br><br>  Kami tidak begitu menyukainya.  Dan kami memukul keras. <br><br><h2>  Parsing </h2><br>  Pertama, pengguna tidak boleh menulis sesuatu yang berlebihan, dan kedua, kami memiliki gagasan bahwa interaksi kontrak dengan kontrak harus sederhana, dan diuji tanpa meningkatkan blockchain, blockchain lambat dan sulit. <br><br>  Oleh karena itu, kami memutuskan untuk membungkus kontrak dalam pembungkus, yang dihasilkan berdasarkan kontrak dan templat pembungkus, pada prinsipnya, solusi yang dapat dimengerti.  Pertama, pembungkus membuat objek ekspor untuk kami, dan kedua, itu menggantikan perpustakaan dengan kontrak yang dikumpulkan ketika pengguna menulis kontrak, perpustakaan yayasan digunakan dengan mokas di dalamnya, dan ketika kontrak diterbitkan, itu diganti dengan pertempuran yang bekerja dengan blockchain itu sendiri . <br><br>  Untuk memulainya, Anda perlu mengurai kode dan memahami apa yang umumnya kita miliki, menemukan struktur yang diwarisi dari BaseContract untuk menghasilkan pembungkus di sekitarnya. <br><br>  Ini dilakukan cukup sederhana, kami membaca file dengan kode dalam [] byte, meskipun parser itu sendiri dapat membaca file, ada baiknya memiliki teks di suatu tempat yang semua elemen AST merujuk, mereka merujuk ke nomor byte dalam file, dan di masa depan kami ingin menerima kode struktur apa adanya, kami hanya mengambil sesuatu seperti. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pf *ParsedFile)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">codeOfNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n ast.Node)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(pf.code[n.Pos()<span class="hljs-number"><span class="hljs-number">-1</span></span> : n.End()<span class="hljs-number"><span class="hljs-number">-1</span></span>]) }</code> </pre> <br>  Kami benar-benar mem-parsing file dan mendapatkan simpul AST paling atas dari mana kami akan menjelajah file. <br><br><pre> <code class="go hljs">fileSet = token.NewFileSet() node, err := parser.ParseFile(fileSet, name, code, parser.ParseComments)</code> </pre> <br>  Selanjutnya, kita berkeliling kode mulai dari simpul atas, dan mengumpulkan segala sesuatu yang menarik dalam struktur yang terpisah. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, decl := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> node.Decls { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> d := decl.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ast.GenDecl: … <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ast.FuncDecl: … } }</code> </pre> <br>  Decls, sudah diuraikan menjadi array, daftar semua yang didefinisikan dalam file, tetapi itu adalah array dari antarmuka Decl yang tidak menggambarkan apa yang ada di dalamnya, sehingga setiap elemen perlu dikonversi ke jenis tertentu, di sini penulis bahasa berangkat dari ide mereka menggunakan antarmuka, antarmuka di go / ast lebih merupakan kelas dasar. <br><br>  Kami tertarik pada simpul tipe GenDecl dan FuncDecl.  GenDecl adalah definisi dari variabel atau tipe, dan Anda perlu memeriksa apa sebenarnya tipe di dalamnya, dan sekali lagi dilemparkan ke tipe TypeDecl, yang sudah dapat Anda gunakan.  FuncDecl lebih sederhana - ini adalah fungsi, dan jika memiliki bidang Recv diisi, maka ini adalah metode struktur yang sesuai.  Kami mengumpulkan semua hal ini dalam penyimpanan yang nyaman, karena kami menggunakan teks / templat, dan tidak memiliki banyak kekuatan ekspresif. <br><br>  Satu-satunya hal yang perlu kita ingat secara terpisah adalah nama tipe data yang diwarisi dari BaseContract, dan kita akan menari di sekitarnya. <br><br><h2>  Pembuatan Kode </h2><br>  Jadi, kita tahu semua jenis dan fungsi yang ada dalam kontrak kita dan kita harus bisa membuat pemanggilan metode pada objek dari nama metode yang masuk dan array argumen serial.  Tapi bagaimanapun, pada saat pembuatan kode, kita tahu seluruh perangkat kontrak, jadi kita meletakkan di samping file kontrak kita di sebelah file lain, dengan nama paket yang sama, di mana kita memasukkan semua impor yang diperlukan, jenis sudah ditentukan dalam file utama dan tidak perlu. <br><br>  Dan di sini adalah hal utama, pembungkus fungsi.  Nama bungkusnya dilengkapi dengan semacam awalan dan sekarang bungkusnya mudah ditemukan. <br><br><pre> <code class="go hljs">symbol, err := p.Lookup(<span class="hljs-string"><span class="hljs-string">"INSMETHOD_"</span></span> + Method) wrapper, ok := symbol.(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ph proxyctx.ProxyHelper, object []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, result []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  Setiap bungkus memiliki tanda tangan yang sama, jadi ketika kita menyebutnya dari program utama, kita tidak perlu refleksi tambahan, satu-satunya hal adalah pembungkus fungsi berbeda dari pembungkus metode, mereka tidak menerima dan tidak mengembalikan keadaan objek. <br><br>  Apa yang kita miliki di dalam bungkusnya? <br><br>  Kami membuat array variabel kosong yang sesuai dengan argumen fungsi, memasukkannya ke dalam variabel tipe array antarmuka, dan membatalkan deserialisasi argumen ke dalamnya, jika kita adalah sebuah metode, kita juga harus membuat serial keadaan objek, umumnya seperti ini: <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $method := .Methods }} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">INSMETHOD_</span></span></span></span>{{ $method.Name }}(ph proxyctx.ProxyHelper, object []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, data []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) ([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, error) { self := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>({{ $.ContractType }}) err := ph.Deserialize(object, self) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ $method.ArgumentsZeroList }} err = ph.Deserialize(data, &amp;args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $method.Results }} {{ $method.Results }} := self.{{ $method.Name }}( {{ $method.Arguments }} ) {{ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> }} self.{{ $method.Name }}( {{ $method.Arguments }} ) {{ end }} state := []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{} err = ph.Serialize(self, &amp;state) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $i := $method.ErrorInterfaceInRes }} ret{{ $i }} = ph.MakeErrorSerializable(ret{{ $i }}) {{ end }} ret := []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{} err = ph.Serialize([]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} { {{ $method.Results }} }, &amp;ret) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, ret, err } {{ end }}</code> </pre><br>  Pembaca yang penuh perhatian akan tertarik pada apa itu pembantu proxy?  - ini adalah objek gabungan yang masih kita butuhkan, tetapi untuk saat ini kita menggunakan kemampuannya untuk membuat serial dan deserialize. <br><br>  Nah, siapa pun yang membaca akan bertanya, "Tapi ini argumen Anda, dari mana mereka berasal?"  Ini juga jawaban yang bisa dimengerti, ya teks / templat di sana tidak cukup bintang dari langit, itu sebabnya kami menghitung garis-garis ini dalam kode, dan bukan di templat. <br><br>  method.ArgumentsZeroList berisi sesuatu seperti <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arg0 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> Var arg1 <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = “” Var arg2 ackwardType = ackwardType{} Args := []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{&amp;arg0, &amp;arg1, &amp;arg2}</code> </pre> <br>  Dan Argumen sesuai mengandung "arg0, arg1, arg2". <br><br>  Dengan demikian, kita dapat memanggil apa saja yang kita inginkan, dengan tanda tangan apa saja. <br><br>  Tetapi kami tidak dapat membuat serialisasi jawaban apa pun, faktanya adalah bahwa serializers bekerja dengan refleksi, dan itu tidak memberikan akses ke bidang struktur yang tidak diekspor, itu sebabnya kami memiliki metode pembantu proxy khusus yang mengambil objek antarmuka kesalahan dan membuat objek tipe pondasi darinya. Kesalahan, yang berbeda dari yang biasa di mana teks kesalahan ada di dalamnya di bidang yang diekspor, dan kita bisa membuat serial, meskipun dengan beberapa kerugian. <br><br>  Tetapi jika kita menggunakan sterilisasi penghasil kode, maka kita bahkan tidak membutuhkannya, kita dikompilasi dalam paket yang sama, kita memiliki akses ke bidang yang tidak diekspor. <br><br><h2>  Tetapi bagaimana jika kita ingin memanggil suatu kontrak dari suatu kontrak? </h2><br>  Anda tidak mengerti kedalaman masalah jika Anda merasa mudah untuk memanggil kontrak dari kontrak.  Faktanya adalah bahwa validitas kontrak lain harus dikonfirmasikan dengan konsensus, dan fakta panggilan ini harus ditandatangani di blockchain, secara umum, hanya mengkompilasi dengan kontrak lain dan menggunakan metode ini tidak akan berhasil, walaupun saya benar-benar ingin.  Tapi kami adalah teman programmer, jadi kami harus memberi mereka kesempatan untuk melakukan semuanya secara langsung, dan menyembunyikan semua trik di bawah kap sistem.  Dengan demikian, pengembangan kontrak seolah-olah dengan panggilan langsung, dan kontrak saling menarik secara transparan, tetapi ketika kami mengumpulkan kontrak untuk publikasi, kami menyelipkan proxy alih-alih kontrak lain, yang hanya mengetahui alamat dan tanda tangan panggilan tentang kontrak tersebut. <br><br>  Bagaimana mengatur semua ini?  - Kita harus menyimpan kontrak lain di direktori khusus yang generator kita dapat mengenali dan membuat proksi untuk setiap kontrak yang diimpor. <br><br>  Yaitu, jika kita bertemu: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> “ContractsDir/ContractAddress<span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br>  Kami menulisnya ke daftar kontrak impor. <br><br>  Ngomong-ngomong, untuk ini Anda tidak perlu tahu kode sumber kontrak, Anda hanya perlu mengetahui deskripsi yang telah kami kumpulkan, jadi jika kami menerbitkan deskripsi seperti itu di suatu tempat, dan semua panggilan melalui sistem utama, maka kami tidak peduli apa kontrak lain ditulis dalam bahasa, jika kita dapat memanggil metode di atasnya, kita dapat menulis sebuah rintisan untuk itu di Go, yang akan terlihat seperti paket dengan kontrak yang dapat dipanggil secara langsung.  Rencana Napoleon, mari kita mulai. <br><br>  Pada prinsipnya, kami sudah memiliki metode pembantu proxy, dengan tanda tangan ini: <br><br><pre> <code class="go hljs">RouteCall(ref Address, method <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) ([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, error)</code> </pre> <br>  Metode ini dapat dipanggil langsung dari kontrak, itu disebut kontrak jarak jauh, mengembalikan respons berseri yang perlu kita uraikan dan kembali ke kontrak kita. <br><br>  Tetapi penting bagi pengguna untuk terlihat seperti: <br><br><pre> <code class="go hljs">ret := contractPackage.GetObject(Address).Method(arg1,arg2, …)</code> </pre> <br>  Mari kita mulai, pertama, di proksi, Anda perlu membuat daftar semua jenis yang digunakan dalam tanda tangan metode kontrak, tetapi seperti yang kita ingat, untuk setiap node AST kita dapat mengambil representasi tekstualnya, dan sekarang saatnya untuk mekanisme ini. <br><br>  Selanjutnya, kita perlu membuat jenis kontrak, pada prinsipnya, dia sudah tahu kelasnya, hanya alamat yang diperlukan. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> {{ .ContractType }} <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Reference Address }</code> </pre> <br>  Selanjutnya, kita perlu mengimplementasikan fungsi GetObject, yang pada alamat di blockchain akan mengembalikan instance proxy yang tahu cara bekerja dengan kontrak ini, dan bagi pengguna itu tampak seperti instance kontrak. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref Address)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *{{ .ContractType }})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;{{ .ContractType }}{Reference: ref} }</code> </pre> <br>  Menariknya, metode GetObject dalam mode debugging pengguna secara langsung adalah metode struktur BaseContract, tetapi tidak ada, tidak ada yang menghalangi kita, mengamati SLA, untuk melakukan apa yang nyaman bagi kita.  Sekarang kita dapat membuat kontrak proxy, metode yang kita kendalikan.  Tetap benar-benar membuat metode. <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $method := .MethodsProxies }} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *{{ $.ContractType }})</span></span></span></span> {{ $method.Name }}( {{ $method.Arguments }} ) ( {{ $method.ResultsTypes }} ) { {{ $method.InitArgs }} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> argsSerialized []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> err := proxyctx.Current.Serialize(args, &amp;argsSerialized) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } res, err := proxyctx.Current.RouteCall(r.Reference, <span class="hljs-string"><span class="hljs-string">"{{ $method.Name }}"</span></span>, argsSerialized) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } {{ $method.ResultZeroList }} err = proxyctx.Current.Deserialize(res, &amp;resList) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {{ $method.Results }} } {{ end }}</code> </pre> <br>  Di sini cerita yang sama dengan konstruksi daftar argumen, karena kita malas dan menyimpan persis ast. Metode ini, maka perhitungan memerlukan banyak jenis konversi yang tidak diketahui templat, sehingga semuanya disiapkan terlebih dahulu.  Dengan fungsi, semuanya menjadi lebih rumit, dan ini adalah topik dari artikel lain. <br><br>  Fungsi yang kami miliki adalah konstruktor objek dan ada banyak penekanan pada bagaimana objek sebenarnya dibuat dalam sistem kami, fakta penciptaan terdaftar pada pelaksana jarak jauh, objek ditransfer ke pelaksana lain, diperiksa dan benar-benar disimpan di sana, dan ada banyak cara untuk menyimpan, dengan sia-sia bidang pengetahuan ini disebut crypt.  Dan idenya pada dasarnya sederhana, sebuah pembungkus di dalamnya hanya alamat yang disimpan, dan metode yang membuat serial panggilan dan menarik prosesor singleton kami, yang melakukan sisanya.  Kami tidak dapat menggunakan pembantu proxy yang ditransmisikan, karena pengguna tidak memberikannya kepada kami, jadi kami harus menjadikannya singleton. <br><br>  Trik lain - pada kenyataannya, kita masih menggunakan konteks panggilan, ini adalah objek yang menyimpan informasi tentang siapa, kapan, mengapa, mengapa kontrak pintar kita dipanggil, berdasarkan informasi ini, pengguna membuat keputusan apakah akan melakukan eksekusi sama sekali, dan jika mungkin lalu bagaimana. <br><br>  Sebelumnya, kami hanya melewati konteks, itu adalah bidang yang tidak bisa diekspresikan dalam tipe BaseContract dengan setter dan pengambil, dan setter tersebut memungkinkan pengaturan bidang hanya sekali, jadi konteksnya ditetapkan sebelum kontrak dieksekusi, dan pengguna hanya bisa membacanya. <br><br>  Tapi di sini masalahnya, pengguna hanya membaca konteks ini, jika ia membuat panggilan ke beberapa jenis fungsi sistem, misalnya, panggilan proxy ke kontrak lain, maka panggilan proxy ini tidak menerima konteks apa pun, karena tidak ada yang meneruskannya kepadanya.  Dan kemudian penyimpanan lokal goroutine memasuki lokasi.  Kami memutuskan untuk tidak menulis sendiri, tetapi gunakan github.com/tylerb/gls. <br><br>  Ini memungkinkan Anda untuk mengatur dan mengambil konteks untuk goroutine saat ini.  Jadi, jika tidak ada goroutine yang dibuat di dalam kontrak, kami hanya mengatur konteks di gls sebelum memulai kontrak, sekarang kami memberikan pengguna bukan metode, tetapi hanya sebuah fungsi. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">core</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicCallContext</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gls.Get(<span class="hljs-string"><span class="hljs-string">"ctx"</span></span>).(*core.LogicCallContext) }</code> </pre> <br>  Dan dia dengan senang hati menggunakannya, tetapi kami menggunakannya di RouteCall (), misalnya, untuk memahami kontrak mana yang saat ini meminta seseorang. <br><br>  Pada prinsipnya, pengguna dapat membuat goroutine, tetapi jika dia melakukannya, maka konteksnya hilang, jadi kita perlu melakukan sesuatu dengan ini, misalnya, jika pengguna menggunakan kata kunci go, maka kita harus membungkus panggilan tersebut di bungkus kami, yang konteksnya akan mengingat dan membuat goroutine dan kembalikan konteks di dalamnya, tetapi ini adalah topik dari artikel lain. <br><br><h2>  Semuanya bersama </h2><br>  Kami pada dasarnya menyukai cara kerja toolchain bahasa GO, pada kenyataannya itu adalah banyak perintah berbeda yang melakukan satu hal, yang dieksekusi bersama ketika Anda membangun, misalnya.  Kami memutuskan untuk melakukan hal yang sama, satu tim menempatkan file kontrak di direktori sementara, yang kedua menempatkan pembungkus untuknya di sebelahnya dan memanggil yang ketiga kalinya, yang membuat proxy untuk setiap kontrak yang diimpor, yang keempat mengkompilasi semuanya, yang kelima menerbitkannya di blockchain.  Dan ada satu perintah untuk menjalankan semuanya dalam urutan yang benar. <br><br>  Hore, kami sekarang memiliki toolchain dan runtime untuk meluncurkan GO dari GO.  Masih ada banyak masalah, misalnya, Anda perlu membongkar kode yang tidak terpakai, Anda perlu menentukan apakah itu hang dan memulai kembali proses yang ditangguhkan, tetapi ini adalah tugas yang jelas bagaimana menyelesaikannya. <br><br>  Ya, tentu saja, kode yang kami tulis tidak berpura-pura menjadi perpustakaan, itu tidak dapat digunakan secara langsung, tetapi membaca contoh pembuatan kode kerja selalu bagus, pada satu waktu saya melewatkannya.  Dengan demikian, bagian dari pembuatan kode dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompiler</a> , tetapi bagaimana itu dimulai di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelaksana</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425985/">https://habr.com/ru/post/id425985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425973/index.html">Bagaimana kami membangun penyimpanan S3 DataLine. Eksperimen, pengujian, dan sedikit tentang kuda nil</a></li>
<li><a href="../id425975/index.html">Ubah kata dan frasa menjadi anagram</a></li>
<li><a href="../id425977/index.html">Flexbox: seberapa besar kotak fleksibel ini?</a></li>
<li><a href="../id425981/index.html">Karier Pemula di LK: Melompat dan maju perlahan-lahan tumbuh maju</a></li>
<li><a href="../id425983/index.html">Keamanan penerbangan</a></li>
<li><a href="../id425989/index.html">Di bawah tenda Graveyard Keeper: Bagaimana efek grafis diimplementasikan</a></li>
<li><a href="../id425991/index.html">Bagaimana kami menciptakan hosting</a></li>
<li><a href="../id425993/index.html">Bagaimana menjembatani kesenjangan gender dalam teknologi</a></li>
<li><a href="../id425995/index.html">Visualisasikan FHIR - Standar TI untuk Kedokteran</a></li>
<li><a href="../id425997/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 11: Bahasa Pemrograman Web / Web, Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>