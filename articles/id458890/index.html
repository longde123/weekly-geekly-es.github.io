<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔊 👕 🛡️ Pengambilan sampel dan akurasi perhitungan 👗 🎳 🎀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sejumlah kolega saya dihadapkan dengan masalah bahwa untuk menghitung beberapa jenis metrik, misalnya, tingkat konversi, Anda harus memvalidasi seluru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengambilan sampel dan akurasi perhitungan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458890/"><p>  Sejumlah kolega saya dihadapkan dengan masalah bahwa untuk menghitung beberapa jenis metrik, misalnya, tingkat konversi, Anda harus memvalidasi seluruh basis data.  Atau Anda perlu melakukan studi terperinci untuk setiap klien, di mana ada jutaan pelanggan.  Kerry jenis ini dapat bekerja cukup lama, bahkan dalam repositori yang dibuat khusus.  Tidak terlalu menyenangkan untuk menunggu 5-15-40 menit sampai metrik sederhana dianggap mengetahui bahwa Anda perlu menghitung sesuatu yang lain atau menambahkan sesuatu yang lain. </p><br><p>  Salah satu solusi untuk masalah ini adalah pengambilan sampel: kami tidak mencoba menghitung metrik kami pada seluruh array data, tetapi mengambil subset yang secara representatif mewakili metrik yang kami butuhkan.  Sampel ini bisa 1000 kali lebih kecil dari susunan data kami, tetapi cukup baik untuk menunjukkan angka yang kami butuhkan. </p><br><p>  Dalam artikel ini, saya memutuskan untuk menunjukkan bagaimana ukuran sampel sampel memengaruhi kesalahan metrik akhir. </p><a name="habracut"></a><br><h2 id="problema">  Masalah </h2><br><p>  Pertanyaan kuncinya adalah: seberapa baik sampel menggambarkan “populasi”?  Karena kami mengambil sampel dari array umum, metrik yang kami terima ternyata menjadi variabel acak.  Sampel yang berbeda akan memberi kita hasil metrik yang berbeda.  Beda, tidak berarti apa-apa.  Teori probabilitas memberi tahu kita bahwa nilai metrik yang diperoleh dengan pengambilan sampel harus dikelompokkan di sekitar nilai metrik sebenarnya (dibuat di atas seluruh sampel) dengan tingkat kesalahan tertentu.  Selain itu, kita sering mengalami masalah di mana tingkat kesalahan yang berbeda dapat ditiadakan.  Adalah satu hal untuk mengetahui apakah kami mendapatkan konversi 50% atau 10%, dan itu hal lain untuk mendapatkan hasil dengan akurasi 50,01% vs 50,02%. </p><br><p>  Sangat menarik bahwa dari sudut pandang teori, koefisien konversi yang diamati oleh kami atas seluruh sampel juga merupakan variabel acak, karena  Tingkat konversi "teoritis" hanya dapat dihitung pada sampel dengan ukuran tak terbatas.  Ini berarti bahwa bahkan semua pengamatan kami dalam basis data benar-benar memberikan perkiraan konversi dengan keakuratannya, meskipun bagi kami angka-angka yang dihitung ini benar-benar akurat.  Ini juga mengarah pada kesimpulan bahwa bahkan jika hari ini tingkat konversi berbeda dari kemarin, ini tidak berarti bahwa sesuatu telah berubah, tetapi hanya berarti bahwa sampel saat ini (semua pengamatan dalam database) berasal dari populasi umum (semua mungkin pengamatan untuk hari ini, yang terjadi dan tidak terjadi) memberikan hasil yang sedikit berbeda dari kemarin.  Bagaimanapun, untuk setiap produk atau analis yang jujur, ini harus menjadi hipotesis dasar. </p><br><h2 id="formulirovka-zadachi">  Pernyataan tugas </h2><br><p>  Katakanlah kita memiliki 1.000.000 catatan dalam database tipe 0/1, yang memberi tahu kami apakah konversi telah terjadi pada suatu acara.  Maka tingkat konversi hanyalah jumlah 1 dibagi 1 juta. </p><br><p>  Pertanyaan: jika kita mengambil sampel berukuran N, berapa banyak dan dengan probabilitas apa perbedaan tingkat konversi dari yang dihitung atas seluruh sampel? </p><br><h2 id="teoreticheskie-rassuzhdeniya">  Pertimbangan teoretis </h2><br><p>  Tugas dikurangi untuk menghitung interval kepercayaan dari koefisien konversi untuk sampel dengan ukuran tertentu untuk distribusi binomial. </p><br><p>  Dari teori, simpangan baku untuk distribusi binomial adalah: <br>  S = sqrt (p * (1 - p) / N) </p><br><p>  Dimana <br>  p - tingkat konversi <br>  N - Ukuran Sampel <br>  S - standar deviasi </p><br><p>  Saya tidak akan mempertimbangkan interval kepercayaan langsung dari teori.  Ada matan yang agak rumit dan membingungkan, yang akhirnya menghubungkan standar deviasi dan estimasi akhir dari interval kepercayaan. </p><br><p>  Mari kita kembangkan "intuisi" tentang rumus standar deviasi: </p><br><ol><li>  Semakin besar ukuran sampel, semakin kecil kesalahannya.  Dalam kasus ini, kesalahan jatuh dalam ketergantungan kuadrat terbalik, mis.  menambah sampel sebanyak 4 kali meningkatkan akurasi hanya 2 kali.  Ini berarti bahwa pada titik tertentu meningkatkan ukuran sampel tidak akan memberikan keuntungan tertentu, dan juga berarti bahwa akurasi yang cukup tinggi dapat diperoleh dengan sampel yang cukup kecil. </li></ol><br><p><img src="https://habrastorage.org/webt/gw/e-/mc/gwe-mczmjmsdsq8ezxuulsf6ito.png"></p><br><ol><li>  Ada ketergantungan kesalahan pada nilai tingkat konversi.  Kesalahan relatif (yaitu, rasio kesalahan dengan nilai tingkat konversi) memiliki kecenderungan "keji" untuk menjadi lebih besar, semakin rendah tingkat konversi: </li></ol><br><p><img src="https://habrastorage.org/webt/4x/9y/0t/4x9y0t_ornj-056s43ejtdovfle.png"></p><br><ol><li>  Seperti yang kita lihat, kesalahan "terbang" ke langit dengan tingkat konversi yang rendah.  Ini berarti bahwa jika Anda mencicipi peristiwa langka, maka Anda memerlukan ukuran sampel yang besar, jika tidak, Anda akan mendapatkan taksiran konversi dengan kesalahan yang sangat besar. </li></ol><br><h2 id="modelirovanie">  Pemodelan </h2><br><p>  Kita dapat sepenuhnya menjauh dari solusi teoretis dan menyelesaikan masalah "langsung".  Berkat bahasa R, ini sekarang sangat mudah dilakukan.  Untuk menjawab pertanyaan, kesalahan apa yang kita dapatkan saat pengambilan sampel, Anda bisa melakukan seribu sampel dan melihat kesalahan apa yang kita dapatkan. </p><br><p>  Pendekatannya adalah ini: </p><br><ol><li>  Kami mengambil tingkat konversi yang berbeda (dari 0,01% menjadi 50%). </li><li>  Kami mengambil 1000 sampel dari 10, 100, 1000, 10.000, 50.000, 100.000, 250.000, 500.000 elemen dalam sampel </li><li>  Kami menghitung tingkat konversi untuk setiap kelompok sampel (1000 koefisien) </li><li>  Kami menyusun histogram untuk setiap kelompok sampel dan menentukan sejauh mana tingkat konversi 60%, 80%, dan 90% yang diamati berada. </li></ol><br><p>  Data penghasil kode R: </p><br><pre><code class="plaintext hljs">sample.size &lt;- c(10, 100, 1000, 10000, 50000, 100000, 250000, 500000) bootstrap = 1000 Error &lt;- NULL len = 1000000 for (prob in c(0.0001, 0.001, 0.01, 0.1, 0.5)){ CRsub &lt;- data.table(sample_size = 0, CR = 0) v1 = seq(1,len) v2 = rbinom(len, 1, prob) set = data.table(index = v1, conv = v2) print(paste('probability is: ', prob)) for (j in 1:length(sample.size)){ for(i in 1:bootstrap){ ss &lt;- sample.size[j] subset &lt;- set[round(runif(ss, min = 1, max = len),0),] CRsample &lt;- sum(subset$conv)/dim(subset)[1] CRsub &lt;- rbind(CRsub, data.table(sample_size = ss, CR = CRsample)) } print(paste('sample size is:', sample.size[j])) q &lt;- quantile(CRsub[sample_size == ss, CR], probs = c(0.05,0.1, 0.2, 0.8, 0.9, 0.95)) Error &lt;- rbind(Error, cbind(prob,ss,t(q))) }</code> </pre> <br><p>  Hasilnya, kita mendapatkan tabel berikut (akan ada grafik nanti, tetapi detailnya lebih baik terlihat dalam tabel). </p><br><div class="scrollable-table"><table><thead><tr><th>  Tingkat konversi </th><th>  Ukuran sampel </th><th>  5% </th><th>  10% </th><th>  20% </th><th>  80% </th><th>  90% </th><th>  95% </th></tr></thead><tbody><tr><td>  0,0001 </td><td>  10 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0,0001 </td><td>  100 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0,0001 </td><td>  1000 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0,001 </td></tr><tr><td>  0,0001 </td><td>  10.000 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0,0002 </td><td>  0,0002 </td><td>  0,0003 </td></tr><tr><td>  0,0001 </td><td>  50.000 </td><td>  0,00004 </td><td>  0,00004 </td><td>  0,00006 </td><td>  0,00014 </td><td>  0,00016 </td><td>  0,00018 </td></tr><tr><td>  0,0001 </td><td>  100.000 </td><td>  0,00005 </td><td>  0,00006 </td><td>  0,00007 </td><td>  0,00013 </td><td>  0,00014 </td><td>  0,00016 </td></tr><tr><td>  0,0001 </td><td>  250000 </td><td>  0,000072 </td><td>  0,0000796 </td><td>  0,000088 </td><td>  0,00012 </td><td>  0,000128 </td><td>  0,000136 </td></tr><tr><td>  0,0001 </td><td>  500.000 </td><td>  0,00008 </td><td>  0,000084 </td><td>  0,000092 </td><td>  0,000114 </td><td>  0,000122 </td><td>  0,000128 </td></tr><tr><td>  0,001 </td><td>  10 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0,001 </td><td>  100 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0,01 </td></tr><tr><td>  0,001 </td><td>  1000 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0,002 </td><td>  0,002 </td><td>  0,003 </td></tr><tr><td>  0,001 </td><td>  10.000 </td><td>  0,0005 </td><td>  0,0006 </td><td>  0,0007 </td><td>  0,0013 </td><td>  0,0014 </td><td>  0,0016 </td></tr><tr><td>  0,001 </td><td>  50.000 </td><td>  0,0008 </td><td>  0,000858 </td><td>  0,00092 </td><td>  0,00116 </td><td>  0,00122 </td><td>  0,00126 </td></tr><tr><td>  0,001 </td><td>  100.000 </td><td>  0,00087 </td><td>  0,00091 </td><td>  0,00095 </td><td>  0,00112 </td><td>  0,00116 </td><td>  0,0012105 </td></tr><tr><td>  0,001 </td><td>  250000 </td><td>  0,00092 </td><td>  0,000948 </td><td>  0,000972 </td><td>  0,001084 </td><td>  0,001116 </td><td>  0,0011362 </td></tr><tr><td>  0,001 </td><td>  500.000 </td><td>  0,000952 </td><td>  0,0009698 </td><td>  0,000988 </td><td>  0,001066 </td><td>  0,001086 </td><td>  0,0011041 </td></tr><tr><td>  0,01 </td><td>  10 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0,1 </td></tr><tr><td>  0,01 </td><td>  100 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0,02 </td><td>  0,02 </td><td>  0,03 </td></tr><tr><td>  0,01 </td><td>  1000 </td><td>  0,006 </td><td>  0,006 </td><td>  0,008 </td><td>  0,013 </td><td>  0,014 </td><td>  0,015 </td></tr><tr><td>  0,01 </td><td>  10.000 </td><td>  0,0086 </td><td>  0,0089 </td><td>  0,0092 </td><td>  0,0109 </td><td>  0,0114 </td><td>  0,0118 </td></tr><tr><td>  0,01 </td><td>  50.000 </td><td>  0,0093 </td><td>  0,0095 </td><td>  0,0097 </td><td>  0,0104 </td><td>  0,0106 </td><td>  0,0108 </td></tr><tr><td>  0,01 </td><td>  100.000 </td><td>  0,0095 </td><td>  0,0096 </td><td>  0,0098 </td><td>  0,0103 </td><td>  0,0104 </td><td>  0,0106 </td></tr><tr><td>  0,01 </td><td>  250000 </td><td>  0,0097 </td><td>  0,0098 </td><td>  0,0099 </td><td>  0,0102 </td><td>  0,0103 </td><td>  0,0104 </td></tr><tr><td>  0,01 </td><td>  500.000 </td><td>  0,0098 </td><td>  0,0099 </td><td>  0,0099 </td><td>  0,0102 </td><td>  0,0102 </td><td>  0,0103 </td></tr><tr><td>  0,1 </td><td>  10 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0,2 </td><td>  0,2 </td><td>  0,3 </td></tr><tr><td>  0,1 </td><td>  100 </td><td>  0,05 </td><td>  0,06 </td><td>  0,07 </td><td>  0,13 </td><td>  0,14 </td><td>  0,15 </td></tr><tr><td>  0,1 </td><td>  1000 </td><td>  0,086 </td><td>  0,0889 </td><td>  0,093 </td><td>  0,108 </td><td>  0,1121 </td><td>  0,117 </td></tr><tr><td>  0,1 </td><td>  10.000 </td><td>  0,0954 </td><td>  0,0963 </td><td>  0,0979 </td><td>  0,1028 </td><td>  0,1041 </td><td>  0,1055 </td></tr><tr><td>  0,1 </td><td>  50.000 </td><td>  0,098 </td><td>  0,0986 </td><td>  0,0992 </td><td>  0,1014 </td><td>  0,1019 </td><td>  0,1024 </td></tr><tr><td>  0,1 </td><td>  100.000 </td><td>  0,0987 </td><td>  0,099 </td><td>  0,0994 </td><td>  0,1011 </td><td>  0,1014 </td><td>  0,1018 </td></tr><tr><td>  0,1 </td><td>  250000 </td><td>  0,0993 </td><td>  0,0995 </td><td>  0,0998 </td><td>  0,1008 </td><td>  0,1011 </td><td>  0,1013 </td></tr><tr><td>  0,1 </td><td>  500.000 </td><td>  0,0996 </td><td>  0,0998 </td><td>  0,1 </td><td>  0,1007 </td><td>  0,1009 </td><td>  0,101 </td></tr><tr><td>  0,5 </td><td>  10 </td><td>  0,2 </td><td>  0,3 </td><td>  0,4 </td><td>  0,6 </td><td>  0,7 </td><td>  0.8 </td></tr><tr><td>  0,5 </td><td>  100 </td><td>  0,42 </td><td>  0,44 </td><td>  0,46 </td><td>  0,54 </td><td>  0,56 </td><td>  0,58 </td></tr><tr><td>  0,5 </td><td>  1000 </td><td>  0,473 </td><td>  0,478 </td><td>  0,486 </td><td>  0,513 </td><td>  0,52 </td><td>  0,525 </td></tr><tr><td>  0,5 </td><td>  10.000 </td><td>  0,4922 </td><td>  0,4939 </td><td>  0,4959 </td><td>  0,5044 </td><td>  0,5061 </td><td>  0,5078 </td></tr><tr><td>  0,5 </td><td>  50.000 </td><td>  0,4962 </td><td>  0,4968 </td><td>  0,4978 </td><td>  0,5018 </td><td>  0,5028 </td><td>  0,5036 </td></tr><tr><td>  0,5 </td><td>  100.000 </td><td>  0,4974 </td><td>  0,4979 </td><td>  0,4986 </td><td>  0,5014 </td><td>  0,5021 </td><td>  0,5027 </td></tr><tr><td>  0,5 </td><td>  250000 </td><td>  0,4984 </td><td>  0,4987 </td><td>  0,4992 </td><td>  0,5008 </td><td>  0,5013 </td><td>  0,5017 </td></tr><tr><td>  0,5 </td><td>  500.000 </td><td>  0,4988 </td><td>  0,4991 </td><td>  0,4994 </td><td>  0,5006 </td><td>  0,5009 </td><td>  0,5011 </td></tr></tbody></table></div><br><p>  Mari kita lihat kasus dengan konversi 10% dan dengan konversi 0,01% rendah, karena  semua fitur bekerja dengan sampling terlihat jelas pada mereka. </p><br><p>  Pada konversi 10%, gambar terlihat sangat sederhana: </p><br><p><img src="https://habrastorage.org/webt/qz/n-/k7/qzn-k7kgvtlilgfg1yqjfuj7vog.png"></p><br><p>  Poin adalah tepi dari interval kepercayaan 5-95%, mis.  membuat sampel, kami akan dalam 90% kasus mendapatkan CR pada sampel dalam interval ini.  Skala vertikal - ukuran sampel (skala logaritmik), horizontal - nilai tingkat konversi.  Bilah vertikal adalah CR "benar". </p><br><p>  Kami melihat hal yang sama yang kami lihat dari model teoretis: akurasi meningkat ketika ukuran sampel bertambah, dan satu konvergen cukup cepat dan sampel mendapatkan hasil mendekati "benar".  Total untuk 1000 sampel kami memiliki 8,6% - 11,7%, yang akan cukup untuk sejumlah tugas.  Dan dalam 10 ribu sudah 9,5% - 10,55%. </p><br><p>  Hal-hal buruk dengan kejadian langka dan ini konsisten dengan teori: </p><br><p><img src="https://habrastorage.org/webt/bu/rt/cy/burtcyycddxkmqy4kmgyoirmboc.png"></p><br><p>  Pada tingkat konversi yang rendah 0,01%, masalahnya adalah statistik pada 1 juta pengamatan, dan dengan sampel situasinya bahkan lebih buruk.  Kesalahannya hanya raksasa.  Pada sampel hingga 10.000, metrik pada prinsipnya tidak valid.  Misalnya, pada sampel 10 pengamatan, generator saya baru saja 0 konversi 1000 kali, jadi hanya ada 1 poin.  Pada 100 ribu, kita memiliki sebaran dari 0,005% hingga 0,0016%, yaitu kita dapat membuat hampir setengah koefisien dengan pengambilan sampel seperti itu. </p><br><p>  Perlu juga dicatat bahwa ketika Anda mengamati konversi dalam skala kecil hingga 1 juta uji coba, maka Anda hanya memiliki kesalahan alami yang besar.  Dari sini dapat disimpulkan bahwa dinamika kejadian langka seperti itu harus dilakukan pada sampel yang sangat besar, jika tidak, Anda hanya mengejar hantu, fluktuasi acak dalam data. </p><br><p>  Kesimpulan: </p><br><ol><li>  Mengambil sampel metode kerja untuk mendapatkan taksiran </li><li>  Akurasi sampel meningkat dengan meningkatnya ukuran sampel dan berkurang dengan penurunan tingkat konversi. </li><li>  Keakuratan estimasi dapat dimodelkan untuk tugas Anda dan dengan demikian pilih sampel yang optimal untuk Anda sendiri. </li><li>  Penting untuk diingat bahwa peristiwa langka tidak dapat dicicipi dengan baik </li><li>  Secara umum, kejadian langka sulit untuk dianalisis, mereka memerlukan sampel data besar tanpa sampel. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458890/">https://habr.com/ru/post/id458890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458880/index.html">Pengembangan Linux pada Windows dengan WSL dan Visual Studio Code Remote</a></li>
<li><a href="../id458882/index.html">Berbicara di depan umum. Secara singkat tentang hal utama</a></li>
<li><a href="../id458884/index.html">Sedikit tentang standar komunikasi ruang</a></li>
<li><a href="../id458886/index.html">Desain Mail.ru Yang Paling Berguna, Conf × Dribbble Meetup 2019 Papers oleh True Engineering</a></li>
<li><a href="../id458888/index.html">Pertemuan Droid Musim Panas</a></li>
<li><a href="../id458892/index.html">Saran untuk Kerentanan dan Perlindungan Model Pembelajaran Mesin</a></li>
<li><a href="../id458894/index.html">Orang-orang biasa dan jaringan tempat mereka tinggal</a></li>
<li><a href="../id458896/index.html">JavaScript Fungsional: apa fungsi tingkat tinggi dan mengapa diperlukan?</a></li>
<li><a href="../id458900/index.html">Kartrid konsol sebagai modem</a></li>
<li><a href="../id458902/index.html">5 Kesalahan Umum Pemula Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>