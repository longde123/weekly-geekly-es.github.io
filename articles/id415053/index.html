<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé± ‚òÆÔ∏è üöΩ Mengapa prosesor Skylake terkadang berjalan 2 kali lebih lambat üë©üèæ ‚åõÔ∏è üê∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya diberitahu bahwa di komputer baru, beberapa tes regresi menjadi lebih lambat. Suatu hal yang biasa terjadi. Konfigurasi yang salah di suatu tempa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa prosesor Skylake terkadang berjalan 2 kali lebih lambat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415053/">  Saya diberitahu bahwa di komputer baru, beberapa tes regresi menjadi lebih lambat.  Suatu hal yang biasa terjadi.  Konfigurasi yang salah di suatu tempat di Windows atau bukan nilai-nilai paling optimal di BIOS.  Tetapi kali ini kami tidak dapat menemukan pengaturan "knock down" yang sama.  Karena perubahannya signifikan: 9 vs 19 detik (pada tabel, biru adalah besi tua dan oranye adalah yang baru), saya harus menggali lebih dalam. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a9/6db/d57/4a96dbd573606b0a0aabc6a0874dd2fa.png"><br><a name="habracut"></a><br><h1>  OS yang sama, perangkat keras yang sama, prosesor yang berbeda: 2 kali lebih lambat </h1><br>  Penurunan kinerja dari 9,1 ke 19,6 detik pasti bisa disebut signifikan.  Kami melakukan pemeriksaan tambahan dengan perubahan dalam versi program yang diuji, pengaturan Windows dan BIOS.  Tapi tidak, hasilnya tidak berubah.  Satu-satunya perbedaan hanya muncul pada prosesor yang berbeda.  Di bawah ini adalah hasil dari CPU terbaru. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a2/fc8/12e/6a2fc812e9f12ae4581b9ed3fd46c4b7.png"><br><br>  Dan inilah yang digunakan untuk perbandingan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e81/f8b/d4f/e81f8bd4f20ffe609673ef3db6dd414d.png"><br><br>  Xeon Gold berjalan pada arsitektur yang berbeda yang disebut Skylake, yang umum untuk prosesor Intel baru sejak pertengahan 2017.  Jika Anda membeli perangkat keras terbaru, Anda akan mendapatkan prosesor dengan arsitektur Skylake.  Ini adalah mobil yang bagus, tetapi, seperti yang ditunjukkan oleh tes, kebaruan dan kecepatan bukanlah hal yang sama. <br><br>  Jika tidak ada yang membantu, maka Anda perlu menggunakan profiler untuk penelitian mendalam.  Mari kita uji pada peralatan lama dan baru dan dapatkan sesuatu seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b3/6a3/98e/3b36a398e5ee9ce0950c1d940f3de9c7.png"><br><br>  Tab di Windows Performance Analyzer (WPA) menunjukkan dalam tabel perbedaan antara Jejak 2 (11 detik) dan Jejak 1 (19 detik).  Perbedaan negatif dalam tabel terkait dengan peningkatan konsumsi CPU dalam tes yang lebih lambat.  Jika Anda melihat perbedaan paling signifikan dalam konsumsi CPU, kita akan melihat <i>AwareLock :: Contention</i> , <i>JIT_MonEnterWorker_InlineGetThread_GetThread_GetThread_PatchLabel</i> dan <i>ThreadNative.SpinWait</i> .  Semuanya menunjukkan "berputar" dalam CPU [berputar - upaya siklus untuk mendapatkan kunci, kira-kira.  per.], saat utas bertarung untuk memblokir.  Tetapi ini adalah tanda yang salah, karena pemintalan bukanlah alasan utama penurunan produktivitas.  Meningkatnya persaingan untuk kunci berarti bahwa sesuatu dalam perangkat lunak kami telah melambat dan mempertahankan kunci, yang akibatnya menyebabkan peningkatan pemintalan dalam CPU.  Saya memeriksa waktu kunci dan indikator kunci lainnya, seperti kinerja disk, tetapi saya tidak dapat menemukan sesuatu yang berarti yang dapat menjelaskan penurunan kinerja.  Meskipun ini tidak logis, tetapi saya kembali meningkatkan beban pada CPU dalam berbagai metode. <br><br>  Akan menarik untuk menemukan di mana prosesor macet.  WPA memiliki kolom # dan baris # file, tetapi hanya bekerja dengan karakter pribadi, yang tidak kami miliki, karena ini adalah kode .NET Framework.  Hal terbaik berikutnya yang bisa kita lakukan adalah mendapatkan alamat dll di mana instruksi yang disebut Image RVA berada.  Jika Anda memuat dll ini ke debugger dan lakukan <br><br> <code>u xxx.dll+ImageRVA</code> <br> <br>  maka kita akan melihat instruksi yang membakar sebagian besar siklus CPU, karena itu akan menjadi satu-satunya alamat "panas". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fe/54e/e7b/9fe54ee7bfe194a0e6fec932148f730c.png"><br><br>  Kami akan memeriksa alamat ini menggunakan berbagai metode Windbg: <br><br> <code>0:000&gt; u clr.dll+0x19566B-10 <br> clr!AwareLock::Contention+0x135: <br> 00007ff8`0535565b f00f4cc6 lock cmovl eax,esi <br> 00007ff8`0535565f 2bf0 sub esi,eax <br> 00007ff8`05355661 eb01 jmp clr!AwareLock::Contention+0x13f (00007ff8`05355664) <br> 00007ff8`05355663 cc int 3 <br> 00007ff8`05355664 83e801 sub eax,1 <br> 00007ff8`05355667 7405 je clr!AwareLock::Contention+0x144 (00007ff8`0535566e) <br> 00007ff8`05355669 f390 pause <br> 00007ff8`0535566b ebf7 jmp clr!AwareLock::Contention+0x13f (00007ff8`05355664)</code> <br> <br>  Dan dengan berbagai metode JIT: <br><br> <code>0:000&gt; u clr.dll+0x2801-10 <br> clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x124: <br> 00007ff8`051c27f1 5e pop rsi <br> 00007ff8`051c27f2 c3 ret <br> 00007ff8`051c27f3 833d0679930001 cmp dword ptr [clr!g_SystemInfo+0x20 (00007ff8`05afa100)],1 <br> 00007ff8`051c27fa 7e1b jle clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x14a (00007ff8`051c2817) <br> 00007ff8`051c27fc 418bc2 mov eax,r10d <br> 00007ff8`051c27ff f390 pause <br> 00007ff8`051c2801 83e801 sub eax,1 <br> 00007ff8`051c2804 75f9 jne clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x132 (00007ff8`051c27ff)</code> <br> <br>  Sekarang kami memiliki templat.  Dalam satu kasus, alamat panas adalah pernyataan lompatan, dan dalam kasus lain, itu adalah pengurangan.  Namun kedua instruksi panas tersebut didahului oleh pernyataan jeda umum yang sama.  Metode yang berbeda menjalankan instruksi prosesor yang sama, yang karena alasan tertentu membutuhkan waktu yang sangat lama.  Mari kita mengukur kecepatan eksekusi pernyataan jeda dan melihat apakah kita beralasan dengan benar. <br><br><h1>  Jika masalah didokumentasikan, maka itu menjadi fitur. </h1><br><table cellpadding="2" width="400" border="1"><tbody><tr><td width="224">  <strong>CPU</strong> </td><td width="176">  <strong>jeda dalam nanodetik</strong> </td></tr><tr><td width="224">  Xeon E5 1620v3 3.5 GHz </td><td width="176">  4 </td></tr><tr><td width="224">  Xeon¬Æ Gold 6126 @ 2.60 GHz </td><td width="176">  43 </td></tr></tbody></table><br>  Jeda dalam prosesor Skylake baru membutuhkan urutan besarnya lebih lama.  Tentu saja, apa pun bisa menjadi lebih cepat, dan kadang-kadang sedikit lebih lambat.  Tapi <b>sepuluh kali</b> lebih lambat?  Ini lebih seperti bug.  Pencarian kecil di Internet tentang jeda instruksi mengarah ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual Intel</a> , yang secara eksplisit menyebutkan mikroarsitektur Skylake dan instruksi jeda: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ca/c9f/30c/8cac9f30cd834d8c47eeab6297dda445.png"><br><br>  Tidak, ini bukan kesalahan, ini adalah fungsi yang terdokumentasi.  Bahkan ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman yang</a> menunjukkan waktu pelaksanaan hampir semua instruksi prosesor. <br><br><ul><li>  Jembatan berpasir 11 </li><li>  Ivy Bridege 10 </li><li>  Haswell 9 </li><li>  Broadwell 9 </li><li>  SkylakeX 141 </li></ul><br>  Jumlah siklus prosesor ditunjukkan di sini.  Untuk menghitung waktu aktual, Anda perlu membagi jumlah siklus dengan frekuensi prosesor (biasanya dalam GHz) dan mendapatkan waktu dalam nanodetik. <br><br>  Ini berarti bahwa jika Anda menjalankan aplikasi yang sangat banyak-ulir di .NET pada perangkat keras terakhir, maka mereka dapat bekerja jauh lebih lambat.  Seseorang sudah memperhatikan ini dan pada Agustus 2017 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendaftarkan bug</a> .  Masalah telah <a href="">diperbaiki</a> di .NET Core 2.1 dan .NET Framework 4.8 Pratinjau. <br><br><blockquote>  Spin-wait yang ditingkatkan di beberapa primitif sinkronisasi untuk kinerja yang lebih baik pada Intel Skylake dan mikroarsitektur selanjutnya.  [495945, mscorlib.dll, Bug] </blockquote><br>  Tetapi karena masih ada satu tahun sebelum rilis. NET 4.8, saya diminta untuk mendukung perbaikan sehingga .NET 4.7.2 kembali ke kecepatan normal pada prosesor baru.  Karena ada kunci yang saling eksklusif (spinlocks) di banyak bagian. NET, Anda harus melacak peningkatan beban CPU ketika Thread.SpinWait dan metode pemintalan lainnya berfungsi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c35/a11/ec8/c35a11ec843bb50b6a4c96906fa705f1.png"><br><br>  Sebagai contoh, Task.Result secara internal menggunakan pemintalan, jadi saya mengantisipasi peningkatan beban CPU yang signifikan dan kinerja yang lebih rendah dalam pengujian lain. <br><br><h1>  Seberapa buruk itu? </h1><br>  Saya melihat kode .NET Core untuk berapa lama prosesor akan terus berputar jika kunci tidak dilepaskan sebelum memanggil WaitForSingleObject untuk membayar untuk saklar konteks "mahal".  Switch konteks membutuhkan mikrodetik atau lebih jika banyak thread mengharapkan objek kernel yang sama. <br><br>  .NET mengunci kalikan durasi pemintalan maksimum dengan jumlah inti, jika kita mengambil kasus absolut di mana utas pada setiap inti mengharapkan kunci yang sama dan pemintalan berlanjut cukup lama bagi setiap orang untuk bekerja sedikit sebelum membayar untuk panggilan kernel.  Spinning in .NET menggunakan algoritma penuaan eksponensial ketika dimulai dengan siklus 50 panggilan jeda, di mana untuk setiap iterasi jumlah putaran tiga kali lipat hingga spin counter berikutnya melebihi durasi maksimumnya.  Saya menghitung total durasi pemintalan per prosesor untuk berbagai prosesor dan jumlah core yang berbeda: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/238/63b/ef9/23863bef9c09567a160f8eb3a7c2d8e7.png"><br><br>  Di bawah ini adalah kode pemintalan yang disederhanakan dalam .NET Locks: <br><br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> how .NET <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> spinning during <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> contention minus the <span class="hljs-keyword"><span class="hljs-keyword">Lock</span></span> taking/SwitchToThread/Sleep calls /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="nCores"&gt;&lt;/param&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Spin(<span class="hljs-type"><span class="hljs-type">int</span></span> nCores) { const <span class="hljs-type"><span class="hljs-type">int</span></span> dwRepetitions = <span class="hljs-number"><span class="hljs-number">10</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> dwInitialDuration = <span class="hljs-number"><span class="hljs-number">0x32</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> dwBackOffFactor = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> dwMaximumDuration = <span class="hljs-number"><span class="hljs-number">20</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span> * nCores; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; dwRepetitions; i++) { <span class="hljs-type"><span class="hljs-type">int</span></span> duration = dwInitialDuration; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; duration; k++) { Call_PAUSE(); } duration *= dwBackOffFactor; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (duration &lt; dwMaximumDuration); } }</code> </pre> <br>  Sebelumnya, waktu pemintalan berada dalam interval milidetik (19 ms untuk 24 core), yang sudah banyak dibandingkan dengan waktu perpindahan konteks yang disebutkan sebelumnya, yang merupakan urutan besarnya lebih cepat.  Tetapi dalam prosesor Skylake, total waktu pemintalan untuk prosesor hanya meledak hingga 246 ms pada mesin 24-bit atau 48-core, hanya karena instruksi jeda melambat 14 kali.  Benarkah ini?  Saya menulis tester kecil untuk memeriksa keseluruhan pemintalan pada CPU - dan angka yang dihitung sesuai dengan harapan.  Berikut adalah 48 utas pada CPU 24-inti menunggu satu kunci, yang saya sebut Monitor.PulseAll: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f9/6ad/e20/2f96ade20f682b4e7efe8a65d760e87e.png"><br><br>  Hanya satu utas yang akan memenangkan perlombaan, tetapi 47 akan terus berputar sampai mereka kehilangan detak jantung.  Ini adalah bukti eksperimental bahwa kami benar-benar memiliki masalah beban CPU dan pemintalan yang sangat lama adalah nyata.  Ini merongrong skalabilitas, karena siklus ini bukan pekerjaan yang bermanfaat dari utas lainnya, meskipun instruksi jeda membebaskan beberapa sumber daya bersama CPU, menyediakan tidur untuk waktu yang lebih lama.  Alasan pemintalan adalah upaya untuk mendapatkan kunci lebih cepat tanpa mengakses kernel.  Jika demikian, maka meningkatkan beban pada CPU hanya akan nominal, tetapi tidak mempengaruhi kinerja sama sekali, karena kernel terlibat dalam tugas-tugas lain.  Tetapi tes menunjukkan penurunan kinerja dalam operasi berulir tunggal hampir, di mana satu utas menambahkan sesuatu ke antrian kerja, sedangkan utas kerja mengharapkan hasilnya, dan kemudian melakukan tugas tertentu dengan item kerja. <br><br>  Alasannya paling mudah ditunjukkan dalam diagram.  Putaran permusuhan terjadi dengan tiga kali lipat pemintalan di setiap langkah.  Setelah setiap putaran, kunci diperiksa kembali untuk melihat apakah utas saat ini dapat menerimanya.  Meskipun pemintalan mencoba untuk jujur ‚Äã‚Äãdan beralih dari waktu ke waktu ke utas lainnya untuk membantu mereka menyelesaikan pekerjaan mereka.  Ini meningkatkan kemungkinan melepaskan kunci pada cek berikutnya.  Masalahnya adalah bahwa cek untuk take hanya mungkin dilakukan pada akhir putaran penuh: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dec/def/1fd/decdef1fd8ee504f92375acf31eca87d.png"><br><br>  Misalnya, jika pada awal putaran kelima sebuah kunci menandakan ketersediaan, Anda hanya dapat membawanya pada akhir putaran.  Setelah menghitung durasi putaran putaran terakhir, kami dapat memperkirakan kasus keterlambatan terburuk untuk aliran kami: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/610/b07/173/610b0717341447bc0415e77efaa731c8.png"><br><br>  Banyak milidetik menunggu hingga pemintalan berakhir.  Apakah ini masalah nyata? <br><br>  Saya membuat aplikasi pengujian sederhana yang mengimplementasikan antrian produsen konsumen, di mana alur kerja melakukan setiap item pekerjaan selama 10 ms, dan konsumen memiliki keterlambatan 1-9 ms sebelum item pekerjaan berikutnya.  Ini cukup untuk melihat efeknya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/701/70c/b97/70170cb97d0ac98a07b9733664c304fb.png"><br><br>  Kami melihat untuk keterlambatan 1-2 ms, total durasi adalah 2.2-2.3 dtk, sementara dalam kasus lain pekerjaan lebih cepat hingga 1.2 dtk.  Ini menunjukkan bahwa pemintalan yang berlebihan pada CPU bukan hanya masalah kosmetik dalam aplikasi berlebih.  Ini benar-benar membahayakan threading sederhana dari produsen-konsumen, yang hanya mencakup dua utas.  Untuk proses di atas, data ETW berbicara sendiri: peningkatan pemintalanlah yang menyebabkan keterlambatan yang diamati: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae9/325/01e/ae932501eb724b116bc0aceac8216ef5.png"><br><br>  Jika Anda hati-hati melihat bagian dengan "rem", kita akan melihat 11 ms berputar di area merah, meskipun pekerja (biru muda) telah menyelesaikan pekerjaannya dan telah memberikan kunci itu sejak lama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89d/a51/030/89da5103028ac3b3285fced21f18d8bf.png"><br><br>  Kasing cepat non-degeneratif terlihat jauh lebih baik, di sini hanya 1 ms yang dihabiskan untuk memintal blokir. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ef/220/8a4/6ef2208a4ec2e433fc2f9c8da030adca.png"><br><br>  Saya menggunakan aplikasi uji <i>SkylakeXPause</i> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsip zip</a> berisi kode sumber dan binari untuk .NET Core dan .NET 4.5.  Sebagai perbandingan, saya menginstal .NET 4.8 Pratinjau dengan perbaikan dan .NET Core 2.0, yang masih menerapkan perilaku lama.  Aplikasi ini dirancang untuk .NET Standard 2.0 dan .NET 4.5, menghasilkan exe dan dll.  Sekarang Anda dapat memeriksa perilaku berputar lama dan baru secara berdampingan tanpa perlu memperbaiki apa pun, itu sangat nyaman. <br><br><pre> <code class="hljs pgsql">readonly <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> _LockObject = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-type"><span class="hljs-type">int</span></span> WorkItems; <span class="hljs-type"><span class="hljs-type">int</span></span> CompletedWorkItems; Barrier SyncPoint; <span class="hljs-type"><span class="hljs-type">void</span></span> RunSlowTest() { const <span class="hljs-type"><span class="hljs-type">int</span></span> processingTimeinMs = <span class="hljs-number"><span class="hljs-number">10</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> WorkItemsToSend = <span class="hljs-number"><span class="hljs-number">100</span></span>; Console.WriteLine($"Worker thread works {processingTimeinMs} ms for {WorkItemsToSend} times"); // Test one sender one receiver thread <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> different timings <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> the sender wakes up again // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> send the next <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> item // synchronize worker <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> sender. Ensure that worker starts first <span class="hljs-type"><span class="hljs-type">double</span></span>[] sendDelayTimes = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var sendDelay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sendDelayTimes) { SyncPoint = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Barrier(<span class="hljs-number"><span class="hljs-number">2</span></span>); // one sender one receiver var sw = Stopwatch.StartNew(); Parallel.Invoke(() =&gt; Sender(workItems: WorkItemsToSend, delayInMs: sendDelay), () =&gt; Worker(maxWorkItemsToWork: WorkItemsToSend, workItemProcessTimeInMs: processingTimeinMs)); sw.Stop(); Console.WriteLine($"Send Delay: {sendDelay:F1} ms Work completed in {sw.Elapsed.TotalSeconds:F3} s"); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); // <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> gap <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ETW data so we can differentiate the test runs } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Simulate a worker thread which consumes CPU which <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> triggered <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> the Sender thread /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Worker(<span class="hljs-type"><span class="hljs-type">int</span></span> maxWorkItemsToWork, <span class="hljs-type"><span class="hljs-type">double</span></span> workItemProcessTimeInMs) { SyncPoint.SignalAndWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (CompletedWorkItems != maxWorkItemsToWork) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_LockObject) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WorkItems == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Monitor.Wait(_LockObject); // wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WorkItems; i++) { CompletedWorkItems++; SimulateWork(workItemProcessTimeInMs); // consume CPU under this <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> } WorkItems = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// <span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the Worker thread under a <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wake up the worker thread n times /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Sender(<span class="hljs-type"><span class="hljs-type">int</span></span> workItems, <span class="hljs-type"><span class="hljs-type">double</span></span> delayInMs) { CompletedWorkItems = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> previous <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> SyncPoint.SignalAndWait(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; workItems; i++) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_LockObject) { WorkItems++; Monitor.PulseAll(_LockObject); } SimulateWork(delayInMs); } }</code> </pre> <br><h1>  Kesimpulan </h1><br>  Ini bukan masalah .NET.  Semua implementasi spinlock menggunakan pernyataan jeda dipengaruhi.  Saya dengan cepat memeriksa inti Windows Server 2016, tetapi tidak ada masalah seperti itu di permukaan.  Tampaknya Intel cukup baik - dan mengisyaratkan bahwa beberapa perubahan dalam pendekatan untuk pemintalan diperlukan. <br><br>  Bug untuk .NET Core dilaporkan pada Agustus 2017, dan pada September 2017 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">patch</a> dan versi .NET Core 2.0.3 dirilis.  Tautan tidak hanya menunjukkan reaksi yang sangat baik dari grup .NET Core, tetapi juga fakta bahwa beberapa hari yang lalu masalah telah diperbaiki di cabang utama, serta diskusi tentang optimasi pemintalan tambahan.  Sayangnya, Desktop .NET Framework tidak bergerak begitu cepat, tetapi dalam menghadapi Pratinjau .NET Framework 4.8, kami memiliki setidaknya bukti konseptual bahwa perbaikan di sana juga dapat diterapkan.  Sekarang saya sedang menunggu backport untuk. NET 4.7.2 untuk menggunakan. NET dengan kecepatan penuh dan pada perangkat keras terakhir.  Ini adalah bug pertama yang saya temukan yang berhubungan langsung dengan perubahan kinerja karena satu instruksi CPU.  ETW tetap menjadi profiler utama di Windows.  Jika saya bisa, saya akan meminta Microsoft untuk port infrastruktur ETW ke Linux, karena profiler Linux saat ini masih omong kosong.  Mereka baru-baru ini menambahkan fitur kernel yang menarik, tetapi masih belum ada alat analisis seperti WPA. <br><br>  Jika Anda bekerja dengan .NET Core 2.0 atau desktop .NET Framework pada prosesor terbaru yang telah dirilis sejak pertengahan 2017, maka jika terjadi masalah dengan penurunan kinerja, Anda harus memeriksa aplikasi Anda dengan profiler - dan meningkatkan ke .NET Core dan, mudah-mudahan, segera untuk .NET Desktop  Aplikasi pengujian saya akan memberi tahu Anda tentang ada atau tidaknya masalah. <br><br> <code>D:\SkylakeXPause\bin\Release\netcoreapp2.0&gt;dotnet SkylakeXPause.dll -check <br> Did call pause 1,000,000 in 3.5990 ms, Processors: 8 <br> No SkylakeX problem detected</code> <br> <br>  atau <br><br> <code>D:\SkylakeXPause\SkylakeXPause\bin\Release\net45&gt;SkylakeXPause.exe -check <br> Did call pause 1,000,000 in 3.6195 ms, Processors: 8 <br> No SkylakeX problem detected</code> <br> <br>  Alat ini akan melaporkan masalah jika Anda bekerja pada .NET Framework tanpa pembaruan yang sesuai dan pada prosesor Skylake. <br><br>  Saya harap Anda menemukan penyelidikan masalah ini semenarik yang saya lakukan.  Untuk benar-benar memahami masalah, Anda perlu membuat cara mereproduksinya, memungkinkan Anda untuk bereksperimen dan mencari faktor-faktor yang memengaruhi.  Sisanya hanya pekerjaan yang membosankan, tetapi sekarang saya jauh lebih baik dalam memahami penyebab dan konsekuensi dari upaya siklus untuk mendapatkan kunci pada CPU. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415053/">https://habr.com/ru/post/id415053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415043/index.html">Robot terbang berubah bentuk di udara</a></li>
<li><a href="../id415045/index.html">Kebijakan lisensi Oracle mendorong analitik pada Hadoop</a></li>
<li><a href="../id415047/index.html">Acara digital di Moskow dari 25 Juni hingga 1 Juli</a></li>
<li><a href="../id415049/index.html">Membuat perintah manajemen di Django</a></li>
<li><a href="../id415051/index.html">Isometry, indeks-z dalam game mobile dan pengoptimalannya</a></li>
<li><a href="../id415055/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 320 (18-24 Juni, 2018)</a></li>
<li><a href="../id415057/index.html">PHP Digest No. 133 (10 - 24 Juni 2018)</a></li>
<li><a href="../id415059/index.html">Rahasia masakan JavaScript: rempah-rempah</a></li>
<li><a href="../id415061/index.html">Dari frontend ke backend</a></li>
<li><a href="../id415063/index.html">Blue Origin akan mulai menjual tiket ke luar angkasa turis tahun depan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>