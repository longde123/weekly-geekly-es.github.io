<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍⚕️ 🌈 ❄️ select / poll / epoll: différence pratique 📅 🚖 🗾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors de la conception d'applications réseau hautes performances avec des sockets non bloquants, il est important de décider quelle méthode de surveill...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>select / poll / epoll: différence pratique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/415259/">  Lors de la conception d'applications réseau hautes performances avec des sockets non bloquants, il est important de décider quelle méthode de surveillance des événements réseau nous utiliserons.  Il y en a plusieurs, et chacun est bon et mauvais à sa manière.  Le choix de la bonne méthode peut être critique pour l'architecture de votre application. <br><br>  Dans cet article, nous considérerons: <br><br><ul><li>  sélectionnez () </li><li>  poll () </li><li>  epoll () </li><li>  libevent </li></ul><a name="habracut"></a><br><h3>  Utilisation de select () </h3><br>  L'ancien, éprouvé au fil des ans, le travailleur acharné select () a été créé à l'époque où les «prises» étaient appelées « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prises Berkeley</a> ».  Cette méthode n'était pas incluse dans la toute première spécification de ces sockets Berkeley elles-mêmes, car à l'époque il n'existait toujours pas de concept d'E / S non bloquantes.  Mais quelque part dans les années 80, elle est apparue, et avec elle, sélectionnez ().  Depuis lors, rien n'a changé de manière significative dans son interface. <br><br>  Pour utiliser select (), le développeur doit initialiser et remplir plusieurs structures fd_set avec des descripteurs et des événements qui doivent être surveillés, puis appeler select ().  Un code typique ressemble à ceci: <br><br><pre><code class="cpp hljs">fd_set fd_in, fd_out; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tv</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   FD_ZERO( &amp;fd_in ); FD_ZERO( &amp;fd_out ); //        sock1 FD_SET( sock1, &amp;fd_in ); //        sock2 FD_SET( sock2, &amp;fd_out ); //       (select   ) int largest_sock = sock1 &gt; sock2 ? sock1 : sock2; //    10  tv.tv_sec = 10; tv.tv_usec = 0; //  select int ret = select( largest_sock + 1, &amp;fd_in, &amp;fd_out, NULL, &amp;tv ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { if ( FD_ISSET( sock1, &amp;fd_in ) ) //    sock1 if ( FD_ISSET( sock2, &amp;fd_out ) ) //    sock2 }</span></span></code> </pre> <br>  Lorsque select () a été conçu, personne ne s'attendait à ce qu'à l'avenir, nous devions écrire des applications multithreads desservant des milliers de connexions.  Select () présente plusieurs inconvénients importants qui le rendent mal adapté pour travailler sur de tels systèmes.  Les principaux sont: <br><br><ul><li>  select modifie les structures fd_sets qui lui sont transmises, afin qu'aucune d'entre elles ne puisse être réutilisée.  Même si vous n'avez rien à changer (par exemple, après avoir reçu une donnée, vous voulez en obtenir plus), les structures fd_sets devront être réinitialisées.  Eh bien, ou copiez à partir d'une sauvegarde précédemment enregistrée à l'aide de FD_COPY.  Et cela devra être fait encore et encore, avant chaque appel de sélection. </li><li>  Pour savoir exactement quel descripteur a généré l'événement, vous devez tous les interroger manuellement avec FD_ISSET.  Lorsque vous surveillez 2000 descripteurs et que l'événement s'est produit uniquement pour l'un d'entre eux (qui, selon la loi de la méchanceté, sera le dernier de la liste) - vous gaspillerez beaucoup de ressources processeur. </li><li>  Est-ce que je viens de mentionner 2000 descripteurs?  J'en ai été excité.  select ne prend pas beaucoup en charge.  Eh bien, au moins sur Linux ordinaire, avec le noyau habituel.  Le nombre maximal de descripteurs observés simultanément est limité par la constante FD_SETSIZE, qui est rigidement égale à 1024 sous Linux. Certains systèmes d'exploitation vous permettent d'implémenter un piratage en remplaçant la valeur FD_SETSIZE avant d'inclure le fichier d'en-tête sys / select.h, mais ce piratage ne fait pas partie d'un standard commun.  Le même Linux l'ignorera. </li><li>  Vous ne pouvez pas travailler avec des descripteurs d'un ensemble observable d'un autre thread.  Imaginez un thread exécutant le code ci-dessus.  Il a donc démarré et attend les événements dans son select ().  Imaginez maintenant que vous avez un autre thread qui surveille la charge globale du système, et maintenant il a décidé que les données du socket sock1 n'étaient pas arrivées trop longtemps et qu'il était temps de rompre la connexion.  Comme ce socket peut être réutilisé pour servir de nouveaux clients, il serait bon de le fermer correctement.  Mais le premier thread observe ce descripteur en ce moment.  Que se passera-t-il si nous le fermons tout de même?  Oh, la documentation a une réponse à cette question et vous ne l'aimerez pas: "Si le handle observé avec select () est fermé par un autre thread, vous obtiendrez un comportement indéfini." </li><li>  Le même problème apparaît lorsque vous essayez d'envoyer des données via sock1.  Nous n'enverrons rien tant que select n'aura pas terminé son travail. </li><li>  Le choix des événements que nous pouvons surveiller est assez limité.  Par exemple, pour déterminer qu'un socket distant a été fermé, vous devez, premièrement, surveiller les événements d'arrivée de données dessus, et deuxièmement, essayer de lire ces données (read renverra 0 pour le socket fermé).  Cela peut toujours être considéré comme acceptable lors de la lecture de données à partir d'un socket (lire 0 - le socket est fermé), mais que se passe-t-il si notre tâche actuelle envoie des données à ce socket et aucune lecture de données à partir de ce moment? </li><li>  select vous impose un fardeau inutile pour calculer le «plus grand descripteur» et le passer comme paramètre séparé </li></ul><br>  Bien sûr, tout ce qui précède n'est pas une nouvelle.  Les développeurs de systèmes d'exploitation sont depuis longtemps conscients de ces problèmes et nombre d'entre eux ont été pris en compte lors de la conception de la méthode d'interrogation.  À ce stade, vous pouvez vous demander, pourquoi étudions-nous même l'histoire ancienne maintenant, et y a-t-il aujourd'hui des raisons d'utiliser l'ancienne sélection?  Oui, il y a deux raisons.  Pas le fait qu'ils vous seront utiles un jour, mais pourquoi ne pas les découvrir. <br><br>  La première raison est la portabilité.  select () est avec nous depuis un million d'années.  Peu importe ce que la jungle des plates-formes matérielles et logicielles vous apporte, s'il y a un réseau là-bas, il y en aura.  Il n'y a peut-être pas d'autres méthodes, mais la sélection sera presque garantie.  Et ne pensez pas que je tombe maintenant dans la sénilité sénile et me souviens de quelque chose comme des cartes perforées et ENIAC, non.  Il n'y a pas de méthode d'interrogation plus moderne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, par exemple, dans Windows XP</a> .  Mais sélectionnez est. <br><br>  La deuxième raison est plus exotique et liée au fait que select peut (théoriquement) fonctionner avec des délais d'attente de l'ordre de la nanoseconde (si le matériel le permet), tandis que poll et epoll ne prennent en charge qu'une précision en millisecondes.  Cela ne devrait pas jouer un rôle spécial sur les ordinateurs de bureau ordinaires (ou même les serveurs), où vous n'avez toujours pas de minuterie matérielle de précision en nanosecondes.  Mais toujours dans le monde, il existe des systèmes en temps réel qui ont de tels temporisateurs.  Donc, je vous en prie, lorsque vous écrivez le firmware d'un réacteur nucléaire ou d'une fusée - ne soyez pas trop paresseux pour mesurer le temps en nanosecondes.  Tu sais, je veux vivre. <br><br>  Le cas décrit ci-dessus est probablement le seul dans lequel vous n'avez vraiment pas le choix de ce que vous devez utiliser (seule la sélection est appropriée).  Cependant, si vous écrivez une application régulière pour travailler sur du matériel ordinaire, et que vous fonctionnerez avec un nombre adéquat de sockets (des dizaines, des centaines - et pas plus), alors la différence de sondage et de performances sélectionnées ne sera pas perceptible, donc le choix sera basé sur d'autres facteurs. <br><br><h3>  Sondage avec poll () </h3><br>  poll est une nouvelle méthode d'interrogation des sockets, créée après que les gens ont commencé à écrire des services réseau volumineux et fortement chargés.  Il est beaucoup mieux conçu et ne souffre pas de la plupart des inconvénients de la méthode de sélection.  Dans la plupart des cas, lors de l'écriture d'applications modernes, vous choisirez entre l'utilisation de poll et epoll / libevent. <br><br>  Pour utiliser poll, un développeur doit initialiser les membres de la structure pollfd avec des descripteurs et des événements observables, puis appeler poll (). <br>  Un code typique ressemble à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   struct pollfd fds[2]; //  sock1      fds[0].fd = sock1; fds[0].events = POLLIN; //   sock2 -  fds[1].fd = sock2; fds[1].events = POLLOUT; //   10  int ret = poll( &amp;fds, 2, 10000 ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { //  ,  revents      if ( pfd[0].revents &amp; POLLIN ) pfd[0].revents = 0; //     sock1 if ( pfd[1].revents &amp; POLLOUT ) pfd[1].revents = 0; //     sock2 }</span></span></code> </pre> <br>  Le sondage a été créé pour résoudre les problèmes de la méthode select, voyons comment cela s'est avéré: <br><br><ul><li>  Il n'y a pas de limite au nombre de descripteurs observés; plus de 1024 peuvent être surveillés </li><li>  La structure pollfd n'est pas modifiée, ce qui permet de la réutiliser entre les appels à poll () - il suffit de réinitialiser le champ revents. </li><li>  Les événements observés sont mieux structurés.  Par exemple, vous pouvez déterminer si un client distant est déconnecté sans avoir à lire les données du socket. </li></ul><br>  Nous avons déjà évoqué les lacunes de la méthode de sondage: elle n'est pas disponible sur certaines plateformes, comme Windows XP.  Depuis Vista, il existe, mais s'appelle WSAPoll.  Le prototype est le même, donc pour le code indépendant de la plate-forme, vous pouvez écrire un remplacement, comme: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined (WIN32) static inline int poll( struct pollfd *pfd, int nfds, int timeout) { return WSAPoll ( pfd, nfds, timeout ); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Eh bien, la précision des délais d'attente est de 1 ms, ce qui ne suffira pas très rarement.  Cependant, le sondage présente d'autres inconvénients: <br><br><ul><li>  Comme pour l'utilisation de select, il est impossible de déterminer quels descripteurs ont généré les événements sans passer par toutes les structures observées et vérifier les champs revents qui s'y trouvent.  Pire encore, il est également implémenté dans le noyau du système d'exploitation. </li><li>  Comme avec select, il n'y a aucun moyen de modifier dynamiquement l'ensemble d'événements observé </li></ul><br>  Cependant, tout ce qui précède peut être considéré comme relativement insignifiant pour la plupart des applications clientes.  L'exception est probablement uniquement les protocoles p2p, où chacun des clients peut être associé à des milliers d'autres.  Ces problèmes peuvent être ignorés même par la plupart des applications serveur.  Par conséquent, le sondage devrait être votre préférence par défaut par rapport à la sélection, sauf si l'une des deux raisons ci-dessus vous limite. <br><br>  Pour l'avenir, je dirai que le sondage est préférable même par rapport à l'epoll plus moderne (discuté ci-dessous) dans les cas suivants: <br><br><ul><li>  Vous voulez écrire du code multiplateforme (epoll est uniquement sur Linux) </li><li>  Vous n'avez pas besoin de surveiller plus de 1000 sockets (epoll ne vous donnera rien de significatif dans ce cas) </li><li>  Vous devez surveiller plus de 1000 sockets, mais le temps de connexion avec chacun d'eux est très faible (dans ces cas, les performances de poll et epoll seront très proches - le gain de l'attente de moins d'événements dans epoll sera barré par le surcoût de leur ajout / suppression) </li><li>  Votre application n'est pas conçue pour modifier les événements d'un thread pendant qu'un autre les attend (ou vous n'en avez pas besoin) </li></ul><br><h3>  Sondage avec epoll () </h3><br>  epoll est la méthode la plus récente et la meilleure pour attendre des événements sur Linux (et uniquement sur Linux).  Eh bien, ce n'est pas que le "plus récent" est direct - il est au cœur depuis 2002.  Il diffère du sondage et sélectionne en ce qu'il fournit une API pour ajouter / supprimer / modifier la liste des descripteurs et événements observés. <br><br>  L'utilisation d'epoll nécessite des préparations un peu plus approfondies.  Le développeur doit: <br><br><ul><li>  Créez un descripteur epoll en appelant epoll_create </li><li>  Initialisez la structure epoll_event avec les événements nécessaires et les pointeurs vers les contextes de connexion.  Le «contexte» ici peut être n'importe quoi, epoll passe juste cette valeur dans les événements retournés </li><li>  Appelez epoll_ctl (... EPOLL_CTL_ADD) pour ajouter un handle à la liste des observables </li><li>  Appelez epoll_wait () pour attendre les événements (nous indiquons exactement combien d'événements nous voulons recevoir à la fois, par exemple 20).  Contrairement aux méthodes précédentes, nous obtenons ces événements séparément, et non dans les propriétés des structures d'entrée.  Si nous observons 200 descripteurs et que 5 d'entre eux ont reçu de nouvelles données - epoll_wait ne renverra que 5 événements.  Si 50 événements se produisent, les 20 premiers nous seront retournés et les 30 restants attendront le prochain appel, ils ne seront pas perdus </li><li>  Traiter les événements reçus.  Ce sera un traitement relativement rapide, car nous ne regardons pas les descripteurs où rien ne s'est passé </li></ul><br>  Un code typique ressemble à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   epoll.       ,      //    (    ,   ),        int pollingfd = epoll_create( 0xCAFE ); if ( pollingfd &lt; 0 ) //  //   epoll_event struct epoll_event ev = { 0 }; //     .    ,   // epoll     . , ,       ev.data.ptr = pConnection1; //    ,     ev.events = EPOLLIN | EPOLLONESHOT; //     .        //      epoll_wait -    if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) != 0 ) // report error //       20    struct epoll_event pevents[ 20 ]; //  10  int ready = epoll_wait( pollingfd, pevents, 20, 10000 ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { //     for ( int i = 0; i &lt; ret; i++ ) { if ( pevents[i].events &amp; EPOLLIN ) { //        ,   Connection * c = (Connection*) pevents[i].data.ptr; c-&gt;handleReadEvent(); } } }</span></span></code> </pre> <br>  Commençons par les défauts d'epoll - ils sont évidents d'après le code.  Cette méthode est plus difficile à utiliser, vous devez écrire plus de code, elle fait plus d'appels système. <br><br>  Les avantages sont également évidents: <br><br><ul><li>  epoll renvoie une liste des seuls descripteurs pour lesquels les événements observés se sont réellement produits.  Vous n'avez pas besoin de parcourir des milliers de structures à la recherche de celle, peut-être celle où l'événement attendu a fonctionné. </li><li>  Vous pouvez associer un contexte significatif à chaque événement observé.  Dans l'exemple ci-dessus, nous avons utilisé un pointeur vers un objet de la classe de connexion pour cela - cela nous a sauvé une autre recherche potentielle pour un tableau de connexions. </li><li>  Vous pouvez ajouter ou supprimer des sockets de la liste à tout moment.  Vous pouvez même modifier les événements observés.  Tout fonctionnera correctement, cela est officiellement pris en charge et documenté. </li><li>  Vous pouvez démarrer plusieurs threads en attente d'événements à partir de la même file d'attente à l'aide de epoll_wait.  Quelque chose qui ne peut en aucun cas être fait avec select / poll. </li></ul><br>  Mais vous devez également vous rappeler qu'epoll n'est pas «un sondage amélioré à tous les niveaux».  Il présente des inconvénients par rapport au sondage: <br><br><ul><li>  La modification des drapeaux d'événements (par exemple, le passage de READ à WRITE) nécessite un appel système epoll_ctl supplémentaire, tandis que pour le sondage, vous changez simplement le masque de bits (complètement en mode utilisateur).  Passer de 5 000 sockets de lecture à écriture nécessitera 5 000 appels système et commutateurs de contexte pour epoll, tandis que pour interrogation, ce sera une opération de bits triviale dans une boucle. </li><li>  Pour chaque nouvelle connexion, vous devez appeler accept () et epoll_ctl () sont deux appels système.  Si vous utilisez le sondage, il n'y aura qu'un seul appel.  Avec une durée de vie de connexion très courte, cela peut faire la différence. </li><li>  epoll n'est disponible que sur Linux.  D'autres systèmes d'exploitation ont des mécanismes similaires, mais toujours pas complètement identiques.  Vous ne pourrez pas écrire de code avec epoll pour qu'il se compile et fonctionne, par exemple, sur FreeBSD. </li><li>  Il est difficile d'écrire du code parallèle très chargé.  De nombreuses applications n'ont pas besoin d'une telle approche fondamentale, car leur niveau de charge est facilement traité à l'aide de méthodes plus simples. </li></ul><br>  Par conséquent, epoll ne doit être utilisé que lorsque toutes les conditions suivantes sont remplies: <br><br><ul><li>  Votre application utilise un pool de threads pour gérer les connexions réseau.  Le gain d'epoll dans une application monothread sera négligeable, et vous ne devriez pas vous soucier de l'implémentation. </li><li>  Vous vous attendez à un nombre relativement important de connexions (de 1000 et plus).  Sur un petit nombre de sockets observées, epoll ne donnera pas de gain de performances, et s'il y a littéralement quelques sockets, il peut même ralentir. </li><li>  Vos connexions vivent relativement longtemps.  Dans une situation où une nouvelle connexion transfère seulement quelques octets de données et se ferme juste là - l'interrogation fonctionnera plus rapidement, car elle devra effectuer moins d'appels système pour la traiter. </li><li>  Vous avez l'intention d'exécuter votre code sous Linux et uniquement sous Linux. </li></ul><br>  Si un ou plusieurs éléments échouent, envisagez d'utiliser poll ou libevent. <br><br><h3>  libevent </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libevent</a> est une bibliothèque qui encapsule les méthodes d'interrogation répertoriées dans cet article (ainsi que certaines autres) dans une API unifiée.  L'avantage ici est qu'une fois que vous avez écrit le code, vous pouvez le construire et l'exécuter sur différents systèmes d'exploitation.  Néanmoins, il est important de comprendre que libevent n'est qu'un wrapper, à l'intérieur duquel toutes les méthodes ci-dessus fonctionnent, avec tous leurs avantages et inconvénients.  libevent ne forcera pas select à écouter plus de 1024 sockets, et epoll ne modifiera pas la liste des événements sans appel système supplémentaire.  Il est donc toujours important de connaître les technologies sous-jacentes. <br><br>  La nécessité de prendre en charge différentes méthodes d'interrogation rend l'API de la bibliothèque libevent plus complexe.  Mais encore, son utilisation est plus facile que d'écrire manuellement deux moteurs de sélection d'événement différents pour, par exemple, Linux et FreeBSD (en utilisant epoll et kqueue). <br><br>  Pensez à utiliser libevent lorsque vous combinez deux événements: <br><br><ul><li>  Vous avez examiné les méthodes de sélection et d'interrogation et elles n'ont certainement pas fonctionné pour vous. </li><li>  Vous devez prendre en charge plusieurs systèmes d'exploitation </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415259/">https://habr.com/ru/post/fr415259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415249/index.html">Un petit pas pour un programmeur est un grand pas pour une ONG</a></li>
<li><a href="../fr415251/index.html">Des employés d'Amazon, de Google et de Microsoft protestent contre la coopération avec l'armée et la police</a></li>
<li><a href="../fr415253/index.html">Les photographies du XIXe siècle ont été restaurées à l'aide de la technologie du XXIe siècle</a></li>
<li><a href="../fr415255/index.html">Roskosmos a annoncé la fin des vols de missiles Proton</a></li>
<li><a href="../fr415257/index.html">8 façons d'améliorer la visualisation des données</a></li>
<li><a href="../fr415261/index.html">Artiste VFX dans le développement de jeux: fonctionnalités, carrière, développement</a></li>
<li><a href="../fr415263/index.html">Comment nous avons ajouté des entrées à la carte et réduit la taille des bases de 10%</a></li>
<li><a href="../fr415265/index.html">À la recherche d'un successeur au KL-7: RACE et AROFLEX</a></li>
<li><a href="../fr415269/index.html">Fonctionnement de JS: arborescences de syntaxe abstraite, analyse et optimisation</a></li>
<li><a href="../fr415271/index.html">Comment les diagrammes de Gantt simplifient la gestion de projet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>