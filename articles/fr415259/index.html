<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äç‚öïÔ∏è üåà ‚ùÑÔ∏è select / poll / epoll: diff√©rence pratique üìÖ üöñ üóæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors de la conception d'applications r√©seau hautes performances avec des sockets non bloquants, il est important de d√©cider quelle m√©thode de surveill...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>select / poll / epoll: diff√©rence pratique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/415259/">  Lors de la conception d'applications r√©seau hautes performances avec des sockets non bloquants, il est important de d√©cider quelle m√©thode de surveillance des √©v√©nements r√©seau nous utiliserons.  Il y en a plusieurs, et chacun est bon et mauvais √† sa mani√®re.  Le choix de la bonne m√©thode peut √™tre critique pour l'architecture de votre application. <br><br>  Dans cet article, nous consid√©rerons: <br><br><ul><li>  s√©lectionnez () </li><li>  poll () </li><li>  epoll () </li><li>  libevent </li></ul><a name="habracut"></a><br><h3>  Utilisation de select () </h3><br>  L'ancien, √©prouv√© au fil des ans, le travailleur acharn√© select () a √©t√© cr√©√© √† l'√©poque o√π les ¬´prises¬ª √©taient appel√©es ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prises Berkeley</a> ¬ª.  Cette m√©thode n'√©tait pas incluse dans la toute premi√®re sp√©cification de ces sockets Berkeley elles-m√™mes, car √† l'√©poque il n'existait toujours pas de concept d'E / S non bloquantes.  Mais quelque part dans les ann√©es 80, elle est apparue, et avec elle, s√©lectionnez ().  Depuis lors, rien n'a chang√© de mani√®re significative dans son interface. <br><br>  Pour utiliser select (), le d√©veloppeur doit initialiser et remplir plusieurs structures fd_set avec des descripteurs et des √©v√©nements qui doivent √™tre surveill√©s, puis appeler select ().  Un code typique ressemble √† ceci: <br><br><pre><code class="cpp hljs">fd_set fd_in, fd_out; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tv</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   FD_ZERO( &amp;fd_in ); FD_ZERO( &amp;fd_out ); //        sock1 FD_SET( sock1, &amp;fd_in ); //        sock2 FD_SET( sock2, &amp;fd_out ); //       (select   ) int largest_sock = sock1 &gt; sock2 ? sock1 : sock2; //    10  tv.tv_sec = 10; tv.tv_usec = 0; //  select int ret = select( largest_sock + 1, &amp;fd_in, &amp;fd_out, NULL, &amp;tv ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { if ( FD_ISSET( sock1, &amp;fd_in ) ) //    sock1 if ( FD_ISSET( sock2, &amp;fd_out ) ) //    sock2 }</span></span></code> </pre> <br>  Lorsque select () a √©t√© con√ßu, personne ne s'attendait √† ce qu'√† l'avenir, nous devions √©crire des applications multithreads desservant des milliers de connexions.  Select () pr√©sente plusieurs inconv√©nients importants qui le rendent mal adapt√© pour travailler sur de tels syst√®mes.  Les principaux sont: <br><br><ul><li>  select modifie les structures fd_sets qui lui sont transmises, afin qu'aucune d'entre elles ne puisse √™tre r√©utilis√©e.  M√™me si vous n'avez rien √† changer (par exemple, apr√®s avoir re√ßu une donn√©e, vous voulez en obtenir plus), les structures fd_sets devront √™tre r√©initialis√©es.  Eh bien, ou copiez √† partir d'une sauvegarde pr√©c√©demment enregistr√©e √† l'aide de FD_COPY.  Et cela devra √™tre fait encore et encore, avant chaque appel de s√©lection. </li><li>  Pour savoir exactement quel descripteur a g√©n√©r√© l'√©v√©nement, vous devez tous les interroger manuellement avec FD_ISSET.  Lorsque vous surveillez 2000 descripteurs et que l'√©v√©nement s'est produit uniquement pour l'un d'entre eux (qui, selon la loi de la m√©chancet√©, sera le dernier de la liste) - vous gaspillerez beaucoup de ressources processeur. </li><li>  Est-ce que je viens de mentionner 2000 descripteurs?  J'en ai √©t√© excit√©.  select ne prend pas beaucoup en charge.  Eh bien, au moins sur Linux ordinaire, avec le noyau habituel.  Le nombre maximal de descripteurs observ√©s simultan√©ment est limit√© par la constante FD_SETSIZE, qui est rigidement √©gale √† 1024 sous Linux. Certains syst√®mes d'exploitation vous permettent d'impl√©menter un piratage en rempla√ßant la valeur FD_SETSIZE avant d'inclure le fichier d'en-t√™te sys / select.h, mais ce piratage ne fait pas partie d'un standard commun.  Le m√™me Linux l'ignorera. </li><li>  Vous ne pouvez pas travailler avec des descripteurs d'un ensemble observable d'un autre thread.  Imaginez un thread ex√©cutant le code ci-dessus.  Il a donc d√©marr√© et attend les √©v√©nements dans son select ().  Imaginez maintenant que vous avez un autre thread qui surveille la charge globale du syst√®me, et maintenant il a d√©cid√© que les donn√©es du socket sock1 n'√©taient pas arriv√©es trop longtemps et qu'il √©tait temps de rompre la connexion.  Comme ce socket peut √™tre r√©utilis√© pour servir de nouveaux clients, il serait bon de le fermer correctement.  Mais le premier thread observe ce descripteur en ce moment.  Que se passera-t-il si nous le fermons tout de m√™me?  Oh, la documentation a une r√©ponse √† cette question et vous ne l'aimerez pas: "Si le handle observ√© avec select () est ferm√© par un autre thread, vous obtiendrez un comportement ind√©fini." </li><li>  Le m√™me probl√®me appara√Æt lorsque vous essayez d'envoyer des donn√©es via sock1.  Nous n'enverrons rien tant que select n'aura pas termin√© son travail. </li><li>  Le choix des √©v√©nements que nous pouvons surveiller est assez limit√©.  Par exemple, pour d√©terminer qu'un socket distant a √©t√© ferm√©, vous devez, premi√®rement, surveiller les √©v√©nements d'arriv√©e de donn√©es dessus, et deuxi√®mement, essayer de lire ces donn√©es (read renverra 0 pour le socket ferm√©).  Cela peut toujours √™tre consid√©r√© comme acceptable lors de la lecture de donn√©es √† partir d'un socket (lire 0 - le socket est ferm√©), mais que se passe-t-il si notre t√¢che actuelle envoie des donn√©es √† ce socket et aucune lecture de donn√©es √† partir de ce moment? </li><li>  select vous impose un fardeau inutile pour calculer le ¬´plus grand descripteur¬ª et le passer comme param√®tre s√©par√© </li></ul><br>  Bien s√ªr, tout ce qui pr√©c√®de n'est pas une nouvelle.  Les d√©veloppeurs de syst√®mes d'exploitation sont depuis longtemps conscients de ces probl√®mes et nombre d'entre eux ont √©t√© pris en compte lors de la conception de la m√©thode d'interrogation.  √Ä ce stade, vous pouvez vous demander, pourquoi √©tudions-nous m√™me l'histoire ancienne maintenant, et y a-t-il aujourd'hui des raisons d'utiliser l'ancienne s√©lection?  Oui, il y a deux raisons.  Pas le fait qu'ils vous seront utiles un jour, mais pourquoi ne pas les d√©couvrir. <br><br>  La premi√®re raison est la portabilit√©.  select () est avec nous depuis un million d'ann√©es.  Peu importe ce que la jungle des plates-formes mat√©rielles et logicielles vous apporte, s'il y a un r√©seau l√†-bas, il y en aura.  Il n'y a peut-√™tre pas d'autres m√©thodes, mais la s√©lection sera presque garantie.  Et ne pensez pas que je tombe maintenant dans la s√©nilit√© s√©nile et me souviens de quelque chose comme des cartes perfor√©es et ENIAC, non.  Il n'y a pas de m√©thode d'interrogation plus moderne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, par exemple, dans Windows XP</a> .  Mais s√©lectionnez est. <br><br>  La deuxi√®me raison est plus exotique et li√©e au fait que select peut (th√©oriquement) fonctionner avec des d√©lais d'attente de l'ordre de la nanoseconde (si le mat√©riel le permet), tandis que poll et epoll ne prennent en charge qu'une pr√©cision en millisecondes.  Cela ne devrait pas jouer un r√¥le sp√©cial sur les ordinateurs de bureau ordinaires (ou m√™me les serveurs), o√π vous n'avez toujours pas de minuterie mat√©rielle de pr√©cision en nanosecondes.  Mais toujours dans le monde, il existe des syst√®mes en temps r√©el qui ont de tels temporisateurs.  Donc, je vous en prie, lorsque vous √©crivez le firmware d'un r√©acteur nucl√©aire ou d'une fus√©e - ne soyez pas trop paresseux pour mesurer le temps en nanosecondes.  Tu sais, je veux vivre. <br><br>  Le cas d√©crit ci-dessus est probablement le seul dans lequel vous n'avez vraiment pas le choix de ce que vous devez utiliser (seule la s√©lection est appropri√©e).  Cependant, si vous √©crivez une application r√©guli√®re pour travailler sur du mat√©riel ordinaire, et que vous fonctionnerez avec un nombre ad√©quat de sockets (des dizaines, des centaines - et pas plus), alors la diff√©rence de sondage et de performances s√©lectionn√©es ne sera pas perceptible, donc le choix sera bas√© sur d'autres facteurs. <br><br><h3>  Sondage avec poll () </h3><br>  poll est une nouvelle m√©thode d'interrogation des sockets, cr√©√©e apr√®s que les gens ont commenc√© √† √©crire des services r√©seau volumineux et fortement charg√©s.  Il est beaucoup mieux con√ßu et ne souffre pas de la plupart des inconv√©nients de la m√©thode de s√©lection.  Dans la plupart des cas, lors de l'√©criture d'applications modernes, vous choisirez entre l'utilisation de poll et epoll / libevent. <br><br>  Pour utiliser poll, un d√©veloppeur doit initialiser les membres de la structure pollfd avec des descripteurs et des √©v√©nements observables, puis appeler poll (). <br>  Un code typique ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   struct pollfd fds[2]; //  sock1      fds[0].fd = sock1; fds[0].events = POLLIN; //   sock2 -  fds[1].fd = sock2; fds[1].events = POLLOUT; //   10  int ret = poll( &amp;fds, 2, 10000 ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { //  ,  revents      if ( pfd[0].revents &amp; POLLIN ) pfd[0].revents = 0; //     sock1 if ( pfd[1].revents &amp; POLLOUT ) pfd[1].revents = 0; //     sock2 }</span></span></code> </pre> <br>  Le sondage a √©t√© cr√©√© pour r√©soudre les probl√®mes de la m√©thode select, voyons comment cela s'est av√©r√©: <br><br><ul><li>  Il n'y a pas de limite au nombre de descripteurs observ√©s; plus de 1024 peuvent √™tre surveill√©s </li><li>  La structure pollfd n'est pas modifi√©e, ce qui permet de la r√©utiliser entre les appels √† poll () - il suffit de r√©initialiser le champ revents. </li><li>  Les √©v√©nements observ√©s sont mieux structur√©s.  Par exemple, vous pouvez d√©terminer si un client distant est d√©connect√© sans avoir √† lire les donn√©es du socket. </li></ul><br>  Nous avons d√©j√† √©voqu√© les lacunes de la m√©thode de sondage: elle n'est pas disponible sur certaines plateformes, comme Windows XP.  Depuis Vista, il existe, mais s'appelle WSAPoll.  Le prototype est le m√™me, donc pour le code ind√©pendant de la plate-forme, vous pouvez √©crire un remplacement, comme: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined (WIN32) static inline int poll( struct pollfd *pfd, int nfds, int timeout) { return WSAPoll ( pfd, nfds, timeout ); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Eh bien, la pr√©cision des d√©lais d'attente est de 1 ms, ce qui ne suffira pas tr√®s rarement.  Cependant, le sondage pr√©sente d'autres inconv√©nients: <br><br><ul><li>  Comme pour l'utilisation de select, il est impossible de d√©terminer quels descripteurs ont g√©n√©r√© les √©v√©nements sans passer par toutes les structures observ√©es et v√©rifier les champs revents qui s'y trouvent.  Pire encore, il est √©galement impl√©ment√© dans le noyau du syst√®me d'exploitation. </li><li>  Comme avec select, il n'y a aucun moyen de modifier dynamiquement l'ensemble d'√©v√©nements observ√© </li></ul><br>  Cependant, tout ce qui pr√©c√®de peut √™tre consid√©r√© comme relativement insignifiant pour la plupart des applications clientes.  L'exception est probablement uniquement les protocoles p2p, o√π chacun des clients peut √™tre associ√© √† des milliers d'autres.  Ces probl√®mes peuvent √™tre ignor√©s m√™me par la plupart des applications serveur.  Par cons√©quent, le sondage devrait √™tre votre pr√©f√©rence par d√©faut par rapport √† la s√©lection, sauf si l'une des deux raisons ci-dessus vous limite. <br><br>  Pour l'avenir, je dirai que le sondage est pr√©f√©rable m√™me par rapport √† l'epoll plus moderne (discut√© ci-dessous) dans les cas suivants: <br><br><ul><li>  Vous voulez √©crire du code multiplateforme (epoll est uniquement sur Linux) </li><li>  Vous n'avez pas besoin de surveiller plus de 1000 sockets (epoll ne vous donnera rien de significatif dans ce cas) </li><li>  Vous devez surveiller plus de 1000 sockets, mais le temps de connexion avec chacun d'eux est tr√®s faible (dans ces cas, les performances de poll et epoll seront tr√®s proches - le gain de l'attente de moins d'√©v√©nements dans epoll sera barr√© par le surco√ªt de leur ajout / suppression) </li><li>  Votre application n'est pas con√ßue pour modifier les √©v√©nements d'un thread pendant qu'un autre les attend (ou vous n'en avez pas besoin) </li></ul><br><h3>  Sondage avec epoll () </h3><br>  epoll est la m√©thode la plus r√©cente et la meilleure pour attendre des √©v√©nements sur Linux (et uniquement sur Linux).  Eh bien, ce n'est pas que le "plus r√©cent" est direct - il est au c≈ìur depuis 2002.  Il diff√®re du sondage et s√©lectionne en ce qu'il fournit une API pour ajouter / supprimer / modifier la liste des descripteurs et √©v√©nements observ√©s. <br><br>  L'utilisation d'epoll n√©cessite des pr√©parations un peu plus approfondies.  Le d√©veloppeur doit: <br><br><ul><li>  Cr√©ez un descripteur epoll en appelant epoll_create </li><li>  Initialisez la structure epoll_event avec les √©v√©nements n√©cessaires et les pointeurs vers les contextes de connexion.  Le ¬´contexte¬ª ici peut √™tre n'importe quoi, epoll passe juste cette valeur dans les √©v√©nements retourn√©s </li><li>  Appelez epoll_ctl (... EPOLL_CTL_ADD) pour ajouter un handle √† la liste des observables </li><li>  Appelez epoll_wait () pour attendre les √©v√©nements (nous indiquons exactement combien d'√©v√©nements nous voulons recevoir √† la fois, par exemple 20).  Contrairement aux m√©thodes pr√©c√©dentes, nous obtenons ces √©v√©nements s√©par√©ment, et non dans les propri√©t√©s des structures d'entr√©e.  Si nous observons 200 descripteurs et que 5 d'entre eux ont re√ßu de nouvelles donn√©es - epoll_wait ne renverra que 5 √©v√©nements.  Si 50 √©v√©nements se produisent, les 20 premiers nous seront retourn√©s et les 30 restants attendront le prochain appel, ils ne seront pas perdus </li><li>  Traiter les √©v√©nements re√ßus.  Ce sera un traitement relativement rapide, car nous ne regardons pas les descripteurs o√π rien ne s'est pass√© </li></ul><br>  Un code typique ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   epoll.       ,      //    (    ,   ),        int pollingfd = epoll_create( 0xCAFE ); if ( pollingfd &lt; 0 ) //  //   epoll_event struct epoll_event ev = { 0 }; //     .    ,   // epoll     . , ,       ev.data.ptr = pConnection1; //    ,     ev.events = EPOLLIN | EPOLLONESHOT; //     .        //      epoll_wait -    if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) != 0 ) // report error //       20    struct epoll_event pevents[ 20 ]; //  10  int ready = epoll_wait( pollingfd, pevents, 20, 10000 ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { //     for ( int i = 0; i &lt; ret; i++ ) { if ( pevents[i].events &amp; EPOLLIN ) { //        ,   Connection * c = (Connection*) pevents[i].data.ptr; c-&gt;handleReadEvent(); } } }</span></span></code> </pre> <br>  Commen√ßons par les d√©fauts d'epoll - ils sont √©vidents d'apr√®s le code.  Cette m√©thode est plus difficile √† utiliser, vous devez √©crire plus de code, elle fait plus d'appels syst√®me. <br><br>  Les avantages sont √©galement √©vidents: <br><br><ul><li>  epoll renvoie une liste des seuls descripteurs pour lesquels les √©v√©nements observ√©s se sont r√©ellement produits.  Vous n'avez pas besoin de parcourir des milliers de structures √† la recherche de celle, peut-√™tre celle o√π l'√©v√©nement attendu a fonctionn√©. </li><li>  Vous pouvez associer un contexte significatif √† chaque √©v√©nement observ√©.  Dans l'exemple ci-dessus, nous avons utilis√© un pointeur vers un objet de la classe de connexion pour cela - cela nous a sauv√© une autre recherche potentielle pour un tableau de connexions. </li><li>  Vous pouvez ajouter ou supprimer des sockets de la liste √† tout moment.  Vous pouvez m√™me modifier les √©v√©nements observ√©s.  Tout fonctionnera correctement, cela est officiellement pris en charge et document√©. </li><li>  Vous pouvez d√©marrer plusieurs threads en attente d'√©v√©nements √† partir de la m√™me file d'attente √† l'aide de epoll_wait.  Quelque chose qui ne peut en aucun cas √™tre fait avec select / poll. </li></ul><br>  Mais vous devez √©galement vous rappeler qu'epoll n'est pas ¬´un sondage am√©lior√© √† tous les niveaux¬ª.  Il pr√©sente des inconv√©nients par rapport au sondage: <br><br><ul><li>  La modification des drapeaux d'√©v√©nements (par exemple, le passage de READ √† WRITE) n√©cessite un appel syst√®me epoll_ctl suppl√©mentaire, tandis que pour le sondage, vous changez simplement le masque de bits (compl√®tement en mode utilisateur).  Passer de 5 000 sockets de lecture √† √©criture n√©cessitera 5 000 appels syst√®me et commutateurs de contexte pour epoll, tandis que pour interrogation, ce sera une op√©ration de bits triviale dans une boucle. </li><li>  Pour chaque nouvelle connexion, vous devez appeler accept () et epoll_ctl () sont deux appels syst√®me.  Si vous utilisez le sondage, il n'y aura qu'un seul appel.  Avec une dur√©e de vie de connexion tr√®s courte, cela peut faire la diff√©rence. </li><li>  epoll n'est disponible que sur Linux.  D'autres syst√®mes d'exploitation ont des m√©canismes similaires, mais toujours pas compl√®tement identiques.  Vous ne pourrez pas √©crire de code avec epoll pour qu'il se compile et fonctionne, par exemple, sur FreeBSD. </li><li>  Il est difficile d'√©crire du code parall√®le tr√®s charg√©.  De nombreuses applications n'ont pas besoin d'une telle approche fondamentale, car leur niveau de charge est facilement trait√© √† l'aide de m√©thodes plus simples. </li></ul><br>  Par cons√©quent, epoll ne doit √™tre utilis√© que lorsque toutes les conditions suivantes sont remplies: <br><br><ul><li>  Votre application utilise un pool de threads pour g√©rer les connexions r√©seau.  Le gain d'epoll dans une application monothread sera n√©gligeable, et vous ne devriez pas vous soucier de l'impl√©mentation. </li><li>  Vous vous attendez √† un nombre relativement important de connexions (de 1000 et plus).  Sur un petit nombre de sockets observ√©es, epoll ne donnera pas de gain de performances, et s'il y a litt√©ralement quelques sockets, il peut m√™me ralentir. </li><li>  Vos connexions vivent relativement longtemps.  Dans une situation o√π une nouvelle connexion transf√®re seulement quelques octets de donn√©es et se ferme juste l√† - l'interrogation fonctionnera plus rapidement, car elle devra effectuer moins d'appels syst√®me pour la traiter. </li><li>  Vous avez l'intention d'ex√©cuter votre code sous Linux et uniquement sous Linux. </li></ul><br>  Si un ou plusieurs √©l√©ments √©chouent, envisagez d'utiliser poll ou libevent. <br><br><h3>  libevent </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libevent</a> est une biblioth√®que qui encapsule les m√©thodes d'interrogation r√©pertori√©es dans cet article (ainsi que certaines autres) dans une API unifi√©e.  L'avantage ici est qu'une fois que vous avez √©crit le code, vous pouvez le construire et l'ex√©cuter sur diff√©rents syst√®mes d'exploitation.  N√©anmoins, il est important de comprendre que libevent n'est qu'un wrapper, √† l'int√©rieur duquel toutes les m√©thodes ci-dessus fonctionnent, avec tous leurs avantages et inconv√©nients.  libevent ne forcera pas select √† √©couter plus de 1024 sockets, et epoll ne modifiera pas la liste des √©v√©nements sans appel syst√®me suppl√©mentaire.  Il est donc toujours important de conna√Ætre les technologies sous-jacentes. <br><br>  La n√©cessit√© de prendre en charge diff√©rentes m√©thodes d'interrogation rend l'API de la biblioth√®que libevent plus complexe.  Mais encore, son utilisation est plus facile que d'√©crire manuellement deux moteurs de s√©lection d'√©v√©nement diff√©rents pour, par exemple, Linux et FreeBSD (en utilisant epoll et kqueue). <br><br>  Pensez √† utiliser libevent lorsque vous combinez deux √©v√©nements: <br><br><ul><li>  Vous avez examin√© les m√©thodes de s√©lection et d'interrogation et elles n'ont certainement pas fonctionn√© pour vous. </li><li>  Vous devez prendre en charge plusieurs syst√®mes d'exploitation </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415259/">https://habr.com/ru/post/fr415259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415249/index.html">Un petit pas pour un programmeur est un grand pas pour une ONG</a></li>
<li><a href="../fr415251/index.html">Des employ√©s d'Amazon, de Google et de Microsoft protestent contre la coop√©ration avec l'arm√©e et la police</a></li>
<li><a href="../fr415253/index.html">Les photographies du XIXe si√®cle ont √©t√© restaur√©es √† l'aide de la technologie du XXIe si√®cle</a></li>
<li><a href="../fr415255/index.html">Roskosmos a annonc√© la fin des vols de missiles Proton</a></li>
<li><a href="../fr415257/index.html">8 fa√ßons d'am√©liorer la visualisation des donn√©es</a></li>
<li><a href="../fr415261/index.html">Artiste VFX dans le d√©veloppement de jeux: fonctionnalit√©s, carri√®re, d√©veloppement</a></li>
<li><a href="../fr415263/index.html">Comment nous avons ajout√© des entr√©es √† la carte et r√©duit la taille des bases de 10%</a></li>
<li><a href="../fr415265/index.html">√Ä la recherche d'un successeur au KL-7: RACE et AROFLEX</a></li>
<li><a href="../fr415269/index.html">Fonctionnement de JS: arborescences de syntaxe abstraite, analyse et optimisation</a></li>
<li><a href="../fr415271/index.html">Comment les diagrammes de Gantt simplifient la gestion de projet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>