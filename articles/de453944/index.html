<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🔧 🚻 👨🏻‍🔬 Maskierte Bugs in eingebettet 🙋🏼 🐟 🚫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stecker sind bei der Entwicklung von Software unvermeidlich. In einem Embedd können ihre großzügigen fünf Cent auch Hardwareprobleme verursachen, aber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Maskierte Bugs in eingebettet</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453944/">  Stecker sind bei der Entwicklung von Software unvermeidlich.  In einem Embedd können ihre großzügigen fünf Cent auch Hardwareprobleme verursachen, aber dies ist ein separater Song.  Aber rein programmierte Hinterhalte, wenn man an einem scheinbar leeren Ort festsitzt ... Für mich gibt es drei Arten von Hinterhalten. <br><br>  Der einfachste Weg ist, wenn das Handbuch, der Standard oder beispielsweise das Verfahren zum Konfigurieren der Bibliothek für Eisen nicht vollständig verstanden ist.  Hier ist klar: Nicht alle Bewegungen sind erschöpft, Geduld und Arbeit, weitere fünf oder zwei Experimente, und es wird zum Leben erweckt.  Oszilloskop und wissenschaftlicher Typ helfen. <br><br><img src="https://habrastorage.org/webt/uy/nn/ia/uynniacpwibqxoyroe7zgfjijjy.png"><br>  <i>Auswahl eines Frequenzteilers zur Konfiguration des CAN-Busses</i> <br><br>  Schlimmer noch, wenn das Problem ein Tippfehler oder ein Fehler in der Logik ist, den Sie erst sehen können, wenn Sie zwanzig Mal mit Ihren Augen durch diesen Ort gehen und Schritt für Schritt debuggen.  Dann dämmert es, ein klangvoller Schlag auf die Stirn, ein Schrei: „Nun, du bist eine Art Babai!“, Schnitt.  Es funktioniert. <br><br>  Und eine düstere dritte Ansicht: eine Panne, die in einer fremden Bibliothek verankert ist und mit Eisen an der Kreuzung herauskriecht.  Shakespeares Leidenschaften lassen das stetige Licht eines Monitors entstehen.  „Warum, es kann nicht, das System kann sich nicht so verhalten, weil es niemals kann!  Nun, wirklich!  Ah ?! "  Nein.  Empfangen, unterschreiben. <br><br>  Infolgedessen ist die Realität breiter, breiter und breiter als erwartet.  Einige Beispiele: <br><a name="habracut"></a><br><h2>  Geschichte Nr. 1.  MicroSD-Flash-Laufwerk und DMA funktionieren </h2><br><h3>  Anamnese </h3><br>  Sie müssen die Daten in eine Datei auf der SD-Karte sichern.  Natürlich habe ich weder Zeit noch Lust, das Dateisystem und den SDIO-Treiber selbst zu schreiben, also nehme ich die fertige Bibliothek.  Ich habe es für Eisen eingerichtet und alles funktioniert gut.  Zuerst.  Und dann stellt sich heraus, dass die Daten wild aufgezeichnet werden: Die Volumes sind genau, aber in den Dateien selbst werden separate Paare von Tripelbytes dupliziert und verschwinden dann ohne Regelmäßigkeit.  Nicht gut! <br><br>  Experimente beginnen.  Ich schreibe Testdaten - alles ist in Ordnung.  Ich schreibe Kampf - eine Art Teufelei.  Ich ändere die Größe der Datenpuffer, die Häufigkeit ihrer Leerung, Datenvorlagen sind nutzlos.  In den Puffern selbst ist immer alles hervorragend, die Daten im Speicher sind überall das, was Sie brauchen.  Und trotzdem Pannen auf einem Flash-Laufwerk - hier sind sie. <br><br>  Es dauerte ein paar Tage, um den Hund zu graben. <br><br><h3>  Die Diagnose </h3><br>  Das Problem lag in der Interaktion der Bibliothek mit <abbr title="Direkter Speicherzugriff. Datenübertragung vom RAM zur Peripherie oder zurück ohne Beteiligung des Prozessors.">DMA-</abbr> Geräten. <br><br>  SD-Karten haben eine Besonderheit: Sie werden nur in Blöcken von 512 Bytes geschrieben.  Zu diesem Zweck puffert die Bibliothek die Daten in einem 512-Byte-Array und wird beim Füllen von dort über DMA zum Flashen gespült.  Aber! <br><br>  Wenn ich ein Fragment, das größer als &lt;512xN + leerer Speicherplatz im Bibliothekspuffer&gt; Bytes ist, auf den Datensatz übertrage, tut die Bibliothek (offensichtlich, um den Speicher nicht hin und her zu verschieben) Folgendes: Sie füllt ihren Puffer auf und schreibt ihn in Flash und die nächsten 512xN Bytes werden direkt aus meinem Puffer in meinen DMA geworfen!  Nun, wenn etwas unvollendet bleibt, wird es bis zum nächsten Mal wieder selbst kopiert. <br><br>  Und alles wäre in Ordnung, aber der DMA-Controller verlangt, dass die Daten im Speicher abgelegt werden, der an einer 4-Byte-Grenze ausgerichtet ist.  Der Bibliothekspuffer ist immer so ausgerichtet, dass die Sprache dies garantiert.  Aber mit welcher Adresse beginnen nach dem Kopieren eines Teils der Daten die verbleibenden 512xN mit einem kleinen Byte bei mir - Gott weiß.  Und die Bibliothek überprüft dies überhaupt nicht: Die Adresse wird so wie sie ist an den DMA-Controller übergeben. <br><br>  "Sie haben etwas Unbeholfenes geschickt ... Ein Hund mit ihm."  Die Steuerung setzt die unteren 2 Bits der übertragenen Adresse stillschweigend zurück.  Und startet die Übertragung. <br><img src="https://habrastorage.org/webt/cj/vt/eg/cjvtegekkqclanfzdkv8v0xhfsy.png"><br><br>  Die Adresse, anfangs kein Vielfaches von 4, wird durch ein Vielfaches ersetzt - voila, bis zu den letzten drei Bytes aus dem Bibliothekspuffer werden von mir in die Datei neu geschrieben, und die gleiche Anzahl von Bytes aus meinem Puffer geht spurlos verloren.  Infolgedessen ist die Gesamtdatenmenge korrekt, die Vorgänge laufen reibungslos, aber die Festplatte ist Unsinn. <br><br><h3>  Behandlung </h3><br>  Ich musste unmittelbar vor dem Aufrufen der Hardware-Aufnahmefunktion einen weiteren Puffer hinzufügen.  Wenn die Schreibadresse kein Vielfaches von 4 ist, werden die Daten zuerst darauf kopiert.  Gleichzeitig erhöhte sich die Durchschnittsgeschwindigkeit aufgrund einer vernünftigen Wahl der Puffergröße.  Natürlich hat es Gedächtnis gekostet, aber was sind 4 Kilobyte für einen guten Zweck, wenn Sie zu Ihrer Verfügung haben - grenzenlose 192! <br><br><h2>  Geschichte Nr. 2.  Rantime und ein Haufen </h2><br><h3>  Prolog </h3><br>  Nach der nächsten Änderung begann das Programm zu fallen, und irgendwie fiel es sehr schwer und warf den Prozessor in den <abbr title="Schwerer Ausfall. Der Status des Prozessors, in den er fällt, nachdem ein Fehler aufgetreten ist: Beispielsweise ist ein Hardware-Interrupt aufgetreten, und der Prozessor konnte die Adresse der entsprechenden Handlerfunktion nicht lesen">Hard Fault-</abbr> Handler.  Und er warf es gleich nach dem Start dorthin, noch bevor die Ausführung zu main () kam, das heißt, keine einzige Zeile meines Codes hatte Zeit zum Ausführen. <br><br>  Der erste Eindruck ist: "Der Biber ist tot, der Chip soll ersetzt werden."  Und dann gab der Programmierer die Eiche.  Aber nein, die alte Version der Firmware funktioniert stabil, aber die neue Version fällt stetig in einige dunkle Montagetiefen zwischen dem Start und meinem Code.  Ich hatte keine Vermutungen, was für eine Häresie das war. <br><br><h3>  Kapitel 1 </h3><br>  Hat dem Internet geholfen, zu sehen, wie man zumindest einige zusätzliche Informationen erhält.  Das Verfahren zum Parsen der Konsequenzen eines harten Ausfalls wurde gegoogelt: Status der Register, Dump-Stack.  Dopilil.  Ich habe es benutzt. <br><br>  Es stellte sich heraus, dass es aufgrund eines Betriebsfehlers auf dem Bus abstürzt.  Ich entschied, dass dies wieder ein unausgewogener Zugang war - ein Problem des gleichen Typs wie in der ersten Geschichte, aber aus einer anderen Perspektive.  Das Gegenteil ist jedoch der Ort, an dem der Fehler aufgetreten ist.  Und es entstand in der Laufzeitbibliothek, dh im Code, der theoretisch an einem sonnigen Tag wie die blauen Flecken der Katze geleckt wurde. <br><br>  Die Fortsetzung der Analyse zeigte, dass der Fehler eine Folge des Versuchs ist, lokale statische Variablen zu initialisieren. <br><br><div class="spoiler">  <b class="spoiler_title">Lyrischer Exkurs</b> <div class="spoiler_text">  In Anbetracht des zerlegten Codes fand ich übrigens gleichzeitig die Antwort auf eine Frage, die ich mir manchmal stellte, die aber zu faul war, um sofort zu googeln: Wie wird die Situation gelöst, wenn zwei oder mehr Threads gleichzeitig versuchen können, eine solche Variable zu initialisieren?  Es stellte sich heraus, dass in diesem Fall der Compiler die Initialisierung mit Semaphoren arrangiert, um sicherzustellen, dass jeweils nur ein Thread die gesamte Prozedur durchläuft und der Rest wartet, bis der erste abgeschlossen ist.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieses Verhalten wurde seit C ++ 11 standardisiert.</a>  Wussten Sie schon?  Ich nicht. </div></div><br><h3>  Kapitel 2 </h3><br>  Sobald die Laufzeit mit der Erstellung von Variablen beschäftigt ist, kann er nach Abschluss des Programms auch Destruktoren aufrufen (auch wenn das Programm die Arbeit nie tatsächlich abschließt, was für Mikrocontroller die absolute Norm ist).  Dazu muss er irgendwo Informationen zu allen Variablen speichern, die er initialisiert hat. <br><br>  Das ist genau dort, wo solche Informationen in einer Art interner Liste gespeichert sind, ist auch die Laufzeit gesunken.  Da die Funktion malloc (), über die Speicher für die Elemente dieser Liste zugewiesen wurde und die gemäß dem Standard Blöcke erzeugt, die garantiert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mindestens an der 8-Byte-Grenze ausgerichtet sind</a> , nach einer n-ten Anzahl erfolgreicher Aufrufe ein Stück erzeugt, das an dieser Grenze nicht ausgerichtet ist. <br><br><img src="https://habrastorage.org/webt/sx/0c/bw/sx0cbwlau__vlj2kwrdznxmehew.jpeg"><br><br>  Änderungen im neuen Firmware-Code brachen malloc ?!  Aber wie ist das überhaupt möglich?  Ich habe malloc nicht genau neu definiert, ich selbst brauche es nirgendwo anders! <br><br>  Nützlich in den Compiler-Optionen, um nach einigen Schlüsselwörtern zu suchen, helfen, aber es wurde überall klar gesagt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">malloc () garantiert die Ausgabe des Speichers entlang der Grundgrenze ausgerichtet.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oder Nullzeiger, falls nicht genügend Speicher vorhanden ist</a> . <br><br><h3>  Kapitel 3 </h3><br>  Lange Zeit blieb ich sinnlos im Code, setzte Haltepunkte, litt und verstand nichts, bis es irgendwann nicht mehr stocherte und ich mir die von malloc zurückgegebenen Adressen genau ansah.  Zuvor sollte bei der gesamten Analyse festgestellt werden, ob die letzte Ziffer der Adresse 0x4 ist.  Und jetzt begann er, die Adressen, die durch aufeinanderfolgende Anrufe bei malloc ausgegeben wurden, vollständig miteinander zu vergleichen. <br><br>  Und oh, ein Wunder! <br><br>  Alle erfolgreichen Anrufe gaben Adressen aus dem RAM-Speicher aus (0x20000000 und älter für diesen Stein) und nahmen von Anruf zu Anruf nacheinander zu.  Und der erste erfolglose gab 0x00000036 zurück.  Das heißt, die Adresse ist nicht nur nicht ausgerichtet, sondern befand sich auch überhaupt nicht im Adressraum des RAM!  Der Prozessor versuchte dort etwas zu schreiben und fiel natürlich hin. <br><br>  Und selbst wenn malloc () gemäß dem Standard gehandelt und 0 zurückgegeben hätte, wenn nicht genügend Speicherplatz vorhanden gewesen wäre, hätte dies überraschenderweise nichts im Sinne eines Programmabsturzes geändert (es sei denn, die Ursache des Fehlers wäre zuvor geklärt worden).  Der von malloc zurückgegebene Wert wird weiterhin in keiner Weise überprüft, sondern wird sofort aktiviert.  Dies ist zur Laufzeit. <br><br><h3>  Nachwort </h3><br>  Die Größe des Heapspeichers in der Konfigurationsdatei wurde erhöht, und alles wurde behoben. <br><br>  Aber vor diesem Moment habe ich nicht einmal an die Lautstärke gedacht.  Ob sich die Hölle mir ergeben hat, dachte ich.  Wie auch immer, ich habe alle Variablen und Objekte entweder statisch oder auf dem Stapel.  Nur durch Trägheit habe ich 0x300 Bytes darunter gelassen, da in allen Vorlagenprojekten ein gewisses Volumen unter dem Heap zugewiesen ist.  Aber nein, die C ++ - Laufzeit benötigt nach den Standards der Controller immer noch dynamisch zugewiesenen Speicher und dies in beachtlichen Mengen. <br><br>  Lebe und lerne. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453944/">https://habr.com/ru/post/de453944/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453930/index.html">Vergleich und Auswahl von Datenmigrationssystemen</a></li>
<li><a href="../de453932/index.html">Ein paar Worte zur Verteidigung des Monolithen</a></li>
<li><a href="../de453934/index.html">11 Fragen, die vor Arbeitsbeginn zu besprechen sind</a></li>
<li><a href="../de453938/index.html">NB-IoT Stolen Bike Tracking</a></li>
<li><a href="../de453942/index.html">Über Ethik mit dem PMI-Codex-Beispiel</a></li>
<li><a href="../de453950/index.html">Du sollst hier sein! 22 Jahre nach Veröffentlichung des legendären Spiels Duke Nukem 3D</a></li>
<li><a href="../de453952/index.html">"Die Anfrage ist gereift": Alexei Fedorov über eine neue Konferenz über verteilte Systeme</a></li>
<li><a href="../de453956/index.html">Museum DataArt. Videoterminal ADM-3A. Das Auto ist schwer, zuverlässig, geschlachtet</a></li>
<li><a href="../de453958/index.html">Monorepositories: bitte</a></li>
<li><a href="../de453960/index.html">Globales DevOps Bootcamp 2019 in Moskau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>