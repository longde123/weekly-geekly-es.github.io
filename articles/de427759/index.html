<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì† ü§´ üßê √úber die L√∂sbarkeit von Umgehungsproblemen in der Polynomzeit ‚ôéÔ∏è üòè ü••</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Sch√ºler lernen das Problem der Umgehungsstra√üe durch die Teilnahme an Bioinformatikkursen kennen. Einer der qualitativ hochwertigsten und f√ºr Prog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úber die L√∂sbarkeit von Umgehungsproblemen in der Polynomzeit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427759/">  Die Sch√ºler lernen das Problem der Umgehungsstra√üe durch die Teilnahme an Bioinformatikkursen kennen. Einer der qualitativ hochwertigsten und f√ºr Programmierer am besten geeigneten Kurse ist der Bioinformatikkurs (Pavel Pevzner) auf der Coursera der University of California in San Diego.  Das Problem f√§llt durch die Einfachheit der Aussage, die praktische Bedeutung und die Tatsache auf, dass es immer noch als ungel√∂st angesehen wird und offensichtlich in der Lage ist, es mit einfacher Codierung zu l√∂sen.  Das Problem wird auf diese Weise gestellt.  Ist es m√∂glich, die Koordinaten einer Menge von Punkten <u>in der Polynomzeit</u> wiederherzustellen <u>?</u> <math> </math> $ inline $ X $ inline $   wenn die Menge aller paarweisen Abst√§nde zwischen ihnen bekannt ist <math> </math> $ inline $ \ Delta X $ inline $   ? <br><br>  Diese scheinbar einfache Aufgabe steht immer noch auf der Liste der ungel√∂sten Probleme der Rechengeometrie.  Dar√ºber hinaus betrifft die Situation nicht einmal Punkte in mehrdimensionalen R√§umen, insbesondere gekr√ºmmte, das Problem ist bereits die einfachste Option - wenn alle Punkte ganzzahlige Koordinaten haben und auf derselben Linie lokalisiert sind. <br><a name="habracut"></a><br>  In den letzten fast einem halben Jahrhundert, seit diese Aufgabe von Mathematikern als Herausforderung erkannt wurde (Shamos, 1975), wurden einige Ergebnisse erzielt.  Wir halten zwei F√§lle f√ºr ein eindimensionales Problem f√ºr m√∂glich: <br><br><ol><li>  Punkte liegen auf einer geraden Linie (Turnpike-Problem) </li><li>  Punkte befinden sich auf einem Kreis (Umgehungsproblem) </li></ol><br>  Diese beiden F√§lle erhielten aus einem bestimmten Grund unterschiedliche Namen - es sind unterschiedliche Anstrengungen erforderlich, um sie zu l√∂sen.  In der Tat wurde die erste Aufgabe schnell genug gel√∂st (in 15 Jahren) und ein Backtracking-Algorithmus wurde erstellt, der die L√∂sung im Durchschnitt in quadratischer Zeit wiederherstellt <math> </math> $ inline $ O (n ^ 2 \ log n) $ inline $   wo <math> </math> $ inline $ n $ inline $   - die Anzahl der Punkte (Skiena, 1990);  F√ºr die zweite Aufgabe wurde dies bisher nicht durchgef√ºhrt, und der am besten vorgeschlagene Algorithmus weist eine exponentielle Rechenkomplexit√§t auf <math> </math> $ inline $ O (n ^ n \ log n) $ inline $   (Lemke, 2003).  Das folgende Bild zeigt eine Sch√§tzung, wie lange Ihr Computer arbeiten wird, um eine L√∂sung f√ºr ein Set mit einer anderen Anzahl von Punkten zu erhalten. <br><br><img src="https://habrastorage.org/webt/tt/ye/xn/ttyexncu2xqbyfqk0jd4tbcv0nm.jpeg"><br><br>  Das hei√üt, in einer psychologisch akzeptablen Zeit (~ 10 Sekunden) k√∂nnen Sie viele wiederherstellen <math> </math> $ inline $ X $ inline $   Bis zu 10 Tausend Punkte in einem Turnpike-Koffer und nur ~ 10 Punkte in einem Beltway-Koffer, was f√ºr praktische Anwendungen absolut wertlos ist. <br><br>  Eine kleine Klarstellung.  Es wird angenommen, dass das Turnpike-Problem im Hinblick auf die praktische Verwendung gel√∂st ist, dh f√ºr die √ºberwiegende Mehrheit der angetroffenen Daten.  In diesem Fall werden die Einw√§nde reiner Mathematiker gegen die Tatsache, dass es spezielle Datens√§tze gibt, f√ºr die die Zeit, um eine L√∂sung zu erhalten, exponentiell ignoriert <math> </math> $ inline $ O (2 ^ n \ log n) $ inline $   (Zhang, 1982).  Im Gegensatz zu Turnpike kann das Umgehungsproblem mit seinem Exponentialalgorithmus in keiner Weise als gel√∂st angesehen werden. <br><br><h3>  Bedeutung der L√∂sung von Umgehungsproblemen im Hinblick auf die Bioinformatik </h3><br>  Ende des 20. Jahrhunderts wurde ein neuer Syntheseweg f√ºr Biomolek√ºle entdeckt, der als nichtribosomaler Syntheseweg bezeichnet wird.  Der Hauptunterschied zum klassischen Syntheseweg besteht darin, dass das endg√ºltige Syntheseergebnis √ºberhaupt nicht in DNA kodiert wird.  Stattdessen wird nur der Code von ‚ÄûWerkzeugen‚Äú (viele verschiedene Synthetasen), die diese Objekte sammeln k√∂nnen, in die DNA geschrieben.  Somit ist die Biomaschinentechnik erheblich angereichert, und anstelle eines einzelnen Sammlertyps (Ribosom), der nur mit 20 Standardteilen (Standardaminos√§uren, auch als proteinogen bezeichnet) arbeitet, erscheinen viele andere Sammlertypen, die mit mehr als 500 Standard- und Nichtstandardteilen arbeiten k√∂nnen (nicht proteinogene Aminos√§uren und ihre verschiedenen Modifikationen).  Und diese Assembler k√∂nnen nicht nur Teile zu Ketten verbinden, sondern auch sehr komplizierte Strukturen erhalten - zyklisch, verzweigt sowie Strukturen mit vielen Zyklen und Verzweigungen.  All dies erh√∂ht das Arsenal der Zelle f√ºr verschiedene F√§lle ihres Lebens erheblich.  Die biologische Aktivit√§t solcher Strukturen ist hoch, auch die Spezifit√§t (Selektivit√§t der Wirkung), eine Vielzahl von Eigenschaften ist nicht begrenzt.  Die Klasse dieser Zellprodukte wird in der englischen Literatur als NRPs (nicht-ribosomale Produkte oder nicht-ribosomale Peptide) bezeichnet.  Biologen hoffen, dass gerade unter solchen Produkten des Zellstoffwechsels neue pharmakologische Pr√§parate gefunden werden k√∂nnen, die hochwirksam sind und aufgrund ihrer Spezifit√§t keine Nebenwirkungen haben. <br><br>  Die Frage ist nur, wie und wo nach NRPs gesucht werden soll.  Sie sind sehr effektiv, daher muss die Zelle sie absolut nicht in gro√üen Mengen produzieren, und ihre Konzentrationen sind vernachl√§ssigbar.  Daher sind chemische Extraktionsmethoden mit ihrer geringen Genauigkeit von ~ 1% und den enormen Reagenzien- und Zeitkosten nutzlos.  Weiter.  Sie sind nicht in DNA kodiert, was bedeutet, dass alle Datenbanken, die w√§hrend der Dekodierung des Genoms akkumuliert wurden, sowie alle Methoden der Bioinformatik und Genomik ebenfalls unbrauchbar sind.  Der einzige Weg, etwas zu finden, sind physikalische Methoden, n√§mlich Massenspektroskopie.  Dar√ºber hinaus ist das Nachweisniveau von Substanzen in modernen Spektrometern so hoch, dass unbedeutende Mengen mit insgesamt&gt; ~ 800 Molek√ºlen (atto-molarer Bereich oder Konzentration) gefunden werden k√∂nnen <math> </math> $ inline $ 10 ^ {- 18} $ inline $   ) <br><br><img src="https://habrastorage.org/webt/rw/hx/gj/rwhxgjyugok3edbfnytfqinvmvi.jpeg">  "" <br><br>  Wie funktioniert ein Massenspektrometer?  In der Arbeitskammer des Ger√§ts werden Molek√ºle in Fragmente zerlegt (h√§ufiger durch Kollisionen miteinander, seltener durch √§u√üere Einfl√ºsse).  Diese Fragmente werden ionisiert und dann beschleunigt und in einem externen elektromagnetischen Feld getrennt.  Die Trennung erfolgt entweder durch den Zeitpunkt, zu dem der Detektor erreicht wird, oder durch den Drehwinkel im Magnetfeld, da die Masse des Fragments gr√∂√üer und seine Ladung geringer ist, je ungeschickter es ist.  Somit "wiegt" das Massenspektrometer die Massen von Fragmenten.  Dar√ºber hinaus kann das "Wiegen" schrittweise erfolgen, indem Fragmente mit derselben Masse (genauer gesagt mit einem Wert) wiederholt gefiltert werden <math> </math> $ inline $ m / z $ inline $   ) und treiben sie durch Fragmentierung mit weiterer Trennung.  Zweistufige Massenspektrometer sind weit verbreitet und werden als Tandem-Massenspektrometer bezeichnet. Mehrstufige Massenspektrometer sind √§u√üerst selten und werden einfach als bezeichnet <math> </math> $ inline $ ms ^ n $ inline $   wo <math> </math> $ inline $ n $ inline $   - die Anzahl der Stufen.  Und hier erscheint die Aufgabe, wie man, wenn man nur die Massen aller Arten von Fragmenten eines Molek√ºls kennt, seine Struktur kennt?  So kamen wir zu Turnpike- und Beltway-Problemen f√ºr lineare bzw. cyclische Peptide. <br><br>  Ich werde am Beispiel eines cyclischen Peptids genauer erkl√§ren, wie die Aufgabe der Wiederherstellung der Struktur eines Biomolek√ºls auf die angegebenen Probleme reduziert wird. <br><br><img src="https://habrastorage.org/webt/ly/5w/_n/ly5w_nxe55-vjooh2jy-l4oa0yy.jpeg"><br><br>  Das cyclische Peptid ABCD im ersten Stadium der Fragmentierung kann an 4 Stellen entweder durch DA-Verkn√ºpfung oder durch AB, BC oder CD gebrochen werden, wobei 4 m√∂gliche lineare Peptide gebildet werden - entweder ABCD, BCDA, CDAB oder DABC.  Da eine gro√üe Anzahl identischer Peptide das Spektrometer passiert, werden am Ausgang Fragmente aller vier Typen vorhanden sein.  Dar√ºber hinaus stellen wir fest, dass alle Fragmente die gleiche Masse haben und im ersten Stadium nicht getrennt werden k√∂nnen.  In der zweiten Stufe kann das lineare Fragment ABCD an drei Stellen gebrochen werden, wobei kleinere Fragmente mit unterschiedlichen Massen A und BCD, AB und CD, ABC und D gebildet werden und das entsprechende Massenspektrum gebildet wird.  In diesem Spektrum ist die Fragmentmasse entlang der x-Achse und die Anzahl kleiner Fragmente mit einer gegebenen Masse entlang der y-Achse aufgetragen.  In √§hnlicher Weise werden Spektren f√ºr die verbleibenden drei linearen Fragmente von BCDA, CDAB und DABC gebildet.  Da alle 4 gro√üen Fragmente in die zweite Stufe √ºbergegangen sind, werden alle ihre Spektren addiert.  Insgesamt ist das Ergebnis eine gewisse Masse <math> </math> $ inline $ \ {m_1 ^ {n_1}, m_2 ^ {n_2}, .., m_q ^ {n_q} \} $ inline $   wo <math> </math> $ inline $ m_i $ inline $   - etwas Masse und <math> </math> $ inline $ n_i $ inline $   - die H√§ufigkeit seiner Wiederholung.  Gleichzeitig wissen wir nicht, zu welchem ‚Äã‚ÄãFragment diese Masse geh√∂rt und ob dieses Fragment einzigartig ist, da verschiedene Fragmente eine Masse haben k√∂nnen.  Je weiter die Bindungen im Peptid voneinander entfernt sind, desto gr√∂√üer ist die Masse des Peptidfragments zwischen ihnen.  Das hei√üt, die Aufgabe, die Reihenfolge der Elemente in einem cyclischen Peptid wiederherzustellen, reduziert sich auf ein Umgehungsproblem, bei dem die Elemente des Satzes <math> </math> $ inline $ X $ inline $   sind Bindungen im Peptid und Elemente einer Vielzahl <math> </math> $ inline $ \ Delta X $ inline $   - Massen von Fragmenten zwischen Bindungen. <br><br><h3>  Antizipation der Existenz eines Algorithmus mit Polynomzeit zur L√∂sung von Umgehungsproblemen </h3><br>  Aus meiner Erfahrung und aus der Kommunikation mit Menschen, die versucht oder wirklich etwas getan haben, um dieses Problem zu l√∂sen, habe ich festgestellt, dass die √ºberwiegende Mehrheit der Menschen versucht, es entweder im allgemeinen Fall oder f√ºr ganzzahlige Daten in einem engen Bereich wie diesem zu l√∂sen (1, 50).  Beide Optionen sind zum Scheitern verurteilt.  F√ºr den allgemeinen Fall wurde nachgewiesen, dass die Gesamtzahl der L√∂sungen f√ºr Umgehungsprobleme im eindimensionalen Fall <math> </math> $ inline $ S_1 (n) $ inline $   begrenzt durch Werte (Lemke, 2003) <p><math> </math> $$ display $$ e ^ {2 ^ {\ frac {\ ln n} {\ ln \ ln n} + o (1)}} \ leq S_1 (n) \ leq \ frac {1} {2} n ^ {n-2} $$ Anzeige $$ </p>  was das Vorhandensein einer exponentiellen Anzahl von L√∂sungen in der Asymptotik bedeutet <math> </math> $ inline $ n \ rightarrow \ infty $ inline $   .  Wenn die Anzahl der L√∂sungen exponentiell zunimmt, kann der Zeitpunkt ihres Eingangs nat√ºrlich nicht langsamer wachsen.  Das hei√üt, f√ºr den allgemeinen Fall ist es unm√∂glich, eine Polynomzeitl√∂sung zu erhalten.  Bei ganzzahligen Daten in einem engen Bereich kann alles experimentell √ºberpr√ºft werden, da es nicht allzu schwierig ist, Code zu schreiben, der durch umfassende Suche nach einer L√∂sung sucht.  F√ºr kleine <math> </math> $ inline $ n $ inline $   Ein solcher Code wird nicht sehr lange dauern.  Die Testergebnisse eines solchen Codes zeigen, dass unter solchen Datenbedingungen die Gesamtzahl der verschiedenen L√∂sungen f√ºr jeden Satz <math> </math> $ inline $ \ Delta X $ inline $   schon klein <math> </math> $ inline $ n $ inline $   w√§chst auch extrem stark. <br><br>  Nachdem Sie diese Fakten kennengelernt haben, k√∂nnen Sie diese Aufgabe aufgeben und aufgeben.  Ich gebe zu, dass dies einer der Gr√ºnde ist, warum das Umgehungsproblem immer noch als ungel√∂st gilt.  Es gibt jedoch L√ºcken.  Denken Sie daran, dass die Exponentialfunktion <math> </math> $ inline $ e ^ {\ alpha x} $ inline $   verh√§lt sich sehr interessant.  Zuerst w√§chst es furchtbar langsam und steigt √ºber ein unendlich gro√ües Intervall von 0 auf 1 an <math> </math> $ inline $ \ infty $ inline $   auf 0, dann beschleunigt sich sein Wachstum immer mehr.  Je niedriger jedoch der Wert <math> </math> $ inline $ \ alpha $ inline $   Je gr√∂√üer der Wert sein sollte <math> </math> $ inline $ x $ inline $   so dass das Ergebnis der Funktion √ºber einen eingestellten Wert springt <math> </math> $ inline $ y = \ xi $ inline $   .  Als solcher Wert ist es bequem, eine Zahl zu w√§hlen <math> </math> $ inline $ \ xi = 2 $ inline $   Vor ihm die einzige L√∂sung, nach ihm gibt es viele Entscheidungen.  Frage  Und hat jemand die Abh√§ngigkeit der Anzahl der Entscheidungen davon √ºberpr√ºft, welche Daten in die Eingabe gelangen?  Ja, ich habe es getan.  Es gibt eine wunderbare Doktorarbeit der kroatischen Mathematikerin Tamara Dakis (Dakic, 2000), in der sie festlegte, welche Bedingungen die Eingabedaten erf√ºllen m√ºssen, damit das Problem in Polynomzeit gel√∂st werden kann.  Die wichtigsten davon sind die Eindeutigkeit der L√∂sung und das Fehlen von Duplikaten im Satz der Eingabedaten <math> </math> $ inline $ \ Delta X $ inline $   .  Das Niveau ihrer Doktorarbeit ist sehr hoch.  Es ist bedauerlich, dass sich diese Studentin nur auf ein Turnpike-Problem beschr√§nkt hat. Ich bin √ºberzeugt, dass dies l√§ngst gel√∂st gewesen w√§re, wenn sie ihr Interesse an dem Umgehungsproblem gewendet h√§tte. <br><br><h3>  Erhalten eines Algorithmus mit Polynomzeit zur L√∂sung von Umgehungsproblemen </h3><br>  Es war m√∂glich, die Daten zu finden, f√ºr die es m√∂glich ist, den gew√ºnschten Algorithmus zuf√§llig zu erstellen.  Es brauchte zus√§tzliche Ideen.  Die Hauptidee ergab sich aus der Beobachtung (siehe oben), dass das Spektrum eines cyclischen Peptids die Summe der Spektren aller linearen Peptide ist, die bei Einzelringbr√ºchen gebildet werden.  Da die Sequenz von Aminos√§uren in einem Peptid aus einem solchen linearen Peptid wiederhergestellt werden kann, ist die Gesamtzahl der Linien im Spektrum signifikant (in <math> </math> $ inline $ n $ inline $   mal wo <math> </math> $ inline $ n $ inline $   - Die Anzahl der Aminos√§uren im Peptid ist zu hoch.  Die Frage ist nur, welche Linien aus dem Spektrum ausgeschlossen werden sollten, um die F√§higkeit zur Wiederherstellung der Sequenz nicht zu verlieren.  Da beide Aufgaben (Wiederherstellung der cyclischen Peptidsequenz aus dem Massenspektrum und dem Umgehungsproblem) mathematisch isomorph sind, ist es auch m√∂glich, viele auszud√ºnnen <math> </math> $ inline $ \ Delta X $ inline $   . <br><br>  Ausd√ºnnungsvorg√§nge <math> </math> $ inline $ \ Delta X $ inline $   wurden unter Verwendung lokaler Symmetrien der Menge konstruiert <math> </math> $ inline $ \ Delta X $ inline $   (Fomin, 2016a). <br><br><ul><li>  Symmetrisierung  Die erste Operation besteht darin, ein beliebiges Element der Menge auszuw√§hlen <math> </math> $ inline $ x _ {\ mu} \ in \ Delta X $ inline $   und entfernen von <math> </math> $ inline $ \ Delta X $ inline $   alle Elemente au√üer denen, die symmetrische Paare in Bezug auf Punkte haben <math> </math> $ inline $ x _ {\ mu} / 2 $ inline $   und <math> </math> $ inline $ (L + x _ {\ mu}) / 2 $ inline $   wo <math> </math> $ inline $ L $ inline $   - Umfang (ich erinnere mich, dass sich im Umgehungsfall alle Punkte auf dem Kreis befinden). </li><li>  Teill√∂sungsfaltung.  Die zweite Operation verwendet das R√§tselraten √ºber die L√∂sung, dh die Kenntnis der einzelnen Punkte, die zur L√∂sung geh√∂ren, die sogenannte Teill√∂sung.  Von vielen <math> </math> $ inline $ \ Delta X $ inline $   Alle Elemente werden ebenfalls gel√∂scht, mit Ausnahme derjenigen, die die Bedingung erf√ºllen. Wenn wir den Abstand zwischen dem zu testenden Punkt und allen Punkten einer Teill√∂sung messen, sind <u>alle</u> erhaltenen Werte in <math> </math> $ inline $ \ Delta X $ inline $   .  Ich werde klarstellen, dass, wenn mindestens eine der erhaltenen Entfernungen in fehlt <math> </math> $ inline $ \ Delta X $ inline $   dann wird der Punkt ignoriert. </li></ul><br>  Es wurde bewiesen, dass beide Operationen die Menge verd√ºnnen <math> </math> $ inline $ \ Delta X $ inline $   Es sind jedoch noch gen√ºgend Elemente vorhanden, um die L√∂sung wiederherzustellen <math> </math> $ inline $ X $ inline $   .  Unter Verwendung dieser Operationen wurde ein Algorithmus erstellt und in c ++ implementiert, um das Umgehungsproblem zu l√∂sen (Fomin, 2016b).  Der Algorithmus unterscheidet sich kaum vom klassischen Backtracking-Algorithmus (dh wir versuchen, eine L√∂sung zu erstellen, indem wir m√∂gliche Optionen aufz√§hlen und zur√ºckkehren, wenn w√§hrend der Erstellung ein Fehler auftritt).  Der einzige Unterschied besteht darin, die Menge einzugrenzen <math> </math> $ inline $ \ Delta X $ inline $   uns zu testen wird deutlich weniger m√∂glichkeiten. <br><br>  Hier ist ein Beispiel daf√ºr, wie viele <math> </math> $ inline $ \ Delta X $ inline $   beim Ausd√ºnnen. <br><br><img src="https://habrastorage.org/webt/i_/c1/ae/i_c1ae44o0uxkkyvmvi-kutlirq.jpeg"><br><br>  Computerexperimente wurden f√ºr zuf√§llig erzeugte cyclische Peptide mit einer L√§nge durchgef√ºhrt <math> </math> $ inline $ n $ inline $   10 bis 1000 Aminos√§uren (die Ordinatenachse auf einer logarithmischen Skala).  Die Abszisse zeigt auch auf einer logarithmischen Skala die Anzahl der Elemente in den Mengen, die durch verschiedene Operationen ausged√ºnnt wurden <math> </math> $ inline $ \ Delta X $ inline $   in Einheiten <math> </math> $ inline $ n $ inline $   .  Eine solche Darstellung ist absolut ungew√∂hnlich, daher werde ich entschl√ºsseln, wie sie an einem Beispiel gelesen wird.  Wir sehen uns das linke Diagramm an.  Lassen Sie das Peptid eine L√§nge haben <math> </math> $ inline $ n = 100 $ inline $   .  F√ºr ihn die Anzahl der Elemente im Set <math> </math> $ inline $ \ Delta X $ inline $   gleich <math> </math> $ inline $ n ^ 2 = 10000 $ inline $   (Dies ist ein Punkt auf der oberen gestrichelten Linie <math> </math> $ inline $ y = n ^ 2 $ inline $   )  Nach dem Entfernen aus dem Set <math> </math> $ inline $ \ Delta X $ inline $   sich wiederholende Elemente, Anzahl der Elemente in <math> </math> $ inline $ \ Delta X $ inline $   sinkt auf <math> </math> $ inline $ n_D \ ca. n ^ {1.9} \ ca. 6300 $ inline $   (Kreise mit Kreuzen).  Nach der Symmetrisierung sinkt die Anzahl der Elemente auf <math> </math> $ inline $ n_S \ ca. n ^ {1,75} \ ca. 3100 $ inline $   (schwarze Kreise) und nach Faltung durch Teill√∂sung zu <math> </math> $ inline $ n_C \ ca. n ^ {1.35} \ ca. 500 $ inline $   (Kreuze).  Total, das Gesamtvolumen des Sets <math> </math> $ inline $ \ Delta X $ inline $   nur um das 20-fache reduziert.  F√ºr ein Peptid gleicher L√§nge, aber im rechten Diagramm, kommt die Kontraktion von <math> </math> $ inline $ n ^ 2 = 10000 $ inline $   vorher <math> </math> $ inline $ N_C \ ca. n \ ca. 100 $ inline $   das hei√üt 100 mal. <br><br>  Beachten Sie, dass die Generierung von Testf√§llen f√ºr das linke Diagramm so durchgef√ºhrt wird, dass der Grad der Duplizierung erreicht wird <math> </math> $ inline $ k_ {dup} $ inline $   in <math> </math> $ inline $ \ Delta X $ inline $   lag im Bereich von 0,1 bis 0,3 und rechts - weniger als 0,1.  Der Grad der Duplizierung ist definiert als <math> </math> $ inline $ k_ {dup} = 2- \ log {N_u} / \ log {n} $ inline $   wo <math> </math> $ inline $ N_u $ inline $   - die Anzahl der eindeutigen Elemente im Set <math> </math> $ inline $ \ Delta X $ inline $   .  Eine solche Definition ergibt ein nat√ºrliches Ergebnis: Wenn keine Duplikate in der Menge vorhanden sind <math> </math> $ inline $ \ Delta X $ inline $   seine Macht ist gleich <math> </math> $ inline $ N_u = n ^ 2 $ inline $   und <math> </math> $ inline $ k_ {dup} = 0 $ inline $   bei der maximal m√∂glichen Vervielf√§ltigung <math> </math> $ inline $ N_u = n $ inline $   und <math> </math> $ inline $ k_ {dup} = 1 $ inline $   .  Wie man es erm√∂glicht, eine andere Duplizierungsstufe bereitzustellen, werde ich etwas sp√§ter sagen.  Die Diagramme zeigen, dass je geringer der Duplizierungsgrad ist, desto d√ºnner wird es <math> </math> $ inline $ \ Delta X $ inline $   bei <math> </math> $ inline $ k_ {dup} &lt;0.1 $ inline $   Anzahl der verd√ºnnten Elemente <math> </math> $ inline $ \ Delta X $ inline $   im Allgemeinen erreicht seine Grenze <math> </math> $ inline $ O (n ^ 2) \ rightarrow O (n) $ inline $   , da in der dezimierten Menge kleiner als ist <math> </math> $ inline $ O (n) $ inline $   Elemente k√∂nnen nicht abgerufen werden (Operationen speichern gen√ºgend Elemente, um eine L√∂sung zu erhalten, in der <math> </math> $ inline $ n $ inline $   Elemente).  Die Tatsache, die Macht von einzugrenzen <math> </math> $ inline $ \ Delta X $ inline $   bis zur Untergrenze ist sehr wichtig, er ist es, der zu dramatischen √Ñnderungen in der rechnerischen Komplexit√§t des Erhaltens einer L√∂sung f√ºhrt. <br><br>  Nach dem Einf√ºgen von Ausd√ºnnungsoperationen in den Backtracking-Algorithmus und dem L√∂sen des Umgehungsproblems wurde ein vollst√§ndiges Analogon dessen enth√ºllt, wor√ºber Tamara Dakis in Bezug auf das Turnpike-Problem sprach.  Lass mich dich erinnern.  Sie sagte, dass es f√ºr Turnpike-Probleme m√∂glich ist, eine L√∂sung in Polynomzeit zu erhalten, wenn die L√∂sung eindeutig ist und es keine Duplizierung gibt <math> </math> $ inline $ \ Delta X $ inline $   .  Es stellte sich heraus, dass ein v√∂lliges Fehlen von Duplikaten nicht erforderlich ist (f√ºr reale Daten ist dies kaum m√∂glich). Es reicht aus, dass der Pegel recht gering sein wird.  Die folgende Abbildung zeigt, wie viel Zeit erforderlich ist, um eine L√∂sung des Umgehungsproblems zu erhalten, abh√§ngig von der L√§nge des Peptids und dem Grad der Duplikation in <math> </math> $ inline $ \ Delta X $ inline $   . <br><br><img src="https://habrastorage.org/webt/dt/mp/oa/dtmpoaofmxxdk_fhmdxqdqsbxmu.jpeg"><br><br>  In der Figur sind sowohl die Abszisse als auch die Ordinate auf einer logarithmischen Skala angegeben.  So k√∂nnen Sie deutlich erkennen, ob die Abh√§ngigkeit der Z√§hlzeit von der Sequenzl√§nge liegt <math> </math> $ inline $ T = f (n) $ inline $   Exponential (gerade Linie) oder Polynom (logarithmische Kurve).  Wie in den Diagrammen zu sehen ist, wird die L√∂sung mit einem geringen Duplikationsgrad (rechtes Diagramm) in Polynomzeit erhalten.  Genauer gesagt wird die L√∂sung in quadratischer Zeit erhalten.  Dies tritt auf, wenn Ausd√ºnnungsvorg√§nge die Leistung des Ger√§ts auf eine Untergrenze reduzieren. <math> </math> $ inline $ O (n ^ 2) \ rightarrow O (n) $ inline $   Es gibt nur noch wenige Punkte, die zur√ºckgegeben werden, wenn das Iterieren √ºber Optionen einzeln wird, und der Algorithmus h√∂rt im Wesentlichen auf, √ºber Optionen zu iterieren, sondern erstellt einfach eine L√∂sung aus dem, was √ºbrig bleibt. <br><br>  PS Nun, ich werde das letzte Geheimnis bez√ºglich der Erzeugung von Sets auf verschiedenen Ebenen der Vervielf√§ltigung enth√ºllen.  Dies ist auf die unterschiedliche Genauigkeit der Datenpr√§sentation zur√ºckzuf√ºhren.  Wenn die Daten mit geringer Genauigkeit generiert werden (z. B. auf ganze Zahlen gerundet), wird der Duplizierungsgrad mit mehr als 0,3 hoch.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Daten mit guter Genauigkeit generiert werden, beispielsweise mit bis zu 3 Dezimalstellen, nimmt der Duplizierungsgrad stark ab, weniger als 0,1. Und von hier folgt die letzte wichtige Bemerkung. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr reale Daten wird das Problem der Umgehungsstra√üe unter Bedingungen immer h√∂herer Messgenauigkeit in Echtzeit l√∂sbar.</font></font><br></i> <br><br>  Literatur <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Dakic, T. (2000). Auf dem Turnpike-Problem. Doktorarbeit, Simon Fraser University. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Fomin. E. (2016a) Ein einfacher Ansatz zur Rekonstruktion einer Menge von Punkten aus dem Multiset von n ^ 2 paarweisen Abst√§nden in n ^ 2 Schritten f√ºr das Sequenzierungsproblem: I. Theorie. J Comput Biol. 2016, 23 (9): 769 &amp; ndash; 75. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Fomin. E. (2016b) Ein einfacher Ansatz zur Rekonstruktion eines Satzes von Punkten aus dem Multiset von n ^ 2 paarweisen Abst√§nden in n ^ 2 Schritten f√ºr das Sequenzierungsproblem: II. Algorithmus. J Comput Biol. 2016, 23 (12): 934 &amp; ndash; 942. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Lemke, P., Skiena, S. und Smith, W. (2003). Rekonstruieren von Mengen aus Zwischenpunktabst√§nden. Diskrete und rechnergest√ºtzte Geometriealgorithmen und Kombinatorik, 25: 597‚Äì631.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. S. Skiena, W. Smith und P. Lemke (1990). </font><font style="vertical-align: inherit;">Rekonstruktion von Mengen aus Zwischenpunktabst√§nden. </font><font style="vertical-align: inherit;">In Proceedings of the Sixth ACM Symposium on Computational Geometry, S. 332‚Äì339. </font><font style="vertical-align: inherit;">Berkeley, CA </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Zhang, Z. 1982. Ein exponentielles Beispiel f√ºr einen partiellen Digest-Mapping-Algorithmus. </font><font style="vertical-align: inherit;">J. Comp. </font><font style="vertical-align: inherit;">Biol. </font><font style="vertical-align: inherit;">1, 235‚Äì240.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427759/">https://habr.com/ru/post/de427759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427747/index.html">Wer ein unbemanntes Auto vernichten soll: Ergebnisse des Moral Machine-Experiments</a></li>
<li><a href="../de427749/index.html">Apple und Samsung haben zum ersten Mal eine Geldstrafe wegen Verlangsamung alter Telefone verh√§ngt</a></li>
<li><a href="../de427751/index.html">CudaText Erhabene Ideen</a></li>
<li><a href="../de427755/index.html">Neue Version von GitLab 11.4 mit Peer Review von Zusammenf√ºhrungsanforderungen und Feature-Flags</a></li>
<li><a href="../de427757/index.html">Zusammengebaute Microcode-Hintert√ºren des X86-Prozessors</a></li>
<li><a href="../de427761/index.html">Implementierung des k-means (k-means) -Algorithmus am Beispiel der Arbeit mit Pixeln</a></li>
<li><a href="../de427763/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 13: Netzwerkprotokolle, Teil 1</a></li>
<li><a href="../de427767/index.html">Situation: In Kanada wurde vorgeschlagen, eine Steuer auf Streaming einzuf√ºhren - wir diskutieren das Problem</a></li>
<li><a href="../de427771/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 13: Netzwerkprotokolle, Teil 2</a></li>
<li><a href="../de427773/index.html">Ich habe eine browser√ºbergreifende Erweiterung f√ºr Registerkarten geschrieben, aber das tun Sie nicht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>