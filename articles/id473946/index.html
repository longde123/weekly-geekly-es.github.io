<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â—¾ï¸ ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§ ğŸ¤™ğŸ¾ Penebangan Terdistribusi dan Pelacakan untuk Layanan Mikro ğŸ‘©ğŸ»â€ğŸš’ ğŸ†— ğŸ‘©ğŸ¼â€âœˆï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Logging adalah bagian penting dari aplikasi apa pun. Setiap sistem logging melewati tiga langkah evolusi utama. Yang pertama adalah output ke konsol, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penebangan Terdistribusi dan Pelacakan untuk Layanan Mikro</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/473946/">  Logging adalah bagian penting dari aplikasi apa pun.  Setiap sistem logging melewati tiga langkah evolusi utama.  Yang pertama adalah output ke konsol, yang kedua adalah log ke file dan tampilan kerangka kerja untuk logging terstruktur, dan yang ketiga didistribusikan logging atau mengumpulkan log dari berbagai layanan di satu pusat. <br><br>  Jika logging dikelola dengan baik, ini memungkinkan Anda untuk memahami apa, kapan dan bagaimana kesalahannya, dan untuk menyampaikan informasi yang diperlukan kepada orang-orang yang harus memperbaiki kesalahan ini.  Untuk sistem di mana 100 ribu pesan dikirim setiap detik di 10 pusat data di 190 negara, dan 350 insinyur menyebarkan sesuatu setiap hari, sistem logging sangat penting. <br><br><img src="https://habrastorage.org/webt/sy/7i/u_/sy7iu_dnjrrvar7krt8llrje1ga.jpeg"><br><br>  <b>Ivan Letenko</b> adalah pemimpin tim dan pengembang di Infobip.  Untuk memecahkan masalah pemrosesan terpusat dan penelusuran log dalam arsitektur layanan mikro di bawah beban yang begitu besar, perusahaan mencoba berbagai kombinasi tumpukan ELK, Graylog, Neo4j, dan MongoDB.  Akibatnya, setelah banyak menyapu, mereka menulis layanan log mereka di Elasticsearch, dan PostgreSQL diambil sebagai database untuk informasi tambahan. <br><br>  Di bawah kucing secara rinci, dengan contoh dan grafik: arsitektur dan evolusi sistem, garu, penebangan dan penelusuran, metrik dan pemantauan, praktik bekerja dengan kelompok Elasticsearch dan mengelolanya dengan sumber daya terbatas. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Sr71xsI6X5I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Untuk memperkenalkan Anda pada konteksnya, saya akan memberi tahu Anda sedikit tentang perusahaan tersebut.  Kami membantu klien-organisasi mengirimkan pesan kepada klien mereka: pesan dari layanan taksi, SMS dari bank tentang pembatalan, atau kata sandi satu kali saat memasuki VC.  <b>350 juta pesan</b> melewati kami setiap hari untuk klien di 190 negara.  Masing-masing dari mereka kami terima, proses, tagihan, rute, adaptasi, kirim ke operator, dan sebaliknya, proses pengiriman laporan dan hasilkan analitik. <br><br>  Agar semua ini berfungsi dalam volume seperti itu, kami memiliki: <br><br><ul><li>  36 pusat data di seluruh dunia; <br></li><li>  5000+ mesin virtual <br></li><li>  350+ insinyur; <br></li><li>  730+ layanan microser yang berbeda. <br></li></ul><br>  Ini adalah sistem yang kompleks, dan tidak seorang guru pun yang dapat memahami skala penuh seorang diri.  Salah satu tujuan utama perusahaan kami adalah kecepatan tinggi pengiriman fitur baru dan rilis untuk bisnis.  Dalam hal ini, semuanya harus bekerja dan tidak jatuh.  Kami sedang mengerjakan ini: 40.000 penempatan pada 2017, 80.000 pada 2018, 300 penempatan per hari. <br><br>  Kami memiliki 350 insinyur - ternyata <b>setiap insinyur menyebarkan sesuatu setiap hari</b> .  Hanya beberapa tahun yang lalu, hanya satu orang di perusahaan yang memiliki produktivitas seperti itu - Kreshimir, insinyur utama kami.  Tapi kami memastikan bahwa setiap insinyur merasa percaya diri seperti Kresimir ketika dia menekan tombol Deploy atau menjalankan skrip. <br><br>  Apa yang dibutuhkan untuk ini?  Pertama-tama, <b>kepercayaan diri bahwa kita memahami apa yang terjadi dalam sistem</b> dan dalam keadaan apa itu.  Keyakinan diberikan oleh kemampuan untuk mengajukan pertanyaan kepada sistem dan mencari tahu penyebab masalah selama insiden dan selama pengembangan kode. <br><br>  Untuk mencapai kepercayaan ini, kami berinvestasi dalam <b>observability</b> .  Secara tradisional, istilah ini menggabungkan tiga komponen: <br><br><ul><li>  penebangan; <br></li><li>  metrik <br></li><li>  jejak. <br></li></ul><br>  Kami akan membicarakan ini.  Pertama-tama, mari kita lihat solusi kami untuk login, tetapi kami juga akan menyentuh metrik dan jejak. <br><br><h2>  Evolusi </h2><br>  Hampir semua aplikasi atau sistem logging, termasuk kita, melewati beberapa tahap evolusi. <br><br>  Langkah pertama adalah <b>output ke konsol</b> . <br><br>  Kedua - kita mulai <b>menulis log ke file</b> , <b>kerangka kerja</b> muncul untuk output terstruktur ke file.  Kami biasanya menggunakan Logback karena kami tinggal di JVM.  Pada tahap ini, log masuk terstruktur ke file muncul, memahami bahwa log yang berbeda harus memiliki tingkat, peringatan, kesalahan yang berbeda. <br><br>  Segera <b>setelah ada beberapa</b> <b>contoh layanan kami</b> atau layanan yang berbeda, tugas <b>akses terpusat</b> ke log untuk pengembang dan dukungan muncul.  Kami beralih ke logging terdistribusi - kami menggabungkan berbagai layanan menjadi layanan logging tunggal. <br><br><h2>  Logging terdistribusi </h2><br>  Opsi yang paling terkenal adalah tumpukan ELK: Elasticsearch, Logstash dan Kibana, tetapi kami memilih <b>Graylog</b> .  Ini memiliki antarmuka yang keren yang diarahkan untuk logging.  Alarm keluar dari kotak sudah dalam versi gratis, yang tidak ada di Kibana, misalnya.  Bagi kami, ini adalah pilihan yang sangat baik dalam hal log, dan di bawah tenda adalah Elasticsearch yang sama. <br><br><img src="https://habrastorage.org/webt/x1/en/7f/x1en7fmypsgbipabhmfhy6y7rts.jpeg"><br>  <i>Di Graylog, Anda bisa membuat lansiran, bagan seperti Kibana, dan bahkan mencatat metrik.</i> <br><br><h3>  Masalahnya </h3><br>  Perusahaan kami berkembang, dan pada titik tertentu menjadi jelas bahwa ada sesuatu yang salah dengan Graylog. <br><br>  <b>Beban berlebih</b> .  Ada masalah kinerja.  Banyak pengembang mulai menggunakan fitur-fitur keren Graylog: mereka membangun metrik dan dasbor yang melakukan agregasi data.  Bukan pilihan terbaik untuk membangun analitik yang rumit pada gugus Elasticsearch, yang berada di bawah beban perekaman yang berat. <br><br>  <b>Tabrakan</b>  Ada banyak tim, tidak ada skema tunggal.  Secara tradisional, ketika satu ID pertama kali memukul Graylog sebagai panjang, pemetaan secara otomatis terjadi.  Jika tim lain memutuskan bahwa harus ada UUID yang ditulis sebagai string - ini akan merusak sistem. <br><br><h2>  Keputusan pertama </h2><br>  <b>Log aplikasi dan log komunikasi yang terpisah</b> .  Log yang berbeda memiliki skenario dan metode aplikasi yang berbeda.  Ada, misalnya, log aplikasi yang timnya berbeda memiliki persyaratan berbeda untuk parameter yang berbeda: berdasarkan waktu penyimpanan dalam sistem, oleh kecepatan pencarian. <br><br>  Oleh karena itu, hal pertama yang kami lakukan adalah memisahkan log aplikasi dan log komunikasi.  Tipe kedua adalah log penting yang menyimpan informasi tentang interaksi platform kami dengan dunia luar dan tentang interaksi di dalam platform.  Kami akan berbicara lebih banyak tentang ini. <br><br>  <b>Mengganti sebagian besar log dengan metrik</b> .  Di perusahaan kami, pilihan standar adalah Prometheus dan Grafana.  Beberapa tim menggunakan solusi lain.  Tetapi penting bahwa kami menyingkirkan sejumlah besar dasbor dengan agregasi di dalam Graylog, mentransfer semuanya ke Prometheus dan Grafana.  Ini sangat meringankan beban di server. <br><br>  Mari kita lihat skenario untuk menerapkan log, metrik, dan jejak. <br><br><h3>  Log </h3><br>  <b>Dimensi tinggi, debugging, dan penelitian</b> .  Apa itu log yang baik? <br><blockquote>  Log adalah peristiwa yang kita catat. </blockquote>  Mereka dapat memiliki dimensi besar: Anda dapat mencatat ID Permintaan, ID Pengguna, atribut permintaan dan data lainnya, yang dimensinya tidak terbatas.  Mereka juga baik untuk debugging dan penelitian, untuk mengajukan pertanyaan sistem tentang apa yang terjadi dan mencari sebab dan akibat. <br><br><h3>  Metrik </h3><br>  <b>Dimensi, agregasi, pemantauan, dan peringatan yang rendah</b> .  Di bawah kap semua sistem pengumpulan metrik adalah basis data deret waktu.  Database ini melakukan pekerjaan agregasi yang sangat baik, sehingga metrik cocok untuk agregasi, pemantauan, dan peringatan bangunan. <br><blockquote>  Metrik sangat sensitif terhadap dimensi data. </blockquote>  Untuk metrik, dimensi data tidak boleh melebihi seribu.  Jika kami menambahkan beberapa ID Permintaan, yang ukuran nilainya tidak terbatas, maka kami akan segera menghadapi masalah serius.  Kami sudah menginjak penggaruk ini. <br><br><h3>  Korelasi dan penelusuran </h3><blockquote>  Log harus dikorelasikan. </blockquote>  Log terstruktur tidak cukup bagi kami untuk dengan mudah mencari berdasarkan data.  Harus ada bidang dengan nilai-nilai tertentu: ID Permintaan, ID Pengguna, data lain dari layanan dari mana log itu berasal. <br><br>  Solusi tradisional adalah dengan menetapkan ID unik untuk transaksi (log) di pintu masuk ke sistem.  Kemudian ID ini (konteks) diteruskan melalui seluruh sistem melalui rantai panggilan dalam suatu layanan atau antar layanan. <br><br><img src="https://habrastorage.org/webt/sk/ba/ht/skbahtrbo1zjpc7x8u8hy_odxg4.png"><br>  <i>Korelasi dan penelusuran.</i> <br><br>  Ada istilah yang sudah mapan.  Jejak dibagi menjadi bentang dan menunjukkan tumpukan panggilan dari satu layanan relatif ke yang lain, satu metode relatif ke yang lain relatif terhadap timeline.  Anda dapat dengan jelas melacak jalur pesan, semua timing. <br><br>  Pertama kami menggunakan Zipkin.  Sudah pada tahun 2015, kami memiliki Bukti Konsep (proyek percontohan) dari solusi ini. <br><br><img src="https://habrastorage.org/webt/iw/jg/f1/iwjgf1st5rm6ymwppx3g9scb_uw.jpeg"><br>  <i>Jejak terdistribusi</i> <br><br>  Untuk mendapatkan gambar seperti itu, <b>kode harus diinstrumentasi</b> .  Jika Anda sudah bekerja dengan basis kode yang ada, Anda harus menjalaninya - itu membutuhkan perubahan. <br><br>  Untuk mendapatkan gambaran lengkap dan mendapatkan manfaat dari jejak, Anda perlu <b>memasukkan semua layanan dalam rantai</b> , dan bukan hanya satu layanan yang sedang Anda kerjakan. <br><br>  Ini adalah alat yang ampuh, tetapi membutuhkan biaya administrasi dan perangkat keras yang signifikan, jadi kami beralih dari Zipkin ke solusi lain, yang disediakan oleh "sebagai layanan". <br><br><h2>  Laporan Pengiriman </h2><br>  Log harus dikorelasikan.  Jejak juga harus dikorelasikan.  Kami membutuhkan ID tunggal - konteks umum yang dapat diteruskan ke seluruh rantai panggilan.  Tetapi seringkali ini tidak mungkin - <b>korelasi terjadi di dalam sistem sebagai akibat dari operasinya</b> .  Ketika kita memulai satu atau lebih transaksi, kita masih tidak tahu bahwa mereka adalah bagian dari keseluruhan besar. <br><br>  Perhatikan contoh pertama. <br><br><img src="https://habrastorage.org/webt/05/lf/ds/05lfdssmlzvh6h41nzgl3w8cjwu.jpeg"><br>  <i>Laporan pengiriman.</i> <br><br><ul><li>  Klien mengirim permintaan untuk pesan, dan platform internal kami memprosesnya. <br></li><li>  Layanan, yang terlibat dalam interaksi dengan operator, mengirim pesan ini ke operator - entri muncul di sistem log. <br></li><li>  Kemudian, operator mengirimi kami laporan pengiriman. <br></li><li>  Layanan pemrosesan tidak mengetahui pesan yang terkait dengan laporan pengiriman ini.  Hubungan ini dibuat kemudian di platform kami. <br></li></ul><br>  Dua transaksi terkait adalah bagian dari satu transaksi keseluruhan.  Informasi ini sangat penting untuk insinyur pendukung dan pengembang integrasi.  Tapi ini benar-benar mustahil untuk dilihat berdasarkan satu jejak atau ID tunggal. <br><br>  Kasus kedua serupa - klien mengirimi kami pesan dalam satu bundel besar, kemudian kami membongkar mereka, mereka juga kembali dalam batch.  Jumlah paket bahkan dapat bervariasi, tetapi kemudian semuanya digabungkan. <br><br><img src="https://habrastorage.org/webt/67/jg/w3/67jgw3eyg33a7bwjsx8savqmgxo.jpeg"><br><br>  Dari sudut pandang klien, ia mengirim pesan dan menerima tanggapan.  Tetapi kami mendapat beberapa transaksi independen yang perlu digabungkan.  Ternyata hubungan satu-ke-banyak, dan dengan laporan pengiriman - satu ke satu.  Ini pada dasarnya adalah grafik. <br><br><img src="https://habrastorage.org/webt/h6/bm/ak/h6bmak77dcsvoqebnfriqxuiqcq.jpeg"><br>  <i>Kami sedang membangun grafik.</i> <br><br>  Setelah kita melihat grafik, maka pilihan yang memadai adalah basis data grafik, misalnya, Neo4j.  Pilihannya jelas karena Neo4j memberikan T-shirt keren dan buku gratis di konferensi. <br><br><h3>  Neo4j </h3><br>  Kami menerapkan Bukti Konsep: host 16-inti yang dapat memproses grafik 100 juta node dan 150 juta tautan.  Grafik hanya menempati 15 GB disk - maka cocok untuk kami. <br><br><img src="https://habrastorage.org/webt/aa/5q/bk/aa5qbkmdwshpycitkyz3-lztkck.jpeg"><br>  <i>Keputusan kami.</i>  <i>Arsitektur log.</i> <br><br>  Selain Neo4j, kami sekarang memiliki antarmuka sederhana untuk melihat log terkait.  Dengan dia, para insinyur melihat seluruh gambar. <br><br>  Tapi cukup cepat, kami menjadi kecewa dengan database ini. <br><br><h3>  Masalah dengan Neo4j </h3><br>  <b>Rotasi data</b> .  Kami memiliki volume yang kuat dan data harus diputar.  Tetapi ketika sebuah node dihapus dari Neo4j, data pada disk tidak dihapus.  Saya harus membangun solusi yang kompleks dan sepenuhnya membangun kembali grafik. <br><br>  <b>Performa</b> .  Semua basis data grafik hanya baca.  Saat merekam, kinerjanya terasa kurang.  Kasus kami benar-benar kebalikannya: kami banyak menulis dan relatif jarang membaca - ini adalah unit permintaan per detik atau bahkan per menit. <br><br>  <b>Ketersediaan tinggi dan analisis kluster untuk biaya</b> .  Pada skala kami, ini berarti biaya yang layak. <br><br>  Karena itu, kami pergi ke arah lain. <br><br><h3>  Solusi dengan PostgreSQL </h3><br>  Kami memutuskan bahwa karena kami jarang membaca, grafik dapat dibangun dengan cepat saat membaca.  Jadi kita di database relasional PostgreSQL menyimpan daftar kedekatan ID kita dalam bentuk plat sederhana dengan dua kolom dan indeks pada keduanya.  Ketika permintaan datang, kami memotong grafik konektivitas menggunakan algoritma DFS yang sudah dikenal (kedalaman traversal), dan mendapatkan semua ID terkait.  Tapi ini perlu. <br><br>  Rotasi data juga mudah dipecahkan.  Untuk setiap hari kami memulai piring baru dan setelah beberapa hari ketika saatnya tiba, kami menghapusnya dan merilis data.  Solusi sederhana. <br><br>  Kami sekarang memiliki 850 juta koneksi di PostgreSQL, mereka menempati 100 GB disk.  Kami menulis di sana dengan kecepatan 30 ribu per detik, dan untuk ini dalam database hanya ada dua VM dengan 2 CPU dan 6 GB RAM.  Seperti yang diperlukan, PostgreSQL dapat menulis rindu dengan cepat. <br><br>  Masih ada mesin kecil untuk layanan itu sendiri, yang memutar dan mengontrol. <br><br><img src="https://habrastorage.org/webt/yk/re/vq/ykrevqnk3xx8rpa3lkc9lkgiram.jpeg"><br>  <i>Bagaimana arsitektur kita berubah.</i> <br><br><h2>  Tantangan dengan Graylog </h2><br>  Perusahaan tumbuh, pusat data baru muncul, beban meningkat secara nyata, bahkan dengan solusi dengan log komunikasi.  Kami berpikir bahwa Graylog tidak lagi sempurna. <br><br>  <b>Skema dan sentralisasi terpadu</b> .  Saya ingin memiliki alat manajemen satu cluster di 10 pusat data.  Juga, muncul pertanyaan tentang skema pemetaan data terpadu sehingga tidak ada tabrakan. <br><br>  <b>API</b>  Kami menggunakan antarmuka kami sendiri untuk menampilkan koneksi antara log dan standar Graylog API tidak selalu nyaman digunakan, misalnya, ketika Anda perlu menampilkan data dari pusat data yang berbeda, mengurutkan dan menandai dengan benar.  Karena itu, kami ingin dapat mengubah API sesuka kami. <br><br>  <b>Kinerja, sulit menilai kerugian</b> .  Lalu lintas kami adalah 3 TB log per hari, yang layak.  Oleh karena itu, Graylog tidak selalu bekerja secara stabil, perlu masuk ke bagian dalamnya untuk memahami penyebab kegagalan.  Ternyata kami tidak lagi menggunakannya sebagai alat - kami harus melakukan sesuatu. <br><br>  <b>Memproses penundaan (antrian)</b> .  Kami tidak menyukai penerapan standar antrian di Graylog. <br><br>  <b>Kebutuhan untuk mendukung MongoDB</b> .  Graylog menyeret MongoDB, perlu untuk mengelola sistem ini juga. <br><br>  Kami menyadari bahwa pada tahap ini kami menginginkan solusi kami sendiri.  Mungkin ada lebih sedikit fitur keren untuk peringatan yang belum pernah digunakan, untuk dasbor, tetapi fitur mereka sendiri lebih baik. <br><br><h3>  Keputusan kami </h3><br>  Kami telah mengembangkan layanan Log kami sendiri. <br><br><img src="https://habrastorage.org/webt/2e/cl/zb/2eclzbtgkkzyjdy1u9amvwujcw8.jpeg"><br>  <i>Layanan log.</i> <br><br>  Pada saat itu, kami sudah memiliki keahlian dalam melayani dan mempertahankan kelompok Elasticsearch yang besar, jadi kami mengambil Elasticsearch sebagai basis.  Tumpukan standar di perusahaan adalah JVM, tetapi untuk backend kami juga menggunakan Kotlin terkenal, jadi kami mengambil bahasa ini untuk layanan. <br><br>  Pertanyaan pertama adalah bagaimana merotasi data dan apa yang harus dilakukan dengan pemetaan.  Kami menggunakan pemetaan tetap.  Dalam Elasticsearch, lebih baik memiliki indeks dengan ukuran yang sama.  Tetapi dengan indeks seperti itu, kita perlu memetakan data, terutama untuk beberapa pusat data, sistem terdistribusi, dan status terdistribusi.  Ada ide untuk mempercepat ZooKeeper, tetapi ini lagi-lagi merupakan komplikasi dari pemeliharaan dan kode. <br><blockquote>  Oleh karena itu, kami memutuskan hanya - menulis tepat waktu. </blockquote>  Satu indeks selama satu jam, di pusat data lain 2 indeks selama satu jam, di indeks ketiga selama 3 jam, tetapi semua dalam waktu.  Indeks diperoleh dalam ukuran yang berbeda, karena pada malam hari lalu lintas kurang dari siang hari, tetapi secara umum berfungsi.  Pengalaman menunjukkan bahwa tidak ada komplikasi yang diperlukan. <br><br>  Untuk memudahkan migrasi dan diberi sejumlah besar data, kami memilih protokol GELF, sebuah protokol Graylog sederhana berbasis TCP.  Jadi kami mendapat server GELF untuk Netty dan dekoder GELF. <br><br>  Kemudian JSON dikodekan untuk menulis ke Elasticsearch.  Kami menggunakan Java API resmi dari Elasticsearch dan menulis dalam Massal. <br><blockquote>  Untuk kecepatan perekaman tinggi Anda perlu menulis Bulk'ami. </blockquote>  Ini adalah optimasi penting.  API menyediakan prosesor Massal yang secara otomatis mengakumulasi permintaan dan kemudian mengirimkannya untuk direkam dalam satu bundel atau dari waktu ke waktu. <br><br><h3>  Masalah dengan Prosesor Massal </h3><br>  Segalanya tampak baik-baik saja.  Tetapi kami mulai dan menyadari bahwa kami bersandar pada prosesor Massal - itu tidak terduga.  Kami tidak dapat mencapai nilai-nilai yang kami andalkan - masalahnya datang entah dari mana. <br><br><img src="https://habrastorage.org/webt/f8/eh/aq/f8ehaq7rjnpje-lcnrr3gtbk6ho.jpeg"><br><br>  Dalam implementasi standar, prosesor Massal adalah single-threaded, sinkron, terlepas dari kenyataan bahwa ada pengaturan paralelisme.  Itu masalahnya. <br><br>  Kami mencari-cari dan ternyata ini adalah bug yang diketahui, tetapi tidak diselesaikan.  Kami mengubah prosesor Massal sedikit - membuat kunci eksplisit melalui ReentrantLock.  Hanya pada bulan Mei, perubahan serupa dilakukan pada repositori resmi Elasticsearch dan hanya akan tersedia dari versi 7.3.  Yang sekarang adalah 7.1, dan kami menggunakan versi 6.3. <br><br>  Jika Anda juga bekerja dengan prosesor Massal dan ingin meng-overclock entri di Elasticsearch - lihat <a href="">perubahan</a> ini <a href="">di GitHub</a> dan port kembali ke versi Anda.  Perubahan hanya memengaruhi prosesor Massal.  Tidak akan ada kesulitan jika Anda perlu port ke versi di bawah ini. <br><br>  Semuanya baik-baik saja, prosesor Massal telah pergi, kecepatan telah dipercepat. <br><br><img src="https://habrastorage.org/webt/al/kk/nz/alkknzzqgvbtqc-lx0alpunp27y.jpeg"><br><br>  Kinerja penulisan Elasticsearch tidak stabil dari waktu ke waktu, karena berbagai operasi berlangsung di sana: penggabungan indeks, flush.  Juga, kinerja melambat untuk sementara waktu selama pemeliharaan, ketika bagian dari node dikeluarkan dari cluster, misalnya. <br><br>  Dalam hal ini, kami menyadari bahwa kami perlu mengimplementasikan tidak hanya buffer dalam memori, tetapi juga antrian.  Kami memutuskan bahwa kami hanya akan mengirim pesan yang ditolak ke antrian - hanya yang tidak dapat ditulis oleh prosesor Massal ke Elasticsearch. <br><br><h3>  Coba lagi fallback </h3><br>  Ini adalah implementasi sederhana. <br><br><ul><li> Kami menyimpan pesan yang ditolak dalam file - <code>RejectedExecutionHandler</code> . <br></li><li>  Kirim ulang pada interval yang ditentukan dalam pelaksana terpisah. <br></li><li>  Namun, kami tidak menunda lalu lintas baru. <br></li></ul><br>  Untuk insinyur dan pengembang dukungan, lalu lintas baru dalam sistem terasa lebih penting daripada lalu lintas yang karena beberapa alasan tertunda selama lonjakan atau perlambatan Elasticsearch.  Dia bertahan, tetapi dia akan datang nanti - bukan masalah besar.  Lalu lintas baru diprioritaskan. <br><br><img src="https://habrastorage.org/webt/_f/jf/xz/_fjfxzutbmmt88ibablan9les0i.jpeg"><br>  <i>Skema kami mulai terlihat seperti ini.</i> <br><br>  Sekarang mari kita bicara tentang bagaimana kita mempersiapkan Elasticsearch, parameter apa yang kita gunakan dan bagaimana kita mengaturnya. <br><br><h2>  Konfigurasi Pencarian Elastics </h2><br>  Masalah yang kita hadapi adalah kebutuhan untuk meng-overclock Elasticsearch dan mengoptimalkannya untuk menulis, karena jumlah bacaan terasa lebih kecil. <br><br>  Kami menggunakan beberapa parameter. <br><br>  <code>"ignore_malformed": true</code> - <b>buang bidang dengan tipe yang salah, dan bukan seluruh dokumen</b> .  Kami masih ingin menyimpan data, bahkan jika karena alasan tertentu pemetaan yang salah telah bocor di sana.  Opsi ini tidak sepenuhnya terkait dengan kinerja. <br><br>  Untuk zat besi, Elasticsearch memiliki nuansa.  Ketika kami mulai meminta kelompok besar, kami diberitahu bahwa RAID-array dari SSD-drive untuk volume Anda sangat mahal.  Tetapi array tidak diperlukan karena toleransi kesalahan dan partisi sudah dibangun ke dalam Elasticsearch.  Bahkan di situs resminya ada rekomendasi untuk mengonsumsi zat besi lebih murah daripada yang lebih murah dan bagus.  Ini berlaku untuk cakram dan jumlah inti prosesor, karena seluruh Elasticsearch sejajar dengan sangat baik. <br><br>  <code>"index.merge.scheduler.max_thread_count": 1</code> - <b>direkomendasikan untuk HDD</b> . <br>  Jika Anda tidak mendapatkan SSD, tetapi HDD biasa, maka atur parameter ini menjadi satu.  Indeks ditulis dalam bentuk potongan, kemudian bagian ini dibekukan.  Ini menghemat sedikit disk, tetapi, di atas segalanya, mempercepat pencarian.  Juga, ketika Anda berhenti menulis ke indeks, Anda bisa melakukan <code>force merge</code> .  Ketika beban pada kluster kurang, secara otomatis membeku. <br><br>  <code>"index.unassigned.node_left.delayed_timeout": "5m"</code> - <b>keterlambatan penyebaran ketika sebuah node hilang</b> .  Ini adalah waktu setelah Elasticsearch akan mulai menerapkan indeks dan data jika sebuah simpul di-boot ulang, disebarkan, atau ditarik untuk pemeliharaan.  Tetapi jika Anda memiliki banyak beban pada disk dan jaringan, maka penyebaran adalah operasi yang sulit.  Agar tidak membebani mereka, batas waktu ini lebih baik untuk mengontrol dan memahami penundaan yang dibutuhkan. <br><br>  <code>"index.refresh_interval": -1</code> - <b>jangan perbarui indeks jika tidak ada permintaan pencarian</b> .  Kemudian indeks akan diperbarui ketika permintaan pencarian muncul.  Indeks ini dapat diatur dalam detik dan menit. <br><br>  <code>"index.translogDurability": "async"</code> - seberapa sering menjalankan fsync: dengan setiap permintaan atau berdasarkan waktu.  Memberikan keuntungan kinerja untuk drive yang lambat. <br><br>  Kami juga memiliki cara yang menarik untuk menggunakannya.  Dukungan dan pengembang ingin dapat pencarian teks lengkap dan menggunakan regexp'ov di seluruh isi pesan.  Tetapi dalam Elasticsearch ini tidak mungkin - ia hanya dapat mencari berdasarkan token yang sudah ada dalam sistemnya.  RegExp dan wildcard dapat digunakan, tetapi token tidak dapat mulai dengan beberapa RegExp.  Karena itu, kami menambahkan <code>word_delimiter</code> ke filter: <br><br><pre> <code class="plaintext hljs">"tokenizer": "standard" "filter" : [ "word_delimiter" ]</code> </pre> <br>  Secara otomatis membagi kata menjadi token: <br><br><ul><li>  â€œWi-Fiâ€ â†’ â€œWiâ€, â€œFiâ€; <br></li><li>  â€œPowerShotâ€ â†’ â€œPowerâ€, â€œShotâ€; <br></li><li>  "SD500" â†’ "SD", "500". <br></li></ul><br>  Dengan cara yang sama nama kelas ditulis, berbagai informasi debugging.  Dengan itu, kami menutup beberapa masalah dengan pencarian teks lengkap.  Saya menyarankan Anda untuk menambahkan pengaturan seperti itu ketika bekerja dengan login. <br><br><h3>  Tentang kluster </h3><br>  <b>Jumlah pecahan harus sama dengan jumlah data node untuk load balancing</b> .  Jumlah minimum replika adalah 1, maka setiap node akan memiliki satu beling utama dan satu replika.  Tetapi jika Anda memiliki data berharga, misalnya, transaksi keuangan, lebih baik 2 atau lebih. <br><br>  <b>Ukuran beling adalah dari beberapa GB hingga beberapa puluh GB</b> .  Jumlah pecahan pada sebuah simpul tidak lebih dari 20 per 1 GB pinggul Elasticsearch, tentu saja.  Selanjutnya Elasticsearch melambat - kami juga menyerangnya.  Di pusat data tersebut di mana ada sedikit lalu lintas, data tidak berputar dalam volume, ribuan indeks muncul dan sistem macet. <br><br>  <b>Gunakan</b> <code>allocation awareness</code> , misalnya, dengan nama hypervisor jika ada layanan.  Membantu menyebarkan indeks dan pecahan di berbagai hypervisor sehingga tidak tumpang tindih saat hypervisor keluar. <br><br>  <b>Buat indeks sebelumnya</b> .  Latihan yang bagus, terutama saat menulis tepat waktu.  Indeks langsung panas, siap dan tidak ada penundaan. <br><br>  <b>Batasi jumlah pecahan satu indeks per node</b> .  <code>"index.routing.allocation.total_shards_per_node": 4</code> adalah jumlah maksimum pecahan satu indeks per node.  Dalam kasus ideal, ada 2 dari mereka, kami menempatkan 4 berjaga-jaga, jika kami masih memiliki mobil lebih sedikit. <br><br>  Apa masalahnya di sini?  Kami menggunakan <code>allocation awareness</code> - Elasticsearch tahu bagaimana cara menyebarkan indeks secara tepat di seluruh hypervisor.  Tetapi kami menemukan bahwa setelah node dimatikan untuk waktu yang lama, dan kemudian kembali ke cluster, Elasticsearch melihat bahwa secara formal ada lebih sedikit indeks di dalamnya dan mereka dipulihkan.  Sampai data disinkronkan, secara formal ada beberapa indeks pada node.  Jika perlu, alokasikan indeks baru, Elasticsearch mencoba memalu mesin ini sepadat mungkin dengan indeks baru.  Jadi sebuah node mendapatkan beban tidak hanya dari fakta bahwa data direplikasi padanya, tetapi juga dengan lalu lintas baru, indeks dan data baru yang jatuh pada node ini.  Kontrol dan batasi. <br><br><h3>  Rekomendasi Pemeliharaan Elasticsearch </h3><br>  Mereka yang bekerja dengan Elasticsearch memahami rekomendasi ini. <br><blockquote>  Selama pemeliharaan terjadwal, terapkan rekomendasi untuk meningkatkan rolling: menonaktifkan alokasi shard, flush disinkronkan. </blockquote>  <b>Nonaktifkan alokasi shard</b> .  Nonaktifkan alokasi shard replika, biarkan kemampuan hanya mengalokasikan primer.  Ini secara nyata membantu Elasticsearch - ini tidak akan mengalokasikan kembali data yang tidak Anda butuhkan.  Misalnya, Anda tahu bahwa dalam setengah jam simpul akan naik - mengapa mentransfer semua pecahan dari satu simpul ke simpul lainnya?  Tidak ada yang mengerikan akan terjadi jika Anda hidup dengan kluster kuning selama setengah jam, ketika hanya pecahan utama yang tersedia. <br><br>  <b>Siram disinkronkan</b> .  Dalam hal ini, simpul akan melakukan sinkronisasi jauh lebih cepat ketika kembali ke cluster. <br><blockquote>  Dengan beban besar pada penulisan ke indeks atau pemulihan, Anda dapat mengurangi jumlah replika. </blockquote>  Jika Anda mengunduh sejumlah besar data, misalnya, beban puncak, Anda dapat mematikan pecahan dan kemudian memberikan perintah kepada Elasticsearch untuk membuatnya ketika bebannya sudah kurang. <br><br>  Berikut adalah beberapa perintah yang ingin saya gunakan: <br><br><ul><li>  <code>GET _cat/thread_pool?v</code> - memungkinkan Anda untuk melihat <code>thread_pool</code> pada setiap node: apa yang sedang panas sekarang, apa antrian penulisan dan baca. <br></li><li>  <code>GET _cat/recovery/?active_only=true</code> - indeks mana yang digunakan di mana, di mana pemulihan terjadi. <br></li><li>  <code>GET _cluster/allocation/explain</code> - dalam bentuk manusia yang mudah mengapa dan indeks atau replika mana yang tidak dialokasikan. <br></li></ul><br>  Untuk pemantauan kami menggunakan Grafana. <br><br><img src="https://habrastorage.org/webt/zg/wz/pm/zgwzpmdlzs580aaf88kv-l_rnh4.jpeg"><br><br>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengekspor yang</a> sangat baik dan Teamplay Grafana dari <b>Vincent van Hollebeke</b> , yang memungkinkan Anda untuk melihat secara visual status cluster dan semua parameter utamanya.  Kami menambahkannya ke gambar Docker kami dan semua metrik saat digunakan dari kotak kami. <br><br><h2>  Kesimpulan Penebangan </h2><br>  Log harus: <br><br><ul><li>  <b>terpusat</b> - titik masuk tunggal untuk pengembang; <br></li><li>  <b>tersedia</b> - kemampuan untuk mencari dengan cepat; <br></li><li>  <b>terstruktur</b> - untuk ekstraksi informasi berharga yang cepat dan mudah; <br></li><li>  <b>berkorelasi</b> - tidak hanya di antara mereka sendiri, tetapi juga dengan metrik dan sistem lain yang Anda gunakan. <br></li></ul><br>  Kontes <b>Melodifestivalen</b> Swedia baru-baru ini diadakan.  Ini adalah pilihan perwakilan dari Swedia untuk Eurovision.  Sebelum kompetisi, layanan dukungan kami menghubungi kami: â€œSekarang di Swedia akan ada beban besar.  Lalu lintas sangat sensitif dan kami ingin menghubungkan beberapa data.  Anda memiliki data di log yang hilang di dasbor Grafana.  Kami memiliki metrik yang dapat diambil dari Prometheus, tetapi kami membutuhkan data tentang permintaan ID tertentu. " <br><br>  Mereka menambahkan Elasticsearch sebagai sumber Grafana dan dapat menghubungkan data ini, menutup masalah dan mendapatkan hasil yang baik dengan cukup cepat. <br><blockquote>  Memanfaatkan solusi Anda sendiri jauh lebih mudah. </blockquote>  Sekarang, alih-alih 10 cluster Graylog yang berfungsi untuk solusi ini, kami memiliki beberapa layanan.  Ini adalah 10 pusat data, tetapi kami bahkan tidak memiliki tim khusus dan orang-orang yang melayani mereka.  Ada beberapa orang yang mengerjakannya dan mengubah sesuatu sesuai kebutuhan.  Tim kecil ini terintegrasi dengan sempurna ke dalam infrastruktur kami - penggunaan dan servis lebih mudah dan lebih murah. <br><blockquote>  Pisahkan kasing dan gunakan alat yang sesuai. </blockquote>  Ini adalah alat terpisah untuk mencatat, melacak dan memantau.  Tidak ada "instrumen emas" yang akan memenuhi semua kebutuhan Anda. <br><br>  Untuk memahami alat mana yang diperlukan, apa yang harus dipantau, di mana menggunakan log, persyaratan apa untuk log, Anda harus beralih ke <b>SLI / SLO</b> - Indikator Tingkat Layanan / Sasaran Tingkat Layanan.  Anda perlu tahu apa yang penting bagi pelanggan dan bisnis Anda, indikator apa yang mereka lihat. <br><br><blockquote>  Seminggu kemudian, SKOLKOVO akan menyelenggarakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad ++ 2019</a> .  Pada malam 7 November, Ivan Letenko <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akan memberi tahu Anda</a> bagaimana ia hidup bersama Redis, dan secara total ada 150 laporan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">program</a> tentang berbagai topik. <br><br>  Jika Anda mengalami masalah saat mengunjungi HighLoad ++ 2019 secara langsung, kami memiliki kabar baik.  Tahun ini konferensi akan diadakan di tiga kota sekaligus - di Moskow, Novosibirsk dan St. Petersburg.  Pada saat bersamaan.  Bagaimana nantinya dan bagaimana menuju ke sana - cari tahu di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman promo</a> terpisah acara. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473946/">https://habr.com/ru/post/id473946/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473932/index.html">Bagaimana cara kerja game AI hibrid dan apa kelebihannya</a></li>
<li><a href="../id473936/index.html">Kinerja Audio Interaktif - Era Baru Game Asisten Suara</a></li>
<li><a href="../id473938/index.html">Menyimpan pengaturan aplikasi secara universal melalui IConfiguration</a></li>
<li><a href="../id473940/index.html">Uji kekuatan: nanomekanika dari bunda mutiara mulia pinna</a></li>
<li><a href="../id473944/index.html">Saran dari pencipta RimWorld: distorsi kognitif dalam memprediksi penggemar game</a></li>
<li><a href="../id473948/index.html">Operon: Mempercepat Kinerja Ansible</a></li>
<li><a href="../id473950/index.html">Menerapkan, skala: pengalaman menggunakan autotest di VTB</a></li>
<li><a href="../id473952/index.html">Seperti yang saya tulis AI untuk strategi turn-based</a></li>
<li><a href="../id473956/index.html">Informasi rahasia dari perusahaan telepon pengedar narkoba</a></li>
<li><a href="../id473958/index.html">Jepang dari NICT memperkenalkan cluster serat yang bekerja dengan bandwidth 1 Pbit / s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>