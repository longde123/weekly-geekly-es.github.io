<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôèÔ∏è üêÑ ü•ë Faire le bien faire le mal: √©crire du code diabolique avec Go, partie 1 üëäüèæ üåñ üßóüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mauvais conseils pour un programmeur Go 


 Apr√®s des d√©cennies de programmation en Java, ces derni√®res ann√©es, j'ai principalement travaill√© sur Go. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Faire le bien faire le mal: √©crire du code diabolique avec Go, partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460645/"><h4>  <i>Mauvais conseils pour un programmeur Go</i> </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/1c9/72b/d9b/1c972bd9b185f33a0348abfd7d81e470.png" alt="image"><br><br>  Apr√®s des d√©cennies de programmation en Java, ces derni√®res ann√©es, j'ai principalement travaill√© sur Go.  Travailler avec Go est g√©nial, principalement parce que le code est tr√®s facile √† suivre.  Java a simplifi√© le mod√®le de programmation C ++ en supprimant l'h√©ritage multiple, la gestion manuelle de la m√©moire et la surcharge de l'op√©rateur.  Go fait de m√™me, continuant √† √©voluer vers un style de programmation simple et direct, supprimant compl√®tement l'h√©ritage et la surcharge de fonctions.  Le code simple est un code lisible et le code lisible est un code pris en charge.  Et c'est formidable pour l'entreprise et mes employ√©s. <br><br>  Comme dans toutes les cultures, le d√©veloppement de logiciels a ses propres l√©gendes, des histoires qui sont racont√©es par le refroidisseur d'eau.  Nous avons tous entendu parler de d√©veloppeurs qui, au lieu de se concentrer sur la cr√©ation d'un produit de qualit√©, se concentrent sur la protection de leur propre travail contre les √©trangers.  Ils n'ont pas besoin de code pris en charge, car cela signifie que d'autres personnes pourront le comprendre et le modifier.  Est-ce possible sur Go?  Est-il possible de rendre le code Go si compliqu√©?  Je dirai tout de suite - ce n'est pas une t√¢che facile.  Examinons les options possibles. <br><a name="habracut"></a><br>  Vous pensez: ¬´ <i>Combien pouvez-vous corroder le code dans un langage de programmation?</i>  <i>Est-il possible d'√©crire un code si horrible sur Go que son auteur devient indispensable dans l'entreprise?</i>  ¬ªNe t'inqui√®te pas.  Quand j'√©tais √©tudiant, j'avais un projet dans lequel je soutenais le code Lisp-e de quelqu'un d'autre √©crit par un √©tudiant dipl√¥m√©.  En fait, il a r√©ussi √† √©crire du code Fortran-e en utilisant Lisp.  Le code ressemblait √† ceci: <br><br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> add-mult-pi (<span class="hljs-name"><span class="hljs-name">in1</span></span> in2) (<span class="hljs-name"><span class="hljs-name">setq</span></span> a in1) (<span class="hljs-name"><span class="hljs-name">setq</span></span> b in2) (<span class="hljs-name"><span class="hljs-name">setq</span></span> c (<span class="hljs-name"><span class="hljs-name">+</span></span> ab)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> d (<span class="hljs-name"><span class="hljs-name">*</span></span> <span class="hljs-number"><span class="hljs-number">3.1415</span></span> c) d )</code> </pre> <br>  Il y avait des dizaines de fichiers de ce code.  Il √©tait absolument terrible et absolument brillant √† la fois.  J'ai pass√© des mois √† essayer de le comprendre.  Par rapport √† cela, √©crire du mauvais code sur Go n'est qu'une salive. <br><br>  Il existe de nombreuses fa√ßons diff√©rentes de rendre votre code non pris en charge, mais nous n'en examinerons que quelques-unes.  Pour faire le mal, vous devez d'abord apprendre √† faire le bien.  Par cons√©quent, nous examinons d'abord comment les ¬´bons¬ª programmeurs Go √©crivent, puis nous regardons comment faire le contraire. <br><br><h3>  Mauvais emballage </h3><br>  Les packages sont un sujet pratique pour commencer.  Comment l'organisation du code peut-elle nuire √† la lisibilit√©? <br><br>  Dans Go, le nom du package est utilis√© pour faire r√©f√©rence √† l'entit√© export√©e (par exemple, ` <i>fmt.Println`</i> <i>ou` http.RegisterFunc`</i> ).  Puisque nous pouvons voir le nom du package, les ¬´bons¬ª programmeurs Go s'assurent que ce nom d√©crit ce que sont les entit√©s export√©es.  Nous ne devrions pas avoir de paquets util, car des noms comme ` <i>util.JSONMarshal`</i> ne fonctionneront pas pour nous - nous avons besoin de` <i>json.Marshal`</i> . <br><br>  Les "bons" d√©veloppeurs Go ne cr√©ent pas non plus de package s√©par√© pour le DAO ou le mod√®le.  Pour ceux qui ne connaissent pas ce terme, un DAO est un ¬´ <i>objet d'acc√®s aux donn√©es</i> ¬ª - une couche de code qui interagit avec votre base de donn√©es.  J'avais l'habitude de travailler pour une entreprise o√π 6 services Java importaient la m√™me biblioth√®que DAO pour acc√©der √† la m√™me base de donn√©es qu'ils partageaient, car " <i>... eh bien, vous savez, les microservices sont les m√™mes ...</i> ". <br><br>  Si vous avez un package s√©par√© avec tous vos DAO, il est plus probable que vous obtiendrez une d√©pendance circulaire entre les packages, ce qui est interdit dans Go.  Et si vous disposez de plusieurs services qui incluent ce package DAO en tant que biblioth√®que, vous pouvez √©galement rencontrer une situation o√π un changement dans un service n√©cessite la mise √† jour de tous vos services, sinon quelque chose se cassera.  C'est ce qu'on appelle un monolithe distribu√© et est incroyablement difficile √† mettre √† jour. <br><br>  Lorsque vous savez comment les emballages devraient fonctionner et ce qui les aggrave, ¬´commencer √† servir le mal¬ª devient simple.  Organisez mal votre code et donnez de mauvais noms √† vos packages.  Divisez votre code en packages tels que <i>model</i> , <i>util</i> et <i>dao</i> .  Si vous voulez vraiment commencer √† cr√©er le chaos, essayez de cr√©er des packages en l'honneur de votre chat ou de votre couleur pr√©f√©r√©e.  Lorsque les gens sont confront√©s √† des d√©pendances cycliques ou √† des monolithes distribu√©s en raison de l'utilisation de votre code, vous devez soupirer, rouler des yeux et leur dire qu'ils font simplement du mal ... <br><br><h3>  Interfaces inappropri√©es </h3><br>  Maintenant que tous nos packages sont corrompus, nous pouvons passer aux interfaces.  Les interfaces dans Go ne sont pas comme les interfaces dans d'autres langues.  Le fait que vous ne d√©clariez pas explicitement que ce type impl√©mente l'interface au premier abord semble insignifiant, mais en fait il renverse compl√®tement le concept des interfaces. <br><br>  Dans la plupart des langues avec des types abstraits, une interface est d√©finie avant ou en m√™me temps que l'impl√©mentation.  Vous devrez le faire au moins pour les tests.  Si vous ne cr√©ez pas l'interface √† l'avance, vous ne pouvez pas l'ins√©rer ult√©rieurement sans casser tout le code qui utilise cette classe.  Parce que vous devez le r√©√©crire avec un lien vers l'interface au lieu d'un type sp√©cifique. <br><br>  Pour cette raison, le code Java a souvent de gigantesques interfaces de service avec de nombreuses m√©thodes.  Les classes qui impl√©mentent ces interfaces utilisent ensuite les m√©thodes dont elles ont besoin et ignorent le reste.  L'√©criture de tests est possible, mais vous ajoutez un niveau d'abstraction suppl√©mentaire, et lorsque vous √©crivez des tests, vous avez souvent recours √† des outils pour g√©n√©rer des impl√©mentations de ces m√©thodes dont vous n'avez pas besoin. <br><br>  Dans Go, les interfaces implicites d√©terminent les m√©thodes √† utiliser.  Le code poss√®de une interface, et non l'inverse.  M√™me si vous utilisez un type avec de nombreuses m√©thodes d√©finies, vous pouvez sp√©cifier une interface qui inclut uniquement les m√©thodes dont vous avez besoin.  Un autre code utilisant des champs s√©par√©s du m√™me type d√©finira d'autres interfaces qui couvrent uniquement les fonctionnalit√©s n√©cessaires.  En r√®gle g√©n√©rale, ces interfaces n'ont que quelques m√©thodes. <br><br>  Cela facilite la compr√©hension de votre code, car une d√©claration de m√©thode d√©termine non seulement les donn√©es dont elle a besoin, mais indique √©galement avec pr√©cision les fonctionnalit√©s qu'elle va utiliser.  C'est l'une des raisons pour lesquelles les bons d√©veloppeurs Go suivent le conseil: " <i>Accepter les interfaces, retourner les structures</i> ." <br><br>  Mais ce n'est pas parce que c'est une bonne pratique que vous devez le faire ... <br>  La meilleure fa√ßon de rendre vos interfaces ¬´mauvaises¬ª est de revenir aux principes d'utilisation des interfaces d'autres langues, c'est-√†-dire  D√©finissez les interfaces √† l'avance dans le cadre du code appel√©.  D√©finissez d'√©normes interfaces avec de nombreuses m√©thodes utilis√©es par tous les clients de service.  Il devient difficile de savoir quelles m√©thodes sont vraiment n√©cessaires.  Cela complique le code, et la complication, comme vous le savez, est le meilleur ami d'un programmeur ¬´diabolique¬ª. <br><br><h3>  Passer les pointeurs de tas </h3><br>  Avant d'expliquer ce que cela signifie, vous devez un peu philosopher.  Si vous distrayez et pensez, chaque programme √©crit fait la m√™me chose.  Il re√ßoit des donn√©es, les traite, puis envoie les donn√©es trait√©es √† un autre emplacement.  Il en est ainsi, que vous √©criviez un syst√®me de paie, acceptiez des requ√™tes HTTP et renvoyiez des pages Web, ou m√™me v√©rifiez le joystick pour suivre un clic de bouton - les programmes traitent les donn√©es. <br><br>  Si nous regardons les programmes de cette mani√®re, la chose la plus importante √† faire est de nous assurer qu'il est facile pour nous de comprendre comment les donn√©es sont converties.  Il est donc recommand√© de conserver les donn√©es inchang√©es aussi longtemps que possible pendant le programme.  Parce que les donn√©es qui ne changent pas sont des donn√©es faciles √† suivre. <br><br>  Dans Go, nous avons des types de r√©f√©rence et des types de valeur.  La diff√©rence entre les deux est de savoir si la variable fait r√©f√©rence √† une copie des donn√©es ou √† l'emplacement des donn√©es en m√©moire.  Les pointeurs, les tranches, les cartes, les canaux, les interfaces et les fonctions sont des types de r√©f√©rence, et tout le reste est un type de valeur.  Si vous affectez une variable de type valeur √† une autre variable, cela cr√©e une copie de la valeur;  changer une variable ne change pas la valeur d'une autre. <br><br>  L'affectation d'une variable d'un type de r√©f√©rence √† une autre variable d'un type de r√©f√©rence signifie qu'ils partagent tous les deux la m√™me zone de m√©moire, donc si vous modifiez les donn√©es vers lesquelles le premier pointe, vous modifiez les donn√©es vers lesquelles le second pointe.  Cela est vrai pour les variables locales et les param√®tres de fonction. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//  a := 1 b := a b = 2 fmt.Println(a, b) // prints 1 2 //  c := &amp;a *c = 3 fmt.Println(a, b, *c) // prints 3 2 3 }</span></span></code> </pre> <br>  Les d√©veloppeurs de Kind Go veulent faciliter la compr√©hension de la mani√®re dont les donn√©es sont collect√©es.  Ils essaient d'utiliser le type de valeurs comme param√®tres de fonctions aussi souvent que possible.  Il n'y a aucun moyen dans Go de marquer les champs dans les structures ou les param√®tres de fonction comme d√©finitifs.  Si une fonction utilise des param√®tres de valeur, la modification des param√®tres ne modifiera pas les variables dans la fonction appelante.  Tout ce que la fonction appel√©e peut faire est de renvoyer la valeur √† la fonction appelante.  Ainsi, si vous remplissez une structure en appelant une fonction avec des param√®tres de valeur, vous ne pouvez pas avoir peur de transf√©rer des donn√©es vers la structure, car vous comprenez d'o√π vient chaque champ de la structure. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>,i*<span class="hljs-number"><span class="hljs-number">2</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { f := Foo{} fA = getA() fB = getB(fA) <span class="hljs-comment"><span class="hljs-comment">//  ,    f fmt.Println(f) }</span></span></code> </pre> <br>  Eh bien, comment devient-on ¬´mal¬ª?  Tr√®s simple - retourner ce mod√®le. <br><br>  Au lieu d'appeler des fonctions qui renvoient les valeurs souhait√©es, vous passez un pointeur sur la structure dans la fonction et leur permettez d'apporter des modifications √† la structure.  √âtant donn√© que chaque fonction a sa propre structure, la seule fa√ßon de savoir quels champs changent est de regarder le code entier.  Vous pouvez √©galement avoir des d√©pendances implicites entre les fonctions - la 1√®re fonction transf√®re les donn√©es n√©cessaires √† la 2√®me fonction.  Mais dans le code lui-m√™me, rien n'indique que vous devez d'abord appeler la 1√®re fonction.  Si vous construisez vos structures de donn√©es de cette fa√ßon, vous pouvez √™tre s√ªr que personne ne comprendra ce que fait votre code. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *Foo)</span></span></span></span> { fA = <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-comment"><span class="hljs-comment">//   fA! func setB(f *Foo) { fB = fmt.Sprintf("%d", fA*2) } func main() { f := Foo{} setA(&amp;f) setB(&amp;f) // ,  setA  setB //    ? fmt.Println(f) }</span></span></code> </pre> <br><h3>  Rev√™tement de panique </h3><br>  Maintenant, nous commen√ßons √† g√©rer les erreurs.  Vous pensez probablement qu'il est mauvais d'√©crire des programmes qui g√®rent les erreurs d'environ 75%, et je ne dirai pas que vous vous trompez.  Le code Go est souvent rempli de gestion des erreurs de la t√™te aux pieds.  Et bien s√ªr, il serait commode de les traiter pas si facilement.  Des erreurs se produisent et leur gestion est ce qui distingue les professionnels des d√©butants.  Une gestion erron√©e des erreurs conduit √† des programmes instables qui sont difficiles √† d√©boguer et difficiles √† maintenir.  Parfois, √™tre un ¬´bon¬ª programmeur signifie ¬´tendre¬ª. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dus DBUserService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User, error)</span></span></span></span> { rows, err := dus.DB.Query(<span class="hljs-string"><span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span></span>, id) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"no user for id %d"</span></span>, id) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> err = rows.Scan(&amp;name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } err = rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{Id: id, Name: name}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  De nombreux langages, tels que C ++, Python, Ruby et Java, utilisent des exceptions pour g√©rer les erreurs.  Si quelque chose se passe mal, les d√©veloppeurs de ces langages l√®vent ou l√®vent une exception, s'attendant √† ce que du code le g√®re.  Bien s√ªr, le programme s'attend √† ce que le client soit au courant d'une erreur possible de lancement √† un emplacement donn√© afin qu'il soit possible de lever une exception.  Parce que, sauf (sans jeu de mots), les exceptions Java v√©rifi√©es, rien dans la signature de la m√©thode dans les langages ou les fonctions n'indique qu'une exception peut se produire.  Alors, comment les d√©veloppeurs savent-ils quelles exceptions s'inqui√©ter?  Ils ont deux options: <br><br><ul><li>  Tout d'abord, ils peuvent lire tout le code source de toutes les biblioth√®ques que leur code appelle, et toutes les biblioth√®ques qui appellent les biblioth√®ques appel√©es, etc. </li><li>  Deuxi√®mement, ils peuvent faire confiance √† la documentation.  Je peux √™tre partial, mais mon exp√©rience personnelle ne me permet pas de faire enti√®rement confiance √† la documentation. </li></ul><br>  Alors, comment pouvons-nous faire venir ce mal?  Abuser de la panique ( <i>panique</i> ) et de la r√©cup√©ration ( <i>r√©cup√©rer</i> ), bien s√ªr!  La panique est con√ßue pour des situations telles que ¬´le lecteur est tomb√©¬ª ou ¬´la carte r√©seau a explos√©¬ª.  Mais pas pour un tel - "quelqu'un a pass√© une cha√Æne au lieu d'un int". <br><br>  Malheureusement, d'autres ¬´d√©veloppeurs moins √©clair√©s¬ª renverront des erreurs de leur code.  Par cons√©quent, voici une petite fonction d'aide de PanicIfErr.  Utilisez-le pour transformer les erreurs des autres d√©veloppeurs en panique. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PanicIfErr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } }</code> </pre> <br>  Vous pouvez utiliser PanicIfErr pour envelopper les erreurs des autres, compresser le code.  Plus de gestion d'erreur laide!  Toute erreur est maintenant une panique.  C'est tellement productif! <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dus DBUserService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadEvil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span></span> { rows, err := dus.DB.Query( <span class="hljs-string"><span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span></span>, id) PanicIfErr(err) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"no user for id %d"</span></span>, id)) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> PanicIfErr(rows.Scan(&amp;name)) PanicIfErr(rows.Close()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{Id: id, Name: name} }</code> </pre> <br>  Vous pouvez placer la r√©cup√©ration quelque part plus pr√®s du d√©but du programme, peut-√™tre dans votre propre <i>middleware</i> .  Et dites ensuite que non seulement vous traitez les erreurs, mais que vous nettoyez √©galement le code de quelqu'un d'autre.  Faire le mal en faisant le bien est le meilleur type de mal. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PanicMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); r != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">", - ."</span></span>) } }() h.ServeHTTP(rw, req) } ) }</code> </pre> <br><h3>  D√©finition des effets secondaires </h3><br>  Ensuite, nous allons cr√©er un effet secondaire.  N'oubliez pas que le ¬´bon¬ª d√©veloppeur Go veut comprendre comment les donn√©es transitent par le programme.  La meilleure fa√ßon de savoir ce que traversent les donn√©es est de configurer des d√©pendances explicites dans l'application.  M√™me les entit√©s qui correspondent √† la m√™me interface peuvent varier consid√©rablement dans leur comportement.  Par exemple, un code qui stocke des donn√©es en m√©moire et un code qui acc√®de √† la base de donn√©es pour le m√™me travail.  Cependant, il existe des moyens d'installer des d√©pendances dans Go sans appels explicites. <br><br>  Comme beaucoup d'autres langages, Go a un moyen d'ex√©cuter comme par magie du code sans l'invoquer directement.  Si vous cr√©ez une fonction appel√©e init sans param√®tres, elle d√©marrera automatiquement au chargement du package.  Et, pour encore plus de confusion, si dans un fichier il y a plusieurs fonctions avec le nom init ou plusieurs fichiers dans un seul paquet, elles d√©marreront toutes. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Account <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ Id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UserId <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"  !"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"   ,     init()"</span></span>) }</code> </pre> <br>  Les fonctions init sont souvent associ√©es √† des importations vides.  Go a une fa√ßon sp√©ciale de d√©clarer les importations, qui ressemble √† ¬´import _¬´ github.com / lib / pq ¬ª.  Lorsque vous d√©finissez un identifiant de nom vide pour un package import√©, la m√©thode init s'ex√©cute dans celui-ci, mais elle n'affiche aucun des identificateurs de package.  Pour certaines biblioth√®ques Go - telles que les pilotes de base de donn√©es ou les formats d'image - vous devez les charger en activant l'importation de package vide, juste pour appeler la fonction init afin que le package puisse enregistrer son code. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/lib/pq"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { db, err := sql.Open( <span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, <span class="hljs-string"><span class="hljs-string">"postgres://jon@localhost/evil?sslmode=disable"</span></span>) }</code> </pre><br>  Et c'est clairement une option ¬´mal√©fique¬ª.  Lorsque vous utilisez l'initialisation, le code qui fonctionne comme par magie est compl√®tement hors du contr√¥le du d√©veloppeur.  Les meilleures pratiques ne recommandent pas d'utiliser les fonctions d'initialisation - ce sont des fonctionnalit√©s non √©videntes, elles confondent le code et sont faciles √† masquer dans la biblioth√®que. <br><br>  En d'autres termes, les fonctions init sont id√©ales pour nos fins perverses.  Au lieu de configurer ou d'enregistrer explicitement des entit√©s dans des packages, vous pouvez utiliser les fonctions d'initialisation et d'importation vide pour configurer l'√©tat de votre application.  Dans cet exemple, nous mettons le compte √† la disposition du reste de l'application via le registre et le package lui-m√™me est plac√© dans le registre √† l'aide de la fonction init. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/registry"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StubAccountService <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a StubAccountService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBalance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(accountId </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { registry.Register(<span class="hljs-string"><span class="hljs-string">"account"</span></span>, StubAccountService{}) }</code> </pre> <br>  Si vous souhaitez utiliser un compte, mettez une importation vide dans votre programme.  Il n'est pas n√©cessaire que ce soit le code principal ou connexe - il doit simplement √™tre ¬´quelque part¬ª.  C'est magique! <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( _ <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/account"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/registry"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Balancer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetBalance(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := registry.Get(<span class="hljs-string"><span class="hljs-string">"account"</span></span>).(Balancer) money := a.GetBalance(<span class="hljs-number"><span class="hljs-number">12345</span></span>) }</code> </pre> <br>  Si vous utilisez inits dans vos biblioth√®ques pour configurer les d√©pendances, vous verrez imm√©diatement que d'autres d√©veloppeurs se demandent comment ces d√©pendances ont √©t√© install√©es et comment les modifier.  Et personne ne sera plus sage que toi. <br><br><h3>  Configuration compliqu√©e </h3><br>  Il y a encore beaucoup de tout ce que nous pouvons faire avec la configuration.  Si vous √™tes un ¬´bon¬ª d√©veloppeur Go, vous voudrez isoler la configuration du reste du programme.  Dans la fonction main (), vous obtenez des variables de l'environnement et les convertissez en valeurs n√©cessaires pour les composants qui sont explicitement li√©s les uns aux autres.  Vos composants ne savent rien des fichiers de configuration ni de la fa√ßon dont leurs propri√©t√©s sont appel√©es.  Pour les composants simples, vous d√©finissez les propri√©t√©s publiques et pour les plus complexes, vous pouvez cr√©er une fonction d'usine qui re√ßoit des informations de configuration et renvoie un composant correctement configur√©. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b, err := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"account.json"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"error reading config file: %v"</span></span>, err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{} json.Unmarshal(b, &amp;m) prefix := m[<span class="hljs-string"><span class="hljs-string">"account.prefix"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) maker := account.NewMaker(prefix) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Maker <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { prefix <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m Maker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Account</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Account{Name: name, Id: m.prefix + <span class="hljs-string"><span class="hljs-string">"-12345"</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMaker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prefix </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Maker</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Maker{prefix: prefix} }</code> </pre> <br>  Mais les d√©veloppeurs "mal√©fiques" savent qu'il vaut mieux disperser les informations sur la configuration √† travers le programme.  Au lieu d'avoir une fonction dans un package qui d√©finit les noms et les types de valeur de votre package, utilisez une fonction qui prend la configuration telle qu'elle est et la convertit d'elle-m√™me. <br><br>  Si cela vous semble trop "diabolique", utilisez la fonction init pour charger le fichier de propri√©t√©s depuis votre package et d√©finissez vous-m√™me les valeurs.  Il peut sembler que vous avez facilit√© la vie d'autres d√©veloppeurs, mais vous et moi savons ... <br><br>  En utilisant la fonction init, vous pouvez d√©finir de nouvelles propri√©t√©s √† l'arri√®re du code, et personne ne les trouvera jusqu'√† ce qu'elles entrent en production et que tout tombe, car quelque chose n'entrera pas dans l'une des dizaines de fichiers de propri√©t√©s n√©cessaires √† l'ex√©cution.  Si vous voulez encore plus de ¬´puissance mal√©fique¬ª, vous pouvez sugg√©rer de cr√©er un wiki pour garder une trace de toutes les propri√©t√©s dans toutes les biblioth√®ques et pour ¬´oublier¬ª en ajouter p√©riodiquement de nouvelles.  En tant que gardien de propri√©t√©, vous devenez la seule personne √† pouvoir ex√©cuter le logiciel. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m maker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Account</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Account{Name: name, Id: m.prefix + <span class="hljs-string"><span class="hljs-string">"-12345"</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Maker maker <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b, _ := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"account.json"</span></span>) m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{} json.Unmarshal(b, &amp;m) Maker.prefix = m[<span class="hljs-string"><span class="hljs-string">"account.prefix"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) }</code> </pre> <br><h3>  Cadres de fonctionnalit√© </h3><br>  Enfin, nous arrivons au sujet des frameworks vs biblioth√®ques.  La diff√©rence est tr√®s subtile.  Ce n'est pas seulement une question de taille;  vous pouvez avoir de grandes biblioth√®ques et de petits cadres.  Le framework appelle votre code pendant que vous appelez vous-m√™me le code de la biblioth√®que.  Les frameworks exigent que vous √©criviez votre code d'une certaine mani√®re, qu'il s'agisse de nommer vos m√©thodes selon des r√®gles sp√©cifiques, ou qu'elles correspondent √† certaines interfaces, ou que vous soyez oblig√© d'enregistrer votre code dans le framework.  Les frameworks ont leurs propres exigences pour tout votre code.  C'est-√†-dire, en g√©n√©ral, les frameworks vous commandent. <br><br>  Go encourage l'utilisation des biblioth√®ques car les biblioth√®ques sont li√©es.  Bien que, bien s√ªr, chaque biblioth√®que s'attende √† ce que les donn√©es soient transmises dans un format sp√©cifique, vous pouvez √©crire du code de connexion pour convertir la sortie d'une biblioth√®que en entr√©e pour une autre. <br>  Il est difficile de faire fonctionner les frameworks de mani√®re transparente, car chaque framework veut un contr√¥le complet sur le cycle de vie du code.  Souvent, la seule fa√ßon de faire fonctionner les cadres est que leurs auteurs se r√©unissent et organisent clairement un soutien mutuel.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et la meilleure fa√ßon d'utiliser les ¬´mauvais cadres¬ª pour gagner du pouvoir √† long terme est d'√©crire votre propre cadre, qui n'est utilis√© qu'au sein de l'entreprise. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mal actuel et futur </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir ma√Ætris√© ces astuces, vous vous embarquerez √† jamais sur le chemin du mal. </font><font style="vertical-align: inherit;">Dans la deuxi√®me partie, je montrerai comment d√©ployer tout ce "mal", et comment transformer correctement le "bon" code en "mal".</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460645/">https://habr.com/ru/post/fr460645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460633/index.html">D√©tails d'impl√©mentation pour RSTP et la redondance en anneau √©tendue propri√©taire</a></li>
<li><a href="../fr460635/index.html">CLRium # 6: Concurrence et parall√©lisme. Deux jours: du processeur √† l'async / attente</a></li>
<li><a href="../fr460637/index.html">Contr√¥le de la lumi√®re sur ZigBee</a></li>
<li><a href="../fr460641/index.html">YouTokenToMe: un outil pour la tokenisation rapide du texte de l'√©quipe VKontakte</a></li>
<li><a href="../fr460643/index.html">R√©partition uniforme des points sur une sph√®re</a></li>
<li><a href="../fr460647/index.html">R√©soudre un travail avec pwnable.kr 05 - mot de passe. R√©√©crire la table des liens de proc√©dure via la vuln√©rabilit√© de cha√Æne de format</a></li>
<li><a href="../fr460651/index.html">R√©union de la Society of Anonymous Testers: TMS, monitoring monitoring, search quality evaluation and native iOS tests</a></li>
<li><a href="../fr460655/index.html">Comment j'ai bris√© Telegram</a></li>
<li><a href="../fr460659/index.html">Utilisation de tuyaux pour pivoter</a></li>
<li><a href="../fr460661/index.html">Tout ce que vous devez savoir sur Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>