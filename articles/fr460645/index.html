<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♏️ 🐄 🥑 Faire le bien faire le mal: écrire du code diabolique avec Go, partie 1 👊🏾 🌖 🧗🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mauvais conseils pour un programmeur Go 


 Après des décennies de programmation en Java, ces dernières années, j'ai principalement travaillé sur Go. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Faire le bien faire le mal: écrire du code diabolique avec Go, partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460645/"><h4>  <i>Mauvais conseils pour un programmeur Go</i> </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/1c9/72b/d9b/1c972bd9b185f33a0348abfd7d81e470.png" alt="image"><br><br>  Après des décennies de programmation en Java, ces dernières années, j'ai principalement travaillé sur Go.  Travailler avec Go est génial, principalement parce que le code est très facile à suivre.  Java a simplifié le modèle de programmation C ++ en supprimant l'héritage multiple, la gestion manuelle de la mémoire et la surcharge de l'opérateur.  Go fait de même, continuant à évoluer vers un style de programmation simple et direct, supprimant complètement l'héritage et la surcharge de fonctions.  Le code simple est un code lisible et le code lisible est un code pris en charge.  Et c'est formidable pour l'entreprise et mes employés. <br><br>  Comme dans toutes les cultures, le développement de logiciels a ses propres légendes, des histoires qui sont racontées par le refroidisseur d'eau.  Nous avons tous entendu parler de développeurs qui, au lieu de se concentrer sur la création d'un produit de qualité, se concentrent sur la protection de leur propre travail contre les étrangers.  Ils n'ont pas besoin de code pris en charge, car cela signifie que d'autres personnes pourront le comprendre et le modifier.  Est-ce possible sur Go?  Est-il possible de rendre le code Go si compliqué?  Je dirai tout de suite - ce n'est pas une tâche facile.  Examinons les options possibles. <br><a name="habracut"></a><br>  Vous pensez: « <i>Combien pouvez-vous corroder le code dans un langage de programmation?</i>  <i>Est-il possible d'écrire un code si horrible sur Go que son auteur devient indispensable dans l'entreprise?</i>  »Ne t'inquiète pas.  Quand j'étais étudiant, j'avais un projet dans lequel je soutenais le code Lisp-e de quelqu'un d'autre écrit par un étudiant diplômé.  En fait, il a réussi à écrire du code Fortran-e en utilisant Lisp.  Le code ressemblait à ceci: <br><br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> add-mult-pi (<span class="hljs-name"><span class="hljs-name">in1</span></span> in2) (<span class="hljs-name"><span class="hljs-name">setq</span></span> a in1) (<span class="hljs-name"><span class="hljs-name">setq</span></span> b in2) (<span class="hljs-name"><span class="hljs-name">setq</span></span> c (<span class="hljs-name"><span class="hljs-name">+</span></span> ab)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> d (<span class="hljs-name"><span class="hljs-name">*</span></span> <span class="hljs-number"><span class="hljs-number">3.1415</span></span> c) d )</code> </pre> <br>  Il y avait des dizaines de fichiers de ce code.  Il était absolument terrible et absolument brillant à la fois.  J'ai passé des mois à essayer de le comprendre.  Par rapport à cela, écrire du mauvais code sur Go n'est qu'une salive. <br><br>  Il existe de nombreuses façons différentes de rendre votre code non pris en charge, mais nous n'en examinerons que quelques-unes.  Pour faire le mal, vous devez d'abord apprendre à faire le bien.  Par conséquent, nous examinons d'abord comment les «bons» programmeurs Go écrivent, puis nous regardons comment faire le contraire. <br><br><h3>  Mauvais emballage </h3><br>  Les packages sont un sujet pratique pour commencer.  Comment l'organisation du code peut-elle nuire à la lisibilité? <br><br>  Dans Go, le nom du package est utilisé pour faire référence à l'entité exportée (par exemple, ` <i>fmt.Println`</i> <i>ou` http.RegisterFunc`</i> ).  Puisque nous pouvons voir le nom du package, les «bons» programmeurs Go s'assurent que ce nom décrit ce que sont les entités exportées.  Nous ne devrions pas avoir de paquets util, car des noms comme ` <i>util.JSONMarshal`</i> ne fonctionneront pas pour nous - nous avons besoin de` <i>json.Marshal`</i> . <br><br>  Les "bons" développeurs Go ne créent pas non plus de package séparé pour le DAO ou le modèle.  Pour ceux qui ne connaissent pas ce terme, un DAO est un « <i>objet d'accès aux données</i> » - une couche de code qui interagit avec votre base de données.  J'avais l'habitude de travailler pour une entreprise où 6 services Java importaient la même bibliothèque DAO pour accéder à la même base de données qu'ils partageaient, car " <i>... eh bien, vous savez, les microservices sont les mêmes ...</i> ". <br><br>  Si vous avez un package séparé avec tous vos DAO, il est plus probable que vous obtiendrez une dépendance circulaire entre les packages, ce qui est interdit dans Go.  Et si vous disposez de plusieurs services qui incluent ce package DAO en tant que bibliothèque, vous pouvez également rencontrer une situation où un changement dans un service nécessite la mise à jour de tous vos services, sinon quelque chose se cassera.  C'est ce qu'on appelle un monolithe distribué et est incroyablement difficile à mettre à jour. <br><br>  Lorsque vous savez comment les emballages devraient fonctionner et ce qui les aggrave, «commencer à servir le mal» devient simple.  Organisez mal votre code et donnez de mauvais noms à vos packages.  Divisez votre code en packages tels que <i>model</i> , <i>util</i> et <i>dao</i> .  Si vous voulez vraiment commencer à créer le chaos, essayez de créer des packages en l'honneur de votre chat ou de votre couleur préférée.  Lorsque les gens sont confrontés à des dépendances cycliques ou à des monolithes distribués en raison de l'utilisation de votre code, vous devez soupirer, rouler des yeux et leur dire qu'ils font simplement du mal ... <br><br><h3>  Interfaces inappropriées </h3><br>  Maintenant que tous nos packages sont corrompus, nous pouvons passer aux interfaces.  Les interfaces dans Go ne sont pas comme les interfaces dans d'autres langues.  Le fait que vous ne déclariez pas explicitement que ce type implémente l'interface au premier abord semble insignifiant, mais en fait il renverse complètement le concept des interfaces. <br><br>  Dans la plupart des langues avec des types abstraits, une interface est définie avant ou en même temps que l'implémentation.  Vous devrez le faire au moins pour les tests.  Si vous ne créez pas l'interface à l'avance, vous ne pouvez pas l'insérer ultérieurement sans casser tout le code qui utilise cette classe.  Parce que vous devez le réécrire avec un lien vers l'interface au lieu d'un type spécifique. <br><br>  Pour cette raison, le code Java a souvent de gigantesques interfaces de service avec de nombreuses méthodes.  Les classes qui implémentent ces interfaces utilisent ensuite les méthodes dont elles ont besoin et ignorent le reste.  L'écriture de tests est possible, mais vous ajoutez un niveau d'abstraction supplémentaire, et lorsque vous écrivez des tests, vous avez souvent recours à des outils pour générer des implémentations de ces méthodes dont vous n'avez pas besoin. <br><br>  Dans Go, les interfaces implicites déterminent les méthodes à utiliser.  Le code possède une interface, et non l'inverse.  Même si vous utilisez un type avec de nombreuses méthodes définies, vous pouvez spécifier une interface qui inclut uniquement les méthodes dont vous avez besoin.  Un autre code utilisant des champs séparés du même type définira d'autres interfaces qui couvrent uniquement les fonctionnalités nécessaires.  En règle générale, ces interfaces n'ont que quelques méthodes. <br><br>  Cela facilite la compréhension de votre code, car une déclaration de méthode détermine non seulement les données dont elle a besoin, mais indique également avec précision les fonctionnalités qu'elle va utiliser.  C'est l'une des raisons pour lesquelles les bons développeurs Go suivent le conseil: " <i>Accepter les interfaces, retourner les structures</i> ." <br><br>  Mais ce n'est pas parce que c'est une bonne pratique que vous devez le faire ... <br>  La meilleure façon de rendre vos interfaces «mauvaises» est de revenir aux principes d'utilisation des interfaces d'autres langues, c'est-à-dire  Définissez les interfaces à l'avance dans le cadre du code appelé.  Définissez d'énormes interfaces avec de nombreuses méthodes utilisées par tous les clients de service.  Il devient difficile de savoir quelles méthodes sont vraiment nécessaires.  Cela complique le code, et la complication, comme vous le savez, est le meilleur ami d'un programmeur «diabolique». <br><br><h3>  Passer les pointeurs de tas </h3><br>  Avant d'expliquer ce que cela signifie, vous devez un peu philosopher.  Si vous distrayez et pensez, chaque programme écrit fait la même chose.  Il reçoit des données, les traite, puis envoie les données traitées à un autre emplacement.  Il en est ainsi, que vous écriviez un système de paie, acceptiez des requêtes HTTP et renvoyiez des pages Web, ou même vérifiez le joystick pour suivre un clic de bouton - les programmes traitent les données. <br><br>  Si nous regardons les programmes de cette manière, la chose la plus importante à faire est de nous assurer qu'il est facile pour nous de comprendre comment les données sont converties.  Il est donc recommandé de conserver les données inchangées aussi longtemps que possible pendant le programme.  Parce que les données qui ne changent pas sont des données faciles à suivre. <br><br>  Dans Go, nous avons des types de référence et des types de valeur.  La différence entre les deux est de savoir si la variable fait référence à une copie des données ou à l'emplacement des données en mémoire.  Les pointeurs, les tranches, les cartes, les canaux, les interfaces et les fonctions sont des types de référence, et tout le reste est un type de valeur.  Si vous affectez une variable de type valeur à une autre variable, cela crée une copie de la valeur;  changer une variable ne change pas la valeur d'une autre. <br><br>  L'affectation d'une variable d'un type de référence à une autre variable d'un type de référence signifie qu'ils partagent tous les deux la même zone de mémoire, donc si vous modifiez les données vers lesquelles le premier pointe, vous modifiez les données vers lesquelles le second pointe.  Cela est vrai pour les variables locales et les paramètres de fonction. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//  a := 1 b := a b = 2 fmt.Println(a, b) // prints 1 2 //  c := &amp;a *c = 3 fmt.Println(a, b, *c) // prints 3 2 3 }</span></span></code> </pre> <br>  Les développeurs de Kind Go veulent faciliter la compréhension de la manière dont les données sont collectées.  Ils essaient d'utiliser le type de valeurs comme paramètres de fonctions aussi souvent que possible.  Il n'y a aucun moyen dans Go de marquer les champs dans les structures ou les paramètres de fonction comme définitifs.  Si une fonction utilise des paramètres de valeur, la modification des paramètres ne modifiera pas les variables dans la fonction appelante.  Tout ce que la fonction appelée peut faire est de renvoyer la valeur à la fonction appelante.  Ainsi, si vous remplissez une structure en appelant une fonction avec des paramètres de valeur, vous ne pouvez pas avoir peur de transférer des données vers la structure, car vous comprenez d'où vient chaque champ de la structure. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>,i*<span class="hljs-number"><span class="hljs-number">2</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { f := Foo{} fA = getA() fB = getB(fA) <span class="hljs-comment"><span class="hljs-comment">//  ,    f fmt.Println(f) }</span></span></code> </pre> <br>  Eh bien, comment devient-on «mal»?  Très simple - retourner ce modèle. <br><br>  Au lieu d'appeler des fonctions qui renvoient les valeurs souhaitées, vous passez un pointeur sur la structure dans la fonction et leur permettez d'apporter des modifications à la structure.  Étant donné que chaque fonction a sa propre structure, la seule façon de savoir quels champs changent est de regarder le code entier.  Vous pouvez également avoir des dépendances implicites entre les fonctions - la 1ère fonction transfère les données nécessaires à la 2ème fonction.  Mais dans le code lui-même, rien n'indique que vous devez d'abord appeler la 1ère fonction.  Si vous construisez vos structures de données de cette façon, vous pouvez être sûr que personne ne comprendra ce que fait votre code. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *Foo)</span></span></span></span> { fA = <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-comment"><span class="hljs-comment">//   fA! func setB(f *Foo) { fB = fmt.Sprintf("%d", fA*2) } func main() { f := Foo{} setA(&amp;f) setB(&amp;f) // ,  setA  setB //    ? fmt.Println(f) }</span></span></code> </pre> <br><h3>  Revêtement de panique </h3><br>  Maintenant, nous commençons à gérer les erreurs.  Vous pensez probablement qu'il est mauvais d'écrire des programmes qui gèrent les erreurs d'environ 75%, et je ne dirai pas que vous vous trompez.  Le code Go est souvent rempli de gestion des erreurs de la tête aux pieds.  Et bien sûr, il serait commode de les traiter pas si facilement.  Des erreurs se produisent et leur gestion est ce qui distingue les professionnels des débutants.  Une gestion erronée des erreurs conduit à des programmes instables qui sont difficiles à déboguer et difficiles à maintenir.  Parfois, être un «bon» programmeur signifie «tendre». <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dus DBUserService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User, error)</span></span></span></span> { rows, err := dus.DB.Query(<span class="hljs-string"><span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span></span>, id) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"no user for id %d"</span></span>, id) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> err = rows.Scan(&amp;name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } err = rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{Id: id, Name: name}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  De nombreux langages, tels que C ++, Python, Ruby et Java, utilisent des exceptions pour gérer les erreurs.  Si quelque chose se passe mal, les développeurs de ces langages lèvent ou lèvent une exception, s'attendant à ce que du code le gère.  Bien sûr, le programme s'attend à ce que le client soit au courant d'une erreur possible de lancement à un emplacement donné afin qu'il soit possible de lever une exception.  Parce que, sauf (sans jeu de mots), les exceptions Java vérifiées, rien dans la signature de la méthode dans les langages ou les fonctions n'indique qu'une exception peut se produire.  Alors, comment les développeurs savent-ils quelles exceptions s'inquiéter?  Ils ont deux options: <br><br><ul><li>  Tout d'abord, ils peuvent lire tout le code source de toutes les bibliothèques que leur code appelle, et toutes les bibliothèques qui appellent les bibliothèques appelées, etc. </li><li>  Deuxièmement, ils peuvent faire confiance à la documentation.  Je peux être partial, mais mon expérience personnelle ne me permet pas de faire entièrement confiance à la documentation. </li></ul><br>  Alors, comment pouvons-nous faire venir ce mal?  Abuser de la panique ( <i>panique</i> ) et de la récupération ( <i>récupérer</i> ), bien sûr!  La panique est conçue pour des situations telles que «le lecteur est tombé» ou «la carte réseau a explosé».  Mais pas pour un tel - "quelqu'un a passé une chaîne au lieu d'un int". <br><br>  Malheureusement, d'autres «développeurs moins éclairés» renverront des erreurs de leur code.  Par conséquent, voici une petite fonction d'aide de PanicIfErr.  Utilisez-le pour transformer les erreurs des autres développeurs en panique. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PanicIfErr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } }</code> </pre> <br>  Vous pouvez utiliser PanicIfErr pour envelopper les erreurs des autres, compresser le code.  Plus de gestion d'erreur laide!  Toute erreur est maintenant une panique.  C'est tellement productif! <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dus DBUserService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadEvil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span></span> { rows, err := dus.DB.Query( <span class="hljs-string"><span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span></span>, id) PanicIfErr(err) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"no user for id %d"</span></span>, id)) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> PanicIfErr(rows.Scan(&amp;name)) PanicIfErr(rows.Close()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{Id: id, Name: name} }</code> </pre> <br>  Vous pouvez placer la récupération quelque part plus près du début du programme, peut-être dans votre propre <i>middleware</i> .  Et dites ensuite que non seulement vous traitez les erreurs, mais que vous nettoyez également le code de quelqu'un d'autre.  Faire le mal en faisant le bien est le meilleur type de mal. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PanicMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); r != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">", - ."</span></span>) } }() h.ServeHTTP(rw, req) } ) }</code> </pre> <br><h3>  Définition des effets secondaires </h3><br>  Ensuite, nous allons créer un effet secondaire.  N'oubliez pas que le «bon» développeur Go veut comprendre comment les données transitent par le programme.  La meilleure façon de savoir ce que traversent les données est de configurer des dépendances explicites dans l'application.  Même les entités qui correspondent à la même interface peuvent varier considérablement dans leur comportement.  Par exemple, un code qui stocke des données en mémoire et un code qui accède à la base de données pour le même travail.  Cependant, il existe des moyens d'installer des dépendances dans Go sans appels explicites. <br><br>  Comme beaucoup d'autres langages, Go a un moyen d'exécuter comme par magie du code sans l'invoquer directement.  Si vous créez une fonction appelée init sans paramètres, elle démarrera automatiquement au chargement du package.  Et, pour encore plus de confusion, si dans un fichier il y a plusieurs fonctions avec le nom init ou plusieurs fichiers dans un seul paquet, elles démarreront toutes. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Account <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ Id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UserId <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"  !"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"   ,     init()"</span></span>) }</code> </pre> <br>  Les fonctions init sont souvent associées à des importations vides.  Go a une façon spéciale de déclarer les importations, qui ressemble à «import _« github.com / lib / pq ».  Lorsque vous définissez un identifiant de nom vide pour un package importé, la méthode init s'exécute dans celui-ci, mais elle n'affiche aucun des identificateurs de package.  Pour certaines bibliothèques Go - telles que les pilotes de base de données ou les formats d'image - vous devez les charger en activant l'importation de package vide, juste pour appeler la fonction init afin que le package puisse enregistrer son code. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/lib/pq"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { db, err := sql.Open( <span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, <span class="hljs-string"><span class="hljs-string">"postgres://jon@localhost/evil?sslmode=disable"</span></span>) }</code> </pre><br>  Et c'est clairement une option «maléfique».  Lorsque vous utilisez l'initialisation, le code qui fonctionne comme par magie est complètement hors du contrôle du développeur.  Les meilleures pratiques ne recommandent pas d'utiliser les fonctions d'initialisation - ce sont des fonctionnalités non évidentes, elles confondent le code et sont faciles à masquer dans la bibliothèque. <br><br>  En d'autres termes, les fonctions init sont idéales pour nos fins perverses.  Au lieu de configurer ou d'enregistrer explicitement des entités dans des packages, vous pouvez utiliser les fonctions d'initialisation et d'importation vide pour configurer l'état de votre application.  Dans cet exemple, nous mettons le compte à la disposition du reste de l'application via le registre et le package lui-même est placé dans le registre à l'aide de la fonction init. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/registry"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StubAccountService <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a StubAccountService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBalance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(accountId </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { registry.Register(<span class="hljs-string"><span class="hljs-string">"account"</span></span>, StubAccountService{}) }</code> </pre> <br>  Si vous souhaitez utiliser un compte, mettez une importation vide dans votre programme.  Il n'est pas nécessaire que ce soit le code principal ou connexe - il doit simplement être «quelque part».  C'est magique! <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( _ <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/account"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/registry"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Balancer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetBalance(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := registry.Get(<span class="hljs-string"><span class="hljs-string">"account"</span></span>).(Balancer) money := a.GetBalance(<span class="hljs-number"><span class="hljs-number">12345</span></span>) }</code> </pre> <br>  Si vous utilisez inits dans vos bibliothèques pour configurer les dépendances, vous verrez immédiatement que d'autres développeurs se demandent comment ces dépendances ont été installées et comment les modifier.  Et personne ne sera plus sage que toi. <br><br><h3>  Configuration compliquée </h3><br>  Il y a encore beaucoup de tout ce que nous pouvons faire avec la configuration.  Si vous êtes un «bon» développeur Go, vous voudrez isoler la configuration du reste du programme.  Dans la fonction main (), vous obtenez des variables de l'environnement et les convertissez en valeurs nécessaires pour les composants qui sont explicitement liés les uns aux autres.  Vos composants ne savent rien des fichiers de configuration ni de la façon dont leurs propriétés sont appelées.  Pour les composants simples, vous définissez les propriétés publiques et pour les plus complexes, vous pouvez créer une fonction d'usine qui reçoit des informations de configuration et renvoie un composant correctement configuré. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b, err := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"account.json"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"error reading config file: %v"</span></span>, err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{} json.Unmarshal(b, &amp;m) prefix := m[<span class="hljs-string"><span class="hljs-string">"account.prefix"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) maker := account.NewMaker(prefix) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Maker <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { prefix <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m Maker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Account</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Account{Name: name, Id: m.prefix + <span class="hljs-string"><span class="hljs-string">"-12345"</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMaker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prefix </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Maker</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Maker{prefix: prefix} }</code> </pre> <br>  Mais les développeurs "maléfiques" savent qu'il vaut mieux disperser les informations sur la configuration à travers le programme.  Au lieu d'avoir une fonction dans un package qui définit les noms et les types de valeur de votre package, utilisez une fonction qui prend la configuration telle qu'elle est et la convertit d'elle-même. <br><br>  Si cela vous semble trop "diabolique", utilisez la fonction init pour charger le fichier de propriétés depuis votre package et définissez vous-même les valeurs.  Il peut sembler que vous avez facilité la vie d'autres développeurs, mais vous et moi savons ... <br><br>  En utilisant la fonction init, vous pouvez définir de nouvelles propriétés à l'arrière du code, et personne ne les trouvera jusqu'à ce qu'elles entrent en production et que tout tombe, car quelque chose n'entrera pas dans l'une des dizaines de fichiers de propriétés nécessaires à l'exécution.  Si vous voulez encore plus de «puissance maléfique», vous pouvez suggérer de créer un wiki pour garder une trace de toutes les propriétés dans toutes les bibliothèques et pour «oublier» en ajouter périodiquement de nouvelles.  En tant que gardien de propriété, vous devenez la seule personne à pouvoir exécuter le logiciel. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m maker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Account</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Account{Name: name, Id: m.prefix + <span class="hljs-string"><span class="hljs-string">"-12345"</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Maker maker <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b, _ := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"account.json"</span></span>) m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{} json.Unmarshal(b, &amp;m) Maker.prefix = m[<span class="hljs-string"><span class="hljs-string">"account.prefix"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) }</code> </pre> <br><h3>  Cadres de fonctionnalité </h3><br>  Enfin, nous arrivons au sujet des frameworks vs bibliothèques.  La différence est très subtile.  Ce n'est pas seulement une question de taille;  vous pouvez avoir de grandes bibliothèques et de petits cadres.  Le framework appelle votre code pendant que vous appelez vous-même le code de la bibliothèque.  Les frameworks exigent que vous écriviez votre code d'une certaine manière, qu'il s'agisse de nommer vos méthodes selon des règles spécifiques, ou qu'elles correspondent à certaines interfaces, ou que vous soyez obligé d'enregistrer votre code dans le framework.  Les frameworks ont leurs propres exigences pour tout votre code.  C'est-à-dire, en général, les frameworks vous commandent. <br><br>  Go encourage l'utilisation des bibliothèques car les bibliothèques sont liées.  Bien que, bien sûr, chaque bibliothèque s'attende à ce que les données soient transmises dans un format spécifique, vous pouvez écrire du code de connexion pour convertir la sortie d'une bibliothèque en entrée pour une autre. <br>  Il est difficile de faire fonctionner les frameworks de manière transparente, car chaque framework veut un contrôle complet sur le cycle de vie du code.  Souvent, la seule façon de faire fonctionner les cadres est que leurs auteurs se réunissent et organisent clairement un soutien mutuel.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et la meilleure façon d'utiliser les «mauvais cadres» pour gagner du pouvoir à long terme est d'écrire votre propre cadre, qui n'est utilisé qu'au sein de l'entreprise. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mal actuel et futur </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir maîtrisé ces astuces, vous vous embarquerez à jamais sur le chemin du mal. </font><font style="vertical-align: inherit;">Dans la deuxième partie, je montrerai comment déployer tout ce "mal", et comment transformer correctement le "bon" code en "mal".</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460645/">https://habr.com/ru/post/fr460645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460633/index.html">Détails d'implémentation pour RSTP et la redondance en anneau étendue propriétaire</a></li>
<li><a href="../fr460635/index.html">CLRium # 6: Concurrence et parallélisme. Deux jours: du processeur à l'async / attente</a></li>
<li><a href="../fr460637/index.html">Contrôle de la lumière sur ZigBee</a></li>
<li><a href="../fr460641/index.html">YouTokenToMe: un outil pour la tokenisation rapide du texte de l'équipe VKontakte</a></li>
<li><a href="../fr460643/index.html">Répartition uniforme des points sur une sphère</a></li>
<li><a href="../fr460647/index.html">Résoudre un travail avec pwnable.kr 05 - mot de passe. Réécrire la table des liens de procédure via la vulnérabilité de chaîne de format</a></li>
<li><a href="../fr460651/index.html">Réunion de la Society of Anonymous Testers: TMS, monitoring monitoring, search quality evaluation and native iOS tests</a></li>
<li><a href="../fr460655/index.html">Comment j'ai brisé Telegram</a></li>
<li><a href="../fr460659/index.html">Utilisation de tuyaux pour pivoter</a></li>
<li><a href="../fr460661/index.html">Tout ce que vous devez savoir sur Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>