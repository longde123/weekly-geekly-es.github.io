<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🎤 👨🏻‍🍳 🐹 الآلي الخلوية في المتصفح 👨🏼‍🍳 🧕🏻 📠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="النظام الآلي الخلوي هو نظام يتكون من خلايا ذات قيم عددية في الشبكة ، وكذلك قواعد تحدد سلوك هذه الخلايا. بتطبيق القاعدة بشكل متكرر على كل خلية شبكة بال...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>الآلي الخلوية في المتصفح</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481672/" style=";text-align:right;direction:rtl"><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/028/8da/3c1/0288da3c139cf936f21eccce5342a6d6.jpg" alt="صورة"></div><br>  النظام الآلي الخلوي هو نظام يتكون من خلايا ذات قيم عددية في الشبكة ، وكذلك قواعد تحدد سلوك هذه الخلايا.  بتطبيق القاعدة بشكل متكرر على كل خلية شبكة بالتوازي مع تصور الشبكة ، يمكن للمرء في كثير من الأحيان الحصول على تأثير كائن حي معين مع سلوك معقد ومعقد ، حتى لو كانت القواعد بسيطة نسبيًا. <br><br>  الأوتوماتيكية الخلوية لها أشكال وأنواع وأبعاد مختلفة.  من المحتمل أن يكون الأوتوماتون الخلوي الأكثر شهرة هو لعبة كونواي للحياة (GOL).  يتكون من شبكة ثنائية الأبعاد تحتوي كل خلية فيها على قيمة ثنائية (حية أو ميتة).  تحدد القواعد المصاحبة ، بناءً على حالة الخلايا المجاورة ، ما إذا كانت الخلية يجب أن تكون ميتة أم حية.  تقول القواعد أن الخلية الحية تموت من الوحدة إذا كان هناك أقل من خليتين حيتين حولها.  إذا كانت أكثر من ثلاث خلايا مجاورة على قيد الحياة ، فإنها تموت من الاكتظاظ السكاني.  بمعنى آخر ، الخلية "تنجو" إذا كانت هناك خلايا مجاورة حية أو 2 حولها.  لكي تظهر الخلية <em>الميتة</em> ، يجب أن تحتوي على ثلاث خلايا مجاورة حية ، وإلا فإنها تظل ميتة.  ويرد أدناه مثال على جهاز GoL يتكرر عبر عدة حالات. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/562/8d3/d06/5628d3d06c87bcf93b7949f8ea5eec7a.gif" alt="لعبة الحياة"></div><br>  إصدار آخر مشهور من automaton الخلوية أحادي الأبعاد؛  يطلق عليه الابتدائية الخلوية التلقائية (ECA).  هذا ما نطبقه في هذا المنشور. <br><a name="habracut"></a><br>  يتم تخزين كل حالة من هذا الإكمال التلقائي كصفيف أحادي البعد لقيم منطقية ، وعلى الرغم من أن هناك حاجة إلى بعدين لتصور حالة GOL ، فإن الإضافة التلقائية للقيم تكفي لهذا الإكمال التلقائي.  بفضل هذا ، يمكننا استخدام بعدين (بدلاً من الرسوم المتحركة) لتصور التاريخ الكامل لحالات هذا التشغيل التلقائي.  كما هو الحال في GOL ، فإن حالة الخلية في هذا الجهاز هي 0 أو 1 ، ولكن على عكس خلية GOL ، والتي يتم تحديثها وفقًا لجيرانها الثمانية ، يتم تحديث خلية ECA استنادًا إلى حالة الجار الأيسر والجار الأيمن ونفسه! <br><br>  فيما يلي أمثلة للقواعد: الخلايا الثلاثة الأولى هي مدخلات القاعدة ، والخلية السفلية هي الخرج ، حيث يكون الأسود 1 والأبيض يساوي 0. وأيضًا ، يمكننا أن نرى الأنماط التي تم إنشاؤها بواسطة كل منها ، عندما تكون الحالة الأولية جميعًا 0 باستثناء 1 في الخلية الوسطى. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/c6d/69a/7adc6d69a6e6f302850bc9227ea8bdb1.jpg"></div><br>  قد تتساءل: لماذا القواعد المذكورة أعلاه مبينة بالأرقام؟  لأن كل رقم في النطاق من 0 إلى 255 يتوافق مباشرة مع قاعدة ECA ، وبالتالي يتم استخدام هذه الأرقام كأسماء للقواعد.  هذه المراسلات مبينة أدناه: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/a41/65e/13b/a4165e13bf83463bbf66a155ba8441fd.png"></div><br>  <i>من الرقم إلى القاعدة</i> <br><br>  يمكن تمثيل أي رقم في النطاق من 0 إلى 255 في شكل ثنائي مع 8 أرقام فقط (السهم الأول أعلاه).  علاوة على ذلك ، يمكننا إعطاء كل من هذه الأرقام فهرسًا استنادًا إلى موقعه (السهم الثاني).  من الطبيعي أن تكون هذه المؤشرات في حدود 0 إلى 7 ، أي أنه يمكن تمثيلها في شكل ثنائي باستخدام 3 أرقام فقط (السهم الثالث).  عند تفسير هذه الأرقام الثلاثة كمدخلات ، والرقم المقابل من الرقم الأصلي كمخرجات ، نحصل على الوظيفة الثلاثية التي نحتاجها (السهم الرابع). <br><br><h2 style=";text-align:right;direction:rtl">  جيل القاعدة </h2><br>  دعنا ننفذ التفسير أعلاه كدالة <code>get_rule</code> ذات ترتيب <code>get_rule</code> تتلقى رقمًا من 0 إلى 255 كمدخلات وإرجاع قاعدة ECA المقابلة لهذا الرقم. <br><br>  نحن بحاجة إلى إنشاء شيء مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rule30 = get_rule(<span class="hljs-number"><span class="hljs-number">30</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> output110 = rule30(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  في المثال أعلاه ، <code>rule30(1,1,0)</code> جميع القيم الثنائية الثلاث في رقم واحد (110 = 6) وستعود قليلاً في هذا الموضع (6) في التمثيل الثنائي 30. الرقم 30 في التمثيل الثنائي هو 00011110 ، لذلك ، سوف ترجع الدالة 0 (نعول على اليمين ونبدأ العد من 0). <br><br>  مع العلم أنه سيتم دمج متغيرات الإدخال الثنائية الثلاثة في رقم واحد ، فلنبدأ بتنفيذ مثل هذه الوظيفة المدمجة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> combine = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b1, b2, b3</span></span></span><span class="hljs-function">) =&gt;</span></span> (b1 &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) + (b2 &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) + (b3 &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  بعد أن قمت بتحويل الوسيطات إلى المواضع المقابلة ، ثم إضافة الأرقام الثلاثة المقلوبة ، نحصل على المجموعة المطلوبة. <br><br>  الجزء المهم الثاني من دالة <code>get_rule</code> هو تحديد قيمة البت في موضع معين في رقم.  لذلك ، دعونا ننشئ دالة <code>get_bit(num, pos)</code> ، والتي يمكنها إرجاع قيمة بت في موضع معين <code>pos</code> في رقم معين.  على سبيل المثال ، الرقم 141 في شكل ثنائي هو 10001101 ، لذلك يجب أن ترجع <code>get_bit(2, 141)</code> <code>1</code> ، ويجب أن تعيد <code>get_bit(5, 141)</code> <code>0</code> . <br><br>  يمكن تنفيذ وظيفة <code>get_bit(num,pos)</code> عن طريق إجراء أول تغيير في الرقم في <code>pos</code> إلى اليمين ، ثم تنفيذ عملية bitwise "AND" مع الرقم 1. <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> get_bit = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num, pos</span></span></span><span class="hljs-function">) =&gt;</span></span> (num &gt;&gt; pos) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  الآن نحن بحاجة فقط إلى الجمع بين هاتين الوظيفتين: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> get_rule = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function"> =&gt;</span></span> (b1, b2, b3) =&gt; get_bit(num, combine(b1, b2, b3));</code> </pre> <br>  ! ممتاز  لذلك ، لدينا وظيفة تتمثل في أن لكل رقم في الفواصل الزمنية لدينا يعطينا قاعدة فريدة من نوعها ECA التي يمكننا أن نفعل أي شيء.  والخطوة التالية هي جعلها في المتصفح. <br><br><h2 style=";text-align:right;direction:rtl">  قواعد التصور </h2><br>  لتقديم automata في المستعرض ، سوف نستخدم عنصر <code>canvas</code> .  يمكن إنشاء <code>canvas</code> وإضافته إلى نص html كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canvas = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>); canvas.width = <span class="hljs-number"><span class="hljs-number">800</span></span>; canvas.height = <span class="hljs-number"><span class="hljs-number">800</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(canvas); };</code> </pre> <br>  لتكون قادرة على التفاعل مع <code>canvas</code> ، نحتاج إلى <em>السياق</em> .  يسمح لنا السياق برسم الأشكال والخطوط وتلوين الكائنات والتنقل بشكل عام في <code>canvas</code> .  يتم توفيرها لنا من خلال طريقة <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext" rel="nofollow"><code>getContext</code></a> من <code>canvas</code> لدينا. <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> context = canvas.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>);</code> </pre> <br>  تشير المعلمة <code>'2d'</code> إلى نوع السياق الذي سنستخدمه في هذا المثال. <br><br>  بعد ذلك ، سننشئ وظيفة ، مع وجود السياق ، فإن قاعدة ECA ، وكذلك بعض المعلومات حول مقياس وعدد الخلايا ، ترسم القاعدة على <code>canvas</code> .  الفكرة هي إنشاء ورسم خط شبكة بخط ؛  الجزء الرئيسي من الكود يبدو كالتالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_rule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, rule, scale, width, height</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> row = initial_row(width); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; height; i++) { draw_row(ctx, row, scale); row = next_row(row, rule); } }</code> </pre> <br>  نبدأ بنوع من الخلايا الأولية ، وهو الصف الحالي.  يحتوي هذا السطر ، كما هو موضح في الأمثلة أعلاه ، على جميع الأصفار ، باستثناء وحدة واحدة في الخلية الوسطى ، ولكن يمكن أن يحتوي أيضًا على صف عشوائي تمامًا من 1 و 0. نرسم هذا الصف من الخلايا ، ثم نستخدم القاعدة لحساب الصف التالي من القيم استنادًا إلى الخط الحالي.  ثم نكرر الرسم ونحسب الخطوات الجديدة حتى نجد أن الشبكة مرتفعة بدرجة كافية. <br><br>  بالنسبة إلى مقتطف الشفرة أعلاه ، نحتاج إلى تنفيذ ثلاث وظائف: <code>initial_row</code> و <code>draw_row</code> و <code>next_row</code> . <br><br>  <code>initial_row</code> هي وظيفة بسيطة.  يقوم بإنشاء صفيف من الأصفار وتغيير العنصر في وسط الصفيف واحدًا. <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initial_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initial_row = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length).fill(<span class="hljs-number"><span class="hljs-number">0</span></span>); initial_row[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(length / <span class="hljs-number"><span class="hljs-number">2</span></span>)] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> initial_row; }</code> </pre> <br>  نظرًا لأن لدينا بالفعل وظيفة قاعدة ، فإن وظيفة <code>next_row</code> يمكن أن تتكون من سطر واحد.  قيمة كل خلية في صف جديد هي نتيجة تطبيق القاعدة مع قيم الخلايا الأقرب ، ويتم استخدام الصف القديم كمدخلات. <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> next_row = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row, rule</span></span></span><span class="hljs-function">) =&gt;</span></span> row.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, i</span></span></span><span class="hljs-function">) =&gt;</span></span> rule(row[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], row[i], row[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]));</code> </pre> <br>  هل لاحظت أننا خدعنا على هذا الخط؟  تتطلب كل خلية في صف جديد إدخالًا من ثلاث خلايا أخرى ، لكن تتلقى خليتان عند حواف الصف بيانات من خليتين فقط.  على سبيل المثال ، <code>next_row[0]</code> الحصول على قيمة <code>next_row[0]</code> من <code>row[-1]</code> .  هذا لا يزال يعمل ، لأنه عند محاولة الوصول إلى القيم عن طريق الفهارس غير الموجودة في المصفوفة ، تُرجع javascript <code>undefined</code> ، ويحدث ذلك دائمًا <code>(undefined &gt;&gt; [ ])</code> (من دالة <code>combine</code> ) دائمًا 0. هذا يعني أننا في الواقع نقوم بمعالجة كل قيمة خارج الصفيف كـ 0. <br><br>  أعلم أن هذا أمر قبيح ، ولكننا سننشئ قريبًا شيئًا جميلًا على الشاشة ، حتى يتسنى لنا المغفرة. <br><br>  التالي يأتي وظيفة <code>draw_row</code> .  هي التي تؤدي العرض! <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, row, scale</span></span></span><span class="hljs-function">) </span></span>{ ctx.save(); row.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell</span></span></span><span class="hljs-function"> =&gt;</span></span> { ctx.fillStyle = cell === <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-string"><span class="hljs-string">'#000'</span></span> : <span class="hljs-string"><span class="hljs-string">'#fff'</span></span>; ctx.fillRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, scale, scale); ctx.translate(scale, <span class="hljs-number"><span class="hljs-number">0</span></span>); }); ctx.restore(); ctx.translate(<span class="hljs-number"><span class="hljs-number">0</span></span>, scale); }</code> </pre> <br>  وهنا نعتمد اعتمادًا كبيرًا على كائن السياق ، باستخدام 5 طرق مختلفة على الأقل منه.  فيما يلي قائمة مختصرة وكيفية استخدامها. <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يشير <code>fillStyle</code> إلى الطريقة التي نريد بها ملء الأشكال.  يمكن أن يكون لونًا ، على سبيل المثال ، <code>"#f55"</code> ، بالإضافة إلى تدرج أو نقش.  نستخدم هذه الطريقة لفصل الخلايا بصريًا عن الخلايا 1. </li><li style=";text-align:right;direction:rtl">  <code>fillRect(x, y, w, h)</code> يرسم مستطيل من نقطة (س ، ص) مع عرض ث والارتفاع ح ، معبأ وفقا ل <code>fillStyle</code> .  المستطيلات لدينا عبارة عن مربعات بسيطة ، ولكن قد تفاجأ بأن نقطة الانطلاق جميعها في الأصل.  لقد حدث ذلك لأننا نستخدم هذه الطريقة مع <code>translate</code> . </li><li style=";text-align:right;direction:rtl">  <code>translate(x, y)</code> يسمح لك بنقل نظام الإحداثيات بأكمله.  يتم حفظ الموضع ، وبالتالي فإن الطريقة هي بديل ممتاز لتتبع المواضع المختلفة للعناصر.  على سبيل المثال ، بدلاً من حساب موضع كل خلية شبكة فردية ، يمكننا ببساطة رسم خلية ، والانتقال إلى اليمين ، ورسم خلية جديدة ، وما إلى ذلك. </li><li style=";text-align:right;direction:rtl">  <code>save()</code> <code>restore()</code> بالاقتران مع طرق تحويل الإحداثيات <code>translate</code> وغيرها.  نستخدمها <em>لحفظ</em> نظام الإحداثيات الحالي عند نقطة معينة ، بحيث يمكننا لاحقًا الرجوع إليه (باستخدام <em>الاستعادة</em> ).  في هذه الحالة ، نقوم بحفظ نظام الإحداثيات قبل تقديم الخط ونقله إلى اليمين.  ثم ، عندما انتهينا من رسم الخط وذهبنا إلى اليمين ، تتم استعادة الإحداثيات ونعود إلى حالتها الأصلية.  ثم نتحرك لأسفل للاستعداد لرسم السطر التالي. </li></ul><br>  الآن لدينا جميع الأجزاء اللازمة لوظيفة <code>draw_rule</code> .  نحن نستخدم هذه الوظيفة في <code>window.onload</code> بعد إعداد <code>canvas</code> .  سنحدد أيضًا المعلمات التي نحتاجها. <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> width = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Width of the canvas const height = 500; // Height of the canvas const cells_across = 200; // Number of cells horizontally in the grid const cell_scale = width / cells_across; // Size of each cell const cells_down = height / cell_scale; // Number of cells vertically in the grid const rule = get_rule(30); // The rule to display const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; document.body.appendChild(canvas); const context = canvas.getContext('2d'); draw_rule(context, rule, cell_scale, cells_across, cells_down); };</span></span></code> </pre> <br>  نحن استخراج أبعاد <code>canvas</code> كمتغيرات منفصلة جنبا إلى جنب مع عدد الخلايا أفقيا.  ثم نقوم بحساب <code>cell_scale</code> و "cell_down" حتى تملأ الشبكة <code>canvas</code> بالكامل ، بينما تظل الخلايا مربعة.  بفضل هذا ، يمكننا بسهولة تغيير "دقة" الشبكة ، وتبقى داخل <code>canvas</code> . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/d98/566/33e/d9856633e69f731e69a8ae40a79591c2.png"></div><br>  هذا كل شئ!  المثال الكامل للرمز موجود على <a href="" rel="nofollow">github</a> وعلى <a href="https://codepen.io/kgolid/pen/oNgZKqV" rel="nofollow">codepen</a> : <br><br><h2 style=";text-align:right;direction:rtl">  المضي قدما </h2><br>  بفضل هذا النظام ، سنكون قادرين على فحص كل القواعد الـ 256 واحدة تلو الأخرى ، إما تكرارا ، أو تغيير الكود ، أو اختيار رقم القاعدة عشوائيا عند تحميل كل صفحة.  مهما كان الأمر ، فمن المثير للغاية دراسة جميع هذه النتائج غير المتوقعة في بيئتنا الخاضعة للرقابة. <br><br>  يمكنك أيضًا جعل الحالة الأولية لخلايا الأوتوماتون عشوائية بدلاً من "الأصفار الصلبة ووحدة واحدة" ثابتة.  لذلك نحصل على نتائج أكثر لا يمكن التنبؤ بها.  يمكن كتابة هذا الإصدار من دالة <code>initial_row</code> كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random_initial_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">width</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(width), _ =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">2</span></span>)); }</code> </pre> <br>  فيما يلي ترى مدى تأثير تغيير خط الإخراج هذا بشكل كبير على الإخراج. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/6a6/023/75e/6a602375ecbe522ad75829547ee92b5f.png"></div><br>  <i>سلسلة مصدر عشوائي</i> <br><br>  وهذا مجرد جانب واحد يمكنك تغييره!  لماذا تقتصر على شرطين فقط؟  (الانتقال من 2 إلى 3 حالات يزيد من عدد القواعد من 256 إلى 7 625 597 484 987!) لماذا تقتصر على المربعات؟  لماذا فقط 2 الأبعاد؟  لماذا قاعدة واحدة فقط في وقت واحد؟ <br><br>  فيما يلي أمثلة على المرئيات المرتكزة على ECA ، ولكن مع وظيفة <code>draw_rule</code> بديلة لا <code>draw_rule</code> الخطوط مع المربعات ، ولكن بنمط متساوي القياس ، ثم تملأ المساحات المحددة بواسطة هذه الخطوط بالألوان.  ليس لديك حتى عرض خطوط فاصلة وعرض الألوان فقط. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/028/8da/3c1/0288da3c139cf936f21eccce5342a6d6.jpg"></div><br>  إذا ذهبت إلى أبعد من ذلك ، فيمكنك إضافة تماثلات ، محورية (صف وسط) ومرآة (صف سفلي). <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/f71/cad/adc/f71cadadc23b156366f5bb93669d8b06.jpg"></div><br>  إذا بدت هذه المرئيات مثيرة للاهتمام بالنسبة لك ، ولكن قم بدراسة <a href="https://generated.space/sketch/hatch-automata-full/" rel="nofollow">هذا الصندوق التفاعلي</a> ، أو حتى أفضل منه ، ابدأ بالكود الذي أنشأناه وحاول الخروج بأتمتة الخلوية الخاصة بك! <br><br>  حظا سعيدا </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar481672/">https://habr.com/ru/post/ar481672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar481662/index.html">محاولة أدوات جديدة لبناء وأتمتة النشر في Kubernetes</a></li>
<li><a href="../ar481664/index.html">Serverless التسعير والتكاليف: AWS Lambda</a></li>
<li><a href="../ar481666/index.html">قواعد سويفت لينت المخصصة</a></li>
<li><a href="../ar481668/index.html">مشكلة العارض الأول ، أو صعوبات تحويل تدفقات الفيديو WebRTC إلى HLS</a></li>
<li><a href="../ar481670/index.html">قم بإنشاء خطة عمل باستخدام AWS Cloud Adoption Framework</a></li>
<li><a href="../ar481674/index.html">قم بتحويل مبيعات السيارات أو كيف لا يتم دمج العملاء وحتى العمل مع من رفضوا خدماتك؟</a></li>
<li><a href="../ar481676/index.html">أسبوع الأمان 52: أمان مكبرات الصوت الذكية وكاميرات IP</a></li>
<li><a href="../ar481678/index.html">قبل مراجعة عطلة: N6IIT01 لاعب وسماعات رأس YB04 حديد التسليح - مرحبا فاي من جنوب الصين</a></li>
<li><a href="../ar481680/index.html">كتابة TodoMVC على dap. الجزء 2</a></li>
<li><a href="../ar481684/index.html">كمبيوتر محمول من Powerbank؟</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>