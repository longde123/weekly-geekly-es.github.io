<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏽 ☦️ 🏇🏼 Pembelajaran Mesin untuk Menemukan Kesalahan dalam Kode: Bagaimana Saya Magang di JetBrains Research ✍🏽 ⛎ 👌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, kami berbicara tentang cara mendapatkan magang di Google. Selain Google, siswa kami mencoba tangan mereka di JetBrains, Yandex, Acronis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pembelajaran Mesin untuk Menemukan Kesalahan dalam Kode: Bagaimana Saya Magang di JetBrains Research</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/434368/">  Baru-baru ini, kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara</a> tentang cara mendapatkan magang di Google.  Selain Google, siswa kami mencoba tangan mereka di JetBrains, Yandex, Acronis, dan perusahaan lain. <br><br>  Pada artikel ini saya akan berbagi pengalaman magang di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JetBrains Research</a> , berbicara tentang tugas yang mereka selesaikan di sana, dan membahas bagaimana pembelajaran mesin dapat menemukan bug dalam kode program. <br><br><img src="https://habrastorage.org/webt/gf/xa/bh/gfxabh9xemshdpmkrr48vind45a.jpeg"><br><a name="habracut"></a><br><h2>  Tentang diri saya </h2><br>  Nama saya Egor Bogomolov, saya seorang mahasiswa tahun ke-4 dari gelar sarjana HSE St. Petersburg dalam Matematika Terapan dan Ilmu Komputer.  Selama 3 tahun pertama, saya, seperti teman-teman sekelas saya, belajar di Universitas Akademik, dan sejak September kami telah pindah ke Sekolah Tinggi Ekonomi bersama seluruh departemen. <br><br>  Setelah tahun ke-2 saya melanjutkan magang musim panas di Google Zurich.  Di sana saya menghabiskan tiga bulan bekerja di tim Kalender Android, sebagian besar waktu melakukan frontend'om dan sedikit riset UX.  Bagian paling menarik dari pekerjaan saya adalah penelitian tentang bagaimana antarmuka kalender akan terlihat di masa depan.  Ternyata menyenangkan bahwa hampir semua pekerjaan yang saya lakukan pada akhir magang berakhir di versi utama aplikasi.  Tetapi topik magang di Google sangat baik dibahas dalam posting sebelumnya, jadi saya akan berbicara tentang apa yang saya lakukan musim panas ini. <br><br><h2>  Apa itu JB Research? </h2><br>  JetBrains Research adalah sekumpulan laboratorium yang bekerja di berbagai bidang: bahasa pemrograman, matematika terapan, pembelajaran mesin, robot, dan lainnya.  Di setiap daerah ada beberapa kelompok ilmiah.  Berdasarkan arahan saya, saya paling mengenal kegiatan kelompok di bidang pembelajaran mesin.  Masing-masing dari mereka menyelenggarakan seminar mingguan di mana anggota kelompok atau tamu undangan berbicara tentang pekerjaan mereka atau artikel menarik di bidang mereka.  Banyak siswa dari HSE datang ke seminar ini, karena mereka pergi ke seberang jalan dari gedung utama Kampus HSE di St. Petersburg. <br><br>  Di program sarjana kami, kami wajib terlibat dalam pekerjaan penelitian (R&amp;D) dan mempresentasikan hasil penelitian dua kali setahun.  Seringkali pekerjaan ini secara bertahap berkembang menjadi magang musim panas.  Ini juga terjadi dengan pekerjaan penelitian saya: musim panas ini saya magang di laboratorium "Metode Pembelajaran Mesin dalam Rekayasa Perangkat Lunak" dengan penyelia riset saya Timofey Bryksin.  Tugas yang sedang dikerjakan di laboratorium ini meliputi saran refactoring otomatis, analisis gaya kode untuk programmer, penyelesaian kode, dan mencari kesalahan dalam kode program. <br><br>  Magang saya berlangsung dua bulan (Juli dan Agustus), dan pada musim gugur saya terus terlibat dalam tugas-tugas yang ditugaskan dalam kerangka penelitian.  Saya bekerja di beberapa area, yang paling menarik dari mereka, menurut saya, adalah pencarian bug secara otomatis dalam kode, dan saya ingin membicarakannya.  Titik awalnya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel oleh Michael Pradel</a> . <br><br><h2>  Pencarian bug otomatis </h2><br><h3>  Bagaimana bug dicari sekarang? </h3><br>  Mengapa mencari bug lebih atau kurang jelas.  Mari kita lihat bagaimana keadaan mereka sekarang.  Detektor bug modern sebagian besar didasarkan pada analisis kode statis.  Untuk setiap jenis kesalahan, cari pola yang sebelumnya diperhatikan yang dapat ditentukan.  Kemudian, untuk mengurangi jumlah positif palsu, heuristik ditemukan, diciptakan untuk setiap kasus individu.  Pola dapat dicari baik dalam pohon sintaksis abstrak (AST) yang dibangun oleh kode dan dalam grafik dari aliran kontrol atau data. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) || x &gt; MAX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = bar(x); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><img src="https://habrastorage.org/webt/76/8t/wn/768twn22o7j83mwak6x-n9kw5d4.png"><br><br>  Kode dan pohon yang dibangun di atasnya. <br><br>  Untuk memahami cara kerjanya, pertimbangkan sebuah contoh.  Jenis bug dapat berupa penggunaan = bukannya == di C ++.  Mari kita lihat bagian kode berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span>; … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value = <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … }</code> </pre><br>  Ada kesalahan dalam ekspresi kondisional, sedangkan yang pertama = dalam penugasan nilai ke variabel sudah benar.  Pola berasal dari sini: jika tugas digunakan di dalam kondisi in, ini adalah bug potensial.  Mencari pola seperti itu di AST, kita dapat mendeteksi kesalahan dan memperbaikinya. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span>; … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … }</code> </pre><br>  Dalam kasus yang lebih umum, kita tidak akan dapat dengan mudah menemukan cara untuk menggambarkan kesalahan.  Misalkan kita ingin menentukan urutan operan yang benar.  Sekali lagi, lihat fragmen kode: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; n; i++) { a[i] = a[<span class="hljs-number"><span class="hljs-number">1</span></span> - i] + a[i - <span class="hljs-number"><span class="hljs-number">2</span></span>]; }</code> </pre><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitReverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> - i; }</code> </pre><br>  Dalam kasus pertama, penggunaan 1-i salah, dan yang kedua sepenuhnya benar, yang jelas dari konteksnya.  Tetapi bagaimana menggambarkannya dalam bentuk pola?  Dengan komplikasi jenis kesalahan, kita harus mempertimbangkan bagian kode yang lebih besar dan menganalisis lebih banyak kasus individual. <br><br>  Contoh motivasi terakhir: informasi berguna juga terkandung dalam nama metode dan variabel.  Bahkan lebih sulit untuk diungkapkan oleh beberapa kondisi yang ditentukan secara manual. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSquare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDim, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> yDim)</span></span></span><span class="hljs-function"> </span></span>{ … } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span>, y = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = getSquare(y, x);</code> </pre><br>  Seseorang memahami bahwa, kemungkinan besar, argumen dalam pemanggilan fungsi dicampuradukkan, karena kita memiliki pemahaman bahwa x lebih mirip xDim daripada yDim.  Tetapi bagaimana cara melaporkan ini ke detektor?  Anda dapat menambahkan beberapa jenis heuristik dari bentuk "nama variabel adalah awalan dari nama argumen", tetapi anggaplah x lebih sering lebar daripada tinggi, jadi tidak lagi dinyatakan. <br><br>  Total: masalah dari pendekatan modern untuk menemukan kesalahan adalah bahwa banyak pekerjaan harus dilakukan dengan tangan Anda: untuk menentukan pola, menambahkan heuristik, karena ini, menambahkan dukungan untuk jenis kesalahan baru di detektor menjadi memakan waktu.  Selain itu, sulit untuk menggunakan bagian penting dari informasi yang ditinggalkan oleh pengembang dalam kode: nama-nama variabel dan metode. <br><br><h3>  Bagaimana pembelajaran mesin dapat membantu? </h3><br>  Seperti yang mungkin Anda perhatikan, dalam banyak contoh kesalahan dapat dilihat oleh manusia, tetapi sulit untuk dijelaskan secara formal.  Dalam situasi seperti itu, metode pembelajaran mesin sering dapat membantu.  Mari kita memikirkan pencarian untuk menyusun ulang argumen dalam panggilan fungsi dan memahami apa yang kita butuhkan untuk mencari mereka menggunakan pembelajaran mesin: <br><br><ol><li>  Sejumlah besar kode sampel tanpa bug </li><li>  Sejumlah besar kode dengan kesalahan jenis tertentu </li><li>  Metode untuk memvariasikan potongan kode </li><li>  Model yang akan kami ajarkan untuk membedakan antara kode dengan dan tanpa kesalahan </li></ol><br>  Kita bisa berharap bahwa dalam sebagian besar kode yang diletakkan di domain publik, argumen dalam panggilan fungsi berada dalam urutan yang benar.  Oleh karena itu, untuk kode sampel tanpa bug, Anda dapat mengambil beberapa dataset besar.  Dalam kasus penulis artikel asli, itu adalah JS 150K (150 ribu file dalam Javascript), dalam kasus kami, dataset serupa untuk Python. <br><br>  Menemukan kode dengan bug jauh lebih sulit.  Tapi kita tidak bisa mencari kesalahan orang lain, tetapi lakukan sendiri!  Untuk jenis kesalahan, Anda perlu menentukan fungsi yang, menurut bagian kode yang benar, akan membuatnya rusak.  Dalam kasus kami, atur ulang argumen dalam panggilan fungsi. <br><br><h3>  Bagaimana cara membuat vektor kode? </h3><br>  Berbekal banyak kode baik dan buruk, kami hampir siap untuk mengajarkan sesuatu.  Sebelum itu, kita masih perlu menjawab pertanyaan: bagaimana menyajikan fragmen kode? <br><br>  Panggilan fungsi dapat direpresentasikan sebagai tupel nama metode, nama metodenya, nama dan tipe argumen yang diteruskan ke variabel.  Jika kita belajar bagaimana membuat vektor token individu (nama variabel dan metode, semua "kata" yang ditemukan dalam kode), maka kita dapat mengambil gabungan vektor-vektor token yang menarik bagi kita dan mendapatkan vektor yang diinginkan untuk fragmen. <br><br>  Untuk membuat vektor token, mari kita lihat bagaimana kata-kata dalam teks biasa membuat vektor.  Salah satu cara paling sukses dan populer adalah word2vec yang diusulkan pada 2013. <br><br><img src="https://habrastorage.org/webt/kj/0o/pp/kj0opp-scftpuqr16t5c9fj1uv0.png"><br><br>  Ini berfungsi sebagai berikut: kami mengajarkan jaringan untuk memprediksi dengan kata kata lain yang muncul di sebelahnya dalam teks.  Dalam hal ini, jaringan terlihat seperti lapisan input ukuran kamus, lapisan tersembunyi ukuran vektorisasi yang ingin kita terima, dan lapisan output, juga ukuran kamus.  Selama pelatihan, jaringan diberi makan dengan vektor unit input dengan satu unit di tempat kata yang dipertanyakan (rubah), dan pada output kami ingin mendapatkan kata-kata yang terjadi di dalam jendela di sekitar kata ini (cepat, coklat, melompat, lebih).  Dalam hal ini, jaringan pertama-tama menerjemahkan semua kata menjadi vektor pada lapisan tersembunyi, dan kemudian membuat prediksi. <br><br>  Vektor yang dihasilkan untuk setiap kata memiliki sifat yang baik.  Sebagai contoh, vektor kata dengan makna yang mirip dekat satu sama lain, dan jumlah dan perbedaan vektor adalah penambahan dan perbedaan dari "makna" kata-kata. <br><br>  Untuk membuat vektorisasi token yang serupa dalam kode, Anda perlu mengatur lingkungan yang akan diprediksi.  Mereka mungkin informasi dari AST: jenis simpul di sekitar, token yang ditemukan, posisi di pohon. <br><br>  Setelah menerima vektorisasi, Anda dapat melihat token mana yang mirip satu sama lain.  Untuk melakukan ini, hitung jarak cosinus di antara mereka.  Akibatnya, vektor tetangga berikut diperoleh untuk Javascript (angka adalah jarak kosinus): <br><br><img src="https://habrastorage.org/webt/lf/q0/4q/lfq04qjp4fcygqjikgy0zq9av8y.png"><br><br>  ID dan LIT yang ditambahkan di awal menunjukkan apakah token adalah pengidentifikasi (nama variabel, metode) atau literal (konstan).  Dapat dilihat bahwa kedekatan itu bermakna. <br><br><h3>  Pelatihan Klasifikasi </h3><br>  Setelah menerima vektorisasi untuk token individu, mendapatkan tampilan untuk sepotong kode dengan potensi kesalahan cukup sederhana: ini adalah gabungan dari vektor-vektor yang penting untuk klasifikasi token.  Perceptron dua lapis dilatih dalam potongan kode dengan ReLU sebagai fungsi aktivasi dan putus untuk mengurangi overfitting.  Belajar konvergen dengan cepat, model yang dihasilkan kecil dan dapat membuat prediksi untuk ratusan contoh per detik.  Ini memungkinkan Anda untuk menggunakannya secara waktu nyata, yang akan dibahas nanti. <br><br><h3>  Hasil </h3><br>  Penilaian kualitas dari classifier yang dihasilkan dibagi menjadi dua bagian: evaluasi pada sejumlah besar contoh yang dibuat secara artifisial dan verifikasi manual pada sejumlah kecil (50 untuk setiap detektor) dari contoh dengan probabilitas prediksi tertinggi.  Hasil untuk tiga detektor (argumen disusun ulang, kebenaran dari operator biner dan operan biner) adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/n9/f5/sm/n9f5smfdvj55bw3qeb-l_y9jub0.png"><br><br>  Beberapa kesalahan yang diprediksi akan sulit ditemukan dengan metode pencarian klasik.  Contoh dengan pengaturan ulang dan kesalahan dalam panggilan ke p.done: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( promises === <span class="hljs-literal"><span class="hljs-literal">null</span></span> || promises . length === <span class="hljs-number"><span class="hljs-number">0</span></span>) { p. done (error , result ) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { promises [<span class="hljs-number"><span class="hljs-number">0</span></span>](error, result).then( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, err</span></span></span><span class="hljs-function">) </span></span>{ p.done(res, err); }); }</code> </pre><br>  Ada juga contoh di mana tidak ada kesalahan, tetapi variabel harus dinamai ulang agar tidak menyesatkan orang yang mencoba mencari tahu kode.  Misalnya, menambahkan lebar dan masing-masing tampaknya bukan ide yang baik, meskipun ternyata tidak menjadi bug: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cw = cs[i].width + each;</code> </pre><br><h3>  Porting Python </h3><br>  Saya terlibat dalam porting karya Michael Pradel dari js ke python, dan kemudian membuat plug-in untuk PyCharm yang mengimplementasikan inspeksi berdasarkan metode yang dijelaskan di atas.  Kami menggunakan dataset <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Python 150K</a> (150 ribu file Python tersedia di GitHub). <br><br>  Pertama, ternyata di Python ada lebih banyak token yang berbeda daripada di javascript.  Untuk js, 10.000 token paling populer menyumbang lebih dari 90% dari semua yang ditemui, sementara untuk Python perlu menggunakan sekitar 40.000.Ini menyebabkan peningkatan ukuran token dalam vektor, yang membuat porting ke plugin sulit. <br><br>  Kedua, setelah menerapkan untuk Python mencari argumen yang salah dalam panggilan fungsi dan melihat hasil secara manual, saya mendapat tingkat kesalahan lebih dari 90%, yang berbeda dengan hasil untuk js.  Setelah mengerti alasannya, ternyata dalam javascript lebih banyak fungsi dideklarasikan dalam file yang sama dengan panggilan mereka.  Saya, mengikuti contoh penulis artikel, pada awalnya tidak mengizinkan deklarasi fungsi dari file lain, yang menyebabkan hasil yang buruk. <br><br>  Menjelang akhir Agustus, saya menyelesaikan implementasi untuk Python dan menulis dasar untuk plugin tersebut.  Plugin ini terus dikembangkan, sekarang siswa Anastasia Tuchina dari laboratorium kami terlibat dalam ini. <br><br>  Anda dapat menemukan langkah-langkah untuk mencoba cara kerja plugin di wiki repositori. <br><br>  Tautan di github: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori dengan implementasi python</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori dengan plugin</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434368/">https://habr.com/ru/post/id434368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434356/index.html">Python Stiller dengan Email</a></li>
<li><a href="../id434358/index.html">Substitusi impor sistem operasi. Bagaimana cara melihat OS domestik</a></li>
<li><a href="../id434360/index.html">Penjelasan pembicaraan tentang pemrograman asinkron dalam Javascript</a></li>
<li><a href="../id434362/index.html">BUKAN perkiraan untuk 2019</a></li>
<li><a href="../id434364/index.html">Dukungan Antrian Hangfire</a></li>
<li><a href="../id434370/index.html">Penakluk bayangan lain di Phaser, atau penggunaan sepeda</a></li>
<li><a href="../id434374/index.html">Memeriksa RBAC di Kubernetes</a></li>
<li><a href="../id434380/index.html">Dasar-dasar Injeksi Ketergantungan</a></li>
<li><a href="../id434382/index.html">Porting Alpine Linux ke RISC-V</a></li>
<li><a href="../id434384/index.html">Atas tanggung jawab pemain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>