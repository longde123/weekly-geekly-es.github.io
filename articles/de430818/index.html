<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍⚖️ ㊗️ 🦐 SQLAlchemy-Beschleunigung für Architekturastronauten 👨🏿‍🏫 👩🏼‍✈️ 🗄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Habr, dies ist ein Bericht des Software-Ingenieurs Alexei Starkov auf der Moscow Python Conf ++ 2018-Konferenz in Moskau. Video am Ende des Beitrags. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQLAlchemy-Beschleunigung für Architekturastronauten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qrator/blog/430818/"><img src="https://habrastorage.org/webt/nk/mr/3o/nkmr3o45oaha-8h6n1elhxx3nai.png"><br><blockquote>  Habr, dies ist ein Bericht des Software-Ingenieurs Alexei Starkov auf der Moscow Python Conf ++ 2018-Konferenz in Moskau.  Video am Ende des Beitrags. </blockquote>  Hallo allerseits!  Mein Name ist Alexei Starkov - das bin ich, in meinen besten Jahren arbeite ich in einer Fabrik. <br>  Jetzt arbeite ich bei Qrator Labs.  Grundsätzlich habe ich mein ganzes Leben lang C und C ++ studiert - ich liebe Alexandrescu, The Gang of Four, die Prinzipien von SOLID - das ist alles.  Was mich zu einem architektonischen Astronauten macht.  Ich habe Python in den letzten Jahren geschrieben, weil es mir gefällt. <br><br>  Wer sind eigentlich "architektonische Kosmonauten"?  Als ich diesen Begriff zum ersten Mal mit Joel Spolsky traf, haben Sie ihn wahrscheinlich gelesen.  Er beschreibt die "Astronauten" als Menschen, die eine ideale Architektur aufbauen wollen, die Abstraktion über Abstraktion, über Abstraktion hängen, die immer allgemeiner wird.  Am Ende sind diese Ebenen so hoch, dass sie alle möglichen Programme beschreiben, aber keine praktischen Probleme lösen.  In diesem Moment geht dem "Astronauten" (dies ist das letzte Mal, dass dieser Begriff von Anführungszeichen umgeben ist) die Luft aus und er stirbt. <br><br>  Ich habe auch Tendenzen zur Erforschung des architektonischen Weltraums, aber in diesem Bericht werde ich ein wenig darüber sprechen, wie es mich gebissen hat und mir nicht erlaubt hat, ein System mit der erforderlichen Leistung zu bauen.  Die Hauptsache ist, wie ich es überwunden habe. <br><br>  Zusammenfassung meines Berichts: war / war. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/wj/_u/7c/wj_u7c0h2uaody3dj48xsbytsb4.png"><br><br>  Eine tausende und millionenfache Zunahme.  Als ich diese Folie machte, war der einzige Gedanke, den ich hatte, "Wie?" <br><br><img src="https://habrastorage.org/webt/of/cb/q_/ofcbq_bd033u4wh31hzexjkstfc.png"><br><br>  Wo könnte ich so viel vermasseln?  Wenn Sie es nicht wie ich vermasseln wollen - lesen Sie weiter. <br><br><img src="https://habrastorage.org/webt/md/ni/gt/mdnigtyu3igzmlqmcf89isptecc.png"><br><br>  Ich werde über das Konfigurationssystem sprechen.  Das Konfigurationssystem ist ein internes Tool in Qrator Labs, das Konfigurationen für das Software Defined Network (SDN) - unser Filternetzwerk - speichert.  Es ist verpflichtet, die Konfiguration zwischen Komponenten zu synchronisieren und ihren Status zu überwachen. <br><br><img src="https://habrastorage.org/webt/xz/kg/zr/xzkgzr2wrphmvslxnx3v2qezxta.png"><br><br>  Woraus besteht es kurz gesagt?  Wir haben eine Datenbank, in der eine Momentaufnahme unserer Konfiguration für das gesamte Netzwerk gespeichert ist, und wir haben einen Server, der die eingehenden Befehle verarbeitet und die Konfiguration irgendwie ändert. <br><br>  Unsere technischen Administratoren und Clients kommen zu diesem Server und geben über die Konsole, über die Endpunkt-APIs, REST-APIs, JSON-RPCs und andere Dinge Befehle an den Server aus, wodurch unsere Konfiguration geändert wird. <br><br>  Teams können entweder sehr einfach oder komplizierter sein.  Dann haben wir einen bestimmten Satz von Empfängern, aus denen unser SDN besteht, und der Server überträgt die Konfiguration an diese Empfänger.  Das klingt ziemlich einfach.  Grundsätzlich werde ich über diesen Teil sprechen. <br><br><img src="https://habrastorage.org/webt/yp/uq/c7/ypuqc7pzaeqvmbzsrksb9gefq-w.png"><br><br>  Da ist sie es, die mit der Datenbank und der Alchemie verwandt ist. <br><br><img src="https://habrastorage.org/webt/qg/sz/np/qgsznprvrp4smdpbuoxopevxxt4.png"><br><br>  Was ist die Besonderheit dieses Systems?  Es ist ziemlich klein - mittelmäßig.  Hunderttausende, bis zu Millionen von Entitäten werden in dieser Datenbank gespeichert.  Die Besonderheit ist, dass der Graph der Beziehungen zwischen Entitäten ziemlich komplex ist.  Es gibt mehrere Vererbungshierarchien zwischen Entitäten, es gibt Einschlüsse, es gibt einfach Abhängigkeiten zwischen ihnen.  Alle diese Einschränkungen werden von der Geschäftslogik bestimmt und wir müssen sie einhalten. <br><br>  Das Verhältnis von Schreibanforderungen zu Leseanforderungen beträgt ungefähr 15: 1.  Hier ist klar: Es gibt viele Befehle zum Ändern der Konfiguration, und einmal in einem bestimmten Zeitraum haben wir die Konfiguration an die Endpunkte verschoben. <br><br>  MySQL wird intern verwendet - es ist auch in anderen Produkten unseres Unternehmens verfügbar, wir haben ziemlich ernsthaftes Fachwissen in dieser Datenbank, es gibt Leute, die damit arbeiten können: Erstellen eines Datenschemas, Entwurfsabfragen und alles andere.  Daher haben wir MySQL als universelle relationale Datenbank verwendet. <br><br><img src="https://habrastorage.org/webt/x0/xs/ae/x0xsae3wqaqw4dfth-y8q7i3tqk.png"><br><br>  Was war das Problem, nachdem wir dieses System entworfen haben?  Die Ausführung eines Befehls dauerte je nach Komplexität des Teams zwischen einer und dreißig Sekunden.  Dementsprechend erreichte die Verzögerung der Ausführung fünf Minuten.  Ein Team traf ein - 30 Sekunden, das zweite und so weiter, ein Stapel angesammelter - eine Verzögerung von 5 Minuten. <br><br>  Die Verzögerung beim Anwenden der Konfiguration beträgt bis zu zehn Minuten.  Es wurde entschieden, dass dies für uns nicht ausreicht und dass eine Optimierung erforderlich ist. <br><br><img src="https://habrastorage.org/webt/ah/6t/fj/ah6tfjmleq-fzvoecldzw5qxxu0.png"><br><br>  Bevor eine Optimierung durchgeführt wird, muss zunächst eine Untersuchung durchgeführt werden, um herauszufinden, worum es tatsächlich geht. <br><br><img src="https://habrastorage.org/webt/nu/wf/g6/nuwfg6v2hg2jangw6agmu9i6bw0.png"><br><br>  Wie sich herausstellte, fehlte uns die wichtigste Komponente für die Untersuchung - wir hatten keine Telemetrie.  Wenn Sie also eine Art System entwerfen, setzen Sie zunächst in der Entwurfsphase Telemetrie ein.  Selbst wenn das System anfangs klein ist, dann ein bisschen mehr, dann noch mehr - am Ende kommt jeder in eine Situation, in der man Tracks sehen muss, aber es gibt keine Telemetrie. <br><br><img src="https://habrastorage.org/webt/eh/ws/3t/ehws3tezqmrdlvfcljs1pxbttgm.png"><br><br>  Was kann als nächstes getan werden, wenn Sie keine Telemetrie haben?  Sie können die Protokolle analysieren.  Hier gehen ziemlich einfache Skripte unsere Protokolle durch und wandeln sie in eine solche Tabelle um, die die schnellsten, langsamsten und durchschnittlichen Befehlsausführungszeiten darstellt.  Ab hier können wir bereits sehen, an welchen Stellen wir Gags haben: Welche Teams brauchen länger, welche schneller. <br><br><img src="https://habrastorage.org/webt/m6/0a/gc/m60agccykga4hl82ktrjfjglzqq.png"><br><br>  Das einzige, was zu beachten ist, ist, dass bei der Analyse der Protokolle nur die Ausführungszeit dieser Befehle auf dem Server berücksichtigt wird.  Dies ist die erste Stufe - die als t2 gekennzeichnete.  t1 - So sieht der Client die Ausführungszeit unseres Teams: In die Warteschlange treten, warten, Ausführung auf dem Server.  Diese Zeit wird länger sein, daher optimieren wir die Zeit t2 und verwenden dann die Zeit t1, um festzustellen, ob wir das Ziel erreicht haben. <br><br>  t1 ist die Qualitätsmetrik unserer Leistung. <br><br><img src="https://habrastorage.org/webt/dx/dd/05/dxdd05sisxq1ciu6nu-na0zons8.png"><br><br>  Dementsprechend haben wir auf diese Weise alle Teams profiliert - das heißt, wir haben das Protokoll vom Server genommen, es durch unsere Skripte geführt, die Komponenten gesucht und identifiziert, die am langsamsten arbeiteten.  Der Server ist recht modular aufgebaut, für jeden Befehl ist eine eigene Komponente verantwortlich, und wir können die Komponenten einzeln profilieren - und Benchmarks für sie erstellen.  Hier hatten wir also eine Klasse - für jede problematische Komponente, die wir geschrieben haben, in der wir in code_under_test () eine Aktivität ausgeführt haben, die den Kampfeinsatz der Komponente darstellt.  Und es gab zwei Methoden: profile () und bank ().  Der erste Aufruf von cProfile zeigt an, wie oft was aufgerufen wurde und wo die Engpässe liegen. <br><br>  Bench () wurde mehrmals ausgeführt und hat für uns unterschiedliche Metriken berücksichtigt - so haben wir die Leistung bewertet. <br><br>  Es stellte sich jedoch heraus, dass dies nicht das Problem ist! <br><br><img src="https://habrastorage.org/webt/wz/r8/-p/wzr8-pc9epal61cjoraog7bkvxc.png"><br><br>  Das Hauptproblem war die Anzahl der Datenbankabfragen.  Es gab viele Anfragen, und um zu verstehen, warum es so viele gab, schauen wir uns an, wie alles organisiert war. <br><br><img src="https://habrastorage.org/webt/bg/r0/rz/bgr0rzhohcouyykpc3raznbi4rq.png"><br><br>  Vor uns liegt ein Teil einer einfachen Schaltung, die unsere Empfänger darstellt und in Form der Reciever-Klasse dargestellt wird.  Sie sind in einer Gruppe - Empfängergruppe - vereint.  Dementsprechend gibt es einige Konfigurationsebenen - Slices der Konfiguration, die eine Teilmenge der Konfigurationen sind, die für eine „Rolle“ dieses Empfängers verantwortlich sind.  Zum Beispiel für Routing - Routing-Ebene.  Ebenen mit Empfängern können in beliebiger Reihenfolge verbunden werden - das heißt, dies ist eine Viele-zu-Viele-Beziehung. <br><br>  Dies ist ein Teil des großen Umrisses, den ich hier präsentiere, damit Beispiele besser verstanden werden können. <br><br>  Was möchte jeder Architektur-Kosmonaut tun, wenn er die API eines anderen sieht?  Er möchte es ausblenden, abstrahieren und seine Schnittstelle schreiben, um diese API entfernen oder vielmehr ausblenden zu können. <br><br><img src="https://habrastorage.org/webt/nq/zq/7-/nqzq7-zlnbxkkmy7mywbp8lqvq4.png"><br><br>  Dementsprechend gibt es eine "schmutzige" API der Alchemie, in der es tatsächlich Mapper und unsere "reine" Klasse - Receiver gibt, in der einige Konfigurationen gespeichert sind und es Methoden gibt: load (), save (), delete ().  Und alle anderen damit verbundenen Klassen.  Wir erhalten ein Diagramm von Python-Objekten, die irgendwie miteinander verbunden sind - jedes von ihnen verfügt über eine Methode load (), save (), delete (), die sich auf den Alchemy Mapper bezieht, der wiederum die API aufruft. <br><br><img src="https://habrastorage.org/webt/cs/bo/lr/csbolr6uozuvbxhimmqik_llgak.png"><br><br>  Die Implementierung hier ist sehr einfach.  Wir haben eine Lademethode, die eine Abfrage an die Datenbank durchführt und für jedes empfangene Objekt ein eigenes Python-Objekt erstellt.  Es gibt eine Speichermethode, die den umgekehrten Vorgang ausführt. Wenn nicht, wird ein Objekt mit dem Primärschlüssel in der Datenbank vorhanden. Andernfalls wird der Status dieses Objekts erstellt, hinzugefügt und anschließend gespeichert.  Löschen auf dem Primärschlüssel empfängt und löscht das Objekt aus der Datenbank. <br><br><img src="https://habrastorage.org/webt/fl/hq/lp/flhqlp2vg6srgo7wswpbowrlq6e.png"><br><br>  Das Hauptproblem ist sofort sichtbar - dies ist die Zuordnung.  Zuerst machen wir es einmal vom Python-Objekt zum Mapper, dann vom Mapper zur Basis.  Zusätzliche Zuordnung sind ein oder zwei Aufrufe, die möglicherweise noch nicht so beängstigend sind.  Das Hauptproblem war die manuelle Synchronisation.  Wir haben zwei Objekte unserer "sauberen" Oberfläche und eines davon ändert das Attribut - wie sehen wir, dass sich das Attribut im anderen geändert hat?  Auf keinen Fall.  Es ist erforderlich, die Änderungen in der Datenbank zusammenzuführen und das Attribut in einem anderen Objekt abzurufen.  Wenn wir wissen, dass Objekte im selben Kontext vorhanden sind, können wir dies natürlich irgendwie verfolgen.  Aber wenn wir zwei Sitzungen an verschiedenen Orten haben - nur über die Basis oder blockieren Sie die Basis im Speicher, was wir nicht getan haben. <br><br>  Dieses Laden / Speichern / Löschen ist ein weiterer Mapper, der die Innenseiten der Alchemie vollständig dupliziert, was gut geschrieben und getestet ist.  Dieses Tool ist viele Jahre alt, es gibt eine Menge Hilfe im Internet und das Duplizieren ist auch nicht sehr gut. <br><br>  Sehen Sie das Symbol in der oberen rechten Ecke?  Also werde ich die Folien markieren, auf denen etwas für "Reinheit" getan wird, um den Abstraktionsgrad für die architektonische Astronautik zu erhöhen.  Das heißt, Folien ohne dieses Symbol sind pragmatisch und langweilig, uninteressant und können nicht gelesen werden. <br><br>  Was tun, wenn viele Abfragen langsam sind?  Wie viele?  Eigentlich viel.  Stellen Sie sich eine Vererbungskette vor: Ein Objekt hat ein Elternteil, dieses hat ein anderes Elternteil.  Wir synchronisieren das untergeordnete Objekt. Dazu müssen Sie zuerst die übergeordneten Objekte synchronisieren.  Um ein übergeordnetes Element zu synchronisieren, müssen Sie das übergeordnete Element synchronisieren.  Nun, alle waren synchronisiert.  Abhängig davon, wie wir das Diagramm erstellt haben, können wir alle diese Objekte hundertmal durchlaufen und synchronisieren - daher eine große Anzahl von Anforderungen. <br><br><img src="https://habrastorage.org/webt/zo/n7/uh/zon7uhhtngwjd5rnaztxexuatsu.png"><br><br>  Was haben wir getan  Wir haben unsere gesamte Geschäftslogik übernommen und in den Mapper gesteckt.  Alle anderen Objekte hier wurden ebenfalls mit den Mappern zusammengeführt, und unsere gesamte API, die gesamte Datenabstraktionsschicht, erwies sich als fehlerhaft. <br><br><img src="https://habrastorage.org/webt/qn/4a/fz/qn4afzy7q6yrh0t-yw4r4m6c9se.png"><br><br>  So sieht es in Python aus - unser Mapper hat eine Art Geschäftslogik, genau dort gibt es eine deklarative Beschreibung dieser Platte.  Spalten werden aufgelistet, Beziehungen.  Hier haben wir eine solche Klasse. <br><br><img src="https://habrastorage.org/webt/ez/ud/sg/ezudsgqk1b9domctg8sdvzh4uj8.png"><br><br>  Aus Sicht eines jeden Astronauten ist eine schmutzige API natürlich ein Nachteil.  Geschäftslogik in einer deklarativen Beschreibung der Basis.  Schemata werden mit Geschäftslogik gemischt.  Puh.  Hässlich. <br><br>  Die Beschreibung der Schaltung ist unübersichtlich.  Dies ist tatsächlich ein Problem - wenn die Geschäftslogik nicht aus zwei Zeilen, sondern aus einem größeren Volumen besteht, müssen wir in dieser Klasse sehr lange scrollen oder suchen, um zu bestimmten Beschreibungen zu gelangen.  Davor war alles schön: an einem Ort die Beschreibung der Basis, deklarativ, Beschreibung der Schemata, an einem anderen Ort Geschäftslogik.  Und dann ist die Schaltung überfüllt. <br><br>  Andererseits erhalten wir sofort die Mechanismen der Alchemie: Arbeitseinheit, mit der Sie verfolgen können, welche Objekte verschmutzt sind und welche Relais aktualisiert werden müssen;  Wir erhalten eine Beziehung, die es uns ermöglicht, zusätzliche Fragen in der Datenbank zu entfernen, ohne sicherzustellen, dass die relevanten Sammlungen gefüllt sind.  und die Identitätskarte, die uns am meisten geholfen hat.  Die Identitätszuordnung stellt sicher, dass zwei Python-Objekte dasselbe Python-Objekt sind, wenn sie denselben Primärschlüssel haben. <br><br>  Dementsprechend haben wir die Komplexität sofort auf linear reduziert. <br><br><img src="https://habrastorage.org/webt/j4/ek/x8/j4ekx8dvwphpdavetrxejd1uvxg.png"><br><br>  Dies sind Zwischenergebnisse.  Die Leistung stieg sofort um das Zehnfache, die Anzahl der Abfragen an die Datenbank sank um das 40-80-fache und der RPS stieg auf 1-5.  Gut.  Aber die API ist schmutzig.  Was zu tun ist? <br><br><img src="https://habrastorage.org/webt/kj/po/hs/kjpohswqs8svlzroeizbub0tpmk.png"><br><br>  Mixins.  Wir nehmen die Geschäftslogik, entfernen sie wieder aus unserem Mapper, aber damit es kein Mapping mehr gibt, erben wir unseren Mapper innerhalb der Alchemie von unserem Mixin.  Warum nicht umgekehrt?  Dies wird in der Alchemie nicht funktionieren, sie wird schwören und sagen: "Sie haben zwei verschiedene Klassen, die sich auf eine Tablette beziehen, es gibt keinen Polyformismus - gehen Sie von hier aus."  Und so - es ist möglich. <br><br>  Wir haben also eine deklarative Beschreibung im Mapper, die vom Mixin geerbt wird und die gesamte Geschäftslogik empfängt.  Sehr bequem.  Und der Rest der Klassen ist genau das gleiche.  Es scheint - cool, alles ist sauber.  Es gibt jedoch eine Einschränkung: Verbindungen und Relais verbleiben in der Alchemie, und wenn wir uns beispielsweise durch eine sekundäre Zwischenplatten-Tabelle verbinden, ist der Mapper dieser Platte irgendwie im Client-Code vorhanden, was nicht sehr schön ist. <br><br>  Die Alchemie wäre kein so guter, berühmter Rahmen gewesen, wenn sie mir nicht die Gelegenheit gegeben hätte, dagegen anzukämpfen. <br><br><img src="https://habrastorage.org/webt/g6/dz/gg/g6dzggup-pvokdl7h4mguhedazc.png"><br><br>  Wie sieht ein Mixin aus?  Er hat Geschäftslogik, Mapper separat, eine deklarative Beschreibung der Platte.  Verbindungen bleiben innerhalb der Alchemie, aber die Geschäftslogik ist getrennt. <br><br>  Wie sieht der allgemeine Umriss aus? <br><br><img src="https://habrastorage.org/webt/xl/1c/eh/xl1cehyjtaoqytk_gz5h-wbc5we.png"><br><br>  Wir haben eine Datei mit einem Schema, in dem alle unsere deklarativen Klassen gesammelt werden - nennen wir es schema.py.  Und wir haben Entitäten in der Geschäftslogik separat.  Diese Entitäten werden in der Schemadatei vererbt. Wir schreiben für jede Entität eine separate Klasse und erben sie im Schema.  Somit liegt die Geschäftslogik in einem Haufen, das Schema in einem anderen und sie können unabhängig voneinander geändert werden. <br><br><img src="https://habrastorage.org/webt/rj/cl/ql/rjclqll79e8wcjwkjfxova8hhpe.png"><br><br>  Als Beispiel für eine Verbesserung betrachten wir ein einfaches Schema aus zwei Bezeichnungen: Empfänger (Empfängertabelle) und Slices der Konfiguration (ReceiverPlanes-Tabelle).  Dem Empfängeretikett sind mehrere Konfigurationsscheiben zugeordnet.  Es gibt nichts besonders kompliziertes. <br><br>  Um Beziehungen innerhalb der „schmutzigen“ Schnittstelle der Alchemie zu verbergen, verwenden wir Beziehungen und Sammlungen. <br><br><img src="https://habrastorage.org/webt/mz/ih/qg/mzihqg-lfqb8vhflbkxjpf8igp8.png"><br><br>  Sie ermöglichen es uns, unsere Mapper vor dem Client-Code zu verbergen. <br><br><img src="https://habrastorage.org/webt/y8/qc/v1/y8qcv1qj8_jq3y_pn-2xw-t6bji.png"><br><br>  Insbesondere sind zwei sehr nützliche Sammlungen Associated_proxy und attribute_mapped_collection.  Wir benutzen sie zusammen.  Wie die klassische Beziehung in der Alchemie funktioniert: Wir haben eine Beziehung - dies ist eine bestimmte Sammlung, Liste, Mapper.  Mapper sind weit entfernte Beziehungsobjekte.  Mit Attribute_mapped_collection können Sie diese Liste durch ein Diktat ersetzen, dessen Schlüssel einige der Attribute der Mapper sind und deren Werte die Mapper selbst sind. <br><br>  Dies ist der erste Schritt. <br><br><img src="https://habrastorage.org/webt/ho/tj/tt/hotjtty0hmg99f_kquecwyo4ms4.png"><br><br>  Im zweiten Schritt führen wir Association_Proxy über diese Beziehung aus.  Es erlaubt uns, den Mapper nicht an die Sammlung zu übergeben, sondern einen Wert zu übergeben, der später zum Initialisieren unseres Mappers ReceiverPlanes verwendet wird. <br><br>  Hier haben wir Lambda, in dem wir den Schlüssel und den Wert übergeben.  Der Schlüssel wird zum Namen des Konfigurations-Slice und der Wert zum Wert des Konfigurations-Slice.  Infolgedessen sieht im Client-Code alles so aus. <br><br><img src="https://habrastorage.org/webt/ko/00/s7/ko00s71bgaxu6i-h_baocnnqz-w.png"><br><br>  Wir haben nur eine Art Diktat in eine Art Wörterbuch eingefügt.  Alles funktioniert: keine Mapper, keine Alchemie, keine Datenbanken. <br><br>  Es stimmt, es gibt Fallstricke. <br><br><img src="https://habrastorage.org/webt/ux/ji/uy/uxjiuybsymdbtrvqlazqhckdv8c.png"><br><br>  Wenn wir demselben Schlüssel zweimal unterschiedliche oder sogar einen Wert zuweisen - Lambda wird für jedes dieser festgelegten Elemente aufgerufen, wird ein Objekt erstellt - ein Mapper.  Und je nach Struktur des Schemas kann dies zu verschiedenen Konsequenzen führen, von „nur Verstößen gegen die Konstanten“ bis zu unvorhersehbaren Konsequenzen.  Sie haben beispielsweise ein Objekt aus der Sammlung gelöscht, es ist jedoch weiterhin dort geblieben: Sie haben nur eines gelöscht.  Als ich anfing, habe ich viel Zeit mit solchen Dingen verbracht. <br><br>  Und eine kleine implizite Synchronisation.  Association_proxy und attribute_mapped_collection können etwas verzögert sein: Wenn wir ein Mapper-Objekt erstellen, wird es der Datenbank hinzugefügt, ist jedoch noch nicht im Auflistungsattribut vorhanden.  Es wird dort nur angezeigt, wenn das Attribut in dieser Sitzung abläuft.  Wenn es abläuft, wird eine neue Synchronisation mit der Datenbank durchgeführt und es wird dort ankommen. <br><br>  Um dies zu überwinden, haben wir unsere eigenen, selbst geschriebenen Sammlungen verwendet.  Dies ist nicht einmal Alchemie - Sie können einfach Ihre eigene Sammlung erstellen, um all dies zu überwinden. <br><br><img src="https://habrastorage.org/webt/bk/l6/ya/bkl6yaerwagttjp6qprlfbsdpaw.png"><br><br>  Es gibt mehr Code und der wichtigste Teil wird hervorgehoben.  Wir haben eine bestimmte Sammlung, die von veränderlichen Zuordnungen erbt - dies ist ein Diktat, in dessen Schlüsseln Sie die Werte ändern können.  Und es gibt eine _get_plane_obj-Methode, um das Konfigurations-Slice-Objekt abzurufen. <br><br>  Hier machen wir einfache Dinge - wir versuchen, es durch Namen, durch einen Primärschlüssel zu erhalten, und wenn dies nicht der Fall ist, erstellen wir dieses Objekt und geben es zurück. <br><br>  Als nächstes definieren wir nur zwei Methoden neu: __setitem__ und __getitem__ <br>  In __setitem__ fügen wir diese Objekte in einer Sammlung in unsere Sammlung ein.  Das einzige ist, dass wir ganz am Ende Wert zuweisen.  Daher implementieren wir den gleichen Mechanismus wie assoziations_proxy - übergeben Sie den Wert, diktieren Sie dort und er wird dem entsprechenden Attribut zugewiesen. <br><br>  __getitem__ führt die umgekehrte Manipulation durch.  Es empfängt per Schlüssel ein Objekt vom Relais und gibt sein Attribut zurück.  Hier gibt es auch eine kleine Gefahr: Wenn Sie die Sammlung in unserem Mapping zwischenspeichern, kann es sein, dass die Synchronisation etwas ausfällt.  Denn wenn das Attribut der Sammlung in der Alchemie abgelaufen ist, wird die Sammlung nach Ablauf durch eine andere ersetzt.  Daher können wir den Verweis auf die alte Sammlung beibehalten und wissen nicht, dass die alte abgelaufen ist und eine neue bereits erschienen ist.  Daher gehen wir im letzten Teil direkt zur Instanz der Alchemie, erhalten die Sammlung erneut über __getattr__ und machen __getitem__ damit.  Das heißt, wir können die Planes-Sammlung hier nicht zwischenspeichern. <br><br><img src="https://habrastorage.org/webt/_0/l6/tt/_0l6tt3pcdjmsxlwy2hivf1b4ty.png"><br><br>  Wie schlägt diese Sammlung auf unsere Mixins?  Richten Sie wie gewohnt ein Sammlungsattribut ein.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einzig interessante Ort ist, dass beim Laden einer Instanz aus der Datenbank die Methode __init__ nicht aufgerufen wird. Alle Attribute werden nachträglich ersetzt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alchemy bietet einen Standard-Rekonstruktor-Dekorator, mit dem Sie eine Methode als aufgerufen markieren können, nachdem Sie ein Objekt aus der Datenbank geladen haben. Und gerade beim Booten müssen wir unsere Sammlung initialisieren. Selbst ist genau diese Instanz. Die Verwendung ist genau die gleiche wie im vorherigen Beispiel. </font></font><br><br><img src="https://habrastorage.org/webt/qe/yr/h4/qeyrh4fd3cmfpm8-exbfd1rwpkw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unserem Schema sind die Ohren der Datenbank jedoch weiterhin sichtbar - dies ist die Konfiguration. Welche Art von Konfiguration? Ist es varchar oder ist es blob? In der Tat ist der Kunde nicht interessiert. Er muss mit abstrakten Entitäten seiner Ebene arbeiten. Dafür bietet die Alchemie eine Art Dekoration.</font></font><br><br><img src="https://habrastorage.org/webt/ds/lc/ic/dslcicbf3yrljfchfwbxhcucleq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein einfaches Beispiel. Unsere Datenbank speichert IPAddress als varchar. Wir verwenden die TypeDecorator-Klasse, die Teil der Alchemie ist und die es ermöglicht, zum einen anzugeben, welcher zugrunde liegende Datenbanktyp für diesen Typ verwendet wird, und zum anderen zwei Parameter zu definieren: process_bind_param, die den Wert in den Datenbanktyp konvertieren, und process_result_value, wenn wir bewerten Konvertieren Sie vom Datenbanktyp in ein Python-Objekt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Attribut from address nimmt den Python-Typ IPAddress an. Und wir können beide Methoden dieses Typs aufrufen und Objekte dieses Typs zuweisen, und alles funktioniert für uns. Und es ist in der Datenbank gespeichert ... Ich weiß nicht, was gespeichert ist, varchar (45), aber wir können diese Zeile ersetzen und der Blob wird gespeichert. Wenn ein nativer Typ IP-Adressen unterstützt, können Sie ihn verwenden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Client-Code hängt nicht davon ab, er muss nicht neu geschrieben werden. </font></font><br><br><img src="https://habrastorage.org/webt/xb/m5/uu/xbm5uu_ryeji94kthsv0rp2ogdw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere interessante Sache ist, dass wir eine Version haben. Wir möchten, dass die Version sofort erhöht wird, sobald wir unser Objekt ändern. Wir haben einen Versionszähler, wir haben das Objekt geändert - es hat sich geändert, die Version hat sich erhöht. Wir machen das automatisch, um nicht zu vergessen. </font></font><br><br><img src="https://habrastorage.org/webt/zy/g5/ro/zyg5rofkv1ibi-yb-kuv3kikbww.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dafür haben wir Ereignisse verwendet. Ereignisse sind Ereignisse, die in verschiedenen Lebensphasen eines Mappers auftreten. Sie können ausgelöst werden, wenn sich Attribute ändern, wenn eine Entität von einem Status in einen anderen wechselt, z. B. "erstellt", "in der Datenbank gespeichert", "aus der Datenbank geladen", "gelöscht". und auch - bei Ereignissen auf Sitzungsebene, bevor der SQL-Code an die Datenbank ausgegeben wird, vor dem Festschreiben, nach dem Festschreiben und auch nach dem Rollback.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Alchemy können wir Handler für alle diese Ereignisse zuweisen, aber die Reihenfolge, in der Handler für dasselbe Ereignis ausgeführt werden, ist nicht garantiert. Das heißt, es ist spezifisch, aber es ist nicht bekannt, welches. Wenn Ihnen die Ausführungsreihenfolge wichtig ist, müssen Sie daher einen Registrierungsmechanismus durchführen. </font></font><br><br><img src="https://habrastorage.org/webt/wb/h2/w1/wbh2w1k4s4y6jqemt4oatlknwug.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Beispiel. Hier werden drei Ereignisse verwendet:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on_before_flush - Bevor der SQL-Code an die Datenbank ausgegeben wird, gehen wir alle Objekte durch, die in dieser Sitzung als fehlerhaft markiert wurden, und prüfen, ob dieses Objekt geändert wurde oder nicht. Warum ist das notwendig, wenn die Alchemie bereits alles markiert hat? Alchemie markiert ein Objekt als verschmutzt, sobald sich ein Attribut geändert hat. Wenn wir diesem Attribut denselben Wert zuweisen, den es hatte, wird es als verschmutzt markiert. Hierfür gibt es eine is_modified-Sitzungsmethode - sie wird intern verwendet, ich habe sie nicht gezeichnet. Aus Sicht unserer Semantik und aus Sicht unserer Geschäftslogik kann das Objekt auch dann unverändert bleiben, wenn sich das Attribut geändert hat. Zum Beispiel gibt es eine bestimmte Liste, in der zwei Elemente ausgetauscht werden - aus Sicht der Alchemie hat sich das Attribut geändert, aber es spielt für die Geschäftslogik keine Rolle, wenn beispielsweiseeine Art.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und am Ende rufen wir eine andere objektspezifische Methode auf, um zu verstehen, ob das Objekt geändert wird oder nicht. Und wir fügen sie einer bestimmten Variablen hinzu, die mit der Sitzung verknüpft ist, die wir selbst aufgerufen haben - dies ist unsere Variable dirty_instances, in die wir dieses Objekt einfügen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das folgende Ereignis tritt vor dem Commit auf - before_commit. Es gibt auch eine kleine Gefahr: Wenn wir für die gesamte Transaktion keinen einzigen Flush hatten, wird der Flush vor dem Commit aufgerufen. In meinem Fall wurde der Handler vor dem Commit vor dem Flush aufgerufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen können, hilft uns das, was wir im vorherigen Absatz getan haben, möglicherweise nicht und session.dirty_instances ist leer. Daher machen wir im Handler erneut Flush, sodass alle Handler vor dem Flush aufgerufen werden, und erhöhen die Version einfach um eins.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after_commit, after_soft_rollback - nach dem Commit bereinigen wir es einfach, damit es beim nächsten Mal keine Überschüsse gibt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie sehen also, diese install_handler-Methode installiert Handler für drei Ereignisse gleichzeitig. Als Klasse bestehen wir die Sitzung hier, da dies ein Ereignis seines Niveaus ist. </font></font><br><br><img src="https://habrastorage.org/webt/oi/w8/pk/oiw8pkhgdpx7shz7rqrovfmg6lk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitte schön. Ich werde Sie daran erinnern, was wir erreicht haben - Geschwindigkeit von 30-40 Sekunden für komplexe und große Teams. Überhaupt nicht, einige wurden in einer Sekunde abgeschlossen, andere in 200 Millisekunden, wie Sie auf RPS sehen können. Datenbankabfragen wurden zu Hunderten gezählt. </font></font><br><br><img src="https://habrastorage.org/webt/7p/wk/qo/7pwkqo4-g_hksl5m_cqoo3xph5y.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ergebnis ist ein ziemlich ausgewogenes System. Es gab jedoch eine Einschränkung. Einige Anfragen kommen von uns in Chargen, Emissionen. Das heißt, ungefähr 30 Anfragen kommen an und jede von ihnen ist so! (Sprecher zeigt Daumen)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir sie jeweils eine Sekunde lang verarbeiten, funktioniert die letzte Anforderung in der Warteschlange 30 Sekunden lang. Der erste, die zweiten beiden und so weiter. </font></font><br><br><img src="https://habrastorage.org/webt/ut/br/gl/utbrglrwurgv0uux2yk8eme4owg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deshalb müssen wir noch beschleunigen. Was machen wir? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich besteht die Alchemie aus zwei Teilen. Die erste ist eine Abstraktion über eine SQL-Datenbank namens SQLAlchemy Core. Das zweite ist ORM, die tatsächliche Zuordnung zwischen der relationalen Datenbank und der Objektdarstellung. Dementsprechend fällt der Alchemiekern ungefähr eins zu eins mit SQL zusammen - wenn Sie letzteres kennen, werden Sie keine Probleme mit dem Kern haben. Wenn Sie SQL nicht kennen - lernen Sie SQL. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Darüber hinaus stellt der Kern den geringsten Overhead dar. Es gibt praktisch kein Pumpen - Abfragen werden mit dem Abfragegenerator generiert und dann ausgeführt. Der Overhead über Dbapi ist minimal.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können Anforderungen beliebiger Komplexität und Art erstellen und sie für die Aufgabe optimieren. Das heißt, wenn es ORM im allgemeinen Fall egal ist, wie das Datenbankschema erstellt wird - es gibt eine Beschreibung der Tabellen, werden einige Abfragen generiert, ohne zu wissen, dass es in diesem Fall beispielsweise optimal ist, von hier, in einem anderen - von dort aus auszuwählen Wenden Sie den Filter an, und dort - noch einen, dann können wir hier Anfragen für die Aufgabe stellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Nachteil ist, dass wir wieder zur manuellen Synchronisation gekommen sind. Alle Ereignisse, Relais - all dies im Kern funktioniert nicht. Wir haben eine Auswahl getroffen, Objekte sind zu uns gekommen, wir haben etwas mit ihnen gemacht, dann aktualisiert, eingefügt ... Sie müssen die Version mit Ihren Händen erhöhen, die Konstanten selbst überprüfen. Core erlaubt es nicht, all dies bequem auf hohem Niveau zu erledigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun, wir leben nicht am ersten Tag.</font></font><br><br><img src="https://habrastorage.org/webt/qx/kk/bx/qxkkbxwleeqwvdukaghimiat7sw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein einfacher Anwendungsfall. Jeder Mapper enthält intern ein __table__ -Objekt, das im Core verwendet wird. Als nächstes sehen Sie - wir nehmen die übliche Auswahl, listen die Spalten auf, verbinden zwei Platten, geben links und rechts an, geben an, unter welchen Bedingungen wir sie verbinden. Außerdem geben wir diese generierte Anforderung in die Sitzung ein und sie gibt sie iterabel an uns zurück, wobei die tippartigen Objekte sowohl nach dem Namen der Spalte als auch nach der Nummer indiziert werden. Die Nummer entspricht der Reihenfolge, in der sie in der Auswahl aufgeführt sind. </font></font><br><br><img src="https://habrastorage.org/webt/r2/uq/f4/r2uqf4wn-wa-cvigivokusan6um.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist viel besser geworden. Die Leistung fiel im schlimmsten Fall auf 2-4 Sekunden, die komplexeste und längste Anforderung enthielt 14 Befehle und RPS 10-15. Es ist fest. </font></font><br><br><img src="https://habrastorage.org/webt/m9/8d/mw/m98dmwpmo0trjpw3vta7dylmryw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ich abschließend sagen möchte.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Produzieren Sie keine Entitäten, wo sie nicht benötigt werden - schrauben Sie Ihre nicht dort, wo sie fertig sind. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie SQLA ORM - dies ist ein sehr praktisches Tool, mit dem Sie Ereignisse auf hoher Ebene verfolgen, auf verschiedene Ereignisse im Zusammenhang mit der Datenbank reagieren und alle Ohren der Alchemie verbergen können. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn alles andere fehlschlägt, reicht die Leistung nicht aus - verwenden Sie SQLA Core. </font><font style="vertical-align: inherit;">Dies ist immer noch besser als die Verwendung von reinem SQL, da es eine relationale Abstraktion über die Datenbank bietet. </font><font style="vertical-align: inherit;">Entgeht automatisch Parametern, führt Ordner korrekt aus, es spielt keine Rolle, welche Datenbank sich darunter befindet - sie kann geändert werden und Core unterstützt verschiedene Dialekte.</font></font> Es ist sehr bequem. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das ist alles, was ich dir heute sagen wollte. </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/flA2lEl2a0M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430818/">https://habr.com/ru/post/de430818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430804/index.html">Tesla / Panasonic-Batterien sind die günstigsten Batterien für Elektrofahrzeuge auf dem Markt</a></li>
<li><a href="../de430806/index.html">Wir haben angefangen Englisch zu lernen - haben eine Anwendung geschrieben: EWM - Erfahrung bei der Erstellung eines Schulungsprojekts</a></li>
<li><a href="../de430808/index.html">Sprechertheorie: 16 Materialien zur Funktionsweise von Sprechern und Sprechern</a></li>
<li><a href="../de430810/index.html">Lastprüfung mit Heuschrecke. Teil 2</a></li>
<li><a href="../de430812/index.html">Was developer.android.com über RecyclerView spricht</a></li>
<li><a href="../de430820/index.html">Schwarzer Freitag 2018 - VDS in Moskau und Amsterdam</a></li>
<li><a href="../de430822/index.html">Informationssicherheit im Internet der Dinge: Wer ist das Ding und wer ist der Meister?</a></li>
<li><a href="../de430824/index.html">Suchen Sie in MS SQL Server 2005 nach beschädigtem Objekt anhand der beschädigten Seitenzahl</a></li>
<li><a href="../de430826/index.html">Wie man einen Entwicklungsmanager entwickelt</a></li>
<li><a href="../de430828/index.html">Erfahrung in der Verwendung von LCD-Displays auf Basis von MELT-Produkten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>