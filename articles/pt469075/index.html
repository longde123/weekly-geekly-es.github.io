<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôá üó∫Ô∏è üìá Grokay DLR üíß üë©üèæ‚Äçü§ù‚Äçüë®üèΩ ‚úäüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pref√°cio do tradutor 

 Isso √© mais uma recontagem gratuita, n√£o uma tradu√ß√£o. Inclu√≠ neste artigo apenas as partes do original que est√£o diretamente ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grokay DLR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469075/">  <i><b>Pref√°cio do tradutor</b></i> <i><br><br></i>  <i>Isso √© mais uma recontagem gratuita, n√£o uma tradu√ß√£o.</i>  <i>Inclu√≠ neste artigo apenas as partes do original que est√£o diretamente relacionadas aos mecanismos internos do DLR ou explicam id√©ias importantes.</i>  <i>As notas ser√£o colocadas entre colchetes.</i> <br><br>  Muitos desenvolvedores .NET ouviram falar sobre o Dynamic Language Runtime (DLR), mas n√£o sabem quase nada sobre isso.  Os desenvolvedores que escrevem em linguagens como C # ou Visual Basic evitam linguagens de digita√ß√£o din√¢micas por medo de problemas de escalabilidade historicamente relacionados.  Eles tamb√©m est√£o preocupados com o fato de que linguagens como Python ou Ruby n√£o executam verifica√ß√£o de tipo em tempo de compila√ß√£o, o que pode levar a erros de tempo de execu√ß√£o dif√≠ceis de encontrar e corrigir.  Esses s√£o medos bem fundamentados que podem explicar por que o DLR n√£o √© popular entre a maioria dos desenvolvedores .NET, mesmo dois anos ap√≥s o lan√ßamento oficial <i>[o artigo √© bastante antigo, mas nada mudou desde ent√£o]</i> .  Afinal, qualquer .NET <i>Runtime que</i> contenha as palavras <i>Dynamic</i> e <i>Language</i> em seu nome deve ser projetado estritamente para suportar idiomas como Python, certo? <br><br>  Desacelere.  Embora o DLR tenha sido realmente projetado para suportar a implementa√ß√£o Iron do Python e Ruby no .NET Framework, sua arquitetura fornece abstra√ß√µes muito mais profundas. <br><br><img src="https://habrastorage.org/webt/9p/co/0r/9pco0rjy7-sqeqb0hzgdngobjky.png"><br><a name="habracut"></a><br>  Sob o cap√¥, o DLR oferece um rico conjunto de interfaces para comunica√ß√£o entre processos [Comunica√ß√£o entre processos (IPC)].  Ao longo dos anos, os desenvolvedores viram muitas ferramentas da Microsoft para intera√ß√£o entre aplicativos: DDE, DCOM, ActiveX, .Net Remoting, WCF, OData.  Essa lista pode continuar por muito tempo.  Este √© um desfile quase infinito de acr√¥nimos, cada um dos quais representa uma tecnologia que promete que este ano ser√° ainda mais f√°cil trocar dados ou chamar c√≥digo remoto do que antes. <br><br><h2>  L√≠ngua das l√≠nguas </h2><br>  A primeira vez que ouvi Jim Hugunin falar sobre DLR, seu discurso me surpreendeu.  Jim criou uma implementa√ß√£o Python para a Java Virtual Machine (JVM) conhecida como Jython.  Pouco antes do show, ele se juntou √† Microsoft para criar o IronPython for .NET.  Com base em sua experi√™ncia, eu esperava que ele se concentrasse na linguagem, mas Jim falava quase o tempo todo sobre coisas abstrusas, como √°rvores de express√£o, envio din√¢mico de chamadas e mecanismos de cache de chamadas.  Jim descreveu um conjunto de servi√ßos de compila√ß√£o em tempo de execu√ß√£o que permitia a intera√ß√£o de dois idiomas, praticamente sem perda de desempenho. <br><br>  Durante esse discurso, escrevi um termo que surgiu na minha cabe√ßa quando ouvi Jim recontando a arquitetura DLR: a linguagem das l√≠nguas.  Quatro anos depois, esse apelido ainda caracteriza o DLR com muita precis√£o.  No entanto, tendo adquirido uma experi√™ncia de uso no mundo real, percebi que o DLR n√£o se refere apenas √† compatibilidade de idiomas.  Gra√ßas ao suporte de tipos din√¢micos em C # e Visual Basic, o DLR pode atuar como um gateway das nossas linguagens .NET favoritas para dados e c√≥digos em qualquer sistema remoto, independentemente do tipo de equipamento ou software usado por este √∫ltimo. <br><br><img src="https://habrastorage.org/webt/sp/l2/k3/spl2k3kcuitbvqg151r1wfx_zzc.png"><br><br>  Para entender a id√©ia por tr√°s do DLR, que √© um mecanismo integrado na linguagem IPC, vamos come√ßar com um exemplo que n√£o tem nada a ver com programa√ß√£o din√¢mica.  Imagine dois sistemas de computador: um chamado iniciador e o segundo - o sistema de destino.  O iniciador precisa executar a fun√ß√£o <b>foo</b> no sistema de destino, passando para l√° um determinado conjunto de par√¢metros e obter os resultados.  Ap√≥s a descoberta do sistema de destino, o iniciador deve fornecer todas as informa√ß√µes necess√°rias para a execu√ß√£o da fun√ß√£o em um formato que seja compreens√≠vel para ela.  No m√≠nimo, essas informa√ß√µes incluir√£o o nome da fun√ß√£o e os par√¢metros passados.  Ap√≥s descompactar a solicita√ß√£o e validar os par√¢metros, o sistema de destino executar√° a fun√ß√£o foo.  Depois disso, ele deve compactar o resultado, incluindo os erros que ocorreram durante a execu√ß√£o, e envi√°-los de volta ao iniciador.  Por fim, o iniciador deve ser capaz de descompactar os resultados e notificar a meta.  Esse padr√£o de solicita√ß√£o-resposta √© bastante comum e, em um n√≠vel alto, descreve a opera√ß√£o de quase qualquer mecanismo IPC. <br><br><h3>  Dynamicmetaobject </h3><br>  Para entender como o DLR implementa o padr√£o apresentado, vejamos uma das classes centrais do DLR: <b>DynamicMetaObject</b> .  Come√ßamos explorando tr√™s dos doze m√©todos principais desse tipo: <br><br><ol><li>  BindCreateInstance - cria ou ativa um objeto </li><li>  BindInvokeMember - chame o m√©todo encapsulado </li><li>  BindInvoke - execu√ß√£o de objeto (como uma fun√ß√£o) </li></ol><br>  Quando voc√™ precisa executar um m√©todo em um sistema remoto, primeiro precisa criar uma inst√¢ncia do tipo.  Obviamente, nem todos os sistemas s√£o orientados a objetos; portanto, o termo "inst√¢ncia" pode ser uma met√°fora.  De fato, o servi√ßo que precisamos pode ser implementado como um pool de objetos ou como um singleton, para que os termos "ativa√ß√£o" ou "conex√£o" possam ser usados ‚Äã‚Äãcom o mesmo direito que "inst√¢ncia". <br><br>  Outras estruturas seguem o mesmo padr√£o.  Por exemplo, o COM fornece uma fun√ß√£o <b>CoCreateInstance</b> para criar objetos.  No .NET Remoting, voc√™ pode usar o m√©todo <b>CreateInstance</b> da classe <b>System.Activator</b> .  O DLR <b>DynamicMetaObject</b> fornece um <b>BindCreateInstance</b> para fins semelhantes. <br><br>  Depois de usar o m√©todo <b>BindCreateInstance</b> , <i>algo</i> criado pode ser um tipo que exp√µe v√°rios m√©todos.  O <b>m√©todo de</b> metaobjeto <b>BindInvokeMember √©</b> usado para ligar uma opera√ß√£o que pode chamar uma fun√ß√£o.  Na figura acima, a string foo pode ser passada como um par√¢metro para indicar ao fich√°rio que um m√©todo com esse nome deve ser chamado.  Al√©m disso, est√£o inclu√≠das informa√ß√µes sobre o n√∫mero de argumentos, seus nomes e um sinalizador especial que indica ao fich√°rio se √© poss√≠vel ignorar mai√∫sculas e min√∫sculas ao procurar um elemento nomeado adequado.  Afinal, nem todos os idiomas diferenciam mai√∫sculas de min√∫sculas. <br><br>  Quando <i>algo</i> retornado de <b>BindCreateInstance</b> √© apenas uma fun√ß√£o (ou delegado), o m√©todo BindInvoke √© usado.  Para esclarecer a figura, vejamos o pequeno peda√ßo de c√≥digo din√¢mico a seguir: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> Write = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntWriter(Console.WriteLine); Write(<span class="hljs-number"><span class="hljs-number">5</span></span>); }</code> </pre> <br>  Este c√≥digo n√£o √© a melhor maneira de imprimir o n√∫mero 5 no console.  Um bom desenvolvedor nunca usar√° algo t√£o in√∫til.  No entanto, esse c√≥digo ilustra o uso de uma vari√°vel din√¢mica cujo valor √© um delegado que pode ser usado como uma fun√ß√£o.  Se o tipo de delegado implementar a interface <b>IDynamicMetaObjectProvider</b> , o m√©todo <b>BindInvoke</b> de <b>DynamicMetaObject</b> ser√° usado para vincular a opera√ß√£o ao trabalho real.  Isso ocorre porque o compilador reconhece que o objeto de <b>grava√ß√£o</b> din√¢mico √© usado <i>sintaticamente</i> como uma fun√ß√£o.  Agora considere outro trecho de c√≥digo para entender quando o compilador ir√° gerar <b>BindInvokeMember</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Writer</span></span> : <span class="hljs-title"><span class="hljs-title">IDynamicMetaObjectProvider</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(n); } <span class="hljs-comment"><span class="hljs-comment">//    } void Main() { dynamic Writer = new Writer(); Writer.Write(7); }</span></span></code> </pre><br>  Omitirei a implementa√ß√£o da interface neste pequeno exemplo, porque ser√° necess√°rio muito c√≥digo para demonstrar isso corretamente.  Neste exemplo resumido, implementamos um meta-objeto din√¢mico com apenas algumas linhas de c√≥digo. <br><br>  Uma coisa importante a entender √© que o compilador reconhece que <b>Writer.Write (7)</b> √© uma opera√ß√£o de acesso ao elemento.  O que geralmente chamamos de "operador de ponto" em C # √© formalmente chamado de "operador de acesso de membro de tipo".  O c√≥digo DLR gerado pelo compilador nesse caso acabar√° chamando <b>BindInvokeMember</b> , no qual passar√° a seq√º√™ncia de grava√ß√£o e o n√∫mero do par√¢metro 7 para a opera√ß√£o que √© capaz de fazer a chamada.  Em resumo, <b>BindInvoke √©</b> usado para chamar um objeto din√¢mico como uma fun√ß√£o, enquanto <b>BindInvokeMember √©</b> usado para chamar um m√©todo como um elemento de um objeto din√¢mico. <br><br><h3>  Acesse propriedades atrav√©s do DynamicMetaObject </h3><br>  Pode ser visto nos exemplos acima que o compilador usa a sintaxe da linguagem para determinar quais opera√ß√µes de liga√ß√£o do DLR devem ser executadas.  Se voc√™ usar o Visual Basic para trabalhar com objetos din√¢micos, sua sem√¢ntica ser√° usada.  O operador de acesso (ponto), √© claro, √© necess√°rio n√£o apenas para acessar m√©todos.  Voc√™ pode us√°-lo para acessar propriedades.  O metaobjeto DLR fornece tr√™s m√©todos para acessar as propriedades de objetos din√¢micos: <br><br><ol><li>  BindGetMember - obt√©m o valor da propriedade </li><li>  BindSetMember - define o valor da propriedade </li><li>  BindDeleteMember - excluir um item </li></ol><br>  O objetivo de <b>BindGetMember</b> e <b>BindSetMember</b> deve ser √≥bvio.  Especialmente agora que voc√™ sabe como eles se relacionam com o modo como o .NET funciona com propriedades.  Quando o compilador calcula as propriedades <i>get</i> ("read") de um objeto din√¢mico, ele usa uma chamada para <b>BindGetMember</b> .  Quando o compilador calcula o conjunto ("registro"), ele usa <b>BindSetMember</b> . <br><br><h3>  Representa√ß√£o de um objeto como uma matriz </h3><br>  Algumas classes s√£o cont√™ineres para inst√¢ncias de outros tipos.  O DLR sabe como lidar com esses casos.  Cada m√©todo de meta-objeto "orientado a matriz" possui um postfix de "√çndice": <br><br><ol><li>  BindGetIndex - obt√©m valor por √≠ndice </li><li>  BindSetIndex - defina o valor por √≠ndice </li><li>  BindDeleteIndex - excluir um valor por √≠ndice </li></ol><br>  Para entender como <b>BindGetIndex</b> e <b>BindSetIndex s√£o usados</b> , imagine uma <b>classe de</b> wrapper <b>JavaBridge</b> que possa carregar arquivos com classes Java e permita que voc√™ os use a partir do c√≥digo .NET sem dificuldades.  Esse wrapper pode ser usado para carregar a classe Java do <b>Cliente</b> , que cont√©m algum c√≥digo ORM.  O meta-objeto DLR pode ser usado para chamar esse c√≥digo ORM do .NET no estilo C # cl√°ssico.  Abaixo est√° um c√≥digo de exemplo que mostra como o <b>JavaBridge</b> pode funcionar na pr√°tica: <br><br><pre> <code class="cs hljs">JavaBridge java = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JavaBridge(); <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> customers = java.Load(<span class="hljs-string"><span class="hljs-string">"Customer.class"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> Jason = customers[<span class="hljs-string"><span class="hljs-string">"Bock"</span></span>]; Jason.Balance = <span class="hljs-number"><span class="hljs-number">17.34</span></span>; customers[<span class="hljs-string"><span class="hljs-string">"Wagner"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Customer(<span class="hljs-string"><span class="hljs-string">"Bill"</span></span>);</code> </pre> <br>  Como a terceira e a quinta linhas usam o operador de acesso pelo √≠ndice ([]), o compilador reconhece isso e usa os <b>m√©todos BindGetIndex</b> e <b>BindSetIndex</b> ao trabalhar com o meta objeto retornado do <b>JavaBridge</b> .  Entende-se que a implementa√ß√£o desses m√©todos no objeto retornado solicitar√° a execu√ß√£o do m√©todo da JVM por meio da Java Remote Method Invocation (RMI).  Nesse cen√°rio, o DLR atua como uma ponte entre C # e outro idioma com digita√ß√£o est√°tica.  Espero que isso esclare√ßa por que chamei o DLR de "linguagem das l√≠nguas". <br><br>  O m√©todo <b>BindDeleteMember</b> , assim como <b>BindDeleteIndex</b> , n√£o se destina ao uso de idiomas com digita√ß√£o est√°tica como C # e Visual Basic, pois eles n√£o oferecem suporte ao pr√≥prio conceito.  No entanto, voc√™ pode concordar em considerar "remover" alguma opera√ß√£o expressa pelos meios do idioma, se isso for √∫til para voc√™.  Por exemplo, voc√™ pode implementar BindDeleteMember como anulando um elemento pelo √≠ndice. <br><br><h3>  Transforma√ß√µes e operadores </h3><br>  O √∫ltimo grupo de m√©todos de metaobjeto DLR trata de lidar com operadores e transforma√ß√µes. <br><br><ol><li>  BindConvert - converte um objeto para outro tipo </li><li>  BindBinaryOperation - usando um operador bin√°rio em dois operandos </li><li>  BindUnaryOperation - usando um operador un√°rio em um operando </li></ol><br>  O m√©todo <b>BindConvert √©</b> usado quando o compilador percebe que o objeto precisa ser convertido para outro tipo conhecido.  A convers√£o impl√≠cita ocorre quando o resultado de uma chamada din√¢mica √© atribu√≠do a uma vari√°vel com um tipo est√°tico.  Por exemplo, no exemplo C # a seguir, atribuir a vari√°vel <b>y</b> leva a uma chamada impl√≠cita para <b>BindConvert</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> x = <span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = x + <span class="hljs-number"><span class="hljs-number">11</span></span>;</code> </pre> <br>  Os <b>m√©todos BindBinaryOperation</b> e <b>BindUnaryOperation</b> s√£o sempre usados ‚Äã‚Äãquando opera√ß√µes aritm√©ticas ("+") ou incrementos ("++") s√£o encontradas.  No exemplo acima, adicionar a vari√°vel din√¢mica <b>x</b> √† constante 11 chamar√° o m√©todo <b>BindBinaryOperation</b> .  Lembre-se deste pequeno exemplo, n√≥s o usamos na pr√≥xima se√ß√£o para adicionar outra classe DLR chave chamada CallSite. <br><br><h2>  Envio din√¢mico com CallSite </h2><br>  Se sua introdu√ß√£o ao DLR n√£o fosse al√©m do uso da palavra-chave <b>din√¢mica</b> , voc√™ provavelmente nunca saberia sobre a exist√™ncia do CallSite no .NET Framework.  Esse tipo modesto, formalmente conhecido como <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> , reside no <b>espa√ßo para nome System.Runtime.CompilerServices</b> .  Esta √© a "fonte de energia" da metaprograma√ß√£o: √© preenchida com todos os tipos de m√©todos de otimiza√ß√£o que tornam o c√≥digo .NET din√¢mico r√°pido e eficiente.  Mencionarei os aspectos de desempenho do <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> no final do artigo. <br><br>  A maior parte do que o CallSite faz no c√≥digo .NET din√¢mico envolve a gera√ß√£o e compila√ß√£o de c√≥digo em tempo de execu√ß√£o.  √â importante observar que a <b>classe CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> est√° no espa√ßo para nome que cont√©m as palavras " <b>Runtime</b> " e " <b>CompilerServices</b> ".  Se o DLR √© uma "linguagem de idiomas", o <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> √© uma de suas constru√ß√µes gramaticais mais importantes.  Vejamos nosso exemplo da se√ß√£o anterior novamente para conhecer o CallSite e como o compilador os incorpora em seu c√≥digo. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> x = <span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = x + <span class="hljs-number"><span class="hljs-number">11</span></span>;</code> </pre> <br>  Como voc√™ j√° sabe, os m√©todos <b>BindBinaryOperaion</b> e <b>BindConvert</b> ser√£o chamados para executar esse c√≥digo.  Em vez de mostrar uma lista longa do c√≥digo MSIL desmontado gerado pelo compilador, fiz um diagrama: <br><br><img src="https://habrastorage.org/webt/c8/pw/0o/c8pw0osalzvckhg3w6b3eddlik4.png"><br><br>  Lembre-se de que o compilador usa a sintaxe da linguagem para determinar quais m√©todos de tipo din√¢mico ser√£o executados.  Em nosso exemplo, duas opera√ß√µes s√£o executadas: adicionando a vari√°vel <b>x</b> ao n√∫mero ( <b>Site2</b> ) e convertendo o resultado em int ( <b>Site1</b> ).  Cada uma dessas a√ß√µes se transforma em CallSite, que √© armazenado em um cont√™iner especial.  Como voc√™ pode ver no diagrama, os CallSites s√£o criados na ordem inversa, mas s√£o chamados da maneira correta. <br><br>  Na figura, voc√™ pode ver que os m√©todos de metaobjeto <b>BindConvert</b> e <b>BindBinaryOperation</b> s√£o chamados imediatamente antes das opera√ß√µes "create CallSite1" e "create CallSite2".  No entanto, opera√ß√µes vinculadas s√£o executadas apenas no final.  Espero que a visualiza√ß√£o o ajude a entender que m√©todos de liga√ß√£o e cham√°-los s√£o opera√ß√µes diferentes no contexto do DLR.  Al√©m disso, a liga√ß√£o ocorre apenas uma vez, enquanto a chamada ocorre quantas vezes for necess√°ria, reutilizando os CallSites j√° inicializados para otimizar o desempenho. <br><br><h2>  Siga o caminho mais f√°cil </h2><br>  No cora√ß√£o do DLR, as √°rvores de express√£o s√£o usadas para gerar fun√ß√µes ligadas aos doze m√©todos de liga√ß√£o apresentados acima.  Muitos desenvolvedores s√£o constantemente confrontados com √°rvores de express√£o usando o LINQ, mas apenas alguns t√™m experi√™ncia suficiente para implementar completamente o contrato <b>IDynamicMetaObjectProvider</b> .  Felizmente, o .NET Framework cont√©m uma classe base chamada <b>DynamicObject</b> que cuida da maior parte do trabalho. <br><br>  Para criar sua pr√≥pria classe din√¢mica, tudo o que voc√™ precisa fazer √© herdar do <b>DynamicObject</b> e implementar os doze m√©todos a seguir: <br><br><ol><li>  TryCreateInstance </li><li>  TryInvokeMember </li><li>  Tryinvoke </li><li>  TryGetMember </li><li>  TrySetMember </li><li>  TryDeleteMember </li><li>  TryGetIndex </li><li>  TrySetIndex </li><li>  TryDeleteIndex </li><li>  Tryconvert </li><li>  TryBinaryOperation </li><li>  TryUnaryOperation </li></ol><br>  Os nomes dos m√©todos parecem familiares?  Voc√™ deve, porque acabou de estudar os elementos da classe Abstract <b>DynamicMetaObject</b> , que incluem m√©todos como <b>BindCreateInstance</b> e <b>BindInvoke</b> .  A classe <b>DynamicMetaObject</b> fornece uma implementa√ß√£o para <b>IDynamicMetaObjectProvider</b> , que retorna um <b>DynamicMetaObject</b> de seu √∫nico m√©todo.  As opera√ß√µes associadas √† implementa√ß√£o base do objeto meta simplesmente delegam suas chamadas aos m√©todos, come√ßando com "Try" na inst√¢ncia <b>DynamicObject</b> .  Tudo o que voc√™ precisa fazer √© sobrecarregar m√©todos como <b>TryGetMember</b> e <b>TrySetMember</b> em uma classe herdada do <b>DynamicObject</b> , enquanto o objeto meta assume todo o trabalho sujo com √°rvores de express√£o. <br><br><h2>  Armazenamento em cache </h2><br>  <i>[Voc√™ pode ler mais sobre armazenamento em cache no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior sobre DLR</a> ]</i> <br><br>  A maior preocupa√ß√£o ao trabalhar com linguagens din√¢micas para desenvolvedores √© o desempenho.  O DLR toma medidas extraordin√°rias para dissipar essas experi√™ncias.  <b>Mencionei</b> brevemente o fato de que o <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> reside em um espa√ßo para nome chamado <b>System.Runtime.CompilerServices</b> .  No mesmo espa√ßo para nome, existem v√°rias outras classes que fornecem armazenamento em cache multin√≠vel.  Usando esses tipos, o DLR implementa tr√™s n√≠veis principais de armazenamento em cache para acelerar opera√ß√µes din√¢micas: <br><br><ol><li>  Cache global </li><li>  Cache local </li><li>  Cache delegado polim√≥rfico </li></ol><br>  O cache √© usado para evitar desperd√≠cio desnecess√°rio de recursos para a cria√ß√£o de liga√ß√µes para um CallSite espec√≠fico.  Se dois objetos do tipo <i>string forem</i> passados ‚Äã‚Äãpara um m√©todo din√¢mico que retorna <i>int</i> , o cache global ou local salvar√° a liga√ß√£o resultante.  Isso simplificar√° bastante as chamadas subseq√ºentes. <br><br>  O cache de delegado, que est√° dentro do pr√≥prio CallSite, √© chamado polim√≥rfico, porque esses delegados podem assumir diferentes formas, dependendo de qual c√≥digo din√¢mico √© executado e de quais regras de outros caches foram usadas para ger√°-los.  O cache delegado tamb√©m √© chamado de cache embutido.  O motivo para usar esse termo √© que as express√µes geradas pelo DLR e seus ligantes s√£o convertidas em c√≥digo MSIL que passa pela compila√ß√£o JIT, como qualquer outro c√≥digo .NET.  A compila√ß√£o no tempo de execu√ß√£o ocorre simultaneamente com a execu√ß√£o "normal" do seu programa.  √â claro que a transforma√ß√£o de c√≥digos din√¢micos din√¢micos em c√≥digo MSIL compilado durante a execu√ß√£o do programa pode afetar bastante o desempenho do aplicativo, portanto, os mecanismos de cache s√£o vitais. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469075/">https://habr.com/ru/post/pt469075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469055/index.html">Pr√°tica Zen em espa√ßo aberto</a></li>
<li><a href="../pt469059/index.html">O que h√° de novo no ML.NET e no Model Builder</a></li>
<li><a href="../pt469061/index.html">Vers√£o Rust 1.38.0: compila√ß√£o em pipeline, # [descontinuado] para macros e std :: any :: type_name</a></li>
<li><a href="../pt469071/index.html">Intelig√™ncia Artificial Microsoft domina mahjong</a></li>
<li><a href="../pt469073/index.html">Derivada discreta ou resumo de como somar s√©ries</a></li>
<li><a href="../pt469077/index.html">Novo curso de Python da Microsoft [em ingl√™s]</a></li>
<li><a href="../pt469079/index.html">Python no c√≥digo do Visual Studio: atualiza√ß√£o de extens√£o de setembro</a></li>
<li><a href="../pt469085/index.html">Retiramos o software do microcontrolador protegido por senha Renesas M16C</a></li>
<li><a href="../pt469087/index.html">MVCC no PostgreSQL-2. Garfos, arquivos, p√°ginas</a></li>
<li><a href="../pt469093/index.html">Compara√ß√£o de bibliotecas menos populares e n√£o muito CLI: cliff, plac, plumbum e outras (parte 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>