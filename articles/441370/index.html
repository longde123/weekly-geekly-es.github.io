<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>げ   Protecci贸n sin miedo. Seguridad de roscas en 贸xido  し ぞ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta es la segunda parte de la serie de art铆culos Fearless Protection. En el primero hablamos de seguridad de memoria 

 Las aplicaciones modernas son...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protecci贸n sin miedo. Seguridad de roscas en 贸xido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441370/">  <font color="gray"><i>Esta es la segunda parte de la serie de art铆culos Fearless Protection.</i></font>  <font color="gray"><i>En el primero hablamos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguridad de memoria</a></i></font> <br><br>  Las aplicaciones modernas son multiproceso: en lugar de ejecutar tareas secuencialmente, el programa utiliza subprocesos para realizar simult谩neamente varias tareas.  Todos observamos <i>trabajo simult谩neo</i> y <i>concurrencia</i> todos los d铆as: <br><br><ul><li>  Varios sitios web son atendidos por varios usuarios al mismo tiempo. <br></li><li> La interfaz de usuario realiza un trabajo en segundo plano que no molesta al usuario (imagine que cada vez que escribe un car谩cter, la aplicaci贸n se congela para verificar la ortograf铆a). <br></li><li>  Una computadora puede ejecutar m煤ltiples aplicaciones al mismo tiempo. </li></ul><br>  Las transmisiones paralelas aceleran el trabajo, pero presentan un conjunto de problemas de sincronizaci贸n, a saber, puntos muertos y condiciones de carrera.  Desde el punto de vista de la seguridad, 驴por qu茅 nos importa la seguridad de los hilos?  Porque la seguridad de la memoria y los subprocesos tiene el mismo problema principal: el uso inapropiado de los recursos.  Los ataques aqu铆 tienen los mismos efectos que los ataques de memoria, incluida la escalada de privilegios, la ejecuci贸n de c贸digo arbitrario (ACE) y eludir las comprobaciones de seguridad. <br><a name="habracut"></a><br>  Los errores de concurrencia, como los errores de implementaci贸n, est谩n estrechamente relacionados con la correcci贸n del programa.  Si bien las vulnerabilidades de la memoria son casi siempre peligrosas, los errores de implementaci贸n / l贸gica no siempre indican un problema de seguridad si no ocurren en la parte del c贸digo relacionada con el cumplimiento de los contratos de seguridad (por ejemplo, permiso para eludir las verificaciones de seguridad).  Pero los errores de concurrencia tienen una peculiaridad.  Si los problemas de seguridad debidos a errores l贸gicos a menudo aparecen junto al c贸digo correspondiente, los errores de concurrencia a menudo ocurren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en otras funciones, y no en la que se cometi贸 directamente</a> , lo que dificulta su seguimiento y eliminaci贸n.  Otra dificultad es una cierta superposici贸n entre el procesamiento inadecuado de la memoria y los errores de concurrencia, que vemos en las carreras de datos. <br><br>  Los lenguajes de programaci贸n han desarrollado diversas estrategias de concurrencia para ayudar a los desarrolladores a gestionar el rendimiento y los problemas de seguridad de las aplicaciones de subprocesos m煤ltiples. <br><br><h1>  Problemas de concurrencia </h1><br>  En general, se acepta que la programaci贸n paralela es m谩s dif铆cil de lo habitual: nuestro cerebro est谩 mejor adaptado al razonamiento secuencial.  El c贸digo paralelo puede tener interacciones inesperadas y no deseadas entre subprocesos, incluidos puntos muertos, contenciones y carreras de datos. <br><br>  <i>Un punto muerto se</i> produce cuando varios subprocesos esperan que otros realicen ciertas acciones para continuar trabajando.  Aunque este comportamiento no deseado puede causar un ataque de denegaci贸n de servicio, no causar谩 vulnerabilidades como ACE. <br><br>  <i>Una condici贸n de carrera</i> es una situaci贸n en la que el tiempo o el orden de las tareas pueden afectar la correcci贸n de un programa.  La carrera de datos ocurre cuando varias secuencias intentan acceder simult谩neamente a la misma ubicaci贸n de memoria con al menos un intento de escritura.  Sucede que una condici贸n de carrera y una carrera de datos se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">producen independientemente</a> una de la otra.  Pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las carreras de datos son siempre peligrosas</a> . <br><br><h3>  Posibles consecuencias de errores de concurrencia </h3><br><ol><li>  Punto muerto <br></li><li>  P茅rdida de informaci贸n: otro hilo sobrescribe la informaci贸n <br></li><li>  P茅rdida de integridad: la informaci贸n de varias corrientes est谩 entrelazada <br></li><li>  P茅rdida de viabilidad: problemas de rendimiento debido al acceso desigual a los recursos compartidos. </li></ol><br>  El tipo de ataque de concurrencia m谩s famoso se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TOCTOU</a> (tiempo de verificaci贸n hasta tiempo de uso): de hecho, el estado de una carrera es entre las condiciones de verificaci贸n (por ejemplo, credenciales de seguridad) y el uso de los resultados.  Un ataque TOCTOU resulta en una p茅rdida de integridad. <br><br>  Los bloqueos mutuos y la p茅rdida de capacidad de supervivencia se consideran problemas de rendimiento, no problemas de seguridad, mientras que la p茅rdida de informaci贸n y la integridad probablemente est茅n relacionadas con la seguridad.  Un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art铆culo de Red Balloon Security</a> analiza algunas de las posibles haza帽as.  Un ejemplo es una corrupci贸n de puntero seguida de escalada de privilegios o ejecuci贸n remota de c贸digo.  En el exploit, una funci贸n que carga la biblioteca compartida ELF (formato ejecutable y enlazable) inicia correctamente un sem谩foro solo en la primera llamada, y luego limita incorrectamente el n煤mero de subprocesos, lo que provoca da帽os en la memoria del n煤cleo.  Este ataque es un ejemplo de p茅rdida de informaci贸n. <br><br>  La parte m谩s dif铆cil de la programaci贸n concurrente es probar y depurar, porque los errores de concurrencia son dif铆ciles de reproducir.  Tiempo de eventos, decisiones del sistema operativo, tr谩fico de red y otros factores ... todo esto cambia el comportamiento del programa en cada inicio. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/aa1/702/1b2/aa17021b2f9cb3eb726ea37995ed4e2e.png"></a> </div><br>  <i><font color="gray">A veces es realmente m谩s f谩cil eliminar todo el programa que buscar un error.</font></i>  <i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Heisenbugs</a></font></i> <br><br>  El comportamiento no solo cambia cada vez que se inicia, sino que incluso insertar declaraciones de salida o depuraci贸n puede cambiar el comportamiento, lo que resulta en "errores de Heisenberg" (errores no deterministas, dif铆ciles de reproducir, t铆picos de la programaci贸n paralela) que surgen y desaparecen misteriosamente. <br><br>  La programaci贸n paralela es dif铆cil.  Es dif铆cil predecir c贸mo interactuar谩 el c贸digo paralelo con otro c贸digo paralelo.  Cuando aparecen errores, son dif铆ciles de encontrar y corregir.  En lugar de confiar en los probadores, veamos formas de desarrollar programas y el uso de lenguajes que faciliten la escritura de c贸digo paralelo. <br><br>  Primero, formulamos el concepto de "seguridad del hilo": <br><br><blockquote>  "Un tipo de datos o m茅todo est谩tico se considera seguro para subprocesos si se comporta correctamente cuando se llama desde varios subprocesos, independientemente de c贸mo se ejecutan estos subprocesos, y no requiere coordinaci贸n adicional del c贸digo de llamada".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MIT</a> </blockquote><br><h1>  C贸mo funcionan los lenguajes de programaci贸n con paralelismo </h1><br>  En idiomas sin seguridad de subprocesos est谩ticos, los programadores tienen que monitorear constantemente la memoria que se comparte con otro subproceso y que puede cambiar en cualquier momento.  En la programaci贸n secuencial, se nos ense帽a a evitar las variables globales si otra parte del c贸digo las cambia silenciosamente.  Es imposible exigir a los programadores que garanticen un cambio seguro en los datos compartidos, as铆 como la gesti贸n manual de la memoria. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/3e3/5d2/e3e3e35d2775715a1f337d7c58aad7f7.gif"></div><br>  <i><font color="gray">"隆Vigilancia constante!"</font></i> <br><br>  Por lo general, los lenguajes de programaci贸n se limitan a dos enfoques: <br><br><ol><li>  Limitaci贸n de la mutabilidad o restricci贸n del acceso compartido. <br></li><li>  Seguridad manual del hilo (p. Ej., Cerraduras, sem谩foros) </li></ol><br>  Los idiomas con restricci贸n de subprocesos ponen un l铆mite de 1 subproceso para variables mutables o requieren que todas las variables comunes sean inmutables.  Ambos enfoques abordan el problema b谩sico de la carrera de datos (datos compartidos incorrectamente modificables), pero las restricciones son demasiado severas.  Para resolver el problema, los lenguajes hicieron primitivas de sincronizaci贸n de bajo nivel, como mutexes.  Se pueden usar para construir estructuras de datos seguras para subprocesos. <br><br><h3>  Python y bloqueo global por int茅rprete </h3><br>  La implementaci贸n de referencia en Python y Cpython tiene un tipo de mutex llamado Global Interpreter Lock (GIL), que bloquea todos los otros hilos cuando un hilo accede a un objeto.  Python multiproceso es conocido por su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ineficiencia</a> debido a la latencia GIL.  Por lo tanto, la mayor铆a de los programas concurrentes de Python funcionan en varios procesos para que cada uno tenga su propio GIL. <br><br><h3>  Java y excepciones de tiempo de ejecuci贸n </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java</a> admite programaci贸n concurrente a trav茅s de un modelo de memoria compartida.  Cada hilo tiene su propia ruta de ejecuci贸n, pero puede acceder a cualquier objeto en el programa: el programador debe sincronizar el acceso entre los hilos usando las primitivas Java incorporadas. <br><br>  Aunque Java tiene bloques de construcci贸n para crear programas seguros para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subprocesos</a> , <b>el</b> compilador <b>no garantiza la</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguridad de subprocesos</a> (a diferencia de la seguridad de la memoria).  Si se produce un acceso no sincronizado a la memoria (es decir, la carrera de datos), Java lanzar谩 una excepci贸n en tiempo de ejecuci贸n, pero los programadores deben usar correctamente las primitivas de concurrencia. <br><br><h3>  C ++ y el cerebro del programador </h3><br>  Si bien Python evita las condiciones de carrera con GIL y Java lanza excepciones en tiempo de ejecuci贸n, C ++ espera que el programador sincronice manualmente el acceso a la memoria.  Antes de C ++ 11, la biblioteca est谩ndar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no inclu铆a primitivas de concurrencia</a> . <br><br>  La mayor铆a de los idiomas proporcionan herramientas para escribir c贸digo seguro para subprocesos, y existen m茅todos especiales para detectar datos de carrera y estado de carrera;  pero no ofrece ninguna garant铆a de seguridad de subprocesos y no protege contra la carrera de datos. <br><br><h1>  驴C贸mo resolver el problema del 贸xido? </h1><br>  Rust adopta un enfoque multifac茅tico para eliminar las condiciones de carrera, utilizando reglas de propiedad y tipos seguros para proteger completamente contra las condiciones de carrera en tiempo de compilaci贸n. <br><br>  En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer art铆culo,</a> presentamos el concepto de propiedad, este es uno de los conceptos b谩sicos de Rust.  Cada variable tiene un propietario 煤nico, y la propiedad puede ser transferida o prestada.  Si otro hilo quiere cambiar el recurso, entonces transferimos la propiedad moviendo la variable a un nuevo hilo. <br><br>  Mover arroja una excepci贸n: varios subprocesos pueden escribir en la misma memoria, pero nunca al mismo tiempo.  Dado que el propietario siempre est谩 solo, 驴qu茅 sucede si otro hilo toma prestada una variable? <br><br>  En Rust, tienes un pr茅stamo mutable o varios inmutables.  No es posible introducir simult谩neamente pr茅stamos mutables e inmutables (o varios pr茅stamos mutables).  En la seguridad de la memoria, es importante que los recursos se liberen correctamente, y en la seguridad de los subprocesos es importante que solo un subproceso tenga derecho a cambiar una variable en un momento dado.  Adem谩s, en tal situaci贸n, ning煤n otro flujo se referir谩 a pr茅stamos obsoletos: es posible registrarlos o compartirlos, pero no ambos. <br><br>  El concepto de propiedad est谩 dise帽ado para abordar las vulnerabilidades de la memoria.  Result贸 que tambi茅n evita la carrera de datos. <br><br>  Aunque muchos idiomas tienen m茅todos de seguridad de la memoria (como el conteo de enlaces y la recolecci贸n de basura), por lo general dependen de la sincronizaci贸n manual o las prohibiciones del uso compartido simult谩neo para evitar la carrera de datos.  El enfoque de Rust aborda ambos tipos de seguridad, tratando de resolver el problema principal de determinar el uso aceptable de los recursos y garantizar esta validez en el momento de la compilaci贸n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/972/88b/4d9/97288b4d9796a35d8cce9400c2dbfd73.png"></div><br><br><h3>  Pero espera!  Eso no es todo! </h3><br>  Las reglas de propiedad evitan que m煤ltiples hilos escriban datos en la misma ubicaci贸n de memoria y proh铆ben el intercambio simult谩neo de datos entre hilos y mutabilidad, pero esto no necesariamente proporciona estructuras de datos seguras para hilos.  Cada estructura de datos en Rust es segura para subprocesos o no.  Esto se pasa al compilador utilizando un sistema de tipos. <br><br><blockquote>  "Un programa bien escrito no puede cometer un error".  - Robin Milner, 1978 </blockquote><br>  En lenguajes de programaci贸n, los sistemas de tipos describen un comportamiento aceptable.  En otras palabras, un programa bien escrito est谩 bien definido.  Mientras nuestros tipos sean lo suficientemente expresivos como para capturar el significado deseado, un programa bien tipado se comportar谩 seg煤n lo previsto. <br><br>  Rust es un lenguaje de tipo seguro, aqu铆 el compilador verifica la consistencia de todos los tipos.  Por ejemplo, el siguiente c贸digo no se compila: <br><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-string"><span class="hljs-string">"I am a string"</span></span>; x = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br><pre> <code class="rust hljs"> error[E0308]: mismatched types --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span> | x = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-comment"><span class="hljs-comment">// | ^ expected &amp;str, found integral variable | = note: expected type `&amp;str` found type `{integer}`</span></span></code> </pre> <br>  Todas las variables en Rust son de tipo a menudo impl铆cito.  Tambi茅n podemos definir nuevos tipos y describir las capacidades de cada tipo utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sistema de rasgos</a> .  Los rasgos proporcionan una abstracci贸n de la interfaz.  Dos rasgos incorporados importantes son <code>Send</code> y <code>Sync</code> , que el compilador proporciona de manera predeterminada para cada tipo: <br><br><ul><li>  <code>Send</code> indica que la estructura se puede transferir de forma segura entre subprocesos (requerido para transferir la propiedad) <br></li><li>  <code>Sync</code> indica que los hilos pueden usar la estructura de forma segura. </li></ul><br>  El siguiente ejemplo es una versi贸n simplificada del <a href="">c贸digo de la biblioteca est谩ndar</a> que genera hilos: <br><br><pre> <code class="rust hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawn</span></span></span></span>&lt;Closure: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>() + <span class="hljs-built_in"><span class="hljs-built_in">Send</span></span>&gt;(closure: Closure){ ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = std::rc::Rc::new(<span class="hljs-number"><span class="hljs-number">6</span></span>); spawn(|| { x; });</code> </pre> <br>  La funci贸n <code>spawn</code> toma un solo argumento, <code>closure</code> y requiere un tipo para este 煤ltimo que implemente los rasgos <code>Send</code> y <code>Fn</code> .  Al intentar crear una secuencia y pasar el valor de <code>closure</code> con la variable <code>x</code> compilador arroja un error: <br><br><pre>  error [E0277]: `std :: rc :: Rc &lt;i32&gt;` no se puede enviar entre hilos de forma segura
      -&gt; src / main.rs: 8: 1
       El |
     8 |  engendrar (mover || {x;});
       El |  ^^^^^ `std :: rc :: Rc &lt;i32&gt;` no se puede enviar entre hilos de forma segura
       El |
       = ayuda: dentro de `[cierre@src/main.rs: 8: 7: 8:21 x: std :: rc :: Rc &lt;i32&gt;]`, el rasgo `std :: marker :: Send` no est谩 implementado para `std :: rc :: Rc &lt;i32&gt;`
       = nota: requerido porque aparece dentro del tipo `[cierre@src/main.rs: 8: 7: 8:21 x: std :: rc :: Rc &lt;i32&gt;]`
     nota: requerido por `spawn` </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los rasgos de</a> <code>Send</code> y <code>Sync</code> permiten que el sistema de tipo Rust entienda qu茅 datos se pueden compartir.  Al incluir esta informaci贸n en el sistema de tipos, la seguridad de los hilos se convierte en parte de la seguridad de tipos.  En lugar de documentaci贸n, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguridad del subproceso se implementa mediante la ley del compilador</a> . <br><br>  Los programadores ven claramente objetos comunes entre subprocesos, y el compilador garantiza la fiabilidad de esta instalaci贸n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35c/af5/27e/35caf527e18989b41893e6fd37239dab.gif"></div><br><br>  Aunque las herramientas de programaci贸n paralela est谩n disponibles en muchos idiomas, evitar las condiciones de carrera no es f谩cil.  Si requiere que los programadores alternen complejas instrucciones e interact煤en entre hilos, entonces los errores son inevitables.  Aunque las infracciones de seguridad de la memoria y los hilos conducen a consecuencias similares, las protecciones de memoria tradicionales, como el conteo de enlaces y la recolecci贸n de basura, no impiden las condiciones de la carrera.  Adem谩s de la garant铆a est谩tica de seguridad de la memoria, el modelo de propiedad Rust tambi茅n evita cambios de datos inseguros y el intercambio incorrecto de objetos entre subprocesos, mientras que el sistema de tipos proporciona seguridad de subprocesos en tiempo de compilaci贸n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92d/429/fb9/92d429fb9c3812ddfdf115d71a3695ed.jpg"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441370/">https://habr.com/ru/post/441370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441360/index.html">OpenShift - manualidades de sombrero rojo</a></li>
<li><a href="../441362/index.html">Gu铆a del usuario de Kibana. Visualizaci贸n. Parte 3</a></li>
<li><a href="../441364/index.html">Programa de conferencias Lua en Mosc煤 2019</a></li>
<li><a href="../441366/index.html">驴Necesita la tienda Stylish Crossell: la experiencia de Retail Rocket en an谩lisis de im谩genes para formular recomendaciones?</a></li>
<li><a href="../441368/index.html">驴C贸mo se ve la luna invisible de Neptuno?</a></li>
<li><a href="../441372/index.html">[Viernes] C贸mo fre铆r pollo en t茅rminos de f铆sica</a></li>
<li><a href="../441376/index.html">M谩s all谩 de la pureza: qu茅 puede y qu茅 no puede revertir la membrana de 贸smosis</a></li>
<li><a href="../441378/index.html">Investigadores de Google: para protegerse contra Spectre requiere un cambio en la arquitectura del procesador, los parches de software no ayudar谩n</a></li>
<li><a href="../441380/index.html">7 puntos de crecimiento de conversi贸n o c贸mo aumentar la posibilidad de hacer clic en los botones</a></li>
<li><a href="../441382/index.html">Cient铆ficos chinos han desarrollado un generador piezoel茅ctrico para marcapasos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>