<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏼 🎑 🏺 Protección sin miedo. Seguridad de roscas en óxido 🚴 🤷🏿 🤾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta es la segunda parte de la serie de artículos Fearless Protection. En el primero hablamos de seguridad de memoria 

 Las aplicaciones modernas son...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protección sin miedo. Seguridad de roscas en óxido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441370/">  <font color="gray"><i>Esta es la segunda parte de la serie de artículos Fearless Protection.</i></font>  <font color="gray"><i>En el primero hablamos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguridad de memoria</a></i></font> <br><br>  Las aplicaciones modernas son multiproceso: en lugar de ejecutar tareas secuencialmente, el programa utiliza subprocesos para realizar simultáneamente varias tareas.  Todos observamos <i>trabajo simultáneo</i> y <i>concurrencia</i> todos los días: <br><br><ul><li>  Varios sitios web son atendidos por varios usuarios al mismo tiempo. <br></li><li> La interfaz de usuario realiza un trabajo en segundo plano que no molesta al usuario (imagine que cada vez que escribe un carácter, la aplicación se congela para verificar la ortografía). <br></li><li>  Una computadora puede ejecutar múltiples aplicaciones al mismo tiempo. </li></ul><br>  Las transmisiones paralelas aceleran el trabajo, pero presentan un conjunto de problemas de sincronización, a saber, puntos muertos y condiciones de carrera.  Desde el punto de vista de la seguridad, ¿por qué nos importa la seguridad de los hilos?  Porque la seguridad de la memoria y los subprocesos tiene el mismo problema principal: el uso inapropiado de los recursos.  Los ataques aquí tienen los mismos efectos que los ataques de memoria, incluida la escalada de privilegios, la ejecución de código arbitrario (ACE) y eludir las comprobaciones de seguridad. <br><a name="habracut"></a><br>  Los errores de concurrencia, como los errores de implementación, están estrechamente relacionados con la corrección del programa.  Si bien las vulnerabilidades de la memoria son casi siempre peligrosas, los errores de implementación / lógica no siempre indican un problema de seguridad si no ocurren en la parte del código relacionada con el cumplimiento de los contratos de seguridad (por ejemplo, permiso para eludir las verificaciones de seguridad).  Pero los errores de concurrencia tienen una peculiaridad.  Si los problemas de seguridad debidos a errores lógicos a menudo aparecen junto al código correspondiente, los errores de concurrencia a menudo ocurren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en otras funciones, y no en la que se cometió directamente</a> , lo que dificulta su seguimiento y eliminación.  Otra dificultad es una cierta superposición entre el procesamiento inadecuado de la memoria y los errores de concurrencia, que vemos en las carreras de datos. <br><br>  Los lenguajes de programación han desarrollado diversas estrategias de concurrencia para ayudar a los desarrolladores a gestionar el rendimiento y los problemas de seguridad de las aplicaciones de subprocesos múltiples. <br><br><h1>  Problemas de concurrencia </h1><br>  En general, se acepta que la programación paralela es más difícil de lo habitual: nuestro cerebro está mejor adaptado al razonamiento secuencial.  El código paralelo puede tener interacciones inesperadas y no deseadas entre subprocesos, incluidos puntos muertos, contenciones y carreras de datos. <br><br>  <i>Un punto muerto se</i> produce cuando varios subprocesos esperan que otros realicen ciertas acciones para continuar trabajando.  Aunque este comportamiento no deseado puede causar un ataque de denegación de servicio, no causará vulnerabilidades como ACE. <br><br>  <i>Una condición de carrera</i> es una situación en la que el tiempo o el orden de las tareas pueden afectar la corrección de un programa.  La carrera de datos ocurre cuando varias secuencias intentan acceder simultáneamente a la misma ubicación de memoria con al menos un intento de escritura.  Sucede que una condición de carrera y una carrera de datos se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">producen independientemente</a> una de la otra.  Pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las carreras de datos son siempre peligrosas</a> . <br><br><h3>  Posibles consecuencias de errores de concurrencia </h3><br><ol><li>  Punto muerto <br></li><li>  Pérdida de información: otro hilo sobrescribe la información <br></li><li>  Pérdida de integridad: la información de varias corrientes está entrelazada <br></li><li>  Pérdida de viabilidad: problemas de rendimiento debido al acceso desigual a los recursos compartidos. </li></ol><br>  El tipo de ataque de concurrencia más famoso se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TOCTOU</a> (tiempo de verificación hasta tiempo de uso): de hecho, el estado de una carrera es entre las condiciones de verificación (por ejemplo, credenciales de seguridad) y el uso de los resultados.  Un ataque TOCTOU resulta en una pérdida de integridad. <br><br>  Los bloqueos mutuos y la pérdida de capacidad de supervivencia se consideran problemas de rendimiento, no problemas de seguridad, mientras que la pérdida de información y la integridad probablemente estén relacionadas con la seguridad.  Un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo de Red Balloon Security</a> analiza algunas de las posibles hazañas.  Un ejemplo es una corrupción de puntero seguida de escalada de privilegios o ejecución remota de código.  En el exploit, una función que carga la biblioteca compartida ELF (formato ejecutable y enlazable) inicia correctamente un semáforo solo en la primera llamada, y luego limita incorrectamente el número de subprocesos, lo que provoca daños en la memoria del núcleo.  Este ataque es un ejemplo de pérdida de información. <br><br>  La parte más difícil de la programación concurrente es probar y depurar, porque los errores de concurrencia son difíciles de reproducir.  Tiempo de eventos, decisiones del sistema operativo, tráfico de red y otros factores ... todo esto cambia el comportamiento del programa en cada inicio. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/aa1/702/1b2/aa17021b2f9cb3eb726ea37995ed4e2e.png"></a> </div><br>  <i><font color="gray">A veces es realmente más fácil eliminar todo el programa que buscar un error.</font></i>  <i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Heisenbugs</a></font></i> <br><br>  El comportamiento no solo cambia cada vez que se inicia, sino que incluso insertar declaraciones de salida o depuración puede cambiar el comportamiento, lo que resulta en "errores de Heisenberg" (errores no deterministas, difíciles de reproducir, típicos de la programación paralela) que surgen y desaparecen misteriosamente. <br><br>  La programación paralela es difícil.  Es difícil predecir cómo interactuará el código paralelo con otro código paralelo.  Cuando aparecen errores, son difíciles de encontrar y corregir.  En lugar de confiar en los probadores, veamos formas de desarrollar programas y el uso de lenguajes que faciliten la escritura de código paralelo. <br><br>  Primero, formulamos el concepto de "seguridad del hilo": <br><br><blockquote>  "Un tipo de datos o método estático se considera seguro para subprocesos si se comporta correctamente cuando se llama desde varios subprocesos, independientemente de cómo se ejecutan estos subprocesos, y no requiere coordinación adicional del código de llamada".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MIT</a> </blockquote><br><h1>  Cómo funcionan los lenguajes de programación con paralelismo </h1><br>  En idiomas sin seguridad de subprocesos estáticos, los programadores tienen que monitorear constantemente la memoria que se comparte con otro subproceso y que puede cambiar en cualquier momento.  En la programación secuencial, se nos enseña a evitar las variables globales si otra parte del código las cambia silenciosamente.  Es imposible exigir a los programadores que garanticen un cambio seguro en los datos compartidos, así como la gestión manual de la memoria. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/3e3/5d2/e3e3e35d2775715a1f337d7c58aad7f7.gif"></div><br>  <i><font color="gray">"¡Vigilancia constante!"</font></i> <br><br>  Por lo general, los lenguajes de programación se limitan a dos enfoques: <br><br><ol><li>  Limitación de la mutabilidad o restricción del acceso compartido. <br></li><li>  Seguridad manual del hilo (p. Ej., Cerraduras, semáforos) </li></ol><br>  Los idiomas con restricción de subprocesos ponen un límite de 1 subproceso para variables mutables o requieren que todas las variables comunes sean inmutables.  Ambos enfoques abordan el problema básico de la carrera de datos (datos compartidos incorrectamente modificables), pero las restricciones son demasiado severas.  Para resolver el problema, los lenguajes hicieron primitivas de sincronización de bajo nivel, como mutexes.  Se pueden usar para construir estructuras de datos seguras para subprocesos. <br><br><h3>  Python y bloqueo global por intérprete </h3><br>  La implementación de referencia en Python y Cpython tiene un tipo de mutex llamado Global Interpreter Lock (GIL), que bloquea todos los otros hilos cuando un hilo accede a un objeto.  Python multiproceso es conocido por su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ineficiencia</a> debido a la latencia GIL.  Por lo tanto, la mayoría de los programas concurrentes de Python funcionan en varios procesos para que cada uno tenga su propio GIL. <br><br><h3>  Java y excepciones de tiempo de ejecución </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java</a> admite programación concurrente a través de un modelo de memoria compartida.  Cada hilo tiene su propia ruta de ejecución, pero puede acceder a cualquier objeto en el programa: el programador debe sincronizar el acceso entre los hilos usando las primitivas Java incorporadas. <br><br>  Aunque Java tiene bloques de construcción para crear programas seguros para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subprocesos</a> , <b>el</b> compilador <b>no garantiza la</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguridad de subprocesos</a> (a diferencia de la seguridad de la memoria).  Si se produce un acceso no sincronizado a la memoria (es decir, la carrera de datos), Java lanzará una excepción en tiempo de ejecución, pero los programadores deben usar correctamente las primitivas de concurrencia. <br><br><h3>  C ++ y el cerebro del programador </h3><br>  Si bien Python evita las condiciones de carrera con GIL y Java lanza excepciones en tiempo de ejecución, C ++ espera que el programador sincronice manualmente el acceso a la memoria.  Antes de C ++ 11, la biblioteca estándar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no incluía primitivas de concurrencia</a> . <br><br>  La mayoría de los idiomas proporcionan herramientas para escribir código seguro para subprocesos, y existen métodos especiales para detectar datos de carrera y estado de carrera;  pero no ofrece ninguna garantía de seguridad de subprocesos y no protege contra la carrera de datos. <br><br><h1>  ¿Cómo resolver el problema del óxido? </h1><br>  Rust adopta un enfoque multifacético para eliminar las condiciones de carrera, utilizando reglas de propiedad y tipos seguros para proteger completamente contra las condiciones de carrera en tiempo de compilación. <br><br>  En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer artículo,</a> presentamos el concepto de propiedad, este es uno de los conceptos básicos de Rust.  Cada variable tiene un propietario único, y la propiedad puede ser transferida o prestada.  Si otro hilo quiere cambiar el recurso, entonces transferimos la propiedad moviendo la variable a un nuevo hilo. <br><br>  Mover arroja una excepción: varios subprocesos pueden escribir en la misma memoria, pero nunca al mismo tiempo.  Dado que el propietario siempre está solo, ¿qué sucede si otro hilo toma prestada una variable? <br><br>  En Rust, tienes un préstamo mutable o varios inmutables.  No es posible introducir simultáneamente préstamos mutables e inmutables (o varios préstamos mutables).  En la seguridad de la memoria, es importante que los recursos se liberen correctamente, y en la seguridad de los subprocesos es importante que solo un subproceso tenga derecho a cambiar una variable en un momento dado.  Además, en tal situación, ningún otro flujo se referirá a préstamos obsoletos: es posible registrarlos o compartirlos, pero no ambos. <br><br>  El concepto de propiedad está diseñado para abordar las vulnerabilidades de la memoria.  Resultó que también evita la carrera de datos. <br><br>  Aunque muchos idiomas tienen métodos de seguridad de la memoria (como el conteo de enlaces y la recolección de basura), por lo general dependen de la sincronización manual o las prohibiciones del uso compartido simultáneo para evitar la carrera de datos.  El enfoque de Rust aborda ambos tipos de seguridad, tratando de resolver el problema principal de determinar el uso aceptable de los recursos y garantizar esta validez en el momento de la compilación. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/972/88b/4d9/97288b4d9796a35d8cce9400c2dbfd73.png"></div><br><br><h3>  Pero espera!  Eso no es todo! </h3><br>  Las reglas de propiedad evitan que múltiples hilos escriban datos en la misma ubicación de memoria y prohíben el intercambio simultáneo de datos entre hilos y mutabilidad, pero esto no necesariamente proporciona estructuras de datos seguras para hilos.  Cada estructura de datos en Rust es segura para subprocesos o no.  Esto se pasa al compilador utilizando un sistema de tipos. <br><br><blockquote>  "Un programa bien escrito no puede cometer un error".  - Robin Milner, 1978 </blockquote><br>  En lenguajes de programación, los sistemas de tipos describen un comportamiento aceptable.  En otras palabras, un programa bien escrito está bien definido.  Mientras nuestros tipos sean lo suficientemente expresivos como para capturar el significado deseado, un programa bien tipado se comportará según lo previsto. <br><br>  Rust es un lenguaje de tipo seguro, aquí el compilador verifica la consistencia de todos los tipos.  Por ejemplo, el siguiente código no se compila: <br><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-string"><span class="hljs-string">"I am a string"</span></span>; x = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br><pre> <code class="rust hljs"> error[E0308]: mismatched types --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span> | x = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-comment"><span class="hljs-comment">// | ^ expected &amp;str, found integral variable | = note: expected type `&amp;str` found type `{integer}`</span></span></code> </pre> <br>  Todas las variables en Rust son de tipo a menudo implícito.  También podemos definir nuevos tipos y describir las capacidades de cada tipo utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sistema de rasgos</a> .  Los rasgos proporcionan una abstracción de la interfaz.  Dos rasgos incorporados importantes son <code>Send</code> y <code>Sync</code> , que el compilador proporciona de manera predeterminada para cada tipo: <br><br><ul><li>  <code>Send</code> indica que la estructura se puede transferir de forma segura entre subprocesos (requerido para transferir la propiedad) <br></li><li>  <code>Sync</code> indica que los hilos pueden usar la estructura de forma segura. </li></ul><br>  El siguiente ejemplo es una versión simplificada del <a href="">código de la biblioteca estándar</a> que genera hilos: <br><br><pre> <code class="rust hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawn</span></span></span></span>&lt;Closure: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>() + <span class="hljs-built_in"><span class="hljs-built_in">Send</span></span>&gt;(closure: Closure){ ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = std::rc::Rc::new(<span class="hljs-number"><span class="hljs-number">6</span></span>); spawn(|| { x; });</code> </pre> <br>  La función <code>spawn</code> toma un solo argumento, <code>closure</code> y requiere un tipo para este último que implemente los rasgos <code>Send</code> y <code>Fn</code> .  Al intentar crear una secuencia y pasar el valor de <code>closure</code> con la variable <code>x</code> compilador arroja un error: <br><br><pre>  error [E0277]: `std :: rc :: Rc &lt;i32&gt;` no se puede enviar entre hilos de forma segura
      -&gt; src / main.rs: 8: 1
       El |
     8 |  engendrar (mover || {x;});
       El |  ^^^^^ `std :: rc :: Rc &lt;i32&gt;` no se puede enviar entre hilos de forma segura
       El |
       = ayuda: dentro de `[cierre@src/main.rs: 8: 7: 8:21 x: std :: rc :: Rc &lt;i32&gt;]`, el rasgo `std :: marker :: Send` no está implementado para `std :: rc :: Rc &lt;i32&gt;`
       = nota: requerido porque aparece dentro del tipo `[cierre@src/main.rs: 8: 7: 8:21 x: std :: rc :: Rc &lt;i32&gt;]`
     nota: requerido por `spawn` </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los rasgos de</a> <code>Send</code> y <code>Sync</code> permiten que el sistema de tipo Rust entienda qué datos se pueden compartir.  Al incluir esta información en el sistema de tipos, la seguridad de los hilos se convierte en parte de la seguridad de tipos.  En lugar de documentación, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguridad del subproceso se implementa mediante la ley del compilador</a> . <br><br>  Los programadores ven claramente objetos comunes entre subprocesos, y el compilador garantiza la fiabilidad de esta instalación. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35c/af5/27e/35caf527e18989b41893e6fd37239dab.gif"></div><br><br>  Aunque las herramientas de programación paralela están disponibles en muchos idiomas, evitar las condiciones de carrera no es fácil.  Si requiere que los programadores alternen complejas instrucciones e interactúen entre hilos, entonces los errores son inevitables.  Aunque las infracciones de seguridad de la memoria y los hilos conducen a consecuencias similares, las protecciones de memoria tradicionales, como el conteo de enlaces y la recolección de basura, no impiden las condiciones de la carrera.  Además de la garantía estática de seguridad de la memoria, el modelo de propiedad Rust también evita cambios de datos inseguros y el intercambio incorrecto de objetos entre subprocesos, mientras que el sistema de tipos proporciona seguridad de subprocesos en tiempo de compilación. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92d/429/fb9/92d429fb9c3812ddfdf115d71a3695ed.jpg"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441370/">https://habr.com/ru/post/441370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441360/index.html">OpenShift - manualidades de sombrero rojo</a></li>
<li><a href="../441362/index.html">Guía del usuario de Kibana. Visualización. Parte 3</a></li>
<li><a href="../441364/index.html">Programa de conferencias Lua en Moscú 2019</a></li>
<li><a href="../441366/index.html">¿Necesita la tienda Stylish Crossell: la experiencia de Retail Rocket en análisis de imágenes para formular recomendaciones?</a></li>
<li><a href="../441368/index.html">¿Cómo se ve la luna invisible de Neptuno?</a></li>
<li><a href="../441372/index.html">[Viernes] Cómo freír pollo en términos de física</a></li>
<li><a href="../441376/index.html">Más allá de la pureza: qué puede y qué no puede revertir la membrana de ósmosis</a></li>
<li><a href="../441378/index.html">Investigadores de Google: para protegerse contra Spectre requiere un cambio en la arquitectura del procesador, los parches de software no ayudarán</a></li>
<li><a href="../441380/index.html">7 puntos de crecimiento de conversión o cómo aumentar la posibilidad de hacer clic en los botones</a></li>
<li><a href="../441382/index.html">Científicos chinos han desarrollado un generador piezoeléctrico para marcapasos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>