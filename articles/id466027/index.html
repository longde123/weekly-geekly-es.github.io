<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏽 🤬 🤹🏼 Buku "The Way of Python. Sabuk hitam untuk pengembangan, penskalaan, pengujian dan penyebaran ” 🗡️ 📜 🤳🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, habrozhiteli! Jalur Python memungkinkan Anda mengasah keterampilan profesional Anda dan belajar sebanyak mungkin tentang kemampuan bahasa pemrogr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku "The Way of Python. Sabuk hitam untuk pengembangan, penskalaan, pengujian dan penyebaran ”</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/466027/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/kq/of/aw/kqofawsaidazmnefdopvktmtxei.jpeg" align="left" alt="gambar"></a>  Hai, habrozhiteli!  Jalur Python memungkinkan Anda mengasah keterampilan profesional Anda dan belajar sebanyak mungkin tentang kemampuan bahasa pemrograman paling populer.  Anda akan belajar cara menulis kode yang efektif, membuat program terbaik dalam waktu minimal dan menghindari kesalahan umum.  Saatnya berkenalan dengan komputasi multi-utas dan memoisasi, dapatkan saran ahli di bidang API dan desain basis data, serta melihat ke dalam Python untuk memperluas pemahaman Anda tentang bahasa.  Anda harus memulai proyek, bekerja dengan versi, mengatur pengujian otomatis dan memilih gaya pemrograman untuk tugas tertentu.  Kemudian Anda akan melanjutkan untuk mempelajari deklarasi fungsi yang efektif, pilih struktur data dan pustaka yang sesuai, buat program bebas masalah, paket dan optimalkan program pada level bytecode. <br><a name="habracut"></a><br><h3>  Kutipan.  Menjalankan tes secara paralel </h3><br>  Menjalankan test suite dapat menghabiskan waktu.  Ini adalah kejadian umum dalam proyek besar ketika test suite membutuhkan waktu beberapa menit untuk menyelesaikannya.  Secara default, pytest menjalankan tes secara berurutan, dalam urutan tertentu. <br><br>  Karena sebagian besar komputer memiliki prosesor multi-core, Anda dapat mempercepat jika Anda memisahkan tes untuk dijalankan pada beberapa core. <br><br>  Untuk ini, pytest memiliki plugin pytest-xdist yang dapat diinstal menggunakan pip.  Plugin ini memperluas baris perintah pytest dengan argumen ––numprocesses (disingkat –n), yang mengambil jumlah core yang digunakan sebagai argumen.  Menjalankan pytest –n 4 akan menjalankan test suite dalam empat proses paralel, menjaga keseimbangan antara beban core yang tersedia. <br><br>  Karena kenyataan bahwa jumlah inti dapat bervariasi, plugin juga menerima kata kunci otomatis sebagai nilai.  Dalam hal ini, jumlah core yang tersedia akan dikembalikan secara otomatis. <br><br><h3>  Membuat objek yang digunakan dalam tes menggunakan perlengkapan </h3><br>  Dalam pengujian unit, seringkali diperlukan untuk melakukan serangkaian operasi standar sebelum dan setelah menjalankan tes, dan instruksi ini melibatkan komponen-komponen tertentu.  Misalnya, Anda mungkin memerlukan objek yang akan menyatakan kondisi konfigurasi aplikasi, dan harus diinisialisasi sebelum setiap pengujian, dan kemudian mengatur ulang ke nilai awal setelah eksekusi.  Demikian pula, jika tes tergantung pada file sementara, file ini harus dibuat sebelum tes dan dihapus setelahnya.  Komponen semacam itu disebut <i>fixture</i> .  Mereka diinstal sebelum pengujian dan menghilang setelah eksekusi. <br><br>  Dalam perlengkapan pytest dinyatakan sebagai fungsi sederhana.  Fungsi fixture harus mengembalikan objek yang diinginkan sehingga dalam pengujian di mana ia digunakan, objek ini dapat digunakan. <br><br>  Berikut adalah contoh perlengkapan sederhana: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest @pytest.fixture <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">database</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;some database connection&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(database)</span></span></span><span class="hljs-function">:</span></span> database.insert(<span class="hljs-number"><span class="hljs-number">123</span></span>)</code> </pre> <br>  Fixture database secara otomatis digunakan oleh tes apa pun yang memiliki argumen database dalam daftar.  Fungsi test_insert () akan menerima hasil dari fungsi database () sebagai argumen pertama dan akan menggunakan hasil ini sesuai keinginan.  Dengan penggunaan fixture ini, Anda tidak perlu mengulang kode inisialisasi database beberapa kali. <br><br>  Fitur umum lain dari pengujian kode adalah kemampuan untuk menghapus berlebihan setelah operasi fixture.  Misalnya, tutup koneksi basis data.  Menerapkan fixture sebagai generator akan menambah fungsionalitas untuk membersihkan objek yang diverifikasi (Listing 6.5). <br><br><blockquote><h4>  Listing 6.5.  Menghapus Objek Terverifikasi </h4><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest @pytest.fixture <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">database</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> db = &lt;some database connection&gt; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> db db.close() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(database)</span></span></span><span class="hljs-function">:</span></span> database.insert(<span class="hljs-number"><span class="hljs-number">123</span></span>)</code> </pre> </blockquote>  Karena kami menggunakan kata kunci hasil dan membuat generator dari basis data, kode setelah pernyataan hasil dijalankan hanya pada akhir pengujian.  Kode ini akan menutup koneksi database di akhir tes. <br><br>  Menutup koneksi database untuk setiap tes dapat menyebabkan pemborosan daya komputasi, karena tes lain dapat menggunakan koneksi yang sudah terbuka.  Dalam hal ini, Anda bisa meneruskan argumen cakupan ke dekorator fixture, dengan menentukan cakupannya: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest @pytest.fixture(scope=<span class="hljs-string"><span class="hljs-string">"module"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">database</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> db = &lt;some database connection&gt; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> db db.close() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(database)</span></span></span><span class="hljs-function">:</span></span> database.insert(<span class="hljs-number"><span class="hljs-number">123</span></span>)</code> </pre> <br>  Dengan menentukan parameter scope = "module", Anda menginisialisasi fixture satu kali untuk seluruh modul, dan sekarang koneksi database terbuka akan tersedia untuk semua fungsi tes yang memintanya. <br><br>  Anda dapat menjalankan beberapa kode umum sebelum atau setelah pengujian, dengan menetapkan perlengkapan yang secara otomatis digunakan dengan kata kunci autouse, daripada menetapkannya sebagai argumen untuk setiap fungsi pengujian.  Mengkonkretkan fungsi pytest.fixture () dengan argumen True, kata kunci autouse, memastikan bahwa perlengkapan dipanggil setiap kali sebelum menjalankan tes dalam modul atau kelas di mana ia dinyatakan. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest @pytest.fixture(autouse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change_user_env</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> curuser = os.environ.get(<span class="hljs-string"><span class="hljs-string">"USER"</span></span>) os.environ[<span class="hljs-string"><span class="hljs-string">"USER"</span></span>] = <span class="hljs-string"><span class="hljs-string">"foobar"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> os.environ[<span class="hljs-string"><span class="hljs-string">"USER"</span></span>] = curuser <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_user</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> os.getenv(<span class="hljs-string"><span class="hljs-string">"USER"</span></span>) == <span class="hljs-string"><span class="hljs-string">"foobar"</span></span>&lt;/source     .  ,    :     ,      ,       . &lt;h3&gt;  &lt;/h3&gt;           ,    ,   ,         .          Gnocchi,    . Gnocchi      &lt;i&gt;storage API&lt;/i&gt;.    Python          .       ,      API   .        ,      (    storage API),  ,       .   ,   &lt;i&gt; &lt;/i&gt;,     ,        .  <span class="hljs-number"><span class="hljs-number">6.6</span></span>          ,    :    mysql,   —  postgresql. &lt;blockquote&gt;&lt;h4&gt; <span class="hljs-number"><span class="hljs-number">6.6</span></span>.      &lt;/h4&gt; &lt;source lang=<span class="hljs-string"><span class="hljs-string">"python"</span></span>&gt;<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> myapp @pytest.fixture(params=[<span class="hljs-string"><span class="hljs-string">"mysql"</span></span>, <span class="hljs-string"><span class="hljs-string">"postgresql"</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">database</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> d = myapp.driver(request.param) d.start() <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> d d.stop() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(database)</span></span></span><span class="hljs-function">:</span></span> database.insert(<span class="hljs-string"><span class="hljs-string">"somedata"</span></span>)</code> </pre>  Fixture driver menerima dua nilai berbeda sebagai parameter - nama driver database yang didukung oleh aplikasi.  test_insert dijalankan dua kali: sekali untuk database MySQL, dan yang kedua untuk database PostgreSQL.  Ini membuatnya mudah untuk mengikuti tes yang sama, tetapi dengan skenario yang berbeda, tanpa menambahkan baris kode baru. <br><br><h3>  Tes yang Dikelola dengan Objek Dummy </h3><br>  Objek dummy (atau bertopik, objek tiruan) adalah objek yang meniru perilaku objek aplikasi nyata, tetapi dalam keadaan khusus dan terkontrol.  Mereka sangat berguna dalam menciptakan lingkungan yang secara menyeluruh menggambarkan kondisi untuk pengujian.  Anda dapat mengganti semua objek kecuali objek yang diuji dengan objek dummy dan mengisolasinya, serta membuat lingkungan untuk pengujian kode. <br><br>  Satu use case adalah membuat klien HTTP.  Hampir mustahil (atau lebih tepatnya, sangat sulit) untuk membuat server HTTP tempat Anda dapat menjalankan semua situasi dan skenario untuk setiap nilai yang mungkin.  Klien HTTP sangat sulit untuk menguji skenario kesalahan. <br><br>  Perpustakaan standar memiliki perintah tiruan untuk membuat objek dummy.  Dimulai dengan Python 3.3, mock telah diintegrasikan dengan perpustakaan unittest.mock.  Oleh karena itu, Anda dapat menggunakan potongan kode di bawah ini untuk memberikan kompatibilitas mundur antara Python 3.3 dan sebelumnya: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ImportError: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock</code> </pre> <br>  Perpustakaan tiruan sangat mudah digunakan.  Setiap atribut yang tersedia untuk objek mock.Mock dibuat secara dinamis saat runtime.  Atribut apa pun dapat diberi nilai apa pun.  Dalam Listing 6.7, mock digunakan untuk membuat objek dummy untuk atribut dummy. <br><blockquote><h4>  Listing 6.7.  Mengakses atribut mock.Mock </h4><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock &gt;&gt;&gt; m = mock.Mock() &gt;&gt;&gt; m.some_attribute = <span class="hljs-string"><span class="hljs-string">"hello world"</span></span> &gt;&gt;&gt; m.some_attribute <span class="hljs-string"><span class="hljs-string">"hello world"</span></span></code> </pre> </blockquote>  Anda juga bisa secara dinamis membuat metode untuk objek yang bisa berubah, seperti di Listing 6.8, di mana Anda membuat metode dummy yang selalu mengembalikan 42 dan mengambil apa pun yang Anda inginkan sebagai argumen. <br><blockquote><h4>  Listing 6.8.  Membuat metode untuk objek dummy mock.Mock </h4><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock &gt;&gt;&gt; m = mock.Mock() &gt;&gt;&gt; m.some_method.return_value = <span class="hljs-number"><span class="hljs-number">42</span></span> &gt;&gt;&gt; m.some_method() <span class="hljs-number"><span class="hljs-number">42</span></span> &gt;&gt;&gt; m.some_method(<span class="hljs-string"><span class="hljs-string">"with"</span></span>, <span class="hljs-string"><span class="hljs-string">"arguments"</span></span>) <span class="hljs-number"><span class="hljs-number">42</span></span></code> </pre> </blockquote>  Hanya beberapa baris, dan objek mock.Mock sekarang memiliki metode some_method (), yang mengembalikan 42. Dibutuhkan semua jenis argumen, sementara tidak ada verifikasi dari apa argumen itu. <br><br>  Metode yang dihasilkan secara dinamis juga dapat memiliki efek samping (disengaja).  Agar tidak hanya metode boilerplate yang mengembalikan nilai, mereka dapat didefinisikan untuk mengeksekusi kode yang bermanfaat. <br><br>  Listing 6.9 menciptakan metode dummy yang memiliki efek samping - ini menampilkan string “hello world”. <br><blockquote><h4>  Listing 6.9.  Membuat metode untuk objek mock.Mock dengan efek samping </h4><br><pre> <code class="python hljs"> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock &gt;&gt;&gt; m = mock.Mock() &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... print(<span class="hljs-string"><span class="hljs-string">"hello world!"</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">43</span></span> ... ❶ &gt;&gt;&gt; m.some_method.side_effect = print_hello &gt;&gt;&gt; m.some_method() hello world! <span class="hljs-number"><span class="hljs-number">43</span></span> ❷ &gt;&gt;&gt; m.some_method.call_count <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </blockquote>  Kami menetapkan seluruh fungsi ke atribut some_method ❶.  Secara teknis, ini memungkinkan Anda untuk menerapkan skenario yang lebih kompleks dalam pengujian, karena Anda dapat memasukkan kode yang diperlukan untuk pengujian dalam objek dummy.  Selanjutnya, Anda harus meneruskan objek ini ke fungsi yang mengharapkannya. <br><br>  Atribut ❷ call_count adalah cara mudah untuk memeriksa berapa kali suatu metode dipanggil. <br><br>  Perpustakaan tiruan menggunakan pola "aksi-cek": ini berarti bahwa setelah pengujian Anda perlu memastikan bahwa tindakan yang diganti oleh boneka dilakukan dengan benar.  Listing 6.10 menerapkan metode assert () ke objek dummy untuk melakukan pemeriksaan ini. <br><blockquote><h4>  Listing 6.10.  Hubungi metode verifikasi </h4><br><pre> <code class="python hljs"> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock &gt;&gt;&gt; m = mock.Mock() ❶ &gt;&gt;&gt; m.some_method(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>) &lt;Mock name=<span class="hljs-string"><span class="hljs-string">'mock.some_method()'</span></span> id=<span class="hljs-string"><span class="hljs-string">'26144272'</span></span>&gt; ❷ &gt;&gt;&gt; m.some_method.assert_called_once_with(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>) &gt;&gt;&gt; m.some_method.assert_called_once_with(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, ❸mock.ANY) &gt;&gt;&gt; m.some_method.assert_called_once_with(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"/usr/lib/python2.7/dist-packages/mock.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">846</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> assert_cal led_once_with <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.assert_called_with(*args, **kwargs) File <span class="hljs-string"><span class="hljs-string">"/usr/lib/python2.7/dist-packages/mock.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">835</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> assert_cal led_with <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> AssertionError(msg) AssertionError: Expected call: some_method(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>) Actual call: some_method(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>)</code> </pre> </blockquote>  Kami membuat metode dengan argumen foo dan bar sebagai pengujian dengan memanggil metode ❶.  Cara mudah untuk memeriksa panggilan ke objek dummy adalah dengan menggunakan metode assert_called (), seperti assert_called_once_with () ❷.  Untuk metode ini, Anda harus memberikan nilai yang Anda harapkan untuk digunakan saat memanggil metode dummy.  Jika nilai yang diteruskan berbeda dari yang digunakan, maka mock memunculkan eksepsi AssertionError.  Jika Anda tidak tahu argumen apa yang dapat diajukan, gunakan mock.ANY sebagai nilai ❸;  itu akan menggantikan argumen apa pun yang diteruskan ke metode dummy. <br><br>  Perpustakaan tiruan juga dapat digunakan untuk mengganti fungsi, metode, atau objek dari modul eksternal.  Dalam Listing 6.11, kami mengganti fungsi os.unlink () dengan fungsi dummy kami sendiri. <br><blockquote><h4>  Listing 6.11.  Menggunakan mock.patch </h4><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fake_os_unlink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOError(<span class="hljs-string"><span class="hljs-string">"Testing!"</span></span>) ... &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> mock.patch(<span class="hljs-string"><span class="hljs-string">'os.unlink'</span></span>, fake_os_unlink): ... os.unlink(<span class="hljs-string"><span class="hljs-string">'foobar'</span></span>) ... Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fake_os_unlink IOError: Testing!</code> </pre> </blockquote>  Ketika digunakan sebagai manajer konteks, mock.patch () menggantikan fungsi target dengan yang kita pilih.  Ini diperlukan agar kode yang dieksekusi dalam konteks menggunakan metode yang dikoreksi.  Menggunakan metode mock.patch (), Anda dapat memodifikasi bagian mana pun dari kode eksternal, memaksanya berperilaku sedemikian rupa untuk menguji semua kondisi untuk aplikasi (Listing 6.12). <br><blockquote><h4>  Listing 6.12.  Menggunakan mock.patch () untuk menguji banyak perilaku </h4><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhereIsPythonError</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Exception)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ❶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_python_still_a_programming_language</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: r = requests.get(<span class="hljs-string"><span class="hljs-string">"http://python.org"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> IOError: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r.status_code == <span class="hljs-number"><span class="hljs-number">200</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Python is a programming language'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r.content <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> WhereIsPythonError(<span class="hljs-string"><span class="hljs-string">"Something bad happened"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_fake_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status_code, content)</span></span></span><span class="hljs-function">:</span></span> m = mock.Mock() m.status_code = status_code m.content = content <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fake_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fake_get <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raise_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOError(<span class="hljs-string"><span class="hljs-string">"Unable to fetch url %s"</span></span> % url) ❷ @mock.patch(<span class="hljs-string"><span class="hljs-string">'requests.get'</span></span>, get_fake_get( <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-string"><span class="hljs-string">'Python is a programming language for sure'</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_python_is</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> is_python_still_a_programming_language() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> @mock.patch(<span class="hljs-string"><span class="hljs-string">'requests.get'</span></span>, get_fake_get( <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-string"><span class="hljs-string">'Python is no more a programming language'</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_python_is_not</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> is_python_still_a_programming_language() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> @mock.patch(<span class="hljs-string"><span class="hljs-string">'requests.get'</span></span>, get_fake_get(<span class="hljs-number"><span class="hljs-number">404</span></span>, <span class="hljs-string"><span class="hljs-string">'Whatever'</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_bad_status_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> pytest.raises(WhereIsPythonError): is_python_still_a_programming_language() @mock.patch(<span class="hljs-string"><span class="hljs-string">'requests.get'</span></span>, raise_get) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_ioerror</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> pytest.raises(WhereIsPythonError): is_python_still_a_programming_language()</code> </pre> </blockquote><br><br>  Listing 6.12 mengimplementasikan kasus uji yang mencari semua instance <i>Python adalah</i> string <i>bahasa pemrograman</i> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">python.org</a> ❶.  Tidak ada opsi di mana tes tidak akan menemukan baris yang diberikan pada halaman web yang dipilih.  Untuk mendapatkan hasil negatif, Anda perlu mengubah halaman, tetapi ini tidak dapat dilakukan.  Tetapi dengan bantuan mock, Anda dapat melakukan trik dan mengubah perilaku permintaan sehingga mengembalikan respons dummy dengan halaman fiktif yang tidak berisi string yang diberikan.  Ini akan memungkinkan Anda untuk menguji skenario negatif di mana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">python.org</a> tidak berisi string yang diberikan, dan pastikan bahwa program menangani kasus seperti itu dengan benar. <br><br>  Contoh ini menggunakan versi dekorator mock.patch () .  Perilaku objek dummy tidak berubah, dan lebih mudah untuk memberi contoh dalam konteks fungsi tes. <br><br>  Menggunakan objek dummy akan membantu mensimulasikan masalah: server mengembalikan kesalahan 404, kesalahan I / O, atau kesalahan penundaan jaringan.  Kami dapat memastikan bahwa kode mengembalikan nilai yang benar atau melemparkan pengecualian yang tepat dalam setiap kasus, yang menjamin perilaku yang diharapkan dari kode. <br><br><h3>  Identifikasi Kode yang Belum Diuji dengan cakupan </h3><br>  Tambahan yang bagus untuk pengujian unit adalah alat cakupan. [Cakupan kode adalah ukuran yang digunakan dalam pengujian.  Memperlihatkan persentase kode sumber program yang dieksekusi selama proses pengujian - <i>red.</i>  ], yang menemukan potongan kode yang tidak diuji.  Ini menggunakan analisis kode dan alat pelacakan untuk mengidentifikasi baris yang dieksekusi.  Dalam pengujian unit, ini dapat mengungkapkan bagian mana dari kode yang digunakan kembali dan mana yang tidak digunakan sama sekali.  Diperlukan membuat tes, dan kemampuan untuk mengetahui bagian mana dari kode yang Anda lupa selesaikan dengan tes membuat proses ini lebih menyenangkan. <br><br>  Pasang modul cakupan melalui pip untuk dapat menggunakannya melalui shell Anda. <br><br><blockquote><h4>  CATATAN </h4><br>  Perintah ini juga bisa disebut cakupan python jika modul diinstal melalui installer OS Anda.  Contohnya adalah OS Debian. </blockquote><br><br>  Menggunakan cakupan offline sangat sederhana.  Ini menunjukkan bagian-bagian dari program yang tidak pernah memulai dan menjadi "bobot mati" - kode sedemikian rupa sehingga Anda tidak dapat menghapusnya tanpa mengubah fungsionalitas program.  Semua alat uji yang dibahas sebelumnya dalam bab ini terintegrasi dengan cakupan. <br><br>  Saat menggunakan pytest, instal plugin pytest-cov melalui pip instal pytest-pycov dan tambahkan beberapa sakelar untuk menghasilkan keluaran terperinci dari kode yang belum diuji (Listing 6.13). <br><blockquote><h4>  Listing 6.13.  Menggunakan pytest dan cakupan </h4><br><pre> <code class="python hljs">$ pytest --cov=gnocchiclient gnocchiclient/tests/unit ---------- coverage: platform darwin, python <span class="hljs-number"><span class="hljs-number">3.6</span></span><span class="hljs-number"><span class="hljs-number">.4</span></span>-final<span class="hljs-number"><span class="hljs-number">-0</span></span> ----------- Name Stmts Miss Branch BrPart Cover --------------------------- gnocchiclient/__init__.py <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>% gnocchiclient/auth.py <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">23</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">49</span></span>% gnocchiclient/benchmark.py <span class="hljs-number"><span class="hljs-number">175</span></span> <span class="hljs-number"><span class="hljs-number">175</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>% --snip-- --------------------------- TOTAL <span class="hljs-number"><span class="hljs-number">2040</span></span> <span class="hljs-number"><span class="hljs-number">1868</span></span> <span class="hljs-number"><span class="hljs-number">424</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>% === passed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">5.00</span></span> seconds ===</code> </pre> </blockquote>  Opsi --cov memungkinkan output dari laporan pertanggungan di akhir pengujian.  Anda harus memberikan nama paket sebagai argumen agar plugin memfilter laporan dengan benar.  Output akan berisi baris kode yang belum dieksekusi, yang berarti belum diuji.  Yang tersisa untuk Anda adalah membuka editor dan menulis tes untuk kode ini. <br><br>  Modul cakupan bahkan lebih baik - memungkinkan Anda untuk menghasilkan laporan yang jelas dalam format HTML.  Cukup tambahkan -–cov-report-html dan halaman HTML akan muncul di direktori <i>htmlcov</i> dari mana Anda menjalankan perintah.  Setiap halaman akan menunjukkan bagian mana dari kode sumber yang sedang atau tidak berjalan. <br><br>  Jika Anda ingin melangkah lebih jauh, gunakan –-over-fail-under-COVER_MIN_PERCENTAGE, yang akan menyebabkan suite pengujian gagal jika tidak mencakup persentase minimum kode.  Meskipun persentase besar cakupan adalah tujuan yang baik, dan alat pengujian berguna untuk memperoleh informasi tentang status cakupan pengujian, persentase itu sendiri tidak terlalu informatif.  Gambar 6.1 menunjukkan contoh laporan cakupan yang menunjukkan persen cakupan. <br><br>  Misalnya, menutup kode dengan pengujian 100% adalah tujuan yang layak, tetapi ini tidak berarti bahwa kode tersebut sepenuhnya diuji.  Nilai ini hanya menunjukkan bahwa semua baris kode dalam program terpenuhi, tetapi tidak menunjukkan bahwa semua kondisi telah diuji. <br><br>  Sebaiknya gunakan informasi cakupan untuk memperluas test suite dan membuatnya untuk kode yang tidak berjalan.  Ini menyederhanakan dukungan proyek dan meningkatkan kualitas kode secara keseluruhan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d_/af/vl/d_afvlajlx_9ctds7yfu7ef_2ds.png" alt="gambar"></div><br><br><h3>  Tentang penulis </h3><br>  <i>Julien Danju</i> telah meretas freeware selama sekitar dua puluh tahun, dan telah mengembangkan program Python selama hampir dua belas tahun.  Dia saat ini memimpin tim desain untuk platform cloud terdistribusi berbasis OpenStack, yang memiliki database open source Python terbesar yang ada, dengan sekitar dua setengah juta baris kode.  Sebelum mengembangkan layanan cloud, Julien menciptakan window manager dan berkontribusi pada pengembangan banyak proyek, seperti Debian dan GNU Emacs. <br><br><h3>  Tentang Editor Sains </h3><br>  <i>Mike Driscoll telah</i> memprogram dalam Python selama lebih dari satu dekade.  Untuk waktu yang lama, ia menulis tentang Python di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Mouse vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Python</a> .  Penulis beberapa buku Python: Python 101, Wawancara Python, dan ReportLab: Pemrosesan PDF dengan Python.  Anda dapat menemukan Mike di Twitter dan di GitHub: @driscollis. <br><br>  »Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  Kupon diskon 25% untuk penjaja - <b>Python</b> <br><br>  Setelah pembayaran versi kertas buku, sebuah buku elektronik dikirim melalui email. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466027/">https://habr.com/ru/post/id466027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466001/index.html">Feng Shui "Bergerak", atau kita tidur dengan benar (kopi, kecoak, dan intoleransi terhadap Habré)</a></li>
<li><a href="../id466015/index.html">Sedikit lagi tentang trigonometri dalam komputasi</a></li>
<li><a href="../id466017/index.html">Livy - tautan yang hilang dalam rantai Python Hadoop Spark Airflow</a></li>
<li><a href="../id466019/index.html">ABBYY Mobile Web Capture: Foto dokumen berkualitas tinggi tepat di browser ponsel cerdas Anda</a></li>
<li><a href="../id466021/index.html">Bagaimana saya mengajar Yandex. Baik untuk berbicara tentang mainan seks</a></li>
<li><a href="../id466029/index.html">Cara mengubah komputer kuantum menjadi generator angka acak sempurna</a></li>
<li><a href="../id466031/index.html">Misi epik DeepMind untuk memecahkan masalah sains yang paling kompleks</a></li>
<li><a href="../id466033/index.html">Bagaimana cara melibatkan tim dalam pencarian ide dan mendapatkan lebih banyak daripada ide</a></li>
<li><a href="../id466039/index.html">Perpustakaan PHP untuk e-commerce: bekerja dengan ATOL dan Payture, parsing kode GS1 dan tugas lainnya</a></li>
<li><a href="../id466041/index.html">Acara offline pertama dari Lingkaran Pengembang Facebook: komunitas Moskow - Acara Peluncuran</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>