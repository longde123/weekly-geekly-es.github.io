<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏽 🙇🏻 🔼 Panduan Arsitektur Aplikasi Android 🏧 🤱🏻 👨🏽‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya hadir untuk Anda terjemahan gratis "Panduan untuk arsitektur aplikasi" dari JetPack . Saya meminta Anda untuk meninggalkan semua kome...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan Arsitektur Aplikasi Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456256/">  Halo, Habr!  Saya hadir untuk Anda terjemahan gratis "Panduan untuk arsitektur aplikasi" dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JetPack</a> .  Saya meminta Anda untuk meninggalkan semua komentar pada terjemahan di komentar, dan mereka akan diperbaiki.  Juga, komentar dari mereka yang menggunakan arsitektur yang disajikan dengan rekomendasi untuk penggunaannya akan bermanfaat bagi semua orang. <br><br>  Panduan ini mencakup praktik terbaik dan arsitektur yang disarankan untuk membangun aplikasi yang kuat.  Halaman ini mengasumsikan pengantar dasar untuk Kerangka Android.  Jika Anda baru dalam pengembangan aplikasi Android, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan pengembang</a> kami untuk memulai dan mempelajari lebih lanjut tentang konsep yang disebutkan dalam panduan ini.  Jika Anda tertarik pada arsitektur aplikasi dan ingin membiasakan diri dengan materi dalam panduan ini dalam hal pemrograman di Kotlin, lihat kursus Udacity, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Mengembangkan Aplikasi untuk Android dengan Kotlin,"</a> . <br><br><h2>  Pengalaman Pengguna Aplikasi Seluler </h2><br>  Dalam kebanyakan kasus, aplikasi desktop memiliki titik masuk tunggal dari desktop atau peluncur, dan kemudian dijalankan sebagai proses monolitik tunggal.  Aplikasi Android memiliki struktur yang jauh lebih kompleks.  Aplikasi Android tipikal berisi beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen aplikasi</a> , termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aktivitas</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fragmen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ContentProviders,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BroadcastReceivers</a> . <br><br>  Anda menyatakan semua atau beberapa komponen aplikasi ini dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manifes</a> aplikasi.  Android kemudian menggunakan file ini untuk memutuskan bagaimana mengintegrasikan aplikasi Anda ke dalam antarmuka pengguna umum perangkat.  Mengingat bahwa aplikasi Android yang ditulis dengan baik berisi beberapa komponen, dan pengguna sering berinteraksi dengan beberapa aplikasi dalam waktu singkat, aplikasi harus beradaptasi dengan berbagai jenis alur kerja dan tugas yang digerakkan pengguna. <br><a name="habracut"></a><br>  Misalnya, pertimbangkan apa yang terjadi ketika Anda berbagi foto di aplikasi media sosial favorit Anda: <br><br><ol><li>  Aplikasi memicu niat kamera.  Android meluncurkan aplikasi kamera untuk memproses permintaan.  Saat ini, pengguna telah meninggalkan aplikasi untuk jejaring sosial, dan pengalamannya sebagai pengguna sangat sempurna. </li><li>  Aplikasi kamera dapat memicu niat lain, seperti meluncurkan pemilih file, yang dapat meluncurkan aplikasi lain. </li><li>  Pada akhirnya, pengguna kembali ke aplikasi jejaring sosial dan berbagi foto. </li></ol><br>  Setiap saat dalam proses, pengguna dapat terganggu oleh panggilan telepon atau pemberitahuan.  Setelah tindakan yang terkait dengan interupsi ini, pengguna berharap dapat kembali dan melanjutkan proses berbagi foto ini.  Perilaku beralih aplikasi ini biasa terjadi pada perangkat seluler, jadi aplikasi Anda harus menangani poin (tugas) ini dengan benar. <br><br>  Ingatlah bahwa perangkat seluler juga terbatas sumber dayanya, jadi kapan saja, sistem operasi dapat menghancurkan beberapa proses aplikasi untuk membebaskan ruang untuk yang baru. <br><br>  Dengan kondisi lingkungan ini, komponen aplikasi Anda dapat diluncurkan secara terpisah dan tidak berurutan, dan sistem operasi atau pengguna dapat menghancurkannya kapan saja.  Karena peristiwa ini tidak di bawah kendali <b>Anda</b> , <b>Anda tidak boleh menyimpan data atau status apa pun dalam komponen aplikasi Anda,</b> dan komponen aplikasi Anda tidak boleh saling bergantung. <br><br><h2>  Prinsip arsitektur umum </h2><br>  Jika Anda tidak boleh menggunakan komponen aplikasi untuk menyimpan data dan status aplikasi, bagaimana Anda harus mengembangkan aplikasi Anda? <br><br><h3>  Pembagian tanggung jawab </h3><br>  Prinsip yang paling penting untuk diikuti adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembagian tanggung jawab</a> .  Kesalahan umum adalah ketika Anda menulis semua kode Anda di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aktivitas</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fragmen</a> .  Ini adalah kelas antarmuka pengguna yang hanya boleh berisi logika yang memproses interaksi antarmuka pengguna dan sistem operasi.  Dengan berbagi tanggung jawab sebanyak mungkin dalam kelas-kelas ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(SRP)</a> , Anda dapat menghindari banyak masalah yang terkait dengan siklus hidup aplikasi. <br><br><h3>  Kontrol Antarmuka Pengguna dari Model </h3><br>  Prinsip penting lainnya adalah Anda harus <b>mengontrol antarmuka pengguna Anda dari suatu model</b> , lebih disukai dari model permanen.  Model adalah komponen yang bertanggung jawab untuk memproses data untuk aplikasi.  Mereka tidak tergantung pada objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lihat</a> dan komponen aplikasi, oleh karena itu, mereka tidak terpengaruh oleh siklus hidup aplikasi dan masalah terkait. <br><br>  Model permanen sangat ideal karena alasan berikut: <br><br><ul><li>  Pengguna Anda tidak akan kehilangan data jika OS Android menghancurkan aplikasi Anda untuk membebaskan sumber daya. </li><li>  Aplikasi Anda terus berfungsi ketika koneksi jaringan tidak stabil atau tidak tersedia. </li></ul><br>  Dengan mengorganisasi fondasi aplikasi Anda ke dalam kelas model dengan tanggung jawab yang jelas untuk manajemen data, aplikasi Anda menjadi lebih teruji dan didukung. <br><br><h2>  Arsitektur Aplikasi yang Disarankan </h2><br>  Bagian ini menunjukkan bagaimana menyusun aplikasi menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen arsitektur</a> , bekerja dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skenario penggunaan ujung</a> ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ujung</a> . <br><br>  <i><b>Catatan</b></i>  <i>Tidaklah mungkin untuk memiliki satu cara menulis aplikasi yang bekerja paling baik untuk setiap skenario.</i>  <i>Namun, arsitektur yang direkomendasikan adalah titik awal yang baik untuk sebagian besar situasi dan alur kerja.</i>  <i>Jika Anda sudah memiliki cara yang baik untuk menulis aplikasi Android yang memenuhi prinsip arsitektur umum, Anda tidak boleh mengubahnya.</i> <br><br>  Bayangkan kami membuat antarmuka pengguna yang menampilkan profil pengguna.  Kami menggunakan API pribadi dan API REST untuk mengambil data profil. <br><br><h3>  Ulasan </h3><br>  Untuk memulai, pertimbangkan skema interaksi modul arsitektur aplikasi yang sudah selesai: <br><br><img src="https://habrastorage.org/webt/lb/xq/cx/lbxqcxyjtoauqkif9hte7srpnm8.png"><br><br>  Harap dicatat bahwa setiap komponen hanya bergantung pada komponen satu tingkat di bawahnya.  Misalnya, Aktivitas dan Fragmen hanya bergantung pada model tampilan.  Repositori adalah satu-satunya kelas yang bergantung pada banyak kelas lainnya;  dalam contoh ini, penyimpanan tergantung pada model data yang persisten dan sumber data internal jarak jauh. <br><br>  Pola desain ini menciptakan pengalaman pengguna yang konsisten dan menyenangkan.  Terlepas dari apakah pengguna kembali ke aplikasi beberapa menit setelah menutupnya atau beberapa hari kemudian, ia akan langsung melihat informasi pengguna bahwa aplikasi tersebut disimpan secara lokal.  Jika data ini kedaluwarsa, modul penyimpanan aplikasi mulai memperbarui data di latar belakang. <br><br><h3>  Buat antarmuka pengguna </h3><br>  Antarmuka pengguna terdiri dari fragmen <code>UserProfileFragment</code> dan <code>user_profile_layout.xml</code> layout <code>user_profile_layout.xml</code> sesuai. <br><br>  Untuk mengelola antarmuka pengguna, model data kami harus berisi elemen data berikut: <br><br><ul><li>  <b>ID Pengguna:</b> ID pengguna.  Solusi terbaik adalah meneruskan informasi ini ke fragmen menggunakan argumen fragmen.  Jika OS Android menghancurkan proses kami, informasi ini disimpan, sehingga pengidentifikasi akan tersedia saat berikutnya kami meluncurkan aplikasi kami. </li><li>  <b>Objek pengguna:</b> kelas data yang berisi informasi pengguna. </li></ul><br>  Kami menggunakan <code>UserProfileViewModel</code> berdasarkan pada komponen arsitektur ViewModel untuk menyimpan informasi ini. <br><br>  <i><u>Objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ViewModel</a> menyediakan data untuk komponen antarmuka pengguna tertentu, seperti fragmen atau Kegiatan, dan berisi logika pemrosesan data bisnis untuk berinteraksi dengan model.</u></i>  <i><u>Misalnya, <b>ViewModel</b> dapat memanggil komponen lain untuk memuat data dan dapat meneruskan permintaan pengguna untuk perubahan data.</u></i>  <i><u><b>ViewModel</b> tidak tahu tentang komponen-komponen antarmuka pengguna, sehingga tidak terpengaruh oleh perubahan konfigurasi, seperti menciptakan kembali Aktivitas saat perangkat diputar.</u></i> <br><br>  Sekarang kami telah mengidentifikasi file-file berikut: <br><br><ul><li>  <code>user_profile.xml</code> : tata letak antarmuka pengguna yang ditentukan. </li><li>  <code>UserProfileFragment</code> : menggambarkan pengontrol antarmuka pengguna yang bertanggung jawab untuk menampilkan informasi kepada pengguna. </li><li>  <code>UserProfileViewModel</code> : kelas yang bertanggung jawab untuk menyiapkan data untuk ditampilkan di <code>UserProfileFragment</code> dan menanggapi interaksi pengguna. </li></ul><br>  Cuplikan kode berikut menunjukkan konten awal dari file-file ini.  (File tata letak dihilangkan karena kesederhanaan.) <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : User = TODO() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> viewModel: UserProfileViewModel <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> viewModels() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( inflater: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LayoutInflater</span></span></span></span><span class="hljs-function"><span class="hljs-params">, container: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span>: View { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inflater.inflate(R.layout.main_fragment, container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } }</code> </pre> <br>  Sekarang kita memiliki modul kode ini, bagaimana kita menghubungkannya?  Setelah bidang pengguna diatur dalam kelas UserProfileViewModel, kita perlu cara untuk memberi tahu antarmuka pengguna. <br><br>  <i><b>Catatan</b></i>  <i>SavedStateHandle memungkinkan ViewModel untuk mengakses keadaan tersimpan dan argumen dari fragmen atau tindakan yang terkait.</i> <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UserProfileViewModel class UserProfileViewModel( savedStateHandle: SavedStateHandle ) : ViewModel() { val userId : String = savedStateHandle["uid"] ?: throw IllegalArgumentException("missing user id") val user : User = TODO() } // UserProfileFragment private val viewModel: UserProfileViewModel by viewModels( factoryProducer = { SavedStateVMFactory(this) } ... )</span></span></code> </pre> <br>  Sekarang kita perlu memberi tahu Fragmen kita ketika objek pengguna diterima.  Di sinilah komponen arsitektur LiveData muncul. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LiveData</a> adalah pemegang data yang dapat diamati.  Komponen lain dalam aplikasi Anda dapat melacak perubahan pada objek menggunakan dudukan ini, tanpa membuat jalur ketergantungan yang eksplisit dan sulit di antara mereka.  Komponen LiveData juga memperhitungkan keadaan siklus hidup komponen aplikasi Anda, seperti Aktivitas, Fragmen, dan Layanan, dan termasuk logika pembersihan untuk mencegah kebocoran objek dan konsumsi memori yang berlebihan. <br><br>  <i>Catatan</i>  <i>Jika Anda sudah menggunakan pustaka seperti RxJava atau Agera, Anda bisa terus menggunakannya daripada LiveData.</i>  <i>Namun, saat menggunakan perpustakaan dan pendekatan serupa, pastikan Anda menangani siklus hidup aplikasi Anda dengan benar.</i>  <i>Secara khusus, pastikan bahwa Anda menangguhkan aliran data Anda ketika LifecycleOwner terkait dihentikan, dan hancurkan aliran ini ketika LifecycleOwner terkait telah dihancurkan.</i>  <i>Anda juga dapat menambahkan artifact android.arch.lifecycle: jet stream untuk menggunakan LiveData dengan pustaka aliran jet lain seperti RxJava2.</i> <br><br>  Untuk memasukkan komponen LiveData dalam aplikasi kami, kami mengubah jenis bidang di <code>UserProfileViewModel</code> menjadi LiveData.  <code>UserProfileFragment</code> sekarang diinformasikan tentang pembaruan data.  Selain itu, karena bidang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LiveData</a> ini mendukung siklus masa pakai, bidang ini secara otomatis menghapus tautan saat tidak diperlukan lagi. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span></span>( savedStateHandle: SavedStateHandle ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = savedStateHandle[<span class="hljs-string"><span class="hljs-string">"uid"</span></span>] ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"missing user id"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : LiveData&lt;User&gt; = TODO() }</code> </pre> <br>  Sekarang kami memodifikasi <code>UserProfileFragment</code> untuk mengamati data dalam <code>ViewModel</code> dan memperbarui antarmuka pengguna sesuai dengan perubahan: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) viewModel.user.observe(viewLifecycleOwner) { <span class="hljs-comment"><span class="hljs-comment">//  UI } }</span></span></code> </pre> <br>  Setiap kali data profil pengguna diperbarui, panggilan balik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">onChanged ()</a> dipanggil dan antarmuka pengguna diperbarui. <br><br>  Jika Anda terbiasa dengan perpustakaan lain yang menggunakan panggilan balik yang dapat diobservasi, Anda mungkin telah menyadari bahwa kami tidak mendefinisikan kembali metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">onStop ()</a> dari fragmen untuk berhenti mengamati data.  Langkah ini opsional untuk LiveData karena mendukung siklus hidup, yang berarti tidak akan memanggil panggilan balik <code>onChanged()</code> jika fragmennya dalam keadaan tidak aktif;  yaitu, ia menerima panggilan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">onStart ()</a> , tetapi belum menerima <code>onStop()</code> ).  LiveData juga secara otomatis menghapus pengamat saat memanggil metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">onDestroy ()</a> pada fragmen. <br><br>  Kami belum menambahkan logika apa pun untuk menangani perubahan konfigurasi, seperti memutar layar perangkat oleh pengguna.  <code>UserProfileViewModel</code> secara otomatis dikembalikan ketika konfigurasi diubah, sehingga segera setelah sebuah fragmen baru dibuat, ia mendapat instance <code>ViewModel</code> sama, dan panggilan balik dipanggil segera menggunakan data saat ini.  Mengingat bahwa objek <code>ViewModel</code> dirancang untuk bertahan dari objek <code>View</code> terkait yang mereka perbarui, Anda tidak boleh menyertakan referensi langsung ke objek <code>View</code> dalam implementasi ViewModel Anda.  Untuk informasi lebih lanjut tentang masa pakai <code>ViewModel</code> sesuai dengan siklus hidup komponen antarmuka pengguna, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Siklus hidup ViewModel.</a> <br><br><h3>  Pengambilan data </h3><br>  Sekarang kita telah menggunakan LiveData untuk menghubungkan <code>UserProfileViewModel</code> ke <code>UserProfileFragment</code> , bagaimana kita bisa mendapatkan data profil pengguna? <br><br>  Dalam contoh ini, kami menganggap bahwa backend kami menyediakan API REST.  Kami menggunakan pustaka Retrofit untuk mengakses backend kami, meskipun Anda dapat menggunakan pustaka yang berbeda yang memiliki tujuan yang sama. <br><br>  Berikut adalah definisi kami tentang layanan Web yang menautkan ke backend kami: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Webservice</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@GET</span></span></span><span class="hljs-comment"> declares an HTTP GET request * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@Path</span></span></span><span class="hljs-comment">("user") annotation on the userId parameter marks it as a * replacement for the {user} placeholder in the </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@GET</span></span></span><span class="hljs-comment"> path */</span></span> <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/users/{user}"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Path(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"user"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Call&lt;User&gt; }</code> </pre> <br>  Ide pertama untuk mengimplementasikan <code>ViewModel</code> mungkin melibatkan memanggil layanan Web <code>Webservice</code> untuk mengambil data dan menetapkan data itu ke objek <code>LiveData</code> kami.  Desain ini berfungsi, tetapi menggunakannya membuat aplikasi kita lebih sulit untuk dipertahankan seiring pertumbuhannya.  Ini memberikan terlalu banyak tanggung jawab kepada kelas <code>UserProfileViewModel</code> , yang melanggar prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemisahan kepentingan</a> .  Selain itu, ruang lingkup ViewModel dikaitkan dengan siklus hidup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aktivitas</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fragmen</a> , yang berarti bahwa data dari layanan Web hilang ketika siklus hidup objek antarmuka pengguna terkait berakhir.  Perilaku ini menciptakan pengalaman pengguna yang tidak diinginkan. <br><br>  Alih-alih, <code>ViewModel</code> kami mendelegasikan proses pengambilan data ke modul penyimpanan baru. <br><br>  <u><i>Modul <b>repositori</b> menangani operasi data.</i></u>  <u><i>Mereka menyediakan API bersih sehingga sisa aplikasi dapat dengan mudah mendapatkan data ini.</i></u>  <u><i>Mereka tahu di mana mendapatkan data dan panggilan API apa yang harus dilakukan saat memperbarui data.</i></u>  <u><i>Anda dapat menganggap repositori sebagai perantara antara berbagai sumber data, seperti model persisten, layanan web, dan cache.</i></u> <br><br>  Kelas <code>UserRepository</code> kami, ditampilkan dalam cuplikan kode berikut, menggunakan instance <code>WebService</code> untuk mengambil data pengguna: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> webservice: Webservice = TODO() <span class="hljs-comment"><span class="hljs-comment">// ... fun getUser(userId: String): LiveData&lt;User&gt; { //    .    . val data = MutableLiveData&lt;User&gt;() webservice.getUser(userId).enqueue(object : Callback&lt;User&gt; { override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) { data.value = response.body() } //     . override fun onFailure(call: Call&lt;User&gt;, t: Throwable) { TODO() } }) return data } }</span></span></code> </pre> <br>  Meskipun modul penyimpanan tampaknya tidak perlu, itu melayani tujuan penting: itu abstrak sumber data dari sisa aplikasi.  Sekarang <code>UserProfileViewModel</code> kami tidak tahu cara mengambil data, sehingga kami dapat menyediakan model presentasi dengan data yang diperoleh dari beberapa implementasi ekstraksi data yang berbeda. <br><br>  <b>Catatan</b>  Kami melewatkan kasus kesalahan jaringan karena kesederhanaan.  Untuk implementasi alternatif yang mengekspos kesalahan dan status unduhan, lihat Lampiran: Pengungkapan Status Jaringan. <br><br>  <b>Mengelola Ketergantungan antar Komponen</b> <br><br>  Kelas <code>UserRepository</code> atas membutuhkan turunan dari layanan Web untuk mengambil data pengguna.  Dia hanya bisa membuat contoh, tetapi untuk ini dia juga perlu tahu dependensi kelas layanan Web.  Selain itu, <code>UserRepository</code> mungkin bukan satu-satunya kelas yang membutuhkan layanan web.  Situasi ini mengharuskan kami untuk menduplikasi kode, karena setiap kelas yang membutuhkan tautan ke layanan Web perlu tahu cara membuatnya dan ketergantungannya.  Jika setiap kelas membuat <code>WebService</code> baru, aplikasi kita bisa menjadi sangat padat sumber daya. <br><br>  Untuk mengatasi masalah ini, Anda dapat menggunakan pola desain berikut: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ketergantungan Injeksi (DI)</a> .  Injeksi ketergantungan memungkinkan kelas untuk menentukan dependensi mereka tanpa membuatnya.  Pada saat run time, kelas lain bertanggung jawab untuk menyediakan dependensi ini.  Kami merekomendasikan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dagger 2</a> untuk menerapkan injeksi ketergantungan pada aplikasi Android.  Belati 2 secara otomatis membuat objek, melewati pohon dependensi, dan memberikan jaminan waktu kompilasi untuk dependensi. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(Lokasi layanan) Lokasi layanan</a> : Templat lokasi layanan menyediakan registri di mana kelas bisa mendapatkan dependensi mereka alih-alih membangunnya. </li></ul><br>  Menerapkan registri layanan lebih mudah daripada menggunakan DI, jadi jika Anda baru mengenal DI, gunakan templat: lokasi layanan sebagai gantinya. <br><br>  Templat ini memungkinkan Anda untuk menskalakan kode Anda karena mereka memberikan templat yang jelas untuk mengelola dependensi tanpa menduplikasi atau menyulitkan kode.  Selain itu, template ini memungkinkan Anda untuk dengan cepat beralih antara pengujian dan implementasi pengambilan sampel data. <br><br>  Aplikasi sampel kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Belati 2</a> untuk mengelola dependensi objek layanan Web. <br><br><h3>  Hubungkan ViewModel dan Penyimpanan </h3><br>  Sekarang kita memodifikasi <code>UserProfileViewModel</code> kita untuk menggunakan objek <code>UserRepository</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( savedStateHandle: SavedStateHandle, userRepository: UserRepository ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = savedStateHandle[<span class="hljs-string"><span class="hljs-string">"uid"</span></span>] ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"missing user id"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : LiveData&lt;User&gt; = userRepository.getUser(userId) }</code> </pre> <br><h3>  Caching </h3><br>  Implementasi <code>UserRepository</code> mengabstraksi permohonan objek layanan Web, tetapi karena hanya bergantung pada satu sumber data, itu tidak terlalu fleksibel. <br><br>  Masalah utama dengan implementasi <code>UserRepository</code> adalah bahwa setelah menerima data dari backend kami, data ini tidak disimpan di mana pun.  Oleh karena itu, jika pengguna meninggalkan <code>UserProfileFragment</code> dan kemudian kembali ke sana, aplikasi kita harus mengambil data, bahkan jika mereka tidak berubah. <br><br>  Desain ini tidak optimal karena alasan berikut: <br><br><ul><li>  Ini menghabiskan sumber daya lalu lintas yang berharga. </li><li>  Hal ini membuat pengguna menunggu penyelesaian permintaan baru. </li></ul><br>  Untuk mengatasi kekurangan ini, kami menambahkan sumber data baru ke <code>UserRepository</code> kami, yang menyimpan benda-benda <code>User</code> dalam memori: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Dagger,        . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, //    .    . private val userCache: UserCache ) { fun getUser(userId: String): LiveData&lt;User&gt; { val cached = userCache.get(userId) if (cached != null) { return cached } val data = MutableLiveData&lt;User&gt;() userCache.put(userId, data) //     ,  ,  . //      . webservice.getUser(userId).enqueue(object : Callback&lt;User&gt; { override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) { data.value = response.body() } //     . override fun onFailure(call: Call&lt;User&gt;, t: Throwable) { TODO() } }) return data } }</span></span></code> </pre> <br><h3>  Data persisten </h3><br>  Menggunakan implementasi kami saat ini, jika pengguna memutar perangkat atau pergi dan segera kembali ke aplikasi, antarmuka pengguna yang ada menjadi segera terlihat, karena toko mengambil data dari cache kami di memori. <br><br>  Namun, apa yang terjadi jika pengguna meninggalkan aplikasi dan kembali beberapa jam setelah OS Android menyelesaikan prosesnya?  Mengandalkan implementasi kami saat ini dalam situasi ini, kami perlu mendapatkan data dari jaringan lagi.  Proses peningkatan ini bukan hanya pengalaman pengguna yang buruk;  itu juga boros karena mengkonsumsi data seluler yang berharga. <br><br>  Anda dapat memecahkan masalah ini dengan melakukan caching permintaan web, tetapi ini menciptakan masalah baru yang utama: apa yang terjadi jika data pengguna yang sama ditampilkan dalam permintaan dari jenis yang berbeda, misalnya, saat menerima daftar teman?  Aplikasi akan menampilkan data yang saling bertentangan, yang paling membingungkan.  Misalnya, aplikasi kami dapat menampilkan dua versi data yang berbeda dari pengguna yang sama jika pengguna mengirim permintaan daftar teman dan permintaan satu pengguna pada waktu yang berbeda.  Aplikasi kita harus mencari cara untuk menggabungkan data yang bertentangan ini. <br><br>  Cara yang tepat untuk menghadapi situasi ini adalah dengan menggunakan model konstan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Room</a> Permanent Data Library (DB) siap membantu kami. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Room</a> adalah perpustakaan pemetaan objek yang menyediakan penyimpanan data lokal dengan kode standar minimum.  Pada waktu kompilasi, ia memeriksa setiap permintaan untuk kepatuhan dengan skema data Anda, sehingga permintaan SQL yang rusak menghasilkan kesalahan selama kompilasi, dan tidak crash saat runtime.  Ruang abstrak dari beberapa detail implementasi dasar dari tabel dan kueri SQL mentah.  Ini juga memungkinkan Anda untuk mengamati perubahan dalam data database, termasuk koleksi dan permintaan koneksi, mengekspos perubahan tersebut menggunakan objek LiveData.  Itu bahkan secara eksplisit mendefinisikan kendala eksekusi yang memecahkan masalah threading umum, seperti akses ke penyimpanan di utas utama. <br><br>  <i><b>Catatan</b></i>  <i>Jika aplikasi Anda sudah menggunakan solusi lain, seperti SQLite Object Relational Mapping (ORM), Anda tidak perlu mengganti solusi yang ada dengan Room.</i>  <i>Namun, jika Anda menulis aplikasi baru atau mengatur ulang aplikasi yang sudah ada, sebaiknya gunakan Kamar untuk menyimpan data aplikasi Anda.</i>  <i>Dengan demikian, Anda dapat memanfaatkan abstraksi perpustakaan dan verifikasi kueri.</i> <br><br>  Untuk menggunakan Kamar, kita perlu mendefinisikan tata letak lokal kita.  Pertama, kami menambahkan penjelasan @Entity ke kelas model data <code>User</code> kami dan penjelasan <code>@PrimaryKey</code> di bidang <code>id</code> kelas.  Anotasi ini menandai <code>User</code> sebagai tabel dalam basis data kami, dan <code>id</code> sebagai kunci utama tabel: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>( <span class="hljs-meta"><span class="hljs-meta">@PrimaryKey</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String )</code> </pre> <br>  Kemudian kami membuat kelas database dengan mengimplementasikan <code>RoomDatabase</code> untuk aplikasi kami: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Database(entities = [User::class], version = 1)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDatabase</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoomDatabase</span></span></span></span>()</code> </pre> <br>  Perhatikan bahwa <code>UserDatabase</code> abstrak.  Pustaka Room secara otomatis menyediakan implementasi ini.  Lihat dokumentasi untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kamar</a> untuk detailnya. <br><br>  Sekarang kita membutuhkan cara untuk memasukkan data pengguna ke dalam basis data.  Untuk tugas ini, kami membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">objek akses data (DAO)</a> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Dao</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Insert(onConflict = REPLACE)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-meta"><span class="hljs-meta">@Query(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SELECT * FROM user WHERE id = :userId"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(userId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: LiveData&lt;User&gt; }</code> </pre> <br>  Perhatikan bahwa metode <code>load</code> mengembalikan objek bertipe LiveData.  Kamar tahu kapan database diubah, dan secara otomatis memberi tahu semua pengamat aktif tentang perubahan data.  Karena Room menggunakan <i>LiveData</i> , operasi ini efisien;  itu memperbarui data hanya jika ada setidaknya satu pengamat aktif. <br><br>  <i><b>Catatan:</b> Pemeriksaan kamar untuk pembatalan berdasarkan modifikasi tabel, yang berarti dapat mengirim pemberitahuan positif palsu.</i> <br><br>  Setelah mendefinisikan kelas <code>UserDao</code> kami, kami kemudian merujuk DAO dari kelas basis data kami: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Database(entities = [User::class], version = 1)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDatabase</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoomDatabase</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userDao</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: UserDao }</code> </pre> <br>  Sekarang kita dapat mengubah <code>UserRepository</code> kita untuk memasukkan sumber data Room: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  Dagger,         . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, //    .    . private val executor: Executor, private val userDao: UserDao ) { fun getUser(userId: String): LiveData&lt;User&gt; { refreshUser(userId) //   LiveData    . return userDao.load(userId) } private fun refreshUser(userId: String) { //    . executor.execute { // ,      . val userExists = userDao.hasUser(FRESH_TIMEOUT) if (!userExists) { //  . val response = webservice.getUser(userId).execute() //    . //   .  LiveData  , //        . userDao.save(response.body()!!) } } } companion object { val FRESH_TIMEOUT = TimeUnit.DAYS.toMillis(1) } }</span></span></code> </pre> <br>  Harap perhatikan bahwa meskipun kami mengubah sumber data dalam <code>UserRepository</code> , kami tidak perlu mengubah <code>UserProfileViewModel</code> atau <code>UserProfileFragment</code> .  Pembaruan kecil ini menunjukkan fleksibilitas yang disediakan arsitektur aplikasi kami.  Ini juga bagus untuk pengujian karena kami dapat menyediakan <code>UserRepository</code> palsu dan menguji <code>UserProfileViewModel</code> produksi kami secara bersamaan. <br><br>  Jika pengguna kembali dalam beberapa hari, maka aplikasi yang menggunakan arsitektur ini kemungkinan akan menampilkan informasi yang sudah ketinggalan zaman sampai repositori menerima informasi yang diperbarui.  Tergantung pada kasus penggunaan Anda, Anda mungkin tidak menampilkan informasi yang ketinggalan zaman.  Alih-alih, Anda bisa menampilkan data <i>placeholder</i> , yang menunjukkan nilai dummy dan menunjukkan bahwa aplikasi Anda sedang memuat dan memuat informasi terbaru. <br><br> <b>  </b> <br><br>     REST API      . ,        ,    ,              API, ,      .   <code>UserRepository</code>     <code>Webservice</code>  ,   ,        ,               . <br><br>      <code>UserRepository</code>   -   .            <i>LiveData</i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Menggunakan model ini, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">database berfungsi sebagai satu-satunya sumber kebenaran</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan bagian lain dari aplikasi mengaksesnya melalui kita </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Terlepas dari apakah Anda menggunakan cache disk, kami menyarankan repositori Anda mengidentifikasi sumber data sebagai satu-satunya sumber kebenaran untuk sisa aplikasi Anda.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tampilkan kemajuan operasi </font></font></h3><br>    ,   pull-to-refresh, ,     ,       .        ,       . ,     ,         ,     LiveData.     ,      —      ,         <code>User</code> . <br><br>                   ,      : <br><br><ul><li>  <code>getUser ()</code> ,      <code>LiveData</code> .         .  ,   NetworkBoundResource   GitHub <a href="">android-Architecture-components</a> . </li><li>       <code>UserRepository</code> ,      .    ,              ,         ,   pull-to-refresh. </li></ul><br><h3>    </h3><br>       ,          . <br><br>    ,         : <br><br><ul><li> <b>   </b> :  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> Android UI </a> .      —   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Espresso</a> .         <code>UserProfileViewModel</code> .      <code>UserProfileViewModel</code> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">()</a>           . </li><li> <b>ViewModel:</b>     <code>UserProfileViewModel</code>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JUnit</a> .      , <code>UserRepository</code> . </li><li> <b>UserRepository:</b>     <code>UserRepository</code>    JUnit.    <code>Webservice</code>  <code>UserDao</code> .      : <br><br><ul><li>     -. </li><li>      . </li><li>     ,     . </li></ul><br></li><li>   <code>Webservice</code> ,  <code>UserDao</code>  ,             . </li><li> <b>UserDao:</b>   DAO    .       -   ,   .        ,  ,      ,        … <br><br> <i><b>:</b> Room     ,    DAO,   JSQL  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SupportSQLiteOpenHelper</a></b> .     ,      SQLite     SQLite   .</i> </li><li> <b>-:</b>         .   ,  -,      .  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/square/ok">MockWebServer</a> ,          . </li><li> <b> :</b>     maven    .    <code>androidx.arch.core</code> :    JUnit: <br><br><ul><li> <code>InstantTaskExecutorRule:</code>            . </li><li> <code>CountingTaskExecutorRule:</code>         .        Espresso     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </li></ul><br></li></ul><br><h2>   </h2><br>  —   ,     Android   .     ,         ,          ,      ,     . <br><br>      ,   ,         ,      : <br><br> <b>      —   ,     —    .</b> <br><br>           ,    ,     .     ,             . <br><br> <b>        .</b> <br><br> ,   ,     ,         .         —        —   . <br><br> <b>      .</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tahan godaan untuk membuat label “hanya satu” yang mengungkapkan detail implementasi internal dari satu modul. Anda mungkin mendapatkan waktu dalam jangka pendek, tetapi kemudian Anda akan mengalami hutang teknis beberapa kali seiring basis kode Anda berkembang. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pikirkan tentang bagaimana membuat setiap modul dapat diuji secara terpisah.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Misalnya, memiliki API yang terdefinisi dengan baik untuk mengambil data dari jaringan membuatnya mudah untuk menguji modul yang menyimpan data ini dalam database lokal. Jika sebaliknya Anda mencampur logika kedua modul ini di satu tempat atau mendistribusikan kode jaringan Anda di seluruh basis kode, pengujian menjadi jauh lebih sulit - dalam beberapa kasus bahkan tidak mustahil. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fokus pada inti unik aplikasi Anda untuk menonjol dari aplikasi lain.</font></font></b> <br><br>    ,         .         ,     ,     Android        . <br><br> <b>       .</b> <br><br>  ,      ,        . ,         . <br><br> <b>      .</b> <br><br>  ,         ,         . <br><br><h3> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahan: pengungkapan status jaringan</font></font></u> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian di atas arsitektur aplikasi yang direkomendasikan, kami melewatkan kesalahan jaringan dan status boot untuk menyederhanakan cuplikan kode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian ini menunjukkan cara menampilkan status jaringan menggunakan kelas Sumber Daya, yang merangkum data dan kondisinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuplikan kode berikut memberikan contoh implementasi</font></font><code>Resource:</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,         . sealed class Resource&lt;T&gt;( val data: T? = null, val message: String? = null ) { class Success&lt;T&gt;(data: T) : Resource&lt;T&gt;(data) class Loading&lt;T&gt;(data: T? = null) : Resource&lt;T&gt;(data) class Error&lt;T&gt;(message: String, data: T? = null) : Resource&lt;T&gt;(data, message) }</span></span></code> </pre> <br>             ,    ,       .         <code>NetworkBoundResource</code> . <br><br>        <code>NetworkBoundResource</code> : <br><br><img src="https://habrastorage.org/webt/e1/wv/c9/e1wvc9un_w2t8jyi0kiky8wagw0.png"><br><br>         .         , <code>NetworkBoundResource</code> ,     ,     ,       .  ,       , ,  , ,         . <br><br>     ,          .      <code>NetworkBoundResource</code>   . <br><br> <code><b>.</b>             .       ,       .</code> <br> <br>   ,               ,    ,         ,      ,     . <br><br>  ,   ,   ,       .   , ,    ,        .      `SUCCESS`   ,        . <br><br>       API,   <code>NetworkBoundResource</code>   : <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// ResultType:   . // RequestType:   API. abstract class NetworkBoundResource&lt;ResultType, RequestType&gt; { //      API   . @WorkerThread protected abstract fun saveCallResult(item: RequestType) //      ,  ,    //     . @MainThread protected abstract fun shouldFetch(data: ResultType?): Boolean //        . @MainThread protected abstract fun loadFromDb(): LiveData&lt;ResultType&gt; //     API. @MainThread protected abstract fun createCall(): LiveData&lt;ApiResponse&lt;RequestType&gt;&gt; // ,    .   //    ,    . protected open fun onFetchFailed() {} //   LiveData,  , //    . fun asLiveData(): LiveData&lt;ResultType&gt; = TODO() }</span></span></code> </pre> <br>        : <br><br><ul><li>     , <code>ResultType</code>  <code>RequestType</code> ,   ,   API,     ,  . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini menggunakan kelas </font></font><code>ApiResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk permintaan jaringan. </font></font><code>ApiResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merupakan pembungkus sederhana untuk kelas </font></font><code>Retrofit2.Call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mengubah respons menjadi instance </font></font><code>LiveData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi penuh kelas </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muncul sebagai bagian dari proyek </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">android-Architecture-komponen GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah dibuat, </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita dapat menggunakannya untuk menulis disk dan implementasi yang terlampir </font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada jaringan di kelas </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  Dagger2,         . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, private val userDao: UserDao ) { fun getUser(userId: String): LiveData&lt;User&gt; { return object : NetworkBoundResource&lt;User, User&gt;() { override fun saveCallResult(item: User) { userDao.save(item) } override fun shouldFetch(data: User?): Boolean { return rateLimiter.canFetch(userId) &amp;&amp; (data == null || !isFresh(data)) } override fun loadFromDb(): LiveData&lt;User&gt; { return userDao.load(userId) } override fun createCall(): LiveData&lt;ApiResponse&lt;User&gt;&gt; { return webservice.getUser(userId) } }.asLiveData() } }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456256/">https://habr.com/ru/post/id456256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456240/index.html">Pengembangan chatbot (laravel + botman)</a></li>
<li><a href="../id456242/index.html">Sedikit lagi tentang multitasking dalam mikrokontroler</a></li>
<li><a href="../id456246/index.html">Elemen nol</a></li>
<li><a href="../id456248/index.html">Bagaimana saya menangkap: sebelum gaya untuk elemen fokus</a></li>
<li><a href="../id456250/index.html">Lokalisasi aplikasi dan dukungan RTL. Laporkan Yandex.Taxi</a></li>
<li><a href="../id456258/index.html">Gratis seperti angin dan gratis sebagai bir terjemahan "Gratis seperti dalam Kebebasan" ke dalam bahasa Rusia di bawah lisensi GNU FDL 1.3</a></li>
<li><a href="../id456260/index.html">Pembicaraan Ekonomi yang Adil</a></li>
<li><a href="../id456262/index.html">Software Defined Radio - bagaimana cara kerjanya? Bagian 9</a></li>
<li><a href="../id456264/index.html">Buat file biner Android menggunakan sumber dan Android NDK. Kami memompa utilitas screencap</a></li>
<li><a href="../id456266/index.html">Intisari materi menarik untuk pengembang ponsel # 302 (pada 10 - 16 Juni)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>