<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèø üë≠ üíº Preload in PHP 7.4: Composer und Auswahl von Dateien f√ºr das Preload üë®üèª‚Äçüè≠ ü•ó üöæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir bei Badoo stellen aktiv auf PHP 7.4 um und sind sehr begeistert von der M√∂glichkeit, die neue Preload-Funktion zu nutzen. Vor nicht allzu langer Z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Preload in PHP 7.4: Composer und Auswahl von Dateien f√ºr das Preload</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/480746/">  Wir bei Badoo stellen aktiv auf PHP 7.4 um und sind sehr begeistert von der M√∂glichkeit, die neue Preload-Funktion zu nutzen.  Vor nicht allzu langer Zeit haben wir √ºber unsere Experimente mit ihr gesprochen. <br><br>  Anscheinend ist die Community genauso aufgeregt wie wir.  Framework-Entwickler <a href="https://github.com/laravel/ideas/issues/1406">diskutieren</a> aktiv <a href="https://github.com/laravel/ideas/issues/1406">die</a> M√∂glichkeit der Einf√ºhrung eines Preloads (und einige haben dies bereits <a href="https://symfony.com/blog/new-in-symfony-4-4-preloading-symfony-applications-in-php-7-4">unterst√ºtzt</a> ).  Jetzt ist der Abh√§ngigkeitsmanager von Composer an der Reihe. <br><br><img src="https://habrastorage.org/webt/t2/b9/bm/t2b9bmzxxtkxl00vu23lyoqwnd4.png"><br><br>  <a href="https://medium.com/%40DarkGhostHunter">Italo Baeza</a> schrieb <a href="https://medium.com/swlh/composer-how-it-should-preload-in-php-7-4-3f8d19fda40">einen Artikel,</a> in dem er seine Meinung dar√ºber √§u√üerte, wie Composer mit der Vorspannung arbeiten sollte.  Ich beschloss, eine √úbersetzung dieses Textes und gleichzeitig eine √úbersetzung <a href="https://medium.com/swlh/preloading-your-php-7-4-project-in-one-line-9ede756f292c">seines anderen Artikels</a> dar√ºber zu teilen, wie die Composer-Entwickler selbst auf den Vorschlag geantwortet haben, sowie √ºber ein neues Tool, das die Arbeit mit dem Preload erleichtert. <br><a name="habracut"></a><br><h2>  Wie sollte Composer in PHP 7.4 vorinstalliert werden? </h2><br>  Preload ist eine der wichtigen Funktionen, die PHP 7.4 Entwicklern bietet, die eine bessere Leistung ben√∂tigen.  Diese Funktion kann als "Aufw√§rmen" bezeichnet werden, bevor die JIT-Engine implementiert wird, die in PHP 8 angezeigt wird (oder angezeigt werden sollte). Vorher reicht das Vorabladen aus, und wer wei√ü, vielleicht k√∂nnen sie zusammenarbeiten. <br><br>  Was die Vorladefunktion ist, wird in <a href="https://stitcher.io/blog/preloading-in-php-74">diesem Artikel erkl√§rt</a> .  Das Fazit ist sehr einfach: php.ini gibt ein PHP-Skript an, f√ºr das beim Start des Prozesses Dateien in den Speicher geladen werden (Preload).  In Kombination mit OPCache und der Autoloader-Funktion <a href="https://medium.com/tech-tajawal/php-composer-the-autoloader-d676a2f103aa">k√∂nnen</a> Composer-Dateien auch einmal kompiliert und verkn√ºpft werden. Danach stehen sie f√ºr alle nachfolgenden Anforderungen zur Verf√ºgung.  Dadurch muss PHP nicht bei jeder Anforderung Dateien herunterladen und kompilieren. <br><br>  Die Composer-Entwickler haben sich jedoch nicht darauf geeinigt, wie das Vorladen zus√§tzlich zu den Startfunktionen unterst√ºtzt werden soll.  Die Fakten sind wie folgt: <br><br><ul><li>  Preloading wurde erstmals in PHP 7.4 angek√ºndigt; <br></li><li>  Es gibt keine Composer-Direktive, mit deren Hilfe Dateien vorab geladen werden k√∂nnen. <br></li><li>  Zum Vorabladen ben√∂tigen Sie Zugriff auf die php.ini, dh auf den Prozess selbst. <br></li><li>  Durch das Vorladen aller Dateien wird die Leistung nicht unbedingt verbessert, verglichen mit dem Vorladen nur der am h√§ufigsten angeforderten Dateien. <br></li></ul><br>  Mit anderen Worten, nur diejenigen, die vollen Zugriff auf die Server haben, k√∂nnen das Preloading verwenden.  Dies schlie√üt gemeinsam genutzte Server und einige PaaS-L√∂sungen aus, bei denen nicht mit php.ini gearbeitet wird. <br><br>  Wie kann Composer beim Vorladen helfen, da dies eine Innovation ist?  Hier ist meine Meinung. <br><br><h2>  Wie sollte die Vorspannung funktionieren? </h2><br>  Der Mechanismus zum Vorabladen sollte auf einer Liste von Dateien basieren, die beim Start <i>geladen</i> und im Speicher abgelegt werden.  Und da dies eine Liste ist, m√ºssen wir mit einem Array von Dateien arbeiten und Composer die ganze Arbeit √ºberlassen, anstatt jede Datei manuell zu <i>laden</i> . <br><br>  Composer sollte die Liste der von der Anwendung angegebenen Dateien (das Stammprojekt) nehmen und alles in Dateien kompilieren, die PHP problemlos verwenden kann. <br>  Gleichzeitig m√ºssen wir in der Lage sein, Pakete zum Preload-Mechanismus hinzuzuf√ºgen und daraus zu entfernen. <br>  Das Vorladen sollte niemals auf Paketebene funktionieren, da es in der Verantwortung des Entwicklers liegt, das Vorladen jedes Pakets zu aktivieren oder zu deaktivieren. <br><br>  Das Vorladen in Composer sollte optional sein.  Der Entwickler muss in der Lage sein, es zu deaktivieren, damit PHP seinen eigenen Preloader verwendet, der auf der Grundlage der OPCache-Analyse arbeiten kann. Er h√§ngt von der Anwendungslast ab und arbeitet wesentlich effizienter als das einfache Vorladen aller Dateien. <br><br><h3>  Alles beginnt bei preload.json </h3><br>  Um das System nicht zu komplizieren, legen Sie die Datei preload.json im Stammverzeichnis des Projekts ab.  Daraufhin werden die Vorladedateien aufgelistet, die Composer ausw√§hlen kann.  Da es sich um eine JSON-Datei handelt, kann der Entwickler sie mithilfe eines speziellen Befehls generieren.  Ich denke, es w√§re gro√üartig, wenn Composer ein Hilfsprogramm zum Erstellen einer solchen skriptbasierten JSON-Datei h√§tte. <br><br><pre><code class="php hljs">{ <span class="hljs-string"><span class="hljs-string">"pre-compile"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"my-script.php"</span></span>, <span class="hljs-string"><span class="hljs-string">"my-other-script.php"</span></span> ], <span class="hljs-string"><span class="hljs-string">"extensions"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"php"</span></span> ], <span class="hljs-string"><span class="hljs-string">"files"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"app/*"</span></span>, <span class="hljs-string"><span class="hljs-string">"config/"</span></span>, <span class="hljs-string"><span class="hljs-string">"helpers.php"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/Models/*"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/Controllers/*/Http/*"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/Views/Compiled*.php"</span></span> ], <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"App\\Models"</span></span>, <span class="hljs-string"><span class="hljs-string">"App\\Controllers\\"</span></span>, <span class="hljs-string"><span class="hljs-string">"App\\Views\\MainView"</span></span>, <span class="hljs-string"><span class="hljs-string">"Vendor\\Package\\*"</span></span>, ], <span class="hljs-string"><span class="hljs-string">"packages"</span></span>: { <span class="hljs-string"><span class="hljs-string">"symfony/http-client"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">"robert/*-client"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">"vendor/package"</span></span>: { <span class="hljs-string"><span class="hljs-string">"files"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"foo/bar"</span></span>: { <span class="hljs-string"><span class="hljs-string">"files"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"helpers.php"</span></span>, <span class="hljs-string"><span class="hljs-string">"loaders/*"</span></span> ], <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"Foo\\Bar\\DynamicLoaders\\*"</span></span>, <span class="hljs-string"><span class="hljs-string">"Foo\\Bar\\Clients"</span></span> ] } }, <span class="hljs-string"><span class="hljs-string">"output"</span></span>: <span class="hljs-string"><span class="hljs-string">"preload-compiled.php"</span></span> }</code> </pre> <br>  Mit preload.json k√∂nnen Sie schnell √ºberpr√ºfen, ob das Vorladen im Projekt enthalten ist: Wenn die Datei fehlt, wird das Vorladen nicht unterst√ºtzt oder ist unerw√ºnscht. <br><br>  Mal sehen, was die Tasten tun. <br><br>  <b>vorkompilieren</b> <br><br>  Diese Dateien werden von Composer ausgef√ºhrt.  Jedes Skript muss ein Array absoluter Dateipfade zur√ºckgeben, um sie der Preload-Liste hinzuzuf√ºgen, die die Rolle der Hauptliste √ºbernimmt. <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"pre-compile"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"my-script.php"</span></span>, <span class="hljs-string"><span class="hljs-string">"my-other-script.php"</span></span> ]</code> </pre><br>  Diese Dateien werden in der angegebenen Reihenfolge ausgef√ºhrt. <br><br>  Ziel ist es, dass der Entwickler eine Liste von Dateien erstellt, die er f√ºr richtig h√§lt, anstatt sich auf eine einzelne JSON-Datei zu verlassen.  Diese Dateien werden zuerst ausgef√ºhrt.  Und ja, Sie k√∂nnen preload.json nur mit diesem Schl√ºssel implementieren.  Da es sich um PHP-Dateien handelt, k√∂nnen Sie beim Kompilieren eines Arrays sogar andere Dateien hinzuf√ºgen. <br><br>  <b>Erweiterungen</b> <br><br>  Dies ist eine Liste der Dateierweiterungen, die vorab geladen werden m√ºssen.  Standardm√§√üig werden nur Dateien mit der PHP-Erweiterung verwendet. <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"extensions"</span></span>: [<span class="hljs-string"><span class="hljs-string">"php"</span></span>, <span class="hljs-string"><span class="hljs-string">"php5"</span></span>, <span class="hljs-string"><span class="hljs-string">"php7"</span></span>]</code> </pre> <br>  Sie k√∂nnen beispielsweise ein Verzeichnis hinzuf√ºgen, das mit * .phtml-Dateien gef√ºllt ist, einschlie√ülich einiger n√ºtzlicher PHP-Dateien, und Composer w√§hlt nur diese und nicht den gesamten Inhalt des Verzeichnisses aus. <br>  Wie Sie verstehen, kann dieser Vorgang durch manuelles Hinzuf√ºgen von Dateien ersetzt werden. <br><br>  <b>Dateien</b> <br><br>  Dieser Schl√ºssel weist Composer an, alle Dateien aus der Liste herunterzuladen, deren Pfade sich auf den Speicherort von composer.json beziehen. <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"files"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"helpers.php"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/Models/*"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/Controllers/*/Http/*"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/Views/Compiled*.php"</span></span>, ]</code> </pre><br>  Die Liste herauszufinden ist einfach: <br><br><ul><li>  Verwenden Sie relative Pfade, um Dateien und Verzeichnisse hinzuzuf√ºgen. <br></li><li>  Aus Verzeichnissen werden nur untergeordnete Dateien hinzugef√ºgt (nicht rekursiv). <br></li><li>  rekursive Pfade werden durch ein Sternchen (*) gekennzeichnet; <br></li><li>  Mit diesem Symbol k√∂nnen Sie beispielsweise auch bestimmte Dateien und Verzeichnisse hinzuf√ºgen: <code>src/Clients/*/Stores</code> oder <code>src/Model*.php</code> . <br></li></ul><br>  Das Hinzuf√ºgen von Dateien per Maske ohne manuelle Auswahl oder Erstellung von anwendungsspezifischen Skripten ist besonders n√ºtzlich, wenn Sie gro√üe Anwendungen entwickeln. <br><br>  Wenn Sie nur alle Dateien mit <a href="">dem Autoload-Schl√ºssel</a> in der Composer-JSON-Datei vorab laden m√ºssen, setzen Sie ihn auf <code>true</code> . <br><br>  <b>Namespace</b> <br><br>  Dieser Schl√ºssel weist Composer an, Dateien mit einem bestimmten Namespace oder Klassennamen wie <code>file</code> oder <code>directory</code> zu laden.  Mit demselben Mechanismus k√∂nnen Sie Space-Namen aus anderen installierten Paketen dynamisch aufrufen. <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"namespaces"</span></span>: [   <span class="hljs-string"><span class="hljs-string">"App\\Models"</span></span>,   <span class="hljs-string"><span class="hljs-string">"App\\Controllers\\"</span></span>,   <span class="hljs-string"><span class="hljs-string">"App\\Views\\MainView"</span></span>,   <span class="hljs-string"><span class="hljs-string">"Vendor\\Package\\*"</span></span>, ]</code> </pre> <br>  Dies ist auch praktisch, wenn Sie mit gro√üen Anwendungen arbeiten, die st√§rker von Namespaces abh√§ngig sind, als von Dateien, die sich jederzeit √§ndern k√∂nnen.  Composer extrahiert Dateien automatisch gem√§√ü dem Namespace und f√ºgt sie in eine Liste ein. <br><br>  <b>Pakete</b> <br><br>  Mit diesem Schl√ºssel k√∂nnen Sie andere Dateien laden, die aus externen Paketen registriert wurden, z. B. Hilfsdateien oder Klassen, die einem Namespace zugeordnet sind. <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"packages"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"symfony/http-client"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>,   <span class="hljs-string"><span class="hljs-string">"robert/*-client"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>,   <span class="hljs-string"><span class="hljs-string">"vendor/package"</span></span>: {       <span class="hljs-string"><span class="hljs-string">"files"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>,       <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>   },   <span class="hljs-string"><span class="hljs-string">"foo/bar"</span></span>: {       <span class="hljs-string"><span class="hljs-string">"files"</span></span>: {           <span class="hljs-string"><span class="hljs-string">"helpers.php"</span></span>,           <span class="hljs-string"><span class="hljs-string">"loaders/*"</span></span>       },       <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>: [           <span class="hljs-string"><span class="hljs-string">"Foo\\Bar\\DynamicLoaders\\*"</span></span>,           <span class="hljs-string"><span class="hljs-string">"Foo\\Bar\\Clients"</span></span>       ]   } }</code> </pre> <br>  Hier ist alles ganz einfach: Wenn der Wert true ist, wird der gesamte Inhalt <a href="">des Autoload-Schl√ºssels</a> in der Datei composer.json dieses Pakets geladen.  Andernfalls k√∂nnen Sie die Vorspannungsaddition genauer steuern. <br><br>  Wenn der Schl√ºsselwert true ist, werden alle beim <code>autoload</code> Laden registrierten Dateien heruntergeladen.  Der Standardwert ist <code>false</code> .  Dies gilt auch f√ºr den <code>namespace</code> Schl√ºssel. <br><br>  Sie k√∂nnen mit dieser Regel auch einzelne Dateien oder Namespaces ausw√§hlen.  In diesem Fall wird der <code>autoload</code> Schl√ºssel jedoch nicht verwendet. <br><br>  <b>Ausgabe</b> <br><br>  Dies ist einfach der Name der kompilierten Preload-Listendatei. <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"output"</span></span>: <span class="hljs-string"><span class="hljs-string">"preload-compiled.php"</span></span></code> </pre> <br><h3>  Einfache Montage </h3><br>  Unsere Preload-Liste ist fertig und wir k√∂nnen Composer aufrufen, um das Haupt-Preload-Skript zu kompilieren. <br><br><pre> <code class="php hljs">composer preload</code> </pre> <br>  Infolgedessen wird preload-compiled.php mit allen Dateien erstellt, die PHP vorladen muss.  Nat√ºrlich k√∂nnen Sie den Dateinamen beliebig √§ndern. <br><br>  Sie m√ºssen auch die <code>preload</code> Schl√ºssel <code>preload</code> Parametern √ºberschreiben. <br><br><pre> <code class="php hljs">composer preload \   --input=my-custom-preload-<span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.json \   --output=my-preload.php</code> </pre> <br><h3>  Standardm√§√üig deaktiviert </h3><br>  Projekte ohne preload.json geben einen Fehler zur√ºck, wenn Sie versuchen, eine Datei zum Vorladen zu kompilieren.  Der Grund daf√ºr ist, dass Composer nicht erraten wird (und sollte), was vorinstalliert werden soll. <br><br>  Ich m√∂chte Sie daran erinnern, dass das Vorladen die normale Funktionalit√§t von Composer nicht beeintr√§chtigt.  Da dies ein Konsolenbefehl ist, k√∂nnen Sie bei lokaler Entwicklung das Vorladen vollst√§ndig abbrechen.  Das einzige, was der Composer-Vorlademechanismus ben√∂tigt, ist eine Autoload-Datei, die generiert werden sollte, wenn sie fehlt.  Immerhin ist fast das 2020. Jahr in der Werft, PSR-4 wird √ºberall eingesetzt, oder? <br><br><h3>  Ergebnis </h3><br>  Sie sollten eine PHP-Datei mit so etwas bekommen: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/** * Preloading </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@generated</span></span></span><span class="hljs-comment"> by Composer */</span></span> <span class="hljs-comment"><span class="hljs-comment">// Autoload the classes so those can be preloaded using `require_once`. require_once __DIR__.'/../autoload.php'; // File list $files = [ '/var/www/app/Foo.php', '/var/www/app/Bar.php', '/var/www/helpers/basic.php', '/var/www/helpers/advanced.php', '/var/www/vendor/Foo/Bar/src/Class.php', '/var/www/vendor/Foo/Bar/helpers/helpers.php', '/var/www/vendor/Foo/Bar/config.php', // ... ]; // Preload all root project files foreach ($files as $file) { require_once $file; }</span></span></code> </pre> <br>  Tats√§chlich ist dies nur eine Liste von Dateien, die mithilfe der Autoloader-Funktion in Composer vorgeladen werden.  PHP wird diese Datei einmal ausf√ºhren und es wird Geschichte. <br><hr><br>  Ich hoffe aufrichtig, dass Composer die M√∂glichkeit hat, Dateien vorab zu laden, ohne einen Hack schreiben zu m√ºssen. <br><br>  Da die oben beschriebene Methode nicht Teil des Composer-Kernels ist, k√∂nnen Sie dennoch die wichtigsten Dateien f√ºr das Vorladen auf der Grundlage der OPCache-Analyse ausw√§hlen, ohne die weniger ben√∂tigten zu ber√ºhren.  Anstatt 1.500 Dateien mit einer Kapazit√§t von 100 MB vorab zu laden, k√∂nnen Sie nur 150 Dateien mit einer Kapazit√§t von 10 MB herunterladen und dabei 99% der urspr√ºnglichen Leistung beibehalten. <br><br><h2>  Wir laden das PHP 7.4-Projekt in einer Zeile vor </h2><br>  Kurz nachdem ich einen Artikel dar√ºber geschrieben hatte, wie Composer Sie beim <a href="https://github.com/Seldaek">Vorabladen</a> eines Projekts unterst√ºtzen kann, hat <a href="https://github.com/Seldaek">Seldaek</a> (ein Mitglied des Composer-Entwicklungsteams) <a href="https://github.com/composer/composer/issues/7777">die Hoffnung</a> <a href="https://github.com/Seldaek">zunichte gemacht</a> <a href="https://github.com/composer/composer/issues/7777">,</a> dass Composer eine einfache Option zum Vorabladen des Projekts in den PHP-Prozess vom Paket-Manager aus haben w√ºrde. <br><br><blockquote>  (...) Ich werde erkl√§ren: Ich bin mir sicher, dass wir in naher Zukunft nichts hinzuf√ºgen werden, was mit dem Vorladen von Composer zu tun hat. </blockquote><br>  Warum?  Das Vorabladen in PHP ist eher ein Entwicklungsproblem (als ein Abh√§ngigkeitsproblem) und wird durch manuelles Bearbeiten der Datei php.ini gel√∂st. Dies k√∂nnen nur Entwickler, die PHP selbst verwalten. <br><br>  Dies hindert mich jedoch nicht daran, ein eigenes Paket zum Vorabladen des Projekts zu erstellen.  Und du auch. <br><br><h2>  Vorspannung und Metriken </h2><br>  Das Vorladen kann ein gutes Werkzeug f√ºr eine <a href="https://wiki.php.net/rfc/preload">einfache und kosteng√ºnstige</a> Steigerung der Produktivit√§t ohne ernsthafte Verarbeitung sein. <br><br>  Aber das Problem ist nicht, <i>wie man</i> vorl√§dt, sondern <i>was</i> .  Durch das Vorladen ganzer Frameworks und Tausender von Dateien wird der Arbeitsspeicher schnell ersch√∂pft, sodass es zumindest in gro√üen Projekten nicht m√∂glich ist, dies blind zu tun.  Es wird empfohlen, nur die am h√§ufigsten angeforderten Dateien herunterzuladen.  Aber wie definiert man sie? <br><br>  Gl√ºcklicherweise erm√∂glicht <a href="https://www.php.net/manual/en/function.opcache-get-status.php">OPCache opcache_get_status ()</a> , Daten dar√ºber zu sammeln, auf welche Dateien am h√§ufigsten zugegriffen wird.  Sie k√∂nnen nicht nur herausfinden, welche Dateien am meisten nachgefragt werden, sondern auch, wie viel Speicher sie einige Zeit nach dem Start der Anwendung verbrauchen. <br><br>  Es wird empfohlen, entweder eine Woche oder bis zu dem Zeitpunkt zu warten, an dem OPCache eine bestimmte Anzahl von Treffern registriert.  Es h√§ngt alles von der Anwendung ab, aber Sie bekommen den Punkt. <br>  Erstellen wir also eine Preload-Liste basierend auf den Statistiken der beliebtesten Dateien.  Ich habe ein Paket daf√ºr gemacht. <br><br><h2>  Stellen Sie sich vor ... Preloader! </h2><br>  Dieses Paket erstellt automatisch eine Vorladeliste f√ºr Ihre Anwendung.  Es werden OPCache-Nutzungsstatistiken erfasst, die Dateien nach der Anzahl der Treffer sortiert und eine Liste erstellt, sodass die Gesamtdateigr√∂√üe den angegebenen Schwellenwert nicht √ºberschreitet. <br><br><img src="https://habrastorage.org/webt/sm/1b/vi/sm1bvipjlzifwjfc4evvvpaqaau.png"><br><br>  Ich habe lange nach der besten Strategie f√ºr die Erstellung einer Liste gesucht.  Und ich bin zu dem Schluss gekommen, dass es am besten ist, alle Dateien hinzuzuf√ºgen, bis das Speicherlimit erreicht ist, das f√ºr Pakete standardm√§√üig 32 MB betr√§gt.  Dateien werden nach der Anzahl der Treffer sortiert und das Paket wird automatisch ausgeschlossen. <br><br>  Mit anderen Worten, PHP verbessert die Anwendungsleistung bei der Verarbeitung der meisten Anfragen. <br><br>  Und wie benutzt man es?  Teilen Sie Composer Autoloader mit, wo das Preloader-Skript geschrieben werden soll, und fertig. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">DarkGhostHunter</span></span>\<span class="hljs-title"><span class="hljs-title">Preloader</span></span>\<span class="hljs-title"><span class="hljs-title">Preloader</span></span>; Preloader::make() -&gt;autoload(<span class="hljs-string"><span class="hljs-string">'vendor/autoload.php'</span></span>) -&gt;output(<span class="hljs-string"><span class="hljs-string">'preload.php'</span></span>) -&gt;generate();</code> </pre><br>  Nat√ºrlich m√ºssen Sie ausw√§hlen, wann generiert werden soll, aber das ist der springende Punkt.  Sie k√∂nnen dies sogar nach dem Zufallsprinzip tun und die Liste beispielsweise f√ºr jede 100. Anforderung neu schreiben. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">DarkGhostHunter</span></span>\<span class="hljs-title"><span class="hljs-title">Preloader</span></span>\<span class="hljs-title"><span class="hljs-title">Preloader</span></span>; Preloader::make() -&gt;whenOneIn(<span class="hljs-number"><span class="hljs-number">100</span></span>) -&gt;autoload(<span class="hljs-string"><span class="hljs-string">'vendor/autoload.php'</span></span>) -&gt;output(<span class="hljs-string"><span class="hljs-string">'preload.php'</span></span>) -&gt;overwrite() -&gt;generate();</code> </pre><br>  Sie erhalten ein fertiges Preload-Skript, das Sie in die php.ini einf√ºgen k√∂nnen. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/** * This file is generated automatically by Preloader. * * This script uses Composer Autoload file and `require_once` to preload the files in this * list. Add this file to your `php.ini` in `opcache.preload` to preload this list into * PHP at startup. Additionally, this file also includes information about Opcache. * * * Add (or update) this line in `php.ini`: * * opcache.preload=/www/app/vendor/preload.php * * --- Config --- * Generated at: 2019-11-20 15:20:49 UTC * Opcache * - Used Memory: 130585 B * - Free Memory: 294896 B * - Wasted Memory: 347764 B * - Cached files: 2675 * - Hit rate: 94% * - Misses: 542 * Preloader config * - Memory limit: 32 MB * - Overwrite: false * - Files excluded: 0 * - Files appended: 0 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'/www/app/vendor/autoload.php'</span></span>; $files = [ <span class="hljs-string"><span class="hljs-string">'/www/app/ClassFoo.php'</span></span>, <span class="hljs-string"><span class="hljs-string">'/www/app/ClassBar.php'</span></span>, <span class="hljs-string"><span class="hljs-string">'/www/app/ClassBaz.php'</span></span>, <span class="hljs-string"><span class="hljs-string">'/www/app/ClassQuz.php'</span></span>, <span class="hljs-string"><span class="hljs-string">'/www/app/ClassQux.php'</span></span>, <span class="hljs-string"><span class="hljs-string">'/www/app/vendor/author/package/src/Example.php'</span></span>, <span class="hljs-comment"><span class="hljs-comment">// ... ]; foreach ($files as $file) { require_once $file; }</span></span></code> </pre><br>  Und alle.  Probieren Sie es aus: <a href="https://packagist.org/packages/darkghosthunter/preloader%3Fsource%3Dpost_page-----9ede756f292c----------------------">darkghosthunter / preloader - Packagist</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480746/">https://habr.com/ru/post/de480746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480730/index.html">Auto-Moto-Entwicklung und Nginx</a></li>
<li><a href="../de480734/index.html">Als TestMace ist besser als Postman</a></li>
<li><a href="../de480736/index.html">Warum m√ºssen nicht alle Fehler korrigiert werden, um ein IT-Produkt zu verbessern?</a></li>
<li><a href="../de480740/index.html">4 coole Numpy Features, die ich st√§ndig benutze</a></li>
<li><a href="../de480744/index.html">Wie kann ein Programmierer sein Lieblingsprojekt sch√ºtzen?</a></li>
<li><a href="../de480748/index.html">Warum brauchen Sie so viele Entwickler?</a></li>
<li><a href="../de480752/index.html">ICANN stellt Verkauf der .ORG-Domainzone ein</a></li>
<li><a href="../de480754/index.html">Chaos-Management: Bereinigen Sie mit Routing</a></li>
<li><a href="../de480756/index.html">Daten √∂ffnen. Roscosmos. Machen wir es wie in der NASA</a></li>
<li><a href="../de480760/index.html">Arbeiten im Ausland: In welchen L√§ndern ist das schnellste Internet?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>