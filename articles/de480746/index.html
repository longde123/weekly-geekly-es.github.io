<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏿 👭 💼 Preload in PHP 7.4: Composer und Auswahl von Dateien für das Preload 👨🏻‍🏭 🥗 🚾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir bei Badoo stellen aktiv auf PHP 7.4 um und sind sehr begeistert von der Möglichkeit, die neue Preload-Funktion zu nutzen. Vor nicht allzu langer Z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Preload in PHP 7.4: Composer und Auswahl von Dateien für das Preload</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/480746/">  Wir bei Badoo stellen aktiv auf PHP 7.4 um und sind sehr begeistert von der Möglichkeit, die neue Preload-Funktion zu nutzen.  Vor nicht allzu langer Zeit haben wir über unsere Experimente mit ihr gesprochen. <br><br>  Anscheinend ist die Community genauso aufgeregt wie wir.  Framework-Entwickler <a href="https://github.com/laravel/ideas/issues/1406">diskutieren</a> aktiv <a href="https://github.com/laravel/ideas/issues/1406">die</a> Möglichkeit der Einführung eines Preloads (und einige haben dies bereits <a href="https://symfony.com/blog/new-in-symfony-4-4-preloading-symfony-applications-in-php-7-4">unterstützt</a> ).  Jetzt ist der Abhängigkeitsmanager von Composer an der Reihe. <br><br><img src="https://habrastorage.org/webt/t2/b9/bm/t2b9bmzxxtkxl00vu23lyoqwnd4.png"><br><br>  <a href="https://medium.com/%40DarkGhostHunter">Italo Baeza</a> schrieb <a href="https://medium.com/swlh/composer-how-it-should-preload-in-php-7-4-3f8d19fda40">einen Artikel,</a> in dem er seine Meinung darüber äußerte, wie Composer mit der Vorspannung arbeiten sollte.  Ich beschloss, eine Übersetzung dieses Textes und gleichzeitig eine Übersetzung <a href="https://medium.com/swlh/preloading-your-php-7-4-project-in-one-line-9ede756f292c">seines anderen Artikels</a> darüber zu teilen, wie die Composer-Entwickler selbst auf den Vorschlag geantwortet haben, sowie über ein neues Tool, das die Arbeit mit dem Preload erleichtert. <br><a name="habracut"></a><br><h2>  Wie sollte Composer in PHP 7.4 vorinstalliert werden? </h2><br>  Preload ist eine der wichtigen Funktionen, die PHP 7.4 Entwicklern bietet, die eine bessere Leistung benötigen.  Diese Funktion kann als "Aufwärmen" bezeichnet werden, bevor die JIT-Engine implementiert wird, die in PHP 8 angezeigt wird (oder angezeigt werden sollte). Vorher reicht das Vorabladen aus, und wer weiß, vielleicht können sie zusammenarbeiten. <br><br>  Was die Vorladefunktion ist, wird in <a href="https://stitcher.io/blog/preloading-in-php-74">diesem Artikel erklärt</a> .  Das Fazit ist sehr einfach: php.ini gibt ein PHP-Skript an, für das beim Start des Prozesses Dateien in den Speicher geladen werden (Preload).  In Kombination mit OPCache und der Autoloader-Funktion <a href="https://medium.com/tech-tajawal/php-composer-the-autoloader-d676a2f103aa">können</a> Composer-Dateien auch einmal kompiliert und verknüpft werden. Danach stehen sie für alle nachfolgenden Anforderungen zur Verfügung.  Dadurch muss PHP nicht bei jeder Anforderung Dateien herunterladen und kompilieren. <br><br>  Die Composer-Entwickler haben sich jedoch nicht darauf geeinigt, wie das Vorladen zusätzlich zu den Startfunktionen unterstützt werden soll.  Die Fakten sind wie folgt: <br><br><ul><li>  Preloading wurde erstmals in PHP 7.4 angekündigt; <br></li><li>  Es gibt keine Composer-Direktive, mit deren Hilfe Dateien vorab geladen werden können. <br></li><li>  Zum Vorabladen benötigen Sie Zugriff auf die php.ini, dh auf den Prozess selbst. <br></li><li>  Durch das Vorladen aller Dateien wird die Leistung nicht unbedingt verbessert, verglichen mit dem Vorladen nur der am häufigsten angeforderten Dateien. <br></li></ul><br>  Mit anderen Worten, nur diejenigen, die vollen Zugriff auf die Server haben, können das Preloading verwenden.  Dies schließt gemeinsam genutzte Server und einige PaaS-Lösungen aus, bei denen nicht mit php.ini gearbeitet wird. <br><br>  Wie kann Composer beim Vorladen helfen, da dies eine Innovation ist?  Hier ist meine Meinung. <br><br><h2>  Wie sollte die Vorspannung funktionieren? </h2><br>  Der Mechanismus zum Vorabladen sollte auf einer Liste von Dateien basieren, die beim Start <i>geladen</i> und im Speicher abgelegt werden.  Und da dies eine Liste ist, müssen wir mit einem Array von Dateien arbeiten und Composer die ganze Arbeit überlassen, anstatt jede Datei manuell zu <i>laden</i> . <br><br>  Composer sollte die Liste der von der Anwendung angegebenen Dateien (das Stammprojekt) nehmen und alles in Dateien kompilieren, die PHP problemlos verwenden kann. <br>  Gleichzeitig müssen wir in der Lage sein, Pakete zum Preload-Mechanismus hinzuzufügen und daraus zu entfernen. <br>  Das Vorladen sollte niemals auf Paketebene funktionieren, da es in der Verantwortung des Entwicklers liegt, das Vorladen jedes Pakets zu aktivieren oder zu deaktivieren. <br><br>  Das Vorladen in Composer sollte optional sein.  Der Entwickler muss in der Lage sein, es zu deaktivieren, damit PHP seinen eigenen Preloader verwendet, der auf der Grundlage der OPCache-Analyse arbeiten kann. Er hängt von der Anwendungslast ab und arbeitet wesentlich effizienter als das einfache Vorladen aller Dateien. <br><br><h3>  Alles beginnt bei preload.json </h3><br>  Um das System nicht zu komplizieren, legen Sie die Datei preload.json im Stammverzeichnis des Projekts ab.  Daraufhin werden die Vorladedateien aufgelistet, die Composer auswählen kann.  Da es sich um eine JSON-Datei handelt, kann der Entwickler sie mithilfe eines speziellen Befehls generieren.  Ich denke, es wäre großartig, wenn Composer ein Hilfsprogramm zum Erstellen einer solchen skriptbasierten JSON-Datei hätte. <br><br><pre><code class="php hljs">{ <span class="hljs-string"><span class="hljs-string">"pre-compile"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"my-script.php"</span></span>, <span class="hljs-string"><span class="hljs-string">"my-other-script.php"</span></span> ], <span class="hljs-string"><span class="hljs-string">"extensions"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"php"</span></span> ], <span class="hljs-string"><span class="hljs-string">"files"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"app/*"</span></span>, <span class="hljs-string"><span class="hljs-string">"config/"</span></span>, <span class="hljs-string"><span class="hljs-string">"helpers.php"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/Models/*"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/Controllers/*/Http/*"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/Views/Compiled*.php"</span></span> ], <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"App\\Models"</span></span>, <span class="hljs-string"><span class="hljs-string">"App\\Controllers\\"</span></span>, <span class="hljs-string"><span class="hljs-string">"App\\Views\\MainView"</span></span>, <span class="hljs-string"><span class="hljs-string">"Vendor\\Package\\*"</span></span>, ], <span class="hljs-string"><span class="hljs-string">"packages"</span></span>: { <span class="hljs-string"><span class="hljs-string">"symfony/http-client"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">"robert/*-client"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">"vendor/package"</span></span>: { <span class="hljs-string"><span class="hljs-string">"files"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"foo/bar"</span></span>: { <span class="hljs-string"><span class="hljs-string">"files"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"helpers.php"</span></span>, <span class="hljs-string"><span class="hljs-string">"loaders/*"</span></span> ], <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"Foo\\Bar\\DynamicLoaders\\*"</span></span>, <span class="hljs-string"><span class="hljs-string">"Foo\\Bar\\Clients"</span></span> ] } }, <span class="hljs-string"><span class="hljs-string">"output"</span></span>: <span class="hljs-string"><span class="hljs-string">"preload-compiled.php"</span></span> }</code> </pre> <br>  Mit preload.json können Sie schnell überprüfen, ob das Vorladen im Projekt enthalten ist: Wenn die Datei fehlt, wird das Vorladen nicht unterstützt oder ist unerwünscht. <br><br>  Mal sehen, was die Tasten tun. <br><br>  <b>vorkompilieren</b> <br><br>  Diese Dateien werden von Composer ausgeführt.  Jedes Skript muss ein Array absoluter Dateipfade zurückgeben, um sie der Preload-Liste hinzuzufügen, die die Rolle der Hauptliste übernimmt. <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"pre-compile"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"my-script.php"</span></span>, <span class="hljs-string"><span class="hljs-string">"my-other-script.php"</span></span> ]</code> </pre><br>  Diese Dateien werden in der angegebenen Reihenfolge ausgeführt. <br><br>  Ziel ist es, dass der Entwickler eine Liste von Dateien erstellt, die er für richtig hält, anstatt sich auf eine einzelne JSON-Datei zu verlassen.  Diese Dateien werden zuerst ausgeführt.  Und ja, Sie können preload.json nur mit diesem Schlüssel implementieren.  Da es sich um PHP-Dateien handelt, können Sie beim Kompilieren eines Arrays sogar andere Dateien hinzufügen. <br><br>  <b>Erweiterungen</b> <br><br>  Dies ist eine Liste der Dateierweiterungen, die vorab geladen werden müssen.  Standardmäßig werden nur Dateien mit der PHP-Erweiterung verwendet. <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"extensions"</span></span>: [<span class="hljs-string"><span class="hljs-string">"php"</span></span>, <span class="hljs-string"><span class="hljs-string">"php5"</span></span>, <span class="hljs-string"><span class="hljs-string">"php7"</span></span>]</code> </pre> <br>  Sie können beispielsweise ein Verzeichnis hinzufügen, das mit * .phtml-Dateien gefüllt ist, einschließlich einiger nützlicher PHP-Dateien, und Composer wählt nur diese und nicht den gesamten Inhalt des Verzeichnisses aus. <br>  Wie Sie verstehen, kann dieser Vorgang durch manuelles Hinzufügen von Dateien ersetzt werden. <br><br>  <b>Dateien</b> <br><br>  Dieser Schlüssel weist Composer an, alle Dateien aus der Liste herunterzuladen, deren Pfade sich auf den Speicherort von composer.json beziehen. <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"files"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"helpers.php"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/Models/*"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/Controllers/*/Http/*"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/Views/Compiled*.php"</span></span>, ]</code> </pre><br>  Die Liste herauszufinden ist einfach: <br><br><ul><li>  Verwenden Sie relative Pfade, um Dateien und Verzeichnisse hinzuzufügen. <br></li><li>  Aus Verzeichnissen werden nur untergeordnete Dateien hinzugefügt (nicht rekursiv). <br></li><li>  rekursive Pfade werden durch ein Sternchen (*) gekennzeichnet; <br></li><li>  Mit diesem Symbol können Sie beispielsweise auch bestimmte Dateien und Verzeichnisse hinzufügen: <code>src/Clients/*/Stores</code> oder <code>src/Model*.php</code> . <br></li></ul><br>  Das Hinzufügen von Dateien per Maske ohne manuelle Auswahl oder Erstellung von anwendungsspezifischen Skripten ist besonders nützlich, wenn Sie große Anwendungen entwickeln. <br><br>  Wenn Sie nur alle Dateien mit <a href="">dem Autoload-Schlüssel</a> in der Composer-JSON-Datei vorab laden müssen, setzen Sie ihn auf <code>true</code> . <br><br>  <b>Namespace</b> <br><br>  Dieser Schlüssel weist Composer an, Dateien mit einem bestimmten Namespace oder Klassennamen wie <code>file</code> oder <code>directory</code> zu laden.  Mit demselben Mechanismus können Sie Space-Namen aus anderen installierten Paketen dynamisch aufrufen. <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"namespaces"</span></span>: [   <span class="hljs-string"><span class="hljs-string">"App\\Models"</span></span>,   <span class="hljs-string"><span class="hljs-string">"App\\Controllers\\"</span></span>,   <span class="hljs-string"><span class="hljs-string">"App\\Views\\MainView"</span></span>,   <span class="hljs-string"><span class="hljs-string">"Vendor\\Package\\*"</span></span>, ]</code> </pre> <br>  Dies ist auch praktisch, wenn Sie mit großen Anwendungen arbeiten, die stärker von Namespaces abhängig sind, als von Dateien, die sich jederzeit ändern können.  Composer extrahiert Dateien automatisch gemäß dem Namespace und fügt sie in eine Liste ein. <br><br>  <b>Pakete</b> <br><br>  Mit diesem Schlüssel können Sie andere Dateien laden, die aus externen Paketen registriert wurden, z. B. Hilfsdateien oder Klassen, die einem Namespace zugeordnet sind. <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"packages"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"symfony/http-client"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>,   <span class="hljs-string"><span class="hljs-string">"robert/*-client"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>,   <span class="hljs-string"><span class="hljs-string">"vendor/package"</span></span>: {       <span class="hljs-string"><span class="hljs-string">"files"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>,       <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>   },   <span class="hljs-string"><span class="hljs-string">"foo/bar"</span></span>: {       <span class="hljs-string"><span class="hljs-string">"files"</span></span>: {           <span class="hljs-string"><span class="hljs-string">"helpers.php"</span></span>,           <span class="hljs-string"><span class="hljs-string">"loaders/*"</span></span>       },       <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>: [           <span class="hljs-string"><span class="hljs-string">"Foo\\Bar\\DynamicLoaders\\*"</span></span>,           <span class="hljs-string"><span class="hljs-string">"Foo\\Bar\\Clients"</span></span>       ]   } }</code> </pre> <br>  Hier ist alles ganz einfach: Wenn der Wert true ist, wird der gesamte Inhalt <a href="">des Autoload-Schlüssels</a> in der Datei composer.json dieses Pakets geladen.  Andernfalls können Sie die Vorspannungsaddition genauer steuern. <br><br>  Wenn der Schlüsselwert true ist, werden alle beim <code>autoload</code> Laden registrierten Dateien heruntergeladen.  Der Standardwert ist <code>false</code> .  Dies gilt auch für den <code>namespace</code> Schlüssel. <br><br>  Sie können mit dieser Regel auch einzelne Dateien oder Namespaces auswählen.  In diesem Fall wird der <code>autoload</code> Schlüssel jedoch nicht verwendet. <br><br>  <b>Ausgabe</b> <br><br>  Dies ist einfach der Name der kompilierten Preload-Listendatei. <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"output"</span></span>: <span class="hljs-string"><span class="hljs-string">"preload-compiled.php"</span></span></code> </pre> <br><h3>  Einfache Montage </h3><br>  Unsere Preload-Liste ist fertig und wir können Composer aufrufen, um das Haupt-Preload-Skript zu kompilieren. <br><br><pre> <code class="php hljs">composer preload</code> </pre> <br>  Infolgedessen wird preload-compiled.php mit allen Dateien erstellt, die PHP vorladen muss.  Natürlich können Sie den Dateinamen beliebig ändern. <br><br>  Sie müssen auch die <code>preload</code> Schlüssel <code>preload</code> Parametern überschreiben. <br><br><pre> <code class="php hljs">composer preload \   --input=my-custom-preload-<span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.json \   --output=my-preload.php</code> </pre> <br><h3>  Standardmäßig deaktiviert </h3><br>  Projekte ohne preload.json geben einen Fehler zurück, wenn Sie versuchen, eine Datei zum Vorladen zu kompilieren.  Der Grund dafür ist, dass Composer nicht erraten wird (und sollte), was vorinstalliert werden soll. <br><br>  Ich möchte Sie daran erinnern, dass das Vorladen die normale Funktionalität von Composer nicht beeinträchtigt.  Da dies ein Konsolenbefehl ist, können Sie bei lokaler Entwicklung das Vorladen vollständig abbrechen.  Das einzige, was der Composer-Vorlademechanismus benötigt, ist eine Autoload-Datei, die generiert werden sollte, wenn sie fehlt.  Immerhin ist fast das 2020. Jahr in der Werft, PSR-4 wird überall eingesetzt, oder? <br><br><h3>  Ergebnis </h3><br>  Sie sollten eine PHP-Datei mit so etwas bekommen: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/** * Preloading </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@generated</span></span></span><span class="hljs-comment"> by Composer */</span></span> <span class="hljs-comment"><span class="hljs-comment">// Autoload the classes so those can be preloaded using `require_once`. require_once __DIR__.'/../autoload.php'; // File list $files = [ '/var/www/app/Foo.php', '/var/www/app/Bar.php', '/var/www/helpers/basic.php', '/var/www/helpers/advanced.php', '/var/www/vendor/Foo/Bar/src/Class.php', '/var/www/vendor/Foo/Bar/helpers/helpers.php', '/var/www/vendor/Foo/Bar/config.php', // ... ]; // Preload all root project files foreach ($files as $file) { require_once $file; }</span></span></code> </pre> <br>  Tatsächlich ist dies nur eine Liste von Dateien, die mithilfe der Autoloader-Funktion in Composer vorgeladen werden.  PHP wird diese Datei einmal ausführen und es wird Geschichte. <br><hr><br>  Ich hoffe aufrichtig, dass Composer die Möglichkeit hat, Dateien vorab zu laden, ohne einen Hack schreiben zu müssen. <br><br>  Da die oben beschriebene Methode nicht Teil des Composer-Kernels ist, können Sie dennoch die wichtigsten Dateien für das Vorladen auf der Grundlage der OPCache-Analyse auswählen, ohne die weniger benötigten zu berühren.  Anstatt 1.500 Dateien mit einer Kapazität von 100 MB vorab zu laden, können Sie nur 150 Dateien mit einer Kapazität von 10 MB herunterladen und dabei 99% der ursprünglichen Leistung beibehalten. <br><br><h2>  Wir laden das PHP 7.4-Projekt in einer Zeile vor </h2><br>  Kurz nachdem ich einen Artikel darüber geschrieben hatte, wie Composer Sie beim <a href="https://github.com/Seldaek">Vorabladen</a> eines Projekts unterstützen kann, hat <a href="https://github.com/Seldaek">Seldaek</a> (ein Mitglied des Composer-Entwicklungsteams) <a href="https://github.com/composer/composer/issues/7777">die Hoffnung</a> <a href="https://github.com/Seldaek">zunichte gemacht</a> <a href="https://github.com/composer/composer/issues/7777">,</a> dass Composer eine einfache Option zum Vorabladen des Projekts in den PHP-Prozess vom Paket-Manager aus haben würde. <br><br><blockquote>  (...) Ich werde erklären: Ich bin mir sicher, dass wir in naher Zukunft nichts hinzufügen werden, was mit dem Vorladen von Composer zu tun hat. </blockquote><br>  Warum?  Das Vorabladen in PHP ist eher ein Entwicklungsproblem (als ein Abhängigkeitsproblem) und wird durch manuelles Bearbeiten der Datei php.ini gelöst. Dies können nur Entwickler, die PHP selbst verwalten. <br><br>  Dies hindert mich jedoch nicht daran, ein eigenes Paket zum Vorabladen des Projekts zu erstellen.  Und du auch. <br><br><h2>  Vorspannung und Metriken </h2><br>  Das Vorladen kann ein gutes Werkzeug für eine <a href="https://wiki.php.net/rfc/preload">einfache und kostengünstige</a> Steigerung der Produktivität ohne ernsthafte Verarbeitung sein. <br><br>  Aber das Problem ist nicht, <i>wie man</i> vorlädt, sondern <i>was</i> .  Durch das Vorladen ganzer Frameworks und Tausender von Dateien wird der Arbeitsspeicher schnell erschöpft, sodass es zumindest in großen Projekten nicht möglich ist, dies blind zu tun.  Es wird empfohlen, nur die am häufigsten angeforderten Dateien herunterzuladen.  Aber wie definiert man sie? <br><br>  Glücklicherweise ermöglicht <a href="https://www.php.net/manual/en/function.opcache-get-status.php">OPCache opcache_get_status ()</a> , Daten darüber zu sammeln, auf welche Dateien am häufigsten zugegriffen wird.  Sie können nicht nur herausfinden, welche Dateien am meisten nachgefragt werden, sondern auch, wie viel Speicher sie einige Zeit nach dem Start der Anwendung verbrauchen. <br><br>  Es wird empfohlen, entweder eine Woche oder bis zu dem Zeitpunkt zu warten, an dem OPCache eine bestimmte Anzahl von Treffern registriert.  Es hängt alles von der Anwendung ab, aber Sie bekommen den Punkt. <br>  Erstellen wir also eine Preload-Liste basierend auf den Statistiken der beliebtesten Dateien.  Ich habe ein Paket dafür gemacht. <br><br><h2>  Stellen Sie sich vor ... Preloader! </h2><br>  Dieses Paket erstellt automatisch eine Vorladeliste für Ihre Anwendung.  Es werden OPCache-Nutzungsstatistiken erfasst, die Dateien nach der Anzahl der Treffer sortiert und eine Liste erstellt, sodass die Gesamtdateigröße den angegebenen Schwellenwert nicht überschreitet. <br><br><img src="https://habrastorage.org/webt/sm/1b/vi/sm1bvipjlzifwjfc4evvvpaqaau.png"><br><br>  Ich habe lange nach der besten Strategie für die Erstellung einer Liste gesucht.  Und ich bin zu dem Schluss gekommen, dass es am besten ist, alle Dateien hinzuzufügen, bis das Speicherlimit erreicht ist, das für Pakete standardmäßig 32 MB beträgt.  Dateien werden nach der Anzahl der Treffer sortiert und das Paket wird automatisch ausgeschlossen. <br><br>  Mit anderen Worten, PHP verbessert die Anwendungsleistung bei der Verarbeitung der meisten Anfragen. <br><br>  Und wie benutzt man es?  Teilen Sie Composer Autoloader mit, wo das Preloader-Skript geschrieben werden soll, und fertig. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">DarkGhostHunter</span></span>\<span class="hljs-title"><span class="hljs-title">Preloader</span></span>\<span class="hljs-title"><span class="hljs-title">Preloader</span></span>; Preloader::make() -&gt;autoload(<span class="hljs-string"><span class="hljs-string">'vendor/autoload.php'</span></span>) -&gt;output(<span class="hljs-string"><span class="hljs-string">'preload.php'</span></span>) -&gt;generate();</code> </pre><br>  Natürlich müssen Sie auswählen, wann generiert werden soll, aber das ist der springende Punkt.  Sie können dies sogar nach dem Zufallsprinzip tun und die Liste beispielsweise für jede 100. Anforderung neu schreiben. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">DarkGhostHunter</span></span>\<span class="hljs-title"><span class="hljs-title">Preloader</span></span>\<span class="hljs-title"><span class="hljs-title">Preloader</span></span>; Preloader::make() -&gt;whenOneIn(<span class="hljs-number"><span class="hljs-number">100</span></span>) -&gt;autoload(<span class="hljs-string"><span class="hljs-string">'vendor/autoload.php'</span></span>) -&gt;output(<span class="hljs-string"><span class="hljs-string">'preload.php'</span></span>) -&gt;overwrite() -&gt;generate();</code> </pre><br>  Sie erhalten ein fertiges Preload-Skript, das Sie in die php.ini einfügen können. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/** * This file is generated automatically by Preloader. * * This script uses Composer Autoload file and `require_once` to preload the files in this * list. Add this file to your `php.ini` in `opcache.preload` to preload this list into * PHP at startup. Additionally, this file also includes information about Opcache. * * * Add (or update) this line in `php.ini`: * * opcache.preload=/www/app/vendor/preload.php * * --- Config --- * Generated at: 2019-11-20 15:20:49 UTC * Opcache * - Used Memory: 130585 B * - Free Memory: 294896 B * - Wasted Memory: 347764 B * - Cached files: 2675 * - Hit rate: 94% * - Misses: 542 * Preloader config * - Memory limit: 32 MB * - Overwrite: false * - Files excluded: 0 * - Files appended: 0 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'/www/app/vendor/autoload.php'</span></span>; $files = [ <span class="hljs-string"><span class="hljs-string">'/www/app/ClassFoo.php'</span></span>, <span class="hljs-string"><span class="hljs-string">'/www/app/ClassBar.php'</span></span>, <span class="hljs-string"><span class="hljs-string">'/www/app/ClassBaz.php'</span></span>, <span class="hljs-string"><span class="hljs-string">'/www/app/ClassQuz.php'</span></span>, <span class="hljs-string"><span class="hljs-string">'/www/app/ClassQux.php'</span></span>, <span class="hljs-string"><span class="hljs-string">'/www/app/vendor/author/package/src/Example.php'</span></span>, <span class="hljs-comment"><span class="hljs-comment">// ... ]; foreach ($files as $file) { require_once $file; }</span></span></code> </pre><br>  Und alle.  Probieren Sie es aus: <a href="https://packagist.org/packages/darkghosthunter/preloader%3Fsource%3Dpost_page-----9ede756f292c----------------------">darkghosthunter / preloader - Packagist</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480746/">https://habr.com/ru/post/de480746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480730/index.html">Auto-Moto-Entwicklung und Nginx</a></li>
<li><a href="../de480734/index.html">Als TestMace ist besser als Postman</a></li>
<li><a href="../de480736/index.html">Warum müssen nicht alle Fehler korrigiert werden, um ein IT-Produkt zu verbessern?</a></li>
<li><a href="../de480740/index.html">4 coole Numpy Features, die ich ständig benutze</a></li>
<li><a href="../de480744/index.html">Wie kann ein Programmierer sein Lieblingsprojekt schützen?</a></li>
<li><a href="../de480748/index.html">Warum brauchen Sie so viele Entwickler?</a></li>
<li><a href="../de480752/index.html">ICANN stellt Verkauf der .ORG-Domainzone ein</a></li>
<li><a href="../de480754/index.html">Chaos-Management: Bereinigen Sie mit Routing</a></li>
<li><a href="../de480756/index.html">Daten öffnen. Roscosmos. Machen wir es wie in der NASA</a></li>
<li><a href="../de480760/index.html">Arbeiten im Ausland: In welchen Ländern ist das schnellste Internet?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>