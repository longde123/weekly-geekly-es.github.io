<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé¶ üë©üèª‚ÄçüöÄ üõ©Ô∏è Reflektierende Schattenkarten: Teil 2 - Implementierung üë®üèø‚Äçüöí üññüèª üöé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Dieser Artikel enth√§lt eine einfache Implementierung von Reflective Shadow Maps (der Algorithmus wurde in einem fr√ºheren Artikel beschrieb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reflektierende Schattenkarten: Teil 2 - Implementierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440570/">  Hallo Habr!  Dieser Artikel enth√§lt eine einfache Implementierung von <b>Reflective Shadow Maps</b> (der Algorithmus wurde in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel beschrieben</a> ).  Als n√§chstes werde ich erkl√§ren, wie ich es gemacht habe und welche Fallstricke es gab.  Einige m√∂gliche Optimierungen werden ebenfalls ber√ºcksichtigt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/80f/588/6da/80f5886da498099f2e9716d4c0a53e3d.png" alt="Bild"><br>  <i>Abbildung 1: Von links nach rechts: ohne RSM, mit RSM, Unterschied</i> <br><a name="habracut"></a><br><h2>  Ergebnis </h2><br>  In <i>Abbildung 1 sehen</i> Sie das mit <b>RSM</b> erzielte Ergebnis.  Zur Erstellung dieser Bilder wurden das ‚ÄûStanford Rabbit‚Äú und drei mehrfarbige Vierecke verwendet.  Im Bild links sehen Sie das Ergebnis des Renderns ohne <b>RSM</b> , wobei nur <b>Punktlicht verwendet wird</b> .  Alles im Schatten ist komplett schwarz.  Das Bild in der Mitte zeigt das Ergebnis mit <b>RSM</b> .  Folgende Unterschiede sind erkennbar: √úberall dort, wo es hellere Farben gibt, rosa, die den Boden und das Kaninchen √ºberfluten, ist die Schattierung nicht vollst√§ndig schwarz.  Das letzte Bild zeigt den Unterschied zwischen dem ersten und dem zweiten und damit den Beitrag von <b>RSM</b> .  Engere Kanten und Artefakte sind im mittleren Bild sichtbar. Dies kann jedoch durch Anpassen der Gr√∂√üe des Kerns, der Intensit√§t der indirekten Beleuchtung und der Anzahl der Proben behoben werden. <br><br><h2>  Implementierung </h2><br>  Der Algorithmus wurde auf einer eigenen Engine implementiert.  Die Shader sind in HLSL geschrieben, und das Rendern ist in DirectX 11. Ich habe bereits vor dem Schreiben dieses Artikels eine <b>verz√∂gerte Schattierung</b> und <b>Schattenzuordnung</b> f√ºr gerichtetes Licht (gerichtete Lichtquelle) eingerichtet.  Zuerst habe ich <b>RSM</b> f√ºr gerichtetes Licht implementiert und erst nachdem ich Unterst√ºtzung f√ºr die <b>Schattenkarte</b> und <b>RSM</b> f√ºr Punktlicht hinzugef√ºgt habe. <br><br><h3>  Schattenkartenerweiterung </h3><br>  Traditionell ist <b>Shadow Maps</b> (SM) nichts anderes als eine Tiefenkarte.  Dies bedeutet, dass Sie nicht einmal einen Pixel- / Fragment-Shader ben√∂tigen, um SM zu f√ºllen.  F√ºr <b>RSM</b> ben√∂tigen Sie jedoch einige zus√§tzliche Puffer.  Sie m√ºssen die Weltraumposition, die Weltraumnormalen und den <b>Fluss</b> (Lichtleistung) speichern.  Dies bedeutet, dass Sie einen Pixel- / Fragment-Shader mit mehreren Renderzielen ben√∂tigen.  Denken Sie daran, dass Sie f√ºr diese Technik das <b>Keulen</b> des <b>Gesichts</b> abschneiden m√ºssen, nicht die Vorderseite. <br><br>  Die Verwendung von <b>Face-Culling-</b> Vorderkanten ist eine weit verbreitete Methode, um Schattenartefakte zu vermeiden. Dies funktioniert jedoch nicht mit <b>RSM</b> . <br><br>  Sie √ºbergeben die Weltraumpositionen und Normalen an den Pixel-Shader und schreiben sie in die entsprechenden Puffer.  Wenn Sie die <b>normale Zuordnung verwenden</b> , berechnen Sie diese auch im Pixel-Shader.  <b>Der Fluss wird dort</b> berechnet, indem Albedomaterial mit der Farbe der Lichtquelle multipliziert wird.  F√ºr <b>Spotlicht m√ºssen</b> Sie den resultierenden Wert mit dem Einfallswinkel multiplizieren.  F√ºr <b>gerichtetes Licht wird ein nicht</b> schattiertes Bild erhalten. <br><br><h3>  Vorbereitung f√ºr die Lichtberechnung </h3><br>  Es gibt ein paar Dinge, die Sie f√ºr die Hauptpassage tun m√ºssen.  Sie m√ºssen alle im Schattenpass verwendeten Puffer als Texturen binden.  Sie ben√∂tigen auch Zufallszahlen.  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Artikel</a> besagt, dass Sie diese Zahlen vorberechnen und in einem Puffer speichern m√ºssen, um die Anzahl der Operationen im <b>RSM-</b> Abtastdurchlauf zu verringern.  Da der Algorithmus sehr leistungsintensiv ist, stimme ich dem offiziellen Artikel voll und ganz zu.  Es wird dort auch empfohlen, die zeitliche Koh√§renz einzuhalten (f√ºr alle indirekten Beleuchtungsberechnungen das gleiche Stichprobenmuster verwenden).  Dies verhindert ein Flackern, wenn jeder Frame einen anderen Schatten verwendet. <br><br>  Sie ben√∂tigen f√ºr jede Stichprobe zwei zuf√§llige Gleitkommazahlen im Bereich [0, 1].  Diese Zufallszahlen werden verwendet, um die Koordinaten der Stichprobe zu bestimmen.  Sie ben√∂tigen au√üerdem dieselbe Matrix, mit der Sie Positionen vom Weltraum (Weltraum) in den Schattenraum (Lichtquellenraum) konvertieren.  Sie ben√∂tigen solche Parameter auch f√ºr die Abtastung, die eine schwarze Farbe ergeben, wenn Sie √ºber die Grenzen der Textur hinaus abtasten. <br><br><h3>  Beleuchtung passieren </h3><br>  Nun ist der schwer zu verstehende Teil.  Ich empfehle, dass Sie die indirekte Beleuchtung berechnen, nachdem Sie die direkte Beleuchtung f√ºr eine bestimmte Lichtquelle berechnet haben.  Dies liegt daran, dass Sie ein Vollbild-Quad f√ºr <b>gerichtetes Licht</b> ben√∂tigen.  F√ºr <b>Punkt-</b> und <b>Punktlicht</b> m√∂chten Sie jedoch normalerweise Netze einer bestimmten Form mit <b>Keulung verwenden</b> , um weniger Pixel zu f√ºllen. <br><br>  Im folgenden Code wird die indirekte Beleuchtung f√ºr das Pixel berechnet.  Als n√§chstes werde ich erkl√§ren, was dort passiert. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReflectiveShadowMapping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 P, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divideByW, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ float4 textureSpacePosition = mul(lightViewProjectionTextureMatrix, float4(P, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divideByW) textureSpacePosition.xyz /= textureSpacePosition.w; float3 indirectIllumination = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rMax = rsmRMax; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rsmSampleCount; ++i) { float2 rnd = rsmSamples[i].xy; float2 coords = textureSpacePosition.xy + rMax * rnd; float3 vplPositionWS = g_rsmPositionWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 vplNormalWS = g_rsmNormalWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 flux = g_rsmFluxMap.Sample(g_clampedSampler, coords.xy).xyz; float3 result = flux * ((max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(vplNormalWS, P ‚Äì vplPositionWS)) * max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, vplPositionWS ‚Äì P))) / <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(length(P ‚Äì vplPositionWS), <span class="hljs-number"><span class="hljs-number">4</span></span>)); result *= rnd.x * rnd.x; indirectIllumination += result; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(indirectIllumination * rsmIntensity); }</code> </pre> <br>  Das erste Argument f√ºr die Funktion ist <b>P</b> , dh die Weltraumposition (im Weltraum) f√ºr ein bestimmtes Pixel.  <b>DivideByW wird</b> f√ºr die voraussichtliche Division verwendet, die erforderlich ist, um den korrekten <b>Z-</b> Wert zu erhalten.  <b>N</b> ist der Weltraum normal. <br><br><pre> <code class="cpp hljs">float4 textureSpacePosition = mul(lightViewProjectionTextureMatrix, float4(P, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divideByW) textureSpacePosition.xyz /= textureSpacePosition.w; float3 indirectIllumination = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rMax = rsmRMax;</code> </pre><br>  In diesem Teil des Codes wird die Position des Lichtraums (relativ zur Lichtquelle) berechnet, die indirekte Beleuchtungsvariable initialisiert, in der die aus jeder Probe berechneten Werte summiert werden, und die <b>rMax-</b> Variable wird aus der Beleuchtungsgleichung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Artikel festgelegt</a> , deren Wert ich im n√§chsten Abschnitt erl√§utern werde. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rsmSampleCount; ++i) { float2 rnd = rsmSamples[i].xy; float2 coords = textureSpacePosition.xy + rMax * rnd; float3 vplPositionWS = g_rsmPositionWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 vplNormalWS = g_rsmNormalWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 flux = g_rsmFluxMap.Sample(g_clampedSampler, coords.xy).xyz;</code> </pre><br>  Hier starten wir den Zyklus und bereiten unsere Variablen f√ºr die Gleichung vor.  Zu Optimierungszwecken enthalten die von mir berechneten Zufallsstichproben bereits Koordinatenvers√§tze, <b>dh</b> um die UV-Koordinaten zu erhalten, muss ich nur <b>rMax * rnd</b> zu den Lichtraumkoordinaten hinzuf√ºgen.  Wenn die resultierenden UV-Strahlen au√üerhalb des Bereichs [0,1] liegen, sollten die Proben schwarz sein.  Das ist logisch, da sie √ºber den Beleuchtungsbereich hinausgehen. <br><br><pre> <code class="cpp hljs"> float3 result = flux * ((max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(vplNormalWS, P ‚Äì vplPositionWS)) * max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, vplPositionWS ‚Äì P))) / <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(length(P ‚Äì vplPositionWS), <span class="hljs-number"><span class="hljs-number">4</span></span>)); result *= rnd.x * rnd.x; indirectIllumination += result; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(indirectIllumination * rsmIntensity);</code> </pre><br>  Dies ist der Teil, in dem die indirekte Beleuchtungsgleichung berechnet ( <i>Abbildung 2</i> ) und auch gem√§√ü dem Abstand von der Lichtraumkoordinate zur Probe gewogen wird.  Die Gleichung sieht einsch√ºchternd aus und der Code hilft nicht, alles zu verstehen, daher werde ich dies genauer erl√§utern. <br><br>  Die Variable <b>Œ¶</b> (phi) ist der <b>Lichtfluss</b> , der die Strahlungsintensit√§t ist.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der vorherige Artikel</a> beschreibt den <b>Fluss</b> detaillierter. <br><br>  <b>Flussskalen</b> mit zwei skalaren Kunstwerken.  Die erste liegt zwischen der Normalen der Lichtquelle (Texel) und der Richtung von der Lichtquelle zur aktuellen Position.  Die zweite liegt zwischen der Stromnormalen und dem Richtungsvektor von der aktuellen Position zur Position der Lichtquelle (Texel).  Um keinen negativen Beitrag zur Beleuchtung zu leisten (es stellt sich heraus, dass das Pixel nicht beleuchtet ist), sind Skalarprodukte auf den Bereich [0, ‚àû] beschr√§nkt.  In dieser Gleichung wird die Normalisierung vermutlich aus Leistungsgr√ºnden am Ende durchgef√ºhrt.  Es ist ebenso akzeptabel, Richtungsvektoren zu normalisieren, bevor skalare Produkte durchgef√ºhrt werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/dd3/258/ab4dd3258620fc3bae4a044df4072cf5.png" alt="Bild"><br>  <i>Abbildung 2: Gleichung der Beleuchtungsst√§rke eines Punktes mit Position <b>x</b> und normaler <b>n-</b> gerichteter Pixellichtquelle <b>p</b></i> <br><br>  Das Ergebnis dieses Durchlaufs kann mit einem Backbuffer (direkte Beleuchtung) gemischt werden. Das Ergebnis ist wie in <i>Abbildung 1 dargestellt</i> . <br><br><h2>  Fallstricke </h2><br>  Bei der Implementierung dieses Algorithmus sind einige Probleme aufgetreten.  Ich werde √ºber diese Probleme sprechen, damit Sie nicht auf denselben Rechen treten. <br><br><h3>  Falscher Sampler </h3><br>  Ich habe viel Zeit damit verbracht herauszufinden, warum sich meine indirekte Beleuchtung wiederholt.  Die Texturen von Crytek Sponza sind versteckt, daher ben√∂tigen Sie einen verpackten Sampler.  Aber f√ºr <b>RSM ist</b> es nicht sehr geeignet. <br><br><div class="spoiler">  <b class="spoiler_title">Opengl</b> <div class="spoiler_text">  OpenGL setzt <b>RSM-</b> Texturen auf GL_CLAMP_TO_BORDER <br></div></div><br><h3>  Benutzerdefinierte Werte </h3><br>  Um den Workflow zu verbessern, ist es wichtig, einige Variablen per Knopfdruck √§ndern zu k√∂nnen.  Zum Beispiel die Intensit√§t der indirekten Beleuchtung und der <b>Abtastbereich</b> ( <b>rMax</b> ).  Diese Parameter m√ºssen f√ºr jede Lichtquelle angepasst werden.  Wenn Sie einen gro√üen Abtastbereich haben, erhalten Sie von √ºberall eine indirekte Beleuchtung, was f√ºr gro√üe Szenen n√ºtzlich ist.  F√ºr eine lokalere indirekte Beleuchtung ben√∂tigen Sie eine kleinere Reichweite.  <i>Abbildung 3</i> zeigt die globale und lokale indirekte Beleuchtung. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/c98/7f7/a08c987f7a9bf46344a623bafebfc903.png" alt="Bild"><br>  <i>Abbildung 3: Demonstration der <b>rMax-</b> Abh√§ngigkeit.</i> <br><br><h3>  Separate Passage </h3><br>  Zuerst dachte ich, ich k√∂nnte indirekte Beleuchtung in einem Shader machen, in dem ich direkte Beleuchtung betrachte.  Bei <b>gerichtetem Licht</b> funktioniert dies, da Sie immer noch ein Vollbild-Quad zeichnen.  F√ºr <b>Punkt-</b> und <b>Punktlicht m√ºssen</b> Sie jedoch die Berechnung der indirekten Beleuchtung optimieren.  Daher habe ich die indirekte Beleuchtung als separaten Durchgang betrachtet, der erforderlich ist, wenn Sie auch eine <b>Bildschirmrauminterpolation durchf√ºhren</b> m√∂chten. <br><br><h3>  Cache </h3><br>  Dieser Algorithmus ist mit dem Cache √ºberhaupt nicht vertraut.  Es f√ºhrt Stichproben an zuf√§lligen Punkten in mehreren Texturen durch.  Die Anzahl der Proben ohne Optimierungen ist ebenfalls unannehmbar gro√ü.  Mit einer Aufl√∂sung von 1280 * 720 und der Anzahl der <b>RSM</b> 400-Abtastwerte erstellen Sie 1.105.920.000 Abtastwerte f√ºr jede Lichtquelle. <br><br><h3>  Daf√ºr und dagegen </h3><br>  Ich werde die Vor- und Nachteile dieses indirekten Beleuchtungsberechnungsalgorithmus auflisten. <br><table><tbody><tr><td>  F√ºr </td><td>  <b>Gegen</b> </td></tr><tr><td>  Einfach zu verstehender Algorithmus </td><td>  √úberhaupt keine Freunde mit Cache </td></tr><tr><td>  L√§sst sich gut in den verz√∂gerten Renderer integrieren </td><td>  Variable Einstellung erforderlich </td></tr><tr><td>  Kann in anderen Algorithmen ( <b>LPV</b> ) verwendet werden </td><td>  Erzwungene Wahl zwischen lokaler und globaler indirekter Beleuchtung </td></tr></tbody></table><h2>  Optimierungen </h2><br>  Ich habe mehrere Versuche unternommen, die Geschwindigkeit dieses Algorithmus zu erh√∂hen.  Wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Artikel beschrieben</a> , k√∂nnen Sie die <b>Bildschirmrauminterpolation</b> implementieren.  Ich habe das gemacht und ein bisschen schneller gerendert.  Im Folgenden werde ich einige Optimierungen beschreiben und einen Vergleich (in Bildern pro Sekunde) zwischen den folgenden Implementierungen anhand einer Szene mit 3 W√§nden und einem Kaninchen durchf√ºhren: ohne <b>RSM</b> , naive Implementierung von <b>RSM</b> , interpoliert von <b>RSM</b> . <br><br><h3>  Z-Check </h3><br>  Einer der Gr√ºnde, warum mein <b>RSM</b> ineffizient funktionierte, war, dass ich auch die indirekte Beleuchtung f√ºr Pixel berechnet habe, die Teil der Skybox waren.  Skybox braucht es definitiv nicht. <br><br><h3>  CPU-Zufallsstichprobe </h3><br>  Die vorl√§ufige Berechnung von Samples f√ºhrt nicht nur zu einer gr√∂√üeren zeitlichen Koh√§renz, sondern erspart Ihnen auch die Neuberechnung dieser Samples im Shader. <br><br><h3>  Bildschirmrauminterpolation </h3><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Artikel wird vorgeschlagen, ein</a> Renderziel mit niedriger Aufl√∂sung zur Berechnung der indirekten Beleuchtung zu verwenden.  Bei Szenen mit vielen glatten Normalen und geraden W√§nden k√∂nnen Beleuchtungsinformationen leicht zwischen Punkten mit niedrigerer Aufl√∂sung interpoliert werden.  Ich werde die Interpolation nicht im Detail beschreiben, so dass dieser Artikel etwas k√ºrzer ist. <br><br><h2>  Fazit </h2><br>  Nachfolgend sind die Ergebnisse f√ºr eine andere Anzahl von Proben aufgef√ºhrt.  Ich habe einige Kommentare zu diesen Ergebnissen: <br><br><ul><li>  Logischerweise bleibt der FPS f√ºr eine andere Anzahl von Abtastwerten bei etwa 700, wenn keine <b>RSM-</b> Berechnung durchgef√ºhrt wird. </li><li>  Die Interpolation verursacht einen gewissen Overhead und ist bei einer kleinen Anzahl von Abtastwerten nicht sehr n√ºtzlich. </li><li>  Selbst mit 100 Samples sah das endg√ºltige Bild ziemlich gut aus.  Dies kann auf eine Interpolation zur√ºckzuf√ºhren sein, die die indirekte Beleuchtung ‚Äûverwischt‚Äú. </li></ul><br><table><tbody><tr><td>  Probenanzahl </td><td>  FPS f√ºr kein RSM </td><td>  FPS f√ºr naives RSM </td><td>  FPS f√ºr interpoliertes RSM </td></tr><tr><td>  100 </td><td>  ~ 700 </td><td>  152 </td><td>  264 </td></tr><tr><td>  200 </td><td>  ~ 700 </td><td>  89 </td><td>  179 </td></tr><tr><td>  300 </td><td>  ~ 700 </td><td>  62 </td><td>  138 </td></tr><tr><td>  400 </td><td>  ~ 700 </td><td>  44 </td><td>  116 </td></tr></tbody></table></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440570/">https://habr.com/ru/post/de440570/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440560/index.html">Alexander Belokrylov und Dmitry Chuyko √ºber Liberica JDK auf jug.msk.ru</a></li>
<li><a href="../de440562/index.html">Windows Phone - ALLES, es ist immer wieder</a></li>
<li><a href="../de440564/index.html">GPT-2 neuronales Netzwerk von OpenAI. Schnellstart</a></li>
<li><a href="../de440566/index.html">Ungehindert beschleunigen oder SIMD kennenlernen</a></li>
<li><a href="../de440568/index.html">Wir schreiben eine Lernanwendung in Go und Javascript, um die tats√§chlichen Aktienrenditen zu bewerten. Teil 2 - Testen des Backends</a></li>
<li><a href="../de440574/index.html">Russischer AI Cup 2018, Geschichte 9 Pl√§tze</a></li>
<li><a href="../de440576/index.html">Wichtige √Ñnderungen an CTE in PostgreSQL 12</a></li>
<li><a href="../de440582/index.html">Werden Elektroautos auf den Grund des Autokonzerns gezogen?</a></li>
<li><a href="../de440584/index.html">Was ist los mit dem Raspberry Pi</a></li>
<li><a href="../de440586/index.html">Exonum-Konsens: Wie es funktioniert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>