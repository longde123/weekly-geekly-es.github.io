<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥛 💬 ✔️ Python y FPGA. Prueba 🧖🏿 💅🏾 🚇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como continuación del primer artículo , quiero mostrar un ejemplo de trabajo con FPGA (FPGA) en python como ejemplo. Este artículo cubrirá el aspecto ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python y FPGA. Prueba</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442010/">  Como continuación del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer artículo</a> , quiero mostrar un ejemplo de trabajo con FPGA (FPGA) en python como ejemplo.  Este artículo cubrirá el aspecto de la prueba con más detalle.  Si el marco <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MyHDL</a> permite a las personas que trabajan en Python, utilizando la sintaxis y el ecosistema familiares, mirar el mundo de FPGA, entonces los desarrolladores de FPGA experimentados no entienden el significado del uso de Python.  Los paradigmas de descripción de hardware para MyHDL y Verilog son similares, y elegir un idioma específico es una cuestión de hábito y gusto.  Verilog / VHDL representa el hecho de que el firmware se ha escrito en estos idiomas durante mucho tiempo y, de hecho, son estándar para la descripción de equipos digitales.  Python, como novato en este campo, puede competir en entornos de prueba de escritura.  Una parte importante del tiempo del desarrollador de FPGA se dedica a probar sus diseños.  A continuación, quiero demostrar con un ejemplo cómo se hace esto en python con MyHDL. <br><br>  Supongamos que hay una tarea para describir un dispositivo que funciona con memoria en el FPGA.  Para simplificar, tomaré la memoria que se comunica con otros dispositivos a través de una interfaz paralela (y no a través de una serie, por ejemplo, I2C).  Dichos microcircuitos no siempre son prácticos en vista del hecho de que se requieren muchos pines para trabajar con ellos; por otro lado, se proporciona un intercambio de información más rápido y fácil.  Por ejemplo, doméstico 1645RU1U y sus análogos. <br><br><img src="https://habrastorage.org/webt/e6/hh/ls/e6hhlsa3yvrcdjdzke3dc_jaxby.png"><br><a name="habracut"></a><br><h1>  Descripción del módulo </h1><br>  El registro se ve así: FPGA proporciona una dirección de celda de 16 bits, datos de 8 bits, genera una señal de escritura WE (habilitación de escritura).  Dado que OE (habilitación de salida) y CE (habilitación de chip) siempre están habilitados, la lectura se produce cuando se cambia la dirección de la celda.  La escritura y la lectura se pueden llevar a cabo de forma secuencial en varias celdas seguidas, comenzando desde una dirección adr_start específica, registrada en el borde delantero de la señal adr_write, y una celda en una dirección arbitraria (acceso aleatorio). <br><br>  En MyHDL, el código se ve así (las señales de escritura y lectura vienen en lógica inversa): <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> myhdl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * @block <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ram_driver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#     mem_z = data_memory.driver() #      @always(adr_write.posedge, write.posedge, read.negedge) def write_start_adr(): if adr_write: #    adr.next = adr_start else: #    / adr.next = adr + 1 @always(write) def write_data(): if not write: mem_z.next = data_in we.next = 0 #    ,    else: mem_z.next = None #        data_out.next = data_memory we.next = 1 return write_data, write_start_adr</span></span></code> </pre> <br>  Si se convierte a Verilog con la función: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hdl)</span></span></span><span class="hljs-function">:</span></span> data_memory = TristateSignal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_in = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_out = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) adr = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_start = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_write = Signal(bool(<span class="hljs-number"><span class="hljs-number">0</span></span>)) read, write, we = [Signal(bool(<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">3</span></span>)] inst = ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we) inst.convert(hdl=hdl) convert(hdl=<span class="hljs-string"><span class="hljs-string">'Verilog'</span></span>)</code> </pre> <br>  entonces obtenemos lo siguiente: <br><pre> <code class="vhdl hljs">`timescale <span class="hljs-number"><span class="hljs-number">1</span></span>ns/<span class="hljs-number"><span class="hljs-number">10</span></span>ps module ram_driver ( data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we ); input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_in; output [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_out; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_out; output [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adr; reg [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adr; input [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adr_start; input adr_write; <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_memory; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_memory; input read; input write; output we; reg we; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] mem_z; assign data_memory = mem_z; always @(write) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>: RAM_DRIVER_WRITE_DATA <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!write)) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> mem_z &lt;= data_in; we &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> mem_z &lt;= <span class="hljs-symbol"><span class="hljs-symbol">'bz</span></span>; data_out &lt;= data_memory; we &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @(posedge adr_write, posedge write, negedge read) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>: RAM_DRIVER_WRITE_START_ADR <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (adr_write) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> adr &lt;= adr_start; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> adr &lt;= (adr + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre> <br>  No es necesario convertir un proyecto a Verilog para simulación, este paso será necesario para flashear el FPGA. <br><br><h1>  Modelado </h1><br>  Después de la descripción de la lógica, el proyecto debe ser verificado.  Puede restringirse, por ejemplo, para simular influencias de entrada y ver la respuesta del módulo en el diagrama de tiempo.  Pero con esta opción, es más difícil predecir la interacción de su módulo con un chip de memoria.  Por lo tanto, para verificar completamente el funcionamiento del dispositivo creado, debe crear un modelo de memoria y probar la interacción entre estos dos dispositivos. <br><br>  Dado que el trabajo se lleva a cabo en python, el tipo de diccionario dado (diccionario) se sugiere para el modelo de memoria.  Los datos en los que se almacenan como {clave: valor}, y para este caso {dirección: datos}. <br><br><pre> <code class="python hljs">memory = { <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">456</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-number"><span class="hljs-number">789</span></span> } memory[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">123</span></span> memory[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">456</span></span></code> </pre> <br>  Para el mismo propósito, el tipo de datos de la lista es adecuado, donde cada elemento tiene sus propias coordenadas, lo que indica la ubicación del elemento en la lista: <br><br><pre> <code class="python hljs">memory = [<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">456</span></span>, <span class="hljs-number"><span class="hljs-number">789</span></span>] memory[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">123</span></span> memory[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">456</span></span></code> </pre> <br>  El uso de diccionarios para simular la memoria parece preferible en vista de una mayor visibilidad. <br><br>  La descripción del shell de prueba (en el archivo test_seq_access.py) comienza con la declaración de señales, la inicialización de los estados iniciales y su lanzamiento a la función del controlador de memoria descrita anteriormente: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@block def testbench(): data_memory = TristateSignal(intbv(0)[8:]) data_in = Signal(intbv(0)[8:]) data_out = Signal(intbv(0)[8:]) adr = Signal(intbv(0)[16:]) adr_start = Signal(intbv(20)[16:]) adr_write = Signal(bool(0)) read, write, we = [Signal(bool(1)) for i in range(3)] ram = ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we)</span></span></code> </pre> <br>  A continuación se describe el modelo de memoria.  Los estados iniciales se inicializan, por defecto la memoria se llena con valores cero.  Limite el modelo de memoria a 128 celdas: <br><br><pre> <code class="python hljs">memory = {i: intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">128</span></span>)}</code> </pre> <br>  y describa el comportamiento de la memoria: cuando WE en el estado bajo, escriba el valor en la línea en la dirección de memoria correspondiente; de ​​lo contrario, el modelo da el valor en la dirección dada: <br><br><pre> <code class="python hljs">mem_z = data_memory.driver() @always_comb <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">access</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> we: memory[int(adr.val)] = data_memory.val <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we: data_out.next = memory[int(adr.val)] mem_z.next = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Luego, en la misma función, puede describir el comportamiento de las señales de entrada (para el caso de escritura / lectura secuencial): se registra la dirección de inicio → se registran 8 celdas de información → se registra la dirección de inicio → se leen 8 celdas de información grabadas. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@instance def stimul(): init_adr = random.randint(0, 50) #   yield delay(100) write.next = 1 adr_write.next = 1 adr_start.next = init_adr #   yield delay(100) adr_write.next = 0 yield delay(100) for i in range(8): # 8    write.next = 0 data_in.next = random.randint(0, 100) yield delay(100) write.next = 1 yield delay(100) adr_start.next = init_adr #   adr_write.next = 1 yield delay(100) adr_write.next = 0 yield delay(100) for i in range(8): #   read.next = 0 yield delay(100) read.next = 1 yield delay(100) raise StopSimulation return stimul, ram, access</span></span></code> </pre> <br>  Ejecutar simulación: <br><br><pre> <code class="python hljs">tb = testbench() tb.config_sim(trace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) tb.run_sim()</code> </pre> <br>  Después de iniciar el programa, el archivo testbench_seq_access.vcd se genera en la carpeta de trabajo, ábralo en gtkwave: <br><br><pre> <code class="bash hljs">gtkwave testbench_seq_access.vcd</code> </pre> <br>  Y vemos la imagen: <br><br><img src="https://habrastorage.org/webt/io/ak/oc/ioakocq8btz-hdlk_-m7xzeshse.jpeg"><br><br>  La información registrada fue leída con éxito. <br><br>  Puede ver el contenido de la memoria agregando el siguiente código a testbench: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key, value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memory.items(): print(<span class="hljs-string"><span class="hljs-string">'adr:{}'</span></span>.format(key), <span class="hljs-string"><span class="hljs-string">'data:{}'</span></span>.format(value))</code> </pre> <br>  Lo siguiente aparece en la consola: <br><br><img src="https://habrastorage.org/webt/js/sb/ly/jssbly6h3kodhjqrw7ih9mtzamg.jpeg"><br><br><h1>  Prueba </h1><br>  Después de eso, puede realizar varias pruebas automatizadas con un mayor número de celdas grabables / legibles.  Para hacer esto, se agregan varios ciclos de prueba y diccionarios ficticios a testbench, donde se agrega la información escrita y legible y la construcción de aserción, lo que provoca un error si dos diccionarios no son iguales: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@instance def stimul(): for time in range(100): temp_mem_write = {} temp_mem_read = {} init_adr = random.randint(0, 50) yield delay(100) write.next = 1 adr_write.next = 1 adr_start.next = init_adr yield delay(100) adr_write.next = 0 yield delay(100) for i in range(64): write.next = 0 data_in.next = random.randint(0, 100) temp_mem_write[i] = int(data_in.next) yield delay(100) write.next = 1 yield delay(100) adr_start.next = init_adr adr_write.next = 1 yield delay(100) adr_write.next = 0 yield delay(100) for i in range(64): read.next = 0 temp_mem_read[i] = int(data_out.val) yield delay(100) read.next = 1 yield delay(100) assert temp_mem_write == temp_mem_read, "   " for key, value in memory.items(): print('adr:{}'.format(key), 'data:{}'.format(value)) raise StopSimulation return stimul, ram, access</span></span></code> </pre><br>  A continuación, puede crear un segundo banco de pruebas para probar la operación en modo de acceso aleatorio: test_random_access.py. <br><br>  La idea de la segunda prueba es similar: escribimos información aleatoria en una dirección aleatoria y agregamos un par {dirección: datos} al diccionario temp_mem_write.  Luego damos la vuelta a las direcciones en este diccionario y leemos la información de la memoria, ingresándola en el diccionario temp_mem_read.  Y al final con la construcción de aserción, verificamos el contenido de dos diccionarios. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> myhdl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ram_driver <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ram_driver @block <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testbench_random_access</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> data_memory = TristateSignal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_in = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_out = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) adr = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_start = Signal(intbv(<span class="hljs-number"><span class="hljs-number">20</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_write = Signal(bool(<span class="hljs-number"><span class="hljs-number">0</span></span>)) read, write, we = [Signal(bool(<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">3</span></span>)] ram = ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we) memory ={i:intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">128</span></span>)} mem_z = data_memory.driver() @always_comb <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">access</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> we: memory[int(adr.val)] = data_memory.val <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we: data_out.next = memory[int(adr.val)] mem_z.next = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> @instance <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stimul</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>): temp_mem_write = {} temp_mem_read = {} <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">64</span></span>): write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> adr_write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> adr_start.next = random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">126</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) adr_write.next = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) write.next = <span class="hljs-number"><span class="hljs-number">0</span></span> data_in.next = random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) temp_mem_write[int(adr_start.val)] = int(data_in.next) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> temp_mem_write.keys(): adr_start.next = key adr_write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) adr_write.next = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) read.next = <span class="hljs-number"><span class="hljs-number">0</span></span> temp_mem_read[key] = int(data_out.val) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) read.next = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> temp_mem_write == temp_mem_read, <span class="hljs-string"><span class="hljs-string">'  random access'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> StopSimulation <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stimul, ram, access tb = testbench_random_access() tb.config_sim(trace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) tb.run_sim()</code> </pre> <br>  Python tiene varios marcos para automatizar la ejecución de pruebas.  Tomaré pytest por simplicidad, debe instalarse desde pip: <br><br><pre> <code class="bash hljs">pip3 install pytest</code> </pre> <br>  Cuando se inicia el comando "pysest" desde la consola, el marco buscará y ejecutará todos los archivos en la carpeta de trabajo con "test_ *" en sus nombres. <br><br><img src="https://habrastorage.org/webt/pv/sz/zr/pvszzr_l6vdb6hnfn1pwkelu5vo.jpeg"><br><br>  Pruebas completadas con éxito.  Cometeré un error deliberadamente en la descripción del dispositivo: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@block def ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we): mem_z = data_memory.driver() @always(adr_write.posedge, write.posedge, read.negedge) def write_start_adr(): if adr_write: adr.next = adr_start else: adr.next = adr + 1 @always(write) def write_data(): if not write: mem_z.next = data_in we.next = 1 #  ,    else: mem_z.next = None data_out.next = data_memory we.next = 1</span></span></code> </pre> <br>  Corro pruebas: <br><br><img src="https://habrastorage.org/webt/q7/f3/4b/q7f34bqhdrvwapsxawc_sdquxdu.jpeg"><br><br>  Como se esperaba, en ambas pruebas, se consideró la información inicial (ceros), es decir, no se registró nueva información. <br><br><h1>  Conclusión </h1><br>  El uso de python junto con myHDL le permite automatizar las pruebas de firmware desarrollado para FPGA y crear casi cualquier entorno de prueba usando las capacidades ricas del lenguaje de programación python. <br><br>  El artículo considera: <br><br><ul><li>  creando un módulo que funciona con memoria; </li><li>  creando un modelo de memoria; </li><li>  creación de casos de prueba; </li><li>  prueba de automatización con el marco pytest. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442010/">https://habr.com/ru/post/442010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441998/index.html">"Los contenedores ganaron la batalla, pero pierden la guerra en la arquitectura sin servidor", - Simon Wardley</a></li>
<li><a href="../442002/index.html">Introduciendo Neural ODE</a></li>
<li><a href="../442004/index.html">Efectos de filtrado SVG. Parte 7. Adelante</a></li>
<li><a href="../442006/index.html">Gestión de archivos mal hecha - Parte 2: Obra maestra de mierda</a></li>
<li><a href="../442008/index.html">k3s es un Kubernetes pequeño pero certificado por Rancher Labs</a></li>
<li><a href="../442012/index.html">Experimento: recopilamos un directorio de unidades que emitieron un pasaporte</a></li>
<li><a href="../442014/index.html">Dart 2.2 anunciado: Código de máquina más eficiente, soporte para set literales</a></li>
<li><a href="../442016/index.html">Los hackers son peores que pintar, o cómo proteger las aplicaciones web</a></li>
<li><a href="../442018/index.html">Ley de primavera en términos de la constitución. Por qué puede</a></li>
<li><a href="../442020/index.html">Nuevo códec AV1: acelere la carga de video en un navegador</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>