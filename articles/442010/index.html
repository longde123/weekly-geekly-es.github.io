<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•õ üí¨ ‚úîÔ∏è Python y FPGA. Prueba üßñüèø üíÖüèæ üöá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como continuaci√≥n del primer art√≠culo , quiero mostrar un ejemplo de trabajo con FPGA (FPGA) en python como ejemplo. Este art√≠culo cubrir√° el aspecto ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python y FPGA. Prueba</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442010/">  Como continuaci√≥n del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer art√≠culo</a> , quiero mostrar un ejemplo de trabajo con FPGA (FPGA) en python como ejemplo.  Este art√≠culo cubrir√° el aspecto de la prueba con m√°s detalle.  Si el marco <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MyHDL</a> permite a las personas que trabajan en Python, utilizando la sintaxis y el ecosistema familiares, mirar el mundo de FPGA, entonces los desarrolladores de FPGA experimentados no entienden el significado del uso de Python.  Los paradigmas de descripci√≥n de hardware para MyHDL y Verilog son similares, y elegir un idioma espec√≠fico es una cuesti√≥n de h√°bito y gusto.  Verilog / VHDL representa el hecho de que el firmware se ha escrito en estos idiomas durante mucho tiempo y, de hecho, son est√°ndar para la descripci√≥n de equipos digitales.  Python, como novato en este campo, puede competir en entornos de prueba de escritura.  Una parte importante del tiempo del desarrollador de FPGA se dedica a probar sus dise√±os.  A continuaci√≥n, quiero demostrar con un ejemplo c√≥mo se hace esto en python con MyHDL. <br><br>  Supongamos que hay una tarea para describir un dispositivo que funciona con memoria en el FPGA.  Para simplificar, tomar√© la memoria que se comunica con otros dispositivos a trav√©s de una interfaz paralela (y no a trav√©s de una serie, por ejemplo, I2C).  Dichos microcircuitos no siempre son pr√°cticos en vista del hecho de que se requieren muchos pines para trabajar con ellos; por otro lado, se proporciona un intercambio de informaci√≥n m√°s r√°pido y f√°cil.  Por ejemplo, dom√©stico 1645RU1U y sus an√°logos. <br><br><img src="https://habrastorage.org/webt/e6/hh/ls/e6hhlsa3yvrcdjdzke3dc_jaxby.png"><br><a name="habracut"></a><br><h1>  Descripci√≥n del m√≥dulo </h1><br>  El registro se ve as√≠: FPGA proporciona una direcci√≥n de celda de 16 bits, datos de 8 bits, genera una se√±al de escritura WE (habilitaci√≥n de escritura).  Dado que OE (habilitaci√≥n de salida) y CE (habilitaci√≥n de chip) siempre est√°n habilitados, la lectura se produce cuando se cambia la direcci√≥n de la celda.  La escritura y la lectura se pueden llevar a cabo de forma secuencial en varias celdas seguidas, comenzando desde una direcci√≥n adr_start espec√≠fica, registrada en el borde delantero de la se√±al adr_write, y una celda en una direcci√≥n arbitraria (acceso aleatorio). <br><br>  En MyHDL, el c√≥digo se ve as√≠ (las se√±ales de escritura y lectura vienen en l√≥gica inversa): <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> myhdl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * @block <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ram_driver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#     mem_z = data_memory.driver() #      @always(adr_write.posedge, write.posedge, read.negedge) def write_start_adr(): if adr_write: #    adr.next = adr_start else: #    / adr.next = adr + 1 @always(write) def write_data(): if not write: mem_z.next = data_in we.next = 0 #    ,    else: mem_z.next = None #        data_out.next = data_memory we.next = 1 return write_data, write_start_adr</span></span></code> </pre> <br>  Si se convierte a Verilog con la funci√≥n: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hdl)</span></span></span><span class="hljs-function">:</span></span> data_memory = TristateSignal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_in = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_out = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) adr = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_start = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_write = Signal(bool(<span class="hljs-number"><span class="hljs-number">0</span></span>)) read, write, we = [Signal(bool(<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">3</span></span>)] inst = ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we) inst.convert(hdl=hdl) convert(hdl=<span class="hljs-string"><span class="hljs-string">'Verilog'</span></span>)</code> </pre> <br>  entonces obtenemos lo siguiente: <br><pre> <code class="vhdl hljs">`timescale <span class="hljs-number"><span class="hljs-number">1</span></span>ns/<span class="hljs-number"><span class="hljs-number">10</span></span>ps module ram_driver ( data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we ); input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_in; output [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_out; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_out; output [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adr; reg [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adr; input [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adr_start; input adr_write; <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_memory; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_memory; input read; input write; output we; reg we; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] mem_z; assign data_memory = mem_z; always @(write) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>: RAM_DRIVER_WRITE_DATA <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!write)) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> mem_z &lt;= data_in; we &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> mem_z &lt;= <span class="hljs-symbol"><span class="hljs-symbol">'bz</span></span>; data_out &lt;= data_memory; we &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @(posedge adr_write, posedge write, negedge read) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>: RAM_DRIVER_WRITE_START_ADR <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (adr_write) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> adr &lt;= adr_start; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> adr &lt;= (adr + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre> <br>  No es necesario convertir un proyecto a Verilog para simulaci√≥n, este paso ser√° necesario para flashear el FPGA. <br><br><h1>  Modelado </h1><br>  Despu√©s de la descripci√≥n de la l√≥gica, el proyecto debe ser verificado.  Puede restringirse, por ejemplo, para simular influencias de entrada y ver la respuesta del m√≥dulo en el diagrama de tiempo.  Pero con esta opci√≥n, es m√°s dif√≠cil predecir la interacci√≥n de su m√≥dulo con un chip de memoria.  Por lo tanto, para verificar completamente el funcionamiento del dispositivo creado, debe crear un modelo de memoria y probar la interacci√≥n entre estos dos dispositivos. <br><br>  Dado que el trabajo se lleva a cabo en python, el tipo de diccionario dado (diccionario) se sugiere para el modelo de memoria.  Los datos en los que se almacenan como {clave: valor}, y para este caso {direcci√≥n: datos}. <br><br><pre> <code class="python hljs">memory = { <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">456</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-number"><span class="hljs-number">789</span></span> } memory[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">123</span></span> memory[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">456</span></span></code> </pre> <br>  Para el mismo prop√≥sito, el tipo de datos de la lista es adecuado, donde cada elemento tiene sus propias coordenadas, lo que indica la ubicaci√≥n del elemento en la lista: <br><br><pre> <code class="python hljs">memory = [<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">456</span></span>, <span class="hljs-number"><span class="hljs-number">789</span></span>] memory[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">123</span></span> memory[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">456</span></span></code> </pre> <br>  El uso de diccionarios para simular la memoria parece preferible en vista de una mayor visibilidad. <br><br>  La descripci√≥n del shell de prueba (en el archivo test_seq_access.py) comienza con la declaraci√≥n de se√±ales, la inicializaci√≥n de los estados iniciales y su lanzamiento a la funci√≥n del controlador de memoria descrita anteriormente: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@block def testbench(): data_memory = TristateSignal(intbv(0)[8:]) data_in = Signal(intbv(0)[8:]) data_out = Signal(intbv(0)[8:]) adr = Signal(intbv(0)[16:]) adr_start = Signal(intbv(20)[16:]) adr_write = Signal(bool(0)) read, write, we = [Signal(bool(1)) for i in range(3)] ram = ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we)</span></span></code> </pre> <br>  A continuaci√≥n se describe el modelo de memoria.  Los estados iniciales se inicializan, por defecto la memoria se llena con valores cero.  Limite el modelo de memoria a 128 celdas: <br><br><pre> <code class="python hljs">memory = {i: intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">128</span></span>)}</code> </pre> <br>  y describa el comportamiento de la memoria: cuando WE en el estado bajo, escriba el valor en la l√≠nea en la direcci√≥n de memoria correspondiente; de ‚Äã‚Äãlo contrario, el modelo da el valor en la direcci√≥n dada: <br><br><pre> <code class="python hljs">mem_z = data_memory.driver() @always_comb <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">access</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> we: memory[int(adr.val)] = data_memory.val <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we: data_out.next = memory[int(adr.val)] mem_z.next = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Luego, en la misma funci√≥n, puede describir el comportamiento de las se√±ales de entrada (para el caso de escritura / lectura secuencial): se registra la direcci√≥n de inicio ‚Üí se registran 8 celdas de informaci√≥n ‚Üí se registra la direcci√≥n de inicio ‚Üí se leen 8 celdas de informaci√≥n grabadas. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@instance def stimul(): init_adr = random.randint(0, 50) #   yield delay(100) write.next = 1 adr_write.next = 1 adr_start.next = init_adr #   yield delay(100) adr_write.next = 0 yield delay(100) for i in range(8): # 8    write.next = 0 data_in.next = random.randint(0, 100) yield delay(100) write.next = 1 yield delay(100) adr_start.next = init_adr #   adr_write.next = 1 yield delay(100) adr_write.next = 0 yield delay(100) for i in range(8): #   read.next = 0 yield delay(100) read.next = 1 yield delay(100) raise StopSimulation return stimul, ram, access</span></span></code> </pre> <br>  Ejecutar simulaci√≥n: <br><br><pre> <code class="python hljs">tb = testbench() tb.config_sim(trace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) tb.run_sim()</code> </pre> <br>  Despu√©s de iniciar el programa, el archivo testbench_seq_access.vcd se genera en la carpeta de trabajo, √°bralo en gtkwave: <br><br><pre> <code class="bash hljs">gtkwave testbench_seq_access.vcd</code> </pre> <br>  Y vemos la imagen: <br><br><img src="https://habrastorage.org/webt/io/ak/oc/ioakocq8btz-hdlk_-m7xzeshse.jpeg"><br><br>  La informaci√≥n registrada fue le√≠da con √©xito. <br><br>  Puede ver el contenido de la memoria agregando el siguiente c√≥digo a testbench: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key, value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memory.items(): print(<span class="hljs-string"><span class="hljs-string">'adr:{}'</span></span>.format(key), <span class="hljs-string"><span class="hljs-string">'data:{}'</span></span>.format(value))</code> </pre> <br>  Lo siguiente aparece en la consola: <br><br><img src="https://habrastorage.org/webt/js/sb/ly/jssbly6h3kodhjqrw7ih9mtzamg.jpeg"><br><br><h1>  Prueba </h1><br>  Despu√©s de eso, puede realizar varias pruebas automatizadas con un mayor n√∫mero de celdas grabables / legibles.  Para hacer esto, se agregan varios ciclos de prueba y diccionarios ficticios a testbench, donde se agrega la informaci√≥n escrita y legible y la construcci√≥n de aserci√≥n, lo que provoca un error si dos diccionarios no son iguales: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@instance def stimul(): for time in range(100): temp_mem_write = {} temp_mem_read = {} init_adr = random.randint(0, 50) yield delay(100) write.next = 1 adr_write.next = 1 adr_start.next = init_adr yield delay(100) adr_write.next = 0 yield delay(100) for i in range(64): write.next = 0 data_in.next = random.randint(0, 100) temp_mem_write[i] = int(data_in.next) yield delay(100) write.next = 1 yield delay(100) adr_start.next = init_adr adr_write.next = 1 yield delay(100) adr_write.next = 0 yield delay(100) for i in range(64): read.next = 0 temp_mem_read[i] = int(data_out.val) yield delay(100) read.next = 1 yield delay(100) assert temp_mem_write == temp_mem_read, "   " for key, value in memory.items(): print('adr:{}'.format(key), 'data:{}'.format(value)) raise StopSimulation return stimul, ram, access</span></span></code> </pre><br>  A continuaci√≥n, puede crear un segundo banco de pruebas para probar la operaci√≥n en modo de acceso aleatorio: test_random_access.py. <br><br>  La idea de la segunda prueba es similar: escribimos informaci√≥n aleatoria en una direcci√≥n aleatoria y agregamos un par {direcci√≥n: datos} al diccionario temp_mem_write.  Luego damos la vuelta a las direcciones en este diccionario y leemos la informaci√≥n de la memoria, ingres√°ndola en el diccionario temp_mem_read.  Y al final con la construcci√≥n de aserci√≥n, verificamos el contenido de dos diccionarios. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> myhdl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ram_driver <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ram_driver @block <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testbench_random_access</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> data_memory = TristateSignal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_in = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_out = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) adr = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_start = Signal(intbv(<span class="hljs-number"><span class="hljs-number">20</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_write = Signal(bool(<span class="hljs-number"><span class="hljs-number">0</span></span>)) read, write, we = [Signal(bool(<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">3</span></span>)] ram = ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we) memory ={i:intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">128</span></span>)} mem_z = data_memory.driver() @always_comb <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">access</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> we: memory[int(adr.val)] = data_memory.val <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we: data_out.next = memory[int(adr.val)] mem_z.next = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> @instance <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stimul</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>): temp_mem_write = {} temp_mem_read = {} <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">64</span></span>): write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> adr_write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> adr_start.next = random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">126</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) adr_write.next = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) write.next = <span class="hljs-number"><span class="hljs-number">0</span></span> data_in.next = random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) temp_mem_write[int(adr_start.val)] = int(data_in.next) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> temp_mem_write.keys(): adr_start.next = key adr_write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) adr_write.next = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) read.next = <span class="hljs-number"><span class="hljs-number">0</span></span> temp_mem_read[key] = int(data_out.val) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) read.next = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> temp_mem_write == temp_mem_read, <span class="hljs-string"><span class="hljs-string">'  random access'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> StopSimulation <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stimul, ram, access tb = testbench_random_access() tb.config_sim(trace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) tb.run_sim()</code> </pre> <br>  Python tiene varios marcos para automatizar la ejecuci√≥n de pruebas.  Tomar√© pytest por simplicidad, debe instalarse desde pip: <br><br><pre> <code class="bash hljs">pip3 install pytest</code> </pre> <br>  Cuando se inicia el comando "pysest" desde la consola, el marco buscar√° y ejecutar√° todos los archivos en la carpeta de trabajo con "test_ *" en sus nombres. <br><br><img src="https://habrastorage.org/webt/pv/sz/zr/pvszzr_l6vdb6hnfn1pwkelu5vo.jpeg"><br><br>  Pruebas completadas con √©xito.  Cometer√© un error deliberadamente en la descripci√≥n del dispositivo: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@block def ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we): mem_z = data_memory.driver() @always(adr_write.posedge, write.posedge, read.negedge) def write_start_adr(): if adr_write: adr.next = adr_start else: adr.next = adr + 1 @always(write) def write_data(): if not write: mem_z.next = data_in we.next = 1 #  ,    else: mem_z.next = None data_out.next = data_memory we.next = 1</span></span></code> </pre> <br>  Corro pruebas: <br><br><img src="https://habrastorage.org/webt/q7/f3/4b/q7f34bqhdrvwapsxawc_sdquxdu.jpeg"><br><br>  Como se esperaba, en ambas pruebas, se consider√≥ la informaci√≥n inicial (ceros), es decir, no se registr√≥ nueva informaci√≥n. <br><br><h1>  Conclusi√≥n </h1><br>  El uso de python junto con myHDL le permite automatizar las pruebas de firmware desarrollado para FPGA y crear casi cualquier entorno de prueba usando las capacidades ricas del lenguaje de programaci√≥n python. <br><br>  El art√≠culo considera: <br><br><ul><li>  creando un m√≥dulo que funciona con memoria; </li><li>  creando un modelo de memoria; </li><li>  creaci√≥n de casos de prueba; </li><li>  prueba de automatizaci√≥n con el marco pytest. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442010/">https://habr.com/ru/post/442010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441998/index.html">"Los contenedores ganaron la batalla, pero pierden la guerra en la arquitectura sin servidor", - Simon Wardley</a></li>
<li><a href="../442002/index.html">Introduciendo Neural ODE</a></li>
<li><a href="../442004/index.html">Efectos de filtrado SVG. Parte 7. Adelante</a></li>
<li><a href="../442006/index.html">Gesti√≥n de archivos mal hecha - Parte 2: Obra maestra de mierda</a></li>
<li><a href="../442008/index.html">k3s es un Kubernetes peque√±o pero certificado por Rancher Labs</a></li>
<li><a href="../442012/index.html">Experimento: recopilamos un directorio de unidades que emitieron un pasaporte</a></li>
<li><a href="../442014/index.html">Dart 2.2 anunciado: C√≥digo de m√°quina m√°s eficiente, soporte para set literales</a></li>
<li><a href="../442016/index.html">Los hackers son peores que pintar, o c√≥mo proteger las aplicaciones web</a></li>
<li><a href="../442018/index.html">Ley de primavera en t√©rminos de la constituci√≥n. Por qu√© puede</a></li>
<li><a href="../442020/index.html">Nuevo c√≥dec AV1: acelere la carga de video en un navegador</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>