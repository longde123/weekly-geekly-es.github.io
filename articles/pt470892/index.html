<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐢 🧚 🚾 Implementação simples de pequenas CAM no FPGA 👾 🍕 👩‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdução 


 Uma vez eu precisei implementar um pequeno bloco de CAM (memória associativa). Depois de ler como o Xilinx faz isso no BRAM (blocos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementação simples de pequenas CAM no FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470892/"><h2 id="vvedenie">  1. Introdução </h2><br><p>  Uma vez eu precisei implementar um pequeno bloco de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CAM</a> (memória associativa).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Depois de ler</a> como o Xilinx faz isso no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BRAM</a> (blocos de memória estática) ou no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SRL16</a> (registros de deslocamento de 16 bits), fiquei um pouco triste, pois suas implementações ocupavam muito espaço.  Eu decidi tentar fazer isso sozinho.  A primeira opção foi a implementação da testa.  Olhando para o futuro, chegou quase a mim imediatamente e, bem, a frequência alvo para o design era de apenas 125 MHz. </p><a name="habracut"></a><br>
<h2 id="arhitektura">  Arquitetura </h2><br><p>  Para começar, considere a declaração do problema.  Portanto, precisamos de um pequeno CAM com uma largura de palavra de 8 a 64 bits e uma profundidade de 16 a 1024 palavras.  Eu precisava de uma pesquisa binária no CAM, mas, mais tarde, verificou-se que criar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TCAM</a> (memória associativa ternária) a partir dele é bastante barato em termos de recursos e afeta levemente o tempo.  O limite de frequência mais baixo é de 125 MHz na família <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kintex7</a> .  Vamos começar!  Nosso CAM será composto dessas linhas, cada uma das quais corresponderá a um endereço e armazenará uma palavra: </p><br><p><img src="https://habrastorage.org/webt/pv/ua/gk/pvuagk4p3oiguausboxx2ltgc_8.png" alt="Cam_line"></p><br><p>  <em>Figura 1. A estrutura de uma linha do CAM</em> </p><br><p>  Na Fig. 1, <strong>D</strong> é um gatilho D regular para armazenar dados; o número desses gatilhos na linha corresponde à largura da palavra de dados de entrada no CAM.  <strong>VÁLIDO</strong> - D-trigger, que armazena '1' se os dados na linha forem relevantes.  <strong>O CMP</strong> é um comparador que compara o valor do bit do barramento da <strong>chave de pesquisa</strong> correspondente se VALID = '1'.  <strong>write data</strong> - <strong>escreve o</strong> barramento de <strong>dados</strong> , conectado bit a bit ao D correspondente (largura da palavra <strong>N</strong> - CAM), escrevemos sinalizador, <strong>limpamos</strong> - redefinimos VALID (invalidação da linha de dados).  <strong>AND</strong> - saídas AND lógicas dos comparadores, o sinalizador de <strong>correspondência se</strong> transforma em '1' se a pesquisa nesta linha for bem-sucedida. </p><br><p>  Portanto, temos uma linha na qual podemos pesquisar.  Agora combine-os: </p><br><p><img src="https://habrastorage.org/webt/cn/be/1u/cnbe1uhkh4wyaxifvaq3fpxkbrs.png" alt="Cam_structure"></p><br><p>  <em>Figura 2. Estrutura CAM</em> </p><br><p>  Na Fig. 2, <strong>CAM_line</strong> é a própria linha CAM da Fig. 1, <strong>MUX</strong> é o multiplexador de endereço de entrada, <strong>MATCH REGISTER</strong> é um registro que armazena valores de flag de <strong>correspondência</strong> , <strong>ENCODER</strong> é um decodificador que converte o barramento de correspondência no endereço de correspondência mais baixo encontrado.  <strong>O FSM</strong> é uma máquina de controle de estados finitos, que é <strong>anterior.</strong>  <strong>match</strong> remove de MATCH REGISTER o bit correspondente ao endereço enviado, para que ENCODER alterne para o próximo endereço encontrado.  A interface do nosso CAM será a seguinte: </p><br><div class="scrollable-table"><table><thead><tr><th>  Linha </th><th>  Direção </th><th>  Nomeação </th></tr></thead><tbody><tr><td>  addr </td><td>  Entrar </td><td>  Escrever / Apagar Endereço </td></tr><tr><td>  dados </td><td>  Entrar </td><td>  Registro / Dados Chave </td></tr><tr><td>  nós </td><td>  Entrar </td><td>  Gravar sinalizador </td></tr><tr><td>  verificar </td><td>  Entrar </td><td>  Sinalizador de pesquisa de chaves </td></tr><tr><td>  claro </td><td>  Entrar </td><td>  Sinalizar linha de deficiência em </td></tr><tr><td>  addr_o </td><td>  Sair </td><td>  Endereço encontrado por chave </td></tr><tr><td>  match_o </td><td>  Sair </td><td>  Sinalizador de sucesso na pesquisa de chaves </td></tr></tbody></table></div><br><p>  <em>Tabela 1. Interface CAM</em> </p><br><p>  Abaixo, na Fig. 3, está um diagrama de tempo da operação desta interface, que mostra primeiro a gravação de três palavras no CAM, depois uma pesquisa bem sucedida, apagamento e pesquisa novamente: </p><br><p><img src="https://habrastorage.org/webt/zg/mw/vn/zgmwvnreqjf_ipoetqs-99mdrt4.png" alt="Cam_diagramm"><br>  <em>Figura 3. Diagrama de tempo da interface para o CAM</em> </p><br><p>  Então, temos uma descrição do CAM, vamos para a síntese. </p><br><h2 id="sintez">  Síntese </h2><br><p>  Vamos sintetizar no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Xilinx ISE</a> para comparar os resultados com os obtidos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">XAPP1151</a> . </p><br><p><img src="https://habrastorage.org/webt/wi/jq/so/wijqso_fo0rq-yvbtqvbfxadtzi.png" alt="W8v5"></p><br><p>  <em>Figura 4. Dependência de frequência após <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">XST</a> (sintetizador como parte do ISE) na profundidade do CAM para largura de barramento de dados de 8 bits</em> </p><br><p><img src="https://habrastorage.org/webt/0g/de/m4/0gdem4tk5j6b2yd3pn9sgcqtp0q.png" alt="W32v5"></p><br><p>  <em>Figura 5. Frequência após profundidade XST versus CAM para largura do barramento de dados de 32 bits</em> </p><br><p><img src="https://habrastorage.org/webt/s4/qs/nq/s4qsnqivplq45pvoylyokf947_0.png" alt="W64v5"></p><br><p>  <em>Figura 6. Frequência após profundidade XST versus CAM para largura do barramento de dados de 64 bits</em> </p><br><p>  Na Fig. 6, não há dados para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Virtex5</a> , pois o CAM desse tamanho não se encaixava no BRAM existente.  Também observamos que, para uma largura de 64 bits e uma profundidade de 1024, nosso resultado foi um pouco pior que o da implementação no SRL16.  Agora vamos à síntese do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vivado</a> para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">XC7K325T</a> .  Os resultados são os seguintes: </p><br><p><img src="https://habrastorage.org/webt/vx/3i/n-/vx3in-n-do46eukhxrkonmugvgy.png" alt="W32k7"></p><br><p>  <em>Figura 7. Dependência de frequência após <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PnR</a> (colocação de blocos no chip e rastreamento de sinal) na profundidade do CAM para uma largura de barramento de dados de 32 bits</em> </p><br><p><img src="https://habrastorage.org/webt/w6/1q/qc/w61qqcqylt_tb_0p1taxixcosps.png" alt="K7res"></p><br><p>  <em>Figura 8. Utilização de recursos para várias profundidades de CAM para uma largura de dados de 32 bits em%</em> </p><br><p>  É importante notar que os resultados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vivado</a> foram obtidos após o PnR, o que significa que o design não tem dificuldades em rastrear. </p><br><h2 id="tcam">  TCAM </h2><br><p>  Como mencionado acima, obter essa abordagem do CAM TCAM não era um problema específico.  É suficiente adicionar um barramento de mascaramento de dados para bits de dados e distribuí-lo pouco a pouco em comparadores, para que, ao comparar dados com uma chave, eles levem em consideração seu valor.  Essa mudança não levou a uma queda na frequência ou a um aumento sério dos recursos consumidos; por isso, adquirimos o TCAM gratuitamente. </p><br><h2 id="vyvody">  Conclusões </h2><br><p>  Assim, conseguimos concluir a tarefa.  O design resultante permite que a 7ª família Xilinx FPGA receba CAM suficientemente grande com uma frequência acima do alvo 125 MHz.  O resultado da comparação com o XAPP1151 foi inesperado para mim, presumi que a implementação no BRAM, embora seja muito cara em termos de recursos, ultrapassará a implementação frontal em frequência.  No entanto, não celebre a vitória tão cedo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> documento descreve o núcleo IP Xilinx CAM, que permite, por exemplo, obter CAM com profundidade de células 32K e frequência de 155 MHz, com base no BRAM.  Provavelmente, esse resultado pode ser alcançado na versão proposta no artigo, adicionando os estágios do pipeline ou coletando CAM grande de pequenos, mas não posso prever imediatamente se ele se encaixará no chip.  No futuro, tentarei implementar algo semelhante no BRAM, mas, por enquanto, obrigado por sua atenção. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470892/">https://habr.com/ru/post/pt470892/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470878/index.html">Crie construções de sintaxe JavaScript personalizadas usando Babel. Parte 2</a></li>
<li><a href="../pt470880/index.html">Mecânica de jogo. Aventura, o conceito de zero e terapia da fala convincente</a></li>
<li><a href="../pt470882/index.html">Por que você pegou meu mouse ou um jogo de tabuleiro como modelo de interação social</a></li>
<li><a href="../pt470884/index.html">Escrevendo e lendo dados no blockchain Bitcoin</a></li>
<li><a href="../pt470888/index.html">Legislação russa e internacional no campo da proteção de dados pessoais</a></li>
<li><a href="../pt470894/index.html">Bullet</a></li>
<li><a href="../pt470902/index.html">Alto desempenho e particionamento nativo: Zabbix com suporte ao TimescaleDB</a></li>
<li><a href="../pt470904/index.html">O caminho mais suave e peludo do aprendizado de máquina e das redes neurais profundas</a></li>
<li><a href="../pt470908/index.html">Pela primeira vez no mundo, com a ajuda de tecnologias aditivas, foi obtido um conjunto de motores de aeronaves de grande porte</a></li>
<li><a href="../pt470910/index.html">O que pode ser feito com anotações de contratos de microsserviço?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>