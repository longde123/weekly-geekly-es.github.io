<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴🏽 🗜️ 🌸 Nous développons un bot Telegram pour suivre les films sur NodeJS et TypeScript 👏🏾 🕴🏾 🏂🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il vous est arrivé que vous veniez au cinéma et que vous regardiez des bandes-annonces avant le début du film, tandis que certains s'accrochent à vous...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous développons un bot Telegram pour suivre les films sur NodeJS et TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443876/"><img src="https://habrastorage.org/webt/k8/du/50/k8du50aoufwmy7qczw9n6opy2mq.png"><br><br>  Il vous est arrivé que vous veniez au cinéma et que vous regardiez des bandes-annonces avant le début du film, tandis que certains s'accrochent à vous assez fortement et vous vous promettez de regarder ce film sinon au cinéma, puis au moins plus tard, quand il sera disponible en téléchargement ?  J'ose suggérer que oui.  Mais souvent, cela se termine par le fait que vous l'oubliez avec succès et, dans le meilleur des cas, que vous trouviez accidentellement ce film en faisant défiler la liste des films déjà sortis. <br><br>  J'ai souvent rencontré un tel problème et j'ai décidé de le créer avec Eve - Telegram-bot, ce qui m'aide à ne pas oublier les sorties de mes films préférés.  Qu'est-ce que c'est, comment cela fonctionne et comment il a été développé, vous pouvez lire sous la coupe! <br><a name="habracut"></a><br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Préface</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pourquoi?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sélection de technologies</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Telegraf.js</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structure du projet</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Initialisation et lancement</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gérer l'entrée utilisateur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Localisation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusion</a> </li></ul><br><a name="foreword"></a><h3>  Préface </h3><br>  Cet article n'est pas un guide détaillé sur la création de robots Telegram.  Et même si au cours de l'article je ferai souvent référence à mon projet, le but de ce matériel est une histoire de développement en général, à savoir le choix des technologies, les points clés et les écueils que j'ai rencontrés. <br><a name="why"></a><br><h3>  Pourquoi? </h3><br>  Donc, comme je l'ai écrit ci-dessus, j'oublie souvent de regarder ces films dont j'ai aimé la bande-annonce.  J'ai longtemps réfléchi à la solution à ce problème.  La première chose qui m'est venue à l'esprit a été la création d'une application native pour smartphones, mais depuis  Je n'ai jamais fait cela auparavant, cela prendrait beaucoup de temps et non le fait que le résultat final satisferait mes besoins, ainsi que les besoins des utilisateurs potentiels. <br><br>  L'idée suivante était de créer un PWA.  C’est une option assez intéressante pour se familiariser avec la technologie, mais j’ai décidé de la laisser pour l’avenir.  En même temps, j'utilise Telegram depuis longtemps et pendant tout ce temps, j'ai accumulé un nombre suffisant de bots qui me rendent périodiquement la vie un peu plus facile.  Finalement, après avoir pesé tous les avantages et les inconvénients, j'ai décidé que cette plate-forme est parfaite pour cette idée. <br><a name="technologies"></a><br><h3>  Sélection de technologies </h3><br>  Si vous passez par Github pour les bots Telegram, vous pouvez voir que la plupart d'entre eux sont écrits en Python.  Python est vraiment un excellent langage et idéal pour cette idée, mais je voulais implémenter ce projet spécifiquement sur NodeJS + TypeScript.  En appliquant les filtres appropriés, je suis tombé sur 2 outils assez populaires: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">node-telegram-bot-api</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Telegraf.js</a> . <br><br>  Avant cette expérience dans le développement de robots, je n'en avais pas, donc lors du choix parmi ces deux, il n'était pas clair quels paramètres devraient être examinés.  En conséquence, après avoir examiné la documentation et examiné les problèmes de chacune des bibliothèques, je me suis installé sur Telegraf.js.  Le facteur décisif a été la disponibilité des middlewares, qui sont conçus de la même manière que dans le cadre populaire d'Express.js.  Telegraf.js a également un historique des mises à jour plus fréquent et une documentation bien structurée, ce qui suggère que les développeurs font suffisamment d'efforts pour améliorer l'outil.  De plus, il contient des extraits pour TypeScript, ce qui est certainement un avantage pour la pile sélectionnée. <br><a name="telegraf"></a><br><h3>  Telegraf.js </h3><br>  Telegraf.js est la bibliothèque principale sur laquelle le projet a été écrit.  Il utilise plusieurs approches intéressantes qui vous permettent de créer des bots complexes tout en conservant la simplicité du code.  Voici les mécanismes les plus intéressants: <br><br><ul><li>  <b>Middlewares</b> - oui, ce sont les mêmes middlewares disponibles dans Express.js.  Lorsque l'utilisateur envoie quelque chose au bot, le message passe d'abord par tous les middlewares enregistrés, puis il parvient au contrôleur.  Les middlewares peuvent modifier le contexte, ainsi que suspendre l'exécution de la demande, par exemple, si un utilisateur régulier essaie d'accéder à la zone pour les administrateurs.  Telegraf.js fournit des middlewares extrêmement utiles prêts à l'emploi, mais vous pouvez également les utiliser vous-même.  À savoir les middlewares sont considérés comme des caractéristiques tueuses de Telegraf.js </li><li>  <b>Sessions</b> - sessions qui peuvent stocker des informations qui ne sont pas liées au contrôleur.  Vous pouvez donner une analogie avec des variables globales accessibles depuis n'importe où dans le bot.  Une chose très pratique, qui est utilisée, par exemple, pour la localisation.  Il est possible de stocker des sessions dans différents modes - DB, redis, fichiers locaux, etc. </li><li>  <b>Webooks</b> - le bot peut fonctionner dans deux modes - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polling long</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Webhooks</a> .  Et bien qu'ils fonctionnent tout aussi rapidement, il est préférable d'utiliser la deuxième option dans un environnement de production.  Ainsi, le bot n'aura pas besoin de frapper sur le serveur Telegram, à la place, il recevra lui-même toutes les mises à jour. <br><br>  <b>Important: Une</b> condition préalable pour les Webhooks est la prise en charge du serveur SSL / TLS.  Assurez-vous également que le port sur lequel Webhook s'exécute est ouvert et accessible de l'extérieur. </li><li>  <b>Balisage</b> - avec cette classe, vous pouvez apprendre au bot à répondre en balisage / balisage.  Ceci est important si, par exemple, vous créez un jeu HTML.  Cependant, dans mon projet, je ne l'ai utilisé que pour le texte en gras / italique. </li><li>  <b>Stage</b> est un module extrêmement intéressant qui m'a aidé à garder mes nerfs et quelques heures de développement.  Ici, je vais dire plus en détail. <br>  Le bot peut écouter les messages de l'utilisateur et, selon le type ou le contenu du message, le rediriger vers l'un ou l'autre contrôleur, qui remplira sa fonction et enverra une réponse à l'utilisateur.  Cela ressemble à ceci: <br><br><pre><code class="javascript hljs">bot.hears(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ctx =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ctx.reply(<span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>); });</code> </pre> <br>  Cela fonctionne simplement: si vous écrivez bonjour au bot, il répondra simplement bonjour!  Connaissant cet aspect du travail, essayons d'imaginer comment le bot peut fonctionner pour rechercher des films: <br><br><ol><li>  L'utilisateur écrit qu'il veut aller à la recherche de films; </li><li>  L'utilisateur pilote le nom du film; </li><li>  Le bot retourne une liste de films et invite l'utilisateur à enregistrer le film sélectionné dans sa bibliothèque; </li><li>  ... </li></ol><br>  Attention, une question!  Comment un bot peut-il distinguer quand un utilisateur lui écrit qu'il veut commencer à chercher un film et quand il écrit le nom du film à rechercher? <br><br>  <i>Oui, vous pouvez prendre n'importe quel texte envoyé comme nom du film, mais nous voulons faire du bot avec <s>blackjack et hookers une</s> bonne interface.</i> <br><br>  Et ici, les scènes (étapes) entrent en jeu!  Il sera plus facile à dire par l'exemple ci-dessus.  Lorsque l'utilisateur dit vouloir aller à la recherche de films, nous lançons la scène.  À l'intérieur de cette scène, il existe des gestionnaires de texte distincts - bot.hears (...).  Ainsi, tous les messages ultérieurs seront directement liés à la recherche de films jusqu'à ce que l'utilisateur écrive un message pour quitter et quitter la scène.  Après cela, les gestionnaires à l'intérieur de cette scène sont désactivés jusqu'à ce que l'utilisateur y revienne.  Je décrirai ensuite comment j'ai utilisé les scènes pour rendre la gestion des événements aussi simple que possible. <br></li></ul><br><a name="structure"></a><br><h3>  Structure du projet </h3><br>  On soupçonne que l'article se révélera assez volumineux et, par conséquent, afin de ne pas l'étirer encore plus, j'oublierai certains points.  Par exemple, pour que le bot commence à fonctionner, vous devez commencer par obtenir le jeton d'API Telegram Bot.  Vous pouvez lire comment procéder dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> officielle de Telegram ou dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> de Telegraf.js. <br><br>  La structure des fichiers du projet est la suivante: <br><br><div class="spoiler">  <b class="spoiler_title">Structure du projet</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/44/ps/n8/44psn8gqdploz320kpoh0yzmwxg.png"><br></div></div><br>  Cela fonctionne comme suit: <br><br><ul><li>  <b>src / controllers</b> - ce sont les scènes mêmes sur lesquelles il a été écrit ci-dessus.  Dans ce projet, chaque scène est un contrôleur distinct qui traite les requêtes correspondantes. </li><li>  <b>src / locales</b> - traductions pour différentes langues.  Telegraf.js facilite l'ajout de localisation au bot à l'aide de middlewares. </li><li>  <b>src / models</b> - modèles pour MongoDB. </li><li>  <b>src / types</b> - tippings pour TypeScript.  Malheureusement, toutes les bibliothèques utilisées dans le projet n'ont pas de synchronisation par défaut. </li><li>  <b>src / util</b> - diverses fonctions d'aide qui sont utilisées dans différentes parties du projet.  Ici, vous pouvez voir comment fonctionne la disponibilité du film pour le téléchargement, la gestion des sessions, la création de claviers, les gestionnaires d'erreurs et bien plus encore. </li><li>  <b>src / bot.ts</b> - le fichier principal où se fait toute la préparation et le lancement du bot. </li><li>  <b>src / telegram.ts</b> - dans ce cas, nous créons un objet de la classe Telegram à partir de la bibliothèque Telegraf.js.  En utilisant cet objet, nous pouvons d'abord envoyer des messages aux utilisateurs, en utilisant leur ID, et ne pas attendre qu'ils écrivent quelque chose.  Par exemple, dans ce projet, nous envoyons à l'utilisateur un message indiquant que le film qu'il suivait peut déjà être téléchargé.  Bien sûr, cet objet offre beaucoup plus de fonctionnalités. </li><li>  <b>Tout le reste</b> est des configurations pour différentes parties du projet qui ne seront pas discutées dans cet article. </li></ul><br><a name="start"></a><h3>  Initialisation et lancement </h3><br>  Lorsque nous avons compris la structure du projet, voyons comment le bot démarre réellement.  Encore une fois, afin de raccourcir l'article, je n'insérerai pas l'intégralité du code ici, mais je ne parlerai que des principaux moments, à mon avis,.  Vous pouvez voir le code complet dans le référentiel, un lien vers lequel est disponible à la fin de l'article. <br><br>  Tout commence par la connexion à la base de données, qui stocke des informations sur les utilisateurs et les films qu'ils suivent.  Après une connexion réussie, nous enregistrons toutes les scènes utilisées dans le projet, définissons les paramètres de localisation et ajoutons plusieurs middlewares - sessions de traitement, localisation, configuration de scènes, ainsi que plusieurs des nôtres.  L'un d'eux, par exemple, reçoit toutes les informations sur l'utilisateur conformément à son ID et les ajoute au contexte utilisé dans les contrôleurs.  Enfin, après toutes les préparations de base, nous lançons le bot en mode développement (polling long) ou production (Webhooks). <br><br>  <b>Important:</b> si vous utilisez différentes méthodes pour recevoir des mises à jour (interrogation longue et Webhooks), puis lors du démarrage du bot en mode interrogation longue, supprimez d'abord le Webhook d'écoute à l'aide de la demande GET sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">api.telegram.org/botYOUR_TOKEN/deleteWebhook</a> .  Sinon, le bot risque de ne pas fonctionner correctement. <br><a name="userinput"></a><br><h3>  Gérer l'entrée utilisateur </h3><br>  Hourra!  Le bot fonctionne, est connecté à la base de données et est prêt à recevoir des messages des utilisateurs.  Mais comment le faire correctement? <br><br>  Tout d'abord, il sera pratique pour les utilisateurs d'utiliser le clavier Telegram intégré.  En fait, lorsque vous cliquez sur les boutons de ce clavier, des messages sont envoyés avec le contenu de ces boutons.  Ensuite, nous ajoutons simplement des gestionnaires pour ce texte et effectuons certaines actions. <br><br>  Le fichier <a href="">bot.ts contient de</a> tels gestionnaires.  Étant donné que le bot prend en charge deux langues, les boutons peuvent également contenir du texte différent - en russe et en anglais.  Telegraf-i18n a une fonction de correspondance qui peut gérer le fait de cliquer sur le même bouton avec différentes langues. <br><br>  La plupart des gestionnaires de bot.ts remplissent une seule fonction - ils lancent l'utilisateur dans la scène correspondante.  Nous avons donc plusieurs sections - recherche de films, ma collection, les paramètres et les contacts.  Chaque section a sa propre scène et son propre bouton, lorsque vous cliquez dessus, l'utilisateur se déplace vers la scène correspondante. <br><br>  <b>Important:</b> assurez-vous d'ajouter un gestionnaire qui libérera l'utilisateur de la scène, sinon il risque d'y rester pour toujours!  Il sera également utile de faire une commande générale (/ saveme est utilisée dans le bot), qui sera ajoutée à chaque scène et au fichier principal.  Cette commande servira de sortie de n'importe quelle scène, ainsi que de réinitialiser les paramètres utilisateur. <br><br>  Et maintenant, l'utilisateur veut aller à la recherche de films.  En cliquant sur le bouton approprié, nous le déplaçons vers la scène de recherche.  Pour plus de commodité, chaque scène a son propre dossier avec des fichiers, chacun remplissant une fonction spécifique. <br><br>  À l'intérieur de la scène, vous pouvez utiliser vos middlewares, qui se trouvent dans le fichier middlewares.ts.  Par exemple, en utilisant un middleware dans la scène de recherche, nous pouvons simplement transférer toutes les informations sur le film dans les méthodes appropriées, plutôt que d'exécuter la même fonction à chaque fois à l'intérieur. <br><br>  Telegram possède également un clavier en ligne.  Vous avez peut-être rencontré des messages avec des votes, sous lesquels se trouvent plusieurs boutons translucides, et lorsque vous cliquez sur l'un d'eux, le nombre de votes change.  Ces boutons sont le clavier en ligne <br><br><div class="spoiler">  <b class="spoiler_title">Voilà à quoi ça ressemble à Eve</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gz/sn/-n/gzsn-nvolazzilaylnhy-ugacny.png"><br></div></div><br>  Chaque bouton contient des informations, lorsque vous cliquez sur le bouton, elles seront transmises au gestionnaire correspondant.  <b>La taille des informations transmises ne doit pas dépasser 64 octets!</b>  Pour apprendre au bot à écouter les clics sur les boutons, nous devons les enregistrer à l'aide de bot.action (/ trigger /, callback).  Le premier paramètre contient toutes les données liées au bouton.  J'ai décidé d'utiliser quelque chose comme Actions de Redux, où un objet de la forme {a: actionName, p: payload} est attaché à chaque bouton.  Lors de l'enregistrement des écouteurs, nous pouvons utiliser un simple RegExp, par exemple: bot.action (/ actionName /, callBack).  Tous les gestionnaires du clavier intégré se trouvent dans les fichiers actions.ts. <br><br>  De plus, dans certaines scènes, il y a des fichiers helpers.ts, qui contiennent de petites fonctions prises là-bas afin de décharger les fichiers restants.  Pour la plupart, il existe des générateurs de clavier pour diverses actions de l'utilisateur. <br><a name="localization"></a><br><h3>  Localisation </h3><br>  Puisqu'il s'agit d'un sujet important, je pense qu'il vaut la peine d'être mentionné séparément.  Comme je l'ai dit plus tôt, Telegraf.js contient un assez grand nombre de middlewares, dont l'un est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">telegraf-i18n</a> .  Le référentiel contient des instructions détaillées et je n'ai eu aucun problème particulier avec cela, mais néanmoins j'ajouterai quelques mots sur la façon dont cela fonctionne dans ce projet. <br><br>  Il existe un dossier de paramètres régionaux dans lequel se trouvent les fichiers de localisation, qui sont un objet JSON de la forme {"clé": "traduction"}.  De plus, partout où nous devons utiliser différentes langues, nous utilisons la méthode de cette bibliothèque, où nous transférons la traduction dont nous avons besoin par clé, et à la sortie, nous obtenons la traduction correspondante.  Une session peut être utilisée pour stocker des informations sur la langue sélectionnée par l'utilisateur.  Il convient également de mentionner à nouveau les boutons.  Il existe une fonction de correspondance dans la même bibliothèque, donc si le texte sur le bouton change en fonction de la langue, cette fonction vous aidera à suspendre l'auditeur approprié. <br><br>  <b>Important:</b> si vous allez utiliser la localisation et écrire un bot en TypeScript, n'oubliez pas d'ajouter le dossier de traduction à tsconfig.json, sinon le code ne sera pas compilé.  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"include"</span></span>: [<span class="hljs-string"><span class="hljs-string">"src/locales/*.json"</span></span>]</code> </pre> <br><a name="conclusion"></a><h3>  Conclusion </h3><br>  Merci d'avoir lu jusqu'au bout!  Dans cet article, j'ai essayé de décrire le processus de création d'un bot Telegram dans son ensemble aussi détaillé que possible, sans attachement fort à mon projet.  J'espère qu'après avoir lu cet article et étudié le code source d'Eve, vous pourrez facilement créer un bot qui pourra vous aider. <br><br>  Comme promis, vous pouvez consulter le code source sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> et essayer Eve en action <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Je serai extrêmement reconnaissant pour toute critique et suggestion d'amélioration. <br><br>  Je voudrais également noter la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">section</a> dans la documentation Telegraf.js avec des projets open source intéressants que vous pouvez regarder et vous inspirer de l'architecture et des solutions.  À mon tour, je veux mentionner l'un d'eux - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Guard Bot</a> .  Un bot vraiment grand et bien fait, d'où j'ai emprunté certaines des solutions pour mon développement. <br><br>  Et pour le moment j'ai dit tout ce que je voulais, je serai heureux de répondre à vos questions, suggestions et commentaires! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443876/">https://habr.com/ru/post/fr443876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443862/index.html">Les serrures de voiture du procureur. Bestchange est de nouveau verrouillé</a></li>
<li><a href="../fr443868/index.html">En tant que programmeur, je suis allé au gymnase, et ce qui en est sorti</a></li>
<li><a href="../fr443870/index.html">Unity: édition de maillage procédural</a></li>
<li><a href="../fr443872/index.html">Présentation des nouvelles fonctionnalités de nanoCAD SPDS Steelwork version 1.2</a></li>
<li><a href="../fr443874/index.html">Comparaison des frameworks d'apprentissage en profondeur: TensorFlow, PyTorch, Keras, MXNet, Microsoft Cognitive Toolkit, Caffe, etc.</a></li>
<li><a href="../fr443878/index.html">DEV Labs 2019. Python pour résoudre des tâches non triviales. Mitap en ligne</a></li>
<li><a href="../fr443882/index.html">MOSDROID # 15 Phosphorus: vidéo de performance</a></li>
<li><a href="../fr443884/index.html">3 qualités clés d'un chef de produit performant: Anton Danilov</a></li>
<li><a href="../fr443886/index.html">Résoudre une tâche à partir d'une interview Google sur JavaScript: 4 façons différentes</a></li>
<li><a href="../fr443894/index.html">Le quatrième niveau du multi-univers de Max Tegmark</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>