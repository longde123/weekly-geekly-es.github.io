<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🌾 🥜 👋🏻 Programmierung ist die Materialisierung von Ideen. 🔌 🆖 🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Hauptthese dieses Artikels: Softwareentwicklung sollte als Materialisierung von Ideen durch die Umwandlung von mentalen Modellen in Programmcode g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmierung ist die Materialisierung von Ideen.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425321/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ca/ha/pc/cahapcznbgjnjjfsimgdlkqovig.jpeg"></a> <br><br>  Die Hauptthese dieses Artikels: Softwareentwicklung sollte als Materialisierung von Ideen durch die Umwandlung von mentalen Modellen in Programmcode gesehen werden. <br>  Der Artikel beschreibt das Paradigma der Materialisierung von Ideen in der Softwareentwicklung (engl.: RPSE: Reification als Paradigma der Softwareentwicklung). <br><a name="habracut"></a><br>  Englische Version des Artikels: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RPSE</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reification als Paradigma des Software Engineering</a> .  Die Abkürzung RPSE wird später im Text verwendet, um das beschriebene Paradigma anzugeben. <br><br><h2>  Schlüsseldefinitionen </h2><br>  Bevor Sie mit der Erörterung der Hauptpunkte dieses Artikels fortfahren, müssen Sie sich auf die Bedeutung der darin verwendeten Grundbegriffe einigen. <br><br><h3>  Softwareentwicklung </h3><br>  Mit <b>Software-Engineering ist</b> die klassische Definition der Software-Engineering-Disziplin aus dem IEEE-Wörterbuch [1] gemeint: Software-Engineering ist „die Anwendung eines systematischen, disziplinierten, quantifizierbaren Ansatzes für die Entwicklung, den Betrieb und die Wartung von Software“. <br><br><h3>  Paradigma </h3><br>  Der in diesem Artikel verwendete Begriff <b>Paradigma</b> basiert auf der klassischen Definition des Thomas-Kuhn-Paradigmas [2]: Ein Paradigma ist ein Kreis von Problemen, eine Reihe von Konzepten, allgemein anerkannte Regeln und Gesetze, Methoden zur Lösung von Problemen in einem bestimmten Bereich der Wissenschaft. <br><br><div class="spoiler">  <b class="spoiler_title">Mehr zu Paradigmen</b> <div class="spoiler_text">  Um das unten verwendete Konzept des Paradigmas genauer zu bestimmen, ist es nützlich, zwei bekannte Zitate aus Kuhns Buch zu zitieren: <br><blockquote>  Mit Paradigmen meine ich anerkannte wissenschaftliche Errungenschaften, die der wissenschaftlichen Gemeinschaft seit einiger Zeit ein Modell für die Aufstellung von Problemen und deren Lösungen geben ... <br><br>  Mit der Einführung dieses Begriffs meinte ich, dass einige allgemein anerkannte Beispiele für die tatsächliche Praxis der wissenschaftlichen Forschung - Beispiele wie Recht, Theorie, ihre praktische Anwendung und die notwendige Ausrüstung - uns alle Modelle geben, aus denen spezifische Traditionen der wissenschaftlichen Forschung hervorgehen. </blockquote><br>  Der Dualismus dieses Konzepts liegt in der Tatsache, dass das Paradigma einerseits durch eine Gemeinschaft von Spezialisten gekennzeichnet ist, die es erkennen.  Es sind die Spezialisten eines bestimmten Bereichs, die seine Teile bestimmen, erstellen und entwickeln.  Andererseits bedeutet das Erkennen eines bestimmten Paradigmas für einen Spezialisten, der sich einer solchen Gemeinschaft anschließt. </div></div><br>  Thomas Kuhn hat in seinem Buch wissenschaftliche Paradigmen betrachtet.  Sehr bald nach der Veröffentlichung der ersten Ausgabe des Buches wurde jedoch deutlich, wie nützlich es ist, dieses Konzept in der Technologie und in verschiedenen Bereichen des sozialen Lebens einzusetzen.  In diesem Zusammenhang erschienen zahlreiche Veröffentlichungen zu Paradigmen und ihrem Wandel in der Automobilindustrie, zur Stadtplanung, zur Behandlung bestimmter Krankheiten usw. in der Fach- und Populärliteratur. <br><br>  Software-Engineering und insbesondere seine wichtige Komponente - Programmierung - waren keine Ausnahme.  Derzeit gibt es viele konkurrierende Programmierparadigmen.  Ein separater Artikel auf Wikipedia [3] sowie interessante Rezensionen wie [4] widmen sich ihrer Aufzählung. <br><br><div class="spoiler">  <b class="spoiler_title">Über die Grenzen von Programmierparadigmen</b> <div class="spoiler_text">  Die Autoren der in [3] und [4] beschriebenen Paradigmen konzentrieren sich auf einen engen Teilbereich der Softwareentwicklung, nämlich das Schreiben von Programmen in einer bestimmten Programmiersprache.  Ich denke, viele Fachleute sind sich einig, dass echte Softwareprojekte nicht nur im Rahmen eines dieser Paradigmen (z. B. funktionale Programmierung) abgeschlossen werden können. <br><br>  Das in diesem Artikel beschriebene Paradigma ist dagegen auf eine Vielzahl von Themenbereichen und Phasen der Softwareentwicklung anwendbar. </div></div><br><div class="spoiler">  <b class="spoiler_title">Über die Grenzen von Software-Projektmanagement-Paradigmen</b> <div class="spoiler_text">  Einige Autoren nennen beispielsweise in der Übersicht [5] verschiedene Ansätze oder Modelle zur Organisation und Durchführung von Softwareprojekten als Paradigmen.  Beispielsweise werden Wasserfallmodelle, V-Modelle oder agile Modelle verglichen.  Es ist unwahrscheinlich, dass diese Ansätze im Gegensatz zu den oben erwähnten Programmierparadigmen aufgrund ihrer relativen theoretischen Einfachheit und des Fehlens einer breiten theoretischen Basis als Paradigmen im Sinne von Kuhns Definition bezeichnet werden können. <br><br>  Das in diesem Artikel vorgeschlagene Paradigma hat ebenfalls noch keine eigene entwickelte theoretische Basis, aber seine Entwicklungspfade sind bereits heute sichtbar. </div></div><br><h3>  Materialisierung von Ideen </h3><br>  Der in diesem Artikel verwendete Begriff <b>Materialisierung von Ideen</b> (engl.: <i>Reification</i> ) ist eine Erweiterung der klassischen Definition von Reification in der Informatik: „Reification ist der Prozess, durch den eine abstrakte Idee eines Computerprogramms in ein explizites Datenmodell oder ein anderes in einer Programmiersprache erstelltes Objekt umgewandelt wird.“ [6]. <br><br><div class="spoiler">  <b class="spoiler_title">Mehr über die Welt der Ideen, die Welt der Dinge und die Materialisierung</b> <div class="spoiler_text">  Das Wesentliche der Erweiterung der klassischen Definition des in diesem Artikel verwendeten Materialisierungskonzepts kann wie folgt definiert werden. <br><br>  Bereits in den frühesten philosophischen Abschnitten, die uns überliefert sind, war es üblich, das Ideal (die Welt der Ideen) dem Material (der Welt der Dinge) gegenüberzustellen. <br><br>  Wir können das Ideal bestenfalls fühlen (oder denken, dass wir es fühlen).  Ein Indikator für ein solches Gefühl des Ideals kann eine Stimmungsänderung oder ein Gedankengang nach dem Hören eines Musikstücks, eines gelesenen Fragmentes eines Buches usw. sein.  Natürlich meine ich die indirekte Wirkung, zum Beispiel der Musik, auf unser Bewusstsein und nicht die primitive physiologische Unterordnung des Körpers unter das Dröhnen eines Rockkonzerts oder den Rhythmus einer Disco. <br><br>  Versuche, unseren Sinn für das Ideal in der Regel zu formulieren, führen nicht zum Erfolg. <br>  Der große russische Dichter Fedor Ivanovich Tyutchev bemerkte dies bemerkenswert: <br><blockquote>  Wie drückt sich das Herz aus? <br>  Wie kann man dich sonst verstehen? <br>  Wird er verstehen, wie du lebst? <br>  Der geäußerte Gedanke ist eine Lüge ... [7] </blockquote>  Selbst praktische Ideen wie kleinere Reparaturen rund ums Haus oder die Zubereitung einer neuen Variante eines bekannten Gerichts sind zunächst schwer zu formulieren.  Und erst nach Überlegungen oder dem Versuch, es einem anderen zu erklären, nimmt die Idee immer klarere „Umrisse“ an. <br><br>  Gehen wir nun von der Betrachtung des Idealbegriffs zur Betrachtung des Materials über.  Wir können materielle Objekte um uns herum erfassen und registrieren, um ihre Eigenschaften qualitativ zu unterscheiden.  Die Eigenschaften vieler Objekte können objektiv gemessen werden.  Wir können auch Hierarchien und andere Strukturen materieller Objekte objektiv identifizieren. </div></div><br>  Um zu bewerten oder zu messen (um quantitative Merkmale zu erhalten), ist es nicht erforderlich, einen Gegenstand zu haben.  Es reicht aus, sein Modell zu haben.  Darüber hinaus kann das Modell in vielen praktisch interessanten Situationen ohne Objekt verwendet werden.  Modelle können mit anderen besprochen werden.  Modelle können ausgehandelt werden.  Modelle können standardisiert (formalisiert) werden. <br><br>  In einigen Bereichen der menschlichen Tätigkeit ist die Standardisierung von Modellen so weit gegangen, dass Teile (z. B. Gewindebolzen), die auf der Grundlage eines standardisierten Modells (z. B. einer Zeichnung) von verschiedenen Personen oder Maschinengewehren hergestellt wurden, aus technologischer Sicht nicht zu unterscheiden sind. <br><br>  Um die relative Ungenauigkeit der vorgeschlagenen Definition zu erkennen, werde ich später in diesem Artikel die Welt der Phänomene unserer inneren und äußeren Welt <b>U</b> in zwei Teile teilen: <br><br>  <b>U = M + I.</b> <br><br>  wo die Menge <b>M</b> aus ihren Phänomenen besteht, die objektiv registriert oder gemessen werden können (materielle Welt) und <b>ich</b> - alles andere. <br><br>  Ob diese Formel auf absolut alle Phänomene der Welt um uns herum anwendbar ist, ist eine offene philosophische Frage.  Später in diesem Artikel beschränken wir den Umfang dieser Formel auf die Welt der Phänomene aus der Welt der Softwareentwicklung. <br><br>  Oder als These formuliert: Die gesamte Menge der Phänomene im Zusammenhang mit der Softwareentwicklung kann in eine Teilmenge des Ideals und eine Teilmenge des Materials unterteilt werden.  Darüber hinaus werden Materialphänomene anhand ihrer Modelle aufgezeichnet oder gemessen. <br>  Das Erstellen oder Ändern eines Softwaresystems endet in den meisten Fällen mit der Erstellung des einen oder anderen Codes, der mithilfe eines Computers in einem physischen Prozess angezeigt wird (ein reales Phänomen). <br><br>  Dieser Prozess beginnt mit der Entstehung bestimmter Ideen über das zukünftige System in den Köpfen von Kunden oder Entwicklern.  Wir werden diese Ideen und Ideen als <b>mentales Modell bezeichnen</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Über Zwischenmodelle</b> <div class="spoiler_text">  In einfachen Systemen oder mit einfachen Ergänzungen / Änderungen an großen Systemen schreibt der Entwickler sofort Code oder konfiguriert das System basierend auf seinem mentalen Modell.  In den meisten Fällen werden jedoch Zwischenmodelle mit unterschiedlicher Komplexität und unterschiedlichem Formalisierungsgrad erstellt - von einer einfachen Liste von Anforderungen bis hin zu umfangreichen formalen Modellen (z. B. UML- oder BPMN-Modelle). </div></div><br><h2>  Materialisierung von Ideen in Bereichen neben Software Engineering </h2><br>  Es ist klar, dass die obige Definition nicht radikal neu ist und in Bereichen der intellektuellen Arbeit neben der Programmierung (bewusst oder unbewusst) weit verbreitet ist.  Betrachten Sie beispielsweise zwei solche Bereiche - Maschinenbau und Mathematik. <br><br>  Diese beiden Bereiche nutzen die Materialisierung von Ideen seit langem und effektiv.  Sie müssen diesbezüglich viel über das Programmieren lernen. <br><br>  Im Maschinenbau sehen wir einen vollständigen Zyklus der Materialisierung von Ideen - von der Entstehung einer Idee im Kopf eines Designers über das Denken, Ausarbeiten, Abbilden in ein Modell bis hin zur Herstellung aus einem bestimmten Material. <br><br>  In der Mathematik ist die Situation anders. <br><br><div class="spoiler">  <b class="spoiler_title">Zur Materialisierung von Ideen in der Mathematik</b> <div class="spoiler_text">  Interessante Fakten und Überlegungen zur Materialisierung von Ideen in der Mathematik finden sich in Abschnitt 7.3 des Buches [8]. </div></div><br>  Das „Endprodukt“ der Mathematik sind formale Modelle mit streng nachgewiesenen Eigenschaften. <br><br>  Aus dieser Sicht liegt die Programmierung in der Mitte.  Dies kann grafisch wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/webt/8n/ja/84/8nja84baboink2t_bp02narqbja.png"><br><br>  Daher verwendet die Mathematik eine größere Anzahl abstrakterer Modelle und gilt fast nicht für den Bereich extrem spezifischer Modelle wie Konstruktionszeichnungen. <br><br>  Im Gegensatz dazu verwendet der Maschinenbau relativ wenige abstrakte Modelle, aber viele spezifische.  Zum Beispiel solche, für die physische Objekte eindeutig hergestellt werden können. <br><br>  Aus dieser Sicht liegt die Programmierung in der Mitte. <br><br><div class="spoiler">  <b class="spoiler_title">Warum ist die Programmierung in der Mitte?</b> <div class="spoiler_text">  Das endgültige Programmierprodukt ist Software-Code.  Und obwohl es, wenn es auf Hardware ausgeführt wird, auf bestimmte physikalische Objekte (elektrische Signale und Felder verschiedener physikalischer Natur) abgebildet wird, sind diese Objekte schwer mit Muttern, Zahnrädern und Karosserien zu vergleichen.  Andererseits kommt der Programmcode mathematischen Formeln nahe, und manchmal ist es ihre direkte Reflexion.  In jedem realen Softwaresystem müssen Sie jedoch viele spezifische Aspekte der Umgebung und der Interaktion mit Benutzern oder anderen Systemen berücksichtigen.  Dies macht den Programmcode spezifischer als mathematische Formeln. </div></div><br><div class="spoiler">  <b class="spoiler_title">Was Software Engineering von benachbarten Gebieten in Bezug auf die Modellnutzung lernen kann</b> <div class="spoiler_text">  Betrachten Sie zuerst die Mathematik. <br><br><h3>  Multimodell der Welt </h3><br>  Seit mehreren tausend Jahren ihrer Entwicklung hat die Mathematik gelernt, dieselben Phänomene der realen oder imaginären Welt in sehr unterschiedlichen Begriffen zu beschreiben.  Die alten Griechen lernten, rein verbale Aufgabenbeschreibungen durch geometrische Figuren zu ersetzen und mit ihrer Hilfe praktisch wichtige Probleme zu lösen.  Später zeigte sich ein Verständnis für die Austauschbarkeit von Segmenten in der Ebene und Zahlen.  Dann kristallisierte sich das Konzept einer algebraischen Variablen und die Reduktion geometrischer Probleme auf algebraische Gleichungssysteme heraus. <br><br>  Schüler wissen bereits heute, dass dasselbe Problem auf unterschiedliche Weise gelöst werden kann (z. B. geometrisch oder algebraisch) und dass dasselbe mathematische Modell, z. B. eine algebraische Gleichung, viele verschiedene physikalische, chemische usw. beschreibt.  Phänomene. <br><br><h3>  Morphismus von Modellen und Konsistenz von Konzepten und Notationen </h3><br>  Die Mathematik hat gut gelernt, nicht nur dieselben realen oder imaginären Objekte und Prozesse mit Modellen sehr unterschiedlicher mathematischer Natur zu beschreiben.  Eine wichtige Errungenschaft der Mathematik ist die Fähigkeit, den Ähnlichkeitsgrad von Modellen aus verschiedenen Bereichen der Mathematik zu bestimmen sowie sie ineinander umzuwandeln.  Viele bahnbrechende Lösungen für die wichtigsten mathematischen Probleme der letzten Jahre sind im Wesentlichen Ketten getrennter Beweise, von denen jede einen speziellen Apparat aus einem speziellen Bereich der Mathematik verwendet.  An den Knotenpunkten dieser hochspezialisierten Evidenz wandelt die Mathematik Modelle eines Abschnitts der Mathematik gekonnt in Modelle eines anderen Abschnitts um.  Bei der Programmierung geschieht jetzt etwas Ähnliches, wenn der Quellcode eines Programms kompiliert und Code aus DSL (Domain Specific Language) oder Metadaten generiert wird.  Die Kultur der Arbeit mit Modellen im Bereich der Softwareentwicklung liegt jedoch weit hinter der mathematischen zurück. <br><br><h3>  Modelle im Maschinenbau </h3><br>  Und was kann Software Engineering aus der Materialisierung im Engineering lernen? <br>  In vielen Branchen und sogar in großen Unternehmen gibt es Ketten koordinierter formaler und semi-formaler Modelle.  Diese Ketten enden mit Modellen, auf deren Grundlage physische Objekte hergestellt und montiert werden - Geräte und Maschinen.  In der Regel gibt es für die meisten Arten von Zwischenmodellen formale Methoden zur Überprüfung ihrer Richtigkeit (technische Standards).  Modelle sind die Hauptkommunikationssprache von Spezialisten mit unterschiedlichen Profilen bei der Entwicklung und Herstellung technischer Produkte. <br><br>  Vor diesem Hintergrund sieht die Situation in der IT viel schlimmer aus.  Nur innerhalb sehr großer IT-Belange wurden in den letzten Jahren Versuche unternommen, vergleichbare Modelle und Prozesse zu erstellen.  Kleine Unternehmen und IT-Startups haben in der Regel nicht nur keine formalen Modelle und Prozesse entwickelt, sondern vermuten deren Existenz nicht einmal.  Diese Situation wird derzeit von folgenden Faktoren bestimmt: <br><br><ul><li>  Die mangelnde Effizienz bestehender Modelle und Prozesse </li><li>  Der Mangel an Ruhm dieser Modelle außerhalb großer Bedenken </li><li>  Unzureichende Ausbildung für Entwickler und insbesondere Manager </li><li>  Der Rückstand der Universitätsausbildung aus den tatsächlichen Bedürfnissen des Software-Engineerings. </li></ul></div></div><br><h2>  Definition und Konturen des Paradigmas der Materialisierung von Ideen (RPSE) </h2><br>  Wir haben alle notwendigen Konzepte identifiziert, um eine grundlegende Definition des vorgeschlagenen Paradigmas zu geben.  Hier ist es: <br><blockquote>  Softwareentwicklung ist die Materialisierung von Ideen durch die Umwandlung von mentalen Modellen in Code, der auf Computern ausgeführt wird. <br><br>  Im Rahmen des vorgeschlagenen Paradigmas: <br><br><ol><li>  Alle wichtigen Softwareentwicklungsprozesse sind spezifische Varianten (Implementierungen) des Prozesses zur Konstruktion von Ketten mentaler und materieller Modelle.  Das letzte spezifischste Modell in dieser Kette ist in der Regel der Programmcode. </li><li>  Die Essenz der Softwareentwicklung besteht darin, solche Ketten zu erstellen. </li><li>  Alle Hauptprobleme der Entwicklungsoptimierung, der Kostensenkung und der Qualitätsverbesserung können auf die Optimierung der Konstruktion der entsprechenden Modellkette reduziert werden. </li></ol></blockquote><br><div class="spoiler">  <b class="spoiler_title">Warum Materialisierung und nicht Modellierung?</b> <div class="spoiler_text">  Es ist zu beachten, dass sich die Definition von RPSE zwar auf die Konstruktion von Modellketten bezieht, jedoch vorgeschlagen wird, die Paradigmenmaterialisierung eher als Modellierung zu bezeichnen.  Daher wird versucht, die Besonderheit von Modellketten hervorzuheben, die immer weniger abstrakt / ideal und immer konkreter / materieller werden. </div></div><br>  Die obige Definition hat ihre eigenen Eigenschaften und Variationen in verschiedenen Bereichen der Softwareentwicklung.  Nur in sehr wenigen Fällen kommt es vor, dass im Kopf eines Programmierers eine klare Vorstellung davon, wie das Problem vor ihm gelöst werden kann, vollständig reift, die er dann in kurzer Zeit in einen Programmiersprachencode übersetzt.  In den meisten realen Projekten besteht der Prozess der Lösungsfindung und deren Implementierung nebeneinander, entwickelt sich parallel und interagiert miteinander.  Das heißt,  Mentale Modelle, Code und häufig Zwischenmodelle (in Form eines Tests, Bilder, formale Modelle wie UML) wachsen und ändern sich parallel und beeinflussen sich gegenseitig. <br><br><div class="spoiler">  <b class="spoiler_title">Definitionsoptionen</b> <div class="spoiler_text">  Sehr oft arbeiten mehrere Personen gleichzeitig an einem Problem.  Jeder von ihnen hat sein eigenes mentales Modell und möglicherweise seine Zwischenmodelle und Codefragmente. <br><br>  Oft fehlt der Code in einer Programmiersprache praktisch, da bei der Erstellung einer neuen Lösung Masken von Konfiguratoren oder Generatoren verwaltet werden müssen, beispielsweise bei der Arbeit mit Entwicklungstools in Systemen wie SAP oder WebSphere. <br><br>  Die Möglichkeiten, manuell geschriebenen oder automatisch generierten Code in ausführbaren Code umzuwandeln, sind heutzutage ebenfalls sehr vielfältig. <br><br>  Und schließlich hat sich auch das Konzept des Prozessors, auf dem der Code ausgeführt wird, in den letzten Jahren erheblich erweitert.  Waren früher Prozessoren auf den Brettern, die wiederum in die Schalen von Desktops, Laptops und Server-Racks eingesetzt wurden, wurde dieses Set jetzt um verschiedene Chips unterschiedlicher Größe erweitert, die in Mobiltelefone, Spielekonsolen und Überwachungskameras eingebaut sind. “ intelligente "Haushaltsgeräte usw.  Ganz zu schweigen von Quantencomputern. <br><br>  Trotzdem ist RPSE aufgrund seiner Allgemeinheit auf alle oben aufgeführten Bereiche anwendbar. </div></div><br>  Was kann man heute noch über ein bestimmtes Paradigma sagen? Ist es möglich, seine Konturen irgendwie genauer zu skizzieren? <br><br>  Der nächste Schritt zur Verfeinerung des Paradigmas nach dem Versuch, seine Hauptdefinition anzugeben, ist der Versuch, die Hauptkategorien von Phänomenen aufzulisten, die es betrifft.  Unter Hinweis auf Kuhns Definition müssen wir versuchen, die Modelltypen aufzulisten, die RPSE einführt und verwendet. <br><br>  RPSE-Modelle können in drei Hauptkategorien unterteilt werden: <br><br><ul><li>  Mentale Modelle </li><li>  Code in Programmiersprachen oder seinen Entsprechungen als Modelle für ausführbaren Code. </li><li>  Zwischenmodelle. </li></ul><br>  Die am wenigsten erforschten in dieser Triade sind mentale Modelle.  Was genau ist mit ihnen gemeint? <br><br>  <b>Mentale Modelle</b> sind ein Begriff für Ideen, die im Kopf von Kunden, Programmierern und anderen Teilnehmern des Prozesses existieren und auf deren Grundlage der ausführbare Code schließlich entsteht.  Das Vorhandensein solcher Modelle ist unbestreitbar und kann auf mentaler Ebene beispielsweise vom Programmierer selbst registriert werden.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem derzeitigen Stand der technologischen Entwicklung können diese Modelle nicht zuverlässig mit Instrumenten gemessen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine der gut funktionierenden Möglichkeiten, solche Modelle zu fixieren und zu messen, besteht darin, das Medium der Idee zu verwenden. </font><font style="vertical-align: inherit;">Offensichtlich wirken sich der Interviewprozess oder ähnliche dramatisch auf das mentale Modell selbst aus. </font><font style="vertical-align: inherit;">Jeder von uns muss mehr als einmal eine Situation erlebt haben, in der der Versuch, ein Problem zu formulieren, um sich mit einem Kollegen zu beraten, zu einem „Einblick“ und häufig zu einer Lösung des Problems führte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interviews ermöglichen es, basierend auf korrekt formulierten Fragen relativ objektiv Modelle unterschiedlicher Komplexität zu erstellen. </font><font style="vertical-align: inherit;">Die häufigsten sind: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturmodelle:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listen mit Binär-, Aufzählungs-, Zahlen-, Zeichenfolgen- und anderen Werten. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grafik- und Netzwerkdatenstrukturen </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verhaltensbeschreibungsmodelle: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sieben formale Modelle zur Bestimmung des Verhaltens </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Formale Modelle zur Bestimmung des Verhaltens (z. B. Finite-State-Maschinen) </font></font></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur Theorie der mentalen Modelle</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Muster spiegeln mentale Muster wider. </font><font style="vertical-align: inherit;">Der Grad der Nähe von mentalen Modellen zu realen Modellen sollte durch Psychologie oder theoretische Pädagogik behandelt werden. </font><font style="vertical-align: inherit;">Leider sind dem Autor keine ernsthaften Arbeiten in diesem Bereich bekannt. </font><font style="vertical-align: inherit;">(Dies bedeutet nicht, dass solche Arbeiten nicht existieren).</font></font></div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warum braucht Software Engineering ein End-to-End-Paradigma? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Vorhandensein eines „übergreifenden“ Paradigmas eröffnet den Teilnehmern die folgenden Möglichkeiten, das Paradigma des Prozesses der Erstellung, Änderung und Verwendung von Software zu nutzen: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Fähigkeit aller Teilnehmer am Prozess, dieselbe Terminologie zu verwenden. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Fähigkeit, einen End-to-End-Prozess zum Erstellen neuer Software zu erstellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Fähigkeit, seine Prozessparameter, seine Zwischenergebnisse zu bewerten und zu verwalten. </font></font></li></ul>  . <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Hauptziele der Paradigmenentwicklung </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Theoretische Probleme </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie wiederholt festgestellt wurde, einschließlich im Buch Kuhn [2], sind Wissenschaftler in den meisten Fällen an der Lösung potenzieller Probleme beteiligt, die gelöst werden, und es ist weniger wahrscheinlich, dass sie sich mit solchen Problemen befassen, deren Vorgehensweise nicht sehr klar ist. </font><font style="vertical-align: inherit;">Aber genau das sind unsere Aufgaben.</font></font> Hier sind die wichtigsten: <br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstruktive Definition des Konzepts des mentalen Modells. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suche nach konstruktiven Kriterien zur Beurteilung des Grads der Abstraktheit / Idealität vs. </font><font style="vertical-align: inherit;">Spezifität / Materialität von Modellen.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suche nach Kriterien für die Auswahl von Kandidaten für die Rolle von Zwischen- und Zusatzmodellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auswahl und Entwicklung von Kriterien und Methoden zum Vergleich von Modellen verschiedener Typen, einschließlich ihrer direkten und umgekehrten Verfolgung. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entwicklung von Methoden zur automatisierten und automatischen Transformation von Modellen. </font></font></li></ol><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Praktische Aufgaben </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Neben theoretischen Aufgaben zur Entwicklung und Implementierung des beschriebenen Paradigmas in der Praxis des Software Engineerings müssen mindestens folgende praktische Probleme gelöst werden: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellung von Werkzeugen für: a) Extraktion und Fixierung von mentalen Modellen. </font><font style="vertical-align: inherit;">b) Automatisierte und automatische Umwandlung von mentalen Modellen in Zwischenmodelle. </font><font style="vertical-align: inherit;">c) Spuren und Schätzungen von Änderungen im Inhalt transformierbarer Modelle</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellung der notwendigen technischen und pädagogischen Literatur und anderen medialen Lehrmaterialien. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Organisation von Foren und Konferenzen zu diesem Thema </font></font></li></ol><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Artikel versucht, das Paradigma der Softwareentwicklung als Materialisierung von Ideen zu definieren. Das zu definierende (und nicht offene) Wort wird hier nicht zufällig verwendet. Tatsächlich beschäftigen sich Teilnehmer an IT-Projekten seit langem mit der Erstellung, Transformation und Verwendung von Modellen, möglicherweise ohne dies zu bemerken. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im engeren Sinne von Kuhns Definition kann der beschriebene Ansatz noch nicht das Recht beanspruchen, als Paradigma bezeichnet zu werden, sondern nur als Kandidat für ein Paradigma, da es keine umfangreiche Gemeinschaft von Menschen gibt, die es unterstützen, und kein gut entwickeltes System miteinander verbundener Modelle. Ich möchte jedoch glauben, dass die Mängel bald behoben sein werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist der erste Artikel in einer geplanten Artikelserie. In den folgenden Artikeln werde ich über mentale und Zwischenmodelle sprechen.</font></font><br><br><h3>  Literatur </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. IEEE-Standardglossar der Software-Engineering-Terminologie, IEEE std 610.12-1990, 1990. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Kuhn, Thomas S. Die Struktur wissenschaftlicher Revolutionen. 3rd ed. Chicago, IL: University of Chicago Press, 1996. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Programmierparadigma: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Programming_paradigm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Bundesland - 27.08.2008) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Peter A. Henning, Holger Vogelsang Taschenbuch Programmiersprachen. Carl Hanser Verlag GmbH &amp; Co. KG; Auflage: 2., neu bearbeitete (5. September 2007). ISBN-13: 978-3446407442. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Paradigmen und Modelle der Softwareentwicklung Aufsatz </font></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">über</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Informationstechnologie </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">www.uniassignment.com/essay-samples/information-technology/software-engineering-paradigms-and-models-information-technology-essay.php</font></a><font style="vertical-align: inherit;"> (Stand - </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">28.08.2018</font></a><font style="vertical-align: inherit;"> )</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Reification (Informatik) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Reification_</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (computer_science) (Bundesstaat - 27.08.2008) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Fedor Ivanovich Tyutchev. </font><font style="vertical-align: inherit;">Silentium! </font><font style="vertical-align: inherit;">(Silence (lat.), 1829. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Borovik, Alexandre. Mathematik unter dem Mikroskop: Anmerkungen zu kognitiven Aspekten der mathematischen Praxis. American Mathematical Society. ISBN-13: 978-0821847619. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Illustration: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geralt</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425321/">https://habr.com/ru/post/de425321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425305/index.html">Wie die Chemical Brothers Arrangements zeigen: Technische Details und Umstellung</a></li>
<li><a href="../de425311/index.html">Das Buch "Programmieren für Kinder. Von den Grundlagen bis zur Erstellung von Robotern</a></li>
<li><a href="../de425313/index.html">Die 10 besten VS Code-Erweiterungen von 2018 für Front-End-Entwickler</a></li>
<li><a href="../de425315/index.html">Anordnen der Codespeicherung in GitLab und Integrieren der Codeüberprüfung in GitFlow</a></li>
<li><a href="../de425317/index.html">Wie es gemacht wird: Wir schreiben "Minesweeper" in 4 Minuten</a></li>
<li><a href="../de425323/index.html">"Kaninchenbau." UX Designer im Produktteam</a></li>
<li><a href="../de425325/index.html">DIY Bytecode Interpreter</a></li>
<li><a href="../de425327/index.html">Funktionsprogrammierung: Siebenmal messen, einmal schneiden</a></li>
<li><a href="../de425329/index.html">Einige Ratschläge an die Millennials von den "Oldies". Wie man in unserer digitalen Welt erfolgreich ist</a></li>
<li><a href="../de425331/index.html">Alice hilft Entwicklern, Objekte in Benutzeranforderungen zu finden. NER in Dialogen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>