<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüåæ ü•ú üëãüèª Programmierung ist die Materialisierung von Ideen. üîå üÜñ üé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Hauptthese dieses Artikels: Softwareentwicklung sollte als Materialisierung von Ideen durch die Umwandlung von mentalen Modellen in Programmcode g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmierung ist die Materialisierung von Ideen.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425321/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ca/ha/pc/cahapcznbgjnjjfsimgdlkqovig.jpeg"></a> <br><br>  Die Hauptthese dieses Artikels: Softwareentwicklung sollte als Materialisierung von Ideen durch die Umwandlung von mentalen Modellen in Programmcode gesehen werden. <br>  Der Artikel beschreibt das Paradigma der Materialisierung von Ideen in der Softwareentwicklung (engl.: RPSE: Reification als Paradigma der Softwareentwicklung). <br><a name="habracut"></a><br>  Englische Version des Artikels: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RPSE</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reification als Paradigma des Software Engineering</a> .  Die Abk√ºrzung RPSE wird sp√§ter im Text verwendet, um das beschriebene Paradigma anzugeben. <br><br><h2>  Schl√ºsseldefinitionen </h2><br>  Bevor Sie mit der Er√∂rterung der Hauptpunkte dieses Artikels fortfahren, m√ºssen Sie sich auf die Bedeutung der darin verwendeten Grundbegriffe einigen. <br><br><h3>  Softwareentwicklung </h3><br>  Mit <b>Software-Engineering ist</b> die klassische Definition der Software-Engineering-Disziplin aus dem IEEE-W√∂rterbuch [1] gemeint: Software-Engineering ist ‚Äûdie Anwendung eines systematischen, disziplinierten, quantifizierbaren Ansatzes f√ºr die Entwicklung, den Betrieb und die Wartung von Software‚Äú. <br><br><h3>  Paradigma </h3><br>  Der in diesem Artikel verwendete Begriff <b>Paradigma</b> basiert auf der klassischen Definition des Thomas-Kuhn-Paradigmas [2]: Ein Paradigma ist ein Kreis von Problemen, eine Reihe von Konzepten, allgemein anerkannte Regeln und Gesetze, Methoden zur L√∂sung von Problemen in einem bestimmten Bereich der Wissenschaft. <br><br><div class="spoiler">  <b class="spoiler_title">Mehr zu Paradigmen</b> <div class="spoiler_text">  Um das unten verwendete Konzept des Paradigmas genauer zu bestimmen, ist es n√ºtzlich, zwei bekannte Zitate aus Kuhns Buch zu zitieren: <br><blockquote>  Mit Paradigmen meine ich anerkannte wissenschaftliche Errungenschaften, die der wissenschaftlichen Gemeinschaft seit einiger Zeit ein Modell f√ºr die Aufstellung von Problemen und deren L√∂sungen geben ... <br><br>  Mit der Einf√ºhrung dieses Begriffs meinte ich, dass einige allgemein anerkannte Beispiele f√ºr die tats√§chliche Praxis der wissenschaftlichen Forschung - Beispiele wie Recht, Theorie, ihre praktische Anwendung und die notwendige Ausr√ºstung - uns alle Modelle geben, aus denen spezifische Traditionen der wissenschaftlichen Forschung hervorgehen. </blockquote><br>  Der Dualismus dieses Konzepts liegt in der Tatsache, dass das Paradigma einerseits durch eine Gemeinschaft von Spezialisten gekennzeichnet ist, die es erkennen.  Es sind die Spezialisten eines bestimmten Bereichs, die seine Teile bestimmen, erstellen und entwickeln.  Andererseits bedeutet das Erkennen eines bestimmten Paradigmas f√ºr einen Spezialisten, der sich einer solchen Gemeinschaft anschlie√üt. </div></div><br>  Thomas Kuhn hat in seinem Buch wissenschaftliche Paradigmen betrachtet.  Sehr bald nach der Ver√∂ffentlichung der ersten Ausgabe des Buches wurde jedoch deutlich, wie n√ºtzlich es ist, dieses Konzept in der Technologie und in verschiedenen Bereichen des sozialen Lebens einzusetzen.  In diesem Zusammenhang erschienen zahlreiche Ver√∂ffentlichungen zu Paradigmen und ihrem Wandel in der Automobilindustrie, zur Stadtplanung, zur Behandlung bestimmter Krankheiten usw. in der Fach- und Popul√§rliteratur. <br><br>  Software-Engineering und insbesondere seine wichtige Komponente - Programmierung - waren keine Ausnahme.  Derzeit gibt es viele konkurrierende Programmierparadigmen.  Ein separater Artikel auf Wikipedia [3] sowie interessante Rezensionen wie [4] widmen sich ihrer Aufz√§hlung. <br><br><div class="spoiler">  <b class="spoiler_title">√úber die Grenzen von Programmierparadigmen</b> <div class="spoiler_text">  Die Autoren der in [3] und [4] beschriebenen Paradigmen konzentrieren sich auf einen engen Teilbereich der Softwareentwicklung, n√§mlich das Schreiben von Programmen in einer bestimmten Programmiersprache.  Ich denke, viele Fachleute sind sich einig, dass echte Softwareprojekte nicht nur im Rahmen eines dieser Paradigmen (z. B. funktionale Programmierung) abgeschlossen werden k√∂nnen. <br><br>  Das in diesem Artikel beschriebene Paradigma ist dagegen auf eine Vielzahl von Themenbereichen und Phasen der Softwareentwicklung anwendbar. </div></div><br><div class="spoiler">  <b class="spoiler_title">√úber die Grenzen von Software-Projektmanagement-Paradigmen</b> <div class="spoiler_text">  Einige Autoren nennen beispielsweise in der √úbersicht [5] verschiedene Ans√§tze oder Modelle zur Organisation und Durchf√ºhrung von Softwareprojekten als Paradigmen.  Beispielsweise werden Wasserfallmodelle, V-Modelle oder agile Modelle verglichen.  Es ist unwahrscheinlich, dass diese Ans√§tze im Gegensatz zu den oben erw√§hnten Programmierparadigmen aufgrund ihrer relativen theoretischen Einfachheit und des Fehlens einer breiten theoretischen Basis als Paradigmen im Sinne von Kuhns Definition bezeichnet werden k√∂nnen. <br><br>  Das in diesem Artikel vorgeschlagene Paradigma hat ebenfalls noch keine eigene entwickelte theoretische Basis, aber seine Entwicklungspfade sind bereits heute sichtbar. </div></div><br><h3>  Materialisierung von Ideen </h3><br>  Der in diesem Artikel verwendete Begriff <b>Materialisierung von Ideen</b> (engl.: <i>Reification</i> ) ist eine Erweiterung der klassischen Definition von Reification in der Informatik: ‚ÄûReification ist der Prozess, durch den eine abstrakte Idee eines Computerprogramms in ein explizites Datenmodell oder ein anderes in einer Programmiersprache erstelltes Objekt umgewandelt wird.‚Äú [6]. <br><br><div class="spoiler">  <b class="spoiler_title">Mehr √ºber die Welt der Ideen, die Welt der Dinge und die Materialisierung</b> <div class="spoiler_text">  Das Wesentliche der Erweiterung der klassischen Definition des in diesem Artikel verwendeten Materialisierungskonzepts kann wie folgt definiert werden. <br><br>  Bereits in den fr√ºhesten philosophischen Abschnitten, die uns √ºberliefert sind, war es √ºblich, das Ideal (die Welt der Ideen) dem Material (der Welt der Dinge) gegen√ºberzustellen. <br><br>  Wir k√∂nnen das Ideal bestenfalls f√ºhlen (oder denken, dass wir es f√ºhlen).  Ein Indikator f√ºr ein solches Gef√ºhl des Ideals kann eine Stimmungs√§nderung oder ein Gedankengang nach dem H√∂ren eines Musikst√ºcks, eines gelesenen Fragmentes eines Buches usw. sein.  Nat√ºrlich meine ich die indirekte Wirkung, zum Beispiel der Musik, auf unser Bewusstsein und nicht die primitive physiologische Unterordnung des K√∂rpers unter das Dr√∂hnen eines Rockkonzerts oder den Rhythmus einer Disco. <br><br>  Versuche, unseren Sinn f√ºr das Ideal in der Regel zu formulieren, f√ºhren nicht zum Erfolg. <br>  Der gro√üe russische Dichter Fedor Ivanovich Tyutchev bemerkte dies bemerkenswert: <br><blockquote>  Wie dr√ºckt sich das Herz aus? <br>  Wie kann man dich sonst verstehen? <br>  Wird er verstehen, wie du lebst? <br>  Der ge√§u√üerte Gedanke ist eine L√ºge ... [7] </blockquote>  Selbst praktische Ideen wie kleinere Reparaturen rund ums Haus oder die Zubereitung einer neuen Variante eines bekannten Gerichts sind zun√§chst schwer zu formulieren.  Und erst nach √úberlegungen oder dem Versuch, es einem anderen zu erkl√§ren, nimmt die Idee immer klarere ‚ÄûUmrisse‚Äú an. <br><br>  Gehen wir nun von der Betrachtung des Idealbegriffs zur Betrachtung des Materials √ºber.  Wir k√∂nnen materielle Objekte um uns herum erfassen und registrieren, um ihre Eigenschaften qualitativ zu unterscheiden.  Die Eigenschaften vieler Objekte k√∂nnen objektiv gemessen werden.  Wir k√∂nnen auch Hierarchien und andere Strukturen materieller Objekte objektiv identifizieren. </div></div><br>  Um zu bewerten oder zu messen (um quantitative Merkmale zu erhalten), ist es nicht erforderlich, einen Gegenstand zu haben.  Es reicht aus, sein Modell zu haben.  Dar√ºber hinaus kann das Modell in vielen praktisch interessanten Situationen ohne Objekt verwendet werden.  Modelle k√∂nnen mit anderen besprochen werden.  Modelle k√∂nnen ausgehandelt werden.  Modelle k√∂nnen standardisiert (formalisiert) werden. <br><br>  In einigen Bereichen der menschlichen T√§tigkeit ist die Standardisierung von Modellen so weit gegangen, dass Teile (z. B. Gewindebolzen), die auf der Grundlage eines standardisierten Modells (z. B. einer Zeichnung) von verschiedenen Personen oder Maschinengewehren hergestellt wurden, aus technologischer Sicht nicht zu unterscheiden sind. <br><br>  Um die relative Ungenauigkeit der vorgeschlagenen Definition zu erkennen, werde ich sp√§ter in diesem Artikel die Welt der Ph√§nomene unserer inneren und √§u√üeren Welt <b>U</b> in zwei Teile teilen: <br><br>  <b>U = M + I.</b> <br><br>  wo die Menge <b>M</b> aus ihren Ph√§nomenen besteht, die objektiv registriert oder gemessen werden k√∂nnen (materielle Welt) und <b>ich</b> - alles andere. <br><br>  Ob diese Formel auf absolut alle Ph√§nomene der Welt um uns herum anwendbar ist, ist eine offene philosophische Frage.  Sp√§ter in diesem Artikel beschr√§nken wir den Umfang dieser Formel auf die Welt der Ph√§nomene aus der Welt der Softwareentwicklung. <br><br>  Oder als These formuliert: Die gesamte Menge der Ph√§nomene im Zusammenhang mit der Softwareentwicklung kann in eine Teilmenge des Ideals und eine Teilmenge des Materials unterteilt werden.  Dar√ºber hinaus werden Materialph√§nomene anhand ihrer Modelle aufgezeichnet oder gemessen. <br>  Das Erstellen oder √Ñndern eines Softwaresystems endet in den meisten F√§llen mit der Erstellung des einen oder anderen Codes, der mithilfe eines Computers in einem physischen Prozess angezeigt wird (ein reales Ph√§nomen). <br><br>  Dieser Prozess beginnt mit der Entstehung bestimmter Ideen √ºber das zuk√ºnftige System in den K√∂pfen von Kunden oder Entwicklern.  Wir werden diese Ideen und Ideen als <b>mentales Modell bezeichnen</b> . <br><br><div class="spoiler">  <b class="spoiler_title">√úber Zwischenmodelle</b> <div class="spoiler_text">  In einfachen Systemen oder mit einfachen Erg√§nzungen / √Ñnderungen an gro√üen Systemen schreibt der Entwickler sofort Code oder konfiguriert das System basierend auf seinem mentalen Modell.  In den meisten F√§llen werden jedoch Zwischenmodelle mit unterschiedlicher Komplexit√§t und unterschiedlichem Formalisierungsgrad erstellt - von einer einfachen Liste von Anforderungen bis hin zu umfangreichen formalen Modellen (z. B. UML- oder BPMN-Modelle). </div></div><br><h2>  Materialisierung von Ideen in Bereichen neben Software Engineering </h2><br>  Es ist klar, dass die obige Definition nicht radikal neu ist und in Bereichen der intellektuellen Arbeit neben der Programmierung (bewusst oder unbewusst) weit verbreitet ist.  Betrachten Sie beispielsweise zwei solche Bereiche - Maschinenbau und Mathematik. <br><br>  Diese beiden Bereiche nutzen die Materialisierung von Ideen seit langem und effektiv.  Sie m√ºssen diesbez√ºglich viel √ºber das Programmieren lernen. <br><br>  Im Maschinenbau sehen wir einen vollst√§ndigen Zyklus der Materialisierung von Ideen - von der Entstehung einer Idee im Kopf eines Designers √ºber das Denken, Ausarbeiten, Abbilden in ein Modell bis hin zur Herstellung aus einem bestimmten Material. <br><br>  In der Mathematik ist die Situation anders. <br><br><div class="spoiler">  <b class="spoiler_title">Zur Materialisierung von Ideen in der Mathematik</b> <div class="spoiler_text">  Interessante Fakten und √úberlegungen zur Materialisierung von Ideen in der Mathematik finden sich in Abschnitt 7.3 des Buches [8]. </div></div><br>  Das ‚ÄûEndprodukt‚Äú der Mathematik sind formale Modelle mit streng nachgewiesenen Eigenschaften. <br><br>  Aus dieser Sicht liegt die Programmierung in der Mitte.  Dies kann grafisch wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/webt/8n/ja/84/8nja84baboink2t_bp02narqbja.png"><br><br>  Daher verwendet die Mathematik eine gr√∂√üere Anzahl abstrakterer Modelle und gilt fast nicht f√ºr den Bereich extrem spezifischer Modelle wie Konstruktionszeichnungen. <br><br>  Im Gegensatz dazu verwendet der Maschinenbau relativ wenige abstrakte Modelle, aber viele spezifische.  Zum Beispiel solche, f√ºr die physische Objekte eindeutig hergestellt werden k√∂nnen. <br><br>  Aus dieser Sicht liegt die Programmierung in der Mitte. <br><br><div class="spoiler">  <b class="spoiler_title">Warum ist die Programmierung in der Mitte?</b> <div class="spoiler_text">  Das endg√ºltige Programmierprodukt ist Software-Code.  Und obwohl es, wenn es auf Hardware ausgef√ºhrt wird, auf bestimmte physikalische Objekte (elektrische Signale und Felder verschiedener physikalischer Natur) abgebildet wird, sind diese Objekte schwer mit Muttern, Zahnr√§dern und Karosserien zu vergleichen.  Andererseits kommt der Programmcode mathematischen Formeln nahe, und manchmal ist es ihre direkte Reflexion.  In jedem realen Softwaresystem m√ºssen Sie jedoch viele spezifische Aspekte der Umgebung und der Interaktion mit Benutzern oder anderen Systemen ber√ºcksichtigen.  Dies macht den Programmcode spezifischer als mathematische Formeln. </div></div><br><div class="spoiler">  <b class="spoiler_title">Was Software Engineering von benachbarten Gebieten in Bezug auf die Modellnutzung lernen kann</b> <div class="spoiler_text">  Betrachten Sie zuerst die Mathematik. <br><br><h3>  Multimodell der Welt </h3><br>  Seit mehreren tausend Jahren ihrer Entwicklung hat die Mathematik gelernt, dieselben Ph√§nomene der realen oder imagin√§ren Welt in sehr unterschiedlichen Begriffen zu beschreiben.  Die alten Griechen lernten, rein verbale Aufgabenbeschreibungen durch geometrische Figuren zu ersetzen und mit ihrer Hilfe praktisch wichtige Probleme zu l√∂sen.  Sp√§ter zeigte sich ein Verst√§ndnis f√ºr die Austauschbarkeit von Segmenten in der Ebene und Zahlen.  Dann kristallisierte sich das Konzept einer algebraischen Variablen und die Reduktion geometrischer Probleme auf algebraische Gleichungssysteme heraus. <br><br>  Sch√ºler wissen bereits heute, dass dasselbe Problem auf unterschiedliche Weise gel√∂st werden kann (z. B. geometrisch oder algebraisch) und dass dasselbe mathematische Modell, z. B. eine algebraische Gleichung, viele verschiedene physikalische, chemische usw. beschreibt.  Ph√§nomene. <br><br><h3>  Morphismus von Modellen und Konsistenz von Konzepten und Notationen </h3><br>  Die Mathematik hat gut gelernt, nicht nur dieselben realen oder imagin√§ren Objekte und Prozesse mit Modellen sehr unterschiedlicher mathematischer Natur zu beschreiben.  Eine wichtige Errungenschaft der Mathematik ist die F√§higkeit, den √Ñhnlichkeitsgrad von Modellen aus verschiedenen Bereichen der Mathematik zu bestimmen sowie sie ineinander umzuwandeln.  Viele bahnbrechende L√∂sungen f√ºr die wichtigsten mathematischen Probleme der letzten Jahre sind im Wesentlichen Ketten getrennter Beweise, von denen jede einen speziellen Apparat aus einem speziellen Bereich der Mathematik verwendet.  An den Knotenpunkten dieser hochspezialisierten Evidenz wandelt die Mathematik Modelle eines Abschnitts der Mathematik gekonnt in Modelle eines anderen Abschnitts um.  Bei der Programmierung geschieht jetzt etwas √Ñhnliches, wenn der Quellcode eines Programms kompiliert und Code aus DSL (Domain Specific Language) oder Metadaten generiert wird.  Die Kultur der Arbeit mit Modellen im Bereich der Softwareentwicklung liegt jedoch weit hinter der mathematischen zur√ºck. <br><br><h3>  Modelle im Maschinenbau </h3><br>  Und was kann Software Engineering aus der Materialisierung im Engineering lernen? <br>  In vielen Branchen und sogar in gro√üen Unternehmen gibt es Ketten koordinierter formaler und semi-formaler Modelle.  Diese Ketten enden mit Modellen, auf deren Grundlage physische Objekte hergestellt und montiert werden - Ger√§te und Maschinen.  In der Regel gibt es f√ºr die meisten Arten von Zwischenmodellen formale Methoden zur √úberpr√ºfung ihrer Richtigkeit (technische Standards).  Modelle sind die Hauptkommunikationssprache von Spezialisten mit unterschiedlichen Profilen bei der Entwicklung und Herstellung technischer Produkte. <br><br>  Vor diesem Hintergrund sieht die Situation in der IT viel schlimmer aus.  Nur innerhalb sehr gro√üer IT-Belange wurden in den letzten Jahren Versuche unternommen, vergleichbare Modelle und Prozesse zu erstellen.  Kleine Unternehmen und IT-Startups haben in der Regel nicht nur keine formalen Modelle und Prozesse entwickelt, sondern vermuten deren Existenz nicht einmal.  Diese Situation wird derzeit von folgenden Faktoren bestimmt: <br><br><ul><li>  Die mangelnde Effizienz bestehender Modelle und Prozesse </li><li>  Der Mangel an Ruhm dieser Modelle au√üerhalb gro√üer Bedenken </li><li>  Unzureichende Ausbildung f√ºr Entwickler und insbesondere Manager </li><li>  Der R√ºckstand der Universit√§tsausbildung aus den tats√§chlichen Bed√ºrfnissen des Software-Engineerings. </li></ul></div></div><br><h2>  Definition und Konturen des Paradigmas der Materialisierung von Ideen (RPSE) </h2><br>  Wir haben alle notwendigen Konzepte identifiziert, um eine grundlegende Definition des vorgeschlagenen Paradigmas zu geben.  Hier ist es: <br><blockquote>  Softwareentwicklung ist die Materialisierung von Ideen durch die Umwandlung von mentalen Modellen in Code, der auf Computern ausgef√ºhrt wird. <br><br>  Im Rahmen des vorgeschlagenen Paradigmas: <br><br><ol><li>  Alle wichtigen Softwareentwicklungsprozesse sind spezifische Varianten (Implementierungen) des Prozesses zur Konstruktion von Ketten mentaler und materieller Modelle.  Das letzte spezifischste Modell in dieser Kette ist in der Regel der Programmcode. </li><li>  Die Essenz der Softwareentwicklung besteht darin, solche Ketten zu erstellen. </li><li>  Alle Hauptprobleme der Entwicklungsoptimierung, der Kostensenkung und der Qualit√§tsverbesserung k√∂nnen auf die Optimierung der Konstruktion der entsprechenden Modellkette reduziert werden. </li></ol></blockquote><br><div class="spoiler">  <b class="spoiler_title">Warum Materialisierung und nicht Modellierung?</b> <div class="spoiler_text">  Es ist zu beachten, dass sich die Definition von RPSE zwar auf die Konstruktion von Modellketten bezieht, jedoch vorgeschlagen wird, die Paradigmenmaterialisierung eher als Modellierung zu bezeichnen.  Daher wird versucht, die Besonderheit von Modellketten hervorzuheben, die immer weniger abstrakt / ideal und immer konkreter / materieller werden. </div></div><br>  Die obige Definition hat ihre eigenen Eigenschaften und Variationen in verschiedenen Bereichen der Softwareentwicklung.  Nur in sehr wenigen F√§llen kommt es vor, dass im Kopf eines Programmierers eine klare Vorstellung davon, wie das Problem vor ihm gel√∂st werden kann, vollst√§ndig reift, die er dann in kurzer Zeit in einen Programmiersprachencode √ºbersetzt.  In den meisten realen Projekten besteht der Prozess der L√∂sungsfindung und deren Implementierung nebeneinander, entwickelt sich parallel und interagiert miteinander.  Das hei√üt,  Mentale Modelle, Code und h√§ufig Zwischenmodelle (in Form eines Tests, Bilder, formale Modelle wie UML) wachsen und √§ndern sich parallel und beeinflussen sich gegenseitig. <br><br><div class="spoiler">  <b class="spoiler_title">Definitionsoptionen</b> <div class="spoiler_text">  Sehr oft arbeiten mehrere Personen gleichzeitig an einem Problem.  Jeder von ihnen hat sein eigenes mentales Modell und m√∂glicherweise seine Zwischenmodelle und Codefragmente. <br><br>  Oft fehlt der Code in einer Programmiersprache praktisch, da bei der Erstellung einer neuen L√∂sung Masken von Konfiguratoren oder Generatoren verwaltet werden m√ºssen, beispielsweise bei der Arbeit mit Entwicklungstools in Systemen wie SAP oder WebSphere. <br><br>  Die M√∂glichkeiten, manuell geschriebenen oder automatisch generierten Code in ausf√ºhrbaren Code umzuwandeln, sind heutzutage ebenfalls sehr vielf√§ltig. <br><br>  Und schlie√ülich hat sich auch das Konzept des Prozessors, auf dem der Code ausgef√ºhrt wird, in den letzten Jahren erheblich erweitert.  Waren fr√ºher Prozessoren auf den Brettern, die wiederum in die Schalen von Desktops, Laptops und Server-Racks eingesetzt wurden, wurde dieses Set jetzt um verschiedene Chips unterschiedlicher Gr√∂√üe erweitert, die in Mobiltelefone, Spielekonsolen und √úberwachungskameras eingebaut sind. ‚Äú intelligente "Haushaltsger√§te usw.  Ganz zu schweigen von Quantencomputern. <br><br>  Trotzdem ist RPSE aufgrund seiner Allgemeinheit auf alle oben aufgef√ºhrten Bereiche anwendbar. </div></div><br>  Was kann man heute noch √ºber ein bestimmtes Paradigma sagen? Ist es m√∂glich, seine Konturen irgendwie genauer zu skizzieren? <br><br>  Der n√§chste Schritt zur Verfeinerung des Paradigmas nach dem Versuch, seine Hauptdefinition anzugeben, ist der Versuch, die Hauptkategorien von Ph√§nomenen aufzulisten, die es betrifft.  Unter Hinweis auf Kuhns Definition m√ºssen wir versuchen, die Modelltypen aufzulisten, die RPSE einf√ºhrt und verwendet. <br><br>  RPSE-Modelle k√∂nnen in drei Hauptkategorien unterteilt werden: <br><br><ul><li>  Mentale Modelle </li><li>  Code in Programmiersprachen oder seinen Entsprechungen als Modelle f√ºr ausf√ºhrbaren Code. </li><li>  Zwischenmodelle. </li></ul><br>  Die am wenigsten erforschten in dieser Triade sind mentale Modelle.  Was genau ist mit ihnen gemeint? <br><br>  <b>Mentale Modelle</b> sind ein Begriff f√ºr Ideen, die im Kopf von Kunden, Programmierern und anderen Teilnehmern des Prozesses existieren und auf deren Grundlage der ausf√ºhrbare Code schlie√ülich entsteht.  Das Vorhandensein solcher Modelle ist unbestreitbar und kann auf mentaler Ebene beispielsweise vom Programmierer selbst registriert werden.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem derzeitigen Stand der technologischen Entwicklung k√∂nnen diese Modelle nicht zuverl√§ssig mit Instrumenten gemessen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine der gut funktionierenden M√∂glichkeiten, solche Modelle zu fixieren und zu messen, besteht darin, das Medium der Idee zu verwenden. </font><font style="vertical-align: inherit;">Offensichtlich wirken sich der Interviewprozess oder √§hnliche dramatisch auf das mentale Modell selbst aus. </font><font style="vertical-align: inherit;">Jeder von uns muss mehr als einmal eine Situation erlebt haben, in der der Versuch, ein Problem zu formulieren, um sich mit einem Kollegen zu beraten, zu einem ‚ÄûEinblick‚Äú und h√§ufig zu einer L√∂sung des Problems f√ºhrte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interviews erm√∂glichen es, basierend auf korrekt formulierten Fragen relativ objektiv Modelle unterschiedlicher Komplexit√§t zu erstellen. </font><font style="vertical-align: inherit;">Die h√§ufigsten sind: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturmodelle:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listen mit Bin√§r-, Aufz√§hlungs-, Zahlen-, Zeichenfolgen- und anderen Werten. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grafik- und Netzwerkdatenstrukturen </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verhaltensbeschreibungsmodelle: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sieben formale Modelle zur Bestimmung des Verhaltens </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Formale Modelle zur Bestimmung des Verhaltens (z. B. Finite-State-Maschinen) </font></font></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur Theorie der mentalen Modelle</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Muster spiegeln mentale Muster wider. </font><font style="vertical-align: inherit;">Der Grad der N√§he von mentalen Modellen zu realen Modellen sollte durch Psychologie oder theoretische P√§dagogik behandelt werden. </font><font style="vertical-align: inherit;">Leider sind dem Autor keine ernsthaften Arbeiten in diesem Bereich bekannt. </font><font style="vertical-align: inherit;">(Dies bedeutet nicht, dass solche Arbeiten nicht existieren).</font></font></div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warum braucht Software Engineering ein End-to-End-Paradigma? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Vorhandensein eines ‚Äû√ºbergreifenden‚Äú Paradigmas er√∂ffnet den Teilnehmern die folgenden M√∂glichkeiten, das Paradigma des Prozesses der Erstellung, √Ñnderung und Verwendung von Software zu nutzen: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die F√§higkeit aller Teilnehmer am Prozess, dieselbe Terminologie zu verwenden. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die F√§higkeit, einen End-to-End-Prozess zum Erstellen neuer Software zu erstellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die F√§higkeit, seine Prozessparameter, seine Zwischenergebnisse zu bewerten und zu verwalten. </font></font></li></ul>  . <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Hauptziele der Paradigmenentwicklung </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Theoretische Probleme </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie wiederholt festgestellt wurde, einschlie√ülich im Buch Kuhn [2], sind Wissenschaftler in den meisten F√§llen an der L√∂sung potenzieller Probleme beteiligt, die gel√∂st werden, und es ist weniger wahrscheinlich, dass sie sich mit solchen Problemen befassen, deren Vorgehensweise nicht sehr klar ist. </font><font style="vertical-align: inherit;">Aber genau das sind unsere Aufgaben.</font></font> Hier sind die wichtigsten: <br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstruktive Definition des Konzepts des mentalen Modells. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suche nach konstruktiven Kriterien zur Beurteilung des Grads der Abstraktheit / Idealit√§t vs. </font><font style="vertical-align: inherit;">Spezifit√§t / Materialit√§t von Modellen.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suche nach Kriterien f√ºr die Auswahl von Kandidaten f√ºr die Rolle von Zwischen- und Zusatzmodellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auswahl und Entwicklung von Kriterien und Methoden zum Vergleich von Modellen verschiedener Typen, einschlie√ülich ihrer direkten und umgekehrten Verfolgung. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entwicklung von Methoden zur automatisierten und automatischen Transformation von Modellen. </font></font></li></ol><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Praktische Aufgaben </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Neben theoretischen Aufgaben zur Entwicklung und Implementierung des beschriebenen Paradigmas in der Praxis des Software Engineerings m√ºssen mindestens folgende praktische Probleme gel√∂st werden: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellung von Werkzeugen f√ºr: a) Extraktion und Fixierung von mentalen Modellen. </font><font style="vertical-align: inherit;">b) Automatisierte und automatische Umwandlung von mentalen Modellen in Zwischenmodelle. </font><font style="vertical-align: inherit;">c) Spuren und Sch√§tzungen von √Ñnderungen im Inhalt transformierbarer Modelle</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellung der notwendigen technischen und p√§dagogischen Literatur und anderen medialen Lehrmaterialien. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Organisation von Foren und Konferenzen zu diesem Thema </font></font></li></ol><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Artikel versucht, das Paradigma der Softwareentwicklung als Materialisierung von Ideen zu definieren. Das zu definierende (und nicht offene) Wort wird hier nicht zuf√§llig verwendet. Tats√§chlich besch√§ftigen sich Teilnehmer an IT-Projekten seit langem mit der Erstellung, Transformation und Verwendung von Modellen, m√∂glicherweise ohne dies zu bemerken. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im engeren Sinne von Kuhns Definition kann der beschriebene Ansatz noch nicht das Recht beanspruchen, als Paradigma bezeichnet zu werden, sondern nur als Kandidat f√ºr ein Paradigma, da es keine umfangreiche Gemeinschaft von Menschen gibt, die es unterst√ºtzen, und kein gut entwickeltes System miteinander verbundener Modelle. Ich m√∂chte jedoch glauben, dass die M√§ngel bald behoben sein werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist der erste Artikel in einer geplanten Artikelserie. In den folgenden Artikeln werde ich √ºber mentale und Zwischenmodelle sprechen.</font></font><br><br><h3>  Literatur </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. IEEE-Standardglossar der Software-Engineering-Terminologie, IEEE std 610.12-1990, 1990. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Kuhn, Thomas S. Die Struktur wissenschaftlicher Revolutionen. 3rd ed. Chicago, IL: University of Chicago Press, 1996. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Programmierparadigma: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Programming_paradigm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Bundesland - 27.08.2008) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Peter A. Henning, Holger Vogelsang Taschenbuch Programmiersprachen. Carl Hanser Verlag GmbH &amp; Co. KG; Auflage: 2., neu bearbeitete (5. September 2007). ISBN-13: 978-3446407442. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Paradigmen und Modelle der Softwareentwicklung Aufsatz </font></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Informationstechnologie </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">www.uniassignment.com/essay-samples/information-technology/software-engineering-paradigms-and-models-information-technology-essay.php</font></a><font style="vertical-align: inherit;"> (Stand - </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">28.08.2018</font></a><font style="vertical-align: inherit;"> )</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Reification (Informatik) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Reification_</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (computer_science) (Bundesstaat - 27.08.2008) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Fedor Ivanovich Tyutchev. </font><font style="vertical-align: inherit;">Silentium! </font><font style="vertical-align: inherit;">(Silence (lat.), 1829. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Borovik, Alexandre. Mathematik unter dem Mikroskop: Anmerkungen zu kognitiven Aspekten der mathematischen Praxis. American Mathematical Society. ISBN-13: 978-0821847619. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Illustration: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geralt</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425321/">https://habr.com/ru/post/de425321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425305/index.html">Wie die Chemical Brothers Arrangements zeigen: Technische Details und Umstellung</a></li>
<li><a href="../de425311/index.html">Das Buch "Programmieren f√ºr Kinder. Von den Grundlagen bis zur Erstellung von Robotern</a></li>
<li><a href="../de425313/index.html">Die 10 besten VS Code-Erweiterungen von 2018 f√ºr Front-End-Entwickler</a></li>
<li><a href="../de425315/index.html">Anordnen der Codespeicherung in GitLab und Integrieren der Code√ºberpr√ºfung in GitFlow</a></li>
<li><a href="../de425317/index.html">Wie es gemacht wird: Wir schreiben "Minesweeper" in 4 Minuten</a></li>
<li><a href="../de425323/index.html">"Kaninchenbau." UX Designer im Produktteam</a></li>
<li><a href="../de425325/index.html">DIY Bytecode Interpreter</a></li>
<li><a href="../de425327/index.html">Funktionsprogrammierung: Siebenmal messen, einmal schneiden</a></li>
<li><a href="../de425329/index.html">Einige Ratschl√§ge an die Millennials von den "Oldies". Wie man in unserer digitalen Welt erfolgreich ist</a></li>
<li><a href="../de425331/index.html">Alice hilft Entwicklern, Objekte in Benutzeranforderungen zu finden. NER in Dialogen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>