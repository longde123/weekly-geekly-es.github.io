<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèø üë∞üèΩ üå°Ô∏è La explicaci√≥n m√°s simple de c√≥mo funcionan hoy los algoritmos de cifrado sim√©trico üë¥üèª üë©‚Äçüé® üë®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(Encontr√© un hilo en Twitter con una muy buena explicaci√≥n de las cifras sim√©tricas. Fue escrito por Colm MacC√°rthaigh, uno de los principales contrib...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La explicaci√≥n m√°s simple de c√≥mo funcionan hoy los algoritmos de cifrado sim√©trico</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443050/"><p>  <em>(Encontr√© un hilo en Twitter con una muy buena explicaci√≥n de las cifras sim√©tricas. Fue escrito por Colm MacC√°rthaigh, uno de los principales contribuyentes de Apache. Le ped√≠ permiso a Colm para traducir, √©l estuvo de acuerdo amablemente).</em> </p><br><p>  Te explicar√© en un lenguaje sencillo lo que sucede cuando los datos est√°n encriptados.  Espero que sin el misticismo y las cosas complejas que inventaron los cript√≥grafos. </p><br><p>  Entonces, el cifrado sim√©trico es exactamente lo que usamos en la mayor√≠a de los casos cuando queremos cifrar un mont√≥n de datos.  Su navegador env√≠a y recibe datos mediante cifrado sim√©trico.  Si cifra archivos o un disco, el cifrado sim√©trico tambi√©n funciona en este caso.  iMessage, Signal, WhatsApp: todos utilizan cifrado sim√©trico para la seguridad de su correspondencia. </p><br><p> Si cree que al cifrar los datos se mezclan para que nadie pueda leerlos sin una clave, la forma en que realmente sucede. </p><br><p>  Aqu√≠ hay un ejemplo simple.  Supongamos que tengo una cadena Ovaltine y quiero encriptarla.  Podr√≠a usar rot13: el cifrado muy simple de la vieja escuela de C√©sar, que hace un baile redondo de letras donde a y z se toman de la mano, y reemplaza cada letra con otra letra del alfabeto, que son 13 caracteres de la letra reemplazada.  Por lo tanto, "O" se convierte en "B", y "v" se convierte en "i", como resultado, "Ovaltine" se convierte en "Binygvar".  Por supuesto, esto no es muy seguro.  Este es un ejemplo ingenuo, que es muy f√°cil de descifrar, ya que el atacante puede averiguar qu√© letra se encuentra con mayor frecuencia (generalmente en el texto original es "e") y encontrar las letras restantes de esta manera. </p><a name="habracut"></a><br><p>  Ahora puede imaginar que deber√≠a haber formas m√°s dif√≠ciles de "mezclar" las letras.  Por ejemplo, alg√∫n esquema complejo en el que "a" va a "p", pero cuando se vuelve a cifrar, a "f".  Quiz√°s incluso a veces este esquema comienza a encriptar "a" con dos letras, por ejemplo, "jd" u otra cosa.  Por lo tanto, este complicado esquema puede encriptar "Ovaltine" en la cadena "FGyswDmweeRq" (tenga en cuenta que se ha vuelto m√°s largo).  Los algoritmos de cifrado aparecieron en el pasado que funcionaban de manera similar, pero no es as√≠ como funciona el cifrado moderno. </p><br><p>  En lugar de "barajar" letras, el cifrado moderno toma su cadena secreta y la combina ingeniosamente con datos aleatorios.  Esto es similar a rot13 solo en dos aspectos: el cifrado y el descifrado son esencialmente la misma operaci√≥n, y todo sucede "en su lugar".  De hecho, ¬øhas notado que rot13 es un algoritmo de cifrado y descifrado?  rot13 (Ovaltine) -&gt; Binygvar, rot13 (Binygvar) -&gt; Ovaltine.  Creo que esta es una simetr√≠a muy hermosa en el cifrado sim√©trico.  Pero volvamos a nuestro tema.  El truco es que usamos la operaci√≥n XOR bit a bit.  En criptograf√≠a, l√≥gica formal y c√≥digo, los programas XOR se pueden definir de manera diferente, pero utilizar√© una notaci√≥n con la que probablemente est√© familiarizado.  Se ve as√≠: ^. </p><br><p>  XOR significa "OR exclusivo".  Este es un operador (o funci√≥n, si lo prefiere), que toma dos argumentos y devuelve el resultado.  A ^ B = C. Este operador se llama "bit a bit" porque se aplica a los bits que se corresponden entre s√≠.  Si A y B son bytes, entonces podemos suponer que A ^ B = C son esencialmente 8 operaciones diferentes que ocurren simult√°neamente.  ^ compara el primer bit A y el primer bit B, y luego coloca el resultado en el primer bit C. Repite las mismas 7 veces m√°s para los bits restantes.  Las reglas son simples: si el bit de A es "1" O el bit de B es "1", entonces configuramos el bit C correspondiente a "1", pero solo si "A" y "B" no son "1" al mismo tiempo.  Esta es la parte exclusiva.  Aqu√≠ hay una tabla de verdad de la vieja escuela: </p><br><pre><code class="plaintext hljs">A|B|C 0|0|0 1|0|1 0|1|1 1|1|0</code> </pre> <br><p>  Lo mejor de XOR es que parece podrido13.  Podemos usarlo para el cifrado y descifrado.  Mostrar√© esto con un simple ejemplo.  Imaginemos que queremos cifrar el n√∫mero habitual "3" y que nuestra clave de cifrado es otro n√∫mero "7".  Por lo tanto, 3 ^ 7 = 4. Es decir, el resultado del cifrado es "4".  Ahora descifremos el n√∫mero.  Simplemente har√© lo mismo otra vez: 4 ^ 7 = 3. Tome cualquier n√∫mero que desee o cualquier dato, y siempre funcionar√°: XOR siempre podr√° descifrarse. </p><br><p>  Poco a poco: as√≠ es como realmente ciframos y desciframos los datos, no hay mezcla, solo XOR.  La parte dif√≠cil es encontrar datos a los que podamos aplicar XOR.  Un enfoque es tomar una gran cantidad de datos secretos a la mano y usarlos como el segundo argumento para XOR.  En este caso, todos los participantes en el proceso de transmisi√≥n de datos cifrados deben usar el mismo conjunto de datos secretos para el cifrado y descifrado.  Y funcionar√°.  Es cierto que hay varios problemas. </p><br><p>  El primer problema  Los datos secretos deber√≠an parecer aleatorios.  No puedes tomar texto de un libro ni nada de eso.  Cualquier patr√≥n aparecer√° en los datos cifrados.  Esto es precisamente lo que hizo que las fuerzas aliadas fueran superiores en la Segunda Guerra Mundial. </p><br><p>  El segundo problema  No puede reutilizar datos confidenciales, ya que reaparecer√°n los patrones.  Por lo tanto, de alguna manera tiene que proporcionar grandes cantidades de datos secretos para todos los que lo necesitan, como el pad de una sola vez.  Esto es muy dificil. </p><br><p>  En el cifrado moderno, "generamos" los datos secretos que necesitamos a partir de claves peque√±as.  Estas llaves son mucho m√°s f√°ciles de transportar y proteger.  Esto es lo que realmente son los algoritmos de cifrado sim√©trico: esquemas para la generaci√≥n determinista de datos aleatorios a partir de una clave.  La parte sobre el "determinismo" es muy importante: dos personas con la misma clave deben generar absolutamente el mismo conjunto de datos, de lo contrario no podr√°n entenderse.  Probablemente haya escuchado acerca de tales algoritmos: AES, 3DES, DES, RC4, ChaCha20.  Todos lo hacen </p><br><p>  Resulta que el problema matem√°tico de generar un flujo de datos aleatorio (en el que no hay patrones en ninguna forma predecible) usando la clave es muy dif√≠cil.  De esta lista, solo AES y ChaCha20 se consideran seguros hoy en d√≠a.  Se piratearon otros algoritmos: las personas pudieron predecirlos.  Adem√°s, AES tiene una reputaci√≥n ligeramente empa√±ada, porque los cript√≥grafos dicen lo siguiente: </p><br><blockquote>  AES es el algoritmo de cifrado principal y m√°s analizado.  Absolutamente Gold Standard!  : dark_sunglasses: </blockquote><p>  Pero al mismo tiempo agregan: </p><br><blockquote>  Las implementaciones de AES en software (no en hardware) son inseguras o lentas, y algunas veces no son seguras y lentas.  No fue dise√±ado teniendo en cuenta el hecho de que puede ser pirateado mediante el an√°lisis de cach√©.  : facepalm: </blockquote><p>  No tengas miedo si esto no te resulta claro.  La idea principal es esta: AES es magn√≠fico desde el punto de vista de las matem√°ticas, pero es muy complicado en la implementaci√≥n de software.  Pero no se preocupe: casi siempre tenemos soporte AES a nivel de hardware (puede encontrar una lista de todos los procesadores con soporte de hardware AES aqu√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://en.wikipedia.org/wiki/AES_instruction_set</a> , - nota del traductor). </p><br><p>  Sea como fuere, continuamos ... ¬øC√≥mo funcionan realmente estos algoritmos?  ¬øC√≥mo podemos tomar una clave y generar de forma segura un flujo de datos aleatorio?  Aqu√≠ simplificar√© un poco las cosas y comenzar√© con bloques. </p><br><p>  Estos algoritmos reciben tres par√°metros en la entrada y dan el texto cifrado en la salida.  Par√°metros de entrada - una clave, texto cifrado y ... sorpresa - algo extra√±o llamado "vector de inicializaci√≥n" (vector de inicializaci√≥n, IV). </p><br><pre> <code class="plaintext hljs">AES(key, IV, plaintext) -&gt; encrypted_data.</code> </pre> <br><p>  La clave y el IV se combinan entre s√≠ para crear un conjunto de "condiciones de inicio" para el algoritmo;  Esto es similar al intercambio inicial o al barajado de fichas en un juego de Scrabble.  La misma combinaci√≥n de tecla y IV siempre crear√° el mismo conjunto de condiciones de inicio.  Usted pregunta, ¬øpor qu√© necesitamos IV entonces?  Necesitamos un IV para poder encriptar m√∫ltiples mensajes usando la misma clave.  Sin IV, cada flujo de datos generado ser√≠a el mismo, y esto es malo.  Esto violar√≠a una de las reglas de las que hablamos anteriormente: no podemos reutilizar los mismos datos para el cifrado.  Entonces necesitamos una v√≠a intravenosa para mezclar el resultado.  Pero a diferencia de la clave IV, puede ser p√∫blica. </p><br><p>  Entonces, cuando encriptas un mensaje y se lo env√≠as a alguien, tambi√©n puedes agregar: "Hola, aqu√≠ est√° el IV que us√©".  Todav√≠a es cr√≠tico que no reutilicemos la combinaci√≥n de clave y IV, porque nos dar√≠an datos aleatorios repetidos.  Hay dos formas de lograr esta condici√≥n: 1) IV es un tipo de contador que aumentamos con cada nuevo mensaje.  2) IV se genera aleatoriamente, mientras que tiene un valor bastante grande, por lo que no debemos preocuparnos mucho por las colisiones.  Sea como fuere, mencion√© que hablar√© sobre bloques. </p><br><p>  Las teclas y IV est√°n "mezcladas" o combinadas de tal manera que crean un conjunto de condiciones de inicio ... estas condiciones son en realidad el "bloque" inicial de datos aleatorios.  La longitud de este bloque es de 128 bits para AES128, 256 bits para AES256 y 512 bits para ChaCha20.  Y aqu√≠ se manifiesta la verdadera magia e individualidad de un algoritmo de cifrado particular.  De hecho, su esencia radica en c√≥mo se genera la secuencia de bloques y c√≥mo cada bloque est√° asociado con sus vecinos.  La relaci√≥n entre estos bloques sigue siendo predecible incluso para aquellos que no tienen una clave. </p><br><p>  No profundizar√© en c√≥mo funcionan estos algoritmos, pero si desea saber m√°s, le aconsejo que comience a explorar este tema con los generadores congruenciales lineales (LCG).  LCG es una funci√≥n que crea bloques de datos "circulares" de forma aleatoria y no repetitiva.  Luego eche un vistazo a las redes Feistel, el siguiente nivel de desarrollo de LCG.  Luego trate con S-Boxes, y luego mire c√≥mo Salsa20 crea entrelazado en el algoritmo ChaCha20.  ¬°Todo esto es mucho m√°s asequible de lo que piensas! </p><br><p>  Entonces, ahora sabemos c√≥mo se puede combinar un flujo de datos aleatorio con texto para cifrarlo y descifrarlo, y ya estamos un poco en el tema de c√≥mo se crean estos flujos de datos aleatorios.  ¬øNo es eso todo lo que necesitamos?  Para el cifrado de disco, eso es realmente casi todo.  Podemos encriptar cada bloque o sector del almacenamiento usando una clave y IV, que se puede obtener desde la "posici√≥n" en el disco.  Por lo tanto, siempre podemos descifrar cualquier bloque de datos en cualquier parte del disco, siempre que tengamos la clave.  Pero hay un problema ... alguien puede arruinar nuestros datos cifrados.  Si cambio el valor de cualquier byte, incluso si no tengo una clave, al final no podremos descifrar el bloque.  Y no hay protecci√≥n contra este tipo de interferencia.  En el caso de enviar mensajes y datos a trav√©s de la red, esto se vuelve a√∫n m√°s cr√≠tico.  No queremos que nadie estropee nuestros datos transmitidos.  ¬°Entonces necesitamos agregar una verificaci√≥n de integridad!  Hay varios esquemas para hacer esto. </p><br><p>  HMAC, GCM y Poly1305 son los esquemas de comprobaci√≥n de integridad modernos m√°s comunes.  B√°sicamente, estos algoritmos funcionan as√≠: se suministran con datos y otra clave (la llamada clave de integridad).  Despu√©s de los c√°lculos, entregan el MAC (c√≥digo de autenticaci√≥n del mensaje) o la etiqueta, que a su vez es solo otra pieza de datos que act√∫a como una firma. </p><br><p>  Por lo tanto, para el cifrado y la protecci√≥n, nuestro esquema puede verse as√≠: </p><br><pre> <code class="plaintext hljs">AES(key, IV, "Ovaltine") -&gt; encrypted_output HMAC(key, encrypted_output) -&gt; MAC</code> </pre> <br><p>  y luego por cable enviamos: </p><br><pre> <code class="plaintext hljs">IV | encrypted_output | MAC</code> </pre> <br><p>  Para el descifrado, verificamos el MAC, lo generamos nuevamente y comparamos el resultado con el MAC recibido, y luego desciframos los datos.  Existen diferencias internas en c√≥mo HMAC, GCM y Poly1305 generan estas firmas, pero no tiene que preocuparse por eso.  Hasta la fecha, esta combinaci√≥n de operaciones generalmente est√° envuelta en una funci√≥n llamada "AEAD" (Cifrado autenticado con datos adicionales).  Debajo del cap√≥, ella hace todo lo que habl√© antes: </p><br><pre> <code class="plaintext hljs">AEAD(key, IV, plaintext, additional_data) -&gt; IV_encrypted_data_MAC</code> </pre> <br><p>  Una pieza llamada "datos_adicionales" son solo datos con los que puede asegurarse de que la parte remitente tenga estos datos, aunque no se los envi√≥.  Es como los metadatos que establecen los derechos de acceso.  A menudo, este campo se deja en blanco. </p><br><p>  Sin embargo, puede tener problemas con AEAD si usa el mismo IV.  Esto es malo!  Hay intentos de mejorar esta situaci√≥n: mi colega, cuyo nombre es Shay, est√° trabajando en un genial esquema SIV que agrega una capa de protecci√≥n contra este problema.  Pero si usa un IV √∫nico, el cifrado moderno es muy seguro.  Es decir, puede publicar el texto cifrado en el New York Times, y nadie puede descifrarlo.  El cifrado permanecer√° inaccesible incluso si se conoce "alguna" parte del texto.  Por ejemplo, en los protocolos de Internet se conoce una gran cantidad de texto.  Los servidores HTTP siempre responden igual y siempre se conocen los primeros bytes.  Pero este hecho no importa en absoluto: no ayudar√° al atacante a encontrar una sola pieza de los datos restantes ... Hemos recorrido un largo camino desde la Segunda Guerra Mundial. </p><br><p>  ¬°Pero hay ataques que funcionan!  Si env√≠a datos a trav√©s de una red y alguien rastrea el tiempo y el tama√±o de los mensajes, los datos cifrados pueden descifrarse mediante el an√°lisis de tr√°fico. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0f3/159/f21/0f3159f21f88bfaa15fb4e2b7399792c.gif" alt="imagen"></p><br><p>  Vamos a averiguar la longitud primero.  Obviamente, la longitud no es una caracter√≠stica oculta.  Y esto es normal si est√° tratando de proteger su contrase√±a o n√∫mero de tarjeta de cr√©dito en alg√∫n lugar en el medio del mensaje.  No es un gran problema  Pero esto significa que potencialmente cualquier persona puede determinar el tipo de contenido que env√≠a.  Un ejemplo simple: si env√≠a un gif usando un messenger y si el tama√±o de esta imagen es √∫nico, el atacante que intercepta sus datos puede sugerir qu√© GIF se acaba de enviar.  Hay versiones m√°s complicadas de este ataque para Google Maps, Netflix, Wikipedia, etc.  Para protegerse contra este ataque, puede "terminar" los mensajes enviados con bytes adicionales, de modo que todos los mensajes enviados tengan la misma longitud, pase lo que pase.  El cifrado utilizado en las redes militares siempre "termina" el tr√°fico con datos adicionales, es decir, ¬°para el interceptor siempre se ve igual!  Otro problema asociado con la longitud es que si usa la compresi√≥n y le da al atacante la capacidad de cambiar cualquier parte del contenido de la p√°gina que ve el usuario, esto le permite al atacante descubrir incluso los secretos m√°s peque√±os.  Busca un ataque llamado CRIMEN.  Ella es hermosa y aterradora. </p><br><p>  Tambi√©n dije que el otro problema es el tiempo.  Obviamente, el tiempo de env√≠o de cada mensaje es informaci√≥n abierta.  ¬øPodr√≠a ser esto un problema?  Tal vez!  Por ejemplo, si env√≠a un mensaje cada vez que presiona una tecla, es trivial averiguar qu√© se imprime exactamente mediante el an√°lisis de tiempo.  Genial!  Otro ejemplo es VOIP.  Si su aplicaci√≥n de llamada env√≠a datos solo cuando las personas hablan, pero no durante el silencio, esto es suficiente para restaurar el 70% del habla en ingl√©s.  Solo por el silencio.  Miedo genial. </p><br><p>  Estos ejemplos son solo la punta del iceberg.  Incluso cuando usa algoritmos y esquemas de encriptaci√≥n que han estado mejorando durante 80 a√±os, todav√≠a hay brechas que pueden usarse para romper la seguridad.  ¬°Por eso es valioso saberlo! </p><br><p>  Sea como fuere, este es el nivel de explicaci√≥n en el que quiero detenerme ahora, pero hemos considerado las cosas m√°s necesarias para saber.  Si lees hasta este punto, ¬°gracias!  Ahora debe tener una mejor comprensi√≥n de lo que sucede durante el cifrado y de lo que debe tener cuidado. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Si√©ntase libre de hacer preguntas.</a> </p><br><p>  <em>La traducci√≥n se publica bajo la licencia CC BY-NC-SA 4.0</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443050/">https://habr.com/ru/post/443050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443034/index.html">Nuevas estaciones de carga Tesla: cargue la bater√≠a durante 120 kil√≥metros en 5 minutos</a></li>
<li><a href="../443038/index.html">Si el pegamento entra en el ojo</a></li>
<li><a href="../443040/index.html">7 razones principales por las que las aplicaciones est√°n bloqueadas en Google Play y AppStore</a></li>
<li><a href="../443042/index.html">Lanzamiento de 619 mil tetris en GLSL, su renderizado y un simple bot</a></li>
<li><a href="../443046/index.html">C√≥mo los investigadores de seguridad acceden a sitios protegidos de c√≥digo iOS</a></li>
<li><a href="../443052/index.html">Hermoso reloj preciso de un viejo tel√©fono inteligente</a></li>
<li><a href="../443054/index.html">Una selecci√≥n de utilidades para un programador en Linux</a></li>
<li><a href="../443056/index.html">Segundo paciente con VIH alcanza la remisi√≥n</a></li>
<li><a href="../443058/index.html">Arquitectura limpia Parte I - Introducci√≥n</a></li>
<li><a href="../443060/index.html">¬øLa nave espacial llegar√° a Marte?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>