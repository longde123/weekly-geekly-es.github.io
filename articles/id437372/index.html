<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÜ ü•¢ üïµÔ∏è Tiga trik sederhana untuk mengurangi gambar buruh pelabuhan ‚ùáÔ∏è üë¶ üíÉüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika membuat wadah Docker, yang terbaik adalah selalu berusaha untuk meminimalkan ukuran gambar. Gambar yang menggunakan lapisan yang sama dan lebih...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tiga trik sederhana untuk mengurangi gambar buruh pelabuhan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nixys/blog/437372/"><img src="https://habrastorage.org/getpro/habr/post_images/339/ed2/afb/339ed2afb54b94a155f95e6a279ede9d.png" alt="gambar"><br><p>  Ketika membuat wadah Docker, yang terbaik adalah selalu berusaha untuk meminimalkan ukuran gambar.  Gambar yang menggunakan lapisan yang sama dan lebih ringan - lebih cepat ditransfer dan digunakan. </p><br><p> Tetapi bagaimana cara mengontrol ukuran ketika setiap eksekusi dari pernyataan <code>RUN</code> membuat layer baru?  Selain itu, Anda masih memerlukan artefak perantara sebelum membuat gambar itu sendiri ... </p><a name="habracut"></a><br><p>  Anda mungkin tahu bahwa sebagian besar file Docker memiliki fitur yang agak aneh, misalnya: </p><br><pre> <code class="plaintext hljs">FROM ubuntu RUN apt-get update &amp;&amp; apt-get install vim</code> </pre> <br><p>  Nah, mengapa <code>&amp;&amp;</code> sini?  Bukankah lebih mudah menjalankan dua pernyataan <code>RUN</code> , seperti di sini? </p><br><pre> <code class="plaintext hljs">FROM ubuntu RUN apt-get update RUN apt-get install vim</code> </pre> <br><p>  Dimulai dengan Docker versi 1.10, operator <code>COPY</code> , <code>ADD</code> dan <code>RUN</code> menambahkan layer baru pada gambar.  Dalam contoh sebelumnya, dua lapisan dibuat bukan satu. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cfb/fd8/e34/cfbfd8e34d1dd89685121383128c05aa.gif" alt="gambar"></p><br><h3 id="sloi-kak-git-kommity">  Layers sebagai git melakukan. </h3><br><p>  Lapisan Docker mempertahankan perbedaan antara versi gambar sebelumnya dan saat ini.  Dan seperti halnya git commit, mereka berguna jika Anda membaginya dengan repositori atau gambar lain.  Bahkan, ketika meminta gambar dari registri, hanya lapisan yang hilang dimuat, yang menyederhanakan pemisahan gambar di antara kontainer. </p><br><p>  Tetapi pada saat yang sama, setiap lapisan terjadi, dan semakin banyak dari mereka, semakin berat gambar akhir.  Repositori Git serupa dalam hal ini: ukuran repositori bertambah dengan jumlah layer, karena ia harus menyimpan semua perubahan di antara commit.  Ini digunakan sebagai praktik yang baik untuk menggabungkan beberapa pernyataan <code>RUN</code> pada baris yang sama, seperti pada contoh pertama.  Tapi sekarang, sayangnya, tidak. </p><br><h2 id="1-obedinyaem-neskolkih-sloev-v-odin-s-pomoschyu-poetapnoy-sborki-docker-obrazov">  1. Gabungkan beberapa layer menjadi satu menggunakan rakitan Docker-gambar </h2><br><p>  Ketika repositori Git bertambah, Anda bisa meringkas seluruh histori perubahan menjadi satu komit dan melupakannya.  Ternyata sesuatu yang serupa dapat diimplementasikan di Docker - melalui perakitan bertahap. </p><br><p>  Mari kita membuat wadah Node.js. </p><br><p>  Mari kita mulai dengan <code>index.js</code> : </p><br><pre> <code class="plaintext hljs">const express = require('express') const app = express() app.get('/', (req, res) =&gt; res.send('Hello World!')) app.listen(3000, () =&gt; { console.log(`Example app listening on port 3000!`) })</code> </pre> <br><p>  dan <code>package.json</code> : </p><br><pre> <code class="plaintext hljs">{ "name": "hello-world", "version": "1.0.0", "main": "index.js", "dependencies": { "express": "^4.16.2" }, "scripts": { "start": "node index.js" } }</code> </pre> <br><p>  Kemas aplikasi dengan <code>Dockerfile</code> berikut: </p><br><pre> <code class="plaintext hljs">FROM node:8 EXPOSE 3000 WORKDIR /app COPY package.json index.js ./ RUN npm install CMD ["npm", "start"]</code> </pre> <br><p>  Buat gambar: </p><br><pre> <code class="plaintext hljs">$ docker build -t node-vanilla .</code> </pre> <br><p>  Periksa apakah semuanya berfungsi: </p><br><pre> <code class="plaintext hljs">$ docker run -p 3000:3000 -ti --rm --init node-vanilla</code> </pre> <br><p>  <em>Sekarang Anda dapat mengikuti tautan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http: // localhost: 3000</a> dan lihat "Hello World!"</em> </p><br><p>  Di <code>Dockerfile</code> sekarang memiliki operator <code>COPY</code> dan <code>RUN</code> , jadi kami memperbaiki kenaikan setidaknya dua lapisan, dibandingkan dengan gambar asli: </p><br><pre> <code class="plaintext hljs">$ docker history node-vanilla IMAGE CREATED BY SIZE 075d229d3f48 /bin/sh -c #(nop) CMD ["npm" "start"] 0B bc8c3cc813ae /bin/sh -c npm install 2.91MB bac31afb6f42 /bin/sh -c #(nop) COPY multi:3071ddd474429e1‚Ä¶ 364B 500a9fbef90e /bin/sh -c #(nop) WORKDIR /app 0B 78b28027dfbf /bin/sh -c #(nop) EXPOSE 3000 0B b87c2ad8344d /bin/sh -c #(nop) CMD ["node"] 0B &lt;missing&gt; /bin/sh -c set -ex &amp;&amp; for key in 6A010‚Ä¶ 4.17MB &lt;missing&gt; /bin/sh -c #(nop) ENV YARN_VERSION=1.3.2 0B &lt;missing&gt; /bin/sh -c ARCH= &amp;&amp; dpkgArch="$(dpkg --print‚Ä¶ 56.9MB &lt;missing&gt; /bin/sh -c #(nop) ENV NODE_VERSION=8.9.4 0B &lt;missing&gt; /bin/sh -c set -ex &amp;&amp; for key in 94AE3‚Ä¶ 129kB &lt;missing&gt; /bin/sh -c groupadd --gid 1000 node &amp;&amp; use‚Ä¶ 335kB &lt;missing&gt; /bin/sh -c set -ex; apt-get update; apt-ge‚Ä¶ 324MB &lt;missing&gt; /bin/sh -c apt-get update &amp;&amp; apt-get install‚Ä¶ 123MB &lt;missing&gt; /bin/sh -c set -ex; if ! command -v gpg &gt; /‚Ä¶ 0B &lt;missing&gt; /bin/sh -c apt-get update &amp;&amp; apt-get install‚Ä¶ 44.6MB &lt;missing&gt; /bin/sh -c #(nop) CMD ["bash"] 0B &lt;missing&gt; /bin/sh -c #(nop) ADD file:1dd78a123212328bd‚Ä¶ 123MB</code> </pre> <br><p>  Seperti yang Anda lihat, gambar akhir telah meningkat lima lapisan baru: satu untuk setiap operator di <code>Dockerfile</code> kami.  Sekarang mari kita coba membangun Docker bertahap.  Kami menggunakan <code>Dockerfile</code> sama, terdiri dari dua bagian: </p><br><pre> <code class="plaintext hljs">FROM node:8 as build WORKDIR /app COPY package.json index.js ./ RUN npm install FROM node:8 COPY --from=build /app / EXPOSE 3000 CMD ["index.js"]</code> </pre> <br><p>  Bagian pertama <code>Dockerfile</code> membuat tiga lapisan.  Kemudian layer digabungkan dan disalin ke tahap kedua dan terakhir.  Dua lapisan lagi ditambahkan ke gambar di atas.  Hasilnya, kami memiliki tiga lapisan. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/72c/6a6/61e/72c6a661ef969eabd58a91b4b71b0329.gif" alt="gambar"></p><br><p>  Ayo kita coba.  Pertama, buat wadah: </p><br><pre> <code class="plaintext hljs">$ docker build -t node-multi-stage .</code> </pre> <br><p>  Memeriksa sejarah: </p><br><pre> <code class="plaintext hljs">$ docker history node-multi-stage IMAGE CREATED BY SIZE 331b81a245b1 /bin/sh -c #(nop) CMD ["index.js"] 0B bdfc932314af /bin/sh -c #(nop) EXPOSE 3000 0B f8992f6c62a6 /bin/sh -c #(nop) COPY dir:e2b57dff89be62f77‚Ä¶ 1.62MB b87c2ad8344d /bin/sh -c #(nop) CMD ["node"] 0B &lt;missing&gt; /bin/sh -c set -ex &amp;&amp; for key in 6A010‚Ä¶ 4.17MB &lt;missing&gt; /bin/sh -c #(nop) ENV YARN_VERSION=1.3.2 0B &lt;missing&gt; /bin/sh -c ARCH= &amp;&amp; dpkgArch="$(dpkg --print‚Ä¶ 56.9MB &lt;missing&gt; /bin/sh -c #(nop) ENV NODE_VERSION=8.9.4 0B &lt;missing&gt; /bin/sh -c set -ex &amp;&amp; for key in 94AE3‚Ä¶ 129kB &lt;missing&gt; /bin/sh -c groupadd --gid 1000 node &amp;&amp; use‚Ä¶ 335kB &lt;missing&gt; /bin/sh -c set -ex; apt-get update; apt-ge‚Ä¶ 324MB &lt;missing&gt; /bin/sh -c apt-get update &amp;&amp; apt-get install‚Ä¶ 123MB &lt;missing&gt; /bin/sh -c set -ex; if ! command -v gpg &gt; /‚Ä¶ 0B &lt;missing&gt; /bin/sh -c apt-get update &amp;&amp; apt-get install‚Ä¶ 44.6MB &lt;missing&gt; /bin/sh -c #(nop) CMD ["bash"] 0B &lt;missing&gt; /bin/sh -c #(nop) ADD file:1dd78a123212328bd‚Ä¶ 123MB</code> </pre> <br><p>  Lihat apakah ukuran file telah berubah: </p><br><pre> <code class="plaintext hljs">$ docker images | grep node- node-multi-stage 331b81a245b1 678MB node-vanilla 075d229d3f48 679MB</code> </pre> <br><p>  Ya, sudah menjadi lebih kecil, tetapi belum signifikan. </p><br><h2 id="2-snosim-vse-lishnee-iz-konteynera-s-pomoschyu-distroless">  2. Kami menghapus semua yang tidak perlu dari wadah menggunakan distroless </h2><br><p>  Gambar saat ini memberi kami Node.js, <code>yarn</code> , <code>npm</code> , <code>bash</code> , dan banyak binari berguna lainnya.  Juga, ini didasarkan pada Ubuntu.  Dengan demikian, dengan menyebarkannya, kami mendapatkan sistem operasi lengkap dengan banyak biner dan utilitas yang bermanfaat. </p><br><p>  Namun, kami tidak membutuhkan mereka untuk menjalankan wadah.  Satu-satunya ketergantungan yang diperlukan adalah Node.js. </p><br><p>  Kontainer Docker harus mendukung operasi satu proses dan berisi set alat minimum yang diperlukan untuk menjalankannya.  Seluruh sistem operasi tidak diperlukan untuk ini. </p><br><p>  Jadi kita bisa mendapatkan semuanya kecuali Node.js. </p><br><p>  <strong>Tapi bagaimana caranya?</strong> </p><br><p>  Google telah menghasilkan solusi serupa - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GoogleCloudPlatform / distroless</a> . </p><br><p>  Deskripsi untuk repositori berbunyi: </p><br><p>  <em>Gambar distroless hanya berisi aplikasi dan dependensinya.</em>  <em>Tidak ada manajer paket, shell, atau program lain yang biasanya ditemukan dalam distribusi Linux standar.</em> </p><br><p>  <strong>Ini yang kamu butuhkan!</strong> </p><br><p>  Jalankan <code>Dockerfile</code> untuk mendapatkan gambar baru: </p><br><pre> <code class="plaintext hljs">FROM node:8 as build WORKDIR /app COPY package.json index.js ./ RUN npm install FROM gcr.io/distroless/nodejs COPY --from=build /app / EXPOSE 3000 CMD ["index.js"]</code> </pre> <br><p>  Kami mengumpulkan gambar seperti biasa: </p><br><pre> <code class="plaintext hljs">$ docker build -t node-distroless .</code> </pre> <br><p>  Aplikasi harus bekerja dengan baik.  Untuk memeriksa, jalankan wadah: </p><br><pre> <code class="plaintext hljs">$ docker run -p 3000:3000 -ti --rm --init node-distroless</code> </pre> <br><p>  Dan buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http: // localhost: 3000</a> .  Apakah gambar menjadi lebih mudah tanpa binari tambahan? </p><br><pre> <code class="plaintext hljs">$ docker images | grep node-distroless node-distroless 7b4db3b7f1e5 76.7MB</code> </pre> <br><p>  <strong>Seperti itu saja!</strong>  <strong>Sekarang beratnya hanya 76,7 MB, sebanyak 600 MB lebih sedikit!</strong> </p><br><p>  Semuanya keren, tapi ada satu poin penting.  Saat wadah berjalan, dan Anda perlu memeriksanya, Anda dapat terhubung menggunakan: </p><br><pre> <code class="plaintext hljs">$ docker exec -ti &lt;insert_docker_id&gt; bash</code> </pre> <br><p>  Menyambung ke wadah yang sedang berjalan dan memulai <code>bash</code> sangat mirip dengan membuat sesi SSH. </p><br><p>  Tetapi karena distroless adalah versi yang dilucuti dari sistem operasi asli, tidak ada binari tambahan, atau, sebenarnya, sebuah shell! </p><br><p>  Bagaimana cara terhubung ke wadah yang sedang berjalan jika tidak ada shell? </p><br><p>  Yang paling menarik adalah tidak ada apa-apa. </p><br><p>  Ini tidak terlalu baik, karena hanya binari yang dapat dieksekusi dalam sebuah wadah.  Dan satu-satunya yang dapat diluncurkan adalah Node.js: </p><br><pre> <code class="plaintext hljs">$ docker exec -ti &lt;insert_docker_id&gt; node</code> </pre> <br><p>  Bahkan, ada nilai tambah dalam hal ini, karena jika beberapa penyerang dapat memperoleh akses ke wadah, itu akan jauh lebih sedikit ruginya daripada jika memiliki akses ke shell.  Dengan kata lain, lebih sedikit binari - bobot lebih sedikit dan keamanan yang lebih tinggi.  Tapi, dengan biaya debugging yang lebih kompleks. </p><br><p>  Di sini harus dicatat bahwa tidak layak menghubungkan dan men-debug kontainer di lingkungan prod.  Lebih baik mengandalkan sistem logging dan pemantauan yang dikonfigurasi dengan benar. </p><br><p>  Tetapi bagaimana jika kita masih perlu debugging, namun kita ingin gambar buruh pelabuhan menjadi yang terkecil? </p><br><h2 id="3-umenshaem-bazovye-obrazy-s-pomoschyu-alpine">  3. Kurangi gambar dasar dengan Alpine </h2><br><p>  Anda dapat mengganti distroless dengan gambar Alpine. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alpine Linux</a> adalah distribusi yang berorientasi keamanan, ringan berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">musl libc</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">busybox</a> .  Tapi kami tidak akan mengambil kata, melainkan memeriksanya. </p><br><p>  Jalankan <code>Dockerfile</code> menggunakan <code>node:8-alpine</code> : </p><br><pre> <code class="plaintext hljs">FROM node:8 as build WORKDIR /app COPY package.json index.js ./ RUN npm install FROM node:8-alpine COPY --from=build /app / EXPOSE 3000 CMD ["npm", "start"]</code> </pre> <br><p>  Buat gambar: </p><br><pre> <code class="plaintext hljs">$ docker build -t node-alpine .</code> </pre> <br><p>  Periksa ukuran: </p><br><pre> <code class="plaintext hljs">$ docker images | grep node-alpine node-alpine aa1f85f8e724 69.7MB</code> </pre> <br><p>  <strong>Pada output, kami memiliki 69,7MB - ini bahkan kurang dari gambar tanpa distro.</strong> </p><br><p>  Mari kita periksa apakah mungkin untuk terhubung ke wadah yang berfungsi (dalam hal gambar distrolles, kita tidak bisa melakukan ini). </p><br><p>  Luncurkan wadah: </p><br><pre> <code class="plaintext hljs">$ docker run -p 3000:3000 -ti --rm --init node-alpine Example app listening on port 3000!</code> </pre> <br><p>  Dan hubungkan: </p><br><pre> <code class="plaintext hljs">$ docker exec -ti 9d8e97e307d7 bash OCI runtime exec failed: exec failed: container_linux.go:296: starting container process caused "exec: \"bash\": executable file not found in $PATH": unknown</code> </pre> <br><p>  Tidak berhasil  Tapi mungkin wadahnya sudah ...: </p><br><pre> <code class="plaintext hljs">$ docker exec -ti 9d8e97e307d7 sh / #</code> </pre> <br><p>  Hebat!  Kami berhasil terhubung ke wadah, dan pada saat yang sama citranya juga lebih kecil.  Namun di sini ada beberapa nuansa. </p><br><p>  Gambar Alpine didasarkan pada muslc, pustaka standar alternatif untuk C. Sementara sebagian besar distribusi Linux, seperti Ubuntu, Debian, dan CentOS, didasarkan pada glibc.  Dipercaya bahwa kedua perpustakaan ini menyediakan antarmuka yang sama untuk bekerja dengan kernel. </p><br><p>  Namun, mereka memiliki tujuan yang berbeda: glibc adalah yang paling umum dan cepat, sementara muslc mengambil lebih sedikit ruang dan ditulis dengan bias keamanan.  Ketika suatu aplikasi mengkompilasi, sebagai suatu peraturan, ia mengkompilasi ke pustaka C. tertentu. Jika Anda perlu menggunakannya dengan pustaka lain, Anda harus melakukan kompilasi ulang. </p><br><p>  Dengan kata lain, membuat wadah pada gambar Alpine dapat menyebabkan kejadian yang tidak terduga, karena pustaka C standar yang digunakan di dalamnya berbeda.  Perbedaannya akan terlihat ketika bekerja dengan binari yang dikompilasi, seperti ekstensi Node.js untuk C ++. </p><br><p>  Misalnya, paket PhantomJS yang sudah jadi tidak berfungsi di Alpine. </p><br><h2 id="tak-kakoy-zhe-bazovyy-obraz-vybrat">  Jadi apa gambar dasar untuk dipilih? </h2><br><p>  Tampilan alpen, Alpine, atau vanilla - tentu saja, lebih baik memutuskan berdasarkan situasinya. </p><br><p>  <strong>Jika Anda berurusan dengan prod dan keamanan itu penting, mungkin ketidaktahuan akan lebih tepat.</strong> </p><br><p>  Setiap biner yang ditambahkan ke gambar Docker menambah risiko tertentu pada stabilitas seluruh aplikasi.  Risiko ini dapat dikurangi dengan hanya memasang satu biner di wadah. </p><br><p>  Misalnya, jika penyerang dapat menemukan kerentanan dalam aplikasi yang berjalan berdasarkan gambar yang tidak jelas, ia tidak dapat menjalankan shell dalam wadah karena tidak ada! </p><br><p>  <strong>Jika karena alasan tertentu ukuran gambar buruh pelabuhan sangat penting bagi Anda, sudah pasti ada baiknya melihat lebih dekat pada gambar berbasis Alpine.</strong> </p><br><p>  Mereka benar-benar kecil, tetapi, dengan biaya kompatibilitas.  Alpine menggunakan pustaka C standar yang sedikit berbeda, muslc, jadi terkadang masalah akan muncul.  Contohnya tersedia di tautan berikut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/grpc/grpc/issues/8528</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/grpc/grpc/issues/6126</a> . </p><br><p>  <strong>Gambar vanila sangat ideal untuk pengujian dan pengembangan.</strong> </p><br><p>  Ya, mereka besar, tetapi mereka terlihat seperti mesin lengkap dengan Ubuntu diinstal.  Selain itu, semua binari di OS tersedia. </p><br><p>  <strong>Ringkas ukuran gambar Docker yang diterima:</strong> </p><br><p>  <code>node:8</code> 681MB <br>  <code>node:8</code> dengan build incremental 678MB <br>  <code>gcr.io/distroless/nodejs</code> 76.7MB <br>  <code>node:8-alpine</code> 69,7MB </p><br><h3 id="naputstvie-ot-perevodchika">  Kata perpisahan dari penerjemah </h3><br><p>  Baca artikel lain di blog kami: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cadangan stateful di Kubernetes</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mencadangkan sejumlah besar proyek web heterogen</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bot Telegram untuk Redmine.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara menyederhanakan hidup untuk diri sendiri dan orang</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437372/">https://habr.com/ru/post/id437372/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437358/index.html">Manajemen Kompatibilitas Produk</a></li>
<li><a href="../id437360/index.html">Mengunduh pengontrol tanpa menggunakan konsol IDE Arduino</a></li>
<li><a href="../id437364/index.html">Kontrol atas Tele2 akan menelan biaya Rostelecom 240 miliar rubel</a></li>
<li><a href="../id437366/index.html">Cara meretas pabrik: sistem kontrol radio sebagai tautan lemah dalam produksi modern</a></li>
<li><a href="../id437368/index.html">MOSDROID # 15 Fosfor</a></li>
<li><a href="../id437374/index.html">Pengguna Facebook menyewakan akun mereka dengan uang dan laptop gratis</a></li>
<li><a href="../id437376/index.html">Penasaran Penasaran dari Dunia IT - 2</a></li>
<li><a href="../id437378/index.html">Apa itu ARCore? Yang perlu Anda ketahui</a></li>
<li><a href="../id437380/index.html">Semua orang menegur kerangka kerja tes tertulis. Dan kami senang dengan kami</a></li>
<li><a href="../id437382/index.html">Teori kembang api. Fantasi kosmologis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>