<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß§ üö¥üèø üí± Kami berurusan dengan antarmuka di Go ‚ú® üë©‚Äçüåæ üé∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam beberapa bulan terakhir, saya telah melakukan penelitian yang menanyakan kepada orang-orang apa yang sulit untuk mereka pahami di Go. Dan saya p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami berurusan dengan antarmuka di Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/463063/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_f/w7/1l/_fw71luza3o_kj1bh6t015wlp4c.jpeg"></div><br>  Dalam beberapa bulan terakhir, saya telah melakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penelitian yang</a> menanyakan kepada orang-orang apa yang sulit untuk mereka pahami di Go.  Dan saya perhatikan bahwa konsep antarmuka secara teratur disebutkan dalam jawaban.  Go adalah bahasa antarmuka pertama yang saya gunakan, dan saya ingat bahwa pada saat itu konsep ini tampak sangat membingungkan.  Dan dalam panduan ini, saya ingin melakukan ini: <br><br><ol><li>  Untuk menjelaskan dalam bahasa manusia apa antarmuka itu. </li><li>  Jelaskan bagaimana mereka berguna dan bagaimana Anda dapat menggunakannya dalam kode Anda. </li><li> Bicara tentang apa <code>interface{}</code> (antarmuka kosong). </li><li>  Dan berjalanlah melalui beberapa jenis antarmuka berguna yang dapat Anda temukan di perpustakaan standar. </li></ol><a name="habracut"></a><br><h2>  Jadi apa itu antarmuka? </h2><br>  Jenis antarmuka di Go adalah semacam <i>definisi</i> .  Ini mendefinisikan dan menjelaskan metode spesifik yang <i>harus dimiliki beberapa tipe lain</i> . <br><br>  Salah satu jenis antarmuka dari perpustakaan standar adalah antarmuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fmt.Stringer</a> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Stringer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { String() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br>  Kami mengatakan bahwa sesuatu <i>memenuhi antarmuka ini</i> (atau <i>mengimplementasikan antarmuka ini</i> ) jika "sesuatu" ini memiliki metode dengan nilai string tanda tangan khusus <code>String()</code> . <br><br>  Misalnya, tipe <code>Book</code> memenuhi antarmuka karena memiliki metode <code>String()</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Book <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Author <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b Book)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"Book: %s - %s"</span></span>, b.Title, b.Author) }</code> </pre> <br>  Tidak masalah apa jenis <code>Book</code> atau apa fungsinya.  Yang penting adalah ia memiliki metode yang disebut <code>String()</code> yang mengembalikan nilai string. <br><br>  Ini adalah contoh lain.  Tipe <code>Count</code> juga <i>memenuhi antarmuka</i> <code>fmt.Stringer</code> karena memiliki metode dengan nilai string tanda tangan yang sama <code>String()</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Count <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c Count)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strconv.Itoa(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(c)) }</code> </pre> <br>  Penting untuk dipahami di sini bahwa kita memiliki dua jenis <code>Book</code> dan <code>Count</code> yang berbeda, yang bertindak secara berbeda.  Tetapi mereka disatukan oleh fakta bahwa mereka berdua memenuhi antarmuka <code>fmt.Stringer</code> . <br><br>  Anda bisa melihatnya dari sisi lain.  Jika Anda tahu bahwa objek memenuhi antarmuka <code>fmt.Stringer</code> , maka Anda dapat mengasumsikan bahwa ia memiliki metode dengan nilai string tanda tangan <code>String()</code> yang dapat Anda panggil. <br><br>  Dan sekarang yang paling penting. <br><br>  <i>Saat Anda melihat deklarasi di Go (dari variabel, parameter fungsi, atau bidang struktur) yang memiliki tipe antarmuka, Anda bisa menggunakan objek jenis apa saja selama memenuhi antarmuka.</i> <br><br>  Katakanlah kita memiliki fungsi: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s fmt.Stringer)</span></span></span></span> { log.Println(s.String()) }</code> </pre> <br>  Karena <code>WriteLog()</code> menggunakan tipe antarmuka <code>fmt.Stringer</code> dalam <code>fmt.Stringer</code> parameter, kita dapat melewatkan objek apa pun yang memenuhi antarmuka <code>fmt.Stringer</code> .  Misalnya, kita bisa meneruskan jenis <code>Book</code> dan <code>Count</code> yang kita buat sebelumnya dalam metode <code>WriteLog()</code> , dan kode akan berfungsi dengan baik. <br><br>  Selain itu, karena objek yang dikirimkan memenuhi antarmuka <code>fmt.Stringer</code> , kita <i>tahu</i> bahwa ia memiliki metode <code>String()</code> , yang dapat dengan aman dipanggil oleh fungsi <code>WriteLog()</code> . <br><br>  Mari kita satukan semuanya dalam satu contoh, menunjukkan kekuatan antarmuka. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//   Book,    fmt.Stringer. type Book struct { Title string Author string } func (b Book) String() string { return fmt.Sprintf("Book: %s - %s", b.Title, b.Author) } //   Count,    fmt.Stringer. type Count int func (c Count) String() string { return strconv.Itoa(int(c)) } //   WriteLog(),    , //   fmt.Stringer   . func WriteLog(s fmt.Stringer) { log.Println(s.String()) } func main() { //   Book    WriteLog(). book := Book{"Alice in Wonderland", "Lewis Carrol"} WriteLog(book) //   Count    WriteLog(). count := Count(3) WriteLog(count) }</span></span></code> </pre> <br>  Ini luar biasa.  Dalam fungsi utama, kami membuat berbagai jenis <code>Book</code> dan <code>Count</code> , tetapi meneruskannya ke fungsi <code>WriteLog()</code> <i>sama</i> .  Dan dia memanggil fungsi <code>String()</code> sesuai dan menulis hasilnya ke log. <br><br>  Jika Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengeksekusi kode</a> , Anda akan mendapatkan hasil yang serupa: <br><br><pre> <code class="plaintext hljs">2009/11/10 23:00:00 Book: Alice in Wonderland - Lewis Carrol 2009/11/10 23:00:00 3</code> </pre> <br>  Kami tidak akan membahas hal ini secara rinci.  Hal utama yang perlu diingat: menggunakan tipe antarmuka dalam deklarasi fungsi <code>WriteLog()</code> , kami membuat fungsi acuh tak acuh (atau fleksibel) dengan <i>jenis</i> objek yang diterima.  Yang penting adalah <i>metode apa yang dia miliki</i> . <br><br><h2>  Apa antarmuka yang bermanfaat? </h2><br>  Ada sejumlah alasan mengapa Anda bisa mulai menggunakan antarmuka di Go.  Dan dalam pengalaman saya, yang paling penting adalah: <br><br><ol><li>  Antarmuka membantu mengurangi duplikasi, yaitu jumlah kode boilerplate. </li><li>  Mereka membuatnya lebih mudah untuk menggunakan bertopik pada unit test daripada benda nyata. </li><li>  Menjadi alat arsitektur, antarmuka membantu membuka bagian-bagian basis kode Anda. </li></ol><br>  Mari kita lihat lebih dekat cara-cara ini menggunakan antarmuka. <br><br><h3>  Kurangi jumlah kode boilerplate </h3><br>  Misalkan kita memiliki struktur <code>Customer</code> yang berisi beberapa jenis data pelanggan.  Di satu bagian dari kode, kami ingin menulis informasi ini ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bytes.Buffer</a> , dan di bagian lain kami ingin menulis data klien ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">os.File</a> pada disk.  Namun, dalam kedua kasus tersebut, kami ingin membuat serialisasi struktur <code>ustomer</code> menjadi JSON. <br><br>  Dalam skenario ini, kita bisa mengurangi jumlah kode boilerplate menggunakan antarmuka Go. <br><br>  Go memiliki jenis antarmuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">io.Writer</a> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Writer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Write(p []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (n <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, err error) }</code> </pre> <br>  Dan kita dapat mengambil keuntungan dari fakta bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bytes.Buffer</a> dan tipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">os.File</a> memenuhi antarmuka ini, karena mereka memiliki metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bytes.Buffer.Write ()</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">os.File.Write ()</a> , masing-masing. <br><br>  Implementasi sederhana: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//   Customer. type Customer struct { Name string Age int } //   WriteJSON,   io.Writer   . //    ustomer  JSON,     // ,     Write()  io.Writer. func (c *Customer) WriteJSON(w io.Writer) error { js, err := json.Marshal(c) if err != nil { return err } _, err = w.Write(js) return err } func main() { //   Customer. c := &amp;Customer{Name: "Alice", Age: 21} //    Buffer    WriteJSON var buf bytes.Buffer err := c.WriteJSON(buf) if err != nil { log.Fatal(err) } //   . f, err := os.Create("/tmp/customer") if err != nil { log.Fatal(err) } defer f.Close() err = c.WriteJSON(f) if err != nil { log.Fatal(err) } }</span></span></code> </pre> <br>  Tentu saja, ini hanya contoh fiktif (kita dapat menyusun kode secara berbeda untuk mencapai hasil yang sama).  Tapi itu menggambarkan dengan baik keuntungan menggunakan antarmuka: kita dapat membuat metode <code>Customer.WriteJSON()</code> sekali dan menyebutnya setiap kali kita perlu menulis sesuatu yang memenuhi antarmuka <code>io.Writer</code> . <br><br>  Tetapi jika Anda baru menggunakan Go, Anda akan memiliki beberapa pertanyaan: ‚Äú <i>Bagaimana saya tahu jika antarmuka io.Writer ada?</i>  <i>Dan bagaimana Anda tahu sebelumnya bahwa dia puas dengan <code>bytes.Buffer</code> dan <code>os.File</code> ?</i>  " <br><br>  Saya khawatir tidak ada solusi sederhana.  Anda hanya perlu mendapatkan pengalaman, berkenalan dengan antarmuka dan berbagai jenis dari perpustakaan standar.  Ini akan membantu membaca dokumentasi untuk perpustakaan ini dan melihat kode orang lain.  Dan untuk referensi cepat, saya menambahkan jenis-jenis antarmuka yang paling berguna pada akhir artikel. <br><br>  Tetapi bahkan jika Anda tidak menggunakan antarmuka dari perpustakaan standar, tidak ada yang mencegah Anda membuat dan menggunakan <i>jenis antarmuka Anda sendiri</i> .  Kami akan membicarakan ini di bawah ini. <br><br><h3>  Pengujian dan Rintisan Unit </h3><br>  Untuk memahami bagaimana antarmuka membantu dalam pengujian unit, mari kita lihat contoh yang lebih kompleks. <br><br>  Misalkan Anda memiliki informasi toko dan toko tentang penjualan dan jumlah pelanggan di PostgreSQL.  Anda ingin menulis kode yang menghitung pangsa penjualan (jumlah penjualan spesifik per pelanggan) untuk hari terakhir, dibulatkan menjadi dua tempat desimal. <br><br>  Implementasi minimal akan terlihat seperti ini: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// : main.go package main import ( "fmt" "log" "time" "database/sql" _ "github.com/lib/pq" ) type ShopDB struct { *sql.DB } func (sdb *ShopDB) CountCustomers(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM customers WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func (sdb *ShopDB) CountSales(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM sales WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func main() { db, err := sql.Open("postgres", "postgres://user:pass@localhost/db") if err != nil { log.Fatal(err) } defer db.Close() shopDB := &amp;ShopDB{db} sr, err := calculateSalesRate(shopDB) if err != nil { log.Fatal(err) } fmt.Printf(sr) } func calculateSalesRate(sdb *ShopDB) (string, error) { since := time.Now().Sub(24 * time.Hour) sales, err := sdb.CountSales(since) if err != nil { return "", err } customers, err := sdb.CountCustomers(since) if err != nil { return "", err } rate := float64(sales) / float64(customers) return fmt.Sprintf("%.2f", rate), nil }</span></span></code> </pre> <br>  Sekarang kita ingin membuat unit test untuk fungsi <code>calculateSalesRate()</code> untuk memverifikasi bahwa perhitungannya benar. <br><br>  Sekarang bermasalah.  Kita perlu mengonfigurasi contoh pengujian PostgreSQL, serta membuat dan menghapus skrip untuk mengisi basis data dengan data palsu.  Kami memiliki banyak pekerjaan yang harus dilakukan jika kami benar-benar ingin menguji perhitungan kami. <br><br>  Dan antarmuka datang untuk menyelamatkan! <br><br>  Kami akan membuat jenis antarmuka kami sendiri yang menggambarkan metode <code>CountSales()</code> dan <code>CountCustomers()</code> , yang bergantung pada fungsi <code>CountCustomers()</code> .  Kemudian perbarui tanda tangan <code>*ShopDB</code> <code>calculateSalesRate()</code> untuk menggunakan tipe antarmuka ini sebagai parameter alih-alih tipe <code>*ShopDB</code> ditentukan. <br><br>  Seperti ini: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// : main.go package main import ( "fmt" "log" "time" "database/sql" _ "github.com/lib/pq" ) //    ShopModel.     //     ,     //  -,     . type ShopModel interface { CountCustomers(time.Time) (int, error) CountSales(time.Time) (int, error) } //  ShopDB    ShopModel,   //       -- CountCustomers()  CountSales(). type ShopDB struct { *sql.DB } func (sdb *ShopDB) CountCustomers(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM customers WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func (sdb *ShopDB) CountSales(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM sales WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func main() { db, err := sql.Open("postgres", "postgres://user:pass@localhost/db") if err != nil { log.Fatal(err) } defer db.Close() shopDB := &amp;ShopDB{db} sr := calculateSalesRate(shopDB) fmt.Printf(sr) } //       ShopModel    //    *ShopDB. func calculateSalesRate(sm ShopModel) string { since := time.Now().Sub(24 * time.Hour) sales, err := sm.CountSales(since) if err != nil { return "", err } customers, err := sm.CountCustomers(since) if err != nil { return "", err } rate := float64(sales) / float64(customers) return fmt.Sprintf("%.2f", rate), nil }</span></span></code> </pre> <br>  Setelah kami melakukan ini, kami hanya akan membuat tulisan rintisan yang memenuhi antarmuka <code>ShopModel</code> .  Kemudian Anda dapat menggunakannya selama pengujian unit operasi logika matematika yang benar dalam fungsi <code>calculateSalesRate()</code> .  Seperti ini: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// : main_test.go package main import ( "testing" ) type MockShopDB struct{} func (m *MockShopDB) CountCustomers() (int, error) { return 1000, nil } func (m *MockShopDB) CountSales() (int, error) { return 333, nil } func TestCalculateSalesRate(t *testing.T) { //  . m := &amp;MockShopDB{} //     calculateSalesRate(). sr := calculateSalesRate(m) // ,        //   . exp := "0.33" if sr != exp { t.Fatalf("got %v; expected %v", sr, exp) } }</span></span></code> </pre> <br>  Sekarang jalankan tes dan semuanya berfungsi dengan baik. <br><br><h3>  Arsitektur aplikasi </h3><br>  Pada contoh sebelumnya, kami melihat bagaimana Anda dapat menggunakan antarmuka untuk memisahkan bagian-bagian tertentu dari kode dari menggunakan jenis tertentu.  Misalnya, fungsi <code>ShopModel</code> <code>calculateSalesRate()</code> tidak masalah apa yang Anda berikan, asalkan memenuhi antarmuka <code>ShopModel</code> . <br><br>  Anda dapat memperluas ide ini dan membuat seluruh level "tidak terikat" dalam proyek-proyek besar. <br>  Misalkan Anda membuat aplikasi web yang berinteraksi dengan database.  Jika Anda membuat antarmuka yang menjelaskan metode tertentu untuk berinteraksi dengan database, Anda bisa merujuknya daripada jenis tertentu melalui penangan HTTP.  Karena penangan HTTP hanya merujuk ke antarmuka, ini akan membantu memisahkan tingkat HTTP dan tingkat interaksi dengan basis data satu sama lain.  Akan lebih mudah untuk bekerja dengan level secara mandiri, dan di masa depan Anda akan dapat mengganti beberapa level tanpa memengaruhi pekerjaan orang lain. <br><br>  Saya menulis tentang pola ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah satu posting sebelumnya</a> , ada lebih banyak detail dan contoh praktis. <br><br><h2>  Apa itu antarmuka kosong? </h2><br>  Jika Anda telah pemrograman di Go untuk beberapa waktu, maka Anda mungkin menemukan <i>antarmuka tipe antarmuka kosong</i> <code>interface{}</code> .  Saya akan mencoba menjelaskan apa itu.  Di awal artikel ini, saya menulis: <br><br><blockquote>  Jenis antarmuka di Go adalah semacam <i>definisi</i> .  Ini mendefinisikan dan menjelaskan metode spesifik yang <i>harus dimiliki beberapa tipe lain</i> . </blockquote><br>  Jenis antarmuka kosong <i>tidak menjelaskan metode</i> .  Dia tidak punya aturan.  Dan objek apa pun memenuhi antarmuka kosong. <br><br>  Intinya, antarmuka jenis antarmuka kosong <code>interface{}</code> adalah sejenis joker.  Jika Anda bertemu dalam deklarasi (variabel, parameter fungsi atau bidang struktur), maka Anda dapat menggunakan objek <i>jenis apa pun</i> . <br><br>  Pertimbangkan kodenya: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { person := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, <span class="hljs-number"><span class="hljs-number">0</span></span>) person[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Alice"</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = <span class="hljs-number"><span class="hljs-number">21</span></span> person[<span class="hljs-string"><span class="hljs-string">"height"</span></span>] = <span class="hljs-number"><span class="hljs-number">167.64</span></span> fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%+v"</span></span>, person) }</code> </pre> <br>  Di sini kita menginisialisasi peta menjadi <code>person</code> , yang menggunakan tipe string untuk kunci dan antarmuka tipe antarmuka kosong <code>interface{}</code> untuk nilai.  Kami menetapkan tiga jenis berbeda sebagai nilai peta (string, integer dan float32), dan tidak ada masalah.  Karena objek jenis apa pun memenuhi antarmuka kosong, kodenya berfungsi dengan baik. <br><br>  Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menjalankan kode ini di sini</a> , Anda akan melihat hasil yang serupa: <br><br><pre> <code class="plaintext hljs">map[age:21 height:167.64 name:Alice]</code> </pre> <br>  Ketika datang untuk mengekstraksi dan menggunakan nilai-nilai dari peta, penting untuk diingat ini.  Misalkan Anda ingin mendapatkan nilai <code>age</code> dan meningkatkannya dengan 1. Jika Anda menulis kode yang sama, maka itu tidak akan dikompilasi: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { person := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, <span class="hljs-number"><span class="hljs-number">0</span></span>) person[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Alice"</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = <span class="hljs-number"><span class="hljs-number">21</span></span> person[<span class="hljs-string"><span class="hljs-string">"height"</span></span>] = <span class="hljs-number"><span class="hljs-number">167.64</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span> fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%+v"</span></span>, person) }</code> </pre> <br>  Anda akan menerima pesan kesalahan: <br><br><pre> <code class="plaintext hljs">invalid operation: person["age"] + 1 (mismatched types interface {} and int)</code> </pre> <br>  Alasannya adalah bahwa nilai yang disimpan dalam peta mengambil tipe <code>interface{}</code> dan kehilangan tipe int dasarnya.  Dan karena nilainya tidak lagi bilangan bulat, kami tidak dapat menambahkan 1 ke dalamnya. <br><br>  Untuk menyiasatinya, Anda perlu membuat integer nilai lagi, dan baru menggunakannya: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { person := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, <span class="hljs-number"><span class="hljs-number">0</span></span>) person[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Alice"</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = <span class="hljs-number"><span class="hljs-number">21</span></span> person[<span class="hljs-string"><span class="hljs-string">"height"</span></span>] = <span class="hljs-number"><span class="hljs-number">167.64</span></span> age, ok := person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { log.Fatal(<span class="hljs-string"><span class="hljs-string">"could not assert value to int"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = age + <span class="hljs-number"><span class="hljs-number">1</span></span> log.Printf(<span class="hljs-string"><span class="hljs-string">"%+v"</span></span>, person) }</code> </pre> <br>  Jika Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menjalankan ini</a> , semuanya akan berfungsi seperti yang diharapkan: <br><br><pre> <code class="plaintext hljs">2009/11/10 23:00:00 map[age:22 height:167.64 name:Alice]</code> </pre> <br>  Jadi kapan Anda harus menggunakan jenis antarmuka kosong? <br><br>  Mungkin <i>tidak terlalu sering</i> .  Jika Anda sampai pada ini, maka berhentilah dan pikirkan apakah benar menggunakan <code>interface{}</code> .  Sebagai saran umum, saya dapat mengatakan bahwa akan lebih jelas, lebih aman dan lebih produktif untuk menggunakan tipe tertentu, yaitu tipe antarmuka yang tidak kosong.  Dalam contoh di atas, lebih baik untuk mendefinisikan struktur <code>Person</code> dengan bidang yang diketik dengan tepat: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Age <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Height <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> }</code> </pre> <br>  Antarmuka kosong, di sisi lain, berguna ketika Anda perlu mengakses dan bekerja dengan jenis yang tidak dapat diprediksi atau ditentukan oleh pengguna.  Untuk beberapa alasan, antarmuka tersebut digunakan di tempat yang berbeda di perpustakaan standar, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gob.Encode</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fmt.Print,</a> dan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">template.Execute</a> . <br><br><h2>  Jenis Antarmuka yang Berguna </h2><br>  Berikut adalah daftar pendek jenis antarmuka yang paling banyak diminta dan berguna dari perpustakaan standar.  Jika Anda belum terbiasa dengan mereka, maka saya sarankan membaca dokumentasi yang relevan. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">builtin. Kesalahan</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fmt. Stringer</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">io.Reader</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penulis</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">io.ReadWriteCloser</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://golang.org/pkg/net/">http.ResponseWriter</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://golang.org/pkg/net/">http. handler</a> <br></li></ul><br>  Daftar pustaka standar yang lebih panjang juga tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463063/">https://habr.com/ru/post/id463063/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463045/index.html">Secara otomatis mendeteksi emosi dalam percakapan teks menggunakan jaringan saraf</a></li>
<li><a href="../id463055/index.html">Tentang admin, devops, kebingungan tanpa akhir dan transformasi DevOps dalam perusahaan</a></li>
<li><a href="../id463057/index.html">Kerangka kerja Yii 2 hak khusus</a></li>
<li><a href="../id463059/index.html">Tiga tinggal di IT dan bukan hanya</a></li>
<li><a href="../id463061/index.html">Aturan untuk menyiapkan tata letak dalam Figma</a></li>
<li><a href="../id463067/index.html">Pertama bagian depan, dan kemudian bagian belakang (suatu hari nanti)</a></li>
<li><a href="../id463069/index.html">Bereaksi Panduan Animasi Dasar</a></li>
<li><a href="../id463071/index.html">Apa dampak pemadaman internet?</a></li>
<li><a href="../id463073/index.html">QUIC in action: bagaimana Uber menerapkannya untuk mengoptimalkan kinerja</a></li>
<li><a href="../id463075/index.html">Lisensi Open Source Baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>