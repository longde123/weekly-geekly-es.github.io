<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎣 🤰🏼 ⏸️ Pelajari OpenGL. Pelajaran 5.10 - Layar Ruang Ambient Occlusion 🔏 👨🏾‍🎨 🅱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SSAO 
 Topik tentang pencahayaan latar belakang diangkat oleh kami dalam pelajaran tentang dasar - dasar pencahayaan , tetapi hanya secara sepintas. B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelajari OpenGL. Pelajaran 5.10 - Layar Ruang Ambient Occlusion</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421385/"><img align="left" src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="OGL3" width="300"><h2>  SSAO </h2><br>  Topik tentang pencahayaan latar belakang diangkat oleh kami dalam pelajaran tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dasar</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dasar pencahayaan</a> , tetapi hanya secara sepintas.  Biarkan saya mengingatkan Anda: komponen latar belakang pencahayaan pada dasarnya adalah nilai konstan yang ditambahkan ke semua perhitungan pencahayaan pemandangan untuk mensimulasikan proses <i>hamburan cahaya</i> .  Di dunia nyata, cahaya mengalami banyak pantulan dengan berbagai tingkat intensitas, yang menyebabkan pencahayaan yang sama tidak merata dari bagian-bagian pemandangan yang secara tidak langsung diterangi.  Jelas, suar dengan intensitas konstan tidak terlalu masuk akal. <br><br>  Salah satu jenis perhitungan perkiraan bayangan dari pencahayaan tidak langsung adalah algoritma <i>ambient occlusion (AO</i> ), yang mensimulasikan redaman pencahayaan tidak langsung di sekitar sudut, kerutan, dan penyimpangan permukaan lainnya.  Elemen-elemen tersebut, secara umum, secara signifikan tumpang tindih oleh geometri yang berdekatan dan karenanya meninggalkan lebih sedikit sinar cahaya untuk keluar, mengaburkan area-area ini. <br><br>  Di bawah ini adalah perbandingan rendering tanpa dan menggunakan algoritma AO.  Perhatikan bagaimana intensitas pencahayaan latar belakang berkurang di sekitar sudut-sudut dinding dan pecah tajam lainnya di permukaan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6s/8z/kv/6s8zkvpob8nbgaails8mtfutgw8.png"></div><br>  Meskipun efeknya tidak terlalu terlihat, kehadiran efek di seluruh adegan menambah realisme karena ilusi kedalaman tambahan yang diciptakan oleh detail kecil dari efek bayangan diri. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Isi</b> <div class="spoiler_text">  Bagian 1. Memulai <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembuatan jendela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halo jendela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halo segitiga</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tekstur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transformasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sistem koordinat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kamera</a> </li></ol><br>  Bagian 2. Pencahayaan dasar <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Warna</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dasar-dasar pencahayaan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Material</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta tekstur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber cahaya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berbagai Sumber Penerangan</a> </li></ol><br>  Bagian 3. Unduh model 3D <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perpustakaan Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas Polygon Mesh</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas Model 3D</a> </li></ol><br>  Bagian 4. Fitur OpenGL Lanjutan <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes kedalaman</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes stensil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pencampuran warna</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memotong wajah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buffer bingkai</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kartu kubik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penanganan data tingkat lanjut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GLSL tingkat lanjut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shader geometris</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Instancing</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghaluskan</a> </li></ol><br>  Bagian 5. Pencahayaan Lanjut <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pencahayaan tingkat lanjut.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Model Blinn-Fong.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Koreksi gamma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kartu bayangan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta bayangan omnidirectional</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemetaan normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemetaan paralaks</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Render yang ditangguhkan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SSAO</a> </li></ol><br>  Bagian 6. PBR <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teori</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber Cahaya Analitik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Iradiasi difus.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paparan cermin.</a> </li></ol><br></div></div><br>  Perlu dicatat bahwa algoritma untuk menghitung AO cukup intensif sumber daya, karena mereka memerlukan analisis geometri sekitarnya.  Dalam implementasi yang naif, dimungkinkan untuk memancarkan banyak sinar pada setiap titik di permukaan dan menentukan tingkat bayangannya, tetapi pendekatan ini dengan sangat cepat mencapai batas sumber daya intensif yang dapat diterima untuk aplikasi interaktif.  Untungnya, pada tahun 2007, Crytek menerbitkan sebuah makalah yang menjelaskan pendekatannya sendiri untuk mengimplementasikan algoritma <i>Screen-Space Ambient Occlusion (SSAO</i> ) yang digunakan dalam versi rilis Crysis.  Pendekatan ini menghitung tingkat bayangan di ruang layar, hanya menggunakan buffer kedalaman saat ini, bukan data nyata tentang geometri sekitarnya.  Optimalisasi seperti itu secara radikal mempercepat algoritma dibandingkan dengan implementasi referensi dan pada saat yang sama memberikan sebagian besar hasil yang masuk akal, yang membuat pendekatan ini perkiraan perhitungan latar belakang shading industri de facto standar. <br><br>  Prinsip yang menjadi dasar algoritma ini cukup sederhana: untuk setiap fragmen dari quad-screen penuh, <i>faktor oklusi</i> dihitung berdasarkan nilai kedalaman fragmen-fragmen di sekitarnya.  Koefisien naungan yang dihitung kemudian digunakan untuk mengurangi intensitas pencahayaan latar belakang (hingga pengecualian total).  Untuk mendapatkan koefisien, diperlukan pengumpulan data kedalaman dari sejumlah sampel dari wilayah bola yang mengelilingi fragmen yang dimaksud dan membandingkan nilai kedalaman ini dengan kedalaman fragmen yang dimaksud.  Jumlah sampel yang memiliki kedalaman lebih besar daripada fragmen saat ini secara langsung menentukan koefisien naungan.  Lihatlah diagram ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y5/yh/8o/y5yh8oeqvguchqopeu7nz0g-tsy.png"></div><br>  Di sini, setiap titik abu-abu terletak di dalam objek geometris tertentu, dan oleh karena itu memberikan kontribusi pada nilai koefisien naungan.  Semakin banyak sampel di dalam geometri objek di sekitarnya, semakin sedikit intensitas residu dari latar belakang naungan di area ini. <br><br>  Jelas, kualitas dan realisme efek secara langsung tergantung pada jumlah sampel yang diambil.  Dengan sejumlah kecil sampel, keakuratan algoritme menurun dan mengarah pada munculnya artefak <i>banding</i> atau " <i>banding</i> " karena transisi mendadak antara kawasan dengan koefisien bayangan yang sangat berbeda.  Sejumlah besar sampel hanya membunuh kinerja.  Pengacakan inti sampel memungkinkan hasil yang agak mirip untuk sedikit mengurangi jumlah sampel yang diperlukan.  Reorientasi dengan rotasi ke sudut acak dari sekumpulan vektor sampel tersirat.  Namun, memperkenalkan keacakan segera membawa masalah baru dalam bentuk pola kebisingan yang nyata, yang membutuhkan penggunaan filter blur untuk memuluskan hasilnya.  Di bawah ini adalah contoh algoritma (penulis - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">John Chapman</a> ) dan masalah khasnya: pola garis dan derau. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r_/ay/l3/r_ayl3jjozsa6fyuni69ejkwpei.jpeg"></div><br>  Seperti yang dapat dilihat, pita yang terlihat karena jumlah sampel yang sedikit dihilangkan dengan memperkenalkan pengacakan orientasi sampel. <br><br>  Implementasi SSAO spesifik Crytek memiliki gaya visual yang dapat dikenali.  Karena spesialis Crytek menggunakan inti bulat dari sampel, ini bahkan mempengaruhi permukaan datar seperti dinding, menjadikannya teduh - karena setengah volume inti sampel terendam di bawah geometri.  Di bawah ini adalah tangkapan layar adegan dari Crysis yang ditunjukkan dalam skala abu-abu berdasarkan nilai faktor peneduh.  Di sini efek "kelabu" terlihat jelas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j9/zr/r8/j9zrr81dluj-5eobuqcgst48om8.jpeg"></div><br>  Untuk menghindari efek ini, kami akan pindah dari inti bola sampel ke belahan bumi yang berorientasi normal ke permukaan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/br/pf/3v/brpf3vfbmzd9pmna58ub5x7-age.png"></div><br>  Ketika mengambil sampel dari <i>belahan otak yang berorientasi normal,</i> kita tidak harus memperhitungkan fragmen yang berada di bawah permukaan permukaan yang berdekatan dalam perhitungan koefisien naungan.  Pendekatan ini menghilangkan naungan yang tidak perlu, secara umum, memberikan hasil yang lebih realistis.  Pelajaran ini akan menggunakan pendekatan belahan bumi dan kode yang sedikit lebih halus dari pelajaran SSAO yang brilian oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">John Chapman</a> . <br><br><h2>  Buffer data mentah </h2><br>  Proses menghitung faktor peneduh pada setiap fragmen memerlukan ketersediaan data tentang geometri sekitarnya.  Secara khusus, kami membutuhkan data berikut: <br><br><ul><li>  Vektor posisi untuk setiap fragmen; </li><li>  Vektor normal untuk setiap fragmen; </li><li>  Warna difus untuk setiap fragmen; </li><li>  Inti dari sampel </li><li>  Vektor rotasi acak untuk setiap fragmen yang digunakan dalam reorientasi inti sampel. </li></ul><br>  Dengan menggunakan data pada koordinat fragmen dalam ruang spesies, kita dapat mengarahkan belahan dari inti sampel sepanjang vektor normal yang ditentukan dalam ruang spesies untuk fragmen saat ini.  Kemudian, inti yang dihasilkan digunakan untuk membuat sampel dengan berbagai offset dari tekstur yang menyimpan data pada koordinat fragmen.  Kami membuat banyak sampel di setiap fragmen, dan untuk setiap sampel yang kami buat, kami membandingkan nilai kedalamannya dengan nilai kedalaman dari buffer koordinat fragmen untuk memperkirakan jumlah naungan.  Nilai yang dihasilkan kemudian digunakan untuk membatasi kontribusi komponen latar belakang dalam perhitungan pencahayaan akhir.  Menggunakan vektor rotasi acak yang terpecah-pecah, kita dapat secara signifikan mengurangi jumlah sampel yang diperlukan untuk mendapatkan hasil yang layak, dan kemudian ini akan ditunjukkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wv/xo/aj/wvxoajroexwvjgq77n81-fjhats.png"></div><br>  Karena SSAO adalah efek yang diwujudkan dalam ruang layar, dimungkinkan untuk melakukan perhitungan langsung dengan merender layar quad penuh.  Tapi kemudian kita tidak akan memiliki data tentang geometri tempat kejadian.  Untuk mengatasi batasan ini, kami akan memberikan semua informasi yang diperlukan dalam tekstur, yang nantinya akan digunakan dalam shader SSAO untuk mengakses informasi geometris dan lainnya tentang adegan tersebut.  Jika Anda dengan hati-hati mengikuti pelajaran ini, maka Anda harus sudah tahu dalam pendekatan yang dijelaskan tentang penampilan algoritma peneduhan tertunda.  Ini adalah sebagian besar mengapa efek SSAO sebagai asli muncul dalam render dengan peneduhan yang ditangguhkan - setelah semua, tekstur yang menyimpan koordinat dan normal sudah tersedia di buffer-G. <br><br><blockquote>  Dalam pelajaran ini, efeknya diterapkan di atas versi kode yang sedikit disederhanakan dari pelajaran tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencahayaan yang ditangguhkan</a> .  Jika Anda belum membiasakan diri dengan prinsip-prinsip pencahayaan yang tertunda, saya sangat menyarankan Anda beralih ke pelajaran ini. <br></blockquote><br>  Karena akses ke informasi fragmen tentang koordinat dan normals seharusnya sudah tersedia karena buffer-G, shader fragmen pada tahap pemrosesan geometri cukup sederhana: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) out vec4 gPosition; layout (location = 1) out vec3 gNormal; layout (location = 2) out vec4 gAlbedoSpec; in vec2 TexCoords; in vec3 FragPos; in vec3 Normal; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//        gPosition = FragPos; //       gNormal = normalize(Normal); //    -   gAlbedoSpec.rgb = vec3(0.95); }</span></span></span></span></code> </pre> <br>  Karena algoritma SSAO berpengaruh pada ruang layar, dan faktor peneduh dihitung berdasarkan area yang terlihat dari pemandangan, masuk akal untuk melakukan perhitungan dalam ruang tampilan.  Dalam hal ini, variabel <i>FragPos yang</i> diperoleh dari vertex shader menyimpan posisi tepat di viewport.  Perlu memastikan bahwa koordinat dan normals disimpan dalam buffer-G di ruang tampilan, karena semua perhitungan lebih lanjut akan dilakukan di dalamnya. <br><br><blockquote>  Ada kemungkinan untuk mengembalikan vektor posisi hanya berdasarkan kedalaman fragmen yang diketahui dan sejumlah sihir matematika, yang dijelaskan, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog</a> Matt Pettineo.  Ini, tentu saja, membutuhkan biaya perhitungan yang besar, tetapi itu menghilangkan kebutuhan untuk menyimpan data posisi dalam G-buffer, yang memakan banyak memori video.  Namun, demi kesederhanaan, kode contoh akan meninggalkan pendekatan ini untuk pembelajaran pribadi. </blockquote><br>  Tekstur buffer warna <i>gPosition</i> dikonfigurasi sebagai berikut: <br><br><pre> <code class="cpp hljs">glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;gPosition); glBindTexture(GL_TEXTURE_2D, gPosition); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</code> </pre> <br>  Tekstur ini menyimpan koordinat fragmen dan dapat digunakan untuk mendapatkan data kedalaman untuk setiap titik dari inti sampel.  Saya perhatikan bahwa tekstur menggunakan format data floating-point - ini akan memungkinkan koordinat fragmen tidak dikurangi ke interval [0., 1.].  Perhatikan juga mode pengulangan - <i>GL_CLAMP_TO_EDGE</i> diatur.  Hal ini diperlukan untuk menghilangkan kemungkinan tidak melakukan oversampling di ruang layar secara sengaja.  Melampaui interval utama koordinat tekstur akan memberi kita posisi dan kedalaman data yang salah. <br><br>  Selanjutnya, kita akan terlibat dalam pembentukan inti hemispherical sampel dan penciptaan metode orientasi acak. <br><br><h2>  Menciptakan belahan otak yang berorientasi normal </h2><br>  Jadi, tugasnya adalah untuk membuat satu set titik sampel yang terletak di dalam belahan bumi yang berorientasi sepanjang normal ke permukaan.  Karena pembuatan kernel sampel untuk semua kemungkinan arah normal secara komputasi tidak dapat dicapai, kami menggunakan transisi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ruang singgung</a> , di mana normal selalu direpresentasikan sebagai vektor ke arah semiaxis positif <i>Z.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/br/pf/3v/brpf3vfbmzd9pmna58ub5x7-age.png"></div><br>  Dengan asumsi jari-jari belahan bumi menjadi satu proses tunggal, pembentukan inti sampel 64 poin terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      0.0 - 1.0 std::uniform_real_distribution&lt;float&gt; randomFloats(0.0, 1.0); std::default_random_engine generator; std::vector&lt;glm::vec3&gt; ssaoKernel; for (unsigned int i = 0; i &lt; 64; ++i) { glm::vec3 sample( randomFloats(generator) * 2.0 - 1.0, randomFloats(generator) * 2.0 - 1.0, randomFloats(generator) ); sample = glm::normalize(sample); sample *= randomFloats(generator); float scale = (float)i / 64.0; ssaoKernel.push_back(sample); }</span></span></code> </pre> <br>  Di sini kita secara acak memilih koordinat <i>x</i> dan <i>y</i> dalam interval [-1., 1.], dan koordinat <i>z</i> dalam interval [0., 1.] (jika intervalnya sama dengan untuk <i>x</i> dan <i>y</i> , kita akan mendapatkan inti bola sampling).  Vektor sampel yang dihasilkan akan terbatas pada hemisfer, karena inti sampel pada akhirnya akan berorientasi sepanjang normal ke permukaan. <br><br>  Saat ini, semua titik sampel didistribusikan secara acak di dalam inti, tetapi demi kualitas efeknya, sampel yang berada lebih dekat ke asal kernel harus memberikan kontribusi yang lebih besar pada perhitungan koefisien shading.  Ini dapat diwujudkan dengan mengubah distribusi titik sampel yang terbentuk dengan meningkatkan kepadatannya di dekat titik asal.  Tugas ini mudah diselesaikan menggunakan fungsi interpolasi percepatan: <br><br><pre> <code class="cpp hljs">scale = lerp(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, scale * scale); sample *= scale; ssaoKernel.push_back(sample); }</code> </pre> <br>  Fungsi <i>lerp ()</i> didefinisikan sebagai: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lerp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + f * (b - a); }</code> </pre> <br>  Trik semacam itu memberi kita distribusi yang dimodifikasi, di mana sebagian besar titik sampel terletak di dekat asal kernel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h7/dy/xm/h7dyxm-1zerxg1krzbxszp7kzqi.png"></div><br>  Setiap vektor sampel yang diperoleh akan digunakan untuk menggeser koordinat fragmen dalam ruang spesies untuk mendapatkan data tentang geometri sekitarnya.  Untuk mendapatkan hasil yang layak saat bekerja di viewport, Anda mungkin perlu jumlah sampel yang mengesankan, yang pasti akan menekan kinerja.  Namun, pengenalan pseudo-random noise atau rotasi vektor sampel di setiap fragmen yang diproses akan secara signifikan mengurangi jumlah sampel yang diperlukan dengan kualitas yang sebanding. <br><br><h2>  Rotasi acak dari inti sampel </h2><br>  Jadi, memasukkan keacakan dalam distribusi titik-titik dalam inti sampel dapat secara signifikan mengurangi persyaratan jumlah titik-titik ini untuk mendapatkan efek kualitas yang layak.  Dimungkinkan untuk membuat vektor rotasi acak untuk setiap fragmen adegan, tetapi terlalu mahal dari memori.  Ini lebih efisien untuk membuat tekstur kecil yang berisi satu set vektor rotasi acak, dan kemudian hanya menggunakannya dengan <i>set</i> mode pengulangan <i>GL_REPEAT</i> . <br><br>  Buat array 4x4 dan isi dengan vektor rotasi acak yang berorientasi sepanjang vektor normal dalam ruang singgung: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;glm::vec3&gt; ssaoNoise; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; i++) { glm::<span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( randomFloats(generator) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2.0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, randomFloats(generator) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2.0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ssaoNoise.push_back(noise); }</code> </pre> <br>  Karena inti disejajarkan di sepanjang semiaxis positif <i>Z</i> dalam ruang singgung, kita membiarkan komponen <i>z</i> sama dengan nol - ini akan memastikan rotasi hanya di sekitar sumbu <i>Z.</i> <br><br>  Selanjutnya, buat tekstur 4x4 dan isi dengan array vektor rotasi kami.  Pastikan untuk menggunakan <i>mode</i> replay <i>GL_REPEAT</i> untuk ubin tekstur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> noiseTexture; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;noiseTexture); glBindTexture(GL_TEXTURE_2D, noiseTexture); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, &amp;ssaoNoise[<span class="hljs-number"><span class="hljs-number">0</span></span>]); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</code> </pre> <br>  Nah, sekarang kita memiliki semua data yang diperlukan untuk implementasi langsung dari algoritma SSAO! <br><br><h2>  Shader SSAO </h2><br>  Efek shader akan dieksekusi untuk setiap fragmen quad layar penuh, menghitung koefisien bayangan di masing-masingnya.  Karena hasilnya akan digunakan pada tahap rendering lain yang menciptakan pencahayaan akhir, kita perlu membuat objek framebuffer lain untuk menyimpan hasil shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoFBO; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoFBO); glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoColorBuffer; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoColorBuffer); glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Karena hasil dari algoritma adalah satu-satunya bilangan real dalam [0., 1.], untuk penyimpanan akan cukup untuk membuat tekstur dengan satu-satunya komponen yang tersedia.  Itulah sebabnya <i>GL_RED</i> ditetapkan sebagai format internal untuk buffer warna. <br><br>  Secara umum, proses rendering tahap SSAO terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  :  G- glBindFramebuffer(GL_FRAMEBUFFER, gBuffer); [...] glBindFramebuffer(GL_FRAMEBUFFER, 0); //  G-      SSAO glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO); glClear(GL_COLOR_BUFFER_BIT); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, gPosition); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, gNormal); glActiveTexture(GL_TEXTURE2); glBindTexture(GL_TEXTURE_2D, noiseTexture); shaderSSAO.use(); SendKernelSamplesToShader(); shaderSSAO.setMat4("projection", projection); RenderQuad(); glBindFramebuffer(GL_FRAMEBUFFER, 0); //  :    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); shaderLightingPass.use(); [...] glActiveTexture(GL_TEXTURE3); glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer); [...] RenderQuad();</span></span></code> </pre> <br>  <i>ShaderSSAO</i> shader menerima tekstur buffer-G yang dibutuhkan sebagai input, serta tekstur noise dan inti sampel: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out float FragColor; in vec2 TexCoords; uniform sampler2D gPosition; uniform sampler2D gNormal; uniform sampler2D texNoise; uniform vec3 samples[64]; uniform mat4 projection; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//             //      1280x720 const vec2 noiseScale = vec2(1280.0/4.0, 720.0/4.0); void main() { [...] }</span></span></span></span></code> </pre> <br>  Perhatikan variabel <i>noiseScale</i> .  Tekstur kecil kami dengan noise harus dipasang di seluruh permukaan layar, tetapi karena koordinat tekstur <i>TexCoords berada</i> dalam [0., 1.] ini tidak akan terjadi tanpa campur tangan kami.  Untuk keperluan ini, kami menghitung faktor untuk koordinat tekstur, yang ditemukan sebagai rasio ukuran layar dengan ukuran tekstur noise: <br><br><pre> <code class="cpp hljs">vec3 fragPos = texture(gPosition, TexCoords).xyz; vec3 normal = texture(gNormal, TexCoords).rgb; vec3 randomVec = texture(texNoise, TexCoords * noiseScale).xyz;</code> </pre> <br>  Karena ketika membuat tekstur noise <i>texNoise</i> kami mengatur mode repeat ke <i>GL_REPEAT</i> , sekarang akan diulang berkali-kali pada permukaan layar.  Dengan <i>randomVec</i> , <i>fragPos,</i> dan nilai <i>normal</i> , kami dapat membuat matriks transformasi TBN dari garis singgung ke ruang spesies: <br><br><pre> <code class="cpp hljs">vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal)); vec3 bitangent = cross(normal, tangent); mat3 TBN = mat3(tangent, bitangent, normal);</code> </pre> <br>  Menggunakan proses Gram-Schmidt, kami membuat basis ortogonal yang dimiringkan secara acak di setiap fragmen berdasarkan nilai acak <i>randomVec</i> .  Poin penting: karena dalam kasus ini tidak masalah bagi kami bahwa matriks TBN berorientasi tepat di sepanjang permukaan segitiga (seperti dalam kasus dengan paralaks pemetaan, kira-kira Per.), Maka kita tidak perlu data tangen dan bi-tangen yang telah dihitung sebelumnya. <br><br>  Selanjutnya, kita pergi melalui array dari inti sampel, menerjemahkan setiap vektor sampel dari ruang singgung ke ruang spesies dan mendapatkan jumlahnya dengan posisi fragmen saat ini.  Kemudian kita membandingkan nilai kedalaman dari jumlah yang dihasilkan dengan nilai kedalaman yang diperoleh dengan mengambil sampel dari tekstur buffer-G yang sesuai. <br><br>  Meskipun terdengar membingungkan, mari kita ikuti langkah-langkahnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> occlusion = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; kernelSize; ++i) { <span class="hljs-comment"><span class="hljs-comment">//     vec3 sample = TBN * samples[i]; //      - sample = fragPos + sample * radius; [...] }</span></span></code> </pre> <br>  Di sini, <i>kernelSize</i> dan <i>radius</i> adalah variabel yang mengontrol karakteristik efek.  Dalam hal ini, mereka masing-masing adalah 64 dan 0,5.  Pada setiap iterasi, kami menerjemahkan vektor inti sampel ke dalam ruang spesies.  Selanjutnya, kami menambah nilai yang diperoleh dari perpindahan sampel di ruang spesies nilai posisi fragmen di ruang spesies.  Dalam hal ini, nilai offset dikalikan dengan variabel radius, yang mengontrol jari-jari inti sampel efek SSAO. <br><br>  Setelah langkah-langkah ini, kita harus mengubah vektor <i>sampel yang</i> dihasilkan menjadi ruang layar, sehingga kita dapat memilih dari tekstur buffer-G yang menyimpan posisi dan kedalaman fragmen menggunakan nilai proyeksi yang diperoleh.  Karena <i>sampel</i> ada di viewport, kita memerlukan matriks proyeksi <i>proyeksi</i> : <br><br><pre> <code class="cpp hljs">vec4 offset = vec4(sample, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); offset = projection * offset; <span class="hljs-comment"><span class="hljs-comment">//     offset.xyz /= offset.w; //   offset.xyz = offset.xyz * 0.5 + 0.5; //    [0., 1.]</span></span></code> </pre> <br>  Setelah konversi ke ruang klip, kami secara manual melakukan pembagian perspektif dengan hanya membagi komponen <i>xyz</i> dengan komponen <i>w</i> .  Vektor yang dihasilkan dalam koordinat perangkat dinormalisasi ( <i>NDC</i> ) diterjemahkan ke dalam interval nilai [0., 1.] sehingga dapat digunakan sebagai koordinat tekstur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sampleDepth = texture(gPosition, offset.xy).z;</code> </pre> <br>  Kami menggunakan komponen <i>xy</i> dari vektor <i>sampel</i> untuk memilih dari tekstur posisi buffer-G.  Kami mendapatkan nilai kedalaman (komponen <i>z</i> ) yang sesuai dengan vektor sampel ketika dilihat dari posisi pengamat (ini adalah fragmen terlihat unshielded pertama).  Jika pada saat yang sama kedalaman pengambilan sampel yang diperoleh lebih besar dari kedalaman yang disimpan, maka kami meningkatkan koefisien naungan: <br><br><pre> <code class="cpp hljs">occlusion += (sampleDepth &gt;= sample.z + bias ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>);</code> </pre> <br>  Perhatikan offset <i>bias</i> , yang ditambahkan ke kedalaman fragmen asli (atur dalam contoh ke 0,025).  Offset ini tidak selalu diperlukan, tetapi keberadaan variabel memungkinkan Anda untuk mengontrol bagaimana efek SSAO terlihat, dan juga, dalam situasi tertentu, menghilangkan masalah dengan riak di area yang diarsir. <br><br>  Tapi ini tidak semua, karena implementasi seperti itu mengarah pada artefak yang terlihat.  Ini memanifestasikan dirinya dalam kasus-kasus ketika sebuah fragmen yang terletak di dekat tepi permukaan tertentu dipertimbangkan.  Dalam situasi seperti itu, ketika membandingkan kedalaman, algoritma pasti akan menangkap kedalaman permukaan, yang dapat terletak sangat jauh di belakang yang dianggap.  Di tempat-tempat ini, algoritma secara keliru akan sangat meningkatkan tingkat bayangan, yang akan menciptakan lingkaran cahaya gelap yang terlihat di tepi objek.  Artefak diperlakukan dengan memperkenalkan pemeriksaan jarak tambahan (contoh oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">John Chapman</a> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/yv/eq/zvyveqh3zc_rjcy6fo-z8d76eme.png"></div><br>  Pemeriksaan akan membatasi kontribusi pada koefisien naungan hanya untuk nilai kedalaman yang berada dalam radius sampel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rangeCheck = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, radius / <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(fragPos.z - sampleDepth)); occlusion += (sampleDepth &gt;= sample.z + bias ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>) * rangeCheck;</code> </pre> <br>  Kami juga menggunakan fungsi GLSL <i>smoothstep ()</i> , yang mengimplementasikan interpolasi halus dari parameter ketiga antara yang pertama dan yang kedua.  Pada saat yang sama, mengembalikan 0 jika parameter ketiga kurang dari atau sama dengan yang pertama, atau 1 jika parameter ketiga lebih besar atau sama dengan yang kedua.  Jika perbedaan kedalaman berada dalam <i>radius</i> , maka nilainya akan dihaluskan dengan lancar dalam interval [0., 1.] sesuai dengan kurva ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jq/9h/p4/jq9hp4-yun_sc277m6pslbjyin0.png"></div><br>  Jika kita menggunakan batas yang jelas dalam kondisi memeriksa kedalaman, ini akan menambah artefak dalam bentuk batas tajam di tempat-tempat di mana nilai perbedaan kedalaman berada di luar batas <i>radius</i> . <br><br>  Dengan sentuhan akhir, kami menormalkan nilai koefisien naungan menggunakan ukuran inti sampel dan mencatat hasilnya.  Kami juga membalikkan nilai akhir dengan menguranginya dari kesatuan, sehingga Anda dapat menggunakan nilai akhir secara langsung untuk memodulasi komponen latar belakang pencahayaan tanpa langkah-langkah tambahan: <br><br><pre> <code class="cpp hljs">} occlusion = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - (occlusion / kernelSize); FragColor = occlusion;</code> </pre> <br>  Untuk adegan dengan nanosuit berbaring yang familier bagi kami, melakukan SSAO shader memberikan tekstur berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-z/a4/fx/-za4fxhsbref6easc-cgxnsp94q.png"></div><br>  Seperti yang Anda lihat, efek bayangan latar belakang menciptakan ilusi kedalaman yang bagus.  Hanya gambar keluaran shader yang sudah memungkinkan Anda untuk membedakan detail kostum dan memastikan bahwa itu benar-benar terletak di lantai, dan tidak melayang agak jauh darinya. <br><br>  Namun demikian, efeknya jauh dari ideal, karena pola kebisingan yang diperkenalkan oleh tekstur vektor rotasi acak mudah terlihat.  Untuk memperlancar hasil perhitungan SSAO, kami menerapkan filter blur. <br><br><h2>  Mengaburkan bayangan latar belakang </h2><br>  Setelah membangun hasil SSAO dan sebelum pencampuran akhir pencahayaan, perlu untuk mengaburkan tekstur yang menyimpan data pada koefisien naungan.  Untuk melakukan ini, kita akan memiliki framebuffer lain: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoBlurFBO, ssaoColorBufferBlur; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoBlurFBO); glBindFramebuffer(GL_FRAMEBUFFER, ssaoBlurFBO); glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoColorBufferBlur); glBindTexture(GL_TEXTURE_2D, ssaoColorBufferBlur); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBufferBlur, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Ubin tekstur noise di ruang layar memberikan karakteristik keacakan yang jelas yang dapat Anda gunakan untuk keuntungan Anda saat membuat filter blur: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out float FragColor; in vec2 TexCoords; uniform sampler2D ssaoInput; void main() { vec2 texelSize = 1.0 / vec2(textureSize(ssaoInput, 0)); float result = 0.0; for (int x = -2; x &lt; 2; ++x) { for (int y = -2; y &lt; 2; ++y) { vec2 offset = vec2(float(x), float(y)) * texelSize; result += texture(ssaoInput, TexCoords + offset).r; } } FragColor = result / (4.0 * 4.0); }</span></span></code> </pre> <br>  Shader hanya mentransisikan texels dari tekstur SSAO dengan offset dari -2 ke +2, yang sesuai dengan ukuran aktual dari noise noise.  Offset sama dengan ukuran tepat satu texel: fungsi teksturSize <i>()</i> digunakan untuk perhitungan, yang mengembalikan <i>vec2</i> dengan dimensi tekstur yang ditentukan.  T.O.  Shader hanya rata-rata hasil yang disimpan dalam tekstur, yang memberikan blur cepat dan cukup efektif: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/0g/i7/5p0gi7qn_v5w738uyindxexally.png"></div><br>  Secara total, kami memiliki tekstur dengan data bayangan latar belakang untuk setiap fragmen di layar - semuanya siap untuk tahap pengurangan gambar akhir! <br><br><h2>  Terapkan Background Shading </h2><br>  Langkah penerapan koefisien naungan dalam perhitungan akhir pencahayaan sangat sederhana: untuk setiap fragmen, cukup dengan melipatgandakan nilai komponen latar belakang sumber cahaya dengan koefisien naungan dari tekstur yang disiapkan.  Anda dapat mengambil shader yang sudah jadi dengan model Blinn-Fong dari pelajaran tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">naungan yang ditangguhkan</a> dan sedikit memperbaikinya: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D gPosition; uniform sampler2D gNormal; uniform sampler2D gAlbedo; uniform sampler2D ssao; struct Light { vec3 Position; vec3 Color; float Linear; float Quadratic; float Radius; }; uniform Light light; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    G- vec3 FragPos = texture(gPosition, TexCoords).rgb; vec3 Normal = texture(gNormal, TexCoords).rgb; vec3 Diffuse = texture(gAlbedo, TexCoords).rgb; float AmbientOcclusion = texture(ssao, TexCoords).r; //   -    //   :   -  vec3 ambient = vec3(0.3 * Diffuse * AmbientOcclusion); vec3 lighting = ambient; //    (0, 0, 0)   - vec3 viewDir = normalize(-FragPos); //   vec3 lightDir = normalize(light.Position - FragPos); vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * light.Color; //   vec3 halfwayDir = normalize(lightDir + viewDir); float spec = pow(max(dot(Normal, halfwayDir), 0.0), 8.0); vec3 specular = light.Color * spec; //   float dist = length(light.Position - FragPos); float attenuation = 1.0 / (1.0 + light.Linear * dist + light.Quadratic * dist * dist); diffuse *= attenuation; specular *= attenuation; lighting += diffuse + specular; FragColor = vec4(lighting, 1.0); }</span></span></span></span></code> </pre> <br>  Hanya ada dua perubahan besar: transisi ke perhitungan di viewport dan penggandaan komponen pencahayaan latar belakang dengan nilai <i>AmbientOcclusion</i> .  Contoh pemandangan dengan cahaya titik biru tunggal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bz/8_/1i/bz8_1in-othscilg_udfyscghg0.png"></div><br>  Kode sumber lengkap ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Manifestasi dari efek SSAO sangat tergantung pada parameter seperti <i>kernelSize</i> , <i>radius</i> dan <i>bias</i> , yang sering kali fine-tuning mereka adalah masalah bagi artis untuk mencari lokasi / adegan tertentu.  Tidak ada kombinasi parameter "terbaik" dan universal: untuk beberapa adegan, jari-jari kecil inti sampel baik, sementara yang lain mendapat manfaat dari peningkatan jari-jari dan jumlah sampel.  Contoh ini menggunakan 64 titik sampel, yang, terus terang, berlebihan, tetapi Anda selalu dapat mengedit kode dan melihat apa yang terjadi dengan jumlah sampel yang lebih sedikit. <br><br>  Selain seragam yang terdaftar yang bertanggung jawab untuk mengatur efek, ada kemungkinan untuk secara eksplisit mengontrol tingkat keparahan efek bayangan latar belakang.  Untuk melakukan ini, cukup menaikkan koefisien ke tingkat yang dikendalikan oleh seragam lain: <br><br><pre> <code class="cpp hljs">occlusion = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - (occlusion / kernelSize); FragColor = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(occlusion, power);</code> </pre> <br>  Saya menyarankan Anda untuk meluangkan waktu pada permainan dengan pengaturan, karena ini akan memberikan pemahaman yang lebih baik tentang sifat perubahan dalam gambar akhir. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk meringkas, perlu dikatakan bahwa meskipun efek visual dari penerapan SSAO agak halus, dalam adegan dengan pencahayaan yang ditempatkan dengan baik itu tidak dapat disangkal menambahkan sebagian kecil dari realisme. </font><font style="vertical-align: inherit;">Memiliki alat seperti itu di gudang senjata Anda tentu berharga.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sumber Daya Tambahan </font></font></h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial SSAO</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Artikel pelajaran yang sangat bagus dari John Chapman, yang menjadi dasar dibangunnya kode untuk pelajaran ini.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketahui artefak SSAO Anda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Artikel yang sangat berharga dengan jelas menunjukkan tidak hanya masalah paling mendesak dengan kualitas SSAO, tetapi juga cara untuk menyelesaikannya. </font><font style="vertical-align: inherit;">Bacaan yang disarankan.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSAO Dengan Rekonstruksi Kedalaman</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Tambahan pada pelajaran SSAO utama oleh OGLDev mengenai teknik yang biasa digunakan untuk mengembalikan koordinat fragmen berdasarkan kedalaman. </font><font style="vertical-align: inherit;">Pentingnya pendekatan ini adalah karena penghematan memori yang signifikan karena kurangnya kebutuhan untuk menyimpan posisi dalam buffer-G. </font><font style="vertical-align: inherit;">Pendekatannya sangat universal, itu berlaku untuk SSAO sejauh.</font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Kami punya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">telegram conf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk koordinasi transfer. </font><font style="vertical-align: inherit;">Jika Anda memiliki keinginan serius untuk membantu penerjemahan, silakan!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421385/">https://habr.com/ru/post/id421385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421373/index.html">Python membuat pemrograman tersedia untuk khalayak luas</a></li>
<li><a href="../id421375/index.html">Bagaimana ketidakpastian membunuh perdagangan</a></li>
<li><a href="../id421377/index.html">7 kesalahpahaman tentang manajer proyek pemula di gamedev</a></li>
<li><a href="../id421379/index.html">Budaya beracun Intel</a></li>
<li><a href="../id421381/index.html">Kursus Gratis Administrator ASA Cisco</a></li>
<li><a href="../id421387/index.html">Wawancara dengan Lennart Pottering di Linux Piter tentang perubahan di Linux, tentang systemd dan mengapa menghadiri konferensi</a></li>
<li><a href="../id421389/index.html">Pemisahan kekuatan administratif di Zimbra</a></li>
<li><a href="../id421391/index.html">HackThings - hackathon besar di Internet hal 7-9 September di Skoltech</a></li>
<li><a href="../id421393/index.html">Keranjang Mailchimp yang Ditinggalkan: Panduan untuk Malas</a></li>
<li><a href="../id421395/index.html">Laporan Club of Rome 2018, Bab 3.7: "Iklim: kabar baik, tetapi masalah besar"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>