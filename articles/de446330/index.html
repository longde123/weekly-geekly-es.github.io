<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìë ‚èèÔ∏è ‚ôªÔ∏è Automatische Maschinen gegen Spaghetti-Code üéÖüèæ üîä ‚òòÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Ich liebe Spaghetti-Western, ich hasse Spaghetti-Code" 

 Der ‚ÄûSpaghetti-Code‚Äú ist ein idealer Ausdruck f√ºr die Beschreibung von Software, die sowohl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatische Maschinen gegen Spaghetti-Code</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446330/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/049/15b/078/04915b0789f8de5be2bc6950b3265a8a.png"></div><br>  <i>"Ich liebe Spaghetti-Western, ich hasse Spaghetti-Code"</i> <br><br>  Der ‚ÄûSpaghetti-Code‚Äú ist ein idealer Ausdruck f√ºr die Beschreibung von Software, die sowohl aus kognitiver als auch aus √§sthetischer Sicht ein dampfendes Chaos darstellt.  In diesem Artikel werde ich √ºber einen Drei-Punkte-Plan zur Zerst√∂rung eines Spaghetti-Codes sprechen: <br><br><ul><li>  Wir diskutieren, warum der Spaghetti-Code nicht so lecker ist. </li><li>  Einf√ºhrung eines neuen Blicks auf die tats√§chliche Funktionsweise des Codes. </li><li>  Wir diskutieren die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Frame Machine Notation (FMN)</a> , mit der Entwickler einen Pastenball entwirren k√∂nnen. </li></ul><br>  Wir alle wissen, wie schwierig es ist, den Code eines anderen zu lesen.  Dies kann daran liegen, dass die Aufgabe selbst schwierig ist oder dass die Struktur des Codes zu ... "kreativ" ist.  Oft gehen diese beiden Probleme Hand in Hand. <br><br>  Herausforderungen sind schwierige Aufgaben, und normalerweise kann nichts als eine revolution√§re Entdeckung sie vereinfachen.  Es kommt jedoch vor, dass die Softwarestruktur selbst unn√∂tige Komplexit√§t hinzuf√ºgt, und dieses Problem ist es <em>wert,</em> gel√∂st zu werden. <br><br>  Die H√§sslichkeit des Spaghetti-Codes liegt in seiner komplexen bedingten Logik.  Und obwohl das Leben ohne die vielen kniffligen Wenn-Dann-Sonst-Konstrukte schwer vorstellbar ist, zeigt Ihnen dieser Artikel eine bessere L√∂sung. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6cc/af0/c3c/6ccaf0c3c57a472e1eb5b80a238a86c5.png"></div><br>  Um die Situation mit Spaghetti-Code zu veranschaulichen, m√ºssen wir zuerst Folgendes drehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/eac/43c/cf9eac43c588d9fecbbfc9bf15753ee1.jpg"></div><br>  <i>Knusprige Pasta</i> <br><br>  In diesem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/683/f12/7fc683f12aa20bcf4abcf5a774c7a039.jpg"></div><br>  <i>Al dente!</i> <br><br>  Lass uns anfangen zu kochen. <br><br><h3>  Impliziter Zustand </h3><br>  Um Pasta zu machen, brauchen wir definitiv Wasser zum Kochen.  Selbst ein scheinbar einfaches Element mit Spaghetti-Code kann jedoch sehr verwirrend sein. <br><br>  Hier ist ein einfaches Beispiel: <br><br><pre><code class="cpp hljs">(temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>)</code> </pre> <br>  Was macht diese Pr√ºfung wirklich?  Nat√ºrlich teilt es die Zahlenlinie in zwei Teile, aber was <em>bedeuten</em> diese Teile?  Ich denke, Sie k√∂nnen eine logische Annahme treffen, aber das Problem ist, dass der Code dies nicht <em>explizit</em> kommuniziert. <br><br>  Wenn ich wirklich best√§tige, dass sie pr√ºft, ob das Wasser FEST ist <i>[ca.</i>  <i>Spur: Laut der Fahrenheit-Skala gefriert das Wasser bei +32 Grad</i> . Was bedeutet logischerweise, dass die R√ºckgabe falsch ist? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SOLID water } else { // not SOLID water. is (LIQUID | GAS) }</span></span></code> </pre> <br>  Obwohl die Pr√ºfung die Zahlen in zwei Gruppen unterteilt hat, gibt es tats√§chlich drei logische Zust√§nde - fest, fl√ºssig und gasf√∂rmig (FEST, FL√úSSIG, GAS)! <br><br>  Das hei√üt, diese Zahlenreihe: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fad/b04/343/fadb04343c512bbf297dbf17a250d742.png"></div><br>  Aufteilung nach Bedingungspr√ºfung wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/e83/2cc/56ae832ccebc547053d46dec39993ec3.png"></div><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/dcf/20d/a55dcf20d2de1f679a233913c045546f.png"></div><br><pre> <code class="cpp hljs">}</code> </pre> <br>  Beachten Sie, was passiert ist, da dies f√ºr das Verst√§ndnis der Art des Spaghetti-Codes sehr wichtig ist.  Eine boolesche Pr√ºfung teilte den Zahlenraum in zwei Teile, kategorisierte das System jedoch NICHT als echte logische Struktur aus (SOLID, LIQUID, GAS).  Stattdessen teilte die Pr√ºfung den Raum in (SOLID, alles andere). <br><br>  Hier ist eine √§hnliche Pr√ºfung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt; <span class="hljs-number"><span class="hljs-number">212</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// GAS water } else { // not GAS water. is (SOLID | LIQUID) }</span></span></code> </pre> <br>  Optisch sieht es so aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt; <span class="hljs-number"><span class="hljs-number">212</span></span>) {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/127/810/51d127810231b42191868d0972e3865f.png"></div><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42a/187/bd4/42a187bd4559e2dfa9e6acffcd24c8b2.png"></div><br><pre> <code class="cpp hljs">}</code> </pre> <br>  Beachten Sie Folgendes: <br><br><ol><li>  Der vollst√§ndige Satz m√∂glicher Zust√§nde wird nirgendwo angek√ºndigt </li><li>  Nirgendwo in bedingten Konstrukten werden √ºberpr√ºfbare logische Zust√§nde oder Gruppen von Zust√§nden deklariert </li><li>  Einige Zust√§nde werden indirekt nach der Struktur der bedingten Logik und der Verzweigung gruppiert </li></ol><br>  Ein solcher Code ist fragil, aber sehr verbreitet und nicht so gro√ü, dass er Probleme mit seiner Unterst√ºtzung verursacht.  Machen wir die Situation noch schlimmer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/852/bd5/7a1/852bd57a151d005a34ddd883aea5d1ab.png"></div><br>  <i>Ich habe deinen Code sowieso nie gemocht</i> <br><br>  Der oben gezeigte Code impliziert die Existenz von drei Materiezust√§nden - FEST, FL√úSSIG, GAS.  Wissenschaftlichen Daten zufolge gibt es jedoch tats√§chlich <strong><em>vier</em></strong> beobachtbare Zust√§nde, in denen Plasma (PLASMA) enthalten ist (tats√§chlich gibt es viele andere, aber dies wird f√ºr uns ausreichen).  Obwohl niemand eine Paste aus Plasma herstellt, m√ºssen wir diesen Zustand auch beibehalten, wenn dieser Code auf Github ver√∂ffentlicht wird und dann von einem Doktoranden, der Hochenergiephysik studiert, gegabelt wird. <br><br>  Wenn jedoch Plasma hinzugef√ºgt wird, f√ºhrt der oben gezeigte Code naiv Folgendes aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SOLID water } else { // not SOLID water. is (LIQUID | GAS) + (PLASMA?) // how did PLASMA get in here?? } if (temp &gt; 212) { // GAS water + (PLASMA) // again with the PLASMA!! } else { // not GAS water. is (SOLID | LIQUID) }</span></span></code> </pre> <br>  Es ist wahrscheinlich, dass der alte Code, wenn er zu vielen Plasmazust√§nden hinzugef√ºgt wird, in den Zweigen else bricht.  Leider hilft nichts in der Codestruktur, das Vorhandensein eines neuen Zustands zu melden oder √Ñnderungen zu beeinflussen.  Dar√ºber hinaus sind Fehler wahrscheinlich unauff√§llig, dh es ist am schwierigsten, sie zu finden.  Sag einfach nein zu den Insekten in den Spaghetti. <br><br>  Kurz gesagt, das Problem ist folgendes: Boolesche Pr√ºfungen werden verwendet, um Zust√§nde <em>indirekt</em> zu bestimmen.  Logische Zust√§nde werden oft nicht deklariert und sind im Code nicht sichtbar.  Wie wir oben gesehen haben, kann vorhandener Code besch√§digt werden, wenn das System neue logische Zust√§nde hinzuf√ºgt.  Um dies zu vermeiden, <strong>sollten Entwickler jede einzelne bedingte Pr√ºfung und Verzweigung erneut √ºberpr√ºfen,</strong> um sicherzustellen, dass die Codepfade f√ºr <em>alle</em> ihre logischen Zust√§nde weiterhin g√ºltig sind!  Dies ist der Hauptgrund f√ºr die Verschlechterung gro√üer Codefragmente, wenn diese komplexer werden. <br><br>  Obwohl es keine M√∂glichkeiten gibt, bedingte Datenpr√ºfungen vollst√§ndig zu beseitigen, verringert jede Technik, die sie minimiert, die Codekomplexit√§t. <br><br>  Schauen wir uns nun eine typische objektorientierte Implementierung einer Klasse an, die ein <em>sehr</em> einfaches Modell des Wasservolumens erstellt.  Die Klasse wird √Ñnderungen im Zustand der Wassersubstanz verwalten.  Nachdem wir die Probleme der klassischen L√∂sung dieses Problems untersucht haben, diskutieren wir eine neue Notation namens <strong>Frame</strong> und zeigen, wie sie mit den entdeckten Schwierigkeiten umgehen kann. <br><br><h3>  Zuerst das Wasser zum Kochen bringen ... </h3><br>  Die Wissenschaft gab allen m√∂glichen √úberg√§ngen Namen, die eine Substanz machen kann, wenn sich die Temperatur √§ndert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/016/dc5/638016dc5b2a19ecd2b677cc40e2ee26.png"></div><br>  Unsere Klasse ist sehr einfach (und nicht besonders n√ºtzlich).  Es beantwortet die Herausforderungen beim Durchf√ºhren von √úberg√§ngen zwischen Zust√§nden und √§ndert die Temperatur, bis sie f√ºr den gew√ºnschten Zielzustand geeignet ist: <br><br>  (Hinweis: Ich habe diesen Pseudocode geschrieben. Verwenden Sie ihn in Ihrer Arbeit nur auf eigene Gefahr und Gefahr.) <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaterSample</span></span></span><span class="hljs-class"> {</span></span> temp:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Water</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(temp:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.temp = temp } <span class="hljs-comment"><span class="hljs-comment">// gas -&gt; solid func depose() { // If not in GAS state, throw an error if (temp &lt; WATER_GAS_TEMP) throw new IllegalStateError() // do depose while (temp &gt; WATER_SOLID_TEMP) decreaseTemp(1) } // gas -&gt; liquid func condense() { // If not in GAS state, throw an error if (temp &lt; WATER_GAS_TEMP) throw new IllegalStateError() // do condense while (temp &gt; WATER_GAS_TEMP) decreaseTemp(1) } // liquid -&gt; gas func vaporize() { // If not in LIQUID state, throw an error if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError() // do vaporize while (temp &lt; WATER_GAS_TEMP) increaseTemp(1) } // liquid -&gt; solid func freeze() { // If not in LIQUID state, throw an error if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError() // do freeze while (temp &gt; WATER_SOLID_TEMP) decreaseTemp(1) } // solid -&gt; liquid func melt() { // If not in SOLID state, throw an error if (temp &gt; WATER_SOLID_TEMP) throw new IllegalStateError() // do melt while (temp &lt; WATER_SOLID_TEMP) increaseTemp(1) } // solid -&gt; gas func sublimate() { // If not in SOLID state, throw an error if (temp &gt; WATER_SOLID_TEMP) throw new IllegalStateError() // do sublimate while (temp &lt; WATER_GAS_TEMP) increaseTemp(1) } func getState():string { if (temp &lt; WATER_SOLID_TEMP) return "SOLID" if (temp &gt; WATER_GAS_TEMP) return "GAS" return "LIQUID" } }</span></span></code> </pre> <br>  Im Vergleich zum ersten Beispiel weist dieser Code bestimmte Verbesserungen auf.  Zun√§chst werden die fest codierten ‚Äûmagischen‚Äú Zahlen (32, 212) durch die Konstanten der Zustandstemperaturgrenzen (WATER_SOLID_TEMP, WATER_GAS_TEMP) ersetzt.  Diese √Ñnderung beginnt, Staaten expliziter zu machen, wenn auch indirekt. <br><br>  In diesem Code werden auch √úberpr√ºfungen auf "defensive Programmierung" angezeigt, die den Methodenaufruf einschr√§nken, wenn er sich f√ºr die Operation in einem ungeeigneten Zustand befindet.  Zum Beispiel kann Wasser nicht gefrieren, wenn es keine Fl√ºssigkeit ist - dies verst√∂√üt gegen das Naturgesetz.  Das Hinzuf√ºgen von Watchdog-Bedingungen erschwert jedoch das Verst√§ndnis des Zwecks des Codes.  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// liquid -&gt; solid if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError()</span></span></code> </pre> <br>  Diese bedingte Pr√ºfung f√ºhrt Folgendes aus: <br><br><ol><li>  √úberpr√ºft, ob die Temperatur unter der GAS-Grenztemperatur liegt </li><li>  √úberpr√ºft, ob die Temperatur die SOLID-Grenztemperatur √ºberschreitet </li><li>  Gibt einen Fehler zur√ºck, wenn eine dieser Pr√ºfungen nicht wahr ist </li></ol><br>  Diese Logik ist verwirrend.  Erstens wird der fl√ºssige Zustand dadurch bestimmt, was die Substanz <strong>nicht ist</strong> - ein Feststoff oder ein Gas. <br><br><pre> <code class="cpp hljs">(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-comment"><span class="hljs-comment">// is liquid?</span></span></code> </pre> <br>  Zweitens pr√ºft der Code, ob das Wasser fl√ºssig ist, um festzustellen, ob ein Fehler zur√ºckgegeben werden muss. <br><br><pre> <code class="cpp hljs">!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-comment"><span class="hljs-comment">// Seriously?</span></span></code> </pre> <br>  Das erste Mal, diese doppelte Negation von Zust√§nden zu verstehen, ist nicht einfach.  Hier ist eine Vereinfachung, die die Komplexit√§t des Ausdrucks geringf√ºgig verringert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isLiquidWater = (temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLiquidWater) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateError()</code> </pre> <br>  Dieser Code ist leichter zu verstehen, da der <strong>Status isLiquidWater</strong> <em>explizit ist</em> . <br><br>  Jetzt untersuchen wir Techniken, die einen <strong>expliziten Zustand</strong> festlegen, um Probleme am besten zu l√∂sen.  Bei diesem Ansatz werden die logischen Zust√§nde des Systems zur physischen Struktur der Software, was den Code verbessert und sein Verst√§ndnis vereinfacht. <br><br><h3>  Frame Machine Notation </h3><br>  <strong>Frame Machine Notation (FMN)</strong> ist eine dom√§nenspezifische Sprache (DSL), die einen kategorialen, methodischen und einfachen Ansatz zum Definieren und Implementieren verschiedener <em>Maschinentypen definiert</em> .  Der Einfachheit halber werde ich Frame-Automaten einfach "Maschinen" nennen, da diese Notation theoretische Kriterien f√ºr verschiedene Typen definieren kann (Zustandsmaschinen, Gesch√§ftsautomaten und die Top-Entwicklung von Automaten - Turing-Maschinen).  Um mehr √ºber die verschiedenen Maschinentypen und ihre Anwendung zu erfahren, empfehle ich, die Seite auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Wikipedia</a> zu studieren. <br><br>  Obwohl die Automatentheorie interessant sein mag (eine SEHR zweifelhafte Aussage), konzentrieren wir uns in diesem Artikel auf die praktische Anwendung dieser leistungsstarken Konzepte zum Erstellen von Systemen und zum Schreiben von Code. <br><br>  Um dieses Problem zu l√∂sen, f√ºhrt Frame eine standardisierte Notation ein, die auf drei integrierten Ebenen funktioniert: <br><br><ol><li>  Text-DSL zum Definieren von Frame-Controllern mit eleganter und pr√§ziser Syntax </li><li>  Eine Reihe von Referenzcodierungsmustern zum Implementieren objektorientierter Klassen in Form von Maschinen, die Frame als "Controller" bezeichnet. </li><li>  Visuelle Notation, in der FMN verwendet wird, um komplexe Operationen auszudr√ºcken, die schwer grafisch darzustellen sind - <strong>Frame Visual Notation (FVN)</strong> </li></ol><br>  In diesem Artikel werde ich die ersten beiden Punkte betrachten: FMN und Referenzmuster, und ich werde die Diskussion √ºber FVN f√ºr zuk√ºnftige Artikel verlassen. <br><br>  Frame ist eine Notation, die mehrere wichtige Aspekte hat: <br><br><ol><li>  FMN verf√ºgt √ºber Objekte der ersten Ebene im Zusammenhang mit dem Konzept von Automaten, die in objektorientierten Sprachen nicht verf√ºgbar sind. </li><li>  Die FMN-Spezifikation definiert Standardimplementierungsmuster im Pseudocode, die zeigen, wie die FMN-Notation implementiert werden kann. </li><li>  FMN wird in K√ºrze in jeder objektorientierten Sprache kompilieren (in Arbeit) sein k√∂nnen </li></ol><br>  Hinweis: Die Referenzimplementierung wird verwendet, um die absolute √Ñquivalenz der FMN-Notation zu demonstrieren und eine einfache M√∂glichkeit, sie in einer objektorientierten Sprache zu implementieren.  Sie k√∂nnen eine beliebige Methode ausw√§hlen. <br><br>  Jetzt werde ich Ihnen die beiden wichtigsten Objekte der ersten Ebene in Frame vorstellen - <strong>Frame Events</strong> und <strong>Frame Controller</strong> . <br><br><h3>  Rahmenereignisse </h3><br>  FrameEvents sind ein wesentlicher Bestandteil der Einfachheit der FMN-Notation.  Ein FrameEvent wird als Struktur oder Klasse implementiert, die mindestens die folgenden Elementvariablen enth√§lt: <br><br><ul><li>  Nachrichten-ID </li><li>  W√∂rterbuch oder Parameterliste </li><li>  Objekt zur√ºckgeben </li></ul><br>  Hier ist der Pseudocode der FrameEvent-Klasse: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FrameEvent</span></span></span><span class="hljs-class"> {</span></span> var _msg:String var _params:Object var _return:<span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FrameEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg:String, params:Object = null)</span></span></span><span class="hljs-function"> </span></span>{ _msg = msg _params = params } }</code> </pre> <br>  Die Frame-Notation verwendet das <strong>@</strong> -Symbol, das das FrameEvent-Objekt identifiziert.  Jedes der erforderlichen FrameEvent-Attribute verf√ºgt √ºber ein spezielles Token, um darauf zuzugreifen: <br><br><pre> <code class="cpp hljs">@|message| :  -    _msg @[param1] :  []      @^ :              _return</code> </pre> <br>  Oft m√ºssen wir nicht angeben, mit was FrameEvent funktioniert.  Da die meisten Kontexte jeweils nur mit einem FrameEvent arbeiten, kann die Notation definitiv vereinfacht werden, sodass nur Attributselektoren verwendet werden.  Daher k√∂nnen wir den Zugriff vereinfachen: <br><br><pre> <code class="cpp hljs">|buttonClick| <span class="hljs-comment"><span class="hljs-comment">// Select for a "buttonClick" event _msg [firstName] = "Mark" // Set firstName _params property to "Mark" ^ = "YES" // Set the _return object to "YES"</span></span></code> </pre> <br>  Eine solche Notation mag zun√§chst seltsam erscheinen, aber bald werden wir sehen, wie eine so einfache Syntax f√ºr Ereignisse das Verst√§ndnis des FMN-Codes erheblich vereinfacht. <br><br><h3>  Frame Controller </h3><br>  Ein Frame Controller ist eine objektorientierte Klasse, die genau definiert angeordnet ist, um eine Frame-Maschine zu implementieren.  Controller-Typen werden durch das Pr√§fix <strong># gekennzeichnet</strong> : <br><br><pre> <code class="cpp hljs">#MyController</code> </pre> <br>  Dies entspricht dem folgenden objektorientierten Pseudocode: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span>}</code> </pre> <br>  Offensichtlich ist diese Klasse nicht besonders n√ºtzlich.  Damit er etwas tun kann, ben√∂tigt der Controller mindestens einen Status, um auf Ereignisse zu reagieren. <br><br>  Die Steuerungen sind so strukturiert, dass sie Bl√∂cke verschiedener Typen enthalten, die durch einen Bindestrich um den Namen des Blocktyps gekennzeichnet sind: <br><br><pre> <code class="cpp hljs">#MyController&lt;br&gt; -block <span class="hljs-number"><span class="hljs-number">1</span></span>- -block <span class="hljs-number"><span class="hljs-number">2</span></span>- -block <span class="hljs-number"><span class="hljs-number">3</span></span>-</code> </pre> <br>  Ein Controller kann nicht mehr als eine Instanz jedes Blocks haben, und Blocktypen k√∂nnen nur bestimmte Arten von Unterkomponenten enthalten.  In diesem Artikel untersuchen wir nur den <strong>-machine-</strong> Block, der nur Zust√§nde enthalten kann.  Zust√§nde werden durch das <strong>$</strong> -Pr√§fix-Token identifiziert. <br><br>  Hier sehen wir die FMN f√ºr eine Steuerung, die eine Maschine mit nur einem Zustand enth√§lt: <br><br><pre> <code class="cpp hljs">#MyController <span class="hljs-comment"><span class="hljs-comment">// controller declaration -machine- // machine block $S1 // state declaration</span></span></code> </pre> <br>  Hier ist die Implementierung des obigen FMN-Codes: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// -machine- var _state(e:FrameEvent) = S1 // initialize state variable // to $S1 func S1(e:FrameEvent) { // state $S1 does nothing } }</span></span></code> </pre> <br>  Die Implementierung des Maschinenblocks besteht aus folgenden Elementen: <br><br><ol><li>  <strong>_state</strong> Variable, die sich auf eine Funktion des aktuellen Status bezieht.  Es wird mit der ersten Zustandsfunktion in der Steuerung initialisiert. </li><li>  eine oder mehrere Zustandsmethoden </li></ol><br>  Die Frame-Statusmethode wird als Funktion mit der folgenden Signatur definiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e:FrameEvent)</span></span></span></span>;</code> </pre> <br>  Nachdem Sie diese Grundlagen f√ºr die Implementierung des Maschinenblocks definiert haben, k√∂nnen Sie sehen, wie gut das FrameEvent mit der Maschine interagiert. <br><br><h3>  Schnittstelleneinheit </h3><br>  Das Zusammenspiel von FrameEvents, die den Betrieb der Maschine steuern, ist das Wesentliche f√ºr die Einfachheit und Leistungsf√§higkeit der Frame-Notation.  Wir haben die Frage, woher FrameEvents kommen, jedoch noch nicht beantwortet - wie gelangen sie in den Controller, um ihn zu steuern?  Eine Option: Externe Clients k√∂nnen selbst FrameEvents erstellen und initialisieren und dann direkt die Methode aufrufen, auf die die _state-Membervariable verweist: <br><br><pre> <code class="cpp hljs">myController._state(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>))</code> </pre> <br>  Eine viel bessere Alternative w√§re, eine gemeinsame Schnittstelle zu erstellen, die einen direkten Aufruf der Mitgliedsvariablen _state umschlie√üt: <br><br><pre> <code class="cpp hljs">myController.sendEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>))</code> </pre> <br>  Der problemloseste Weg, der der √ºblichen Art der Erstellung objektorientierter Software entspricht, besteht darin, allgemeine Methoden zu erstellen, die ein Ereignis im Namen des Clients an den internen Computer senden: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ FrameEvent e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>) _state(e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e._return } }</code> </pre> <br>  Frame definiert die Syntax f√ºr <strong>einen Schnittstellenblock</strong> , der Methoden enth√§lt, die Aufrufe in eine gemeinsame Schnittstelle f√ºr FrameEvents verwandeln. <br><br><pre> <code class="cpp hljs">#MyController -interface- buttonClick ...</code> </pre> <br>  Der <code>interface</code> hat viele andere Funktionen, aber dieses Beispiel gibt uns eine allgemeine Vorstellung davon, wie dies funktioniert.  Ich werde in den folgenden Artikeln der Reihe weitere Erkl√§rungen geben. <br><br>  Lassen Sie uns nun die Funktionsweise des Frame-Automaten weiter untersuchen. <br><br><h3>  Ereignishandler </h3><br>  Obwohl wir gezeigt haben, wie man ein Auto definiert, haben wir noch keine Notation, mit der <em>wir</em> etwas <em>tun</em> k√∂nnen.  Um Ereignisse zu verarbeiten, m√ºssen wir 1) das zu verarbeitende Ereignis ausw√§hlen k√∂nnen und 2) es an das durchgef√ºhrte Verhalten anh√§ngen. <br><br>  Hier ist ein einfacher Frame-Controller, der die Infrastruktur f√ºr die Behandlung von Ereignissen bereitstellt: <br><br><pre> <code class="cpp hljs">#MyController <span class="hljs-comment"><span class="hljs-comment">// controller declaration -machine- // machine block $S1 // state declaration |e1| ^ // e1 event handler and return</span></span></code> </pre> <br>  Wie oben angegeben, verwendet die FMN-Notation f√ºr den Zugriff auf das <code>_msg</code> Attribut des <code>_msg</code> Ereignisses Klammern aus vertikalen Linien: <br><br><pre> <code class="cpp hljs">|messageName|</code> </pre> <br>  FMN verwendet auch ein Exponententoken, das die return-Anweisung darstellt.  Die oben gezeigte Steuerung wird wie folgt implementiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #MyController // -machine- var _state(e:FrameEvent) = S1 func S1(e:FrameEvent) { // $S1 if (e._msg == "e1") { // |e1| return // ^ } } }</span></span></code> </pre> <br>  Hier sehen wir, wie deutlich die FMN-Notation einem Implementierungsmuster entspricht, das leicht zu verstehen und zu codieren ist. <br><br>  Nachdem wir diese grundlegenden Aspekte von Ereignissen, Steuerungen, Maschinen, Zust√§nden und Ereignishandlern festgelegt haben, k√∂nnen wir mit ihrer Hilfe echte Probleme l√∂sen. <br><br><h3>  Single-Focus-Maschinen </h3><br>  Oben haben wir uns einen zustandslosen Controller angesehen, der ziemlich nutzlos war. <br><br><pre> <code class="cpp hljs">#MyController</code> </pre> <br>  Ein Schritt h√∂her in der Nahrungskette ist eine Klasse mit einem einzigen Zustand, der zwar nicht nutzlos, aber einfach langweilig ist.  Aber zumindest macht er wenigstens <em>etwas</em> . <br><br>  Lassen Sie uns zun√§chst sehen, wie eine Klasse mit nur einem (implizierten) Status implementiert wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mono</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OFF"</span></span> } }</code> </pre> <br>  Hier wird kein Status deklariert oder sogar impliziert, aber nehmen wir an, dass sich das System im Status "Working" befindet, wenn der Code etwas tut. <br><br>  Wir werden auch eine wichtige Idee vorstellen: Schnittstellenaufrufe werden als √§hnlich wie das Senden eines Ereignisses an ein Objekt betrachtet.  Daher kann der obige Code als ein Verfahren zum √úbertragen des | Status | betrachtet werden  die Mono-Klasse, immer im Zustand $ Working. <br><br>  Diese Situation kann mithilfe der Ereignisbindungstabelle visualisiert werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/81e/7e0/e1b81e7e0916b8354c4092abcc79ab40.png"></div><br>  Schauen wir uns nun FMN an, das dieselbe Funktionalit√§t demonstriert und mit derselben Bindungstabelle √ºbereinstimmt: <br><br><pre> <code class="cpp hljs">#Mono -machine- $Working |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>)</code> </pre> <br>  So sieht die Implementierung aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mono</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Mono // -machine- var _state(e:FrameEvent) = Working // initialize start state func Working(e:FrameEvent) { // $Working if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } }</span></span></code> </pre> <br>  Sie k√∂nnen feststellen, dass wir auch eine neue Notation f√ºr die <strong>return-Anweisung eingef√ºhrt</strong> haben. Dies bedeutet, dass der Ausdruck ausgewertet und das Ergebnis an die Schnittstelle zur√ºckgegeben wird: <br><br><pre> <code class="cpp hljs">^(return_expr)</code> </pre> <br>  Dieser Operator ist √§quivalent <br><br><pre> <code class="cpp hljs">@^ = return_expr</code> </pre> <br>  oder einfach <br><br><pre> <code class="cpp hljs">^ = return_expr</code> </pre> <br>  Alle diese Operatoren sind funktional √§quivalent und Sie k√∂nnen jeden von ihnen verwenden, aber <code>^(return_expr)</code> sieht am ausdrucksst√§rksten aus. <br><br><h3>  Schalten Sie den Herd ein </h3><br>  Bisher haben wir einen Controller mit 0 Zust√§nden und einen Controller mit 1 Zustand gesehen.  Sie sind noch nicht sehr n√ºtzlich, aber wir stehen bereits vor etwas Interessantem. <br><br>  Um unsere Nudeln zu kochen, m√ºssen Sie zuerst den Herd einschalten.  Das Folgende ist eine einfache Switch-Klasse mit einer einzelnen booleschen Variablen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch</span></span></span><span class="hljs-class"> {</span></span> boolean _isOn; <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_isOn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"ON"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OFF"</span></span>; } } }</code> </pre> <br>  Obwohl dies auf den ersten Blick nicht offensichtlich ist, implementiert der oben gezeigte Code die folgende Tabelle der Ereignisbindungen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/5f8/ad7/2ef5f8ad7634c21066e847faf89c8228.png"></div><br>  Zum Vergleich hier ein FMN f√ºr das gleiche Verhalten: <br><br><pre> <code class="cpp hljs">#Switch1 -machine- $Off |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  Jetzt sehen wir, wie genau die Frame-Notation dem Zweck unseres Codes entspricht - das Anh√§ngen eines Ereignisses (Methodenaufrufs) an das Verhalten basierend auf dem Status, in dem sich der Controller befindet.  Dar√ºber hinaus entspricht die Implementierungsstruktur auch der Bindungstabelle: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch1 // -machine- var _state(e:FrameEvent) = Off func Off(e:FrameEvent) { // $Off if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } func On(e:FrameEvent) { // $On if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br>  In der Tabelle k√∂nnen Sie den Zweck des Controllers in seinen verschiedenen Zust√§nden schnell verstehen.  Sowohl die Frame-Notationsstruktur als auch das Implementierungsmuster haben √§hnliche Vorteile. <br><br>  Unser Switch weist jedoch ein sp√ºrbares Funktionsproblem auf.  Es wird im Status $ Off initialisiert, kann aber nicht in den Status $ On wechseln!  Dazu m√ºssen wir einen <strong>Zustands√§nderungsoperator</strong> eingeben. <br><br><h3>  Status √§ndern </h3><br>  <strong>Die Anweisung zur Status√§nderung lautet</strong> wie folgt: <br><br><pre> <code class="cpp hljs">-&gt;&gt; $NewState</code> </pre> <br>  Jetzt k√∂nnen wir diesen Operator verwenden, um zwischen $ Off und $ On zu wechseln: <br><br><pre> <code class="cpp hljs">#Switch2 -machine- $Off |toggle| -&gt;&gt; $On ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |toggle| -&gt;&gt; $Off ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  Und hier ist die entsprechende Ereignisbindungstabelle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b02/08f/688/b0208f68897eb1412f386392e8779247.png"></div><br>  Neues Ereignis | umschalten |  L√∂st jetzt eine √Ñnderung aus, die einfach die beiden Zust√§nde durchl√§uft.  Wie kann eine Zustands√§nderungsoperation implementiert werden? <br><br>  Nirgendwo ist es einfacher.  Hier ist die Implementierung von Switch2: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch2 // -machine- var _state(e:FrameEvent) = Off func Off(e:FrameEvent) { if (e._msg == "toggle") { // |toggle| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } func On(e:FrameEvent) { if (e._msg == "toggle") { // |toggle| _state = Off // -&gt;&gt; $Off return // ^("OFF") } if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br>  Sie k√∂nnen auch die letzte Verbesserung in Switch2 vornehmen, sodass Sie nicht nur zwischen Status wechseln k√∂nnen, sondern auch den Status explizit festlegen: <br><br><pre> <code class="cpp hljs">#Switch3 -machine- $Off |turnOn| -&gt;&gt; $On ^ |toggle| -&gt;&gt; $On ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |turnOff| -&gt;&gt; $Off ^ |toggle| -&gt;&gt; $Off ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  Im Gegensatz zum | toggle | -Ereignis, wenn | turnOn |  Wird gesendet, wenn Switch3 bereits eingeschaltet ist, oder | turnOff |, wenn es bereits ausgeschaltet ist, wird die Nachricht ignoriert und es passiert nichts.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese kleine Verbesserung gibt dem Client die M√∂glichkeit, explizit anzugeben, in welchem ‚Äã‚ÄãZustand sich der Switch befinden soll: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch3 // -machine- var _state(e:FrameEvent) = Off /********************************** $Off |turnOn| -&gt;&gt; $On ^ |toggle| -&gt;&gt; $On ^ |status| ^("OFF") ***********************************/ func Off(e:FrameEvent) { if (e._msg == "turnOn") { // |turnOn| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "toggle") { // |toggle| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } /********************************** $On |turnOff| -&gt;&gt; $Off ^ |toggle| -&gt;&gt; $Off ^ |status| ^("ON") ***********************************/ func On(e:FrameEvent) { if (e._msg == "turnOff") { // |turnOff| _state = Off // -&gt;&gt; $Off return // ^ } if (e._msg == "toggle") { // |toggle| _state = Off // -&gt;&gt; $Off return // ^ } if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der letzte Schritt in der Entwicklung unseres Schalters zeigt, wie einfach es ist, den Zweck des FMN-Controllers zu verstehen. </font><font style="vertical-align: inherit;">Relevanter Code zeigt, wie einfach die Implementierung mithilfe von Frame-Mechanismen ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Switch-Maschine erstellt haben, k√∂nnen wir das Feuer einschalten und mit dem Kochen beginnen!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klangzustand </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein wichtiger, wenn auch subtiler Aspekt von Automaten ist, dass der aktuelle Zustand der Maschine entweder das Ergebnis einer Situation (z. B. Einschalten) oder einer Art Analyse von Daten oder der Umgebung ist. </font><font style="vertical-align: inherit;">Wenn die Maschine in den gew√ºnschten Zustand wechselt, ist dies impliziert. </font><font style="vertical-align: inherit;">dass sich die Situation ohne das Wissen des Autos nicht √§ndern wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Annahme ist jedoch nicht immer richtig. </font><font style="vertical-align: inherit;">In einigen Situationen ist eine √úberpr√ºfung (oder "Erfassung") der Daten erforderlich, um den aktuellen logischen Zustand zu bestimmen:</font></font><br><br><ol><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anf√§nglicher wiederhergestellter Zustand</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - wenn die Maschine aus einem konstanten Zustand wiederhergestellt wird</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">externer Zustand</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Definiert die ‚Äûtats√§chliche Situation‚Äú, die zum Zeitpunkt der Erstellung, Wiederherstellung oder des Betriebs der Maschine in der Umgebung besteht</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fl√ºchtiger interner Zustand</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wenn sich ein Teil der internen Daten, die von einer laufenden Maschine verwaltet werden, au√üerhalb der Kontrolle der Maschine √§ndern kann</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In all diesen F√§llen m√ºssen Daten, Umgebung oder beides ‚Äûgepr√ºft‚Äú werden, um die Situation zu bestimmen und den Zustand der Maschine entsprechend einzustellen. </font><font style="vertical-align: inherit;">Idealerweise kann diese Boolesche Logik in einer einzigen Funktion implementiert werden, die den korrekten logischen Zustand definiert. </font><font style="vertical-align: inherit;">Um dieses Muster zu unterst√ºtzen, verf√ºgt die Frame-Notation √ºber eine spezielle Art von Funktion, die das Universum untersucht und die aktuelle Situation bestimmt. </font><font style="vertical-align: inherit;">Solche Funktionen werden durch das Pr√§fix </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vor dem Namen der Methode angegeben, die einen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zum Status</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur√ºckgibt </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs">$probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In unserer Situation kann eine solche Methode wie folgt implementiert werden: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probeForState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:FrameState </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Solid <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">212</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Liquid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Gas }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie wir sehen k√∂nnen, gibt die Methode einfach einen Verweis auf die Zustandsfunktion zur√ºck, die dem korrekten logischen Zustand entspricht. </font><font style="vertical-align: inherit;">Diese Erfassungsfunktion kann dann verwendet werden, um in den richtigen Zustand zu gelangen:</font></font><br><br><pre> <code class="cpp hljs">-&gt;&gt; $probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Implementierungsmechanismus sieht folgenderma√üen aus: </font></font><br><br><pre> <code class="cpp hljs">_state = probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zustandserfassungsmethode ist ein Beispiel f√ºr die Rahmennotation zum Verwalten des Zustands auf eine bestimmte Weise. </font><font style="vertical-align: inherit;">Als n√§chstes lernen wir auch die wichtige Notation f√ºr die Verwaltung von FrameEvents.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verhaltensvererbung und Dispatcher </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verhaltensvererbung und Dispatcher</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind ein leistungsf√§higes Programmierparadigma und das letzte Thema zur Frame-Notation in diesem Artikel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frame verwendet die Vererbung von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verhalten</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nicht die Vererbung von Daten oder anderen Attributen. </font><font style="vertical-align: inherit;">F√ºr diesen Status werden FrameEvents an andere Status gesendet, wenn der Anfangsstatus das Ereignis nicht behandelt (oder, wie wir in den n√§chsten Artikeln sehen werden, es nur weitergeben m√∂chte). </font><font style="vertical-align: inherit;">Diese Ereigniskette kann bis zu einer beliebigen Tiefe reichen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zweck k√∂nnen Maschinen unter Verwendung einer Technik implementiert werden, die als </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methodenverkettung bezeichnet wird</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die FMN-Notation zum Senden von Ereignissen von einem Status in einen anderen lautet </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dispatcher </font></font></strong> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs">$S1 =&gt; $S2</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese FMN-Anweisung kann wie folgt implementiert werden: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">S1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e:FrameEvent)</span></span></span><span class="hljs-function"> </span></span>{ S2(e) <span class="hljs-comment"><span class="hljs-comment">// $S1 =&gt; $S2 }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt sehen wir, wie einfach es ist, Zustandsmethoden zu verketten. </font><font style="vertical-align: inherit;">Wenden wir diese Technik auf eine ziemlich schwierige Situation an:</font></font><br><br><pre> <code class="cpp hljs">#Movement -machine- $Walking =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">3</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Running =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">6</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Crawling =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">.5</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) $AtAttention =&gt; $Motionless |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $LyingDown =&gt; $Motionless |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) $Moving |isMoving| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Motionless |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">0</span></span>) |isMoving| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im obigen Code sehen wir, dass es zwei Grundzust√§nde gibt - $ Moving und $ Motionless - und die anderen f√ºnf Zust√§nde erben wichtige Funktionen von ihnen. </font><font style="vertical-align: inherit;">Die Ereignisbindung zeigt uns deutlich, wie die Bindungen im Allgemeinen aussehen werden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/117/95d/97c/11795d97c6a96d32824dc9ac2ddf62dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dank der Techniken, die wir gelernt haben, wird die Implementierung sehr einfach sein: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Movement</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Movement // -machine- /********************************** $Walking =&gt; $Moving |getSpeed| ^(3) |isStanding| ^(true) ***********************************/ func Walking(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 3 return } if (e._msg == "isStanding") { e._return = true return } Moving(e) // $Walking =&gt; $Moving } /********************************** $Running =&gt; $Moving |getSpeed| ^(6) |isStanding| ^(true) ***********************************/ func Running(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 6 return } if (e._msg == "isStanding") { e._return = true return } Moving(e) // $Running =&gt; $Moving } /********************************** $Crawling =&gt; $Moving |getSpeed| ^(.5) |isStanding| ^(false) ***********************************/ func Crawling(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = .5 return } if (e._msg == "isStanding") { e._return = false return } Moving(e) // $Crawling =&gt; $Moving } /********************************** $AtAttention =&gt; $Motionless |isStanding| ^(true) ***********************************/ func AtAttention(e:FrameEvent) { if (e._msg == "isStanding") { e._return = true return } Motionless(e) // $AtAttention =&gt; $Motionless } /********************************** $LyingDown =&gt; $Motionless |isStanding| ^(false) ***********************************/ func LyingDown(e:FrameEvent) { if (e._msg == "isStanding") { e._return = false return } Motionless(e) // $AtAttention =&gt; $Motionless } /********************************** $Moving |isMoving| ^(true) ***********************************/ func Moving(e:FrameEvent) { if (e._msg == "isMoving") { e._return = true return } } /********************************** $Motionless |getSpeed| ^(0) |isMoving| ^(false) ***********************************/ func Motionless(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 0 return } if (e._msg == "isMoving") { e._return = false return } } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wassermaschine </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt verf√ºgen wir √ºber die Grundlagen des Wissens √ºber FMN, sodass wir verstehen, wie die WaterSample-Klasse mit Zust√§nden und auf viel intelligentere Weise erneut implementiert werden kann. </font><font style="vertical-align: inherit;">Wir werden es auch f√ºr unseren Doktoranden n√ºtzlich machen und ihm einen neuen $ Plasma-Status hinzuf√ºgen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afb/d16/64d/afbd1664dacfde5e4857c45e35ee33ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So sieht die vollst√§ndige FMN-Implementierung aus: </font></font><br><br><pre> <code class="cpp hljs">#WaterSample -machine- $Begin |create| <span class="hljs-comment"><span class="hljs-comment">// set temp to the event param value setTemp(@[temp]) // probe for temp state and change to it -&gt;&gt; $probeForState() ^ $Solid =&gt; $Default |melt| doMelt() -&gt;&gt; $Liquid ^ |sublimate| doSublimate() -&gt;&gt; $Gas ^ |getState| ^("SOLID") $Liquid =&gt; $Default |freeze| doFreeze() -&gt;&gt; $Solid ^ |vaporize| doVaporize() -&gt;&gt; $Gas ^ |getState| ^("LIQUID") $Gas =&gt; $Default |condense| doCondense() -&gt;&gt; $Liquid ^ |depose| doDepose() -&gt;&gt; $Solid ^ |ionize| doIonize() -&gt;&gt; $Plasma ^ |getState| ^("GAS") $Plasma =&gt; $Default |recombine| doRecombine() -&gt;&gt; $Gas ^ |getState| ^("PLASMA") $Default |melt| throw new InvalidStateError() |sublimate| throw new InvalidStateError() |freeze| throw new InvalidStateError() |vaporize| throw new InvalidStateError() |condense| throw InvalidStateError() |depose| throw InvalidStateError() |ionize| throw InvalidStateError() |recombine| throw InvalidStateError() |getState| throw InvalidStateError()</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen k√∂nnen, haben wir den Anfangszustand $ Begin, der auf die Nachricht | create | reagiert und beh√§lt Wert </font></font><code>temp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Erfassungsfunktion √ºberpr√ºft zuerst den Anfangswert </font></font><code>temp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um den logischen Zustand zu bestimmen, und f√ºhrt dann den √úbergang der Maschine in diesen Zustand durch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle physischen Zust√§nde ($ Solid, $ Liquid, $ Gas, $ Plasma) erben das Schutzverhalten vom $ Default-Zustand. Alle Ereignisse, die f√ºr den aktuellen Status nicht g√ºltig sind, werden an den Status $ Default √ºbergeben, der einen InvalidStateError-Fehler ausl√∂st. Dies zeigt, wie einfache defensive Programmierung mithilfe der Verhaltensvererbung implementiert werden kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und jetzt die Implementierung:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaterSample</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// -machine- var _state(e:FrameEvent) = Begin /********************************** $Begin |create| // set temp to the event param value setTemp(@[temp]) // probe for temp state and change to it -&gt;&gt; $probeForState() ^ ***********************************/ func Begin(e:FrameEvent) { if (e._msg == "create") { setTemp(e["temp"]) _state = probeForState() return } } /********************************** $Solid =&gt; $Default |melt| doMelt() -&gt;&gt; $Liquid ^ |sublimate| doSublimate() -&gt;&gt; $Gas ^ |sublimate| ^("SOLID") ***********************************/ func Solid(e:FrameEvent) { if (e._msg == "melt") { doMelt() _state = Liquid return } if (e._msg == "sublimate") { doSublimate() _state = Gas return } if (e._msg == "getState") { e._return = "SOLID" return } Default(e) } /********************************** $Liquid =&gt; $Default |freeze| doFreeze() -&gt;&gt; $Solid ^ |vaporize| doVaporize() -&gt;&gt; $Gas ^ |getState| ^("LIQUID") ***********************************/ func Liquid(e:FrameEvent) { if (e._msg == "freeze") { doFreeze() _state = Solid return } if (e._msg == "vaporize") { doVaporize() _state = Gas return } if (e._msg == "getState") { e._return = "LIQUID" return } Default(e) } /********************************** $Gas =&gt; $Default |condense| doCondense() -&gt;&gt; $Liquid ^ |depose| doDepose() -&gt;&gt; $Solid ^ |ionize| doIonize() -&gt;&gt; $Plasma ^ |getState| ^("GAS") ***********************************/ func Gas(e:FrameEvent) { if (e._msg == "condense") { doCondense() _state = Liquid return } if (e._msg == "depose") { doDepose() _state = Solid return } if (e._msg == "ionize") { doIonize() _state = Plasma return } if (e._msg == "getState") { e._return = "GAS" return } Default(e) } /********************************** $Plasma =&gt; $Default |recombine| doRecombine() -&gt;&gt; $Gas ^ |getState| ^("PLASMA") ***********************************/ func Plasma(e:FrameEvent) { if (e._msg == "recombine") { doRecombine() _state = Gas return } if (e._msg == "getState") { e._return = "PLASMA" return } Default(e) } /********************************** $Default |melt| throw new InvalidStateError() |sublimate| throw new InvalidStateError() |freeze| throw new InvalidStateError() |vaporize| throw new InvalidStateError() |condense| throw InvalidStateError() |depose| throw InvalidStateError() |ionize| throw InvalidStateError() |recombine| throw InvalidStateError() |getState| throw InvalidStateError() ***********************************/ func Default(e:FrameEvent) { if (e._msg == "melt") { throw new InvalidStateError() } if (e._msg == "sublimate") { throw new InvalidStateError() } if (e._msg == "freeze") { throw new InvalidStateError() } if (e._msg == "vaporize") { throw new InvalidStateError() } if (e._msg == "condense") { throw new InvalidStateError() } if (e._msg == "depose") { throw new InvalidStateError() } if (e._msg == "ionize") { throw new InvalidStateError() } if (e._msg == "recombine") { throw new InvalidStateError() } if (e._msg == "getState") { throw new InvalidStateError() } } }</span></span></code> </pre> <br><h3>  Fazit </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automaten sind ein Grundkonzept der Informatik, das zu lange nur in speziellen Bereichen der Software- und Hardwareentwicklung eingesetzt wurde. Die Hauptaufgabe von Frame besteht darin, eine Notation zum Beschreiben von Automaten zu erstellen und einfache Muster zum Schreiben von Code oder ‚ÄûMechanismen‚Äú f√ºr deren Implementierung festzulegen. Ich hoffe, dass die Frame-Notation die Art und Weise √§ndert, wie Programmierer Maschinen betrachten, und eine einfache M√∂glichkeit bietet, sie in allt√§glichen Programmieraufgaben in die Praxis umzusetzen und sie nat√ºrlich vor Spaghetti im Code zu sch√ºtzen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/411/041/f9d/411041f9dac0d4b6b9901a9528939495.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terminator isst Pasta (Foto von Mr. Suzuki)</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In zuk√ºnftigen Artikeln werden wir basierend auf den Konzepten, die wir gelernt haben, eine noch gr√∂√üere Kraft und Ausdruckskraft der FMN-Notation schaffen. </font><font style="vertical-align: inherit;">Im Laufe der Zeit werde ich die Diskussion auf das Studium der visuellen Modellierung ausweiten, das FMN umfasst und die Probleme unsicheren Verhaltens in modernen Ans√§tzen zur Softwaremodellierung l√∂st.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446330/">https://habr.com/ru/post/de446330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446320/index.html">Wie der 3D-Scanner es erm√∂glichte, die vollst√§ndige Steuerbaugruppe der Br√ºcke aufzugeben</a></li>
<li><a href="../de446322/index.html">Kryptographie in Java. Keytool-Dienstprogramm</a></li>
<li><a href="../de446324/index.html">Navigation in DataGrip mit Yandex.Navigator</a></li>
<li><a href="../de446326/index.html">Verkehrsprobleme l√∂sen</a></li>
<li><a href="../de446328/index.html">Warum brauchen wir SMS-Empfangsdienste und womit essen sie?</a></li>
<li><a href="../de446332/index.html">IBM System i (auch bekannt als AS / 400) - Wie wir automatische Tests f√ºr Green-Screen-Anwendungen durchgef√ºhrt haben</a></li>
<li><a href="../de446334/index.html">√úberlegungen zu einer Karriere in der IT und Tipps f√ºr Anf√§nger</a></li>
<li><a href="../de446336/index.html">Wie man Standardkennw√∂rter verbietet und alle dazu bringt, dich zu hassen</a></li>
<li><a href="../de446338/index.html">SVG 3D: Erstellen, Drehen und Animieren</a></li>
<li><a href="../de446340/index.html">Betriebssysteme: Drei einfache Teile. Teil 1: Intro (√úbersetzung)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>