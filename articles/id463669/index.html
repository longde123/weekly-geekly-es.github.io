<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆🏻 📻 🤳 Protokol MQTT: Perendaman Konseptual 🤲🏼 👨🏽‍🚒 💇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Protokol Antrian Transpor Pesan Antrian (MQTT) telah digunakan selama bertahun-tahun, tetapi sekarang ini sangat relevan karena pertumbuhan eksplosif ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protokol MQTT: Perendaman Konseptual</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463669/">  Protokol Antrian Transpor Pesan Antrian (MQTT) telah digunakan selama bertahun-tahun, tetapi sekarang ini sangat relevan karena pertumbuhan eksplosif dari IoT: perangkat konsumen dan industri mengimplementasikan jaringan terdistribusi dan komputasi tepi, dan perangkat dengan transmisi data terus menerus menjadi bagian dari kehidupan sehari-hari hidup. <br><br>  Ini berarti bahwa protokol yang ringan, terbuka, dan terjangkau akan menjadi lebih penting dari waktu ke waktu.  Artikel ini memberikan pencelupan konseptual di MQTT: cara kerjanya, bagaimana digunakan sekarang dan bagaimana akan digunakan di masa depan. <br><a name="habracut"></a><br><h1>  Pengantar kecil </h1><br>  MQTT adalah protokol pengiriman berbasis penerbit (subscriber).  Versi awal pada tahun 1999 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diterbitkan oleh</a> Andy Stanford-Clark dari IBM dan Arlene Nipper dari Cirrus Link.  Mereka memandang MQTT sebagai cara untuk menjaga komunikasi antara mesin dalam jaringan dengan bandwidth terbatas atau komunikasi yang tidak dapat diprediksi.  Salah satu opsi pertama untuk penggunaannya adalah untuk memastikan bahwa potongan-potongan pipa kontak satu sama lain dan dengan tautan pusat melalui satelit. <br><br>  Mengingat kondisi operasi yang keras, protokol dibuat kecil dan ringan.  Ini sangat ideal untuk perangkat berdaya rendah dan dengan usia baterai terbatas.  Ini sekarang termasuk smartphone di mana-mana, dan semakin banyak sensor dan perangkat yang terhubung. <br><br>  Dengan demikian, MQTT telah menjadi protokol untuk streaming data antara perangkat dengan daya CPU terbatas dan / atau masa pakai baterai, serta untuk jaringan dengan bandwidth yang mahal atau rendah, stabilitas yang tidak dapat diprediksi atau latensi tinggi.  Itulah sebabnya MQTT dikenal sebagai kendaraan ideal untuk IoT.  Itu dibangun pada protokol TCP / IP, tetapi ada cabang MQTT-SN untuk bekerja melalui Bluetooth, UDP, ZigBee dan jaringan IoT lainnya selain TCP / IP. <br><br>  MQTT bukan satu-satunya protokol pesan pub / sub-waktu dari jenisnya, tetapi telah menjadi tersebar luas di berbagai lingkungan yang bergantung pada komunikasi mesin-ke-mesin.  Di antara rekan-rekannya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Protokol Perpesanan Aplikasi Web</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Streaming Protokol Pesan Berorientasi Teks</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Protokol Antrian Pesan Alternatif</a> . <br><br>  MQTT adalah pilihan logis untuk pengembang yang ingin membuat aplikasi dengan fungsionalitas andal dan kompatibilitas luas dengan perangkat dan aplikasi yang terhubung ke Internet, termasuk browser, smartphone, dan perangkat IoT. <br><br><h1>  Bagaimana MQTT Bekerja: Dasar-Dasarnya </h1><br>  Sistem komunikasi yang dibangun di MQTT terdiri dari server penerbit, server broker, dan satu atau lebih klien.  Penerbit tidak memerlukan pengaturan apa pun untuk jumlah atau lokasi pelanggan yang menerima pesan.  Selain itu, pelanggan tidak perlu mencari penerbit tertentu.  Mungkin ada beberapa broker pesan dalam sistem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/029/60b/c0b/02960bc0baf11fcfc7c8cd56d331ba4c.png"><br><br>  MQTT menyediakan cara untuk membuat hierarki saluran komunikasi - semacam cabang dengan daun.  Setiap kali penerbit memiliki data baru untuk didistribusikan kepada pelanggan, pesan tersebut disertai dengan catatan kontrol pengiriman.  Klien tingkat yang lebih tinggi dapat menerima setiap pesan, sementara klien tingkat yang lebih rendah dapat menerima pesan yang terkait dengan hanya satu atau dua saluran dasar, "cabang" di bagian bawah hierarki.  Ini memfasilitasi pertukaran informasi mulai dari ukuran dua byte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hingga 256 megabita</a> . <br><br>  Contoh bagaimana Anda dapat mengonfigurasi klien untuk terhubung melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">broker MQTT</a> : <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">keepalive</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-attr"><span class="hljs-attr">username</span></span>: <span class="hljs-string"><span class="hljs-string">'FIRST_HALF_OF_API_KEY'</span></span>, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: <span class="hljs-string"><span class="hljs-string">'SECOND_HALF_OF_API_KEY'</span></span>, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">8883</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = mqtt.connect(<span class="hljs-string"><span class="hljs-string">'mqtts:mqtt.ably.io'</span></span>, options);</code> </pre> <br>  Setiap data yang diterbitkan atau diterima oleh broker MQTT akan dikodekan dalam format biner, karena MQTT adalah protokol biner.  Ini berarti bahwa untuk mendapatkan konten asli, Anda perlu menafsirkan pesan.  Begini tampilannya dengan Ably dan JavaScript: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ably = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ably.Realtime(<span class="hljs-string"><span class="hljs-string">'REPLACE_WITH_YOUR_API_KEY'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> decoder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextDecoder(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> channel = ably.channels.get(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); channel.subscribe(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = decoder.decode(message.data); });</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Broker MQTT</a> kadang-kadang dapat mengakumulasikan pesan yang terkait dengan saluran yang tidak memiliki pelanggan saat ini.  Dalam hal ini, pesan akan dibuang atau disimpan, tergantung pada instruksi dalam pesan kontrol.  Ini berguna dalam kasus di mana pelanggan baru mungkin memerlukan titik data yang terakhir direkam, daripada menunggu pengiriman berikutnya. <br><br>  Perlu dicatat bahwa MQTT mentransmisikan kredensial keamanan dalam teks yang jelas, jika tidak otentikasi atau fungsi keamanan tidak didukung.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sinilah kerangka kerja SSL berperan</a> , membantu melindungi informasi yang dikirimkan agar tidak dicegat atau dirusak. <br><br>  Selain itu, di MQTT, Anda dapat menggunakan otentikasi Ably pada token jika Anda tidak ingin mengungkapkan kunci API Anda ke klien MQTT yang sebenarnya sama sekali (dalam hal MQTT tanpa SSL, token diperlukan untuk mencegah transfer kunci API dalam teks yang jelas).  Contoh otentikasi token: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">keepalive</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-attr"><span class="hljs-attr">username</span></span>: INSERT_TOKEN_HERE, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">8883</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = mqtt.connect(<span class="hljs-string"><span class="hljs-string">'mqtts:mqtt.ably.io'</span></span>, options); client.subscribe(<span class="hljs-string"><span class="hljs-string">"[mqtt]tokenevents"</span></span>, { <span class="hljs-comment"><span class="hljs-comment">/* Create a new token called 'NEW_TOKEN' */</span></span> client.end(); options.username = NEW_TOKEN; client = mqtt.connect(<span class="hljs-string"><span class="hljs-string">'mqtts:mqtt.ably.io'</span></span>, options); });</code> </pre> <br><h1>  Fungsionalitas MQTT: perendaman yang lebih dalam </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menurut IBM</a> , MQTT memiliki sifat-sifat berikut: <br><br><ul><li>  Netral ke konten pesan <br></li><li>  Ideal untuk komunikasi satu-ke-banyak yang didistribusikan dan aplikasi yang terputus <br></li><li>  Dilengkapi dengan fungsi LWT (Wasiat Terakhir dan Wasiat, "wasiat terakhir dan wasiat") untuk memberi tahu pihak-pihak tentang pemutusan yang tidak wajar dari klien <br></li><li>  Mengandalkan TCP / IP untuk tugas komunikasi dasar <br></li><li>  Dirancang untuk mengirim pesan menggunakan templat "paling banyak sekali", "setidaknya sekali" dan "tepat sekali" </li></ul><br>  Seorang anggota sistem MQTT dapat mengambil peran sebagai penerbit, konsumen, atau keduanya sekaligus. <br><br>  Salah satu ciri khas MQTT adalah pemahamannya yang unik tentang saluran: masing-masing diperlakukan sebagai jalur file, misalnya: <br><br><pre> <code class="javascript hljs">channel = <span class="hljs-string"><span class="hljs-string">"user/path/channel"</span></span></code> </pre> <br>  Saluran memastikan bahwa setiap pelanggan menerima pesan yang ditujukan kepadanya.  Dengan memperlakukan saluran sebagai jalur file, MQTT melakukan semua jenis fungsi komunikasi yang berguna, termasuk memfilter pesan berdasarkan di mana - pada tingkat apa atau di cabang mana - klien berlangganan jalur file. <br><br><h1>  Format pesan MQTT </h1><br>  Lihatlah dua komponen yang membentuk setiap pesan MQTT: <br><br><ul><li>  <b>Byte 1</b> : berisi jenis pesan (permintaan koneksi klien, konfirmasi berlangganan, permintaan ping, dll.), Tanda duplikasi, instruksi untuk menyimpan pesan, dan informasi tentang kualitas layanan (QoS). <br></li><li>  <b>Byte 2</b> : berisi informasi tentang panjang pesan yang tersisa, termasuk muatan dan data apa pun di header variabel opsional. </li></ul><br>  Bendera QoS dalam byte 1 patut mendapat perhatian khusus, karena mendasari fungsi variabel yang didukung MQTT.  Bendera QoS berisi nilai-nilai berikut berdasarkan niat dan urgensi pesan: <br><br><ul><li>  0 = tidak lebih dari sekali: server terpicu dan lupa.  Pesan mungkin hilang atau digandakan. <br></li><li>  1 = setidaknya sekali: penerima mengkonfirmasi pengiriman.  Pesan dapat digandakan, tetapi pengiriman dijamin <br></li><li>  2 = tepat sekali: server menyediakan pengiriman.  Pesan tiba tepat sekali tanpa kehilangan atau duplikasi </li></ul><br>  Mari kita lihat cara menggunakan level QoS yang berbeda di perangkat IoT dan aplikasi lain. <br><br><h1>  Di mana saya bisa menggunakan MQTT? </h1><br>  Karena aplikasi IoT sekarang sedang diimplementasikan dalam skala besar, MQTT telah mengemuka sebagai cara yang terbuka, sederhana, dan dapat diskalakan untuk menggunakan komputasi terdistribusi dan fungsi IoT untuk basis pengguna yang lebih luas - baik di pasar konsumen dan industri. <br><br>  Seperti yang dinyatakan di atas, MQTT adalah protokol pengiriman pesan ringan yang dibuat untuk jaringan dan perangkat yang tidak terpercaya dengan pembatasan catu daya dan CPU.  Namun, ini tidak berarti bahwa koneksi dengan paket loss potensial adalah satu-satunya aplikasi.  MQTT menyediakan berbagai tingkat layanan untuk berbagai jenis infrastruktur IoT, dari pengulangan pengambilan sampel data hingga mengelola mesin industri: <br><br><ul><li>  <b>Data Sensor Lingkungan</b> : Seperti yang telah disebutkan, MQTT mendukung model pengiriman pesan “tidak lebih dari sekali”.  Dalam jaringan dengan cakupan parsial atau latensi tinggi, ini berarti bahwa informasi dapat hilang atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">digandakan</a> .  Di area di mana sensor jarak jauh merekam dan mengirimkan data pada interval yang ditentukan, ini bukan masalah, karena bacaan baru diterima secara teratur.  Sensor di lingkungan terpencil biasanya merupakan perangkat berdaya rendah, menjadikan MQTT solusi ideal untuk sensor IoT dengan prioritas transfer data yang relatif rendah. <br></li><li>  <b>Data kinerja alat berat</b> : untuk dengan cepat merespons masalah dan mencegah downtime.  Misalnya, instalasi tenaga angin memerlukan jaminan pengiriman indikator kinerja saat ini kepada tim lokal bahkan sebelum informasi ini mencapai pusat data.  Dalam situasi seperti itu, penyampaian pesan “setidaknya satu kali” memastikan bahwa spesialis yang tepat segera diperhatikan oleh spesialis yang diperlukan, bahkan jika mereka datang sebagai duplikat.  Ini penting untuk komunikasi alat berat dengan prioritas lebih tinggi. <br></li><li>  <b>Sistem penagihan</b> : bahkan ada lebih banyak prioritas dan pesan akurat yang perlu diproses dengan benar.  Dalam situasi bisnis di mana duplikasi catatan tidak dapat diterima, termasuk dalam sistem penagihan, bendera QoS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"tepat sekali"</a> berguna.  Ini menghilangkan duplikasi atau kehilangan paket dalam sistem penagihan atau penagihan, mengurangi jumlah anomali dan kontradiksi yang tidak perlu seperti yang disepakati. </li></ul><br><h1>  Kapan tidak menggunakan MQTT? </h1><br>  Pengembang memiliki berbagai pilihan protokol untuk merancang dan menggunakan saluran komunikasi dua arah IoT, termasuk MQTT, HTTP, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CoAP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebSockets</a> (jika CPU / baterai memungkinkan) dan lainnya.  Apakah MQTT adalah pilihan terbaik tergantung pada perangkat keras dan tugas aplikasi. <br><br>  Dirancang untuk lingkungan dengan bandwidth yang sangat rendah, protokol MQTT bisa sangat tidak fleksibel dalam upayanya untuk menghemat setiap byte.  Misalnya, spesifikasi hanya menetapkan lima pesan kesalahan yang dapat digunakan server untuk menolak koneksi (misalnya, nama pengguna / kata sandi tidak valid atau versi protokol yang tidak dapat diterima).  Jika server ingin menunjukkan beberapa kesalahan lain, itu tidak beruntung.  Lebih buruk lagi, jika kesalahan terjadi setelah memulai koneksi, tidak ada mekanisme untuk melaporkan kesalahan sama sekali.  Server hanya dapat mengangkat bahu dan tiba-tiba mengganggu koneksi TCP, meninggalkan klien tanpa petunjuk mengapa mereka menjatuhkannya (dan tanpa cara untuk membedakan pemutusan yang disengaja dari masalah jaringan sementara).  Bagi orang-orang yang terbiasa dengan protokol pub / sub yang lebih fleksibel dan mudah di-debug (meskipun kurang ekonomis), pendekatan Spartan semacam itu mungkin tampak sedikit primitif. <br><br>  MQTT sering disebut bersamaan dengan HTTP, jadi Google melakukan penelitian yang membandingkannya dalam waktu respons, volume lalu lintas, dan atribut lainnya yang penting bagi pengembang.  MQTT mengambil tempat pertama dalam pengujian Google, tetapi <i>hanya dalam kondisi ketika koneksi dapat digunakan kembali</i> untuk mengirim beberapa muatan. <br><br>  HTTP dan MQTT adalah pilihan yang baik untuk aplikasi IoT karena jumlah lalu lintas yang relatif kecil, baterai rendah dan persyaratan memori. <br><br>  CoAP adalah protokol lain yang sering dibandingkan dengan MQTT untuk mengembangkan sistem IoT.  Mereka serupa, tetapi ada perbedaan yang nyata.  MQTT adalah protokol banyak-ke-banyak, sedangkan CoAP pada dasarnya adalah protokol satu-ke-satu untuk komunikasi antara server dan klien.  Pada saat yang sama, CoAP menyediakan fitur metadata, penemuan, dan negosiasi konten <i>yang tidak dimiliki MQTT</i> . <br><br>  Dalam kasus di mana klien hanya menerima data, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Server-Sent Events</a> juga merupakan opsi yang sesuai. <br><br><h1>  Cara mengatur MQTT dengan cepat </h1><br>  Repositori MQTT di GitHub memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar pustaka MQTT open source</a> dalam berbagai bahasa.  Berikut ini adalah dua contoh kustomisasi menggunakan broker MQTT open source, perpustakaan JavaScript, dan perpustakaan .NET. <br><br><h3>  Eclipse Mosquitto - broker MQTT open source </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eclipse Mosquitto</a> adalah broker pesan sumber terbuka (EPL / EDL) yang mengimplementasikan protokol MQTT versi 5.0, 3.1.1 dan 3.1.  Mosquitto ringan dan cocok untuk digunakan di semua perangkat: mulai dari komputer papan tunggal berdaya rendah hingga server penuh. <br><br><h3>  MQTT.js </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MQTT.js</a> adalah pustaka klien untuk protokol MQTT, ditulis dalam JavaScript untuk Node.js dan browser.  Berikut ini adalah contoh pengiriman pesan menggunakan MQTT.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mqtt = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'mqtt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = mqtt.connect(<span class="hljs-string"><span class="hljs-string">'mqtt://test.mosquitto.org'</span></span>) client.on(<span class="hljs-string"><span class="hljs-string">'connect'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ client.subscribe(<span class="hljs-string"><span class="hljs-string">'presence'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!err) { client.publish(<span class="hljs-string"><span class="hljs-string">'presence'</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello mqtt'</span></span>) } }) }) client.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">topic, message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// message is Buffer console.log(message.toString()) client.end() })</span></span></code> </pre> <br><h3>  MQTTnet </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MQTTnet</a> adalah .NET library berkinerja tinggi yang menyediakan klien dan server MQTT (broker). <br><br>  Instalasi Klien MQTT: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Create a new MQTT client. var factory = new MqttFactory(); var mqttClient = factory.CreateMqttClient();</span></span></code> </pre> <br>  Setelah Anda mengkonfigurasi pengaturan klien MQTT, Anda dapat membuat koneksi.  Kode berikut menunjukkan cara menyambung ke server: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Use WebSocket connection. var options = new MqttClientOptionsBuilder() .WithWebSocketServer("broker.hivemq.com:8000/mqtt") .Build(); await client.ConnectAsync(options);</span></span></code> </pre> <br>  Terima pesan masuk: <br><br><pre> <code class="cpp hljs">client.UseApplicationMessageReceivedHandler(e =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"### RECEIVED APPLICATION MESSAGE ###"</span></span>); Console.WriteLine($<span class="hljs-string"><span class="hljs-string">"+ Topic = {e.ApplicationMessage.Topic}"</span></span>); Console.WriteLine($<span class="hljs-string"><span class="hljs-string">"+ Payload = {Encoding.UTF8.GetString(e.ApplicationMessage.Payload)}"</span></span>); Console.WriteLine($<span class="hljs-string"><span class="hljs-string">"+ QoS = {e.ApplicationMessage.QualityOfServiceLevel}"</span></span>); Console.WriteLine($<span class="hljs-string"><span class="hljs-string">"+ Retain = {e.ApplicationMessage.Retain}"</span></span>); Console.WriteLine(); Task.Run(() =&gt; client.PublishAsync(<span class="hljs-string"><span class="hljs-string">"hello/world"</span></span>)); });</code> </pre> <br>  Publikasi Posting: <br><br><pre> <code class="cpp hljs">var message = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MqttApplicationMessageBuilder() .WithTopic(<span class="hljs-string"><span class="hljs-string">"MyTopic"</span></span>) .WithPayload(<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>) .WithExactlyOnceQoS() .WithRetainFlag() .Build(); await client.PublishAsync(message);</code> </pre> <br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi MQTTnet dan wiki untuk contoh lebih lanjut</a> . <br><br>  Penyedia tingkat perusahaan memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">server MQTT yang siap digunakan</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengiriman</a> pesan yang dapat diskalakan antara aplikasi seluler, mesin industri, dan beragam penggunaan IoT lainnya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan</a> ini memberi tahu Anda cara menggunakan MQTT melalui broker tingkat perusahaan. <br><br><h1>  Bagaimana dengan penskalaan? </h1><br>  Ketika berbicara tentang penskalaan MQTT, ada dua pertimbangan untuk dipertimbangkan: 1) apakah ini protokol yang benar;  2) terlepas dari pilihan protokol, infrastruktur dan kapabilitas jaringan apa yang diperlukan untuk menangani peningkatan lalu lintas antar perangkat yang menggunakan MQTT. <br><br>  Mesin-ke-Mesin Ringan (LWM2M) adalah protokol lain yang dapat digunakan dengan MQTT di tingkat perusahaan.  Dibandingkan dengan MQTT, kadang-kadang <i>lebih cocok untuk sistem IoT jangka panjang</i> .  MQTT sangat ideal untuk uji coba IoT dengan mudah, sementara LWM2M menyediakan fitur untuk infrastruktur jangka panjang yang serbaguna.  LWM2M juga menyediakan alat manajemen perangkat yang unggul seperti pemantauan koneksi, pembaruan firmware, dan tindakan perangkat jarak jauh.  Untuk perusahaan dengan sejumlah besar perangkat tidak terkelola yang mengirim sejumlah besar data ke platform pusat, LWM2M adalah pilihan terbaik.  Namun demikian, kita berbicara tentang penyebaran IoT skala besar, jadi biasanya MQTT lebih dari pilihan yang memadai.  Selain itu, MQTT lebih umum dan memiliki dukungan yang lebih luas. <br><br>  Sekarang tentang kemungkinan infrastruktur.  Ketika datang ke server loading, jumlah koneksi simultan jarang menjadi hambatan.  Sebagian besar server / broker MQTT yang baik mendukung ribuan koneksi bersamaan, tetapi berapa beban kerja yang diperlukan untuk memproses dan membalas pesan setelah server MQTT menerima data aktual?  Sebagai aturan, ada semua jenis masalah potensial, seperti membaca dan menulis ke dan dari basis data, integrasi dengan server, distribusi dan pengelolaan sumber daya untuk setiap klien, dll. Begitu satu mesin berhenti untuk mengatasi beban, Anda perlu menambahkan server tambahan, yaitu, pikirkan tentang penyeimbangan beban, sinkronisasi pesan antara klien yang terhubung ke server yang berbeda, akses umum ke keadaan klien, terlepas dari waktu koneksi atau server tertentu yang terhubung dengan klien - daftar produk  zhaetsya dan terus. <br><br>  Masalah seperti itu pantas mendapatkan artikel terpisah, dan banyak informasi dapat ditemukan di bagian Teknik di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog kami</a> .  Secara khusus, lihat artikel tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa kompleksitas pelayanan infrastruktur pengiriman pesan waktu-nyata berskala besar</a> . <br><br><h1>  Bagaimana situasi saat ini dengan MQTT? </h1><br>  Pada April 2019, OASIS merilis MQTT v5.0 sebagai standar resmi.  OASIS adalah konsorsium nirlaba dari 600 organisasi anggota dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5.000 anggota individu</a> . <br><br>  Versi 5.0 memperkenalkan sejumlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fitur baru</a> yang seharusnya menarik bagi pengembang sistem waktu-nyata.  Fitur-fitur baru ini kompatibel dengan versi MQTT saat ini.  Diantaranya adalah: <br><br><ul><li>  <b>Pelaporan kesalahan yang ditingkatkan</b> : kode pengembalian sekarang dapat menginformasikan bahwa data tidak sedang dikirim karena alasan tertentu.  String opsional didukung untuk menunjukkan alasannya.  Mereka membantu meningkatkan diagnostik pemecahan masalah. <br></li><li>  <b>Berbagi Langganan</b> : Untuk membantu menyeimbangkan beban, langganan dapat dibagi di antara banyak klien di sisi penerima. <br></li><li>  <b>Properti Pesan</b> : Versi 5.0 memperkenalkan metadata sebagai bagian dari header pesan.  Ini dapat menyampaikan informasi tambahan kepada pengguna akhir atau memfasilitasi beberapa fungsi lain yang tercantum di bawah ini. <br></li><li>  <b>Alias ​​Saluran</b> : Penerbit dapat mengganti saluran dengan pengenal angka untuk mengurangi jumlah byte yang akan ditransmisikan. <br></li><li>  Tanggal <b>kedaluwarsa</b> pesan: pesan dapat ditandai untuk dihapus secara otomatis jika sistem tidak dapat mengirimkannya dalam jangka waktu tertentu. </li></ul><br>  Untuk daftar lengkap fitur MQTT 5.0 yang baru, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lampiran C</a> pada standar resmi. <br><br>  Selain banyak perangkat dan layanan konsumen di pasar, MQTT telah digunakan dalam infrastruktur perusahaan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">segala bentuk dan ukuran</a> .  Ini adalah smartphone dan tablet, sistem pemantauan energi, perangkat medis, rig minyak dan rig, industri otomotif dan luar angkasa, serta sensor dan sistem visi mesin yang digunakan dalam penanganan material, konstruksi, rantai pasokan, ritel, dan banyak lagi. <br><br><h1>  MQTT dan Ably </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MQTT</a> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">protokol</a> yang populer, didukung secara luas, dan relatif matang.  Ini bagus untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak aplikasi waktu nyata</a> , dan tidak hanya untuk menggunakan IoT.  Namun, karena produksi dan konsumsi data real-time terus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumbuh secara eksponensial</a> , MQTT mungkin tidak selalu menjadi protokol yang tepat untuk memenuhi kebutuhan streaming Anda.  Ikuti bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konsep Realtime</a> kami untuk informasi tentang protokol lain dan bagaimana mereka sesuai dengan situasi Anda. <br><br>  Ably menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">broker dan adaptor protokol MQTT</a> dengan terjemahan ke protokol Ably sendiri di kedua arah, yang memungkinkan Anda untuk berintegrasi dengan sistem dan koneksi yang ada.  Soket Web yang didukung, HTTP, SSE, gRPC (sedang dikembangkan), STOMP, AMQP, dan protokol lainnya untuk mengatur infrastruktur pengiriman pesan yang didistribusikan secara real time.  Ada lebih dari 40 perpustakaan klien SDK dan dukungan untuk protokol waktu nyata milik. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463669/">https://habr.com/ru/post/id463669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463655/index.html">Kelahiran satu proyek atau cara menulis CMS Anda sendiri</a></li>
<li><a href="../id463657/index.html">Chatbots menyebalkan</a></li>
<li><a href="../id463663/index.html">10 buku untuk memahami struktur pasar saham, investasi di bursa saham dan perdagangan otomatis</a></li>
<li><a href="../id463665/index.html">1,1 miliar naik taksi: klaster ClickHouse 108-inti</a></li>
<li><a href="../id463667/index.html">Forest tidak menyerah pada teknologi pencarian, tetapi para insinyur menyerang balik</a></li>
<li><a href="../id463673/index.html">6 alasan untuk membuka startup IT di Kanada</a></li>
<li><a href="../id463675/index.html">Alkimia personel: apa komposisi optimal tim pusat GosSOPKA?</a></li>
<li><a href="../id463677/index.html">Team Lead di remote: bagaimana saya bepergian dengan keluarga saya dan bekerja dari Yunani dan Vietnam</a></li>
<li><a href="../id463681/index.html">Anggaran gembur untuk GPU. Kenalan dan pengalaman pertama</a></li>
<li><a href="../id463683/index.html">Tinjauan Umum Solusi Koreksi Typo Terbuka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>