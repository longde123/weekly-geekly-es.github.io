<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§õüèΩ üë©üèø‚Äç‚úàÔ∏è üêû Game 3D Shaders for Beginners: Effects üï∫üèø üßëüèø‚Äçü§ù‚Äçüßëüèª üéà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Bagian pertama ] 

 Setelah membahas dasar-dasarnya, pada bagian artikel ini kami menerapkan efek seperti garis besar objek, bloom, SSAO, blur, keda...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Game 3D Shaders for Beginners: Effects</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453692/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a> ] <br><br>  Setelah membahas dasar-dasarnya, pada bagian artikel ini kami menerapkan efek seperti garis besar objek, bloom, SSAO, blur, kedalaman bidang, pixelation, dan lainnya. <br><br><h2>  Garis besar </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/96f/9b2/3b896f9b246e1695fa908b4bdc145480.gif"></div><br>  Menciptakan kontur di sekitar geometri adegan memberikan permainan tampilan yang unik yang menyerupai komik atau kartun. <br><br><h3>  Bahan difus </h3><br>  Shader kontur membutuhkan tekstur input untuk mengenali dan mewarnai pinggirannya.  Calon untuk tekstur yang masuk dapat warna difus dari bahan, warna dari tekstur difus, vertex normal, atau bahkan warna dari peta normal. <br><br><pre><code class="cpp hljs">uniform <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> vec4 diffuse ; } p3d_Material; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 diffuseColor = p3d_Material.diffuse.rgb; fragColor = vec4(diffuseColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Ini adalah shader fragmen kecil yang membuat warna difus dari bahan geometri menjadi tekstur penyangga bingkai.  Tekstur warna difus ini dari buffer bingkai akan menjadi tekstur input untuk path shader. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/abd/05c/f0babd05caf7104156c15929995c9279.gif"></div><br>  Ini adalah tekstur warna bahan yang difus dari frame buffer, yang menampilkan warna yang kami atur di Blender.  Shader kontur akan mengenali tepi dalam adegan dan mewarnai mereka. <br><br>  Perlu dicatat bahwa warna bahan yang menyebar tidak akan berfungsi jika bagian tertentu dari pemandangan tidak memiliki warna bahan yang menyebar sendiri. <br><br><h3>  Membuat Tepian </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/a0d/57a/33aa0d57aeba90366ddd95865ea0d6c6.gif"></div><br>  Membuat edge mirip dengan menggunakan filter edge recognition di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GIMP</a> . <br><br>  Semua perhitungan untuk teknik naungan ini dilakukan dalam shader fragmen.  Untuk membuat kontur untuk shader vertex, cukup untuk melewati empat simpul dari mesh persegi panjang ke output agar sesuai dengan layar. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D materialDiffuseTexture; // ... vec2 texSize = textureSize(materialDiffuseTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy; // ...</span></span></code> </pre> <br>  Sebelum Anda mulai mengenali ujung-ujungnya, Anda perlu menyiapkan tekstur yang masuk, yang dengannya kami akan bekerja.  Karena tekstur memiliki ukuran layar, kita dapat menghitung koordinat UV, mengetahui koordinat fragmen dan ukuran tekstur yang masuk. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int separation = 1; // ...</span></span></code> </pre> <br>  <code>separation</code> dapat disesuaikan dengan selera Anda.  Semakin besar pemisahan, semakin tebal bagian tepi atau garis. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... vec4 mx = vec4(0); vec4 mn = vec4(1); int x = -1; int y = -1; for (int i = 0; i &lt; 9; ++i) { vec4 color = texture ( materialDiffuseTexture , (texCoord + (vec2(x, y) * separation)) / texSize ); mx = max(color, mx); mn = min(color, mn); x += 1; if (x &gt;= 2) { x = -1; y += 1; } } float alpha = ((mx.r + mx.g + mx.b) / 3) - ((mn.r + mn.g + mn.b) / 3); if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/d24/e56/42fd24e5682700e1e7cd5186bebc33af.gif"></div><br>  Teknik pengenalan tepi menemukan perubahan warna pada tekstur yang masuk.  Berfokus pada fragmen saat ini, ia menggunakan jendela fragmen 3x3 untuk menemukan warna paling terang dan paling gelap dari sembilan sampel.  Kemudian dia mengurangi kecerahan satu warna, kecerahan yang lain, mendapatkan perbedaannya. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lineRgb = vec3(0.012, 0.014, 0.022); // ... vec4 lineColor = vec4(lineRgb, alpha); // ... fragColor = lineColor; // ...</span></span></code> </pre> <br>  Perbedaan ini digunakan dalam saluran alfa dari warna keluaran.  Jika tidak ada perbedaan, maka tepi atau garis tidak ditarik.  Jika ada perbedaan, maka ujungnya ditarik. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br>  Coba bereksperimen dengan nilai ambang.  Sekarang nol.  Nilai bukan nol menjadi tepi, ambang ini dapat diubah.  Ini sangat berguna untuk tekstur masuk yang ribut dengan perbedaan kecil.  Dalam kasus tekstur masuk yang bising, Anda biasanya perlu membuat garis besar hanya untuk perbedaan besar. <br><br><h3>  Kode sumber </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">material-difuse.frag</a> </li><li>  <a href="">outline.frag</a> </li></ul><br><h2>  Kabut </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/02c/e52/5af02ce52f813b27461f79e5dca5fe20.gif"></div><br>  Kabut (atau kabut, seperti yang disebut dalam Blender) menambah kabut atmosfer ke tempat kejadian, menciptakan bagian-bagian misterius yang melunak.  Bagian yang menonjol muncul ketika beberapa geometri tiba-tiba jatuh ke dalam piramida visibilitas kamera. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_FogParameters { vec4 color ; float start ; float end ; } p3d_Fog; // ...</span></span></code> </pre> <br>  Panda3D memiliki struktur data yang nyaman yang berisi semua parameter kabut, tetapi Anda dapat mentransfernya ke shader Anda secara manual. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float fogIntensity = clamp ( ( p3d_Fog.end - vertexPosition.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; // ...</span></span></code> </pre> <br>  Dalam contoh kode, model linier digunakan untuk menghitung kecerahan kabut saat bergerak menjauh dari kamera.  Sebagai gantinya, Anda dapat menggunakan model eksponensial.  Kecerahan kabut adalah nol sebelum atau di awal kabut.  Ketika posisi puncak mendekati akhir kabut, <code>fogIntensity</code> mendekati kesatuan.  Untuk semua simpul setelah akhir kabut, <code>fogIntensity</code> terbatas pada 1 dari atas. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = mix ( outputColor , p3d_Fog.color , fogIntensity ); // ...</span></span></code> </pre> <br>  Berdasarkan kecerahan kabut, kami mencampur warna kabut dengan warna output.  Saat <code>fogIntensity</code> mendekati kesatuan, akan ada semakin sedikit <code>outputColor</code> dan semakin banyak warna kabut.  Ketika <code>fogIntensity</code> mencapai kesatuan, hanya warna kabut yang akan tersisa. <br><br><h3>  Kabut pada kontur </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/ee8/d49/e1fee8d490abe10ecb798df618f183f7.gif"></div><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D positionTexture; // ... vec4 position = texture(positionTexture, texCoord / texSize); float fogIntensity = clamp ( ( p3d_Fog.end - position.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; vec4 lineWithFogColor = mix ( lineColor , p3d_Fog.color , fogIntensity ); fragColor = vec4(lineWithFogColor.rgb, alpha); // ...</span></span></code> </pre> <br>  Path Shader menerapkan kabut ke warna tepi untuk gambar yang lebih holistik.  Jika dia tidak melakukan ini, maka geometri kontur akan dikaburkan oleh kabut, yang akan terlihat aneh.  Namun, ia masih membuat kontur pada tepi terluar dari geometri panggung dengan gilingan, karena tepiannya melampaui geometri - ke tempat di mana tidak ada posisi titik. <br><br>  <code>positionTexture</code> adalah tekstur penyangga bingkai yang berisi posisi simpul ruang tampilan.  Anda akan belajar tentang ini ketika kami menerapkan shader SSAO. <br><br><h3>  Kode sumber </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">base.frag</a> </li><li>  <a href="">outline.frag</a> </li></ul><br><h2>  Bloom </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/744/f35/31d744f35168ac87f609474998802b12.gif"></div><br>  Menambahkan mekar ke pemandangan dapat membuat ilusi yang meyakinkan dari model pencahayaan.  Objek yang memancarkan cahaya menjadi lebih meyakinkan, dan pantulan cahaya menerima sejumlah cahaya tambahan. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//... float separation = 3; int samples = 15; float threshold = 0.5; float amount = 1; // ...</span></span></code> </pre> <br>  Anda dapat menyesuaikan pengaturan ini sesuai dengan keinginan Anda.  Pemisahan meningkatkan ukuran blur.  Sampel menentukan kekuatan blur.  Ambang batas menentukan apa yang akan dan tidak akan terpengaruh oleh efek ini.  Jumlah mengontrol jumlah output mekar. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int size = samples; int size2 = size * size; int x = 0; int y = 0; // ... float value = 0; vec4 result = vec4(0); vec4 color = vec4(0); // ... for (int i = 0; i &lt; size2; ++i) { // ... } // ...</span></span></code> </pre> <br>  Teknik ini dimulai dengan melewatkan <code>samples</code> berukuran jendela ke <code>samples</code> berpusat relatif terhadap fragmen saat ini.  Sepertinya jendela yang digunakan untuk membuat jalur. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... color = texture ( bloomTexture , ( gl_FragCoord.xy + vec2(x * separation, y * separation) ) / texSize ); value = ((0.3 * color.r) + (0.59 * color.g) + (0.11 * color.b)); if (value &lt; threshold) { color = vec4(0); } result += color; // ...</span></span></code> </pre> <br>  Kode ini mendapatkan warna dari tekstur yang masuk dan mengubah nilai merah, hijau, dan biru menjadi nilai dalam skala abu-abu.  Jika nilai dalam skala abu-abu kurang dari ambang, maka membuang warna ini, menjadikannya hitam. <br><br>  Melewati semua sampel di dalam jendela, ia mengakumulasikan semua nilainya dalam <code>result</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... result = result / size2; // ...</span></span></code> </pre> <br>  Setelah menyelesaikan pengumpulan sampel, ia membagi jumlah sampel warna dengan jumlah sampel yang diambil.  Hasilnya adalah warna tengah fragmen itu sendiri dan tetangganya.  Dengan melakukannya untuk setiap fragmen, kami mendapatkan gambar buram.  Jenis blur ini disebut blur kotak. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/16f/ea4/f9016fea492bc7b136ef6437a683c937.gif"></div><br>  Di sini Anda melihat proses mengeksekusi algoritma bloom. <br><br><h3>  Kode sumber </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">bloom.frag</a> </li></ul><br><h2>  Layar Space Ambient Occlusion (SSAO) </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/5ab/5bf/f935ab5bf4794caae3be90b611ad771c.gif"></div><br>  SSAO adalah salah satu efek yang Anda tidak tahu ada, tetapi begitu Anda tahu Anda tidak bisa lagi hidup tanpanya.  Dia bisa mengubah adegan biasa-biasa saja menjadi yang menakjubkan!  Dalam adegan statis, oklusi ambien dapat dimasukkan ke dalam tekstur, tetapi untuk adegan yang lebih dinamis kita membutuhkan shader.  SSAO adalah salah satu teknik shading yang lebih canggih, tetapi begitu Anda mengetahuinya, Anda akan menjadi master shader. <br><br>  Perhatikan bahwa istilah "ruang layar" dalam judul tidak sepenuhnya benar, karena tidak semua perhitungan dilakukan dalam ruang layar. <br><br><h3>  Data yang masuk </h3><br>  Shader SSAO akan membutuhkan input berikut. <br><br><ul><li>  Vektor posisi titik di ruang tampilan. </li><li>  Vektor normal ke simpul di ruang tampilan. </li><li>  Sampel vektor dalam ruang singgung. </li><li>  Vektor kebisingan di ruang singgung. </li><li>  Matriks proyeksi pada lensa kamera. </li></ul><br><h3>  Posisi </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/f36/d42/2d2f36d425c2596288d8982158687354.png"></div><br>  Tidak perlu menyimpan posisi simpul dalam tekstur frame buffer.  Kami dapat membuatnya kembali dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">buffer kedalaman kamera</a> .  Saya menulis panduan untuk pemula, jadi kami tidak akan menggunakan pengoptimalan ini, dan segera memulai bisnis.  Dalam implementasi Anda, Anda dapat dengan mudah menggunakan buffer kedalaman. <br><br><pre> <code class="cpp hljs">PT(Texture) depthTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture(<span class="hljs-string"><span class="hljs-string">"depthTexture"</span></span>); depthTexture-&gt;set_format(Texture::Format::F_depth_component32); PT(GraphicsOutput) depthBuffer = graphicsOutput-&gt;make_texture_buffer(<span class="hljs-string"><span class="hljs-string">"depthBuffer"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, depthTexture); depthBuffer-&gt;set_clear_color(LVecBase4f(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); NodePath depthCameraNP = window-&gt;make_camera(); DCAST(Camera, depthCameraNP.node())-&gt;set_lens(window-&gt;get_camera(<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;get_lens()); PT(DisplayRegion) depthBufferRegion = depthBuffer-&gt;make_display_region(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); depthBufferRegion-&gt;set_camera(depthCameraNP);</code> </pre> <br>  Jika Anda memutuskan untuk menggunakan buffer kedalaman, berikut adalah cara Anda dapat mengonfigurasinya di Panda3D. <br><br><pre> <code class="cpp hljs">in vec4 vertexPosition; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fragColor = vertexPosition; }</code> </pre> <br>  Berikut ini adalah shader sederhana untuk merender posisi simpul di ruang tampilan menjadi tekstur penyangga bingkai.  Tugas yang lebih sulit adalah menyesuaikan tekstur buffer bingkai sehingga komponen-komponen vektor fragmen yang diperolehnya tidak terbatas pada interval <code>[0, 1]</code> , dan bahwa masing-masing memiliki akurasi yang cukup tinggi (jumlah bit yang cukup besar).  Misalnya, jika beberapa jenis posisi vertex interpolasi adalah <code>&lt;-139.444444566, 0.00000034343, 2.5&gt;</code> , maka Anda tidak dapat menyimpannya ke tekstur sebagai <code>&lt;0.0, 0.0, 1.0&gt;</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... FrameBufferProperties fbp = FrameBufferProperties::get_default(); // ... fbp.set_rgba_bits(32, 32, 32, 32); fbp.set_rgb_color(true); fbp.set_float_color(true); // ...</span></span></code> </pre> <br>  Berikut adalah contoh kode yang menyiapkan tekstur buffer bingkai untuk menyimpan posisi titik.  Ia membutuhkan 32 bit untuk merah, hijau, biru dan alfa, sehingga ia menonaktifkan batasan nilai dengan interval <code>[0, 1]</code> .  Panggilan ke <code>set_rgba_bits(32, 32, 32, 32)</code> mengatur volume bit dan menonaktifkan pembatasan. <br><br><pre> <code class="cpp hljs"> glTexImage2D ( GL_TEXTURE_2D , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB32F , <span class="hljs-number"><span class="hljs-number">1200</span></span> , <span class="hljs-number"><span class="hljs-number">900</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB , GL_FLOAT , <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> );</code> </pre> <br>  Ini adalah panggilan serupa di OpenGL.  <code>GL_RGB32F</code> menetapkan bit dan menonaktifkan pembatasan. <br><br><blockquote>  Jika penyangga warna memiliki koma tetap, maka komponen nilai awal dan akhir, serta indeks pencampuran, sebelum menghitung persamaan pencampuran dibatasi masing-masing untuk [0, 1] atau [‚àí1, 1], untuk buffer warna yang dinormalisasi dan ditandatangani, ditandai dan ditandatangani.  Jika buffer warna memiliki titik apung, maka batasannya tidak terpenuhi. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Sumber</a> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17b/2d0/2ad/17b2d02ad53c411dc251d90fdc16fdf3.png"></div><br>  Di sini Anda melihat posisi simpul;  sumbu y naik. <br><br>  Ingat bahwa Panda3D mendefinisikan sumbu z sebagai vektor yang mengarah ke atas, sedangkan di OpenGL sumbu y mencari ke atas.  Shader posisi menampilkan posisi simpul dengan z ke atas, karena di Panda3D <br>  parameter <code>gl-coordinate-system default</code> dikonfigurasi. <br><br><h3>  Normal </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c4/064/9c5/0c40649c525edd7bcf3c829d6e948789.gif"></div><br>  Untuk orientasi yang benar dari sampel yang diperoleh dalam shader SSAO, kita perlu normals ke simpul.  Kode sampel menghasilkan beberapa vektor sampel yang didistribusikan di belahan bumi, tetapi Anda dapat menggunakan bola dan sepenuhnya menyelesaikan masalah kebutuhan akan normals. <br><br><pre> <code class="cpp hljs">in vec3 vertexNormal; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 normal = normalize(vertexNormal); fragColor = vec4(normal, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Seperti posisi shader, shader normal sangat sederhana.  Ingatlah untuk menormalkan normals ke simpul dan ingat bahwa mereka berada di ruang pandang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/a82/f00/57ba82f003b0ab9c2aafa7c9affa28bb.gif"></div><br>  Normal ke simpul ditunjukkan di sini;  sumbu y naik. <br><br>  Ingat bahwa Panda3D menganggap sumbu z sebagai vektor ke atas, dan OpenGL ke sumbu y.  Shader normal menampilkan posisi simpul dengan sumbu z mengarah ke atas, karena <code>gl-coordinate-system default</code> dikonfigurasikan dalam Panda3D. <br><br><h3>  Sampel </h3><br>  Untuk menentukan nilai oklusi ambien untuk setiap fragmen tunggal, kita perlu mengambil sampel area sekitarnya. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; numberOfSamples; ++i) { LVecBase3f sample = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) ).normalized(); float rand = randomFloats(generator); sample[0] *= rand; sample[1] *= rand; sample[2] *= rand; float scale = (float) i / (float) numberOfSamples; scale = lerp(0.1, 1.0, scale * scale); sample[0] *= scale; sample[1] *= scale; sample[2] *= scale; ssaoSamples.push_back(sample); } // ...</span></span></code> </pre> <br>  Kode sampel menghasilkan 64 sampel acak yang didistribusikan di belahan bumi.  <code>ssaoSamples</code> ini akan diteruskan ke shader SSAO. <br><br><pre> <code class="cpp hljs"> LVecBase3f sample = LVecBase3f ( randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> ).normalized();</code> </pre> <br>  Jika Anda ingin mendistribusikan sampel Anda di bola, maka ubah interval komponen acak z sehingga itu berubah dari minus satu ke satu. <br><br><h3>  Kebisingan </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; 16; ++i) { LVecBase3f noise = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , 0.0 ); ssaoNoise.push_back(noise); } // ...</span></span></code> </pre> <br>  Untuk menutupi area sampel dengan baik, kita perlu menghasilkan vektor kebisingan.  Vektor kebisingan ini dapat memutar sampel di sekitar bagian atas permukaan. <br><br><h3>  Oklusi ambien </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c1d/bb4/d35c1dbb4e0e9dfeedc3bd4285f26004.gif"></div><br>  SSAO menyelesaikan tugasnya dengan mengambil sampel ruang tampilan di sekitar fragmen.  Semakin banyak sampel di bawah permukaan, semakin gelap warna fragmen.  Sampel-sampel ini terletak di fragmen dan menunjukkan arah umum normal ke verteks.  Setiap sampel digunakan untuk mencari posisi dalam tekstur posisi penyangga bingkai.  Posisi yang dikembalikan dibandingkan dengan sampel.  Jika sampel lebih jauh dari kamera daripada posisi, maka sampel ke arah fragmen tersumbat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/b9a/f1d/cb7b9af1d4dc613f337da5a253ef5a8c.gif"></div><br>  Di sini Anda melihat ruang di atas permukaan sampel untuk penyumbatan. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float radius = 1.1; float bias = 0.026; float lowerRange = -2; float upperRange = 2; // ...</span></span></code> </pre> <br>  Seperti beberapa teknik lainnya, shader SSAO memiliki beberapa parameter kontrol yang dapat diubah untuk mendapatkan tampilan yang diinginkan.  Bias ditambahkan ke jarak dari sampel ke kamera.  Parameter ini dapat digunakan untuk memerangi noda.  radius menambah atau mengurangi area cakupan ruang sampel.  lowerRange dan upperRange mengubah rentang standar metrik faktor dari <code>[0, 1]</code> ke nilai apa pun yang Anda pilih.  Dengan meningkatkan rentang, Anda dapat meningkatkan kontras. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); vec3 normal = texture(normalTexture, texCoord).xyz; int noiseX = int(gl_FragCoord.x - 0.5) % 4; int noiseY = int(gl_FragCoord.y - 0.5) % 4; vec3 random = noise[noiseX + (noiseY * 4)]; // ...</span></span></code> </pre> <br>  Kami mendapatkan posisi, vektor normal dan acak untuk digunakan lebih lanjut.  Ingatlah bahwa dalam contoh kode, 16 vektor acak telah dibuat.  Vektor acak dipilih berdasarkan posisi layar dari fragmen saat ini. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 tangent = normalize(random - normal * dot(random, normal)); vec3 binormal = cross(normal, tangent); mat3 tbn = mat3(tangent, binormal, normal); // ...</span></span></code> </pre> <br>  Menggunakan vektor acak dan vektor normal, kami mengumpulkan matriks garis singgung, binormal, dan normal.  Kita perlu matriks ini untuk mengubah vektor sampel dari ruang singgung ke ruang survei. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float occlusion = NUM_SAMPLES; for (int i = 0; i &lt; NUM_SAMPLES; ++i) { // ... } // ...</span></span></code> </pre> <br>  Memiliki matriks, shader dapat mengulangi semua sampel dalam loop, mengurangi jumlah yang belum dibuka. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 sample = tbn * samples[i]; sample = position.xyz + sample * radius; // ...</span></span></code> </pre> <br>  Menggunakan matriks, tempatkan sampel di sebelah posisi vertex / fragmen dan skala dengan jari-jari. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offset = vec4(sample, 1.0); offset = lensProjection * offset; offset.xyz /= offset.w; offset.xyz = offset.xyz * 0.5 + 0.5; // ...</span></span></code> </pre> <br>  Dengan menggunakan posisi sampel di ruang tampilan, kami mentransformasikannya dari ruang tampilan ke ruang kliping, dan kemudian ke ruang UV. <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">-1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Jangan lupa bahwa komponen ruang kliping berada dalam kisaran dari minus satu ke satu, dan koordinat UV berada dalam kisaran dari nol hingga satu.  Untuk mengkonversi koordinat ruang kliping ke koordinat UV, gandakan dengan satu detik dan tambahkan satu detik. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offsetPosition = texture(positionTexture, offset.xy); float occluded = 0; if (sample.y + bias &lt;= offsetPosition.y) { occluded = 0; } else { occluded = 1; } // ...</span></span></code> </pre> <br>  Menggunakan koordinat offset UV yang diperoleh dengan memproyeksikan sampel 3D ke tekstur posisi 2D, kami menemukan vektor posisi yang sesuai.  Ini membawa kita dari ruang tampilan ke ruang kliping ke ruang UV dan kemudian kembali ke ruang tampilan.  Shader menjalankan loop ini untuk menentukan apakah ada geometri di belakang sampel, di lokasi sampel, atau di depan sampel.  Jika sampel terletak di depan atau dalam beberapa geometri, maka sampel ini tidak diperhitungkan relatif terhadap fragmen yang tumpang tindih.  Jika sampel berada di belakang beberapa geometri, maka sampel ini diperhitungkan relatif terhadap fragmen yang tumpang tindih. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float intensity = smoothstep ( 0.0 , 1.0 , radius / abs(position.y - offsetPosition.y) ); occluded *= intensity; occlusion -= occluded; // ...</span></span></code> </pre> <br>  Sekarang tambahkan bobot pada posisi sampel ini berdasarkan seberapa jauh berada di dalam atau di luar radius.  Kemudian, kurangi sampel ini dari metrik oklusi karena mengasumsikan bahwa semua sampel tumpang tindih sebelum loop. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... occlusion /= NUM_SAMPLES; // ... fragColor = vec4(vec3(occlusion), position.a); // ...</span></span></code> </pre> <br>  Bagilah jumlah yang tumpang tindih dengan jumlah sampel untuk mengkonversi indikator oklusi dari interval <code>[0, NUM_SAMPLES]</code> ke interval <code>[0, 1]</code> .  Nol berarti oklusi lengkap, unit berarti tidak ada oklusi.  Sekarang tetapkan metrik oklusi ke warna fragmen, dan hanya itu. <br><br>  Harap dicatat bahwa dalam kode contoh, saluran alfa ditetapkan nilai alfa dari tekstur posisi dari buffer bingkai untuk menghindari latar belakang yang tumpang tindih. <br><br><h3>  Kabur </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/566/2a7/5b15662a7c46db6b8102fe9eabae17c9.gif"></div><br>  Tekstur frame buffer SSAO sedikit bising, jadi Anda harus mengaburkannya untuk menghaluskan. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( ssaoTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ).rgb; xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  SSAO blur shader adalah blur kotak biasa.  Seperti mekar shader, ia menggambar jendela di atas tekstur yang masuk dan rata-rata setiap fragmen dengan nilai-nilai tetangganya. <br><br>  Perhatikan bahwa <code>parameters.x</code> adalah parameter pemisahan. <br><br><h3>  Warna sekitar </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 ssaoBlurTexSize = textureSize(ssaoBlurTexture, 0).xy; vec2 ssaoBlurTexCoord = gl_FragCoord.xy / ssaoBlurTexSize; float ssao = texture(ssaoBlurTexture, ssaoBlurTexCoord).r; vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex * ssao; // ...</span></span></code> </pre> <br>  Tantangan terakhir untuk SSAO adalah lagi dalam perhitungan pencahayaan.  Di sini kita melihat bagaimana oklusi ditemukan dalam buffer tekstur SSAO tekstur dan termasuk dalam perhitungan cahaya sekitar. <br><br><h3>  Kode sumber </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">position.frag</a> </li><li>  <a href="">normal.frag</a> </li><li>  <a href="">ssao.frag</a> </li><li>  <a href="">blur.frag</a> </li></ul><br><h2>  Kedalaman bidang </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/eb0/10f/6efeb010f4623ff49b928d72550f7985.gif"></div><br>  Kedalaman bidang juga merupakan efek seperti itu, setelah mempelajari tentang itu, Anda tidak dapat hidup tanpanya.  Dari sudut pandang artistik, Anda dapat menggunakannya untuk menarik perhatian penonton ke objek tertentu.  Tetapi dalam kasus umum, kedalaman bidang dengan biaya sedikit usaha menambah sebagian besar realisme. <br><br><h3>  Dalam fokus </h3><br>  Langkah pertama adalah membuat adegan sepenuhnya fokus.  Render ke tekstur bingkai penyangga.  Ini akan menjadi salah satu nilai input untuk kedalaman buffer bidang. <br><br><h3>  Tidak fokus </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 result = vec4(0); for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( blurTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ); xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  Langkah kedua adalah mengaburkan adegan seolah-olah itu benar-benar tidak fokus.  Seperti halnya bloom dan SSAO, Anda bisa menggunakan box blur.  Jadikan adegan ini tidak fokus ke tekstur penyangga bingkai.  Ini akan menjadi nilai input lain untuk kedalaman shader bidang. <br><br>  Perhatikan bahwa <code>parameters.x</code> adalah parameter pemisahan. <br><br><h3>  Kebingungan </h3><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d68/067/83a/d6806783a567c4708d8f13dcb0763f7c.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float focalLengthSharpness = 100; float blurRate = 6; // ...</span></span></code> </pre> <br>  Anda dapat menyesuaikan opsi ini sesuai selera Anda.  <code>focalLengthSharpness</code> memengaruhi seberapa tidak fokusnya adegan pada focal length.  Semakin kecil <code>focalLengthSharpness</code> , semakin tidak fokus adegan akan pada focal length.  <code>blurRate</code> memengaruhi kecepatan mengaburkan adegan saat menjauh dari focal length.  Semakin kecil <code>blurRate</code> , semakin tidak buram pemandangan saat <code>blurRate</code> dari titik fokus. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 focusColor = texture(focusTexture, texCoord); vec4 outOfFocusColor = texture(outOfFocusTexture, texCoord); // ...</span></span></code> </pre> <br>  Kita akan membutuhkan warna dalam fokus dan gambar yang tidak fokus. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); // ...</span></span></code> </pre> <br>  Kita juga mungkin membutuhkan posisi titik di ruang tampilan.  Anda dapat menerapkan kembali tekstur posisi dari penyangga bingkai yang digunakan untuk SSAO. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float blur = clamp ( pow ( blurRate , abs(position.y - focalLength.x) ) / focalLengthSharpness , 0 , 1 ); // ... fragColor = mix(focusColor, outOfFocusColor, blur); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan di sini kebingungan terjadi. </font><font style="vertical-align: inherit;">Semakin dekat </font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu, semakin banyak yang akan digunakan </font></font><code>outOfFocusColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nilai nol </font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berarti bahwa fragmen ini sepenuhnya dalam fokus. </font><font style="vertical-align: inherit;">Dengan </font></font><code>blur &gt;= 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fragmen ini benar-benar tidak fokus.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode sumber </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blur.frag</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depth-of-field.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posterisasi </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/078/84d/f1807884d79c5c73915ce9adf6ead5cb.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posterisasi, atau sampling warna, adalah proses mengurangi jumlah warna unik dalam suatu gambar. </font><font style="vertical-align: inherit;">Anda dapat menggunakan shader ini untuk memberikan permainan komik atau tampilan retro. </font><font style="vertical-align: inherit;">Jika Anda menggabungkannya dengan garis besar, Anda mendapatkan gaya kartun yang nyata.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float levels = 8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat bereksperimen dengan parameter ini. </font><font style="vertical-align: inherit;">Semakin besar, semakin banyak bunga yang tersisa.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 texColor = texture(posterizeTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami akan membutuhkan warna yang masuk. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 grey = vec3((texColor.r + texColor.g + texColor.b) / 3.0); vec3 grey1 = grey; grey = floor(grey * levels) / levels; texColor.rgb += (grey - grey1); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya belum melihat metode posterisasi seperti itu. </font><font style="vertical-align: inherit;">Setelah memeriksanya, saya melihat bahwa itu menciptakan hasil yang lebih indah dibandingkan dengan metode konvensional. </font><font style="vertical-align: inherit;">Untuk mengurangi palet warna, pertama-tama konversikan warna ke nilai dalam skala abu-abu. </font><font style="vertical-align: inherit;">Kami mendiskritasikan warnanya dengan mengikatnya ke salah satu level. </font><font style="vertical-align: inherit;">Kami menghitung perbedaan antara nilai yang didiskritisasi dalam skala abu-abu dan nilai yang tidak didiskritisasi dalam skala abu-abu. </font><font style="vertical-align: inherit;">Tambahkan perbedaan ini ke warna input. </font><font style="vertical-align: inherit;">Perbedaan ini adalah jumlah di mana warna harus naik / turun untuk mencapai nilai diskritisasi dalam skala abu-abu.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texColor; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jangan lupa untuk menetapkan nilai warna input ke warna fragmen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cel shading </font></font></h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d1/f9c/133/2d1f9c1333960c0299388fc51323a8b3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posterisasi dapat membuat gambar tampak seperti cel shading, karena cel shading adalah proses mendiskritasikan warna difus dan difus menjadi warna diskrit. </font><font style="vertical-align: inherit;">Kami hanya ingin menggunakan warna difus padat tanpa detail peta normal dan nilai kecil </font></font><code>levels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode sumber </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posterize.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixelisasi </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/0b9/9bc/3960b99bc2f1fa900c40a1c9f32169bc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixelisasi game 3D dapat memberikan tampilan yang menarik, atau dapat menghemat waktu Anda untuk membuat semua seni pixel secara manual. </font><font style="vertical-align: inherit;">Gabungkan dengan posterisasi untuk menciptakan tampilan retro yang benar.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int pixelSize = 5; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat mengatur sendiri ukuran pikselnya. </font><font style="vertical-align: inherit;">Semakin besar, semakin kasar gambarnya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/818/aee/413818aee5509763cc383f800b837cfb.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float x = int(gl_FragCoord.x) % pixelSize; float y = int(gl_FragCoord.y) % pixelSize; x = floor(pixelSize / 2.0) - x; y = floor(pixelSize / 2.0) - y; x = gl_FragCoord.x + x; y = gl_FragCoord.y + y; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teknik ini menempelkan setiap fragmen ke tengah jendela berukuran piksel terdekat yang tidak tumpang tindih. </font><font style="vertical-align: inherit;">Jendela-jendela ini berbaris di atas tekstur yang masuk. </font><font style="vertical-align: inherit;">Fragmen di tengah jendela menentukan warna fragmen lain di jendela mereka.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texture(pixelizeTexture, vec2(x, y) / texSize); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah kami menentukan koordinat fragmen yang diinginkan untuk digunakan, ambil warnanya dari tekstur yang masuk dan tetapkan ke warna fragmen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode sumber </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixelize.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pertajam </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/674/617/b52674617a0733ee1fe0d525b0053750.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Efek mempertajam (menajamkan) meningkatkan kontras di tepi gambar. </font><font style="vertical-align: inherit;">Ini sangat berguna ketika grafik ternyata terlalu lunak.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan mengubah nilainya, kita dapat mengontrol besarnya ketajaman hasilnya. </font><font style="vertical-align: inherit;">Jika nilainya nol, gambar tidak akan berubah. </font><font style="vertical-align: inherit;">Dengan nilai negatif, gambar mulai terlihat aneh.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float neighbor = amount * -1; float center = amount * 4 + 1; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmen yang berdekatan dikalikan dengan </font></font><code>amount * -1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fragmen saat ini dikalikan dengan </font></font><code>amount * 4 + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 color = texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 1) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x - 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 0) / texSize).rgb * center + texture(sharpenTexture, vec2(gl_FragCoord.x + 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y - 1) / texSize).rgb * neighbor ; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmen tetangga ada di atas, bawah, kiri dan kanan. </font><font style="vertical-align: inherit;">Setelah mengalikan tetangga dan fragmen saat ini dengan nilainya, hasilnya ditambahkan.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = vec4(color, texture(sharpenTexture, texCoord).a); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jumlah ini adalah warna akhir dari fragmen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode sumber </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mempertajam.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Butir film </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f3/16e/232/2f316e232598d07fa8114f8db32c12a7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Butiran film (dalam dosis kecil, dan tidak seperti dalam contoh) dapat menambahkan realisme, yang tidak terlihat sampai efek ini dihilangkan. </font><font style="vertical-align: inherit;">Biasanya ini adalah ketidaksempurnaan yang membuat gambar yang dihasilkan secara digital lebih meyakinkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa butiran film biasanya merupakan efek terakhir yang diterapkan pada bingkai sebelum ditampilkan.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nilai </font></font></h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.1; // ...</span></span></code> </pre> <br> <code>amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengontrol visibilitas butir film. </font><font style="vertical-align: inherit;">Semakin tinggi nilainya, semakin banyak "salju" dalam gambar.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kecerahan acak </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform float osg_FrameTime; //... float toRadians = 3.14 / 180; //... float randomIntensity = fract ( 10000 * sin ( ( gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime ) * toRadians ) ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sepotong kode ini menghitung kecerahan acak yang diperlukan untuk menyesuaikan nilainya. </font></font><br><br><pre> <code class="cpp hljs">Time Since F1 = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span> <span class="hljs-number"><span class="hljs-number">09</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> Frame Number = F1 F3 F4 F5 F6 osg_FrameTime = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai yang </font></font><code>osg_FrameTime</code> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diberikan oleh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Panda3D. </font><font style="vertical-align: inherit;">Waktu bingkai adalah cap waktu dengan informasi tentang berapa detik telah berlalu sejak bingkai pertama. </font><font style="vertical-align: inherit;">Kode sampel menggunakannya untuk menghidupkan butir film, yang </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan berbeda di setiap frame.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... ( gl_FragCoord.x + gl_FragCoord.y * 8009 // Large number here. // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk butiran statis, film harus diganti dengan </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jumlah besar. </font><font style="vertical-align: inherit;">Untuk menghindari melihat pola, Anda dapat mencoba angka yang berbeda.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/358/2bd/6d2/3582bd6d2d67eb5ac1fdcdf8d52800e6.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... * sin ( ( gl_FragCoord.x + gl_FragCoord.y * someNumber // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat titik, atau bintik-bintik butiran film, digunakan koordinat, dan x, dan y. </font><font style="vertical-align: inherit;">Jika Anda menggunakan x, maka hanya garis vertikal yang akan ditampilkan, jika Anda menggunakan y, maka hanya garis horizontal yang akan ditampilkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kode, satu koordinat dikalikan dengan yang lain untuk menghancurkan simetri diagonal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/ad6/d5a/4c0ad6d5ada5d533b6dc31bbfa7aa0fc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, Anda dapat menghilangkan multiplier koordinat, dan mendapatkan efek hujan yang sepenuhnya dapat diterima. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa untuk menghidupkan efek hujan, gandakan hasilnya </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Percobaan dengan koordinat x dan y untuk mengubah arah hujan. </font><font style="vertical-align: inherit;">Untuk mandi bawah, hanya menyisakan koordinat x.</font></font><br><br><pre> <code class="cpp hljs">input = (gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime) * toRadians frame(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(input)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) =</code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digunakan sebagai fungsi hash. </font><font style="vertical-align: inherit;">Koordinat fragmen di hash dengan nilai output </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Berkat ini, properti nyaman muncul - apa pun data input (besar atau kecil), interval output akan berada dalam kisaran dari minus satu hingga satu.</font></font><br><br><pre> <code class="cpp hljs">fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) = fract(<span class="hljs-number"><span class="hljs-number">6400.723818964882</span></span>) = <span class="hljs-number"><span class="hljs-number">0.723818964882</span></span></code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam kombinasi dengan </font></font><code>fract</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juga digunakan sebagai generator angka acak semu.</font></font><br><br><pre> <code class="cpp hljs">&gt;&gt;&gt; [<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(fract(<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(x * toRadians)) * <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 0, 1, 2, 2, 3, 4, 4, 5, 6] &gt;&gt;&gt; [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">floor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fract(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10000</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(x * toRadians)) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 4, 8, 0, 2, 1, 7, 0, 0, 5]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama lihat pada baris pertama angka, dan kemudian pada yang kedua. </font><font style="vertical-align: inherit;">Setiap baris ditentukan, tetapi polanya kurang terlihat di baris kedua daripada di baris kedua. </font><font style="vertical-align: inherit;">Oleh karena itu, terlepas dari kenyataan bahwa output bersifat </font></font><code>fract(10000 * sin(...))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deterministik, polanya diakui jauh lebih lemah.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/6e7/f0f/b886e7f0feda6760c5fc87df6680680f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini kita melihat bagaimana faktornya </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah pertama 1, lalu 10, lalu 100, dan kemudian 1000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika pengali dari nilai output meningkat, </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">polanya menjadi kurang terlihat. </font><font style="vertical-align: inherit;">Karena alasan ini, kode </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini dikalikan 10.000.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warna fragmen </font></font></h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 texSize = textureSize(filmGrainTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; vec4 color = texture(filmGrainTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubah koordinat fragmen menjadi koordinat UV. </font><font style="vertical-align: inherit;">Menggunakan koordinat UV ini, kami mencari warna tekstur untuk fragmen saat ini.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... amount *= randomIntensity; color.rgb += amount; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ubah nilainya menjadi kecerahan acak dan tambahkan ke warna. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = color; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atur warna fragmen, dan hanya itu. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode sumber </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">film-grain.frag</font></font></a> </li></ul><br><h2>  Ucapan Terima Kasih </h2><br><ul><li>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Kiwi Soda Font</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453692/">https://habr.com/ru/post/id453692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453676/index.html">Menghubungkan ke Windows melalui SSH seperti di Linux</a></li>
<li><a href="../id453678/index.html">Cara melihat gema atau transmisi video dengan suara melalui air - 2</a></li>
<li><a href="../id453682/index.html">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd. Bagian 2. Kode program</a></li>
<li><a href="../id453686/index.html">Pekan Keamanan 22: statistik ancaman, trojan perbankan, dan eksploitasi populer</a></li>
<li><a href="../id453688/index.html">Java tidak hanya berdarah perusahaan, tetapi juga aplikasi yang sensitif terhadap latensi cepat</a></li>
<li><a href="../id453694/index.html">Terhubung ke Windows melalui SSH seperti di Linux</a></li>
<li><a href="../id453696/index.html">Ikatan dua arah sudut, sedikit lebih pengertian</a></li>
<li><a href="../id453698/index.html">Informasi kuantum dalam kesadaran kuantum</a></li>
<li><a href="../id453700/index.html">Pelajaran tentang SDL 2: Pelajaran 1 - Halo, SDL 2</a></li>
<li><a href="../id453706/index.html">Bagaimana Saya Lulus dari Ujian Sertifikasi Insinyur Data Google Cloud Professional</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>