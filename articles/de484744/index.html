<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐎 ☘️ 🕋 Wie ich 2D-Schatten in Unity gemacht habe 🤵🏾 👨‍🎨 🧑‍🤝‍🧑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was kommt einem Indie-Spieleentwickler als Erstes in den Sinn, wenn er ein Feature hinzufügen muss, von dessen Implementierung er keine Ahnung hat? Na...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie ich 2D-Schatten in Unity gemacht habe</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484744/">  Was kommt einem Indie-Spieleentwickler als Erstes in den Sinn, wenn er ein Feature hinzufügen muss, von dessen Implementierung er keine Ahnung hat?  Natürlich wird er nach Spuren derer suchen, die diesen Weg bereits gegangen sind und sich die Mühe gemacht haben, ihre Erfahrungen aufzuschreiben.  Also habe ich vor einiger Zeit angefangen, Schatten in meinem Spiel zu erzeugen.  Die richtigen Informationen - in Form von Artikeln, Lektionen und Leitfäden - zu finden, war nicht schwierig.  Zu meiner Überraschung stellte ich jedoch fest, dass keine der beschriebenen Lösungen einfach zu mir passte.  Nachdem ich meine eigenen erkannt hatte, beschloss ich, der Welt davon zu erzählen. <br><br>  Es ist im Voraus zu warnen, dass dieser Text keine Art Ultimatum-Leitfaden oder Meisterklasse darstellt.  Die Methode, die ich verwendet habe, ist möglicherweise nicht universell, keineswegs die effektivste und deckt nicht die Aufgabe ab, zweidimensionale Schatten vollständig zu erzeugen.  Es ist eher eine Geschichte darüber, auf welche Tricks ein unerfahrener Entwickler in meinem Gesicht zurückgreifen musste, um ein Ergebnis zu erzielen, das seine Anforderungen erfüllt. <br><br>  Das Ergebnis selbst liegt vor Ihnen: <br><br> <a href=""><img src="https://habrastorage.org/webt/-y/kc/nf/-ykcnfou6b_na1a44jvq-v3-nts.png"></a> <br><br>  Und die Details des Weges zu seiner Erreichung warten auf Sie unter dem Schnitt. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen über das Spiel</b> <div class="spoiler_text">  Dwarfinator ist ein zweidimensionaler Basisverteidigungs- / Side-Scroll-Shooter, der mit Blick auf die Segmente Mobile und Desktop entwickelt wurde.  Das Gameplay besteht aus der systematischen Zerstörung feindlicher Wellen in zwei abwechselnden Modi - Verteidigung und Jagd.  Der Fortschritt eines Spielers besteht darin, einen „Panzer“ zu pumpen, indem er verschiedene Elemente wie Waffen, Motoren und Räder verbessert und ersetzt sowie das Level erhöht und aktive und passive Fähigkeiten erlernt.  Das Fortschreiten der Umgebung beinhaltet eine konstante Zunahme der Anzahl von Mobs in der Welle, das Hinzufügen neuer Arten von Feinden zu der Welle, während sie sich durch den Ort bewegen, und den sukzessiven Wechsel mehrerer Orte, von denen jeder seine eigene Gruppe von Gegnern hat. <br></div></div><br><h3>  Erklärung des Problems </h3><br>  Zum Zeitpunkt der Entscheidung, dem Spiel Schatten hinzuzufügen, hatte ich also: <br><br><ul><li>  Ort in Form von zwei Sprites, einer zur Anzeige hinter Mobs und anderen Entities, der zweite zur Anzeige vor ihnen; </li></ul><br> <a href=""><img src="https://habrastorage.org/webt/7e/e7/8s/7ee78soifwhkx6g3bgetf4nvfhy.png"></a> <br><br><ul><li>  Mobs und statische zerstörbare Objekte, die ständig animiert sind und aus verschiedenen Sprites in einer Menge von einigen bis einigen Dutzend bestehen; </li></ul><br><img src="https://habrastorage.org/webt/yp/ea/my/ypeamyommcilthpim0gr2o820mu.png"><br><br><ul><li>  Muscheln, eigene und feindliche, in den meisten Fällen entweder durch ein Sprite oder durch ein Partikelsystem dargestellt, in letzterem Fall war kein Schatten erforderlich; </li></ul><br><img src="https://habrastorage.org/webt/bt/9n/ml/bt9nmlkym2iuq6qtrqntzkzil7s.png"><br><br><ul><li>  ein Tank, der aus mehreren Teilen besteht, die nach demselben Schema wie Mobs zusammengesetzt sind; </li></ul><br><img src="https://habrastorage.org/webt/uv/1y/ed/uv1yedokb8lqcxfwmt788egsvne.png"><br><br><ul><li>  Wände mit mehreren festen Zuständen, die wiederum eine Reihe separater Sprites sind. </li></ul><br><img src="https://habrastorage.org/webt/3f/we/7s/3fwe7srgtopajqnn6rvg3kyoiq4.png"><br><br>  Für all dies wurden die einfachsten Schatten benötigt, die die Konturen des Objekts wiederholten und von einer einzigen festen Lichtquelle aus geworfen wurden. <br><br>  Gleichzeitig sollte man ein ausgeprägtes Verhältnis zur Produktivität haben.  Aufgrund der Besonderheiten des Genres und der Besonderheiten seiner Implementierung befinden sich die meisten Objekte, die Schatten werfen, jederzeit direkt auf dem Bildschirm.  Und ihre Gesamtzahl kann mehr als einhundert betragen, wenn wir über Spieleinheiten sprechen, und ein paar Tausend, wenn wir über einzelne Sprites sprechen. <br><br><h3>  Implementierung </h3><br>  Eigentlich stellte sich heraus, dass Dwarfinator grob gesagt ein 2.5D-Spiel ist.  Die überwiegende Mehrheit der Objekte existiert im zweidimensionalen Raum mit der X- und Y-Achse, und die Z-Achse wird äußerst selten verwendet.  Visuell und teilweise im Gameplay wird die Y-Achse verwendet, um sowohl die Höhe als auch die Tiefe anzuzeigen, und zwar auf dieselbe Weise in die virtuellen Y- und Z-Achsen. <br><br>  Tatsächlich brauchte ich keine ehrliche Beleuchtung, es reichte aus, um manuell einen Schatten für jedes Objekt zu erstellen.  Das Einfachste, was mir in den Sinn kam, war, einfach eine Kopie hinter jedes Objekt zu platzieren, das im dreidimensionalen Raum gedreht wurde, um einen Ort auf der Oberfläche zu simulieren.  Alle Sprites dieses Pseudoschattens wurden auf Schwarz gesetzt, während die hierarchische Struktur des Schattenbesitzers beibehalten wurde, sodass er vom selben Animator synchron mit dem Besitzer animiert werden konnte. <br><br>  Eine solche synchrone Animation sah ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/wv/on/vc/wvonvcn2zlzubgo5orcwcjjuu5e.gif"><br><br>  Der Schatten erforderte jedoch Transparenz.  Die einfachste Lösung bestand darin, sie für jedes Schattensprite festzulegen.  Eine solche Implementierung sah jedoch nicht zufriedenstellend aus - Sprites überlappten sich und bildeten weniger transparente Bereiche an der Überlagerungsstelle. <br><br>  Der Screenshot unten zeigt, wie der Schatten mehrerer durchscheinender Segmente aussieht.  Die verwendeten Schattenverzerrungsparameter sind ebenfalls sichtbar: Drehung entlang der X-Achse um -50 Grad, Drehung entlang der Y-Achse um -140 Grad und Skalierung entlang der X-Achse um das 1,3-fache gegenüber dem übergeordneten Objekt. <br><br><img src="https://habrastorage.org/webt/6w/2k/m-/6w2km-vc4g_hhblm2fz3tofrdzq.png"><br><br>  Es wurde deutlich, dass dem Schatten als festem Objekt Transparenz auferlegt werden sollte.  Das erste Experiment zu diesem Thema hing am Schatten der Kamera und renderte diesen Schatten in RenderTexture, das dann als Material verwendet wurde, das an das übergeordnete Element des Ebenenschattens angehängt wurde.  Er konnte bereits ohne Probleme Transparenz einstellen.  Die Schatten selbst befanden sich außerhalb des Rahmens, um eine Überlappung der Kameraerfassungsbereiche zu vermeiden.  Der Ansatz funktionierte, aber es stellte sich heraus, dass bereits ein paar Dutzend Schatten ernsthafte Leistungsprobleme verursachten, hauptsächlich aufgrund der Anzahl der Kameras auf der Bühne.  Darüber hinaus gingen eine Reihe von Animationen von einer signifikanten Bewegung einzelner Mob-Sprites im Rahmen ihres Stammobjekts aus, wodurch ein Kamerabereich gefunden werden sollte, der die Größe des realen Bildes zu einem bestimmten Zeitpunkt erheblich überschreiten würde. <br><br>  Die Lösung wurde schnell gefunden - wenn Sie nicht jeden Schatten mit einer separaten Kamera zeichnen können - warum nicht alle Schatten mit einer Kamera zeichnen?  Dazu musste lediglich ein separater Bereich der Szene unter dem Schatten platziert werden, der etwas höher als das Sichtfeld der Hauptkamera ist, eine zusätzliche Kamera auf diesen Bereich richten und die Ausgabe zwischen dem Standort und anderen Objekten anzeigen. <br><br>  Unten sehen Sie ein Beispiel für die Ausgabe dieser Kamera: <br><br> <a href=""><img src="https://habrastorage.org/webt/in/bt/vm/inbtvmwj2slb2wn8f8wqqqkhbke.png"></a> <br><br>  Die Produktivität einer solchen Implementierung litt viel weniger, sodass die Lösung als funktionierend angesehen und auf alle Mobs, statischen Objekte und Shells angewendet wurde.  Diesem folgte der Ort des Sprites.  Es war unmöglich, ein Sprite für alle Objekte zu verwenden, da es zuvor implementiert wurde.  Die Verwendung einer Kopie eines Objekts als Schatten funktioniert nur, wenn das Objekt vollständig flach ist.  Sogar beim Erstellen von Schatten für Mobs wurde festgestellt, dass Berührungspunkte mit der Oberfläche, die entlang der dritten Koordinate beabstandet sind, die Richtigkeit des Schattens in Bezug auf diese Punkte verletzen. <br><br>  Der folgende Screenshot zeigt ein Beispiel für einen solchen Verstoß.  Die Ferse des Pöbels wird als Berührungspunkt mit der Oberfläche genommen, aber die Schatten der Füße sind bereits jenseits der Füße selbst. <br><br><img src="https://habrastorage.org/webt/-d/zu/an/-dzuan6-5vwdisaiafgysqizvnc.png"><br><br>  Und wenn Sie bei den Beinen des Ogers die Position des Schattens noch leicht verändern und das Problem maskieren können, dann besteht für einige Dutzend Baumstämme keine Chance.  Alle Standortobjekte, die einen Schatten werfen sollten, sollten zu einem separaten GameObject gemacht werden.  Dies ist genau das, was ich getan habe, indem ich Kopien der entsprechenden zerstörbaren Objekte auf dem vorgefertigten Standort platziert und Skripte deaktiviert habe, die an dieser Position nicht verwendet werden.  Gleichzeitig wurde es dadurch möglich, sie in die allgemeine Sortierung von Szenenobjekten einzubeziehen, und Muscheln, die außerhalb des Ortes flogen, wurden nicht mehr streng auf alle Objekte gezeichnet, sondern flogen zwischen ihnen hin und her.  Außerdem wurde es möglich, die Objekte selbst zu animieren. <br><br>  Aber dann erwartete mich ein neuer Ärger.  Mit Schatten und Dutzenden neuer Objekte hat sich die maximale Anzahl von GameObjects gleichzeitig auf der Bühne und damit die Anzahl der Animator- und SpriteRenderer-Komponenten mehr als verdoppelt.  Als ich die ganze Welle von Mobs an dem Ort veröffentlichte, der ungefähr 150 Teile umfasste, zeigte mir Profiler vorwurfsvoll ungefähr 40 ms, die nur zum Rendern und Animieren verschwanden, und die Framerate variierte im Allgemeinen um 10. Ich optimierte meine eigenen Skripte verzweifelt und kämpfte für jede Millisekunde. aber das war nicht genug. <br><br>  Auf der Suche nach zusätzlichen Optimierungstools bin ich auf die umfangreichen Dokumentationen und Anleitungen für die dynamische Stapelverarbeitung gestoßen. <br><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen mehr über das Batching</b> <div class="spoiler_text">  Kurz gesagt, Batching ist ein Mechanismus zur Minimierung der Anzahl der Draw-Aufrufe und damit der Zeit, die zum Zeitpunkt des Renderns des Frames für die Interaktion zwischen CPU und GPU aufgewendet wird.  Anstatt jedes Element einzeln zum Rendern zu senden, werden ähnliche Elemente gleichzeitig gruppiert und gezeichnet.  Im Falle von Unity versucht die Engine selbst, diesen Mechanismus maximal zu nutzen, und der Entwickler muss fast keine zusätzlichen Maßnahmen ergreifen. <br></div></div><br>  Frame-Debugger hat gezeigt, dass ich bestenfalls die Details jedes Objekts oder Mobs separat habe.  Nachdem ich für den ersten und zweiten Teil des Atlas Sprites erstellt hatte, erreichte ich mit nur wenigen Draw Calls Schattenschatten, aber die Besitzer dieser Schatten weigerten sich hartnäckig, sich selbst zu bekämpfen. <br><br>  Experimente in einer separaten Szene haben gezeigt, dass die dynamische Stapelverarbeitung unterbrochen wird, wenn Objekte eine SortingGroup-Komponente haben, mit der ich die Anzeige von Objekten auf dem Bildschirm sortiert habe.  Es war zwar möglich, darauf zu verzichten, aber theoretisch konnte das separate Einstellen der Sortierwerte für jedes Sprite und Partikelsystem in einem Objekt sogar noch teurer ausfallen als das Fehlen einer Stapelverarbeitung. <br><br>  Aber etwas hat mich heimgesucht.  Das Schattenobjekt, das ein Nachkomme des Hostobjekts in der realen Szene ist, gehörte technisch zur gleichen SortingGroup, es gab jedoch keine Probleme mit der dynamischen Spiegelung von Schattenobjekten.  Der einzige Unterschied bestand darin, dass die Hostobjekte von der Hauptkamera direkt auf dem Bildschirm gezeichnet wurden und die Schattenobjekte zuerst in RenderTexture gerendert wurden. <br><br>  Das war der Haken.  Was genau der Grund für dieses Verhalten ist, ist dem Internet unbekannt, aber beim Rendern der Kamerabilder in RenderTexture hat SortingGroup die Stapelverarbeitung nicht mehr unterbrochen.  Die Entscheidung schien sehr seltsam, unlogisch und im Allgemeinen die am meisten belastende.  Indem ich das Rendern von Objekten mit der gleichen Methode wie das Rendern von Schatten implementiere und so zusätzlich zur Schattenebene eine Objektebene erhalten habe, habe ich bereits akzeptable Leistungswerte erzielt. <br><br>  Der Screenshot unten zeigt ein Beispiel für das Rendern eines Entity-Layers. <br><br> <a href=""><img src="https://habrastorage.org/webt/vn/q_/r3/vnq_r3631min5ao58fksxjgcmt0.png"></a> <br><br>  Im Allgemeinen sieht das Rendern einer bestimmten Entität in der Y-Koordinate folgendermaßen aus: <br><br><ol><li>  Das Unternehmen befindet sich bei Y - 20; </li><li>  Eine Entität wird von einer Kamera gerendert, die diese Koordinate in einer RenderTexture für Entitäten beobachtet. </li><li>  Der Objektschatten wird bei Y + 20 platziert. </li><li>  Ein Schatten eines Objekts wird von einer Kamera gezeichnet, die diese Koordinate in einer RenderTexture für Schatten beobachtet. </li><li>  Die Hauptkamera zeichnet das Sprite für die Hauptposition auf dem Bildschirm - das einzige Element, das derzeit direkt auf dem Bildschirm gerendert wird. </li><li>  Die Hauptkamera zeichnet eine Ebene auf dem Bildschirm mit RenderTexture-Schatten als Material. </li><li>  Die Hauptkamera zeichnet eine Ebene auf dem Bildschirm mit einer RenderTexture von Objekten als Material. </li></ol><br>  Eine solche Torte. <br><br>  In der Abbildung unten ist die Kamera des Editors auf den dreidimensionalen Modus eingestellt, um die Position der Ebenen relativ zueinander zu veranschaulichen. <br><br> <a href=""><img src="https://habrastorage.org/webt/pz/ix/0v/pzix0vcz_uw8gh4yppbukrsujjw.png"></a> <br><br><h3>  Nuancen </h3><br>  Da sich jedoch herausstellte, dass die Entscheidung auf andere Unternehmen übertragen wurde, wurden im allgemeinen Fall nicht alle möglichen Szenarien berücksichtigt.  Es gab zum Beispiel Objekte, die sich in einer gewissen Höhe zur Oberfläche befanden, insbesondere Muscheln und einige Zwischensequenzen.  Zusätzlich hatten die Geschosse die Fähigkeit, sich in Abhängigkeit von der Richtung ihrer Bewegung auf dem Bildschirm zu drehen, weshalb es zusätzlich zur Einstellung des Schnittpunkts des Objekts und seines Schattens erforderlich war, das rotierende Teil als separates untergeordnetes Objekt auszuwählen, um die Rotationslogik des Projektils und deren Animation zu korrigieren. <br><br>  Der folgende Screenshot zeigt ein Beispiel für die Drehung von Muscheln und ihren Schatten. <br><br><img src="https://habrastorage.org/webt/53/a1/dm/53a1dm21tezb3p8wktfmfyibubu.png"><br><br>  Fliegende Charaktere können sich wie geplante fliegende Mobs auch innerhalb ihrer virtuellen Y-Koordinaten bewegen, was die Erstellung eines Mechanismus zur Berechnung der Position des Schattens aus der Position seines Besitzers auf der virtuellen Y-Achse erforderlich machte. <br><br>  Das folgende GIF zeigt ein Beispiel für das Verschieben eines Objekts in der Höhe. <br><br><img src="https://habrastorage.org/webt/wh/m8/vz/whm8vzwjlsobsbyhzeapuggku4s.gif"><br><br>  Ein anderer Fall, der aus dem allgemeinen Konzept herauskam, war ein Panzer.  Im Gegensatz zu allen anderen Objekten hat der Panzer entlang der virtuellen Z-Achse eine sehr beachtliche Größe, und die Gesamtimplementierung der Schatten erfordert, wie bereits erwähnt, dass das Objekt fast flach ist.  Der einfachste Weg, dies zu umgehen, bestand darin, Schattenformen für einzelne Teile des Tanks manuell zu zeichnen, da Sie alles auf der Schattenebene platzieren konnten. <br><br>  Für die korrekte Konstruktion von handgezeichneten Schatten musste ich ein Liniendesign auf der Grundlage eines Screenshots eines vorhandenen Schattens erstellen, der im folgenden Screenshot zu sehen ist. <br><br><img src="https://habrastorage.org/webt/md/of/np/mdofnpoa7xwtlus9bkqvnalzpri.png"><br><br>  Wenn Sie diese Struktur so skalieren und platzieren, dass sich der obere Teil an einem Punkt des übergeordneten Objekts und der untere Teil am Kontaktpunkt mit der Oberfläche befindet, wird in der rechten Ecke der Struktur die Stelle angezeigt, an der sich der entsprechende Schattenpunkt befinden sollte.  Nachdem auf diese Weise mehrere wichtige Punkte projiziert wurden, ist es nicht schwierig, den gesamten Schatten darauf aufzubauen. <br><br>  Darüber hinaus können einzelne Teile des Panzers unterschiedliche Höhen für die Befestigung von Kinderteilen aufweisen, was wie bei fliegenden Charakteren und Mobs eine Anpassung der Schattenposition jedes einzelnen Teils erforderlich macht. <br><br>  Der Screenshot unten zeigt den Panzer, seine Schattenmontage und ist auch in Form von separaten Teilen. <br><br><img src="https://habrastorage.org/webt/67/bu/5m/67bu5mgmclx_x53nv2efh9mxnqe.png"><br><br>  Schatten der Wände stellten sich als separater Schmerz heraus.  Zu Beginn der Arbeiten an den Schatten waren die Wände von der gleichen Art wie die Details des Panzers - ein Objekt aus mehreren Dutzend verschiedenen Sprites.  Die Wände hatten jedoch mehrere Zustände, die vom Animator gesteuert wurden. <br><br>  Nach gründlichen Überlegungen kam ich zu dem Schluss, dass das Konzept der Wände geändert werden muss.  Infolgedessen wurden die Wände in Abschnitte unterteilt, von denen jeder einen eigenen Satz von Zuständen, einen eigenen Animator und einen eigenen Schatten hat.  Dies ermöglichte es, für Mobs, die parallel zur X-Achse verlaufen, den gleichen Ansatz für die Erstellung von Schatten zu verwenden wie für Mobs. Für Abschnitte, die dieser Regel nicht entsprachen, mussten sie sich etwas Eigenes einfallen lassen.  In einigen Fällen musste ich meinen eigenen Animator für den Abschnittsschatten erstellen und die Position der Sprites manuell festlegen. <br><br>  Im Fall des in der Abbildung unten gezeigten Abschnitts wird der Schatten beispielsweise erzeugt, indem für jedes einzelne Protokoll eine Verzerrung anstelle des gesamten Abschnitts angewendet wird. <br><br><img src="https://habrastorage.org/webt/bc/ef/sm/bcefsmatcqoghwbttkwfhbrpeme.png"><br><br><h3>  Fazit </h3><br>  Das ist in der Tat alles.  Trotz all der oben genannten Nuancen wurde die ursprüngliche Aufgabe vollständig erledigt, und jetzt kann mein Projekt recht anständig aussehende Schatten aufweisen, wenn auch von etwas zweifelhafter Herkunft.  Ich hoffe, dass dank dieses Artikels für den nächsten Indie-Entwickler, der mir eine ähnliche Frage gestellt hat, das Internet ein wenig nützlicher wird, wenn nicht als Beispiel, dann zumindest als Fehler eines anderen für Ihr eigenes Lernen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484744/">https://habr.com/ru/post/de484744/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484732/index.html">Was ist VMware und warum ist die Kompatibilität mit SSDs wichtig?</a></li>
<li><a href="../de484734/index.html">Was auf der CES im 19. und 20. Jahrhundert hätte präsentiert werden können</a></li>
<li><a href="../de484736/index.html">Linux: Entfernen des Sperrpools / dev / random</a></li>
<li><a href="../de484738/index.html">Exemplarische Vorgehensweise für die kontinuierliche Integration von Laravel 6 in Google Cloud Run</a></li>
<li><a href="../de484740/index.html">Sicherheitswoche 04: Kryptoprobleme in Windows 10</a></li>
<li><a href="../de484750/index.html">Schizophrenie: ein Blick nach</a></li>
<li><a href="../de484752/index.html">Schreiben eines Laptop-Treibers für Spaß und Gewinn oder Festschreiben des Kernels, auch wenn Sie nicht so schlau sind</a></li>
<li><a href="../de484754/index.html">Intel kann sich nicht entscheiden, wer schneller ist: Comet Lake oder Ice Lake</a></li>
<li><a href="../de484756/index.html">Visuelle Informationstheorie (Teil 2)</a></li>
<li><a href="../de484758/index.html">Was ist zwischen Programmieren und Unternehmensgründung üblich?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>