<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõãÔ∏è üëçüèΩ üê´ S'entra√Æner √† travailler avec des pneus personnalis√©s du complexe Redd üê¨ üñãÔ∏è üßòüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le dernier article, nous avons examin√© la th√©orie de la gestion de mille petites choses dans le complexe Redd, mais afin de ne pas gonfler le vol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>S'entra√Æner √† travailler avec des pneus personnalis√©s du complexe Redd</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484706/"> Dans le <a href="https://habr.com/ru/post/483724/">dernier article,</a> nous avons examin√© la th√©orie de la gestion de mille petites choses dans le complexe Redd, mais afin de ne pas gonfler le volume, nous avons report√© la pratique la prochaine fois.  Le moment est venu de mener des exp√©riences pratiques.  Ceux qui n'utilisent pas le complexe Redd pourront √©galement trouver des connaissances utiles dans cet article, √† savoir la m√©thodologie pour envoyer des commandes de fournisseur aux lecteurs USB √† partir de Linux, car, comme d√©j√† mentionn√©, le contr√¥leur STM32 du complexe remplit la fonction d'un lecteur SD, c'est-√†-dire, conduire. <br><br><img src="https://habrastorage.org/webt/_e/hh/5n/_ehh5nw2j8tiw7myjovthvvc_va.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Articles du cycle pr√©c√©dent</b> <div class="spoiler_text"><ol><li>  <a href="https://habr.com/ru/post/452656/">D√©veloppement du ¬´firmware¬ª le plus simple pour les FPGA install√©s dans Redd, et d√©bogage en utilisant le test de m√©moire comme exemple.</a> </li><li>  <a href="https://habr.com/ru/post/453682/">D√©veloppement du ¬´firmware¬ª le plus simple pour les FPGA install√©s dans Redd.</a>  <a href="https://habr.com/ru/post/453682/">Partie 2. Code de programme.</a> </li><li>  <a href="https://habr.com/ru/post/454938/">D√©veloppement de son propre noyau pour l'int√©gration dans un syst√®me de processeur FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/456008/">D√©veloppement de programmes pour le processeur central Redd sur l'exemple d'acc√®s au FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/462253/">Les premi√®res exp√©riences utilisant le protocole de streaming sur l'exemple de la connexion du CPU et du processeur dans le FPGA du complexe Redd.</a> </li><li>  <a href="https://habr.com/ru/post/464795/">Joyeux Quartusel, ou comment le processeur est arriv√© √† une telle vie.</a> </li><li>  <a href="https://habr.com/ru/post/467353/">M√©thodes d'optimisation de code pour Redd.</a>  <a href="https://habr.com/ru/post/467353/">Partie 1: effet de cache.</a> </li><li>  <a href="https://habr.com/ru/post/468027/">M√©thodes d'optimisation de code pour Redd.</a>  <a href="https://habr.com/ru/post/468027/">Partie 2: m√©moire non mise en cache et fonctionnement sur bus parall√®le.</a> </li><li>  <a href="https://habr.com/ru/post/469985/">Optimisation √©tendue du code: remplacement d'un g√©n√©rateur d'horloge pour am√©liorer les performances du syst√®me.</a> </li><li>  <a href="https://habr.com/ru/post/477662/">Acc√®s aux bus Redd mis en ≈ìuvre sur les contr√¥leurs FTDI</a> </li><li>  <a href="https://habr.com/ru/post/483724/">Travailler avec des pneus personnalis√©s complexes Redd</a> </li></ol><br></div></div><br><h2>  Classification des disques par syst√®mes de commande </h2><br>  Lorsque vous travaillez avec des disques, vous devez faire la distinction entre une interface physique et un syst√®me de commande.  En particulier, les lecteurs CD / DVD / BD et autres optiques.  Traditionnellement, ils se connectent √† un c√¢ble SATA (anciennement IDE).  Mais sp√©cifiquement sur ce fil, seules les commandes PACKET s'ex√©cutent en cours de fonctionnement, dans le bloc de donn√©es desquelles sont plac√©es des commandes cod√©es selon un principe compl√®tement diff√©rent (nous allons bient√¥t d√©couvrir par laquelle).  Par cons√©quent, maintenant, nous ne parlerons pas tant des c√¢bles, mais des √©quipes qui les ex√©cutent.  Je connais trois syst√®mes de commande courants pour travailler avec des disques. <br><br><ul><li>  MMC  Il est compris par les cartes SD.  Honn√™tement, c'est pour moi le syst√®me de commandement le plus myst√©rieux.  La fa√ßon de les soumettre, semble-t-il, est claire, mais comment g√©rer le lecteur sans lire attentivement le document contenant beaucoup de graphiques de transition - je suis toujours confus.  Heureusement, cela ne nous d√©range pas aujourd'hui, car bien que nous travaillions avec une carte SD, le contr√¥leur STM32 en mode ¬´bo√Æte noire¬ª fonctionne avec. </li><li>  ATA  Initialement, ces commandes s'ex√©cutaient sur le bus IDE, puis sur SATA.  Un merveilleux syst√®me de commandement, mais aujourd'hui, nous mentionnons √©galement qu'il existe. </li><li>  SCSI  Ce syst√®me de commande est utilis√© sur une large gamme d'appareils.  Consid√©rez son utilisation dans les lecteurs.  Aujourd'hui, les √©quipes SCSI courent tout d'abord le long des c√¢bles du bus SAS (d'ailleurs, m√™me les SSD avec interface SAS sont d√©sormais √† la mode).  Curieusement, les lecteurs optiques physiquement connect√©s au bus SATA fonctionnent √©galement via des commandes SCSI.  Sur le bus USB lorsque vous travaillez selon la norme du p√©riph√©rique de stockage de masse, les commandes sont √©galement transmises au format SCSI.  Le microcontr√¥leur STM32 est connect√© au complexe Redd via le bus USB, c'est-√†-dire que, dans notre cas, les commandes suivent le chemin suivant: <br><br><img src="https://habrastorage.org/webt/hy/iy/f4/hyiyf4m9sjgr8etz8ily8joxsrc.png"><br></li></ul><br>  Du PC au contr√¥leur, via USB, les commandes sont au format SCSI.  Le contr√¥leur transcode les commandes selon la r√®gle MMC et les envoie via le bus SDIO.  Mais nous devons √©crire un programme pour le PC, donc les √©quipes nous laissent au format SCSI.  Ils sont pr√©par√©s par le pilote de p√©riph√©rique du p√©riph√©rique de stockage de masse, avec lequel nous communiquons via le pilote du syst√®me de fichiers.  Est-il possible de m√©langer des demandes avec d'autres appareils pour ces demandes?  Faisons les choses correctement. <br><br><h2>  D√©tails du syst√®me de commande SCSI </h2><br>  Si vous abordez la question de mani√®re formelle, la description de la norme SCSI est disponible sur t10.org, mais nous serons r√©alistes.  Personne ne le lira volontairement.  Plus pr√©cis√©ment, pas le sien, mais le leur: il y a tout un tas de documents ouverts et une montagne de documents ferm√©s. Seul un besoin extr√™me vous fera vous immerger dans le langage complexe dans lequel la norme est √©crite (ceci, soit dit en passant, s'applique √† la norme ATA sur t13.org).  Il est beaucoup plus facile de lire la documentation des vrais disques.  Il est √©crit dans une langue plus vivante, et des parties hypoth√©tiques mais pas vraiment utilis√©es en sont d√©coup√©es.  Lors de la pr√©paration de l'article, je suis tomb√© sur un document plut√¥t nouveau (2016) du <b>manuel de r√©f√©rence des commandes SCSI</b> de Seagate (lien direct <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">www.seagate.com/files/staticfiles/support/docs/manual/Interface%20manuals/100293068j.pdf</a> mais, comme toujours, Je ne sais pas combien de temps elle vivra).  Je pense que si quelqu'un veut ma√Ætriser ce syst√®me de commandes, il devrait commencer par ce document.  Nous nous souvenons seulement que les lecteurs SD impl√©mentent un sous-ensemble encore plus petit des commandes de cette description. <br><br>  Pour parler tr√®s bri√®vement, une unit√© de commande d'une longueur de 6 √† 16 octets est envoy√©e au variateur.  Un bloc de donn√©es peut √™tre attach√© au bloc de commande soit du PC vers le lecteur, soit du lecteur vers le PC (la norme SCSI autorise √©galement l'√©change bidirectionnel, mais pour le p√©riph√©rique de stockage de masse via USB, un seul bloc est autoris√©, ce qui signifie que la direction n'est qu'un).  Dans le bloc d'instructions, le premier octet est toujours le code de commande.  Les octets restants sont ses arguments.  Les r√®gles de remplissage des arguments sont d√©crites exclusivement par les d√©tails de l'impl√©mentation de la commande. <br><br><img src="https://habrastorage.org/webt/xt/1l/eb/xt1lebwoznye5dag98pwbtiuxfm.png"><br><br>  Au d√©but, j'ai ins√©r√© beaucoup d'exemples dans l'article, mais j'ai ensuite r√©alis√© qu'ils rendaient la lecture difficile.  Par cons√©quent, je sugg√®re √† chacun de comparer les champs de la commande READ CAPACITY (10) du tableau 119 du document Seigate et les champs de la commande READ (10) du tableau 97 du m√™me document (voir lien ci-dessus).  Qui n'a trouv√© aucune connexion - ne vous inqui√©tez pas.  Voil√† ce que je voulais montrer.  En plus du champ ¬´commande¬ª dans l'octet z√©ro, le but de tous les champs d√©pend uniquement des sp√©cificit√©s d'une commande particuli√®re.  Vous devez toujours ouvrir le document et √©tudier la fonction des autres champs qu'il contient. <br><br>  Donc: <br><br><ul><li>  Pour communiquer avec le lecteur, vous devez former un bloc de commande d'une longueur de 6 √† 16 octets (selon le format de la commande, le nombre exact est indiqu√© dans la documentation correspondante). </li><li>  Le plus important est l'octet z√©ro du bloc: c'est lui qui d√©finit le code de commande. </li><li>  Les octets de bloc restants n'ont pas un objectif clair.  Pour comprendre comment les remplir, vous devez ouvrir la documentation d'une √©quipe sp√©cifique. </li><li>  Un bloc de donn√©es qui peut √™tre transf√©r√© vers ou depuis un lecteur peut √™tre attach√© √† une commande. </li></ul><br>  En fait, c'est tout.  Nous avons appris les r√®gles d'√©mission des commandes SCSI.  Nous pouvons maintenant les soumettre, il y aurait de la documentation √† leur sujet.  Mais comment le faire au niveau du syst√®me d'exploitation? <br><br><h2>  Commandes Linux SCSI </h2><br><h3>  Rechercher le p√©riph√©rique cible </h3><br>  Pour √©mettre des commandes, ouvrez le p√©riph√©rique de disque.  Trouvons son nom.  Pour ce faire, nous proc√©derons exactement de la m√™me mani√®re que dans l' <a href="https://habr.com/ru/post/477662/">article sur les ports s√©rie</a> .  Voyons la liste des ¬´fichiers¬ª dans le <b>r√©pertoire / dev</b> (rappelez-vous que sur les p√©riph√©riques Linux sont √©galement affich√©s sous forme de fichiers et leur liste est affich√©e avec la m√™me <b>commande ls</b> ). <br><br>  Aujourd'hui, nous pr√™tons attention au <b>disque du</b> r√©pertoire virtuel: <br><br><img src="https://habrastorage.org/webt/t_/py/kj/t_pykjsq2_2gdno-u0oc9wdpltm.png"><br><br>  Nous regardons son contenu: <br><br><img src="https://habrastorage.org/webt/cp/yp/n_/cpypn_cslhfibis7ixhbez64q4y.png"><br><br>  Un ensemble familier de r√©pertoires imbriqu√©s!  Nous essayons de consid√©rer le r√©pertoire <b>by-id</b> , en utilisant le commutateur <b>‚Äìl</b> de la <b>commande ls</b> , que nous connaissons d√©j√† dans l'article sur les ports s√©rie: <br><br><img src="https://habrastorage.org/webt/jq/8s/zn/jq8sznkl6pimg5oxevbdp8m7l4w.png"><br><br>  Les mots surlign√©s parlent d'eux-m√™mes.  Il s'agit d'un lecteur contenant la carte SD interne du complexe Redd.  Super!  Nous savons maintenant que le p√©riph√©rique <b>MIR_Redd_Internal_SD</b> correspond au p√©riph√©rique <b>/ dev / sdb et / dev / sdb1</b> .  Celui sans le num√©ro est le lecteur lui-m√™me, nous travaillerons avec lui, et avec le num√©ro, c'est le syst√®me de fichiers situ√© sur le support ins√©r√©.  En termes de travail avec une carte SD, <b>/ dev / sdb</b> est le lecteur et <b>/ dev / sdb1</b> est le syst√®me de fichiers sur la carte ins√©r√©e. <br><br><h3>  Fonction du syst√®me d'exploitation pour l'√©mission des commandes </h3><br>  Habituellement, dans n'importe quel syst√®me d'exploitation, toutes les choses non standard avec les p√©riph√©riques sont effectu√©es via des demandes directes au pilote.  Sous Linux, la fonction <b>ioctl ()</b> est disponible pour envoyer de telles requ√™tes.  Notre cas ne fait pas exception.  Comme argument, nous transmettons la requ√™te SG_IO d√©crite dans le fichier d'en-t√™te <b>sg.h.</b>  La structure <b>sg_io_hdr_t</b> contenant les param√®tres de requ√™te y est √©galement d√©crite.  Je ne donnerai pas la structure compl√®te, car tous ses champs ne doivent pas √™tre remplis.  Je ne donnerai que les plus importants d'entre eux: <br><br><pre><code class="plaintext hljs">typedef struct sg_io_hdr { int interface_id; /* [i] 'S' for SCSI generic (required) */ int dxfer_direction; /* [i] data transfer direction */ unsigned char cmd_len; /* [i] SCSI command length ( &lt;= 16 bytes) */ unsigned char mx_sb_len; /* [i] max length to write to sbp */ unsigned short int iovec_count; /* [i] 0 implies no scatter gather */ unsigned int dxfer_len; /* [i] byte count of data transfer */ void * dxferp; /* [i], [*io] points to data transfer memory or scatter gather list */ unsigned char * cmdp; /* [i], [*i] points to command to perform */ unsigned char * sbp; /* [i], [*o] points to sense_buffer memory */ unsigned int timeout; /* [i] MAX_UINT-&gt;no timeout (unit: millisec) */</code> </pre> <br>  Cela n'a aucun sens de d√©crire les champs qui sont bien document√©s dans les commentaires ( <b>interface_id, dxfer_direction, timeout</b> ).  L'article s'agrandit d√©j√†. <br><br>  Le champ <b>cmd_len</b> contient le nombre d'octets dans le bloc de commandes et <b>cmdp contient</b> un pointeur vers ce bloc.  Vous ne pouvez pas vous passer d'une commande, le nombre d'octets doit donc √™tre diff√©rent de z√©ro (de 6 √† 16). <br><br>  Les donn√©es sont facultatives.  Si tel est le cas, la longueur du tampon s√©lectionn√© est sp√©cifi√©e dans le champ <b>dxfer_len</b> et un pointeur vers celui-ci est sp√©cifi√© dans le champ <b>dxferp</b> .  Un lecteur peut physiquement transf√©rer moins de donn√©es que la taille de tampon sp√©cifi√©e.  Le sens de transmission est sp√©cifi√© dans le champ <b>dxfer_direction</b> .  Les valeurs de p√©riph√©rique de stockage de masse USB valides sont: <b>SG_DXFER_NONE, SG_DXFER_TO_DEV, SG_DXFER_FROM_DEV</b> .  Il y a encore une chose dans le fichier d'en-t√™te, mais la norme du p√©riph√©rique de stockage de masse ne permet pas de l'impl√©menter physiquement. <br><br>  Vous pouvez √©galement demander le retour d'un code d'erreur √©tendu ( <b>SENSE</b> ).  Ce que c'est peut √™tre trouv√© dans le document Segate, section 2.4.  La longueur du tampon allou√© est indiqu√©e dans le champ <b>mx_sb_len</b> et le pointeur vers le tampon lui-m√™me est indiqu√© dans le champ <b>sbp</b> . <br><br>  Comme vous pouvez le voir, tout ce dont j'ai parl√© ci-dessus est rempli dans cette structure (en plus, vous pouvez obtenir des informations d√©taill√©es sur l'erreur).  En savoir plus sur l' <b>utilisation de la</b> demande <b>SG_IO</b> ici: <a href="http://sg.danny.cz/sg/sg_io.html">sg.danny.cz/sg/sg_io.html</a> <br><br><h3>  Nous envoyons une commande standard au lecteur </h3><br>  Eh bien, nous avons d√©termin√© le format de la commande, nous avons d√©termin√© √† quel appareil l'envoyer, nous avons d√©termin√© la fonction √† appeler.  Essayons d'envoyer une commande standard √† notre appareil.  Que ce soit la commande pour obtenir le nom du lecteur.  Voici comment cela est d√©crit dans le document Sigeyt: <br><br><img src="https://habrastorage.org/webt/nj/qk/ca/njqkcamj1tnhjznoczjnrdfni60.png"><br><br>  Veuillez noter que selon l'id√©ologie SCSI, tous les champs des commandes standard sont remplis en notation Big Endian, c'est-√†-dire l'octet le plus √©lev√© en avant.  Par cons√©quent, nous remplissons le champ avec la longueur du tampon non pas au format "0x80, 0x00", mais au contraire - "0x00, 0x80".  Mais c'est dans les commandes standard.  En non standard tout est possible, vous devriez toujours consulter la description.  En fait, seul le code de commande ( <b>12h</b> ) et la longueur que nous devons remplir.  Nous demanderons une page z√©ro, et les champs restants sont soit r√©serv√©s, soit obsol√®tes, soit par d√©faut √† z√©ro.  Alors remplissez-les tous de z√©ros. <br><br><div class="spoiler">  <b class="spoiler_title">Nous faisons un programme qui donne cette commande:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; // open #include &lt;unistd.h&gt; // close #include &lt;sys/ioctl.h&gt; #include &lt;scsi/scsi.h&gt; #include &lt;scsi/sg.h&gt; int main() { printf("hello from SdAccessTest!\n"); int s_fd = open("/dev/sdb", O_NONBLOCK | O_RDWR); if (s_fd &lt; 0) { printf("Cannot open file\n"); return -1; } sg_io_hdr_t header; memset(&amp;header;, 0, sizeof(header)); uint8_t cmd12h[] = { 0x12,0x00,0x00,0x00,0x80,0x00}; uint8_t data[0x80]; uint8_t sense[0x80]; header.interface_id = 'S'; //  'S' //  header.cmd_len = sizeof(cmd12h); header.cmdp = cmd12h; //  header.dxfer_len = sizeof(data); header.dxferp = data; header.dxfer_direction = SG_DXFER_TO_FROM_DEV; //     header.mx_sb_len = sizeof(sense); header.sbp = sense; // header.timeout = 100; // 100  int res = ioctl(s_fd, SG_IO, &amp;header;); close(s_fd); return 0; }</code> </pre><br></div></div><br><br>  Comment ex√©cuter de tels programmes sur un p√©riph√©rique Redd distant, nous avons d√©j√† discut√© dans l'un des <a href="https://habr.com/ru/post/456008/">articles pr√©c√©dents</a> .  Certes, en le d√©marrant pour la premi√®re fois, j'ai imm√©diatement re√ßu une erreur lors de l'appel de la fonction <b>open ()</b> .  Il s'est av√©r√© que l'utilisateur par d√©faut ne dispose pas de droits suffisants pour ouvrir des p√©riph√©riques de disque.  Lequel de moi est un sp√©cialiste Linux, j'ai √©crit plusieurs fois, mais sur le r√©seau, j'ai r√©ussi √† trouver que pour r√©soudre ce probl√®me, vous pouvez changer les droits d'acc√®s √† l'appareil en √©mettant la commande: <br><br>  <b>sudo chmod 666 / dev / sdb</b> <br><br>  Cependant, mon patron (et il est un grand sp√©cialiste de ce syst√®me d'exploitation) a not√© plus tard que la solution √©tait valide jusqu'au red√©marrage du syst√®me d'exploitation.  Pour obtenir les droits √† coup s√ªr, vous devez ajouter l'utilisateur au groupe de <b>disques</b> . <br><br>  Quel que soit le chemin <b>emprunt√©</b> , mais apr√®s que tout a fonctionn√©, mettez un point d'arr√™t sur la ligne <b>close (s_fd);</b>  et inspecter les r√©sultats au moment o√π il est atteint dans l'environnement de d√©veloppement (puisque le programme n'est m√™me pas d'une journ√©e, ce qui signifie que nous n'avons pas le temps de consacrer du temps et des efforts √† l'insertion de mappeurs si l'environnement de d√©veloppement peut tout nous montrer).  La valeur de <b>res</b> est nulle.  L'√©quipe a donc travaill√© sans erreur. <br><br><img src="https://habrastorage.org/webt/ih/2o/40/ih2o40ujbpv2p0qk9m_qiwdw9do.png"><br><br>  Qu'est-il arriv√© au tampon?  Quand j'ai entr√© le mot <b>data</b> dans l'adresse du vidage, ils m'ont dit qu'ils ne pouvaient pas calculer la valeur, j'ai d√ª entrer <b>&amp; data;</b>  .  C'est √©trange, car les <b>donn√©es</b> sont un pointeur, lors du d√©bogage sous Windows, tout fonctionne, mais je note juste ce fait, cela fonctionne comme ceci: regardez le r√©sultat obtenu comme ceci: <br><br><img src="https://habrastorage.org/webt/bj/tk/ae/bjtkaehd8ucyzdufbdsn1392tgm.png"><br><br>  C'est vrai, ils nous ont retourn√© le nom et la r√©vision du lecteur.  Vous trouverez plus d'informations sur le format de la structure r√©sultante dans le document Segate (section 3.6.2, tableau 59).  Le tampon de <b>d√©tection</b> ne s'est pas rempli, mais la description IOCTL de la demande indique qu'il n'est rempli que lorsqu'une erreur se produit qui renvoie quelque chose dans ce tampon.  Litt√©ralement: <b>donn√©es de d√©tection (utilis√©es uniquement lorsque ¬´status¬ª est CHECK CONDITION ou (driver_status &amp; DRIVER_SENSE) est true)</b> . <br><br><h2>  Format de commande personnalis√© pour le lecteur SD interne Redd </h2><br>  Maintenant que nous avons non seulement √©tudi√© la description s√®che de la norme, mais que nous avons √©galement tout essay√© dans la pratique, ressentant ce qu'est un bloc de commande, nous pouvons d√©j√† montrer le format de commande avec lequel vous pouvez appeler des fonctions non standard qui sont ¬´flash√©es¬ª sur le contr√¥leur STM32 sur la carte du complexe.  J'ai s√©lectionn√© le code de commande depuis le d√©but de la gamme de commandes <b>sp√©cifiques au fournisseur</b> .  Il est √©gal √† 0xC0.  Traditionnellement, dans les descriptions des commandes SCSI, √©crivez <b>C0h</b> .  La longueur de la commande est toujours de 10 octets.  Le format de l'√©quipe est unifi√© et pr√©sent√© dans le tableau ci-dessous. <br><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Octet</b> </td><td>  <b>Rendez-vous</b> </td></tr><tr><td>  0 </td><td>  Code de commande C0h </td></tr><tr><td>  1 </td><td>  Code de sous-commande </td></tr><tr><td>  2 </td><td rowspan="4">  Argument arg1.  D√©fini en notation Little Endian (octet bas en avant) </td></tr><tr><td>  3 </td></tr><tr><td>  4 </td></tr><tr><td>  5 </td></tr><tr><td>  6 </td><td rowspan="4">  Argument arg2.  D√©fini en notation Little Endian (octet bas en avant) </td></tr><tr><td>  7 </td></tr><tr><td>  8 </td></tr><tr><td>  9 </td></tr></tbody></table></div><br>  Comme vous pouvez le voir, les arguments sont donn√©s dans la notation Little Endian.  Cela vous permettra de d√©crire la commande sous la forme d'une structure et d'acc√©der directement √† ses champs, sans recourir √† la fonction de permutation d'octets.  Les probl√®mes d'alignement (les mots doubles dans la structure ont des d√©calages qui ne sont pas multiples de quatre) sur les architectures x86 et x64 n'en valent pas la peine. <br><br>  Les codes de sous-commande sont d√©crits par l'√©num√©ration suivante: <br><pre> <code class="plaintext hljs">enum vendorSubCommands { subCmdSdEnable = 0, // 00 Switch SD card to PC or Outside subCmdSdPower, // 01 Switch Power of SD card On/Off subCmdSdReinit, // 02 Reinitialize SD card (for example, after Power Cycle) subCmdSpiFlashEnable, // 03 Switch SPI Flash to PC or Outside subCmdSpiFlashWritePage, // 04 Write Page to SPI Flash subCmdSpiFlashReadPage, // 05 Read Page from SPI Flash subCmdSpiFlashErasePage,// 06 Erase Pages on SPI Flash (4K block) subCmdRelaysOn, // 07 Switch relays On by mask subCmdRelaysOff, // 08 Switch relays off by mask subCmdRelaysSet, // 09 Set state of all relays by data subCmdFT4222_1_Reset, // 0A Activate Reset State or switch chip to normal mode subCmdFT4222_2_Reset, // 0B Activate Reset State or switch chip to normal mode subCmdFT4222_3_Reset, // 0C Activate Reset State or switch chip to normal mode subCmdFT4232_Reset, // 0D Activate Reset State or switch chip to normal mode subCmdFT2232_Reset, // 0E Activate Reset State or switch chip to normal mode subCmdMAX3421_Reset, // 0F Activate Reset State or switch chip to normal mode subCmdFT4222_1_Cfg, // 10 Write to CFG pins of FT4222_1 subCmdFT4222_2_Cfg, // 11 Write to CFG pins of FT4222_2 subCmdFT4222_3_Cfg, // 12 Write to CFG pins of FT4222_3 };</code> </pre><br>  Ils peuvent √™tre divis√©s en groupes. <br><br><h3>  Passage des appareils en modes interne et externe </h3><br>  Les <b>commandes</b> <b>subCmdSdEnable</b> et <b>subCmdSpiFlashEnable</b> commutent respectivement la carte SD et le flash SPI.  Le param√®tre <b>arg1</b> transmet l'une des valeurs suivantes: <br><br><pre> <code class="plaintext hljs">enum enableMode { enableModeToPC = 0, enableModeOutside };</code> </pre> <br>  Par d√©faut, les deux appareils sont connect√©s √† un PC. <br><br><h3>  Commutation de puissance </h3><br>  Le protocole SDIO n√©cessite pas mal de manipulations lors de l'initialisation.  Parfois, il est utile de r√©initialiser la carte SD √† son √©tat initial (par exemple, lors du basculement de ses lignes vers un connecteur externe).  Pour ce faire, √©teignez-le, puis rallumez-le.  Cela peut √™tre fait √† l'aide de la <b>commande subCmdSdPower</b> .  Dans l'argument <b>arg1, l'</b> une des valeurs suivantes est transmise: 0 - mise hors tension, 1 - mise sous tension.  N'oubliez pas de donner le temps de d√©charger les condensateurs sur la ligne √©lectrique. <br><br>  Apr√®s la mise sous tension, la carte, si elle est connect√©e au PC, doit √™tre r√©initialis√©e.  Pour ce faire, utilisez la commande <b>subCmdSdReinit</b> (elle n'a pas d'arguments). <br><br><h3>  Travailler avec le lecteur flash SPI </h3><br>  Si la carte SD est connect√©e au syst√®me en tant que lecteur complet, la puce d'acc√®s dans la version actuelle est assez limit√©e.  Vous ne pouvez acc√©der qu'√† ses pages individuelles (256 octets) et une seule √† la fois.  La quantit√© de m√©moire dans le microcircuit est telle que m√™me lorsque vous travaillez sur la page, le processus ne prendra pas beaucoup de temps de toute fa√ßon, mais cette approche simplifie consid√©rablement le ¬´firmware¬ª du microcontr√¥leur. <br><br>  La commande <b>subCmdSpiFlashReadPage</b> lit la page.  L'adresse est sp√©cifi√©e dans le param√®tre arg1, le nombre de pages √† transmettre dans le param√®tre arg2.  Mais dans la version actuelle, le nombre de pages doit √™tre √©gal √† un.  La commande renverra 256 octets de donn√©es. <br><br>  <b>La</b> commande <b>subCmdSpiFlashWritePage</b> est en miroir pour elle.  Les arguments pour elle sont compl√©t√©s par le m√™me principe.  La direction du transfert de donn√©es est vers l'appareil. <br><br>  La particularit√© de la m√©moire flash est que seuls des bits simples peuvent √™tre remplac√©s par des bits z√©ro pendant l'enregistrement.  Pour les ramener √† une seule valeur, les pages doivent √™tre effac√©es.  Il existe une commande <b>subCmdSpiFlashErasePage</b> pour <b>cela</b> .  Certes, en raison des caract√©ristiques du microcircuit utilis√©, ce n'est pas une seule page d√©finie dans le param√®tre <b>arg1</b> qui est effac√©e, mais un bloc de 4 kilo-octets le contenant. <br><br><h3>  Gestion des relais statiques </h3><br>  Le complexe dispose de six relais statiques.  Il y a trois √©quipes pour les g√©rer. <br><br>  <b>subCmdRelaysSet</b> - d√©finit la valeur des six relais simultan√©ment.  Dans le param√®tre <b>arg1, une</b> valeur est transmise, chaque bit correspondant √† son propre relais (bit z√©ro - relais avec index 0, premier bit avec index 1, etc.).  Une seule valeur de bit ferme le relais, une valeur nulle provoque son ouverture. <br><br>  Cette m√©thode de fonctionnement est bonne lorsque tous les relais fonctionnent comme un seul groupe.  S'ils fonctionnent ind√©pendamment les uns des autres, avec cette approche, vous devez d√©marrer une variable tampon qui stocke la valeur d'√©tat de tous les relais.  Si diff√©rents relais sont contr√¥l√©s par diff√©rents programmes, le probl√®me du stockage de la valeur agr√©g√©e devient extr√™mement aigu.  Dans ce cas, vous pouvez utiliser deux autres commandes: <br><br>  <b>subCmdRelaysOn</b> - active les relais s√©lectionn√©s par masque.  Les relais qui correspondent aux bits unitaires dans l'argument <b>arg1</b> seront activ√©s.  Les relais qui correspondent √† des z√©ros dans le masque conserveront leur √©tat actuel. <br><br>  La commande <b>subCmdRelaysOff en miroir</b> d√©sactivera les relais s√©lectionn√©s par masque.  Les relais qui correspondent aux bits simples de l'argument <b>arg1</b> seront d√©sactiv√©s.  Les relais qui correspondent √† des z√©ros dans le masque conserveront leur √©tat actuel. <br><br><h3>  R√©initialiser les contr√¥leurs FTDI et Maxim </h3><br>  Pour envoyer des signaux de r√©initialisation aux microcircuits FTDI et Maxim, le groupe de commandes <b>subCmdFT4222_1_Reset</b> , <b>subCmdFT4222_2_Reset</b> , <b>subCmdFT4222_3_Reset</b> , <b>subCmdFT4232_Reset</b> , <b>subCmdFT2232_Reset</b> et <b>subCmdMAX3421_</b> .  De leurs noms, vous pouvez voir les puces qu'ils contr√¥lent par des signaux de r√©initialisation.  Les ponts FT4222, comme nous l'avons consid√©r√© pr√©c√©demment, sont deux dans le circuit (leurs indices sont 1 et 2), un autre pont FT4222 transf√®re les donn√©es √† la puce MAX3421, que nous examinerons dans l'article suivant. <br><br>  Le param√®tre <b>arg1</b> transmet l'une des valeurs suivantes: <br><br><pre> <code class="plaintext hljs">enum ResetState { resetStateActive =0, resetStateNormalOperation };</code> </pre> <br>  Par d√©faut, tous les ponts sont en √©tat de fonctionnement normal.  Comme d√©j√† indiqu√© dans un <a href="https://habr.com/ru/post/483724/">article pr√©c√©dent</a> , nous ne savons pas nous-m√™mes si cette fonctionnalit√© est n√©cessaire, mais lorsqu'il n'y a pas d'acc√®s direct √† l'appareil, il est pr√©f√©rable de pouvoir r√©initialiser √† distance tout et tout. <br><br><h3>  Commutation des lignes de configuration des puces FT4222 </h3><br>  Les puces FT4222 ont quatre modes.  Il est peu probable que quelqu'un ait besoin d'un mode autre que "00", mais si vous en avez soudainement besoin, vous pouvez utiliser les commandes <b>subCmdFT4222_1_Cfg</b> , <b>subCmdFT4222_2_Cfg</b> et <b>subCmdFT4222_3_Cfg</b> pour <b>commuter</b> les premi√®re, deuxi√®me et troisi√®me puces.  La valeur des lignes CFG0 et CFG1 est d√©finie dans les deux bits inf√©rieurs du param√®tre <b>arg1</b> . <br><br><h2>  Exp√©rience pratique dans l'√©mission de commandes vers le contr√¥leur STM32 </h2><br>  Pour tester le mat√©riel th√©orique obtenu dans la pratique, nous allons essayer d'√©teindre la carte SD.  Pour ce faire, <b>ex√©cutez la</b> commande <b>subCmdSdEnable</b> avec le code 0x00 avec l'argument <b>enableModeOutside</b> avec le code 0x01.  Super.  Nous r√©√©crivons le programme √† partir de l'exp√©rience pass√©e comme suit. <br><br><div class="spoiler">  <b class="spoiler_title">Programme r√©√©crit:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; // open #include &lt;unistd.h&gt; // close #include &lt;sys/ioctl.h&gt; #include &lt;scsi/scsi.h&gt; #include &lt;scsi/sg.h&gt; int main() { printf("hello from SdAccessTest!\n"); int s_fd = open("/dev/sdb", O_NONBLOCK | O_RDWR); if (s_fd &lt; 0) { printf("Cannot open file\n"); return -1; } sg_io_hdr_t header; memset(&amp;header;, 0, sizeof(header)); uint8_t cmdSdToOutside[] = { 0xC0,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }; uint8_t cmdSdToPC[] = { 0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }; uint8_t sense[32]; memset(sense, 0, sizeof(sense)); header.interface_id = 'S'; //  'S' //  header.cmd_len = sizeof(cmdSdToOutside); header.cmdp = cmdSdToOutside; //  ( ) header.dxfer_len = 0; header.dxferp = 0; header.dxfer_direction = SG_DXFER_NONE; //     header.mx_sb_len = sizeof(sense); header.sbp = sense; // header.timeout = 100; // 100  int res = ioctl(s_fd, SG_IO, &amp;header;); //   header.cmdp = cmdSdToPC; res = ioctl(s_fd, SG_IO, &amp;header;); close(s_fd); return 0; }</code> </pre><br></div></div><br>  Nous avons modifi√© la longueur de la commande √† dix octets et supprim√© le bloc de donn√©es.  Eh bien, ils ont √©crit le code de commande avec des arguments, comme requis.  Sinon, tout reste le m√™me.  Nous commen√ßons ... Et ... Rien ne fonctionne.  La fonction <b>ioctl ()</b> renvoie une erreur.  La raison est d√©crite dans le <b>document de</b> commande <b>SG_IO</b> .  Le fait est que nous donnons la commande sp√©cifique au vendeur <b>C0h</b> , et ce qui suit est dit √† leur sujet litt√©ralement: <br><blockquote>  Toute autre commande SCSI (opcode) non mentionn√©e pour le pilote sg n√©cessite O_RDWR.  Toute autre commande SCSI (opcode) non mentionn√©e pour la couche de bloc SG_IO ioctl a besoin d'un utilisateur avec la capacit√© CAP_SYS_RAWIO. </blockquote><br>  Comme le patron m'a expliqu√© (je ne fais que r√©p√©ter ses mots), <b>des</b> valeurs de <b>capacit√©s</b> sont affect√©es √† un fichier ex√©cutable.  Pour cette raison, j'ai d√ª tracer √† partir de l'environnement de d√©veloppement en me connectant en tant que <b>root</b> .  Pas la meilleure solution, mais au moins quelque chose.  En fait, sous Windows, la demande <b>IOCTL_SCSI_PASS_THROUGH_DIRECT</b> n√©cessite √©galement des droits d'administrateur.  Peut-√™tre que dans les commentaires, quelqu'un donnera des conseils sur la fa√ßon de r√©soudre le probl√®me de tra√ßage sans ces √©tapes drastiques, mais vous pouvez ex√©cuter le programme d√©j√† √©crit sans <b>root</b> , si vous enregistrez les <b>capacit√©s</b> appropri√©es <b>pour cela</b> .  En attendant, changez le nom d'utilisateur dans l'environnement de d√©veloppement et d√©finissez un point d'arr√™t sur la ligne: <br><br><pre> <code class="plaintext hljs">int res = ioctl(s_fd, SG_IO, &amp;header;);</code> </pre> <br>  et avant d'appeler la fonction <b>ioctl ()</b> , nous regardons la liste des p√©riph√©riques de stockage: <br><br><img src="https://habrastorage.org/webt/ys/ef/ls/yseflsambpnn83pbywoqfuazoqi.png"><br><br>  Appelez <b>ioctl ()</b> et regardez √† nouveau la liste: <br><br><img src="https://habrastorage.org/webt/ro/2g/33/ro2g331krziu9uslxuzo28hylxa.png"><br><br>  Le p√©riph√©rique <b>/ dev / sdb</b> est rest√© (en gros, c'est le lecteur de carte SD lui-m√™me), et <b>/ dev / sdb1 a</b> disparu.  Cet appareil correspond au syst√®me de fichiers sur le support.  Le transporteur s'est d√©connect√© de l'ordinateur - il n'√©tait plus visible.  Nous continuons le tra√ßage.  Apr√®s avoir appel√© la deuxi√®me fonction <b>ioctl ()</b> , nous regardons √† nouveau la liste des p√©riph√©riques: <br><br><img src="https://habrastorage.org/webt/rd/wi/zx/rdwizxqu4amrqeuhzghnrptvkly.png"><br><br>  La carte SD est reconnect√©e au syst√®me, donc <b>/ dev / sdb1 est de</b> nouveau en place.  En fait, nous avons appris √† √©mettre des commandes sp√©cifiques au fournisseur et √† g√©rer un p√©riph√©rique bas√© sur le microcontr√¥leur STM32 dans le complexe Redd.  D'autres commandes seront laiss√©es aux lecteurs pour √©tude ind√©pendante.  Vous pouvez contr√¥ler le fonctionnement de certains d'entre eux de mani√®re similaire.  Si une puce <b>ftdi passe</b> dans un √©tat de r√©initialisation, le p√©riph√©rique correspondant dispara√Ætra du syst√®me.  Le fonctionnement du relais et le contr√¥le des jambes de la configuration devront √™tre contr√¥l√©s par des instruments de mesure.  Eh bien, vous pouvez v√©rifier le travail avec un lecteur flash en √©crivant des pages avec leur contr√¥le de lecture ult√©rieur. <br><br><h2>  Conclusion </h2><br>  Nous avons examin√© deux grands sujets qui ne sont pas li√©s aux FPGA dans le complexe Redd.  Le troisi√®me est rest√© - travailler avec la puce MAX3421, qui permet d'impl√©menter des p√©riph√©riques USB 2.0 FS.  En fait, il y a aussi des h√¥tes, mais il y a beaucoup d'h√¥tes et la carte m√®re.  La fonctionnalit√© de l'appareil permettra au complexe de faire semblant d'√™tre un lecteur flash USB (pour envoyer des mises √† jour de ¬´firmware¬ª), un clavier USB (pour contr√¥ler les unit√©s externes), etc.  Nous examinerons ce sujet dans le prochain article. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484706/">https://habr.com/ru/post/fr484706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484686/index.html">Pourquoi les r√©sistances sont-elles indiqu√©es par leur couleur?</a></li>
<li><a href="../fr484688/index.html">Nous approchons de la limite de la puissance de calcul - nous avons besoin de nouveaux programmeurs</a></li>
<li><a href="../fr484690/index.html">S√©minaire, conf√©rence, mitap: √©tudier les statistiques de 18 000 √©v√©nements</a></li>
<li><a href="../fr484700/index.html">Java 14: aper√ßu des enregistrements</a></li>
<li><a href="../fr484702/index.html">Alternatives √† Prestashop en 2020: les meilleures plateformes de commerce √©lectronique</a></li>
<li><a href="../fr484708/index.html">Richard Hamming "Chapitre inexistant": Comment savons-nous ce que nous savons (version compl√®te)</a></li>
<li><a href="../fr484710/index.html">Enfreindre les r√®gles de la collecte des ordures Unity</a></li>
<li><a href="../fr484712/index.html">Compatibilit√© binaire Reaktive: comment nous la fournissons</a></li>
<li><a href="../fr484716/index.html">Arr√™tez d'appeler tout AI</a></li>
<li><a href="../fr484718/index.html">Les imprimantes modernes HP refusent de travailler sans abonnement √† l'encre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>