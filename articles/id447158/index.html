<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£üèæ üîè üìû Wireshark 3.x: analisis kode macOS dan tinjauan bug üë©‚Äç‚ù§Ô∏è‚Äçüë© üôÖüèø üàØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Wireshark Foundation telah merilis versi stabil terakhir dari penganalisa lalu lintas jaringan populer - Wireshark 3.0.0. Rilis baru memperbaiki b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wireshark 3.x: analisis kode macOS dan tinjauan bug</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/447158/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5d/b08/9a1/e5db089a18a6e0f13aaf26e7f0c5fb91.png" alt="Gambar 1"></div><br>  The Wireshark Foundation telah merilis versi stabil terakhir dari penganalisa lalu lintas jaringan populer - Wireshark 3.0.0.  Rilis baru memperbaiki beberapa bug, mengimplementasikan kemampuan untuk menganalisis protokol baru dan mengganti driver WinPcap dengan Npcap.  Di sini kutipan pengumuman berakhir dan artikel kami tentang bug dalam proyek dimulai.  Sebelum rilis, mereka jelas tidak cukup diperbaiki.  Mari kita perbaiki sehingga ada alasan untuk membuat rilis baru :). <br><br><h2>  Pendahuluan </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wireshark</a> adalah alat yang terkenal untuk menangkap dan menganalisis lalu lintas jaringan.  Program ini bekerja dengan sebagian besar protokol yang diketahui, memiliki antarmuka grafis yang jelas dan logis, sistem filter yang kuat.  Wireshark - lintas-platform, bekerja di OS seperti: Windows, Linux, macOS, Solaris, FreeBSD, NetBSD dan banyak lainnya. <br><br>  Untuk mencari kesalahan, kami menggunakan penganalisa statis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> .  Untuk menganalisis kode sumber, Anda harus terlebih dahulu mengkompilasi proyek di beberapa sistem operasi.  Pilihannya bagus bukan hanya karena sifat lintas-platform dari proyek, tetapi juga karena sifat lintas-platform dari penganalisa.  Untuk menganalisis proyek, saya memilih macOS.  Alat analisis juga dapat diluncurkan pada Windows dan Linux. <br><br>  Tentang kualitas kode yang ingin saya sampaikan secara terpisah.  Sayangnya, saya tidak bisa menyebutnya bagus.  Ini adalah penilaian subjektif, tetapi karena kami secara teratur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memeriksa</a> banyak proyek, saya memiliki sesuatu untuk dibandingkan.  Dalam hal ini, sejumlah besar peringatan PVS-Studio pada sejumlah kecil kode sangat mencolok.  Secara total, lebih dari 3.500 peringatan dari semua tingkatan telah dikeluarkan untuk proyek ini.  Ini tipikal untuk proyek yang tidak menggunakan alat analisis statis sama sekali, bahkan yang gratis.  Faktor lain yang menunjukkan kualitas proyek adalah kesalahan berulang yang diidentifikasi oleh penganalisa.  Contoh kode yang sama tidak akan diberikan dalam artikel, tetapi beberapa kesalahan identik ada dalam kode di ratusan tempat. <br><a name="habracut"></a><br>  Sisipan semacam itu tidak menambah kualitas pada kode: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Input file: packet-acse-template.c */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">line</span></span></span><span class="hljs-meta"> 1 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"./asn1/acse/packet-acse-template.c"</span></span></span></span></code> </pre> <br>  Ada lebih dari 1000 di seluruh proyek.  Sisipan semacam itu mempersulit penganalisa untuk membandingkan peringatan yang dihasilkan dengan file yang diinginkan.  Tapi saya yakin pengembang biasa tidak menikmati dukungan kode seperti itu. <br><br><h2>  Salah ketik </h2><br>  <b>Peringatan 1</b> <br><br>  V641 Ukuran buffer memori yang dialokasikan bukan kelipatan dari ukuran elemen.  mate_setup.c 100 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> mate_cfg_gog* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_gogcfg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mate_config* mc, gchar* name)</span></span></span><span class="hljs-function"> </span></span>{ mate_cfg_gog* cfg = (mate_cfg_gog *)g_malloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(mate_cfg_gop)); .... }</code> </pre> <br>  Ada dua jenis struktur: <i>mate_cfg_gog</i> dan <i>mate_cfg_gop</i> , mereka sangat mirip, tetapi tidak identik.  Kemungkinan besar, fungsi-fungsi tercampur dalam fragmen kode ini, yang penuh dengan potensi kesalahan dalam program selama akses memori oleh pointer. <br><br>  Berikut ini adalah potongan-potongan struktur data yang bingung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mate_cfg_gog</span></span></span><span class="hljs-class"> {</span></span> gchar* name; GHashTable* items; guint last_id; GPtrArray* transforms; LoAL* keys; AVPL* extra; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> expiration; <span class="hljs-keyword"><span class="hljs-keyword">gop_tree_mode_t</span></span> gop_tree_mode; gboolean show_times; .... } mate_cfg_gog; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mate_cfg_gop</span></span></span><span class="hljs-class"> {</span></span> gchar* name; guint last_id; GHashTable* items; GPtrArray* transforms; gchar* on_pdu; AVPL* key; AVPL* start; AVPL* stop; AVPL* extra; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> expiration; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> idle_timeout; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lifetime; gboolean drop_unassigned; <span class="hljs-keyword"><span class="hljs-keyword">gop_pdu_tree_t</span></span> pdu_tree_mode; gboolean show_times; .... } mate_cfg_gop;</code> </pre> <br>  <b>Peringatan 2</b> <br><br>  V519 Variabel 'HDR_TCP.dest_port' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 495, 496. text_import.c 496 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_current_packet</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... HDR_TCP.source_port =isOutbound ? g_htons(hdr_dest_port):g_htons(hdr_src_port); HDR_TCP.dest_port = isOutbound ? g_htons(hdr_src_port) :g_htons(hdr_dest_port); HDR_TCP.dest_port = g_htons(hdr_dest_port); .... }</code> </pre> <br>  Di baris terakhir, nilai yang dihitung hanya dari variabel <i>HDR_TCP.dest_port</i> tidak <i>dikonfirmasi</i> . <br><br><h2>  Kesalahan logis </h2><br>  Pada bagian ini saya akan memberikan beberapa contoh kesalahan dalam pernyataan bersyarat, dan semuanya akan berbeda secara mendasar satu sama lain. <br><br>  <b>Peringatan 1</b> <br><br>  Ekspresi V547 'direction == 0' selalu salah.  paket-adb.c 291 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> P2P_DIR_RECV 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> P2P_DIR_SENT 0 static void save_command(....) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( service_data &amp;&amp; service_data-&gt;remote_id == 0 &amp;&amp; direction == P2P_DIR_RECV) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (direction == P2P_DIR_SENT) { service_data-&gt;remote_id = arg1; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// unreachable code } else { service_data-&gt;remote_id = arg0; } .... } .... }</span></span></span></span></code> </pre> <br>  Dalam kondisi eksternal, variabel <i>arah</i> dibandingkan dengan <i>P2P_DIR_RECV</i> konstan.  Menulis ekspresi melalui operator AND berarti bahwa ketika kondisi internal tercapai, nilai variabel <i>arah</i> pasti tidak akan sama dengan <i>P2P_DIR_SENT</i> konstan <i>lainnya</i> . <br><br>  <b>Peringatan 2</b> <br><br>  V590 Pertimbangkan untuk memeriksa '(type == 0x1) ||  (ketik! = 0x4) ekspresi.  Ekspresi berlebihan atau mengandung kesalahan cetak.  package-fcsb3.c 686 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_fc_sbccs</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((type == FC_SBCCS_IU_CMD_HDR) || (type != FC_SBCCS_IU_CMD_DATA)) { .... }</code> </pre> <br>  Kesalahan fragmen kode ini adalah bahwa hasil dari kondisi tergantung hanya pada satu ekspresi: <br><br><pre> <code class="cpp hljs">(type != FC_SBCCS_IU_CMD_DATA)</code> </pre> <br>  <b>Peringatan 3</b> <br><br>  V590 Pertimbangkan untuk memeriksa ungkapan ini.  Ekspresi berlebihan atau mengandung kesalahan cetak.  snort-config.c 40 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skipWhiteSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *accumulated_offset)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Skip any leading whitespace */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (source[offset] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> &amp;&amp; source[offset] == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { offset++; } *accumulated_offset += offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source + offset; }</code> </pre> <br>  Hasil pernyataan kondisional hanya akan bergantung pada bagian ekspresi ini <i>(sumber [offset] == ‚Äã‚Äã'')</i> .  Pemeriksaan <i>(sumber [offset]! = '\ 0')</i> berlebihan dan dapat dihapus dengan aman.  Ini bukan kesalahan nyata, tetapi kode yang berlebihan membuatnya sulit untuk membaca dan memahami program, jadi lebih baik untuk menyederhanakannya. <br><br>  <b>Peringatan 4</b> <br><br>  Ekspresi V547 'eras_pos! = NULL' selalu benar.  reedsolomon.c 659 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eras_dec_rs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dtype data[NN], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eras_pos[NN-KK], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> no_eras)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(eras_pos != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;count;i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(eras_pos!= <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) eras_pos[i] = INDEX_TO_POS(loc[i]); } } .... }</code> </pre> <br>  Mungkin kita berhadapan dengan verifikasi yang tidak perlu, dan mungkin dengan kesalahan ketik, dan dalam salah satu jika, ada hal lain yang harus diperiksa. <br><br><h2>  Aset Aneh </h2><br>  <b>Peringatan 1</b> <br><br>  V547 Ekspresi 'sub_dissectors! = NULL' selalu benar.  capture_dissectors.c 129 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">capture_dissector_add_uint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... sub_dissectors = (struct capture_dissector_table*)g_hash_table_lookup(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sub_dissectors == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"OOPS: Subdissector \"%s\" not found ... \n"</span></span>, name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getenv(<span class="hljs-string"><span class="hljs-string">"WIRESHARK_ABORT_ON_DISSECTOR_BUG"</span></span>) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } g_assert(sub_dissectors != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Memeriksa pointer di <i>g_assert</i> pada saat ini berlebihan, karena pointer diperiksa sebelum itu.  Mungkin dalam fungsi ini hanya ada <i>g_assert sebelumnya</i> , dan mereka lupa menghapusnya, tapi mungkin di sini Anda harus memeriksa beberapa bidang struktur. <br><br>  <b>Peringatan 2</b> <br><br>  Ekspresi V547 'i &lt;count' selalu benar.  packet-netflow.c 10363 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_v9_v10_template_fields</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... count = tmplt_p-&gt;field_count[fields_type]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;count; i++) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tmplt_p-&gt;fields_p[fields_type] != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { DISSECTOR_ASSERT (i &lt; count); <span class="hljs-comment"><span class="hljs-comment">// &lt;= tmplt_p-&gt;fields_p[fields_type][i].type = type; tmplt_p-&gt;fields_p[fields_type][i].length = length; tmplt_p-&gt;fields_p[fields_type][i].pen = pen; tmplt_p-&gt;fields_p[fields_type][i].pen_str = pen_str; if (length != VARIABLE_LENGTH) {/ tmplt_p-&gt;length += length; } } .... } .... }</span></span></code> </pre> <br>  Tidak jelas mengapa fungsi memiliki pernyataan yang menduplikasi kondisi dari satu loop.  Penghitung siklus di tubuh tidak berubah. <br><br><h2>  Kesalahan dengan pointer </h2><br>  <b>Peringatan 1</b> <br><br>  V595 Pointer 'si-&gt; conv' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 2135, 2144. package-smb2.c 2135 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_smb2_fid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... g_hash_table_insert(si-&gt;conv-&gt;fids, sfi, sfi); <span class="hljs-comment"><span class="hljs-comment">// &lt;= si-&gt;file = sfi; if (si-&gt;saved) { si-&gt;saved-&gt;file = sfi; si-&gt;saved-&gt;policy_hnd = policy_hnd; } if (si-&gt;conv) { // &lt;= eo_file_info = (.... *)g_hash_table_lookup(si-&gt;conv-&gt;files,&amp;policy_hnd); .... } .... }</span></span></code> </pre> <br>  Pointer <i>si-&gt; conv</i> didereferensi beberapa garis lebih awal daripada yang diperiksa apakah sama dengan nol atau tidak. <br><br>  <b>Peringatan 2</b> <br><br>  V774 Penunjuk 'protos' digunakan setelah memori dilepaskan.  paket-k12.c 311 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">k12_update_cb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** err)</span></span></span><span class="hljs-function"> </span></span>{ gchar** protos; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num_protos; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ! (h-&gt;handles[i] = find_dissector(protos[i])) ) { h-&gt;handles[i] = data_handle; h-&gt;handles[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; g_strfreev(protos); *err = g_strdup_printf(<span class="hljs-string"><span class="hljs-string">"Could not find dissector for: '%s'"</span></span>, protos[i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; } } .... }</code> </pre> <br>  <i>protos</i> adalah array string.  Selama memproses pengecualian dalam program, array ini pertama kali dihapus oleh fungsi <i>g_strfreev</i> , dan kemudian salah satu baris array ini digunakan dalam pesan kesalahan.  Kemungkinan besar, baris-baris ini dalam kode harus dipertukarkan: <br><br><pre> <code class="cpp hljs">*err = g_strdup_printf(<span class="hljs-string"><span class="hljs-string">"Could not find dissector for: '%s'"</span></span>, protos[i]); g_strfreev(protos);</code> </pre> <br><h2>  Memori bocor </h2><br>  V773 Pointer 'ptmpstr' diberi nilai dua kali tanpa melepaskan memori.  Kebocoran memori dimungkinkan.  idl2wrs.c 2436 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parsetypedefunion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tmpstr[BASE_BUFFER_SIZE], *ptmpstr; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(num_pointers--){ g_snprintf(tmpstr, BASE_BUFFER_SIZE, <span class="hljs-string"><span class="hljs-string">"%s_%s"</span></span>, ptmpstr, <span class="hljs-string"><span class="hljs-string">"unique"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"static int\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"...."</span></span>, tmpstr); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"{\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">" ...."</span></span>, ptmpstr, ti-&gt;str); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">" return offset;\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); ptmpstr=g_strdup(tmpstr); } .... }</code> </pre> <br>  Setelah fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>g_strdup</i></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>Anda</i></a> perlu memanggil fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>g_free</i></a> di beberapa titik.  Dalam fragmen kode yang disajikan, ini tidak dilakukan, dan dalam loop di setiap iterasi, sepotong RAM baru dialokasikan.  Banyak kebocoran memori terjadi. <br><br>  Beberapa peringatan lagi untuk cuplikan kode serupa: <br><br><ul><li>  V773 Pointer 'ptmpstr' diberi nilai dua kali tanpa melepaskan memori.  Kebocoran memori dimungkinkan.  idl2wrs.c 2447 </li><li>  V773 Pointer 'ptmpstr' diberi nilai dua kali tanpa melepaskan memori.  Kebocoran memori dimungkinkan.  idl2wrs.c 2713 </li><li>  V773 Pointer 'ptmpstr' diberi nilai dua kali tanpa melepaskan memori.  Kebocoran memori dimungkinkan.  idl2wrs.c 2728 </li><li>  V773 Pointer 'ptmpstr' diberi nilai dua kali tanpa melepaskan memori.  Kebocoran memori dimungkinkan.  idl2wrs.c 2732 </li><li>  V773 Pointer 'ptmpstr' diberi nilai dua kali tanpa melepaskan memori.  Kebocoran memori dimungkinkan.  idl2wrs.c 2745 </li></ul><br>  Sayangnya, ada banyak tempat lain yang serupa dalam kode di mana memori tidak dibebaskan. <br><br><h2>  Lain-lain </h2><br>  <b>Peringatan 1</b> <br><br>  V535 Variabel 'i' digunakan untuk loop ini dan untuk loop luar.  Periksa baris: 7716, 7798. package-opa-mad.c 7798 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Parse GetVFInfo MAD from the Performance Admin class. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_GetVFInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; records; i++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= line 7716 .... for (i = 0; i &lt; PM_UTIL_BUCKETS; i++) { // &lt;= line 7748 GetVFInfo_Util_Stats_Bucket_item = proto_tree_add_item(....); proto_item_set_text(....); local_offset += 4; } .... for (i = 0; i &lt; PM_ERR_BUCKETS; i++) { // &lt;= line 7798 GetVFInfo_Error_Stats_Bucket_item = proto_tree_add_item(....); proto_item_set_text(....); local_offset += 4; .... } .... } .... }</span></span></code> </pre> <br>  Dalam fungsi yang sangat panjang, pengembang dengan berani mengubah nilai penghitung lingkaran, dan melakukan ini beberapa kali.  Sulit untuk mengatakan apakah ini kesalahan atau tidak, tetapi ada sekitar 10 siklus dalam proyek tersebut. <br><br>  <b>Peringatan 2</b> <br><br>  V763 Parameter 'item' selalu ditulis ulang di badan fungsi sebelum digunakan.  package-cdma2k.c 1324 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cdma2k_message_ORDER_IND</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(proto_item *item, ....)</span></span></span><span class="hljs-function"> </span></span>{ guint16 addRecLen = <span class="hljs-number"><span class="hljs-number">-1</span></span>, ordq = <span class="hljs-number"><span class="hljs-number">-1</span></span>, rejectedtype = <span class="hljs-number"><span class="hljs-number">-1</span></span>; guint16 l_offset = <span class="hljs-number"><span class="hljs-number">-1</span></span>, rsc_mode_ind = <span class="hljs-number"><span class="hljs-number">-1</span></span>, ordertype = <span class="hljs-number"><span class="hljs-number">-1</span></span>; proto_tree *subtree = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, *subtree1 = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; item = proto_tree_add_item(tree,hf_cdma2k_OrderIndMsg, tvb, ....); <span class="hljs-comment"><span class="hljs-comment">// &lt;= subtree = proto_item_add_subtree(item, ett_cdma2k_subtree1); .... }</span></span></code> </pre> <br>  Pointer <i>item</i> yang diambil fungsi segera rusak oleh nilai lain.  Ini sangat mencurigakan.  Selain itu, kode tersebut berisi beberapa lusin tempat seperti itu, sehingga sulit untuk mengatakan apakah ini kesalahan atau tidak.  Saya bertemu dengan kode yang sama sebelumnya di proyek besar lainnya, itu kode yang benar, hanya saja tidak ada yang berani mengubah antarmuka fungsi. <br><br>  <b>Peringatan 3</b> <br><br>  V762 Mungkin saja fungsi virtual diganti secara tidak benar.  Lihat argumen ketiga fungsi 'headerData' di kelas turunan 'PacketListModel' dan kelas dasar 'QAbstractItemModel'.  package_list_model.h 48 <br><br><pre> <code class="cpp hljs">QVariant QAbstractItemModel::headerData(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> section, Qt::Orientation orientation, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> role = Qt::DisplayRole) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-comment"><span class="hljs-comment">// &lt;= class PacketListModel : public QAbstractItemModel { Q_OBJECT public: .... QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole | Qt::ToolTipRole) const; // &lt;= .... };</span></span></code> </pre> <br>  Analyzer mendeteksi kelebihan fungsi <i>headerData yang salah</i> .  Fungsi memiliki nilai default yang berbeda untuk parameter <i>peran</i> .  Ini mungkin tidak mengarah pada perilaku yang diharapkan oleh programmer. <br><br>  <b>Peringatan 4</b> <br><br>  V610 Perilaku tidak terdefinisi.  Periksa operator shift '&gt;&gt;'.  Operan kanan ('bitshift' = [0..64]) lebih besar dari atau sama dengan panjang dalam bit dari operan kiri yang dipromosikan.  proto.c 10941 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proto_item_add_bitmask_tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || len &gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) g_assert_not_reached(); bitshift = (<span class="hljs-number"><span class="hljs-number">8</span></span> - (guint)len)*<span class="hljs-number"><span class="hljs-number">8</span></span>; available_bits = G_GUINT64_CONSTANT(<span class="hljs-number"><span class="hljs-number">0xFFFFFFFFFFFFFFFF</span></span>) &gt;&gt; bitshift; .... }</code> </pre> <br>  Pergeseran 64-bit akan menghasilkan perilaku yang tidak terdefinisi sesuai dengan standar bahasa. <br><br>  Sebaliknya, kode yang benar harus seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bitshift == <span class="hljs-number"><span class="hljs-number">64</span></span>) available_bits = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> available_bits = G_GUINT64_CONSTANT(<span class="hljs-number"><span class="hljs-number">0xFFFFFFFFFFFFFFFF</span></span>) &gt;&gt; bitshift;</code> </pre> <br><h2>  Kesimpulan </h2><br>  Kelihatannya ada beberapa contoh kesalahan dalam tinjauan, tetapi dalam laporan lengkap kasus yang disajikan berulang puluhan dan ratusan kali.  Ikhtisar peringatan PVS-Studio hanya untuk tujuan demonstrasi.  Ini merupakan kontribusi terhadap kualitas proyek sumber terbuka, tetapi pemeriksaan satu kali adalah cara yang paling tidak efisien untuk menerapkan metodologi analisis statis. <br><br>  Anda bisa mendapatkan dan menganalisis sendiri laporan lengkapnya.  Untuk melakukan ini, Anda hanya perlu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengunduh</a> dan menjalankan alat analisa PVS-Studio. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Svyatoslav Razmyslov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wireshark 3.x: analisis kode di bawah tinjauan macOS dan kesalahan</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447158/">https://habr.com/ru/post/id447158/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447148/index.html">Aplikasi Habr resmi (un) - HabrApp 2.0: akses</a></li>
<li><a href="../id447150/index.html">Mengobrol di situs dan dalam penerbitan Yandex</a></li>
<li><a href="../id447152/index.html">Cross-platform .NET UI toolkit merilis AvaloniaUI 0.8</a></li>
<li><a href="../id447154/index.html">Utang teknis mengarah ke krisis perusahaan</a></li>
<li><a href="../id447156/index.html">Wireshark 3.x: analisis kode di bawah tinjauan macOS dan kesalahan</a></li>
<li><a href="../id447160/index.html">Ruang untuk anak-anak. Beberapa ide untuk Hari Kosmonautika</a></li>
<li><a href="../id447162/index.html">Jangan membeli ERP</a></li>
<li><a href="../id447164/index.html">Bagaimana cara menggabungkan keunggulan laptop dan komputer desktop? Analisis masalah dan solusi (Bagian 2)</a></li>
<li><a href="../id447166/index.html">Help Desk dalam 3 jam. Mengotomatiskan proses bisnis sederhana di PowerApps, Flow, dan Tim</a></li>
<li><a href="../id447168/index.html">Sistem Akusisi Data Otonomi Lokal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>