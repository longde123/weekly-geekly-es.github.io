<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµüèΩ üëéüèæ ü§® MVCC dalam PostgreSQL-4. Jepretan ‚úãüèº üíÉüèΩ üôáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setelah membahas masalah isolasi dan melakukan penyimpangan mengenai struktur data tingkat rendah , terakhir kali kami menjelajahi versi baris dan men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dalam PostgreSQL-4. Jepretan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/479512/">  Setelah membahas masalah <a href="https://habr.com/ru/company/postgrespro/blog/467437/">isolasi</a> dan melakukan penyimpangan mengenai <a href="https://habr.com/ru/company/postgrespro/blog/469087/">struktur data tingkat rendah</a> , terakhir kali kami menjelajahi <a href="https://habr.com/ru/company/postgrespro/blog/477648/">versi baris</a> dan mengamati bagaimana berbagai operasi mengubah bidang tuple header. <br><br>  Sekarang kita akan melihat bagaimana snapshot data yang konsisten diperoleh dari tuple. <br><br><h1>  Apa itu snapshot data? </h1><br>  Halaman data dapat secara fisik berisi beberapa versi dari baris yang sama.  Tetapi setiap transaksi harus melihat hanya satu (atau tidak ada) versi dari setiap baris, sehingga semuanya membuat gambaran yang konsisten dari data (dalam arti ACID) pada titik waktu tertentu. <br><br>  Isolasi dalam PosgreSQL didasarkan pada snapshots: setiap transaksi bekerja dengan snapshot datanya sendiri, yang "berisi" data yang dilakukan sebelum saat snapshot dibuat dan tidak "berisi" data yang belum dilakukan saat itu.  Kita telah <a href="https://habr.com/ru/company/postgrespro/blog/467437/">melihat</a> bahwa walaupun isolasi yang dihasilkan tampak lebih ketat daripada yang disyaratkan oleh standar, ia masih memiliki anomali. <br><a name="habracut"></a><br>  Pada tingkat isolasi Baca Komitmen, sebuah snapshot dibuat di awal setiap pernyataan transaksi.  Cuplikan ini aktif saat pernyataan sedang dijalankan.  Dalam gambar, saat snapshot dibuat (yang, seperti kita ingat, ditentukan oleh ID transaksi) ditunjukkan dengan warna biru. <br><br><img src="https://habrastorage.org/webt/jy/i7/bt/jyi7btkmmha--gyzq7giozodsze.png"><br><br>  Pada tingkat Repeatable Read dan Serializable, snapshot dibuat sekali, pada awal pernyataan transaksi pertama.  Cuplikan seperti itu tetap aktif hingga akhir transaksi. <br><br><img src="https://habrastorage.org/webt/i5/gq/lt/i5gqltpae5nzbrwjree45wfl8_a.png"><br><br><h1>  Visibilitas tuple dalam snapshot </h1><br><h2>  Aturan visibilitas </h2><br>  Cuplikan tentu bukan salinan fisik dari semua tupel yang diperlukan.  Snapshot sebenarnya ditentukan oleh beberapa angka, dan visibilitas tuple dalam snapshot ditentukan oleh aturan. <br><br>  Apakah tuple akan terlihat atau tidak dalam snapshot tergantung pada dua bidang dalam header, yaitu, <code>xmin</code> dan <code>xmax</code> , yaitu ID transaksi yang membuat dan menghapus tuple.  Interval seperti ini tidak tumpang tindih, dan oleh karena itu, tidak lebih dari satu versi mewakili satu baris di setiap foto. <br><br>  Aturan visibilitas yang tepat cukup rumit dan memperhitungkan banyak kasus dan ekstrem yang berbeda. <br><blockquote>  Anda dapat dengan mudah memastikannya dengan melihat ke src / backend / utils / time / tqual.c (dalam versi 12, centang dipindahkan ke src / backend / akses / heap / heapam_visibility.c). <br></blockquote><br>  Untuk menyederhanakan, kita dapat mengatakan bahwa tuple terlihat ketika dalam snapshot, perubahan yang dibuat oleh transaksi <code>xmin</code> terlihat, sedangkan yang dibuat oleh transaksi <code>xmax</code> tidak (dengan kata lain, sudah jelas bahwa tuple dibuat, tetapi belum jelas apakah itu dihapus). <br><br>  Mengenai transaksi, perubahannya terlihat dalam snapshot baik jika itu adalah transaksi yang menciptakan snapshot (itu memang melihat sendiri belum melakukan perubahan) atau transaksi dilakukan sebelum snapshot dibuat. <br><br>  Kami dapat secara grafis mewakili transaksi berdasarkan segmen (dari waktu mulai hingga waktu komit): <br><br><img src="https://habrastorage.org/webt/or/nv/ir/ornvirvfxjcpp0djg6-1e03vffw.png"><br><br>  Di sini: <br><br><ul><li>  Perubahan transaksi 2 akan terlihat sejak selesai sebelum snapshot dibuat. </li><li>  Perubahan transaksi 1 tidak akan terlihat karena aktif saat snapshot dibuat. </li><li>  Perubahan transaksi 3 tidak akan terlihat sejak dimulai setelah snapshot dibuat (terlepas dari apakah itu selesai atau tidak). </li></ul><br>  Sayangnya, sistem tidak mengetahui waktu transaksi yang dilakukan.  Hanya waktu mulainya yang diketahui (yang ditentukan oleh ID transaksi dan ditandai dengan garis putus-putus pada gambar di atas), tetapi acara penyelesaian tidak ditulis di mana pun. <br><br>  Yang bisa kita lakukan adalah mencari tahu status transaksi saat ini di pembuatan snapshot.  Informasi ini tersedia dalam memori bersama server, dalam struktur ProcArray, yang berisi daftar semua sesi aktif dan transaksi mereka. <br><br>  Tetapi kami tidak dapat menemukan post factum apakah transaksi tertentu aktif pada saat snapshot dibuat.  Oleh karena itu, snapshot harus menyimpan daftar semua transaksi aktif saat ini. <br><br>  Dari penjelasan di atas, maka dalam PostgreSQL, tidak mungkin untuk membuat snapshot yang menunjukkan data konsisten pada waktu tertentu mundur, <em>bahkan jika</em> semua tuple yang diperlukan tersedia di halaman tabel.  Sebuah pertanyaan sering muncul mengapa PostgreSQL tidak memiliki pertanyaan retrospektif (atau temporal; atau flashback, seperti Oracle menyebutnya) - dan ini adalah salah satu alasannya. <br><blockquote>  Agak lucu adalah bahwa fungsi ini pertama kali tersedia, tetapi kemudian dihapus dari DBMS.  Anda dapat membaca tentang ini di <a href="https://arxiv.org/pdf/1901.01973.pdf">artikel oleh Joseph M. Hellerstein</a> . <br></blockquote><br>  Jadi, snapshot ditentukan oleh beberapa parameter: <br><br><ul><li>  Saat snapshot dibuat, lebih tepatnya, ID transaksi berikutnya, namun tidak tersedia di sistem ( <code>snapshot.xmax</code> ). </li><li>  Daftar transaksi aktif (sedang berlangsung) pada saat snapshot dibuat ( <code>snapshot.xip</code> ). </li></ul><br>  Untuk kenyamanan dan optimalisasi, ID dari transaksi aktif paling awal juga disimpan ( <code>snapshot.xmin</code> ).  Nilai ini masuk akal, yang akan dibahas di bawah ini. <br><br>  Cuplikan juga menyimpan beberapa parameter lagi, yang tidak penting bagi kami. <br><br><img src="https://habrastorage.org/webt/5z/dx/cf/5zdxcfxgsqzukzjqgyetvvahzru.png"><br><br><h2>  Contoh </h2><br>  Untuk memahami bagaimana snapshot menentukan visibilitas, mari kita buat contoh di atas dengan tiga transaksi.  Tabel akan memiliki tiga baris, di mana: <br><br><ul><li>  Yang pertama ditambahkan oleh transaksi yang dimulai sebelum pembuatan snapshot tetapi diselesaikan setelah itu. </li><li>  Yang kedua ditambahkan oleh transaksi yang dimulai dan diselesaikan sebelum pembuatan snapshot. </li><li>  Yang ketiga ditambahkan setelah pembuatan snapshot. </li></ul><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts;</code> </pre><br>  Transaksi pertama (belum selesai): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">=&gt; SELECT txid_current(); txid_current -------------- 3695 (1 row)</code> </pre><br>  Transaksi kedua (selesai sebelum snapshot dibuat): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3696 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Membuat snapshot dalam transaksi di sesi lain. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Melakukan transaksi pertama setelah foto dibuat: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Dan transaksi ketiga (muncul setelah foto dibuat): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3697 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Terbukti, hanya satu baris yang masih terlihat di snapshot kami: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Pertanyaannya adalah bagaimana Postgres memahami ini. <br><br>  Semua ditentukan oleh snapshot.  Mari kita melihatnya: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_snapshot();</code> </pre><pre> <code class="plaintext hljs">|| txid_current_snapshot || ----------------------- || 3695:3697:3695 || (1 row)</code> </pre><br>  Di sini <code>snapshot.xmin</code> , <code>snapshot.xmin</code> , dan <code>snapshot.xip</code> dicantumkan, dibatasi oleh titik dua ( <code>snapshot.xip</code> adalah satu nomor dalam kasus ini, tetapi secara umum ini adalah daftar). <br><br>  Menurut aturan di atas, dalam snapshot, perubahan itu harus terlihat yang dilakukan oleh transaksi dengan ID <code>xid</code> sedemikian sehingga <code>snapshot.xmin &lt;= xid &lt; snapshot.xmax</code> kecuali yang ada dalam daftar <code>snapshot.xip</code> .  Mari kita lihat semua baris tabel (dalam snapshot baru): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | number | client | amount ------+------+----+--------+--------+--------- 3695 | 0 | 1 | 1001 | alice | 1000.00 3696 | 0 | 2 | 2001 | bob | 100.00 3697 | 0 | 3 | 2002 | bob | 900.00 (3 rows)</code> </pre><br>  Baris pertama tidak terlihat: itu dibuat oleh transaksi yang ada di daftar transaksi aktif ( <code>xip</code> ). <br>  Baris kedua terlihat: dibuat oleh transaksi yang berada dalam kisaran snapshot. <br>  Baris ketiga tidak terlihat: itu dibuat oleh transaksi yang berada di luar jangkauan snapshot. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Perubahan transaksi sendiri </h1><br>  Menentukan visibilitas perubahan transaksi itu sendiri agak menyulitkan situasi.  Dalam hal ini, mungkin diperlukan untuk melihat hanya sebagian dari perubahan tersebut.  Sebagai contoh: pada tingkat isolasi apa pun, kursor yang dibuka pada titik waktu tertentu tidak boleh melihat perubahan dilakukan nanti. <br><br>  Untuk tujuan ini, tuple header memiliki bidang khusus (diwakili dalam kolom semu <code>cmax</code> dan <code>cmax</code> ), yang menunjukkan nomor pesanan di dalam transaksi.  <code>cmin</code> adalah angka untuk penyisipan, dan <code>cmax</code> - untuk penghapusan, tetapi untuk menghemat ruang dalam tuple header, ini sebenarnya satu bidang daripada dua bidang yang berbeda.  Diasumsikan bahwa suatu transaksi jarang memasukkan dan menghapus baris yang sama. <br><br>  Tetapi jika ini terjadi, id perintah kombo khusus ( <code>combocid</code> ) dimasukkan dalam bidang yang sama, dan proses backend mengingat <code>cmin</code> dan <code>cmin</code> sebenarnya untuk <code>combocid</code> ini.  Tapi ini sepenuhnya eksotis. <br><br>  Ini adalah contoh sederhana.  Mari memulai transaksi dan menambahkan baris ke tabel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3698 (1 row)</code> </pre><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3001</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>);</code> </pre><br>  Mari kita <code>cmin</code> isi tabel, bersama dengan bidang <code>cmin</code> (tetapi hanya untuk baris yang ditambahkan oleh transaksi - untuk yang lain tidak ada artinya): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Sekarang kita membuka kursor untuk kueri yang mengembalikan jumlah baris dalam tabel. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br>  Dan setelah itu kita tambahkan baris lain: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3002</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>);</code> </pre><br>  Kueri mengembalikan 4 - baris yang ditambahkan setelah membuka kursor tidak masuk ke snapshot data: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> count ------- 4 (1 row)</code> </pre><br>  Mengapa  Karena snapshot hanya memperhitungkan tupel dengan <code>cmin &lt; 1</code> . <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 3698 | 1 | 5 | 3002 | charlie | 200.00 (5 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Cakrawala acara </h1><br>  ID transaksi aktif paling awal ( <code>snapshot.xmin</code> ) masuk akal: ia menentukan "horizon peristiwa" dari transaksi tersebut.  Artinya, di luar cakrawala transaksi selalu hanya melihat versi baris terbaru. <br><br>  Sungguh, versi baris yang sudah usang (mati) harus terlihat hanya ketika yang baru dibuat oleh transaksi yang belum selesai dan, oleh karena itu, belum terlihat.  Tetapi semua transaksi "di luar cakrawala" selesai pasti. <br><br><img src="https://habrastorage.org/webt/a6/la/gb/a6lagbu1ycmf-5poirlhd0cpyt8.png"><br><br>  Anda dapat melihat cakrawala transaksi di katalog sistem: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Kami juga dapat mendefinisikan cakrawala di tingkat basis data.  Untuk melakukan ini, kita perlu mengambil semua snapshot aktif dan menemukan <code>xmin</code> tertua di antara mereka.  Dan itu akan menentukan cakrawala, di luar itu tupel mati dalam database tidak akan pernah terlihat oleh transaksi apa pun.  <em>Tupel semacam itu dapat dihilangkan dengan debu</em> - dan inilah mengapa konsep horizon begitu penting dari sudut pandang praktis. <br><br>  Jika suatu transaksi menahan snapshot untuk waktu yang lama, dengan itu ia juga akan memegang cakrawala basis data.  Selain itu, hanya keberadaan transaksi yang belum selesai akan memegang cakrawala bahkan jika transaksi itu sendiri tidak memiliki snapshot. <br><br>  Dan ini berarti bahwa tupel mati di DB tidak dapat disedot.  Selain itu, ada kemungkinan bahwa transaksi "long-play" tidak bersinggungan dengan data dengan transaksi lain sama sekali, tetapi ini tidak terlalu penting karena semuanya berbagi satu cakrawala basis data. <br><br>  Jika sekarang kami membuat segmen yang mewakili snapshots (dari <code>snapshot.xmin</code> ke <code>snapshot.xmax</code> ) daripada transaksi, kami dapat memvisualisasikan situasi sebagai berikut: <br><br><img src="https://habrastorage.org/webt/lf/-k/3a/lf-k3azujmyjrddg-6whmoktujc.png"><br><br>  Dalam gambar ini, snapshot terendah berkaitan dengan transaksi yang tidak selesai, dan pada snapshot lainnya, <code>snapshot.xmin</code> tidak boleh lebih besar dari ID transaksi. <br><br>  Dalam contoh kami, transaksi dimulai dengan tingkat isolasi Baca Komit.  Meskipun tidak memiliki snapshot data aktif, ia tetap memiliki horizon: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">1.00</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Dan hanya setelah penyelesaian transaksi, cakrawala bergerak maju, yang memungkinkan menyedot tupel mati: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3700 (1 row)</code> </pre><br>  Dalam kasus situasi yang dijelaskan benar-benar menyebabkan masalah dan tidak ada cara untuk mengatasinya di tingkat aplikasi, dua parameter tersedia mulai dengan versi 9.6: <br><br><ul><li>  <em><code>old_snapshot_threshold</code></em> menentukan masa pakai maksimum foto.  Saat kali ini berlalu, server akan memenuhi syarat untuk menyedot tupel mati, dan jika transaksi "lama-main" masih membutuhkannya, itu akan mendapatkan kesalahan "snapshot terlalu lama". </li><li>  <em><code>idle_in_transaction_session_timeout</code></em> menentukan masa maksimal transaksi idle.  Ketika waktu ini berlalu, transaksi dibatalkan. </li></ul><br><h1>  Ekspor foto </h1><br>  Kadang-kadang situasi muncul di mana beberapa transaksi bersamaan harus dijamin untuk melihat data yang sama.  Contohnya adalah utilitas <code>pg_dump</code> , yang dapat bekerja dalam mode paralel: semua proses pekerja harus melihat database dalam keadaan yang sama agar salinan cadangan konsisten. <br><br>  Tentu saja, kita tidak dapat mengandalkan kepercayaan bahwa transaksi akan melihat data yang sama hanya karena mereka dimulai "secara bersamaan".  Untuk tujuan ini, ekspor dan impor snapshot tersedia. <br><br>  Fungsi <code>pg_export_snapshot</code> mengembalikan ID snapshot, yang dapat diteruskan ke transaksi lain (menggunakan alat di luar DBMS). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">-- any query</span></span></code> </pre><pre> <code class="plaintext hljs"> count ------- 3 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_export_snapshot();</code> </pre><pre> <code class="plaintext hljs"> pg_export_snapshot --------------------- 00000004-00000E7B-1 (1 row)</code> </pre><br>  Transaksi lainnya dapat mengimpor snapshot menggunakan perintah SET TRANSACTION SNAPSHOT sebelum melakukan kueri pertama.  Baca berulang atau tingkat isolasi Serializable juga harus ditentukan sebelumnya karena pada tingkat Komitmen Baca, pernyataan akan menggunakan snapshot mereka sendiri. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span> <span class="hljs-string"><span class="hljs-string">'00000004-00000E7B-1'</span></span>;</code> </pre><br>  Transaksi kedua sekarang akan bekerja dengan snapshot dari yang pertama dan, karenanya, lihat tiga baris (bukan nol): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><br>  Umur snapshot yang diekspor sama dengan umur transaksi ekspor. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  <a href="https://habr.com/ru/company/postgrespro/blog/483768/">Baca terus</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479512/">https://habr.com/ru/post/id479512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479498/index.html">Bagaimana waktu linear berubah menjadi Windows dalam O (n¬≤)</a></li>
<li><a href="../id479502/index.html">Bagaimana cara bertahan hidup di zaman es paling parah dalam sejarah Bumi?</a></li>
<li><a href="../id479504/index.html">Membangun RDP Thin Client berbasis Raspberry Pi</a></li>
<li><a href="../id479508/index.html">Antipatterns PostgreSQL: GABUNGAN dan OR berbahaya</a></li>
<li><a href="../id479510/index.html">Ulasan PocketBook X - pembaca 10,3 inci yang besar dengan layar E Ink Carta Mobius dan casing logam</a></li>
<li><a href="../id479514/index.html">Privasi berdasarkan desain dan privasi secara default (perlindungan data yang dirancang dan privasi default oleh GDPR)</a></li>
<li><a href="../id479516/index.html">Apa itu entropi dalam perangkat lunak dan bagaimana cara mengelolanya?</a></li>
<li><a href="../id479518/index.html">Komunikasi dalam tim jarak jauh adalah pengalaman kami</a></li>
<li><a href="../id479522/index.html">Penerbit Peter. Penjualan musim dingin</a></li>
<li><a href="../id479524/index.html">Layanan untuk Pemulihan Aktif atau sejarah satu proyek industri di Innopolis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>