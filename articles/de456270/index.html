<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌖 🤺 💪🏻 Redis Stream - Zuverlässigkeit und Skalierbarkeit Ihrer Messaging-Systeme 🧡 🌆 🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Redis Stream - ein neuer abstrakter Datentyp, der mit der Veröffentlichung von Version 5.0 in Redis eingeführt wurde 
 Konzeptionell ist Redis Stream ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redis Stream - Zuverlässigkeit und Skalierbarkeit Ihrer Messaging-Systeme</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456270/"><img src="https://habrastorage.org/webt/4z/my/lg/4zmylgmptsa7q0dqxbekaq4gvai.png" alt="Bild"><br><br>  Redis Stream - ein neuer abstrakter Datentyp, der mit der Veröffentlichung von Version 5.0 in Redis eingeführt wurde <br>  Konzeptionell ist Redis Stream eine Liste, zu der Sie Einträge hinzufügen können.  Jeder Eintrag hat eine eindeutige Kennung.  Standardmäßig wird automatisch eine Kennung generiert, die einen Zeitstempel enthält.  Daher können Sie Aufzeichnungsbereiche nach Zeit anfordern oder neue Daten empfangen, sobald diese im Stream ankommen, da der Unix-Befehl tail -f die Protokolldatei liest und in Erwartung neuer Daten einfriert.  Bitte beachten Sie, dass mehrere Clients gleichzeitig den Stream abhören können, da viele "tail-f" -Prozesse gleichzeitig eine Datei lesen können, ohne dass Konflikte auftreten. <br><br>  Um alle Vorteile des neuen Datentyps zu verstehen, erinnern wir uns kurz an die seit langem vorhandenen Redis-Strukturen, die die Funktionalität von Redis Stream teilweise wiederholen. <br><a name="habracut"></a><br><h1>  Historischer Ausflug </h1><br><h4>  Redis Pub / Sub </h4><br>  Redis Pub / Sub ist ein einfaches Messaging-System, das bereits in Ihren Schlüsselwertspeicher integriert ist.  Der Einfachheit halber müssen Sie jedoch bezahlen: <br><br><ul><li>  Wenn der Verlag aus irgendeinem Grund versagt, verliert er alle seine Abonnenten </li><li>  Der Verlag muss die genaue Adresse aller seiner Abonnenten kennen. </li><li>  Ein Herausgeber kann seine Abonnenten überlasten, wenn die Daten schneller veröffentlicht als verarbeitet werden </li><li>  Die Nachricht wird unmittelbar nach der Veröffentlichung aus dem Puffer des Herausgebers gelöscht, unabhängig davon, wie viele Abonnenten sie zugestellt hat und wie schnell sie diese Nachricht verarbeitet haben. </li><li>  Alle Abonnenten erhalten die Nachricht gleichzeitig.  Die Abonnenten selbst müssen sich irgendwie darauf einigen, wie dieselbe Nachricht verarbeitet werden soll. </li><li>  Es gibt keinen eingebauten Mechanismus zum Bestätigen der erfolgreichen Verarbeitung einer Nachricht durch einen Teilnehmer.  Wenn der Abonnent eine Nachricht erhalten hat und während der Verarbeitung abgefallen ist, weiß der Herausgeber nichts davon. </li></ul><br><h4>  Redis Liste </h4><br>  Redis List ist eine Datenstruktur, die Lesebefehle für Sperren unterstützt.  Sie können Nachrichten am Anfang oder Ende der Liste hinzufügen und lesen.  Auf der Grundlage dieser Struktur können Sie einen guten Stapel oder eine gute Warteschlange für Ihr verteiltes System erstellen, was in den meisten Fällen ausreicht.  Die Hauptunterschiede zu Redis Pub / Sub: <br><br><ul><li>  Die Nachricht wird an einen Client übermittelt.  Der erste durch Lesen blockierte Client erhält zuerst die Daten. </li><li>  Clint muss für jede Nachricht einen Lesevorgang einleiten.  List weiß nichts über Kunden. </li><li>  Nachrichten werden gespeichert, bis jemand sie zählt oder explizit löscht.  Wenn Sie einen Redis-Server einrichten, um Daten auf die Festplatte zu übertragen, erhöht sich die Zuverlässigkeit des Systems erheblich. </li></ul><br><h1>  Einführung in Stream </h1><br><h4>  Hinzufügen eines Datensatzes zu einem Stream </h4><br>  Der <b>XADD-</b> Befehl fügt dem Stream einen neuen Datensatz hinzu.  Ein Datensatz ist nicht nur eine Zeichenfolge, sondern besteht aus einem oder mehreren Schlüssel-Wert-Paaren.  Somit ist jeder Datensatz bereits strukturiert und ähnelt der Struktur einer CSV-Datei. <br><br><pre><code class="go hljs">&gt; XADD mystream * sensor-id <span class="hljs-number"><span class="hljs-number">1234</span></span> temperature <span class="hljs-number"><span class="hljs-number">19.8</span></span> <span class="hljs-number"><span class="hljs-number">1518951480106</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span></code> </pre> <br>  Im obigen Beispiel fügen wir dem Stream zwei Felder mit dem Namen (Schlüssel) "mystream" hinzu: "Sensor-ID" und "Temperatur" mit den Werten "1234" bzw. "19.8".  Als zweites Argument akzeptiert der Befehl die Kennung, die dem Datensatz zugewiesen wird. Diese Kennung identifiziert jeden Datensatz im Stream eindeutig.  In diesem Fall haben wir jedoch * bestanden, weil Redis eine neue Kennung für uns generieren soll.  Jede neue Kennung wird erhöht.  Daher hat jeder neue Datensatz eine größere Kennung im Vergleich zu vorherigen Datensätzen. <br><br><h4>  ID-Format </h4><br>  Die vom <b>XADD-</b> Befehl zurückgegebene <b>Datensatzkennung</b> besteht aus zwei Teilen: <br><br> <code>{millisecondsTime}-{sequenceNumber} <br></code> <br>  <i>millisecondsTime</i> - Unix-Zeit in Millisekunden (Redis-Serverzeit).  Wenn jedoch die aktuelle Zeit gleich oder kleiner als die Zeit des vorherigen Datensatzes ist, wird der Zeitstempel des vorherigen Datensatzes verwendet.  Wenn die Serverzeit auf die Vergangenheit zurückgesetzt wird, behält der neue Bezeichner daher weiterhin die Eigenschaft zum Erhöhen bei. <br><br>  <i>sequenceNumber wird</i> für Datensätze verwendet, die in derselben Millisekunde erstellt wurden.  <i>sequenceNumber</i> wird gegenüber dem vorherigen Datensatz um 1 erhöht.  Da <i>sequenceNumber</i> 64 Bit groß ist, sollten Sie in der Praxis nicht auf eine Begrenzung der Anzahl von Datensätzen stoßen, die innerhalb einer Millisekunde generiert werden können. <br><br>  Das Format solcher Kennungen mag auf den ersten Blick seltsam erscheinen.  Ein ungläubiger Leser mag sich fragen, warum Zeit Teil einer Kennung ist.  Der Grund dafür ist, dass Redis-Streams Bereichsanforderungen nach Bezeichnern unterstützen.  Da die Kennung der Zeit zugeordnet ist, zu der der Datensatz erstellt wurde, können Zeitbereiche angefordert werden.  Wir werden uns ein konkretes Beispiel ansehen, wenn wir mit dem Studium des <b>XRANGE-Befehls fortfahren</b> . <br><br>  Wenn der Benutzer aus irgendeinem Grund seine eigene Kennung angeben muss, die beispielsweise einem externen System zugeordnet ist, können wir diese anstelle des * -Zeichens wie unten gezeigt an den <b>XADD-Befehl übergeben</b> : <br><br><pre> <code class="go hljs">&gt; XADD somestream <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span> field value <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span> &gt; XADD somestream <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span> foo bar <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span></code> </pre><br>  Bitte beachten Sie, dass Sie in diesem Fall die Zunahme der Kennung selbst überwachen müssen.  In unserem Beispiel ist die minimale Kennung "0-1", sodass das Team keine andere Kennung akzeptiert, die gleich oder kleiner als "0-1" ist. <br><br><pre> <code class="go hljs">&gt; XADD somestream <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span> foo bar (error) ERR The ID specified in XADD is equal or smaller than the target stream top item</code> </pre><br><h4>  Die Anzahl der Datensätze im Stream </h4><br>  Sie können die Anzahl der Datensätze in einem Stream einfach mit dem Befehl <b>XLEN abrufen</b> .  In unserem Beispiel gibt dieser Befehl den folgenden Wert zurück: <br><br><pre> <code class="go hljs">&gt; XLEN somestream (integer) <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><h4>  Bereichsanforderungen - XRANGE und XREVRANGE </h4><br>  Um Daten für einen Bereich anzufordern, müssen zwei Bezeichner angegeben werden - der Anfang und das Ende des Bereichs.  Der zurückgegebene Bereich enthält alle Elemente, einschließlich Rahmen.  Es gibt auch zwei spezielle Bezeichner "-" und "+", die den kleinsten (erster Datensatz) und den größten (letzter Datensatz) Bezeichner im Stream bedeuten.  Im folgenden Beispiel werden alle Stream-Einträge angezeigt. <br><br><pre> <code class="go hljs">&gt; XRANGE mystream - + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1518951480106</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"sensor-id"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"1234"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-string"><span class="hljs-string">"temperature"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-string"><span class="hljs-string">"19.8"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1518951482479</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"sensor-id"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"9999"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-string"><span class="hljs-string">"temperature"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-string"><span class="hljs-string">"18.2"</span></span></code> </pre><br>  Jeder zurückgegebene Datensatz besteht aus zwei Elementen: einem Bezeichner und einer Liste von Schlüssel-Wert-Paaren.  Wir haben bereits gesagt, dass Datensatzkennungen zeitbezogen sind.  Daher können wir den Bereich eines bestimmten Zeitraums anfordern.  In der Anforderung können wir jedoch nicht die vollständige Kennung, sondern nur die Unix-Zeit angeben, wobei der Teil, der sich auf <i>sequenceNumber</i> bezieht, weggelassen <i>wird</i> .  Der ausgelassene Teil des Bezeichners ist am Anfang des Bereichs automatisch gleich Null und am Ende des Bereichs gleich dem maximal möglichen Wert.  Das folgende Beispiel zeigt, wie ein Bereich von zwei Millisekunden angefordert wird. <br><br><pre> <code class="go hljs">&gt; XRANGE mystream <span class="hljs-number"><span class="hljs-number">1518951480106</span></span> <span class="hljs-number"><span class="hljs-number">1518951480107</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1518951480106</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"sensor-id"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"1234"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-string"><span class="hljs-string">"temperature"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-string"><span class="hljs-string">"19.8"</span></span></code> </pre><br>  Wir haben nur einen Datensatz in diesem Bereich, aber in realen Datensätzen kann das zurückgegebene Ergebnis sehr groß sein.  Aus diesem Grund unterstützt <b>XRANGE</b> die Option COUNT.  Durch Angabe der Menge können wir einfach die ersten N Datensätze erhalten.  Wenn wir die nächsten N Einträge erhalten müssen (Paginierung), können wir den zuletzt empfangenen Bezeichner verwenden, seine <i>Sequenznummer</i> um eins erhöhen und erneut anfordern.  Schauen wir uns das im folgenden Beispiel an.  Wir <b>fangen</b> an, 10 Elemente mit <b>XADD hinzuzufügen</b> (angenommen, der Mystream-Stream wurde bereits mit 10 Elementen gefüllt).  Um die Iteration zu starten und 2 Elemente pro Befehl zu erhalten, beginnen wir mit dem gesamten Bereich, jedoch mit COUNT gleich 2. <br><br><pre> <code class="go hljs">&gt; XRANGE mystream - + COUNT <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1519073278252</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"value_1"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1519073279157</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"value_2"</span></span></code> </pre><br>  Um die Iteration mit den folgenden zwei Elementen fortzusetzen, müssen wir den zuletzt empfangenen Bezeichner auswählen, nämlich 1519073279157-0, und der <i>Sequenznummer</i> 1 hinzufügen. <br>  Der resultierende Bezeichner, in diesem Fall 1519073279157-1, kann jetzt als neues Argument am Anfang des Bereichs für den nächsten <b>XRANGE-</b> Aufruf verwendet werden: <br><br><pre> <code class="go hljs">&gt; XRANGE mystream <span class="hljs-number"><span class="hljs-number">1519073279157</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span> + COUNT <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1519073280281</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"value_3"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1519073281432</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"value_4"</span></span></code> </pre><br>  Usw.  Da die Komplexität von <b>XRANGE</b> O (log (N)) für die Suche und dann O (M) für die Rückgabe von M Elementen ist, ist jeder Schritt der Iteration schnell.  Mit <b>XRANGE ist</b> es daher möglich, Flüsse effizient zu <b>iterieren</b> . <br><br>  Der Befehl <b>XREVRANGE</b> entspricht <b>XRANGE</b> , gibt jedoch die Elemente in umgekehrter Reihenfolge zurück: <br><br><pre> <code class="go hljs">&gt; XREVRANGE mystream + - COUNT <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1519073287312</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"value_10"</span></span></code> </pre><br>  Beachten Sie, dass der Befehl <b>XREVRANGE</b> die Argumente des Start- und <b>Stoppbereichs</b> in umgekehrter Reihenfolge verwendet. <br><br><h4>  Lesen neuer Datensätze mit XREAD </h4><br>  Oft gibt es eine Aufgabe, den Stream zu abonnieren und nur neue Nachrichten zu empfangen.  Dieses Konzept mag wie ein Redis Pub / Sub erscheinen oder Redis List blockieren, aber es gibt grundlegende Unterschiede bei der Verwendung von Redis Stream: <br><br><ol><li>  Jede neue Nachricht wird standardmäßig an jeden Teilnehmer übermittelt.  Dieses Verhalten unterscheidet sich vom Blockieren der Redis-Liste, bei der eine neue Nachricht nur von einem Teilnehmer gelesen wird. </li><li>  Während in Redis Pub / Sub alle Nachrichten vergessen und nie gespeichert werden, werden in Stream alle Nachrichten auf unbestimmte Zeit gespeichert (es sei denn, der Client fordert ausdrücklich zum Löschen auf). </li><li>  Mit Redis Stream können Sie den Zugriff auf Nachrichten innerhalb eines Streams unterscheiden.  Ein bestimmter Abonnent kann nur seinen persönlichen Nachrichtenverlauf sehen. </li></ol><br>  Mit dem Befehl <b>XREAD</b> können Sie den Stream abonnieren und neue Nachrichten <b>empfangen</b> .  Dies ist etwas komplizierter als <b>XRANGE</b> , daher beginnen wir zunächst mit einfacheren Beispielen. <br><br><pre> <code class="go hljs">&gt; XREAD COUNT <span class="hljs-number"><span class="hljs-number">2</span></span> STREAMS mystream <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"mystream"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1519073278252</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"value_1"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1519073279157</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"value_2"</span></span></code> </pre><br>  Im obigen Beispiel wird ein nicht blockierendes <b>XREAD-</b> Formular <b>angegeben</b> .  Bitte beachten Sie, dass die Option COUNT optional ist.  Tatsächlich ist die einzige erforderliche Befehlsoption die Option STREAMS, mit der die Liste der Streams zusammen mit der entsprechenden maximalen Kennung festgelegt wird.  Wir haben "STREAMS mystream 0" geschrieben - wir möchten alle Datensätze des mystream-Streams mit einer Kennung größer als "0-0" abrufen.  Wie Sie dem Beispiel entnehmen können, gibt der Befehl den Namen des Streams zurück, da mehrere Threads gleichzeitig abonniert werden können.  Wir könnten zum Beispiel "STREAMS mystream otherstream 0 0" schreiben.  Bitte beachten Sie, dass wir nach der Option STREAMS zuerst die Namen aller erforderlichen Streams und erst dann eine Liste der Bezeichner angeben müssen. <br><br>  In dieser einfachen Form macht der Befehl im Vergleich zu <b>XRANGE</b> nichts Besonderes.  Das Interessante ist jedoch, dass wir <b>XREAD</b> leicht in einen Blockierungsbefehl verwandeln können, indem wir das BLOCK-Argument <b>angeben</b> : <br><br> <code>&gt; XREAD BLOCK 0 STREAMS mystream $ <br></code> <br>  Im obigen Beispiel wird eine neue BLOCK-Option mit einer Zeitüberschreitung von 0 Millisekunden angegeben (dies bedeutet endloses Warten).  Darüber hinaus wurde anstelle der üblichen Kennung für den Mystream-Stream die spezielle Kennung $ übergeben.  Diese spezielle Kennung bedeutet, dass <b>XREAD</b> die maximale Kennung im Mystream-Stream als Kennung verwenden sollte.  Wir erhalten also erst ab dem Moment, in dem wir zuhören, neue Nachrichten.  In gewisser Weise ähnelt dies dem Unix-Befehl tail -f. <br><br>  Bitte beachten Sie, dass wir bei Verwendung der Option BLOCK nicht die spezielle Kennung $ verwenden müssen.  Wir können jeden im Stream vorhandenen Bezeichner verwenden.  Wenn das Team unsere Anfrage sofort bearbeiten kann, ohne sie zu blockieren, wird es dies tun, andernfalls wird sie blockiert. <br><br>  Durch das Blockieren von <b>XREAD</b> können auch mehrere Streams gleichzeitig <b>abgehört werden.</b> Sie müssen lediglich deren Namen angeben.  In diesem Fall gibt der Befehl einen Datensatz des ersten Streams zurück, in den die Daten eingegangen sind.  Der erste für diesen Stream blockierte Teilnehmer empfängt zuerst die Daten. <br><br><h3>  Verbrauchergruppen </h3><br>  Bei bestimmten Aufgaben möchten wir den Zugriff von Abonnenten auf Nachrichten innerhalb desselben Threads unterscheiden.  Ein Beispiel, bei dem dies nützlich sein kann, ist eine Nachrichtenwarteschlange mit Mitarbeitern, die unterschiedliche Nachrichten vom Stream empfangen, sodass Sie die Nachrichtenverarbeitung skalieren können. <br><br>  Wenn wir uns vorstellen, dass wir drei Teilnehmer C1, C2, C3 und einen Stream haben, der die Nachrichten 1, 2, 3, 4, 5, 6, 7 enthält, erfolgt der Nachrichtendienst wie in der folgenden Abbildung: <br><br> <code>1 -&gt; C1 <br> 2 -&gt; C2 <br> 3 -&gt; C3 <br> 4 -&gt; C1 <br> 5 -&gt; C2 <br> 6 -&gt; C3 <br> 7 -&gt; C1 <br></code> <br>  Um diesen Effekt zu erzielen, verwendet Redis Stream ein Konzept namens Consumer Group.  Dieses Konzept ähnelt einem Pseudo-Teilnehmer, der Daten von einem Stream empfängt, jedoch tatsächlich von mehreren Teilnehmern innerhalb einer Gruppe bedient wird und bestimmte Garantien bietet: <br><br><ol><li>  Jede Nachricht wird an verschiedene Teilnehmer innerhalb der Gruppe gesendet. </li><li>  Innerhalb einer Gruppe werden Abonnenten anhand des Namens identifiziert, bei dem zwischen Groß- und Kleinschreibung unterschieden wird.  Wenn ein Abonnent vorübergehend aus der Gruppe ausscheidet, kann er unter seinem eigenen eindeutigen Namen in der Gruppe wiederhergestellt werden. </li><li>  Jede Verbrauchergruppe folgt dem Konzept der "ersten ungelesenen Nachricht".  Wenn ein Abonnent neue Nachrichten anfordert, kann er nur Nachrichten empfangen, die noch nie an einen Abonnenten innerhalb einer Gruppe gesendet wurden. </li><li>  Es gibt einen Befehl, um die erfolgreiche Verarbeitung der Nachricht durch den Teilnehmer explizit zu bestätigen.  Bis dieser Befehl aufgerufen wird, bleibt die angeforderte Nachricht im Status "Ausstehend". </li><li>  Innerhalb der Verbrauchergruppe kann jeder Abonnent einen Verlauf von Nachrichten anfordern, die ihm zugestellt, aber noch nicht verarbeitet wurden (im Status "Ausstehend"). </li></ol><br>  In gewissem Sinne kann der Zustand einer Gruppe wie folgt dargestellt werden: <br><br><pre> <code class="go hljs">+----------------------------------------+ | consumer_group_name: mygroup | consumer_group_stream: somekey | last_delivered_id: <span class="hljs-number"><span class="hljs-number">1292309234234</span></span><span class="hljs-number"><span class="hljs-number">-92</span></span> | | consumers: | <span class="hljs-string"><span class="hljs-string">"consumer-1"</span></span> with pending messages | <span class="hljs-number"><span class="hljs-number">1292309234234</span></span><span class="hljs-number"><span class="hljs-number">-4</span></span> | <span class="hljs-number"><span class="hljs-number">1292309234232</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> | <span class="hljs-string"><span class="hljs-string">"consumer-42"</span></span> with pending messages | ... (and so forth) +----------------------------------------+</code> </pre><br>  Jetzt ist es Zeit, sich mit den Hauptteams der Verbrauchergruppe vertraut zu machen, nämlich: <br><br><ul><li>  <b>XGROUP wird</b> zum Erstellen, Zerstören und Verwalten von Gruppen verwendet. </li><li>  <b>XREADGROUP wird</b> verwendet, um einen Stream durch eine Gruppe zu lesen. </li><li>  <b>XACK</b> - Mit diesem Befehl kann der Teilnehmer die Nachricht als erfolgreich verarbeitet markieren </li></ul><br><h4>  Schaffung einer Verbrauchergruppe </h4><br>  Angenommen, ein Mystream-Stream ist bereits vorhanden.  Dann sieht der Befehl zur Gruppenerstellung folgendermaßen aus: <br><br> <code>&gt; XGROUP CREATE mystream mygroup $ <br> OK <br></code> <br>  Beim Erstellen einer Gruppe müssen wir eine Kennung übergeben, ab der die Gruppe Nachrichten empfängt.  Wenn wir nur alle neuen Nachrichten empfangen möchten, können wir den speziellen Bezeichner $ verwenden (wie in unserem obigen Beispiel).  Wenn Sie anstelle einer speziellen Kennung 0 angeben, stehen der Gruppe alle Nachrichten des Streams zur Verfügung. <br><br>  <b>Nachdem</b> die Gruppe erstellt wurde, können wir sofort mit dem Lesen des <b>Befehls XREADGROUP</b> Nachrichten <b>lesen</b> .  Dieser Befehl ist <b>XREAD</b> sehr ähnlich und unterstützt die optionale Option BLOCK.  Es gibt jedoch eine obligatorische GROUP-Option, die immer mit zwei Argumenten angegeben werden muss: dem Namen der Gruppe und dem Namen des Abonnenten.  Die COUNT-Option wird ebenfalls unterstützt. <br><br>  Bevor wir den Stream lesen, lassen Sie uns dort einige Nachrichten einfügen: <br><br><pre> <code class="go hljs">&gt; XADD mystream * message apple <span class="hljs-number"><span class="hljs-number">1526569495631</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> &gt; XADD mystream * message orange <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> &gt; XADD mystream * message strawberry <span class="hljs-number"><span class="hljs-number">1526569506935</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> &gt; XADD mystream * message apricot <span class="hljs-number"><span class="hljs-number">1526569535168</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> &gt; XADD mystream * message banana <span class="hljs-number"><span class="hljs-number">1526569544280</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span></code> </pre><br>  Versuchen wir nun, diesen Stream durch die Gruppe zu lesen: <br><br><pre> <code class="go hljs">&gt; XREADGROUP GROUP mygroup Alice COUNT <span class="hljs-number"><span class="hljs-number">1</span></span> STREAMS mystream &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"mystream"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569495631</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"message"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"apple"</span></span></code> </pre><br>  Der obige Befehl lautet wörtlich wie folgt: <br><br>  "Ich, Alices Abonnent, ein Mitglied von mygroup, möchte eine Nachricht aus dem mystream lesen, die noch nie zuvor an jemanden gesendet wurde." <br><br>  Jedes Mal, wenn ein Teilnehmer eine Operation mit einer Gruppe ausführt, muss er seinen Namen angeben und sich innerhalb der Gruppe eindeutig identifizieren.  Der obige Befehl enthält ein weiteres sehr wichtiges Detail - die spezielle Kennung "&gt;".  Diese spezielle Kennung filtert Nachrichten und hinterlässt nur diejenigen, die bisher noch nie zugestellt wurden. <br><br>  In besonderen Fällen können Sie auch eine echte Kennung angeben, z. B. 0 oder eine andere gültige Kennung.  In diesem Fall gibt der Befehl <b>XREADGROUP</b> den Verlauf von Nachrichten mit dem Status "Ausstehend" an Sie zurück, die an den angegebenen Teilnehmer (Alice) <b>gesendet wurden</b> , aber noch nicht mit dem <b>Befehl XACK</b> bestätigt wurden. <br><br>  Wir können dieses Verhalten überprüfen, indem wir sofort die Kennung 0 ohne die Option <b>COUNT</b> angeben.  Wir sehen nur die einzige ausstehende Nachricht, d. H. Die Nachricht mit dem Apfel: <br><br><pre> <code class="go hljs">&gt; XREADGROUP GROUP mygroup Alice STREAMS mystream <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"mystream"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569495631</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"message"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"apple"</span></span></code> </pre><br>  Wenn wir jedoch bestätigen, dass die Nachricht erfolgreich verarbeitet wurde, wird sie nicht mehr angezeigt: <br><br><pre> <code class="go hljs">&gt; XACK mystream mygroup <span class="hljs-number"><span class="hljs-number">1526569495631</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> (integer) <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; XREADGROUP GROUP mygroup Alice STREAMS mystream <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"mystream"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) (empty list or set)</code> </pre><br>  Jetzt ist Bob an der Reihe, etwas zu lesen: <br><br><pre> <code class="go hljs">&gt; XREADGROUP GROUP mygroup Bob COUNT <span class="hljs-number"><span class="hljs-number">2</span></span> STREAMS mystream &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"mystream"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"message"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"orange"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569506935</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"message"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"strawberry"</span></span></code> </pre><br>  Bob, ein Mitglied von mygroup, bat um nicht mehr als zwei Nachrichten.  Der Befehl meldet nur nicht zugestellte Nachrichten aufgrund der speziellen Kennung "&gt;".  Wie Sie sehen können, wird die Meldung "Apfel" nicht angezeigt, da sie bereits an Alice übermittelt wurde, sodass Bob "Orange" und "Erdbeere" erhält. <br><br>  Somit können Alice, Bob und jeder andere Gruppenabonnent verschiedene Nachrichten aus demselben Stream lesen.  Sie können auch ihren Rohnachrichtenverlauf lesen oder Nachrichten als verarbeitet markieren. <br><br>  Es gibt einige Dinge zu beachten: <br><br><ul><li>  Sobald der Teilnehmer die Nachricht als <b>XREADGROUP-</b> Befehl betrachtet, wechselt diese Nachricht in den Status "Ausstehend" und wird diesem bestimmten Teilnehmer zugewiesen.  Andere Gruppenabonnenten können diese Nachricht nicht lesen. </li><li>  Abonnenten werden bei der ersten Erwähnung automatisch erstellt, ihre explizite Erstellung ist nicht erforderlich. </li><li>  Mit <b>XREADGROUP</b> können Sie Nachrichten aus mehreren verschiedenen Streams gleichzeitig lesen. Damit dies jedoch funktioniert, müssen Sie zunächst mit <b>XGROUP</b> für jeden Stream Gruppen mit demselben Namen <b>erstellen</b> </li></ul><br><h4>  Crash Recovery </h4><br>  Der Teilnehmer kann den Fehler beheben und seine Nachrichtenliste mit dem Status "Ausstehend" erneut lesen.  In der realen Welt können Abonnenten jedoch letztendlich scheitern.  Was passiert mit der baumelnden Nachricht eines Abonnenten, wenn er sich nach einem Fehler nicht erholen kann? <br>  Die Verbrauchergruppe bietet eine Funktion, die speziell für solche Fälle verwendet wird - wenn Sie den Eigentümer von Nachrichten ändern müssen. <br><br>  Zunächst müssen Sie den Befehl <b>XPENDING aufrufen</b> , der alle Nachrichten der Gruppe mit dem Status "Ausstehend" anzeigt.  In seiner einfachsten Form wird ein Befehl mit nur zwei Argumenten aufgerufen: dem Namen des Streams und dem Namen der Gruppe: <br><br><pre> <code class="go hljs">&gt; XPENDING mystream mygroup <span class="hljs-number"><span class="hljs-number">1</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">1526569506935</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"Bob"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"2"</span></span></code> </pre><br>  Das Team druckte die Anzahl der unverarbeiteten Nachrichten für die gesamte Gruppe und für jeden Teilnehmer.  Wir haben nur Bob mit zwei unverarbeiteten Nachrichten, da die einzige von Alice angeforderte Nachricht mit <b>XACK</b> bestätigt wurde. <br><br>  Wir können zusätzliche Informationen mit mehr Argumenten anfordern: <br><br> <code>XPENDING {key} {groupname} [{start-id} {end-id} {count} [{consumer-name}]] <br></code> <br>  {Start-ID} {End-ID} - Bereich von Bezeichnern (Sie können "-" und "+" verwenden) <br>  {count} - Die Anzahl der Zustellversuche <br>  {Verbrauchername} - Gruppenname <br><br><pre> <code class="go hljs">&gt; XPENDING mystream mygroup - + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"Bob"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">74170458</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569506935</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"Bob"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">74170458</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Jetzt haben wir die Details für jede Nachricht: Kennung, Teilnehmername, Ausfallzeit in Millisekunden und schließlich die Anzahl der Zustellversuche.  Wir haben zwei Nachrichten von Bob, die 74170458 Millisekunden lang ungefähr 20 Stunden lang inaktiv sind. <br><br>  Bitte beachten Sie, dass uns niemand daran <b>hindert,</b> den Inhalt der Nachricht nur mithilfe von <b>XRANGE zu überprüfen</b> . <br><br><pre> <code class="go hljs">&gt; XRANGE mystream <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"message"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"orange"</span></span></code> </pre><br>  Wir müssen denselben Bezeichner nur zweimal in den Argumenten wiederholen.  Nachdem wir eine Idee haben, kann Alice entscheiden, dass Bob sich nach 20 Stunden Inaktivität wahrscheinlich nicht erholen wird. Es ist Zeit, diese Nachrichten anzufordern und die Verarbeitung anstelle von Bob fortzusetzen.  Dazu verwenden wir den Befehl <b>XCLAIM</b> : <br><br> <code>XCLAIM {key} {group} {consumer} {min-idle-time} {ID-1} {ID-2} ... {ID-N} <br></code> <br>  Mit diesem Befehl können wir eine "fremde" Nachricht erhalten, die noch nicht verarbeitet wurde, indem wir den Eigentümer in {consumer} ändern.  Wir können jedoch auch eine minimale Ausfallzeit (minimale Leerlaufzeit) angeben.  Dies hilft zu vermeiden, dass zwei Clients gleichzeitig versuchen, den Eigentümer derselben Nachrichten zu ändern: <br><br> <code>Client 1: XCLAIM mystream mygroup Alice 3600000 1526569498055-0 <br> Clinet 2: XCLAIM mystream mygroup Lora 3600000 1526569498055-0 <br></code> <br>  Der erste Kunde setzt Ausfallzeiten zurück und erhöht den Zähler für die Anzahl der Lieferungen.  Der zweite Client kann es also nicht anfordern. <br><br><pre> <code class="go hljs">&gt; XCLAIM mystream mygroup Alice <span class="hljs-number"><span class="hljs-number">3600000</span></span> <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"message"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"orange"</span></span></code> </pre><br>  Die Nachricht wurde erfolgreich von Alice beansprucht, die die Nachricht nun verarbeiten und bestätigen kann. <br><br>  Aus dem obigen Beispiel geht hervor, dass die erfolgreiche Ausführung der Anforderung den Inhalt der Nachricht selbst zurückgibt.  Dies ist jedoch nicht erforderlich.  Mit der Option JUSTID können nur Nachrichtenkennungen zurückgegeben werden.  Dies ist nützlich, wenn Sie nicht an den Details der Nachricht interessiert sind und die Systemleistung steigern möchten. <br><br><h3>  Lieferschalter </h3><br>  Der Zähler, den Sie in der <b>XPENDING-</b> Ausgabe beobachten, ist die Anzahl der Zustellungen jeder Nachricht.  Ein solcher Zähler wird auf zwei Arten inkrementiert: wenn die Nachricht erfolgreich über <b>XCLAIM</b> angefordert wurde oder wenn der <b>XREADGROUP-</b> Aufruf <b>verwendet wird</b> . <br><br>  Es ist normal, dass einige Nachrichten mehrmals zugestellt werden.  Die Hauptsache ist, dass dadurch alle Nachrichten verarbeitet werden.  Manchmal treten bei der Verarbeitung einer Nachricht Probleme auf, die auf eine Beschädigung der Nachricht selbst zurückzuführen sind, oder die Verarbeitung der Nachricht führt zu einem Fehler im Handlercode.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall kann sich herausstellen, dass niemand diese Nachricht verarbeiten kann. </font><font style="vertical-align: inherit;">Da wir einen Zähler für Zustellversuche haben, können wir diesen Zähler verwenden, um solche Situationen zu erkennen. </font><font style="vertical-align: inherit;">Sobald der Zustellungszähler eine von Ihnen angegebene große Anzahl erreicht, ist es wahrscheinlich sinnvoller, eine solche Nachricht in einem anderen Stream zu platzieren und eine Benachrichtigung an den Systemadministrator zu senden.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thread-Status </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Befehl </font><b><font style="vertical-align: inherit;">XINFO werden</font></b><font style="vertical-align: inherit;"> verschiedene Informationen zu einem Stream und seinen Gruppen </font><b><font style="vertical-align: inherit;">angefordert</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die Grundform des Befehls lautet beispielsweise wie folgt:</font></font><br><br><pre> <code class="go hljs">&gt; XINFO STREAM mystream <span class="hljs-number"><span class="hljs-number">1</span></span>) length <span class="hljs-number"><span class="hljs-number">2</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) radix-tree-keys <span class="hljs-number"><span class="hljs-number">4</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>) radix-tree-nodes <span class="hljs-number"><span class="hljs-number">6</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>) groups <span class="hljs-number"><span class="hljs-number">8</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>) first-entry <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1524494395530</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"a"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-string"><span class="hljs-string">"b"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-string"><span class="hljs-string">"2"</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>) last-entry <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569544280</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"message"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"banana"</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der obige Befehl zeigt allgemeine Informationen zum angegebenen Stream an. </font><font style="vertical-align: inherit;">Nun ein etwas komplexeres Beispiel:</font></font><br><br><pre> <code class="go hljs">&gt; XINFO GROUPS mystream <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) name <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"mygroup"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) consumers <span class="hljs-number"><span class="hljs-number">4</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>) pending <span class="hljs-number"><span class="hljs-number">6</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) name <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"some-other-group"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) consumers <span class="hljs-number"><span class="hljs-number">4</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>) pending <span class="hljs-number"><span class="hljs-number">6</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der obige Befehl zeigt allgemeine Informationen für alle Gruppen des angegebenen Streams an </font></font><br><br><pre> <code class="go hljs">&gt; XINFO CONSUMERS mystream mygroup <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) name <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"Alice"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) pending <span class="hljs-number"><span class="hljs-number">4</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>) idle <span class="hljs-number"><span class="hljs-number">6</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">9104628</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) name <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"Bob"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) pending <span class="hljs-number"><span class="hljs-number">4</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>) idle <span class="hljs-number"><span class="hljs-number">6</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">83841983</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der obige Befehl zeigt Informationen zu allen Abonnenten des angegebenen Streams und der angegebenen Gruppe an. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie die Befehlssyntax vergessen haben, wenden Sie sich an den Befehl, um Hilfe zu erhalten:</font></font><br><br><pre> <code class="go hljs">&gt; XINFO HELP <span class="hljs-number"><span class="hljs-number">1</span></span>) XINFO {subcommand} arg arg ... arg. Subcommands are: <span class="hljs-number"><span class="hljs-number">2</span></span>) CONSUMERS {key} {groupname} -- Show consumer groups of group {groupname}. <span class="hljs-number"><span class="hljs-number">3</span></span>) GROUPS {key} -- Show the stream consumer groups. <span class="hljs-number"><span class="hljs-number">4</span></span>) STREAM {key} -- Show information about the stream. <span class="hljs-number"><span class="hljs-number">5</span></span>) HELP -- Print this help.</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stream-Größenbeschränkung </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele Anwendungen möchten nicht für immer Daten im Stream sammeln. </font><font style="vertical-align: inherit;">Es ist oft nützlich, die maximale Anzahl von Nachrichten im Stream zu haben. </font><font style="vertical-align: inherit;">In anderen Fällen ist es hilfreich, alle Nachrichten vom Stream in einen anderen dauerhaften Speicher zu übertragen, wenn die angegebene Streamgröße erreicht ist. </font><font style="vertical-align: inherit;">Sie können die Größe des Streams mit dem Parameter </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MAXLEN im Befehl XADD begrenzen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="go hljs">&gt; XADD mystream MAXLEN <span class="hljs-number"><span class="hljs-number">2</span></span> * value <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1526654998691</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> &gt; XADD mystream MAXLEN <span class="hljs-number"><span class="hljs-number">2</span></span> * value <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1526654999635</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> &gt; XADD mystream MAXLEN <span class="hljs-number"><span class="hljs-number">2</span></span> * value <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">1526655000369</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> &gt; XLEN mystream (integer) <span class="hljs-number"><span class="hljs-number">2</span></span> &gt; XRANGE mystream - + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526654999635</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"value"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"2"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526655000369</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"value"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"3"</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei Verwendung von MAXLEN werden alte Datensätze automatisch gelöscht, wenn die angegebene Länge erreicht ist, sodass der Stream eine konstante Größe hat. </font><font style="vertical-align: inherit;">In diesem Fall erfolgt das Trimmen im Redis-Speicher jedoch nicht auf die produktivste Weise. </font><font style="vertical-align: inherit;">Die Situation kann wie folgt </font><font style="vertical-align: inherit;">verbessert </font><font style="vertical-align: inherit;">werden: Das </font><font style="vertical-align: inherit;">Argument ~ im obigen Beispiel bedeutet, dass wir die Länge des Streams nicht auf einen bestimmten Wert beschränken müssen. </font><font style="vertical-align: inherit;">In unserem Beispiel kann dies eine beliebige Zahl größer oder gleich 1000 sein (z. B. 1000, 1010 oder 1030). </font><font style="vertical-align: inherit;">Wir haben nur ausdrücklich angegeben, dass in unserem Stream mindestens 1000 Datensätze gespeichert werden sollen. </font><font style="vertical-align: inherit;">Dies macht das Arbeiten mit Speicher in Redis viel effizienter. </font><font style="vertical-align: inherit;">Es gibt auch einen separaten </font><b><font style="vertical-align: inherit;">XTRIM-</font></b><font style="vertical-align: inherit;"> Befehl </font><font style="vertical-align: inherit;">, der dasselbe tut:</font></font><br><br> <code>XADD mystream MAXLEN ~ 1000 * ... entry fields here ... <br></code> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br> <code>&gt; XTRIM mystream MAXLEN 10 <br> <br> &gt; XTRIM mystream MAXLEN ~ 10 <br></code> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Permanente Speicherung und Replikation </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Stream wird asynchron auf Slave-Knoten repliziert und in Dateien wie AOF (Snapshot aller Daten) und RDB (Protokoll aller Schreibvorgänge) gespeichert. </font><font style="vertical-align: inherit;">Die Statusreplikation für Verbrauchergruppen wird ebenfalls unterstützt. </font><font style="vertical-align: inherit;">Befindet sich die Nachricht auf dem Masterknoten im Status "Ausstehend", hat diese Nachricht auf den Slaveknoten denselben Status.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einzelne Elemente aus einem Stream entfernen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Löschen von Nachrichten gibt es einen speziellen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XDEL-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Befehl </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der Befehl erhält den Namen des Streams, gefolgt von den Bezeichnern der Nachricht, die gelöscht werden muss:</font></font><br><br><pre> <code class="go hljs">&gt; XRANGE mystream - + COUNT <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526654999635</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"value"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"2"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526655000369</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"value"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"3"</span></span> &gt; XDEL mystream <span class="hljs-number"><span class="hljs-number">1526654999635</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> (integer) <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; XRANGE mystream - + COUNT <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526655000369</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"value"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"3"</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie diesen Befehl verwenden, müssen Sie berücksichtigen, dass der Speicher nicht sofort freigegeben wird. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Streams ohne Länge </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Unterschied zwischen Streams und anderen Redis-Datenstrukturen besteht darin, dass die Datenstruktur selbst aus dem Speicher gelöscht wird, wenn andere Datenstrukturen keine Elemente mehr in sich haben. </font><font style="vertical-align: inherit;">So wird beispielsweise die sortierte Menge vollständig gelöscht, wenn der ZREM-Aufruf das letzte Element entfernt. </font><font style="vertical-align: inherit;">Stattdessen dürfen Threads im Speicher bleiben, ohne dass sich auch nur ein einziges Element darin befindet.</font></font><br><br><h4>  Fazit </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Stream ist ideal zum Erstellen von Nachrichtenbrokern, Nachrichtenwarteschlangen, einheitlichen Protokollen und Chat-Systemen, in denen der Verlauf gespeichert wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicklaus Wirth</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einmal sagte </font><font style="vertical-align: inherit;">, sind Programme Algorithmen plus Datenstrukturen, und Redis bietet Ihnen bereits beides.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456270/">https://habr.com/ru/post/de456270/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456258/index.html">Frei wie ein Wind und frei wie ein Bier Übersetzung von "Frei wie in Freiheit" ins Russische unter der GNU FDL 1.3 Lizenz</a></li>
<li><a href="../de456260/index.html">Fair Economy Talk</a></li>
<li><a href="../de456262/index.html">Software Defined Radio - wie funktioniert es? Teil 9</a></li>
<li><a href="../de456264/index.html">Erstellen Sie Android-Binärdateien mit Source und Android NDK. Wir pumpen das Screencap-Dienstprogramm auf</a></li>
<li><a href="../de456266/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 302 (vom 10. bis 16. Juni)</a></li>
<li><a href="../de456272/index.html">Was ist Android Lint und wie können Sie unterstützten Code schreiben?</a></li>
<li><a href="../de456274/index.html">Psychologen: Sexroboter führen zu einer Zunahme der Anzahl von Menschen ohne ein Paar, die keine Beziehung zu anderen Menschen benötigen</a></li>
<li><a href="../de456276/index.html">Was sind Informationen?</a></li>
<li><a href="../de456280/index.html">Erste Schritte mit stm32 oder meine Fehler nicht wiederholen</a></li>
<li><a href="../de456282/index.html">Mehrdimensionale Grafiken in Python - von dreidimensional bis sechsdimensional</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>