<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏽 🙎🏾 🚴🏾 Lambda：从C ++ 11到C ++ 20。 第一部分 👩🏿‍⚖️ 🏳️‍🌈 🏹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="朋友们，下午好。 今天，我们为您准备了文章“ Lambdas：从C ++ 11到C ++ 20”的第一部分的翻译。 该材料的发布时间恰好与明天开始的“ C ++开发人员”课程的发布时间相同。 

 Lambda表达式是C ++ 11中最强大的功能之一，并且随着每种新语言标准的发展而不断发展。 在本文...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lambda：从C ++ 11到C ++ 20。 第一部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/444524/">朋友们，下午好。 今天，我们为您准备了文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Lambdas：从C ++ 11到C ++ 20”</a>的第一部分的翻译。 该材料的发布时间恰好与明天开始的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ C ++开发人员”</a>课程的发布时间相同。 <br><br>  Lambda表达式是C ++ 11中最强大的功能之一，并且随着每种新语言标准的发展而不断发展。 在本文中，我们将回顾他们的历史，并研究现代C ++这个重要部分的演变。 <br><br><img src="https://habrastorage.org/webt/s8/xa/l8/s8xal8zqrhmjeh-omwslxujvsmw.png"><br><br> 第二部分在这里可用： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lambda：从C ++ 11到C ++ 20，第2部分</a> <br><a name="habracut"></a><br>  <b>参赛作品</b> <br><br> 在本地C ++用户组会议上，我们就lambda表达式的“历史”进行了现场编程。 对话由C ++专家TomaszKamiński主持（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请参阅Thomas的Linkedin个人资料</a> ）。 这是事件： <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lambda：从C ++ 11到C ++ 20-C ++用户组克拉科夫</a> <br><br> 我决定从Thomas（经过他的许可！）获取代码，对其进行描述并创建另一篇文章。 <br><br> 我们将从探索C ++ 03和对紧凑局部函数表达式的需求开始。 然后我们转到C ++ 11和C ++ 14。 在本系列的第二部分中，我们将看到C ++ 17中的变化，甚至看看C ++ 20中将发生什么。 <br><br>  <b>C ++ 03中的Lambda</b> <br><br> 从一开始，STL的<code>std::algorithms</code> （例如<code>std::sort</code> ）就可以接受任何被调用的对象，并在容器元素上对其进行调用。 但是，在C ++ 03中，这仅涉及指向函数和函子的指针。 <br><br> 例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; struct PrintFunctor { void operator()(int x) const { std::cout &lt;&lt; x &lt;&lt; std::endl; } }; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); std::for_each(v.begin(), v.end(), PrintFunctor()); }</span></span></span></span></code> </pre> <br> 运行代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <br><br> 但是问题在于，您必须在不同的范围内而不是在算法调用的范围内编写一个单独的函数或函子。 <br><br> 作为一种潜在的解决方案，您可能考虑编写本地仿函数类-因为C ++始终支持此语法。 但这行不通... <br><br> 看一下这段代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintFunctor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; v.push_back(<span class="hljs-number"><span class="hljs-number">1</span></span>); v.push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(v.begin(), v.end(), PrintFunctor()); }</code> </pre> <br> 尝试使用<code>-std=c++98</code>编译，您将在GCC中看到以下错误： <br><br><pre> <code class="cpp hljs">error: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> argument <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'template&lt;class _IIter, class _Funct&gt; _Funct std::for_each(_IIter, _IIter, _Funct)'</span></span> uses local type <span class="hljs-string"><span class="hljs-string">'main()::PrintFunctor'</span></span></code> </pre> <br> 本质上，在C ++ 98/03中，您不能创建具有本地类型的模板的实例。 <br> 由于所有这些限制，委员会开始开发一项新功能，我们可以创建该功能并将其称为“就地” ...“ lambda表达式”！ <br><br> 如果我们看一下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">N3337</a> -C ++ 11的最终版本，我们将看到lambda的单独部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[expr.prim.lambda]</a> 。 <br><br>  <b>紧接C ++ 11</b> <br><br> 我认为lambda已被明智地添加到语言中。 他们使用新的语法，但是编译器随后将其“扩展”为真实的类。 因此，我们拥有真正的严格类型化语言的所有优点（有时是缺点）。 <br><br> 这是一个基本代码示例，还显示了相应的本地仿函数对象： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; int main() { struct { void operator()(int x) const { std::cout &lt;&lt; x &lt;&lt; '\n'; } } someInstance; std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); std::for_each(v.begin(), v.end(), someInstance); std::for_each(v.begin(), v.end(), [] (int x) { std::cout &lt;&lt; x &lt;&lt; '\n'; } ); }</span></span></span></span></code> </pre> <br> 示例： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@WandBox</a> <br><br> 您还可以签出CppInsights，它显示了编译器如何扩展代码： <br><br> 看一下这个例子： <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CppInsighs：Lambda测试</a> <br><br> 在此示例中，编译器将转换： <br><br><pre> <code class="cpp hljs">[] (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; }</code> </pre> <br><br> 变成与此类似的形式（简化形式）： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } } someInstance;</code> </pre> <br>  Lambda表达式语法： <br><br><pre> <code class="cpp hljs">[] () { ; } ^ ^ ^ | | | | | : <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span>, exception, trailing <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>, ... | | |   |     </code> </pre><br> 我们开始之前的一些定义： <br><br> 来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[expr.prim.lambda＃2]</a> ： <br><br> 计算lambda表达式会导致一个临时的prvalue。 此临时对象称为<i>闭包对象</i> 。 <br><br> 并且来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[expr.prim.lambda＃3]</a> ： <br><br>  lambda表达式的类型（也是闭包对象的类型）是称为<i>闭包类型</i>的类的唯一无名非工会<i>类型</i> 。 <br><br>  Lambda表达式的一些示例： <br><br> 例如： <br><br><pre> <code class="cpp hljs">[](<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a*f; } [](MyClass t) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = t.compute(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  <b>λ型</b> <br><br> 由于编译器会为每个lambda生成一个唯一的名称，因此不可能事先知道它。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> myLambda = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2.0</span></span> * a; }</code> </pre> <br> 此外<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[expr.prim.lambda]</a> ： <br> 与lambda表达式关联的闭包类型具有一个远程（[dcl.fct.def.delete]）默认构造函数和一个远程赋值运算符。 <br><br> 因此，您不能写： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [&amp;x, &amp;y]() { ++x; ++y; }; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(foo) fooCopy;</code> </pre> <br> 这会在GCC中导致以下错误： <br><br><pre> <code class="cpp hljs">error: use of deleted function <span class="hljs-string"><span class="hljs-string">'main()::&lt;lambda()&gt;::&lt;lambda&gt;()'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(foo) fooCopy; ^~~~~~~ note: a lambda closure type has a deleted <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> constructor</code> </pre> <br>  <b>呼叫接线员</b> <br><br> 放入lambda主体中的代码被“转换”为相应闭包类型的operator（）代码。 <br><br> 默认情况下，这是一个内置的常量方法。 您可以在声明参数后通过指定mutable来更改它： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> myLambda = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a) <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; a; }</code> </pre> <br> 尽管常量方法不是没有空捕获列表的lambda的“问题”，但是当您要捕获某些东西时，它就很重要。 <br><br>  <b>捕捉</b> <br><br>  []不仅引入了lambda，而且还包含捕获变量的列表。 这称为捕获列表。 <br><br> 通过捕获变量，您可以在闭包类型中创建此变量的副本成员。 然后，可以在lambda主体内访问它。 <br><br> 基本语法为： <br><br><ul><li>  [＆]-通过引用捕获，自动存储中的所有变量都在作用域中声明 </li><li>  [=]-按值捕获，将值复制 </li><li>  [x，＆y]-按值显式捕获x，按引用显式捕获y </li></ul><br> 例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, y = <span class="hljs-number"><span class="hljs-number">1</span></span>; { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [&amp;x, &amp;y]() { ++x; ++y; }; foo(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br> 您可以在此处<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">尝试</a>完整的示例： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <br><br> 尽管指定<code>[=]</code>或<code>[&amp;]</code>会很方便-由于它会捕获自动存储中的所有变量，所以显式地捕获变量更为明显。 因此，编译器可以警告您不必要的影响（例如，请参见有关全局和静态变量的说明） <br><br> 您还可以在Scott Meyers撰写的有效现代C ++第31段中了解更多信息：“避免使用默认捕获模式。” <br><br> 还有一个重要的报价： <br><blockquote>  C ++闭包不会增加捕获链接的生存期。 </blockquote><br><br>  <b>可变的</b> <br><br> 默认情况下，闭包类型运算符（）是常量，您不能在lambda表达式主体内修改捕获的变量。 <br> 如果要更改此行为，则需要在参数列表之后添加mutable关键字： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, y = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [x, y]() <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { ++x; ++y; }; foo(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br> 在上面的示例中，我们可以更改x和y的值，但是这些只是所附范围中x和y的副本。 <br><br>  <b>全局变量捕获</b> <br><br> 如果您具有全局值，然后在lambda中使用[=]，则您可能会认为全局值也可以通过值来捕获，但事实并非如此。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> global = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; global &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [=] () <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { ++global; }; foo(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; global &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; [] { ++global; } (); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; global &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; [global] { ++global; } (); }</code> </pre> <br> 您可以在此处使用代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> <br> 仅捕获自动存储中的变量。  GCC甚至可能发出以下警告： <br><br><pre> <code class="cpp hljs">warning: capture of variable <span class="hljs-string"><span class="hljs-string">'global'</span></span> with non-automatic storage duration</code> </pre> <br> 仅当您明确捕获全局变量时才会出现此警告，因此，如果使用<code>[=]</code> ，编译器将无济于事。 <br>  Clang编译器更有用，因为它会生成错误： <br><br><pre> <code class="cpp hljs">error: <span class="hljs-string"><span class="hljs-string">'global'</span></span> cannot be captured because it does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> have automatic storage duration</code> </pre> <br> 参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <br><br>  <b>捕获静态变量</b> <br><br> 捕获静态变量类似于捕获全局变量： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; void bar() { static int static_int = 10; std::cout &lt;&lt; static_int &lt;&lt; std::endl; auto foo = [=] () mutable { ++static_int; }; foo(); std::cout &lt;&lt; static_int &lt;&lt; std::endl; [] { ++static_int; } (); std::cout &lt;&lt; static_int &lt;&lt; std::endl; [static_int] { ++static_int; } (); } int main() { bar(); }</span></span></span></span></code> </pre> <br> 您可以在此处使用代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <br><br> 结论： <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span></code> </pre> <br> 同样，仅当您显式捕获静态变量时才会出现警告，因此，如果使用<code>[=]</code> ，编译器将无济于事。 <br><br>  <b>班级成员捕获</b> <br><br> 您知道执行以下代码后会发生什么： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; struct Baz { std::function&lt;void()&gt; foo() { return [=] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; int main() { auto f1 = Baz{"ala"}.foo(); auto f2 = Baz{"ula"}.foo(); f1(); f2(); }</span></span></span></span></code> </pre><br> 该代码声明一个Baz对象，然后调用<code>foo()</code> 。 请注意， <code>foo()</code>返回一个lambda（存储在<code>std::function</code> ），该lambda捕获该类的成员。 <br><br> 由于我们使用临时对象，因此无法确定调用f1和f2时会发生什么。 这是一个悬而未决的链接问题，导致未定义的行为。 <br><br> 类似地： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; f1 = Bar{<span class="hljs-string"><span class="hljs-string">"ala"</span></span>}.foo(); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br> 玩<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a>代码 <br><br> 同样，如果您明确指定捕获（[s]）： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>()&gt; foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [s] { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }; }</code> </pre><br> 编译器将防止您的错误： <br><br><pre> <code class="cpp hljs">In member function <span class="hljs-string"><span class="hljs-string">'std::function&lt;void()&gt; Baz::foo()'</span></span>: error: capture of non-variable <span class="hljs-string"><span class="hljs-string">'Baz::s'</span></span> error: <span class="hljs-string"><span class="hljs-string">'this'</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> captured <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> lambda function ...</code> </pre> <br> 查看示例： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <br><br>  <b>只能移动的对象</b> <br><br> 如果您有一个只能移动的对象（例如，unique_ptr），则不能将其作为捕获变量放入lambda中。 按值捕获不起作用，因此您只能按引用捕获...但是，这不会将其转让给您，并且可能不是您想要的。 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [p] () {}; <span class="hljs-comment"><span class="hljs-comment">//  ....</span></span></code> </pre><br>  <b>保存常数</b> <br><br> 如果捕获一个常量变量，则将保留常量： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [x] () <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_const&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(x)&gt;::value &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; x = <span class="hljs-number"><span class="hljs-number">11</span></span>; }; foo();</code> </pre> <br> 参见代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <br><br>  <b>返回类型</b> <br><br> 在C ++ 11中，您可以跳过<code>trailing</code>返回的lambda类型，然后编译器将为您输出它。 <br><br> 最初，返回值类型的输出仅限于包含一个return语句的lambda，但由于实现了更方便的版本没有问题，因此该限制很快被消除。 <br><br> 请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++标准核心语言缺陷报告和已接受的问题</a> （感谢Thomas找到正确的链接！） <br><br> 因此，从C ++ 11开始，如果所有返回语句都可以转换为相同类型，则编译器可以推断出返回值的类型。 <br><blockquote> 如果所有return语句在左值到右值（7.1 [conv.lval]），数组到指针（7.2 [conv.array]）和函数到指针（7.3 [conv。 func]）与泛型类型相同； <br></blockquote><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> baz = [] () { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">1.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">2.1</span></span>; };</code> </pre><br> 您可以在此处使用代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <br><br> 上面的lambda中有两个<code>return</code> ，但是它们都指向<code>double</code> ，因此编译器可以推断类型。 <br><br>  <b>IIFE-立即调用函数表达式</b> <br><br> 在我们的示例中，我定义了一个lambda，然后使用闭包对象对其进行了调用……但也可以立即调用它： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, y = <span class="hljs-number"><span class="hljs-number">1</span></span>; [&amp;]() { ++x; ++y; }(); <span class="hljs-comment"><span class="hljs-comment">// &lt;-- call () std::cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; std::endl;</span></span></code> </pre> <br> 这样的表达式在常量对象的复杂初始化中很有用。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val = []() { <span class="hljs-comment"><span class="hljs-comment">/*   ... */</span></span> }();</code> </pre> <br> 我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IIFE复杂初始化</a>文章中写了更多有关此的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内容</a> 。 <br><br>  <b>转换为函数指针</b> <br><blockquote> 没有捕获的lambda表达式的闭包类型具有开放的非虚拟隐式函数，该函数将常量转换为指向具有与调用闭包类型的函数的运算符相同的参数和返回类型的函数的指针。 此转换函数返回的值必须是该函数的地址，该地址在调用时与调用类似于闭包类型的函数的运算符具有相同的作用。 </blockquote> 换句话说，您可以将没有捕获的lambda转换为函数指针。 <br><br> 例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; void callWith10(void(* bar)(int)) { bar(10); } int main() { struct { using f_ptr = void(*)(int); void operator()(int s) const { return call(s); } operator f_ptr() const { return &amp;call; } private: static void call(int s) { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } baz; callWith10(baz); callWith10([](int x) { std::cout &lt;&lt; x &lt;&lt; std::endl; }); }</span></span></span></span></code> </pre> <br> 您可以在此处使用代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <br><br>  <b>C ++ 14的改进</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">N4140</a>标准和lambda： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[expr.prim.lambda]</a> 。 <br><br>  C ++ 14对lambda表达式进行了两项重大改进： <br><br><ul><li> 用初始化器捕获 </li><li> 常见的λ </li></ul><br> 这些功能解决了C ++ 11中可见的几个问题。 <br><br>  <b>返回类型</b> <br><br>  lambda表达式的返回值类型的输出已更新，以符合函数的自动输出规则。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[expr.prim.lambda＃4]</a> <br><blockquote>  lambda的返回类型为auto，如果提供了返回的类型和/或从return语句推断出该值，则将其替换为尾随的返回类型，如[dcl.spec.auto]中所述。 </blockquote>  <b>用初始化器捕获</b> <br><br> 简而言之，我们可以创建一个新的闭包类型的成员变量，然后在lambda表达式中使用它。 <br><br> 例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [z = x+y]() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; z &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; }; foo(); }</code> </pre> <br> 这可以解决几个问题，例如，仅可用于移动的类型。 <br><br>  <b>搬家</b> <br><br> 现在我们可以将对象移动到闭包类型的成员： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; int main() { std::unique_ptr&lt;int&gt; p(new int[10]); auto foo = [x=10] () mutable { ++x; }; auto bar = [ptr=std::move(p)] {}; auto baz = [p=std::move(p)] {}; }</span></span></span></span></code> </pre> <br>  <b>最佳化</b> <br><br> 另一个想法是将其用作潜在的优化技术。 不必每次调用lambda都计算一些值，而是可以在初始化程序中计算一次： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;memory&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { using namespace std::string_literals; std::vector&lt;std::string&gt; vs; std::find_if(vs.begin(), vs.end(), [](std::string const&amp; s) { return s == "foo"s + "bar"s; }); std::find_if(vs.begin(), vs.end(), [p="foo"s + "bar"s](std::string const&amp; s) { return s == p; }); }</span></span></span></span></code> </pre> <br>  <b>捕获成员变量</b> <br><br> 初始化程序也可以用于捕获成员变量。 然后，我们可以获得成员变量的副本，而不必担心悬挂链接。 <br><br> 例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Baz</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [s=s] { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f1 = Baz{<span class="hljs-string"><span class="hljs-string">"ala"</span></span>}.foo(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f2 = Baz{<span class="hljs-string"><span class="hljs-string">"ula"</span></span>}.foo(); f1(); f2(); }</code> </pre> <br> 您可以在此处使用代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> <br><br> 在<code>foo()</code>我们通过将成员变量复制到闭包类型来捕获它。 另外，我们使用auto输出整个方法（以前，在C ++ 11中，我们可以使用<code>std::function</code> ）。 <br><br>  <b>通用Lambda表达式</b> <br><br> 另一个重要的改进是广义λ。 <br> 从C ++ 14开始，您可以编写： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; }; foo(<span class="hljs-number"><span class="hljs-number">10</span></span>); foo(<span class="hljs-number"><span class="hljs-number">10.1234</span></span>); foo(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>);</code> </pre> <br> 这等效于在闭包类型的调用语句中使用模板声明： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } } someInstance;</code> </pre><br> 当难以推断类型时，这种广义lambda可能非常有用。 <br><br> 例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers { { <span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> }, {<span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> }, { <span class="hljs-string"><span class="hljs-string">"three"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> } }; <span class="hljs-comment"><span class="hljs-comment">//      pair&lt;const string, int&gt;! std::for_each(std::begin(numbers), std::end(numbers), [](const std::pair&lt;std::string, int&gt;&amp; entry) { std::cout &lt;&lt; entry.first &lt;&lt; " = " &lt;&lt; entry.second &lt;&lt; '\n'; } );</span></span></code> </pre><br> 我在这里错了吗？ 输入的类型正确吗？ <br>  。 <br>  。 <br>  。 <br> 可能不是，因为std :: map的值类型是<code>std::pair&lt;const Key, T&gt;</code> 。 因此，我的代码将制作这些行的其他副本... <br> 这可以通过<code>auto</code>来解决： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(numbers), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(numbers), [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entry) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; entry.first &lt;&lt; <span class="hljs-string"><span class="hljs-string">" = "</span></span> &lt;&lt; entry.second &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } );</code> </pre> <br> 您可以在此处使用代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <br><br>  <b>结论</b> <br><br> 真是个故事！ <br><br> 在本文中，我们从C ++ 03和C ++ 11中的lambda表达式开始的第一天开始，然后转到C ++ 14中的改进版本。 <br><br> 您已经了解了如何创建lambda，该表达式的基本结构是什么，捕获列表等等。 <br><br> 在本文的下一部分中，我们将继续学习C ++ 17，并了解C ++ 20的未来功能。 <br><br> 第二部分在这里可用： <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lambda：从C ++ 11到C ++ 20，第2部分</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> <br><br> 参考文献 <br><br>  C ++ 11- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[expr.prim.lambda]</a> <br>  C ++ 14- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[expr.prim.lambda]</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++中的Lambda表达式|</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">微软文档</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">揭秘C ++ lambdas-粘性位-由Feabhas提供支持；粘性位-由Feabhas提供支持</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> <br><br> 我们正在等待您的意见，并邀请对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ C ++开发人员”</a>课程感兴趣的所有人。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444524/">https://habr.com/ru/post/zh-CN444524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444514/index.html">网络研讨会“机器学习安全性：人工智能的自然问题”</a></li>
<li><a href="../zh-CN444516/index.html">Wolfenstein 3D：使用WebGL1进行光线跟踪</a></li>
<li><a href="../zh-CN444518/index.html">走向意识的基本理论</a></li>
<li><a href="../zh-CN444520/index.html">2. Check Point入门R80.20。 解决方案架构</a></li>
<li><a href="../zh-CN444522/index.html">启示录被取消</a></li>
<li><a href="../zh-CN444526/index.html">DOTS堆栈：C ++和C＃</a></li>
<li><a href="../zh-CN444528/index.html">情况：日本可能限制从网络下载内容-我们理解并讨论</a></li>
<li><a href="../zh-CN444530/index.html">Android中依赖项注入的未来</a></li>
<li><a href="../zh-CN444534/index.html">漏洞扫描和安全开发。 第一部分</a></li>
<li><a href="../zh-CN444536/index.html">MVCC-2。 图层，文件，页面</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>