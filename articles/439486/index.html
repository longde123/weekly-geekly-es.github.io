<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéª üïú üöå Tipos de referencia .NET vs Tipos de valor. Parte 1 üê∞ üë®üèΩ‚Äç‚öïÔ∏è ü§ôüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Primero, hablemos sobre los Tipos de referencia y los Tipos de valor. Creo que la gente realmente no entiende las diferencias y los beneficios de ambo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos de referencia .NET vs Tipos de valor. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/439486/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a>  Primero, hablemos sobre los Tipos de referencia y los Tipos de valor.  Creo que la gente realmente no entiende las diferencias y los beneficios de ambos.  Por lo general, dicen que los tipos de referencia almacenan contenido en el mont√≥n y los tipos de valor almacenan contenido en la pila, lo cual es incorrecto. </p><br><p>  Discutamos las diferencias reales: </p><br><ul><li>  <em>Un tipo de valor</em> : su valor es <strong>una estructura completa</strong> .  El valor de un tipo de referencia es <strong>una referencia</strong> a un objeto.  - Una estructura en la memoria: los tipos de valores contienen solo los datos que indic√≥.  Los tipos de referencia tambi√©n contienen dos campos del sistema.  El primero almacena 'SyncBlockIndex', el segundo almacena la informaci√≥n sobre un tipo, incluida la informaci√≥n sobre una Tabla de m√©todos virtuales (VMT). </li><li>  Los tipos de referencia pueden tener m√©todos que se anulan cuando se heredan.  Los tipos de valor no se pueden heredar. </li><li>  Debe asignar espacio en el mont√≥n para una instancia de un tipo de referencia.  Se <em>puede</em> asignar un tipo de valor en la pila, o se convierte en parte de un tipo de referencia.  Esto aumenta suficientemente el rendimiento de algunos algoritmos. </li></ul><br><p>  Sin embargo, hay caracter√≠sticas comunes: </p><br><ul><li>  Ambas subclases pueden heredar el tipo de objeto y convertirse en sus representantes. </li></ul><br><p>  Miremos m√°s de cerca cada caracter√≠stica. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo fue traducido del ruso conjuntamente por el autor y por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traductores profesionales</a> .  Puede ayudarnos con la traducci√≥n del ruso o el ingl√©s a cualquier otro idioma, principalmente al chino o al alem√°n. <br><br>  Adem√°s, si quieres agradecernos, la mejor manera de hacerlo es darnos una estrella en Github o bifurcar el repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/z0/iq/m6/z0iqm6nihoilvykxs3el7zujlrk.jpeg"></a> </p><a name="habracut"></a><br><p>  Miremos m√°s de cerca cada caracter√≠stica. </p><br><h2 id="copying">  Copiando </h2><br><p>  La principal diferencia entre los dos tipos es la siguiente: </p><br><ul><li>  Cada campo de variable, clase o estructura o par√°metros de m√©todo que toman un tipo de referencia almacenan <strong>una referencia</strong> a un valor; </li><li>  Pero cada variable, clase o campo de estructura o par√°metros de m√©todo que toman un tipo de valor almacenan un valor exactamente, es decir, una estructura completa. </li></ul><br><p>  Esto significa que asignar o pasar un par√°metro a un m√©todo copiar√° el valor.  Incluso si cambia la copia, el original permanecer√° igual.  Sin embargo, si cambia los campos de tipo de referencia, esto "afectar√°" todas las partes con una referencia a una instancia de un tipo.  Veamos el <br>  ejemplo: </p><br><pre><code class="cs hljs">DateTime dt = DateTime.Now; <span class="hljs-comment"><span class="hljs-comment">// Here, we allocate space for DateTime variable when calling a method, // but it will contain zeros. Next, let's copy all // values of the Now property to dt variable DateTime dt2 = dt; // Here, we copy the value once again object obj = new object(); // Here, we create an object by allocating memory on the Small Object Heap, // and put a pointer to the object in obj variable object obj2 = obj; // Here, we copy a reference to this object. Finally, // we have one object and two references.</span></span></code> </pre> <br><p>  Parece que esta propiedad produce construcciones de c√≥digo ambiguas como el <br>  cambio de c√≥digo en colecciones: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create an array of such structures and initialize the Data field = 5 var array = new [] { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field array[0].Data = 4; // Let's check the value Console.WriteLine(array[0].Data);</code> </pre> <br><p>  Hay un peque√±o truco en este c√≥digo.  Parece que primero obtenemos la instancia de estructura y luego asignamos un nuevo valor al campo Datos de la copia.  Esto significa que deber√≠amos obtener <code>5</code> nuevamente al verificar el valor.  Sin embargo, esto no sucede.  MSIL tiene una instrucci√≥n separada para establecer los valores de los campos en las estructuras de una matriz, lo que aumenta el rendimiento.  El c√≥digo funcionar√° seg√∫n lo previsto: el programa <br>  salida <code>4</code> a una consola. </p><br><p>  Veamos qu√© suceder√° si cambiamos este c√≥digo: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create a list of such structures and initialize the Data field = 5 var list = new List&lt;ValueHolder&gt; { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field list[0].Data = 4; // Let's check the value Console.WriteLine(list[0].Data);</code> </pre> <br><p>  La compilaci√≥n de este c√≥digo fallar√°, porque cuando escribe <code>list[0].Data = 4</code> obtiene primero la copia de la estructura.  De hecho, est√° llamando a un m√©todo de instancia del tipo <code>List&lt;T&gt;</code> que subyace al acceso mediante un √≠ndice.  Toma la copia de una estructura de una matriz interna ( <code>List&lt;T&gt;</code> almacena datos en matrices) y le devuelve esta copia del m√©todo de acceso utilizando un √≠ndice.  A continuaci√≥n, intenta modificar la copia, que no se usa m√°s adelante.  Este c√≥digo no tiene sentido.  Un compilador proh√≠be tal comportamiento, sabiendo que las personas usan mal los tipos de valor.  Deber√≠amos reescribir este ejemplo de la siguiente manera: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create a list of such structures and initialize the Data field = 5 var list = new List&lt;ValueHolder&gt; { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field. Then, let's save it again. var copy = list[0]; copy.Data = 4; list[0] = copy; // Let's check the value Console.WriteLine(list[0].Data);</code> </pre> <br><p>  Este c√≥digo es correcto a pesar de su aparente redundancia.  El programa <br>  salida <code>4</code> a una consola. </p><br><p>  El siguiente ejemplo muestra lo que quiero decir con "el valor de una estructura es un <br>  estructura completa " </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } int x = 5; PersonInfo person; int y = 6; // Variant 2 int x = 5; int Height; int Width; int HairColor; int y = 6;</code> </pre> <br><p>  Ambos ejemplos son similares en t√©rminos de la ubicaci√≥n de los datos en la memoria, ya que el valor de la estructura es la estructura completa.  Se asigna la memoria para s√≠ mismo donde est√°. </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } class Employee { public int x; public PersonInfo person; public int y; } // Variant 2 class Employee { public int x; public int Height; public int Width; public int HairColor; public int y; }</code> </pre> <br><p>  Estos ejemplos tambi√©n son similares en t√©rminos de la ubicaci√≥n de los elementos en la memoria, ya que la estructura ocupa un lugar definido entre los campos de clase.  No digo que sean totalmente similares, ya que puede operar campos de estructura utilizando m√©todos de estructura. </p><br><p>  Por supuesto, este no es el caso de los tipos de referencia.  Una instancia en s√≠ est√° en el mont√≥n de objetos peque√±os inalcanzable (SOH) o en el mont√≥n de objetos grandes (LOH).  Un campo de clase solo contiene el valor de un puntero a una instancia: un n√∫mero de 32 o 64 bits. </p><br><p>  Veamos el √∫ltimo ejemplo para cerrar el problema. </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } void Method(int x, PersonInfo person, int y); // Variant 2 void Method(int x, int HairColor, int Width, int Height, int y);</code> </pre> <br><p>  En t√©rminos de memoria, ambas variantes de c√≥digo funcionar√°n de manera similar, pero no en t√©rminos de arquitectura.  No es solo un reemplazo de un n√∫mero variable de argumentos.  El orden cambia porque los par√°metros del m√©todo se declaran uno tras otro.  Se ponen en la pila de la misma manera. </p><br><p>  Sin embargo, la pila crece de direcciones m√°s altas a m√°s bajas.  Eso significa que el orden de empujar una estructura pieza por pieza ser√° diferente de empujarla como un todo. </p><br><h2 id="overridable-methods-and-inheritance">  M√©todos reemplazables y herencia </h2><br><p>  La siguiente gran diferencia entre los dos tipos es la falta de virtual <br>  tabla de m√©todos en estructuras.  Esto significa que: </p><br><ol><li>  No puede describir y anular m√©todos virtuales en estructuras. </li><li>  Una estructura no puede heredar otra.  La √∫nica forma de emular la herencia es poner una estructura de tipo base en el primer campo.  Los campos de una estructura "heredada" ir√°n despu√©s de los campos de una estructura "base" y crear√° una herencia l√≥gica.  Los campos de ambas estructuras coincidir√°n en funci√≥n del desplazamiento. </li><li>  Puede pasar estructuras a c√≥digo no administrado.  Sin embargo, perder√° la informaci√≥n sobre los m√©todos.  Esto se debe a que una estructura es solo espacio en la memoria, llena de datos sin la informaci√≥n sobre un tipo.  Puede pasarlo a m√©todos no administrados, por ejemplo, escritos en C ++, sin cambios. </li></ol><br><p>  La falta de una tabla de m√©todos virtuales resta una cierta parte de la herencia "m√°gica" de las estructuras, pero les da otras ventajas.  La primera es que podemos pasar instancias de dicha estructura a entornos externos (fuera de .NET Framework).  Recuerda, esto es solo un recuerdo <br>  rango!  Tambi√©n podemos tomar un rango de memoria del c√≥digo no administrado y emitir un tipo a nuestra estructura para que sus campos sean m√°s accesibles.  No puede hacer esto con clases ya que tienen dos campos inaccesibles.  Estos son SyncBlockIndex y una direcci√≥n de tabla de m√©todos virtuales.  Si esos dos campos pasan al c√≥digo no administrado, ser√° peligroso.  Usando una tabla de m√©todos virtuales, uno puede acceder a cualquier tipo y cambiarlo para atacar una aplicaci√≥n. </p><br><p>  Vamos a mostrar que es solo un rango de memoria sin l√≥gica adicional. </p><br><pre> <code class="plaintext hljs">unsafe void Main() { int secret = 666; HeightHolder hh; hh.Height = 5; WidthHolder wh; unsafe { // This cast wouldn't work if structures had the information about a type. // The CLR would check a hierarchy before casting a type and if it didn't find WidthHolder, // it would output an InvalidCastException exception. But since a structure is a memory range, // you can interpret it as any kind of structure. wh = *(WidthHolder*)&amp;hh; } Console.WriteLine("Width: " + wh.Width); Console.WriteLine("Secret:" + wh.Secret); } struct WidthHolder { public int Width; public int Secret; } struct HeightHolder { public int Height; }</code> </pre> <br><p>  Aqu√≠, realizamos la operaci√≥n que es imposible en tipeo fuerte.  Lanzamos un tipo a otro incompatible que contiene un campo adicional.  Introducimos una variable adicional dentro del m√©todo Main.  En teor√≠a, su valor es secreto.  Sin embargo, el c√≥digo de ejemplo generar√° el valor de una variable, que no se encuentra en ninguna de las estructuras dentro del m√©todo <code>Main()</code> .  Puede considerarlo una violaci√≥n de la seguridad, pero las cosas no son tan simples.  No puede deshacerse del c√≥digo no administrado en un programa.  La raz√≥n principal es la estructura de la pila de hilos.  Se puede usar para acceder al c√≥digo no administrado y jugar con variables locales.  Puede defender su c√≥digo de estos ataques aleatorizando el tama√±o de un marco de pila.  O bien, puede eliminar la informaci√≥n sobre el registro <code>EBP</code> para complicar el retorno de un marco de pila.  Sin embargo, esto no nos importa ahora.  Lo que nos interesa en este ejemplo es lo siguiente.  La variable "secreta" va <strong>antes de</strong> la definici√≥n de la variable hh y <strong>luego</strong> en la estructura WidthHolder (en diferentes lugares, en realidad).  Entonces, ¬øpor qu√© obtuvimos f√°cilmente su valor?  La respuesta es que la pila crece de derecha a izquierda.  Las variables declaradas primero tendr√°n direcciones mucho m√°s altas, y las declaradas despu√©s tendr√°n direcciones m√°s bajas. </p><br><h2 id="the-behavior-when-calling-instance-methods">  El comportamiento al llamar a m√©todos de instancia </h2><br><p>  Ambos tipos de datos tienen otra caracter√≠stica que no es f√°cil de ver y puede explicar la estructura de ambos tipos.  Se trata de llamar a los m√©todos de instancia. </p><br><pre> <code class="plaintext hljs">// The example with a reference type class FooClass { private int x; public void ChangeTo(int val) { x = val; } } // The example with a value type struct FooStruct { private int x; public void ChangeTo(int val) { x = val; } } FooClass klass = new FooClass(); FooStruct strukt = new FooStruct(); klass.ChangeTo(10); strukt.ChangeTo(10);</code> </pre> <br><p>  L√≥gicamente, podemos decidir que el m√©todo tiene un cuerpo compilado.  En otras palabras, no hay una instancia de un tipo que tenga su propio conjunto compilado de m√©todos, similar a los conjuntos de otras instancias.  Sin embargo, el m√©todo llamado sabe a qu√© instancia pertenece como referencia a la instancia de un tipo que es el primer par√°metro.  Podemos reescribir nuestro ejemplo y ser√° id√©ntico a lo que dijimos antes.  No estoy usando un ejemplo con m√©todos virtuales deliberadamente, ya que tienen otro procedimiento. </p><br><pre> <code class="plaintext hljs">// An example with a reference type class FooClass { public int x; } // An example with a value type struct FooStruct { public int x; } public void ChangeTo(FooClass klass, int val) { klass.x = val; } public void ChangeTo(ref FooStruct strukt, int val) { strukt.x = val; } FooClass klass = new FooClass(); FooStruct strukt = new FooStruct(); ChangeTo(klass, 10); ChangeTo(ref strukt, 10);</code> </pre> <br><p>  Deber√≠a explicar el uso de la palabra clave ref.  Si no lo usara, obtendr√≠a una <strong>copia</strong> de la estructura como par√°metro del m√©todo en lugar del original.  Luego lo cambiar√≠a, pero el original se mantendr√≠a igual.  Tendr√≠a que devolver una copia modificada de un m√©todo a una persona que llama (otra copia), y la persona que llama guardar√≠a este valor nuevamente en la variable (una copia m√°s).  En cambio, un m√©todo de instancia obtiene un puntero y lo usa para cambiar el original de inmediato.  El uso de un puntero no influye en el rendimiento, ya que cualquier operaci√≥n a nivel de procesador utiliza punteros.  Ref es parte del mundo de C #, no m√°s. </p><br><h2 id="the-capability-to-point-to-the-position-of-elements">  La capacidad de se√±alar la posici√≥n de los elementos. </h2><br><p>  Tanto las estructuras como las clases tienen otra capacidad para se√±alar el desplazamiento de un campo en particular con respecto al comienzo de una estructura en la memoria.  Esto sirve para varios prop√≥sitos: </p><br><ul><li>  para trabajar con API externas en el mundo no administrado sin tener que insertar campos no utilizados antes de uno necesario; </li><li>  para indicar a un compilador que ubique un campo justo al comienzo del tipo ( <code>[FieldOffset(0)]</code> ).  Har√° el trabajo con este tipo m√°s r√°pido.  Si es un campo de uso frecuente, podemos aumentar el rendimiento de la aplicaci√≥n.  Sin embargo, esto es cierto solo para los tipos de valor.  En los tipos de referencia, el campo con un desplazamiento cero contiene la direcci√≥n de una tabla de m√©todos virtuales, que toma 1 palabra de m√°quina.  Incluso si aborda el primer campo de una clase, utilizar√° un direccionamiento complejo (direcci√≥n + desplazamiento).  Esto se debe a que el campo de clase m√°s utilizado es la direcci√≥n de una tabla de m√©todos virtuales.  La tabla es necesaria para llamar a todos los m√©todos virtuales; </li><li>  para se√±alar varios campos usando una direcci√≥n.  En este caso, el mismo valor se interpreta como diferentes tipos de datos.  En C ++, este tipo de datos se denomina uni√≥n; </li><li>  no molestarse en declarar nada: un compilador asignar√° los campos de manera √≥ptima.  Por lo tanto, el orden final de los campos puede ser diferente. </li></ul><br><p>  <strong>Observaciones generales</strong> </p><br><ul><li>  <strong>Autom√°tico</strong> : el entorno de tiempo de ejecuci√≥n elige autom√°ticamente una ubicaci√≥n y un empaque para todos los campos de clase o estructura.  Las estructuras definidas que est√°n marcadas por un miembro de esta enumeraci√≥n no pueden pasar a c√≥digo no administrado.  El intento de hacerlo producir√° una excepci√≥n; </li><li>  <strong>Expl√≠cito</strong> : un programador controla expl√≠citamente la ubicaci√≥n exacta de cada campo de un tipo con FieldOffsetAttribute; </li><li>  <strong>Secuencial</strong> : los miembros de tipo vienen en un orden secuencial, definido durante el dise√±o de tipo.  El valor StructLayoutAttribute.Pack de un paso de empaquetado indica su ubicaci√≥n. </li></ul><br><p>  <strong>Usar FieldOffset para omitir los campos de estructura no utilizados</strong> </p><br><p>  Las estructuras que provienen del mundo no administrado pueden contener campos reservados.  Se pueden usar en una versi√≥n futura de una biblioteca.  En C / C ++ llenamos estos huecos agregando campos, por ejemplo, reservado1, reservado2, ... Sin embargo, en .NET solo compensamos al comienzo de un campo usando el atributo FieldOffsetAttribute y <code>[StructLayout(LayoutKind.Explicit)]</code> . </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Explicit)] public struct SYSTEM_INFO { [FieldOffset(0)] public ulong OemId; // 92 bytes reserved [FieldOffset(100)] public ulong PageSize; [FieldOffset(108)] public ulong ActiveProcessorMask; [FieldOffset(116)] public ulong NumberOfProcessors; [FieldOffset(124)] public ulong ProcessorType; }</code> </pre> <br><p>  Hay un espacio ocupado pero espacio no utilizado.  La estructura tendr√° un tama√±o igual a 132 y no 40 bytes, como puede parecer desde el principio. </p><br><p>  <strong>Uni√≥n</strong> </p><br><p>  Usando FieldOffsetAttribute puede emular el tipo C / C ++ llamado uni√≥n.  Permite acceder a los mismos datos que las entidades de <br>  diferentes tipos  Veamos el ejemplo: </p><br><pre> <code class="plaintext hljs">// If we read the RGBA.Value, we will get an Int32 value accumulating all // other fields. // However, if we try to read the RGBA.R, RGBA.G, RGBA.B, RGBA.Alpha, we // will get separate components of Int32. [StructLayout(LayoutKind.Explicit)] public struct RGBA { [FieldOffset(0)] public uint Value; [FieldOffset(0)] public byte R; [FieldOffset(1)] public byte G; [FieldOffset(2)] public byte B; [FieldOffset(3)] public byte Alpha; }</code> </pre> <br><p>  Se podr√≠a decir que tal comportamiento es posible solo para los tipos de valor.  Sin embargo, puede simularlo para los tipos de referencia, utilizando una direcci√≥n para superponer dos tipos de referencia o un tipo de referencia y un tipo de valor: </p><br><pre> <code class="plaintext hljs">class Program { public static void Main() { Union x = new Union(); x.Reference.Value = "Hello!"; Console.WriteLine(x.Value.Value); } [StructLayout(LayoutKind.Explicit)] public class Union { public Union() { Value = new Holder&lt;IntPtr&gt;(); Reference = new Holder&lt;object&gt;(); } [FieldOffset(0)] public Holder&lt;IntPtr&gt; Value; [FieldOffset(0)] public Holder&lt;object&gt; Reference; } public class Holder&lt;T&gt; { public T Value; } }</code> </pre> <br><p>  Us√© un tipo gen√©rico para superponer a prop√≥sito.  Si solia usar <br>  superpuesto, este tipo provocar√≠a la TypeLoadException cuando se carga en un dominio de aplicaci√≥n.  En teor√≠a, puede parecer una violaci√≥n de seguridad (especialmente cuando se habla de <strong>complementos de aplicaciones</strong> ), pero si intentamos ejecutar este c√≥digo usando un dominio protegido, obtendremos la misma <code>TypeLoadException</code> . </p><br><h2 id="the-difference-in-allocation">  La diferencia en la asignaci√≥n </h2><br><p>  Otra caracter√≠stica que diferencia ambos tipos es la asignaci√≥n de memoria para objetos o estructuras.  El CLR debe decidir sobre varias cosas antes de asignar memoria para un objeto.  ¬øCu√°l es el tama√±o de un objeto?  ¬øEs m√°s o menos de 85K?  Si es menor, ¬øhay suficiente espacio libre en el SOH para asignar este objeto?  Si es m√°s, el CLR activa el recolector de basura.  Atraviesa un gr√°fico de objetos, compacta los objetos movi√©ndolos al espacio despejado.  Si todav√≠a no hay espacio en el SOH, se iniciar√° la asignaci√≥n de p√°ginas de memoria virtual adicionales.  Es solo entonces que un objeto obtiene espacio asignado, despejado de basura.  Posteriormente, el CLR presenta SyncBlockIndex y VirtualMethodsTable.  Finalmente, la referencia a un objeto vuelve a un usuario. </p><br><p>  Si un objeto asignado es mayor que 85K, se dirige al Mont√≥n de objetos grandes (LOH).  Este es el caso de grandes cadenas y matrices.  Aqu√≠, debemos encontrar el espacio m√°s adecuado en la memoria de la lista de rangos desocupados o asignar uno nuevo.  No es r√°pido, pero vamos a tratar con cuidado los objetos de tal tama√±o.  Adem√°s, no vamos a hablar de ellos aqu√≠. </p><br><p>  Hay varios escenarios posibles para RefTypes: </p><br><ul><li>  RefType &lt;85K, hay espacio en el SOH: asignaci√≥n r√°pida de memoria; </li><li>  RefType &lt;85K, el espacio en el SOH se est√° agotando: asignaci√≥n de memoria muy lenta; </li><li>  RefType&gt; 85K, asignaci√≥n de memoria lenta. </li></ul><br><p>  Tales operaciones son raras y no pueden competir con ValTypes.  El algoritmo de asignaci√≥n de memoria para tipos de valor no existe.  La asignaci√≥n de memoria para los tipos de valor no cuesta nada.  Lo √∫nico que sucede cuando se asigna memoria para este tipo es establecer campos en nulo.  Veamos por qu√© sucede esto: 1. Cuando se declara una variable en el cuerpo de un m√©todo, el tiempo de asignaci√≥n de memoria para una estructura es cercano a cero.  Esto se debe a que el tiempo de asignaci√≥n para las variables locales no depende de su n√∫mero;  2. Si ValTypes se asignan como campos, Reftypes aumentar√° el tama√±o de los campos.  Un tipo de valor se asigna por completo, convirti√©ndose en su parte;  3. Como en el caso de la copia, si ValTypes se pasan como par√°metros de m√©todo, aparece una diferencia, dependiendo del tama√±o y la ubicaci√≥n de un par√°metro. </p><br><p>  Sin embargo, eso no lleva m√°s tiempo que copiar una variable en otra. </p><br><h2 id="the-choice-between-a-class-or-a-structure">  La elecci√≥n entre una clase o una estructura. </h2><br><p>  Analicemos las ventajas y desventajas de ambos tipos y decidamos sus escenarios de uso.  Un principio cl√°sico dice que deber√≠amos elegir un tipo de valor si no es mayor de 16 bytes, permanece sin cambios durante su vida √∫til y no se hereda.  Sin embargo, elegir el tipo correcto significa revisarlo desde diferentes perspectivas bas√°ndose en escenarios de uso futuro.  Propongo tres grupos de criterios: </p><br><ul><li>  basado en la arquitectura del sistema de tipos, en el que su tipo interactuar√°; </li><li>  basado en su enfoque como programador de sistemas para elegir un tipo con un rendimiento √≥ptimo; </li><li>  cuando no hay otra opci√≥n </li></ul><br><p>  Cada caracter√≠stica dise√±ada debe reflejar su prop√≥sito.  Esto no trata solo con su nombre o interfaz de interacci√≥n (m√©todos, propiedades).  Se pueden usar consideraciones arquitect√≥nicas para elegir entre valores y tipos de referencia.  Pensemos por qu√© podr√≠a elegirse una estructura y no una clase desde el punto de vista del sistema de sistema de tipos. </p><br><ol><li><p>  Si su tipo dise√±ado es independiente de su estado, esto significar√° que su estado refleja un proceso o es un valor de algo.  En otras palabras, una instancia de un tipo es constante e inmutable por naturaleza.  Podemos crear otra instancia de un tipo basada en esta constante indicando alg√∫n desplazamiento.  O bien, podemos crear una nueva instancia indicando sus propiedades.  Sin embargo, no debemos cambiarlo.  No quiero decir que la estructura sea de un tipo inmutable.  Puede cambiar sus valores de campo.  Adem√°s, puede pasar una referencia a una estructura a un m√©todo utilizando el par√°metro ref y obtendr√° campos cambiados despu√©s de salir del m√©todo.  De lo que hablo aqu√≠ es del sentido arquitect√≥nico.  Dar√© varios ejemplos. </p><br><ul><li>  DateTime es una estructura que encapsula el concepto de un momento en el tiempo.  Almacena estos datos como una unidad pero da acceso a caracter√≠sticas separadas de un momento: a√±o, mes, d√≠a, hora, minutos, segundos, milisegundos e incluso tics de procesador.  Sin embargo, es inmutable, bas√°ndose en lo que encapsula.  No podemos cambiar un momento en el tiempo.  No puedo vivir el siguiente minuto como si fuera mi mejor cumplea√±os en la infancia.  Por lo tanto, si elegimos un tipo de datos, podemos elegir una clase con una interfaz de solo lectura, que produce una nueva instancia para cada cambio de propiedades.  O bien, podemos elegir una estructura, que puede pero no debe cambiar los campos de sus instancias: su <em>valor</em> es la descripci√≥n de un momento en el tiempo, como un n√∫mero.  No puede acceder a la estructura de un n√∫mero y cambiarlo.  Si desea obtener otro momento en el tiempo, que difiere en un d√≠a del original, obtendr√° una nueva instancia de una estructura. </li><li>  <code>KeyValuePair&lt;TKey, TValue&gt;</code> es una estructura que encapsula el concepto de un par clave-valor conectado.  Esta estructura es solo para generar el contenido de un diccionario durante la enumeraci√≥n.  Desde el punto de vista arquitect√≥nico, una clave y un valor son conceptos inseparables en el <code>Dictionary&lt;T&gt;</code> .  Sin embargo, en el interior tenemos una estructura compleja, donde una clave se encuentra por separado de un valor.  Para un usuario, un par clave-valor es un concepto inseparable en t√©rminos de interfaz y el significado de una estructura de datos.  Es un <em>valor</em> completo en s√≠ mismo.  Si uno asigna otro valor para una clave, todo el par cambiar√°.  Por lo tanto, representan una sola entidad.  Esto hace que una estructura sea una variante ideal en este caso. </li></ul><br></li><li><p>  Si su tipo dise√±ado es una parte inseparable de un tipo externo pero es estructuralmente integral.  Eso significa que es incorrecto decir que el tipo externo se refiere a una instancia de un tipo encapsulado.  Sin embargo, es correcto decir que un tipo encapsulado es parte de un externo junto con todas sus propiedades.  Esto es √∫til al dise√±ar una estructura que es parte de otra estructura. </p><br><ul><li>  Por ejemplo, si tomamos una estructura de un encabezado de archivo, ser√° inapropiado pasar una referencia de un archivo a otro, por ejemplo, un archivo header.txt.  Esto ser√≠a apropiado al insertar un documento en otro, no incrustando un archivo sino usando una referencia en un sistema de archivos.  Un buen ejemplo son los archivos de acceso directo en el sistema operativo Windows.  Sin embargo, si hablamos de un encabezado de archivo (por ejemplo, encabezado de archivo JPEG que contiene metadatos sobre el tama√±o de una imagen, m√©todos de compresi√≥n, par√°metros de fotograf√≠a, coordenadas GPS y otros), entonces deber√≠amos usar estructuras para dise√±ar tipos para analizar el encabezado.  Si describe todos los encabezados en las estructuras, obtendr√° la misma posici√≥n de los campos en la memoria que en un archivo.  Usando la transformaci√≥n insegura <code>*(Header *)readedBuffer</code> insegura <code>*(Header *)readedBuffer</code> sin deserializaci√≥n obtendr√° estructuras de datos completamente llenas. </li></ul><br></li></ol><br><ol><li>  Ning√∫n ejemplo muestra la herencia del comportamiento.  Muestran que no hay necesidad de heredar el comportamiento de estas entidades.  Son independientes.  Sin embargo, si tomamos en cuenta la efectividad del c√≥digo, veremos la elecci√≥n desde otro lado: </li><li>  Si necesitamos tomar algunos datos estructurados del c√≥digo no administrado, debemos elegir estructuras.  Tambi√©n podemos pasar la estructura de datos a un m√©todo inseguro.  Un tipo de referencia no es adecuado para esto en absoluto. </li><li>  Una estructura es su elecci√≥n si un tipo pasa los datos en llamadas a m√©todos (como valores devueltos o como par√°metro de m√©todo) y no hay necesidad de referirse al mismo valor desde diferentes lugares.  El ejemplo perfecto son las tuplas.  Si un m√©todo devuelve varios valores usando tuplas, devolver√° un ValueTuple, declarado como una estructura.  El m√©todo no asignar√° espacio en el mont√≥n, pero utilizar√° la pila del subproceso, donde la asignaci√≥n de memoria no cuesta nada. </li><li>  Si dise√±a un sistema que crea un gran tr√°fico de instancias que tienen un tama√±o y una vida √∫til peque√±os, el uso de tipos de referencia conducir√° a un grupo de objetos o, si no es el grupo de objetos, a una acumulaci√≥n de basura no controlada en el mont√≥n.  Algunos objetos se convertir√°n en generaciones anteriores, aumentando la carga en GC.  El uso de tipos de valor en dichos lugares (si es posible) aumentar√° el rendimiento porque nada pasar√° al SOH.  Esto disminuir√° la carga en GC y el algoritmo funcionar√° m√°s r√°pido; </li></ol><br><p>  Bas√°ndome en lo que he dicho, aqu√≠ hay algunos consejos sobre el uso de estructuras: </p><br><ol><li>  Al elegir colecciones, debe evitar las grandes matrices que almacenan grandes estructuras.  Esto incluye estructuras de datos basadas en matrices.  Esto puede conducir a una transici√≥n al mont√≥n de objetos grandes y su fragmentaci√≥n.  Es un error pensar que si nuestra estructura tiene 4 campos del tipo byte, tomar√° 4 bytes.  Debemos entender que en los sistemas de 32 bits cada campo de estructura est√° alineado en l√≠mites de 4 bytes (cada campo de direcci√≥n debe dividirse exactamente por 4) y en sistemas de 64 bits, en l√≠mites de 8 bytes.  El tama√±o de una matriz debe depender del tama√±o de una estructura y una plataforma que ejecute un programa.  En nuestro ejemplo con 4 bytes - 85K / (de 4 a 8 bytes por campo * el n√∫mero de campos = 4) menos el tama√±o de un encabezado de matriz equivale a aproximadamente 2 600 elementos por matriz dependiendo de la plataforma (esto debe redondearse hacia abajo )  Eso no es mucho.  Puede haber parecido que podr√≠amos alcanzar f√°cilmente una constante m√°gica de 20,000 elementos </li><li>  A veces, utiliza una estructura de gran tama√±o como fuente de datos y la coloca como un campo en una clase, mientras se replica una copia para producir miles de instancias.  Luego expande cada instancia de una clase para el tama√±o de una estructura.  Conducir√° a la expansi√≥n de la generaci√≥n cero y la transici√≥n a la generaci√≥n uno e incluso dos.  Si las instancias de una clase tienen un per√≠odo de vida corto y cree que el GC las recopilar√° en la generaci√≥n cero, durante 1 ms, se sentir√° decepcionado.  Ya est√°n en la generaci√≥n uno e incluso dos.  Esto hace la diferencia.  Si el GC recolecta la generaci√≥n cero durante 1 ms, las generaciones uno y dos se recolectan muy lentamente, lo que conducir√° a una disminuci√≥n de la eficiencia; </li><li>  Por la misma raz√≥n, debe evitar pasar grandes estructuras a trav√©s de una serie de llamadas a m√©todos.  Si todos los elementos se llaman entre s√≠, estas llamadas ocupar√°n m√°s espacio en la pila y StackOverflowException matar√° su aplicaci√≥n.  La siguiente raz√≥n es el rendimiento.  Cuantas m√°s copias haya, m√°s lentamente todo funciona. </li></ol><br><p>  Es por eso que la elecci√≥n de un tipo de datos no es un proceso obvio.  A menudo, esto puede referirse a una optimizaci√≥n prematura, que no se recomienda.  Sin embargo, si sabe que su situaci√≥n se encuentra dentro de los principios establecidos anteriormente, puede elegir f√°cilmente un tipo de valor. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo fue traducido del ruso conjuntamente por el autor y por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traductores profesionales</a> .  Puede ayudarnos con la traducci√≥n del ruso o el ingl√©s a cualquier otro idioma, principalmente al chino o al alem√°n. <br><br>  Adem√°s, si quieres agradecernos, la mejor manera de hacerlo es darnos una estrella en Github o bifurcar el repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439486/">https://habr.com/ru/post/439486/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439476/index.html">Argot de Cockney: historia moderna y estatus social</a></li>
<li><a href="../439478/index.html">Entretenido C #. Cinco ejemplos de coffee breaks</a></li>
<li><a href="../439480/index.html">Ceder, o ¬øPor qu√© su CRM (y CRM) se ralentiza?</a></li>
<li><a href="../439482/index.html">devleads - (des) motivaci√≥n financiera</a></li>
<li><a href="../439484/index.html">Obtener datos de enumeraci√≥n en una perspectiva de Automapper</a></li>
<li><a href="../439488/index.html">QA Meetup Grabaci√≥n de video</a></li>
<li><a href="../439490/index.html">Tipos de referencia .NET vs Tipos de valor. Parte 2</a></li>
<li><a href="../439492/index.html">10 consejos para ser un buen l√≠der tecnol√≥gico</a></li>
<li><a href="../439496/index.html">C√≥mo se realiza la facturaci√≥n all√≠: cuando el cliente y el desarrollador hablan diferentes idiomas</a></li>
<li><a href="../439498/index.html">¬øEn qu√© hardware analizar un enorme eje de informaci√≥n?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>