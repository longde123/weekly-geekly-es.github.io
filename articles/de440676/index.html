<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèø ü§òüèΩ ü§Ωüèø Der Tag, an dem Dodo aufgeh√∂rt hat. Synchrones Skript ü•† üè© üòù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dodo IS ist ein globales System, mit dem Sie Ihr Gesch√§ft bei Dodo Pizza effektiv verwalten k√∂nnen. Es schlie√üt Probleme bei der Bestellung von Pizza,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Der Tag, an dem Dodo aufgeh√∂rt hat. Synchrones Skript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/440676/">  Dodo IS ist ein globales System, mit dem Sie Ihr Gesch√§ft bei Dodo Pizza effektiv verwalten k√∂nnen.  Es schlie√üt Probleme bei der Bestellung von Pizza, hilft dem Franchisenehmer, den √úberblick √ºber das Gesch√§ft zu behalten, verbessert die Effizienz der Mitarbeiter und f√§llt manchmal ab.  Das Letzte ist das Schlimmste f√ºr uns.  Jede Minute solcher St√ºrze f√ºhrt zu Gewinneinbu√üen, Unzufriedenheit der Benutzer und schlaflosen N√§chten der Entwickler. <br><br>  Aber jetzt schlafen wir besser.  Wir haben gelernt, systemische Apokalypse-Szenarien zu erkennen und zu verarbeiten.  Im Folgenden werde ich Ihnen erkl√§ren, wie wir f√ºr Systemstabilit√§t sorgen. <br><img src="https://habrastorage.org/webt/cj/_g/bz/cj_gbzxwy6ky8m_qqomj46f4nf4.png"><br><a name="habracut"></a><blockquote> <b>Eine Reihe von Artikeln √ºber den Zusammenbruch des Dodo IS * -Systems</b> : <br>  1. Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag, an dem Dodo aufgeh√∂rt hat.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Synchrones Skript.</a> <br>  2. Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag, an dem Dodo aufgeh√∂rt hat.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrones Skript.</a> <br><br>  * Die <i>Materialien wurden basierend auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meiner Leistung bei DotNext 2018 in Moskau geschrieben</a></i> . </blockquote><br><h2>  Dodo ist </h2><br>  Das System ist ein gro√üer Wettbewerbsvorteil unserer Franchise, da Franchisenehmer ein vorgefertigtes Gesch√§ftsmodell erhalten.  Dies sind ERP, HRM und CRM in einem. <br><br>  Das System erschien einige Monate nach der Er√∂ffnung der ersten Pizzeria.  Es wird von Managern, Kunden, Kassierern, K√∂chen, Testk√§ufern und Call-Center-Mitarbeitern verwendet - das ist alles.  Herk√∂mmlicherweise ist Dodo IS in zwei Teile unterteilt.  Der erste ist f√ºr Kunden.  Dazu geh√∂ren eine Website, eine mobile Anwendung und ein Contact Center.  Das zweite f√ºr Franchisenehmer-Partner ist die Verwaltung von Pizzerien.  √úber das System werden Rechnungen von Lieferanten, Personalmanagement, Schichtarbeitern, automatischer Lohn- und Gehaltsabrechnung, Online-Schulungen f√ºr Personal, Zertifizierung von Managern, einem Qualit√§tskontrollsystem und Testk√§ufern durchlaufen. <br><br><h2>  Systemleistung </h2><br>  Systemleistung Dodo IS = Zuverl√§ssigkeit = Fehlertoleranz / Wiederherstellung.  Lassen Sie uns auf jeden der Punkte eingehen. <br><br><h4>  Zuverl√§ssigkeit </h4><br>  Wir haben keine gro√üen mathematischen Berechnungen: Wir m√ºssen eine bestimmte Anzahl von Bestellungen bedienen, es gibt bestimmte Lieferzonen.  Die Anzahl der Kunden variiert nicht besonders.  Nat√ºrlich werden wir gl√ºcklich sein, wenn es w√§chst, aber dies passiert selten in gro√üen St√∂√üen.  F√ºr uns l√§uft die Leistung darauf hinaus, wie wenige Fehler auftreten, und auf die Zuverl√§ssigkeit des Systems. <br><br><h4>  Fehlertoleranz </h4><br>  Eine Komponente kann von einer anderen Komponente abh√§ngig sein.  Wenn in einem System ein Fehler auftritt, darf das andere Subsystem nicht fallen. <br><br><h4>  Belastbarkeit </h4><br>  T√§glich treten Ausf√§lle einzelner Komponenten auf.  Es ist in Ordnung.  Es ist wichtig, wie schnell wir uns von einem Fehler erholen k√∂nnen. <br><br><h2>  Synchrones Systemausfallszenario </h2><br><h4>  Was ist das? </h4><br>  Der Instinkt eines gro√üen Unternehmens besteht darin, viele Kunden gleichzeitig zu bedienen.  So wie es unm√∂glich ist, f√ºr eine K√ºchenpizzeria zu arbeiten, die wie eine Hausfrau in einer K√ºche zu Hause f√ºr die Lieferung arbeitet, kann ein Code f√ºr die synchrone Ausf√ºhrung f√ºr den Massenkundenservice auf einem Server nicht erfolgreich funktionieren. <br><br>  Es gibt einen grundlegenden Unterschied zwischen der Ausf√ºhrung eines Algorithmus in einer einzelnen Instanz und der Ausf√ºhrung desselben Algorithmus wie ein Server in einem Massendienst. <br><br>  Schauen Sie sich das Bild unten an.  Links sehen wir, wie Anforderungen zwischen zwei Diensten auftreten.  Dies sind RPC-Aufrufe.  Die n√§chste Anfrage endet nach der vorherigen.  Offensichtlich ist dieser Ansatz nicht skalierbar - zus√§tzliche Auftr√§ge stehen an. <br><br>  Um viele Bestellungen bedienen zu k√∂nnen, ben√∂tigen wir die richtige Option: <br><br><img src="https://habrastorage.org/webt/ce/ux/u0/ceuxu0aoqpmcgvnuvj0oboctjdm.png"><br><br>  Der Vorgang des Blockierens von Code in einer synchronen Anwendung wird stark von dem verwendeten Multithreading-Modell beeinflusst, n√§mlich dem pr√§emptiven Multitasking.  Dies allein kann zu Fehlern f√ºhren. <br><br>  Vereinfachtes pr√§ventives Multitasking k√∂nnte wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/webt/k_/i3/pi/k_i3piihcieztws0hjgt-l6jw1q.png"><br><br>  Farbbl√∂cke sind die eigentliche Arbeit, die die CPU leistet, und wir sehen, dass die n√ºtzliche Arbeit, die im Diagramm durch Gr√ºn angezeigt wird, vor dem allgemeinen Hintergrund recht gering ist.  Wir m√ºssen den Fluss wecken, ihn einschl√§fern, und das ist Overhead.  Ein solches Schlafen / Aufwachen tritt w√§hrend der Synchronisation auf irgendwelchen Synchronisationsprimitiven auf. <br><br>  Offensichtlich nimmt die CPU-Leistung ab, wenn Sie die n√ºtzliche Arbeit mit einer gro√üen Anzahl von Synchronisierungen verw√§ssern.  Wie stark kann pr√§ventives Multitasking die Leistung beeinflussen? <br><br>  Betrachten Sie die Ergebnisse eines synthetischen Tests: <br><br><img src="https://habrastorage.org/webt/k5/vo/bh/k5vobhcdjza0tu5-gz5nkmxb2yu.png"><br><br>  Wenn das Flussintervall zwischen den Synchronisationen etwa 1000 Nanosekunden betr√§gt, ist der Wirkungsgrad recht gering, selbst wenn die Anzahl der Threads gleich der Anzahl der Kerne ist.  In diesem Fall betr√§gt der Wirkungsgrad etwa 25%.  Wenn die Anzahl der Threads viermal h√∂her ist, sinkt der Wirkungsgrad dramatisch auf 0,5%. <br><br>  Denken Sie dar√ºber nach, in der Cloud haben Sie eine virtuelle Maschine mit 72 Kernen bestellt.  Es kostet Geld und Sie verwenden weniger als die H√§lfte eines Kerns.  Genau dies kann in einer Multithread-Anwendung passieren. <br><br>  Wenn weniger Aufgaben vorhanden sind, deren Dauer jedoch l√§nger ist, erh√∂ht sich die Effizienz.  Wir sehen, dass bei 5.000 Operationen pro Sekunde in beiden F√§llen der Wirkungsgrad 80-90% betr√§gt.  F√ºr ein Multiprozessorsystem ist dies sehr gut. <br><br><img src="https://habrastorage.org/webt/mk/h0/ku/mkh0kui8a2xqylkxs4obdexrpms.png"><br><br>  In unseren realen Anwendungen liegt die Dauer einer Operation zwischen den Synchronisierungen irgendwo dazwischen, daher ist das Problem dringend. <br><br><h4>  Was ist los? </h4><br>  Achten Sie auf das Ergebnis von Stresstests.  In diesem Fall handelte es sich um das sogenannte "Extrusionstest". <br><br><img src="https://habrastorage.org/webt/bs/cc/pu/bsccpuz17k6921f54mhkjzg3p_k.png"><br><br>  Das Wesentliche des Tests ist, dass wir mit einem Ladest√§nder immer mehr k√ºnstliche Anfragen an das System senden und versuchen, so viele Bestellungen wie m√∂glich pro Minute aufzugeben.  Wir versuchen, das Limit zu finden, nach dem sich die Anwendung weigert, Anfragen zu bearbeiten, die √ºber ihre F√§higkeiten hinausgehen.  Intuitiv erwarten wir, dass das System bis zum Limit l√§uft und zus√§tzliche Anforderungen verwirft.  Genau das w√ºrde zum Beispiel im wirklichen Leben passieren - wenn man in einem Restaurant serviert, das voller Kunden ist.  Aber noch etwas passiert.  Kunden machten mehr Bestellungen und das System begann weniger zu bedienen.  Das System begann so wenige Auftr√§ge zu bedienen, dass es als v√∂lliger Ausfall oder Ausfall angesehen werden kann.  Dies passiert bei vielen Anwendungen, aber sollte es sein? <br><br>  In der zweiten Grafik nimmt die Zeit f√ºr die Verarbeitung einer Anforderung zu, w√§hrend dieses Intervalls werden weniger Anforderungen bedient.  Anfragen, die fr√ºher eingegangen sind, werden viel sp√§ter bearbeitet. <br><br><img src="https://habrastorage.org/webt/au/ho/9y/auho9yjcdbtb8gqqbjytppvyuc0.png"><br><br>  Warum wird die Anwendung gestoppt?  Es gab einen Algorithmus, der funktionierte.  Wir starten es von unserer lokalen Maschine, es funktioniert sehr schnell.  Wir denken, wenn wir eine hundertmal leistungsst√§rkere Maschine nehmen und hundert identische Anforderungen ausf√ºhren, sollten diese gleichzeitig ausgef√ºhrt werden.  Es stellt sich heraus, dass Anforderungen von verschiedenen Clients kollidieren.  Zwischen ihnen kommt es zu Konflikten, und dies ist ein grundlegendes Problem bei verteilten Anwendungen.  Separate Anfragen k√§mpfen um Ressourcen. <br><br><h2>  M√∂glichkeiten, ein Problem zu finden </h2><br>  Wenn der Server nicht funktioniert, werden wir zun√§chst versuchen, die trivialen Probleme von Sperren in der Anwendung, in der Datenbank und w√§hrend der Datei-E / A zu finden und zu beheben.  Es gibt immer noch eine ganze Reihe von Problemen bei der Netzwerkinteraktion, aber bis jetzt werden wir uns auf diese drei beschr√§nken. Dies reicht aus, um zu lernen, √§hnliche Probleme zu erkennen, und wir sind haupts√§chlich an den Problemen interessiert, die Streit verursachen - dem Kampf um Ressourcen. <br><br><h4>  In-Process-Sperren </h4><br>  Hier ist eine typische Anforderung in einer blockierenden Anwendung. <br><img src="https://habrastorage.org/webt/xn/za/vw/xnzavw3w6riwwwnd9tblut9pj0m.png"><br>  Dies ist eine Variation des Sequenzdiagramms, das den Algorithmus f√ºr die Interaktion des Anwendungscodes und der Datenbank als Ergebnis einer bedingten Operation beschreibt.  Wir sehen, dass ein Netzwerkanruf get√§tigt wird, dann passiert etwas in der Datenbank - die Datenbank wird leicht verwendet.  Dann wird eine weitere Anfrage gestellt.  F√ºr den gesamten Zeitraum werden eine Transaktion in der Datenbank und ein Schl√ºssel verwendet, der allen Anforderungen gemeinsam ist.  Es k√∂nnen zwei verschiedene Kunden oder zwei verschiedene Bestellungen sein, aber ein und dasselbe Restaurantmen√ºobjekt, das in derselben Datenbank wie Kundenbestellungen gespeichert ist.  Wir arbeiten aus Gr√ºnden der Konsistenz mit einer Transaktion. Zwei Abfragen haben Konflikte um den Schl√ºssel des gemeinsamen Objekts. <br><br>  Mal sehen, wie es skaliert. <br><img src="https://habrastorage.org/webt/ej/wl/s1/ejwls1dfpfr0hzq-ysxsvakwm9m.png"><br>  Thread schl√§ft die meiste Zeit.  Er tut tats√§chlich nichts.  Wir haben eine Sperre, die andere Prozesse st√∂rt.  Das √Ñrgerlichste ist, dass die am wenigsten n√ºtzliche Operation in einer Transaktion, die einen Schl√ºssel gesperrt hat, ganz am Anfang stattfindet.  Es verl√§ngert die Umfangstransaktionen rechtzeitig. <br><br>  Wir werden auf diese Weise k√§mpfen. <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fallback = FallbackPolicy&lt;OptionalData&gt; .Handle&lt;OperationCancelledException&gt;() .FallbackAsync&lt;OptionalData&gt;(OptionalData.Default); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> optionalDataTask = fallback .ExecuteAsync(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> CalculateOptionalDataAsync()); <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶ var required = await CalculateRequiredData(); var optional = await optionalDataTask; var price = CalculatePriceAsync(optional, required);</span></span></code> </pre> <br>  Dies ist eventuelle Konsistenz.  Wir gehen davon aus, dass einige unserer Daten m√∂glicherweise weniger aktuell sind.  Dazu m√ºssen wir anders mit dem Code arbeiten.  Wir m√ºssen akzeptieren, dass die Daten von anderer Qualit√§t sind.  Wir werden uns nicht ansehen, was vorher passiert ist - der Manager hat etwas im Men√º ge√§ndert oder der Kunde hat auf die Schaltfl√§che "Kasse" geklickt.  F√ºr uns spielt es keine Rolle, welcher von ihnen zwei Sekunden zuvor den Knopf gedr√ºckt hat.  Und f√ºr das Gesch√§ft gibt es keinen Unterschied. <br><br>  Es gibt keinen Unterschied, wir k√∂nnen so etwas tun.  Nennen Sie es bedingt optionalData.  Das hei√üt, ein Wert, auf den wir verzichten k√∂nnen.  Wir haben einen Fallback - den Wert, den wir aus dem Cache nehmen oder einen Standardwert √ºbergeben.  Und f√ºr die wichtigste Operation (die erforderliche Variable) werden wir warten.  Wir werden fest auf ihn warten und erst dann auf eine Antwort auf Anfragen nach optionalen Daten warten.  Dadurch k√∂nnen wir die Arbeit beschleunigen.  Es gibt noch einen weiteren wichtigen Punkt: Dieser Vorgang wird aus irgendeinem Grund m√∂glicherweise √ºberhaupt nicht ausgef√ºhrt.  Angenommen, der Code f√ºr diese Operation ist nicht optimal, und im Moment liegt ein Fehler vor.  Wenn der Vorgang fehlgeschlagen ist, f√ºhren Sie einen Fallback durch.  Und dann arbeiten wir damit wie mit der √ºblichen Bedeutung. <br><br><h4>  DB-Sperren </h4><br>  Wir erhalten ungef√§hr das gleiche Layout, wenn wir asynchron umschreiben und das Konsistenzmodell √§ndern. <br><img src="https://habrastorage.org/webt/aw/lq/xv/awlqxvspzylkqut1gklosn6pooi.png"><br>  Was hier z√§hlt, ist nicht, dass die Anfrage mit der Zeit schneller geworden ist.  Wichtig ist, dass wir keinen Streit haben.  Wenn wir Anfragen hinzuf√ºgen, ist nur die linke Seite des Bildes mit uns ges√§ttigt. <br><img src="https://habrastorage.org/webt/_y/to/gz/_ytogzwl2pvkvzuxjy6mt365xnm.png"><br><br>  Dies ist eine Blockierungsanforderung.  Hier √ºberlappen sich die Threads und die Schl√ºssel, auf denen Konflikte auftreten.  Rechts haben wir √ºberhaupt keine Transaktionen in der Datenbank und sie werden leise ausgef√ºhrt.  Der richtige Fall kann in diesem Modus unbegrenzt funktionieren.  Links f√ºhrt zum Absturz des Servers. <br><br><h4>  Synchronisieren Sie io </h4><br>  Manchmal brauchen wir Dateiprotokolle.  √úberraschenderweise kann das Protokollierungssystem solche unangenehmen Fehler verursachen.  Latenz auf der Festplatte in Azure - 5 Millisekunden.  Wenn wir eine Datei hintereinander schreiben, sind es nur 200 Anfragen pro Sekunde.  Das war's, die Anwendung wurde gestoppt. <br><img src="https://habrastorage.org/webt/4f/ye/oz/4fyeozpwhurta8vmpo6qelgvot4.png"><br><br>  Es ist nur so, dass Ihre Haare zu Berge stehen, wenn Sie dies sehen - mehr als 2000 F√§den wurden in der Anwendung gez√ºchtet.  78% aller Threads sind der gleiche Aufrufstapel.  Sie hielten an derselben Stelle an und versuchen, den Monitor zu betreten.  Dieser Monitor begrenzt den Zugriff auf die Datei, in der wir alle protokollieren.  Nat√ºrlich muss dies geschnitten werden. <br><img src="https://habrastorage.org/webt/ga/7f/27/ga7f27rhtreou-lssvsrcfjcvzo.png"><br>  Folgendes m√ºssen Sie in NLog tun, um es zu konfigurieren.  Wir machen ein asynchrones Ziel und schreiben darauf.  Und asynchrones Ziel schreibt in die reale Datei.  Nat√ºrlich k√∂nnen wir eine bestimmte Anzahl von Nachrichten im Protokoll verlieren, aber was ist f√ºr das Gesch√§ft wichtiger?  Als das System 10 Minuten lang ausfiel, verloren wir eine Million Rubel.  Es ist wahrscheinlich besser, mehrere Nachrichten im Dienstprotokoll zu verlieren, die fehlgeschlagen sind und neu gestartet wurden. <br><br><h2>  Alles ist sehr schlecht </h2><br>  In Multithread-Anwendungen ist der Konflikt ein gro√ües Problem, sodass Sie eine Single-Thread-Anwendung nicht einfach skalieren k√∂nnen.  Streitquellen m√ºssen identifizieren und beseitigen k√∂nnen.  Eine gro√üe Anzahl von Threads ist f√ºr Anwendungen katastrophal, und blockierende Aufrufe m√ºssen asynchron umgeschrieben werden. <br><br>  Ich musste viel Verm√§chtnis umschreiben, indem ich asynchrone Anrufe blockierte. Ich selbst habe oft ein solches Upgrade initiiert.  Sehr oft kommt jemand und fragt: "H√∂ren Sie, wir schreiben jetzt seit zwei Wochen um, fast alle asynchron.  Und wie viel wird es schneller funktionieren? "  Leute, ich werde dich ver√§rgern - es wird nicht schneller funktionieren.  Es wird noch langsamer.  Schlie√ülich ist TPL ein Wettbewerbsmodell √ºber dem anderen - kooperatives Multitasking gegen√ºber pr√§emptivem Multitasking, und dies ist ein Overhead.  In einem unserer Projekte - ca. + 5% auf die CPU-Auslastung und die Auslastung von GC. <br><br>  Es gibt noch eine weitere schlechte Nachricht: Die Anwendung kann nach dem Umschreiben in Async viel schlechter funktionieren, ohne die Funktionen des Wettbewerbsmodells zu kennen.  Ich werde im n√§chsten Artikel ausf√ºhrlich auf diese Funktionen eingehen. <br><br>  Dies wirft die Frage auf - ist es notwendig, neu zu schreiben? <br><br>  Der synchrone Code wird asynchron umgeschrieben, um das Parallelit√§tsmodell zu entsperren und das pr√§emptive Multitasking-Modell zu entfernen.  Wir haben festgestellt, dass die Anzahl der Threads die Leistung beeintr√§chtigen kann. Sie m√ºssen sich also von der Notwendigkeit befreien, die Anzahl der Threads zu erh√∂hen, um die Parallelit√§t zu erh√∂hen.  Auch wenn wir Legacy haben und diesen Code nicht neu schreiben m√∂chten, ist dies der Hauptgrund, ihn neu zu schreiben. <br><br>  Die gute Nachricht am Ende ist, dass wir jetzt etwas dar√ºber wissen, wie wir die trivialen Probleme von Contention of Blocking Code beseitigen k√∂nnen.  Wenn Sie solche Probleme in Ihrer blockierenden Anwendung finden, ist es Zeit, sie zu beseitigen, bevor Sie sie in asynchron umschreiben, da sie dort nicht von selbst verschwinden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440676/">https://habr.com/ru/post/de440676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440662/index.html">React Tutorial Teil 18: Die sechste Phase der Arbeit an einer TODO-Anwendung</a></li>
<li><a href="../de440666/index.html">Klassifizierung handschriftlicher Zeichnungen. Bericht in Yandex</a></li>
<li><a href="../de440670/index.html">Die Zentralbank ver√∂ffentlichte Empfehlungen zum kryptografischen Schutz von EBS</a></li>
<li><a href="../de440672/index.html">Methoden der Rationalit√§t und das Maghreb-Gebet Mat</a></li>
<li><a href="../de440674/index.html">Verwenden von Streudiagrammen zur Visualisierung von Daten</a></li>
<li><a href="../de440678/index.html">DIY Hobby CNC Fr√§ser. Geisteswissenschaften f√ºr die Geisteswissenschaften. Teil 2</a></li>
<li><a href="../de440680/index.html">Wie man morgen igrofikuyuchi sieht</a></li>
<li><a href="../de440682/index.html">- Und Sie machen dort in der petrochemischen Industrie Gas, oder?</a></li>
<li><a href="../de440688/index.html">PR in der IT: Wie leben, wohin?</a></li>
<li><a href="../de440690/index.html">Funktionen zum Arbeiten mit Mesh in Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>