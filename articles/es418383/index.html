<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✏️ 👹 🚺 Animaciones de Android basadas en Kotlin y RxJava 👖 🧑🏿 💚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! El año pasado, Ivan Škorić de PSPDFKit habló en MBLT DEV con un informe sobre la creación de animaciones en Android basado en Kotlin y la b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Animaciones de Android basadas en Kotlin y RxJava</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/418383/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/2g/5z/pi/2g5zpitzszs5lxzgdighjoo14u4.png"></a> <br><br>  Hola Habr!  El año pasado, Ivan Škorić de PSPDFKit habló en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MBLT DEV</a> con un informe sobre la creación de animaciones en Android basado en Kotlin y la biblioteca RxJava. <br><br>  Ahora uso las técnicas del informe para trabajar en mi proyecto, me ayudan mucho.  Debajo de la escena se encuentra la transcripción del informe y el video, ahora puede aprovechar estos trucos. <a name="habracut"></a><br><br><h2>  Animación </h2><br>  En Android, hay 4 clases que se aplican como si por defecto: <br><br><ol><li>  <b>ValueAnimator</b> : esta clase proporciona un mecanismo de sincronización simple para ejecutar animaciones que calculan valores animados y los configuran para la Vista. </li><li>  <b>ObjectAnimator</b> es una subclase de ValueAnimator que le permite admitir animaciones para propiedades de objeto. </li><li>  <b>AnimatorSet</b> se usa para crear una secuencia de animación.  Por ejemplo, tiene una secuencia de animaciones: <br><br><ol><li>  Ver hojas a la izquierda de la pantalla. </li><li>  Después de completar la primera animación, queremos realizar una animación de apariencia para otra Vista, etc. </li></ol></li><li>  <b>ViewPropertyAnimator</b> : inicia y optimiza automáticamente las animaciones para la propiedad de vista seleccionada.  Lo usaremos principalmente.  Por lo tanto, utilizaremos esta API y luego la pondremos en RxJava como parte de la programación reactiva. </li></ol><br><cut></cut><br><h3>  ValueAnimator </h3><br>  Analicemos <b>el</b> marco <b>ValueAnimator</b> .  Se usa para cambiar el valor.  Puede especificar un rango de valores a través de <b>ValueAnimator.ofFloat</b> para el tipo flotante primitivo de 0 a 100. Especifique un valor de <b>Duración</b> e inicie la animación. <br>  Considere un ejemplo: <br><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animator = ValueAnimator.ofFloat(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">100f</span></span>) animator.duration = <span class="hljs-number"><span class="hljs-number">1000</span></span> animator.start() animator.addUpdateListener(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ValueAnimator.AnimatorUpdateListener { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ValueAnimator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animatedValue = animation.animatedValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> textView.translationX = animatedValue } })</code> </pre> <br>  Aquí agregamos <b>UpdateListener</b> y con cada actualización moveremos nuestra Vista horizontalmente y cambiaremos su posición de 0 a 100, aunque esta no es una muy buena manera de realizar esta operación. <br><br><h3>  ObjectAnimator </h3><br>  Otro ejemplo de implementación de animación es ObjectAnimator: <br><br><pre> <code class="hljs pgsql">val objectAnimator = ObjectAnimator.ofFloat(textView, "translationX", <span class="hljs-number"><span class="hljs-number">100</span></span>f) objectAnimator.duration = <span class="hljs-number"><span class="hljs-number">1000</span></span> objectAnimator.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>()</code> </pre> <br>  Le damos un comando para cambiar el parámetro de Vista específico al valor especificado a la Vista deseada y establecer la hora usando el método <b>setDuration</b> .  La conclusión es que su clase debe tener el método <b>setTranslationX</b> , luego el sistema encontrará este método a través de la reflexión, y luego la Vista se animará.  El problema es que aquí se usa la reflexión. <br><br><h3>  Animatorset </h3><br>  Ahora considere la clase <b>AnimatorSet</b> : <br><br><pre> <code class="hljs pgsql">val bouncer = AnimatorSet() bouncer.play(bounceAnim).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(squashAnim1) bouncer.play(squashAnim1).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(squashAnim2) val fadeAnim = ObjectAnimator.ofFloat(newBall, "alpha", <span class="hljs-number"><span class="hljs-number">1</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>f) fadeAnim.duration = <span class="hljs-number"><span class="hljs-number">250</span></span> val animatorSet = AnimatorSet() animatorSet.play(bouncer).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(fadeAnim) animatorSet.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>()</code> </pre> <br>  De hecho, no es muy conveniente de usar, especialmente para una gran cantidad de objetos.  Si desea realizar animaciones más complejas, por ejemplo, establezca un retraso entre la aparición de las animaciones y cuantas más animaciones desee realizar, más difícil será controlarla. <br><br><h3>  ViewPropertyAnimator </h3><br>  La clase final es <b>ViewPropertyAnimator</b> .  Es una de las mejores clases para animar View.  Esta es una gran API para presentar una secuencia de animaciones que ejecuta: <br><br><pre> <code class="hljs kotlin">ViewCompat.animate(textView) .translationX(<span class="hljs-number"><span class="hljs-number">50f</span></span>) .translationY(<span class="hljs-number"><span class="hljs-number">100f</span></span>) .setDuration(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .setInterpolator(AccelerateDecelerateInterpolator()) .setStartDelay(<span class="hljs-number"><span class="hljs-number">50</span></span>) .setListener(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : Animator.AnimatorListener { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationRepeat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationCancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} })</code> </pre><br>  Iniciamos el método <b>ViewCompat.animate</b> , que devuelve <b>ViewPropertyAnimator</b> , y para la <b>traducción de</b> animación <b>X</b> establecemos el valor en 50, para el parámetro <b>translatonY</b> en 100. Luego especificamos la duración de la animación, así como el interpolador.  El interpolador determina la secuencia en la que aparecen las animaciones.  Este ejemplo utiliza un interpolador que acelera el inicio de la animación y agrega una desaceleración al final.  También agregamos un retraso para comenzar la animación.  Además, tenemos un <b>AnimatorListener</b> .  Con él, puede suscribirse a ciertos eventos que ocurren durante la animación.  Esta interfaz tiene 4 métodos: <b>onAnimationStart</b> , <b>onAnimationCancel</b> , <b>onAnimationEnd</b> , <b>onAnimationRepeat</b> . <br><br>  Como regla, solo estamos interesados ​​en completar la animación.  En API Nivel 16 <br>  agregado con EndAction: <br><br><pre> <code class="hljs pgsql">.withEndAction({ //API <span class="hljs-number"><span class="hljs-number">16</span></span>+ //<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something here <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> animation ends })</code> </pre> <br>  En él, puede definir la interfaz <b>Runnable</b> , y después de completar la visualización de una animación específica, se realiza una acción. <br><br>  Ahora algunos comentarios sobre el proceso de creación de animaciones en general: <br><br><ol><li>  El método <b>start ()</b> es opcional: tan pronto como llame al método <b>animate ()</b> , se introduce una secuencia de animaciones.  Cuando se configura <b>ViewPropertyAnimator</b> , el sistema comenzará la animación tan pronto como esté listo para hacerlo. </li><li>  Solo una clase <b>ViewPropertyAnimator</b> puede animar solo una vista específica.  Por lo tanto, si desea realizar varias animaciones, por ejemplo, desea que algo se mueva y, al mismo tiempo, aumente de tamaño, debe especificar esto en un animador. </li></ol><br><h3>  ¿Por qué elegimos RxJava? </h3><br>  Comencemos con un ejemplo simple.  Supongamos que creamos un método fadeIn: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animationSubject = CompletableSubject.create() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> animationSubject.doOnSubscribe { ViewCompat.animate(view) .setDuration(duration) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .withEndAction { animationSubject.onComplete() } } }</code> </pre> <br>  Esta es una solución bastante primitiva, y para aplicarla a su proyecto, deberá tener en cuenta algunos matices. <br><br>  Vamos a crear un <b>CompletableSubject</b> , que usaremos para esperar a que se completen las animaciones, y luego usaremos el método <b>onComplete</b> para enviar mensajes a los suscriptores.  Para ejecutar animaciones secuencialmente, debe iniciar la animación no inmediatamente, sino tan pronto como alguien se suscriba a ella.  De esta forma, se pueden ejecutar varias animaciones de estilo reactivo de forma secuencial. <br><br>  Considera la animación en sí.  En él, transferimos la Vista, sobre la cual se realizará la animación, y también indicamos la duración de la animación.  Y dado que esta animación es apariencia, debemos indicar la transparencia 1. <br><br>  Tratemos de usar nuestro método y creemos una animación simple.  Supongamos que tenemos 4 botones en la pantalla, y queremos agregarles una animación de la aparición de 1 segundo de duración: <br><br><pre> <code class="hljs go">val durationMs = <span class="hljs-number"><span class="hljs-number">1000</span></span>L button1.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button2.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button3.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button4.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> fadeIn(button1, durationMs) .andThen(fadeIn(button2, durationMs)) .andThen(fadeIn(button3, durationMs)) .andThen(fadeIn(button4, durationMs)) .subscribe()</code> </pre><br>  El resultado es un código tan conciso.  Usando el operador <b>andThen</b> , puede ejecutar animaciones secuencialmente.  Cuando nos suscribamos, enviará el evento <b>doOnSubscribe</b> a <b>Completable</b> , que es el primero en la cola de ejecución.  Después de su finalización, se suscribirá a la segunda, tercera y así sucesivamente en la cadena.  Por lo tanto, si se produce un error en algún momento, la secuencia completa arroja un error.  También debe especificar alfa 0 antes del inicio de la animación para que los botones sean invisibles.  Y así es como se verá: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sq/-m/02/sq-m02uv2i1uu85udver9fwzqww.gif"></div><br>  Usando <b>Kotlin</b> , podemos usar las extensiones: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animationSubject = CompletableSubject.create() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> animationSubject.doOnSubscribe { ViewCompat.animate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setDuration(duration) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .withEndAction { animationSubject.onComplete() } } }</code> </pre> <br>  Para la clase View, se agregó una función de extensión.  En el futuro, no es necesario pasar el argumento View al método fadeIn.  Ahora puede reemplazar todas las llamadas a Ver con esta palabra clave dentro del método.  Esto es lo que <b>Kotlin</b> es capaz de hacer <b>.</b> <br><br>  Veamos cómo ha cambiado la llamada a esta función en nuestra cadena de animación: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre><br>  Ahora el código se ve más comprensible.  Establece claramente que queremos aplicar animación con una cierta duración a la visualización deseada.  Usando el operador <b>andThen</b> , creamos una cadena secuencial de animaciones para el segundo, tercer botón, y así sucesivamente. <br><br>  Siempre indicamos la duración de las animaciones, este valor es el mismo para todas las pantallas: 1000 milisegundos.  <b>Kotlin</b> viene al rescate nuevamente.  Podemos hacer un valor de tiempo predeterminado. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">L)</span></span></span></span>:</code> </pre> <br>  Si no especifica el parámetro de <b>duración</b> , el tiempo se establecerá automáticamente en 1 segundo.  Pero si queremos que el botón en el número 2 aumente este tiempo a 2 segundos, simplemente especificamos este valor en el método: <br><br><pre> <code class="hljs erlang">button1.fadeIn() .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button2.fadeIn(duration = <span class="hljs-number"><span class="hljs-number">2000</span></span>L)) .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button3.fadeIn()) .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button4.fadeIn()) .subscribe()</code> </pre><br><h3>  Ejecutando dos animaciones </h3><br>  Pudimos ejecutar una secuencia de animaciones usando el operador <b>andThen</b> .  ¿Qué sucede si necesito ejecutar 2 animaciones al mismo tiempo?  Para hacer esto, hay un operador <b>mergeWith</b> en <b>RxJava</b> que le permite combinar elementos <b>Completables</b> de tal manera que se <b>inicien</b> simultáneamente.  Esta declaración inicia todos los elementos y termina después de que se muestra el último elemento.  Si cambiamos y <b>luego</b> <b>fusionamos con</b> , obtenemos una animación en la que todos los botones aparecen al mismo tiempo, pero el botón 2 aparecerá un poco más que los demás: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(2000)) <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/fw/xb/jdfwxbgedu3gnufrsrfqezc46ga.gif"></div><br>  Ahora podemos agrupar animaciones.  Intentemos complicar la tarea: por ejemplo, queremos que el botón 1 y el botón 2 aparezcan al mismo tiempo, y luego el botón 3 y el botón 4: <br><br><pre> <code class="hljs css">(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>())) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>())) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre> <br>  Combinamos los botones primero y segundo con el operador <b>mergeWith</b> , repetimos la acción para el tercero y cuarto, y comenzamos estos grupos secuencialmente con el operador <b>andThen</b> .  Ahora mejoraremos el código agregando el método <b>fadeInTogether</b> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeInTogether</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first.fadeIn() .mergeWith(second.fadeIn()) }</code> </pre> <br>  Le permitirá ejecutar la animación de fadeIn para dos vistas al mismo tiempo.  Cómo ha cambiado la cadena de animación: <br><br><pre> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeInTogether</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(button1, button2)</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">andThen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fadeInTogether(button3, button4))</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  El resultado es la siguiente animación: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hk/xw/pe/hkxwpemdtbmksyv_r7mq2qx3bcw.gif"></div><br>  Considere un ejemplo más complejo.  Supongamos que necesitamos mostrar una animación con cierto retraso.  La declaración de <b>intervalo</b> ayudará: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> timeObservable = Observable.interval(<span class="hljs-number"><span class="hljs-number">100</span></span>, TimeUnit.MILLISECONDS) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> btnObservable = Observable.just(button1, button2, button3, button4) }</code> </pre> <br>  Generará valores cada 100 milisegundos.  Cada botón aparecerá después de 100 milisegundos.  A continuación, indicamos otro Observable que emitirá botones.  En este caso, tenemos 4 botones.  Usamos el operador <b>zip</b> . <br><br><img src="https://habrastorage.org/webt/g5/qq/yi/g5qqyih178patmj5cjpfyoevkkw.png" alt="imagen"><br><br>  Ante nosotros están las corrientes de eventos: <br><br><pre> <code class="hljs mel">Observable.zip(timeObservable, btnObservable, BiFunction&lt;Long, View, Disposable&gt; { _, <span class="hljs-keyword"><span class="hljs-keyword">button</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">button</span></span>.fadeIn().subscribe() })</code> </pre> <br>  El primero corresponde a <b>timeObservable</b> .  Este <b>observable</b> generará números a intervalos regulares.  Supongamos que serán 100 milisegundos. <br><br>  El segundo <b>observable</b> generará una vista.  El operador <b>zip</b> espera hasta que el primer objeto aparezca en el primer hilo y lo conecta con el primer objeto del segundo hilo.  A pesar de que todos estos 4 objetos en el segundo hilo aparecerán inmediatamente, él esperará hasta que los objetos comiencen a aparecer en el primer hilo.  Por lo tanto, el primer objeto de la primera secuencia se conectará al primer objeto del segundo en la forma de nuestra vista, y 100 milisegundos después, cuando aparezca un nuevo objeto, el operador lo combinará con el segundo objeto.  Por lo tanto, la vista aparecerá con cierto retraso. <br><br>  Tratemos con <b>BiFinction</b> en <b>RxJava</b> .  Esta función recibe dos objetos como entrada, realiza algunas operaciones en ellos y devuelve un tercer objeto.  Queremos tomar tiempo y ver objetos y obtener <b>Desechables</b> debido al hecho de que llamamos a la animación <b>fadeIn</b> y nos suscribimos para <b>suscribirnos</b> .  El valor del tiempo no es importante para nosotros.  Como resultado, obtenemos esta animación: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8q/wa/1z/8qwa1z75xolp2jb-hsznqzncykw.gif"></div><br><h3>  Vanogogh </h3><br>  Te contaré sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto</a> que Ivan comenzó a desarrollar para MBLT DEV 2017. <br><br>  La biblioteca desarrollada por Ivan presenta varios proyectiles para animaciones.  Ya hemos considerado esto arriba.  También contiene animaciones listas para usar que puede usar.  Obtiene un conjunto generalizado de herramientas para crear sus propias animaciones.  Esta biblioteca le proporcionará componentes más potentes para la programación reactiva. <br><br>  Considere la biblioteca usando un ejemplo: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : AnimationCompletable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnimationBuilder.forView(view) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .duration(<span class="hljs-number"><span class="hljs-number">2000L</span></span>) .build().toCompletable() }</code> </pre> <br>  Suponga que desea crear una animación que aparece, pero esta vez aparece un <b>AnimationCompletable en</b> lugar del objeto <b>Completable</b> .  Esta clase hereda de <b>Completable</b> , por lo que ahora aparecen más funciones.  Una característica importante del código anterior era que era imposible cancelar animaciones.  Ahora puede crear un objeto <b>AnimationCompletable</b> que haga que la animación se detenga tan pronto como nos demos de baja. <br><br>  Cree una animación emergente utilizando <b>AnimationBuilder</b> , una de las clases de la biblioteca.  Especifique a qué Vista se aplicará la animación.  En esencia, esta clase copia el comportamiento de <b>ViewPropertyAnimator</b> , pero con la diferencia de que la salida es una secuencia. <br><br>  A continuación, configure alfa 1f y la duración es de 2 segundos.  Luego recogemos la animación.  Tan pronto como <b>invoquemos la</b> declaración de <b>compilación</b> , aparece la animación.  Asignamos animaciones a la propiedad de un objeto inmutable, por lo que guardará estas características para su lanzamiento.  Pero la animación en sí no comenzará. <br><br>  Llama a <b>toCompletable</b> , que creará un <b>AnimationCompletable</b> .  Envolverá los parámetros de esta animación en una especie de shell para la programación reactiva, y tan pronto como se suscriba, comenzará la animación.  Si lo apaga antes de que se complete el proceso, la animación finalizará.  Ahora también puede agregar una función de devolución de llamada.  Puede escribir los operadores <b>doOnAnimationReady</b> , <b>doOnAnimationStart</b> , <b>doOnAnimationEnd</b> y similares: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : AnimationCompletable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnimationBuilder.forView(view) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .duration(<span class="hljs-number"><span class="hljs-number">2000L</span></span>) .buildCompletable() .doOnAnimationReady { view.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> } }</code> </pre> <br>  En este ejemplo, mostramos lo conveniente que es usar <b>AnimationBuilder</b> y cambiamos el estado de nuestra Vista antes de comenzar la animación. <br><br><h3>  Informar video </h3><br>  Analizamos una de las opciones para crear, componer y ajustar animaciones usando Kotlin y RxJava.  Aquí hay un enlace a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto</a> que describe animaciones básicas y ejemplos para ellos, así como los shells principales para trabajar con animaciones. <br><br>  Además del descifrado, comparto un video del informe: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Yv80bdUnJgw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Altavoces MBLT DEV 2018 </h3><br>  Antes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MBLT DEV 2018</a> , quedan poco más de dos meses.  Tendremos las siguientes actuaciones: <br><br><ul><li>  Laura Morinigo, experta en desarrolladores de Google </li><li>  Kaushik Gopal, autor del podcast fragmentado </li><li>  Artyom Rudoi, Badoo </li><li>  Dina Sidorova, Google y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otros</a> . </li></ul><br>  Mañana el precio del boleto cambiará.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Regístrese</a> hoy </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418383/">https://habr.com/ru/post/es418383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418371/index.html">Microtask para programadores y un método alternativo de pago de criptomonedas</a></li>
<li><a href="../es418375/index.html">Descripción general de la impresora fotográfica Uniz Slash + 3D</a></li>
<li><a href="../es418377/index.html">Kotlin: dos cucharadas de alquitrán en un barril de miel</a></li>
<li><a href="../es418379/index.html">Prótesis bioeléctrica infantil. Parte 2</a></li>
<li><a href="../es418381/index.html">Novedades de DevTools en Chrome Versión 68</a></li>
<li><a href="../es418385/index.html">Cómo ensamblé una computadora para juegos antiguos</a></li>
<li><a href="../es418387/index.html">Diálogo físico sobre el alma.</a></li>
<li><a href="../es418389/index.html">RabbitMQ vs. Kafka: uso de Kafka en aplicaciones orientadas a eventos</a></li>
<li><a href="../es418391/index.html">OSPF (primera parte)</a></li>
<li><a href="../es418393/index.html">[Viernes] Cómo vimos Web 3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>