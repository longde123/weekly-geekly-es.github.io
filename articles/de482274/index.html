<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéí üë©üèº‚Äçüî¨ üíª 5 Gr√ºnde, warum Sie die Verwendung von System.Drawing in ASP.NET einstellen sollten üîï üë∞üèº üíÖüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr Ich pr√§sentiere Ihnen die √úbersetzung des Artikels ‚Äû5 Gr√ºnde, warum Sie die Verwendung von System.Drawing aus ASP.NET beenden sollten‚Äú . 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 Gr√ºnde, warum Sie die Verwendung von System.Drawing in ASP.NET einstellen sollten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482274/"> Hallo habr  Ich pr√§sentiere Ihnen die √úbersetzung des Artikels <a href="https://photosauce.net/blog/post/5-reasons-you-should-stop-using-systemdrawing-from-aspnet" rel="nofollow">‚Äû5 Gr√ºnde, warum Sie die Verwendung von System.Drawing aus ASP.NET beenden sollten‚Äú</a> . <br><br><img src="https://habrastorage.org/webt/cz/ak/-m/czak-mp2zhhou0aufqy5s4p8z4c.png" alt="Bild"><br><br>  Nun, sie haben es geschafft.  Das corefx-Team stimmte schlie√ülich <a href="https://github.com/dotnet/corefx/search%3Fq%3Dsystem.drawing%26type%3DIssues" rel="nofollow">zahlreichen Anfragen zu</a> und nahm System.Drawing in .NET Core auf. <a name="habracut"></a>  (Originalartikel vom Juli 2017) <br><br>  Das <a href="https://github.com/dotnet/corefx/pull/20593" rel="nofollow">kommende System.Drawing.Common-</a> Paket enth√§lt den gr√∂√üten Teil der System.Drawing-Funktionalit√§t von .NET Framework und ist als Kompatibilit√§tsoption f√ºr Benutzer gedacht, die auf .NET Core migrieren m√∂chten, dies jedoch aufgrund von Abh√§ngigkeiten nicht k√∂nnen.  Aus dieser Sicht macht Microsoft das Richtige.  Die Reibung muss verringert werden, da die Einf√ºhrung von .Net Core ein lohnenderes Ziel ist. <br><br>  Andererseits ist System.Drawing einer der √§rmsten und am st√§rksten benachteiligten Bereiche des .Net Frameworks, und viele von uns hofften, dass die Implementierung von .NET Core den langsamen Tod von System.Drawing bedeuten w√ºrde.  Und zusammen mit diesem Tod sollte sich eine Gelegenheit bieten, etwas Besseres zu tun. <br><br>  Das Mono-Team hat beispielsweise einen .NET-kompatiblen Wrapper f√ºr Googles plattform√ºbergreifende <a href="https://skia.org/" rel="nofollow">Skia-</a> Grafikbibliothek namens <a href="https://github.com/mono/SkiaSharp" rel="nofollow">SkiaSharp erstellt</a> .  Um die Installation zu vereinfachen, hat Nuget bei der Unterst√ºtzung nativer Bibliotheken f√ºr jede Plattform einen langen Weg zur√ºckgelegt.  Skia ist ziemlich voll ausgestattet und seine Leistung macht System.Drawing. <br><br>  Das <a href="https://github.com/JimBobSquarePants/ImageSharp" rel="nofollow">ImageSharp-</a> Team hat auch gro√üartige Arbeit geleistet und einen Gro√üteil der System.Drawing-Funktionalit√§t wiederholt, jedoch mit der besten API und 100% C # -Implementierung.  Sie sind immer noch nicht f√ºr eine produktive Nutzung bereit, aber es scheint, dass sie bereits nahe genug daran sind.  Eine kleine Warnung zu dieser Bibliothek, da es sich um die Verwendung in Serveranwendungen handelt: In der Standardkonfiguration wird jetzt Parallel.For verwendet, um einige Vorg√§nge zu beschleunigen. Dies bedeutet, dass m√∂glicherweise mehr Workflows aus dem ASP.NET-Pool verwendet werden Dies f√ºhrt zu einer <a href="https://www.hanselman.com/blog/BackToParallelBasicsDontBlockYourThreadsMakeAsyncIOWorkForYou.aspx" rel="nofollow">Reduzierung des Gesamtdurchsatzes der Anwendung</a> .  Ich hoffe, dass dieses Verhalten vor der Ver√∂ffentlichung √ºberpr√ºft wird, aber selbst jetzt reicht es aus, eine Zeile der Konfiguration zu √§ndern, um sie f√ºr die Verwendung auf dem Server besser geeignet zu machen. <br><br>  In jedem Fall sollten Sie beim Zeichnen, Plotten oder Rendern von Text in Bildern in einer Anwendung auf dem Server ernsthaft in Betracht ziehen, System.Drawing auf irgendetwas zu √§ndern, unabh√§ngig davon, ob Sie zu .NET Core wechseln oder nicht. <br><br>  Ich f√ºr meinen Teil habe eine leistungsstarke Bildverarbeitungs-Pipeline f√ºr .NET und .NET Core zusammengestellt, die eine Bildqualit√§t bietet, die System.Drawing nicht bieten kann, und zwar in einer hochskalierbaren Architektur, die speziell f√ºr die Verwendung auf dem Server entwickelt wurde.  Bisher ist es nur f√ºr Windows, jedoch plattform√ºbergreifend geplant.  Wenn Sie System.Drawing (oder etwas anderes) verwenden, um die Gr√∂√üe von Bildern auf dem Server zu √§ndern, sollten Sie <a href="https://github.com/saucecontrol/PhotoSauce" rel="nofollow">MagicScaler</a> als Ersatz in Betracht <a href="https://github.com/saucecontrol/PhotoSauce" rel="nofollow">ziehen</a> . <br><br>  Aber eine System.Drawing-Wiederbelebung, die einigen Entwicklern den √úbergang erleichtert, wird wahrscheinlich den gr√∂√üten Teil der Dynamik dieser Projekte zunichte machen, da Entwickler gezwungen waren, nach Alternativen zu suchen.  Leider werden im .NET-√ñkosystem Microsoft-Bibliotheken und -Pakete immer gewinnen, egal wie √ºberlegen die Alternativen sein k√∂nnen. <br><br>  Dieser Beitrag ist ein Versuch, einige System.Drawing-Fehler zu beheben, in der Hoffnung, dass Entwickler Alternativen untersuchen, auch wenn System.Drawing eine Option bleibt. <br><br>  Ich beginne mit dem h√§ufig zitierten <a href="https://msdn.microsoft.com/en-us/library/system.drawing.aspx" rel="nofollow">Haftungsausschluss aus der</a> System.Drawing-Dokumentation.  Diese Ablehnung wurde einige Male in einer <a href="https://github.com/dotnet/corefx/issues/20325" rel="nofollow">Diskussion √ºber Github im Zusammenhang mit System.Drawing.Common angesprochen</a> . <br><blockquote>  ‚ÄûKlassen mit dem System.Drawing-Namespace werden f√ºr die Verwendung in Windows- oder ASP.NET-Diensten nicht unterst√ºtzt.  Der Versuch, diese Klassen mit diesen Arten von Anwendungen zu verwenden, kann zu unerwarteten Problemen f√ºhren, wie z. B. einer verringerten Serverleistung und Laufzeitfehlern. " </blockquote><br>  Wie viele von Ihnen habe ich diesen Haftungsausschluss vor sehr langer Zeit gelesen, ihn dann √ºbersprungen und in meiner ASP.NET-Anwendung immer noch System.Drawing verwendet.  Warum?  Weil ich Gefahr liebe.  Entweder das, oder es wurden keine anderen realisierbaren Optionen gefunden.  Und wei√üt du was?  Es ist nichts Schlimmes passiert.  H√∂chstwahrscheinlich h√§tte ich das nicht sagen sollen, aber ich wette, dass viele von Ihnen das Gleiche erlebt haben.  Warum also nicht weiterhin System.Drawing oder darauf basierende Bibliotheken verwenden? <br><br><h3>  Grund 1: GDI-Deskriptoren </h3><br>  Wenn bei der Verwendung von System.Drawing auf einem Server jemals Probleme aufgetreten sind, ist dies h√∂chstwahrscheinlich der Fall.  Wenn dies nicht getestet wird, ist dies eine der wahrscheinlichsten Ursachen. <br><br>  System.Drawing ist gr√∂√ütenteils ein d√ºnner Wrapper um die Windows GDI + -API.  Viele System.Drawing-Objekte werden von <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724291(v%3Dvs.85).aspx" rel="nofollow">GDI-Deskriptoren</a> unterst√ºtzt und haben ein quantitatives Limit f√ºr den Prozessor und die Benutzersitzung.  Wenn dieser Schwellenwert erreicht ist, wird die Ausnahme "Nicht gen√ºgend Speicher" und / oder der allgemeine GDI + -Fehler angezeigt. <br><br>  Das Problem ist, dass in .NET die Garbage Collection und die Prozessbeendigung die Freigabe dieser Deskriptoren um den Zeitpunkt verz√∂gern k√∂nnen, an dem Sie das Limit erreichen, selbst unter geringer Last.  Wenn Sie vergessen haben (oder nicht wissen, was Sie brauchen), um Dispose () f√ºr ein Objekt aufzurufen, das solche Deskriptoren enth√§lt, besteht ein hohes Risiko, dass in Ihrer Umgebung solche Fehler auftreten.  Und wie die meisten Fehler im Zusammenhang mit Ressourcenbeschr√§nkungen oder -lecks wird diese Situation h√∂chstwahrscheinlich erfolgreich getestet und Sie in den produktiven Betrieb versetzt.  Dies geschieht nat√ºrlich, wenn Ihre Anwendung am st√§rksten ausgelastet ist, so dass die maximale Anzahl von Benutzern von Ihrer Schande erf√§hrt. <br><br>  <a href="https://en.wikipedia.org/wiki/Graphics_Device_Interface" rel="nofollow">Die Einschr√§nkungen f√ºr den Prozessor und die Benutzersitzung</a> h√§ngen von der Version des Betriebssystems ab, und die Einschr√§nkungen f√ºr den Prozessor k√∂nnen angepasst werden.  Aber die Version spielt keine Rolle, weil  GDI-Deskriptoren werden intern durch den USHORT-Datentyp dargestellt, daher gibt es ein striktes Limit von 65.536 Deskriptoren pro Benutzersitzung, und selbst eine gut geschriebene Anwendung kann dieses Limit unter ausreichender Last erreichen.  Wenn Sie glauben, dass ein leistungsf√§higerer Server es Ihnen erm√∂glicht, immer mehr Benutzer gleichzeitig auf einer Instanz zu bedienen, wird dieses Risiko realer.  Und wer m√∂chte eigentlich Software mit einer bekannten harten Skalierbarkeitsgrenze erstellen? <br><br><h3>  Grund Nr. 2: Parallelit√§t </h3><br>  GDI + hatte immer Probleme mit der Parallelit√§t, obwohl viele von ihnen mit <a href="https://blogs.msdn.microsoft.com/e7/2009/04/25/engineering-windows-7-graphics-performance/" rel="nofollow">Architektur√§nderungen in Windows 7 / Windows Server 2008 R2 zusammenh√§ngen</a> , sehen Sie immer noch einige von ihnen in neuen Versionen.  Am bemerkenswertesten ist die von GDI + w√§hrend der DrawImage () - Operation angeordnete Prozesssperre.  Wenn Sie die Gr√∂√üe von Bildern auf dem Server mithilfe von System.Drawing (oder den Bibliotheken, in denen sie enthalten sind) √§ndern, ist die DrawImage () -Methode wahrscheinlich die Grundlage f√ºr diesen Code. <br><br>  Wenn Sie DrawImage () mehrere Male gleichzeitig aufrufen, werden <b>alle</b> blockiert, bis <b>alle</b> ausgef√ºhrt wurden.  Auch wenn die Antwortzeit f√ºr Sie kein Problem darstellt (warum nicht? Hassen Sie Ihre Benutzer?) Beachten Sie, dass alle mit diesen Anforderungen verkn√ºpften Speicherressourcen und alle GDI-Deskriptoren, die von den mit diesen Anforderungen verkn√ºpften Objekten gespeichert werden, an die Laufzeit gebunden sind.  Tats√§chlich ist der Server nicht zu stark belastet, um Probleme zu verursachen. <br><br>  Nat√ºrlich gibt es f√ºr dieses spezielle Problem Problemumgehungen.  Einige Entwickler erstellen beispielsweise f√ºr jede DrawImage () - Operation einen externen Prozess.  Tats√§chlich sorgt eine solche Problemumgehung jedoch nur f√ºr zus√§tzliche Zerbrechlichkeit, die Sie eigentlich nicht h√§tten tun d√ºrfen. <br><br><h3>  Grund 3: Ged√§chtnis </h3><br>  Stellen Sie sich einen ASP.NET-Handler vor, der ein Diagramm generiert.  Er sollte so etwas tun: <br><br><ol><li>  Erstellen Sie eine Bitmap als Zeichenfl√§che </li><li>  Zeichnen Sie mit Stiften und / oder Pinseln mehrere Formen auf eine Bitmap </li><li>  Zeichnen Sie Text mit einer oder mehreren Schriftarten </li><li>  Speichern Sie die Bitmap als PNG in MemoryStream </li></ol><br>  Angenommen, das Diagramm misst 600 mal 400 Punkte.  Dies sind insgesamt 240.000 Punkte, multipliziert mit 4 Bytes f√ºr einen Punkt f√ºr das Standard-RGBA-Format, insgesamt 960.000 Bytes f√ºr eine Bitmap sowie ein wenig f√ºr das Zeichnen von Objekten und einen Speicherpuffer.  Lassen Sie es 1 MB f√ºr die gesamte Anforderung sein.  Wahrscheinlich treten in einem solchen Szenario keine Speicherprobleme auf, und wenn Sie auf etwas sto√üen, ist die Anzahl der Deskriptoren, die ich bereits erw√§hnt habe, h√∂chstwahrscheinlich begrenzt, da Bilder, Pinsel, Stifte und Schriftarten ihre eigenen Deskriptoren haben. <br><br>  Das eigentliche Problem tritt auf, wenn System.Drawing f√ºr Imaging-Aufgaben verwendet wird.  System.Drawing ist in erster Linie eine Grafikbibliothek, und Grafikbibliotheken basieren in der Regel auf der Idee, dass sich alles als Bitmap im Speicher befindet.  Dies ist gro√üartig, w√§hrend Sie √ºber die kleinen Dinge nachdenken.  Aber die Bilder k√∂nnen wirklich gro√ü sein und werden jeden Tag gr√∂√üer, weil  Kameras mit vielen Megapixeln werden immer billiger. <br><br>  Wenn Sie den naiven Ansatz von System.Drawing f√ºr die Image-Erstellung w√§hlen, erhalten Sie f√ºr den Resize-Handler Folgendes: <br><br><ol><li>  Erstellen Sie eine Bitmap als Zeichenfl√§che f√ºr das Zielbild. </li><li>  Laden Sie das Originalbild in eine andere Bitmap. </li><li>  Rufen Sie DrawImage () mit dem Parameter "image-source" f√ºr das Zielbild auf und √§ndern Sie die Gr√∂√üe. </li><li>  Speichern Sie die Ziel-Bitmap im JPEG-Format im Memory Stream. </li></ol><br>  Angenommen, das Ziel-Image ist 600 x 400, wie im vorherigen Beispiel, dann haben wir wieder 1 MB f√ºr das <i>Ziel-Image</i> und den Speicher-Stream.  Angenommen, jemand hat ein 24-Megapixel-Bild von seinen neuen DSLRs hochgeladen. Dann ben√∂tigen wir 6000 x 4000 Pixel mit jeweils 3 Byte (72 MB) f√ºr die decodierte Quell-Bitmap im RGB-Format.  Und wir werden das HighQualityBicubic-Resampling von System.Drawing verwenden, da es nur gut aussieht.  Dann m√ºssen wir die anderen 6000x4000 Punkte mit jeweils 4 Bytes f√ºr die <a href="https://photosauce.net/blog/post/image-scaling-with-gdi-part-5-push-vs-pull-and-image-validation" rel="nofollow">PRGBA-Konvertierung ber√ºcksichtigen, die innerhalb der aufgerufenen Methode durchgef√ºhrt wird</a> , wobei zus√§tzliche 96 MB belegter Speicher hinzugef√ºgt werden.  Insgesamt werden 169 MB (!) F√ºr eine Anforderung zum Konvertieren eines einzelnen Bildes erhalten. <br><br>  Stellen Sie sich nun vor, Sie haben mehr als einen Benutzer, der solche Dinge ausf√ºhrt.  Denken Sie jetzt daran, dass Anforderungen blockiert werden, bis alle vollst√§ndig ausgef√ºhrt wurden.  Wie lange dauert es, bis der Speicher voll ist?  Und selbst wenn Sie nicht bef√ºrchten, dass Sie alle verf√ºgbaren Ressourcen vollst√§ndig aussch√∂pfen, gibt es viele M√∂glichkeiten, den Speicher Ihres Servers besser zu nutzen, als eine Reihe von Pixeln zu speichern.  Ber√ºcksichtigen Sie die Auswirkung des Speicherdrucks auf andere Teile der Anwendung / des Systems: <br><br><ol><li>  Der ASP.NET-Cache beginnt m√∂glicherweise, Elemente zu leeren, deren Neuerstellung kostspielig ist </li><li>  Der Garbage Collector wird h√§ufiger gestartet, wodurch die Anwendung verlangsamt wird </li><li>  IIS-Kernel-Cache oder Windows-Dateisystem-Cache k√∂nnen n√ºtzliche Elemente entfernen </li><li>  Der Anwendungspool √ºberschreitet m√∂glicherweise das Speicherlimit und wird m√∂glicherweise neu gestartet </li><li>  Windows beginnt m√∂glicherweise mit dem Auslagern von Speicher auf die Festplatte, wodurch das gesamte System verlangsamt wird </li></ol><br>  Willst du wirklich nichts davon? <br><br>  Speziell f√ºr Bildverarbeitungsaufgaben konzipierte Bibliotheken gehen dieses Problem auf ganz andere Weise an.  Sie m√ºssen nicht das gesamte Quell- oder Zielbild in den Speicher laden.  Wenn Sie nicht darauf zeichnen m√∂chten, ben√∂tigen Sie keine Zeichenfl√§che / Bitmap.  Dies geschieht eher so: <br><br><ol><li>  Erstellen Sie einen Stream f√ºr den JPEG-Encoder des Zielbilds </li><li>  Laden Sie eine Zeile aus dem Originalbild und komprimieren Sie sie horizontal </li><li>  Wiederholen Sie diesen Vorgang so oft wie n√∂tig, um eine Zeile f√ºr die Zieldatei zu bilden </li><li>  Komprimieren Sie die resultierenden Linien vertikal </li><li>  Wiederholen Sie ab Schritt 2, bis alle Zeilen der Quelldatei verarbeitet sind. </li></ol><br>  Mit dieser Methode kann dasselbe Bild mit insgesamt 1 MB Speicher verarbeitet werden, und selbst bei viel gr√∂√üeren Bildern ist ein geringf√ºgig h√∂herer Overhead erforderlich. <br><br>  Ich kenne nur eine .NET-Bibliothek, die nach diesem Prinzip optimiert ist, und ich gebe Ihnen einen Hinweis: Dies ist nicht System.Drawing. <br><br><h3>  Grund 4: CPU </h3><br>  Ein weiterer Nebeneffekt von System.Drawing, das grafisch orientierter als bildorientierter ist, besteht darin, dass DrawImage () in Bezug auf die CPU-Auslastung ziemlich ineffizient ist.  Ich habe dies in einem <a href="https://photosauce.net/blog/post/lies-damned-lies-and-benchmarks-part-2-drawimage-why-u-so-slow" rel="nofollow">fr√ºheren Beitrag</a> ausf√ºhrlich behandelt, aber diese Diskussion kann durch die folgenden Fakten zusammengefasst werden: <br><br><ul><li>  In System.Drawing funktioniert die HighQualityBicubic-Skalierungskonvertierung nur mit dem PRGBA-Format.  In fast allen Szenarien bedeutet dies eine zus√§tzliche Kopie des Bildes.  Dies verbraucht nicht nur (erheblich) mehr zus√§tzlichen Speicher, sondern verbrennt auch die Prozessorzyklen zum Konvertieren und Verarbeiten des zus√§tzlichen Alphakanals. </li><li>  Selbst wenn das Bild in seinem urspr√ºnglichen Format vorliegt, f√ºhrt die HighQualityBicubic-Skalierungskonvertierung ungef√§hr viermal mehr Berechnungen durch, als f√ºr die Erzielung der korrekten Konvertierungsergebnisse erforderlich sind. </li></ul><br>  Diese Tatsachen f√ºhren zu einer erheblichen Anzahl verschwendeter CPU-Zyklen.  In einer tr√ºben Umgebung mit einer Zahlung pro Minute tr√§gt dies direkt zu den Hosting-Kosten bei.  Und nat√ºrlich wird Ihre Reaktionszeit leiden. <br><br>  Und denken Sie daran, dass zus√§tzlicher Strom verbraucht und W√§rme erzeugt wird.  Ihre Verwendung von System.Drawing f√ºr Bildverarbeitungsaufgaben wirkt sich direkt auf die globale Erw√§rmung aus.  Du bist ein Monster. <br><br><h3>  Grund Nr. 5: Die Bildverarbeitung ist t√§uschend komplex </h3><br>  Abgesehen von der Leistung verhindert System.Drawing in vielerlei Hinsicht, dass das Bild korrekt verarbeitet wird.  Das Verwenden von System.Drawing bedeutet, entweder mit einer falschen Ausgabe zu leben oder alles √ºber das ICC-Profil, die Farbquantisierung, die Exif-Ausrichtung, die Korrektur und viele andere spezifische Dinge zu lernen.  Dies ist ein Kaninchenbau, den die meisten Entwickler weder erforschen noch erforschen m√∂chten. <br><br>  Bibliotheken wie ImageResizer und ImageProcessor haben eine Menge Fans gewonnen, die sich um einige dieser Details k√ºmmern, aber seien Sie vorsichtig, sie haben System.Drawing im Inneren und sie kommen mit all dem Gep√§ck, das ich in diesem Artikel ausf√ºhrlich beschrieben habe. <br><br><h3>  Bonusgrund: Sie k√∂nnen es besser machen </h3><br>  Wenn Sie wie ich irgendwann in Ihrem Leben eine Brille tragen mussten, erinnern Sie sich wahrscheinlich, wie Sie sie zum ersten Mal aufgesetzt haben.  Ich dachte, ich sehe normal und wenn ich richtig schaue, ist alles ziemlich klar.  Aber dann setzte ich diese Brille auf und die Welt wurde viel detaillierter, als ich es mir h√§tte vorstellen k√∂nnen. <br><br>  System.Drawing ist √§hnlich.  Es ist richtig, wenn Sie <a href="https://photosauce.net/blog/post/image-scaling-with-gdi-part-3-drawimage-and-the-settings-that-affect-it" rel="nofollow">die Einstellungen richtig ausf√ºllen</a> , aber Sie werden √ºberrascht sein, wie viel besser Ihre Bilder aussehen k√∂nnen, wenn Sie die besten Dienstprogramme verwenden. <br><br>  Ich lasse dies hier nur als Beispiel.  Dies ist die beste System.Drawing-Funktion im Vergleich zu den Standardeinstellungen von MagicScaler.  Vielleicht profitiert Ihre Bewerbung davon, Punkte zu bekommen ... <br><br>  Gdi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a6/9c9/491/9a69c9491e230c3a7e887e830d136860.jpg" alt="Bild"><br><br>  MagicScaler: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd2/eec/e24/dd2eece240e1a41b46c74ccde2e5eed2.jpg" alt="Bild"><br>  <a href="https://unsplash.com/%40jakobowens1" rel="nofollow">Foto von Jakob Owens</a> <br><br>  Schauen Sie sich um, suchen Sie nach Alternativen und beenden Sie im Namen der K√§tzchenliebe die Verwendung von System.Drawing in ASP.NET </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482274/">https://habr.com/ru/post/de482274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482262/index.html">So melden Sie sich bei Talend Open Studio an</a></li>
<li><a href="../de482264/index.html">Brasilien, dunkle Magie, Mortal Kombat, Mars und 15.000 Menschen. Ontiko Jahresergebnisse</a></li>
<li><a href="../de482268/index.html">Megastrukturen der Zukunft: Die Dyson-Kugel, der Sternmotor und die ‚ÄûSchwarze-Loch-Bombe‚Äú</a></li>
<li><a href="../de482270/index.html">WebRTC-Streaming in und um die virtuelle Realit√§t</a></li>
<li><a href="../de482272/index.html">Auswahl eines Data Warehouse f√ºr Prometheus: Thanos vs VictoriaMetrics</a></li>
<li><a href="../de482276/index.html">GOST R 57580. Vom Trend zur effizienten Automatisierung</a></li>
<li><a href="../de482280/index.html">Wie wird Cosplay gemacht? Isaac Clarkes Kost√ºm f√ºr Fortgeschrittene aus Dead Space 2</a></li>
<li><a href="../de482282/index.html">Das Ende der ARMv7-√Ñra oder ein bisschen √ºber das Portieren von Spielen</a></li>
<li><a href="../de482284/index.html">"50 Braunt√∂ne" oder "Wie sind wir dazu gekommen"</a></li>
<li><a href="../de482286/index.html">Unerwartete gemeinsame √úberpr√ºfung von Audio-Technica-Kassetten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>