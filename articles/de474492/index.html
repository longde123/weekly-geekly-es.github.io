<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏻 🧚🏽 👩🏻‍🤝‍👨🏿 Reagieren Sie auf Mehrbenutzer-Chat mit dem Chatix-Backend 👶🏼 🤶🏼 👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jetzt zeige ich Ihnen, wie Sie einen Chat für das Team / die Benutzer / Freunde erstellen, wenn Sie kein Backend haben oder keine Zeit damit verbringe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reagieren Sie auf Mehrbenutzer-Chat mit dem Chatix-Backend</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474492/"><p><img src="https://habrastorage.org/getpro/habr/post_images/d7e/212/ac4/d7e212ac471c99b0cd61dd0e75aab281.png" alt="Chatix Chatroom"></p><br><p>  Jetzt zeige ich Ihnen, wie Sie einen Chat für das Team / die Benutzer / Freunde erstellen, wenn Sie kein Backend haben oder keine Zeit damit verbringen möchten, es zu entwickeln.  Wir werden einen einfachen Text-Chat machen und es wird ungefähr eine Stunde dauern. </p><br><p> Es ist fast unmöglich, einen funktionierenden Netzwerk-Chat ohne Backend zu schreiben. Er muss in der einen oder anderen Form vorliegen.  Wir werden Chatix und sein JavaScript SDK verwenden.  Chatix und SDK werden sich mit Nachrichtenspeicherung und Netzwerkaufgaben befassen, und wir werden uns um das Front-End kümmern. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der fertige Projektcode ist auf GitHub verfügbar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> </p><a name="habracut"></a><br><h2 id="struktura-proekta">  Projektstruktur </h2><br><ul><li>  App (die Stammkomponente der Anwendung fungiert als State Custodian, da in dieser Lektion weder Redux noch ein anderer State Manager hinzugefügt wird.) <br><ul><li>  Kopfzeile (die Kopfzeile unserer Anwendung, in der das Logo und der Chatname angezeigt werden und der Benutzer seinen Namen schreiben kann) </li><li>  LogoHeader </li><li>  Raumtitel </li><li>  Main </li><li>  MemberList (Chatliste) <br><ul><li>  MemberItem [] </li></ul></li><li>  ChatField (ein Container für alles, was mit Chat-Nachrichten zu tun hat) <br><ul><li>  Nachrichtencontainer </li><li>  Nachricht [] (Präsentation der Nachricht; in dieser Lektion werden wir nur mit Textnachrichten arbeiten) </li><li>  SendMessageForm (Formular zum Senden einer neuen Chat-Nachricht) </li></ul></li><li>  ChatixSDK (kopflose Komponente, die für die Arbeit mit dem Backend verantwortlich ist) </li></ul></li></ul><br><blockquote> Wichtiger Hinweis zur Zustandsspeicherung.  Natürlich wäre es bequemer, Redux hier hinzuzufügen und Statusänderungen zu verarbeiten, aber um Zeit zu sparen, speichern wir den Status in der Stammkomponente der App und leiten Daten an die untergeordneten Komponenten weiter und rufen deren Eltern über die untergeordneten Methoden auf. <br>  Wenn wir zum Beispiel den Namen des Chats erhalten, speichern wir ihn im Status der App-Komponente und <code>App → Header → RoomTitle</code> ihn durch <code>props</code> : <code>App → Header → RoomTitle</code> .  Wenn der Benutzer eine Nachricht schreibt, wird diese von SendMessageForm an die App übertragen: <code>SendMessageForm → ChatField → Main → App</code> . </blockquote><p>  Unser Chat wird im Design ungefähr so ​​aussehen: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d1e/096/b73/d1e096b7349824c510542cc215ae437e.png" alt="chatix.io"></p><br><h2 id="vzaimodeystvie-mezhdu-komponentami">  Interaktion zwischen Komponenten </h2><br><p>  Unsere Komponenten müssen Daten untereinander übertragen. Damit alles ordnungsgemäß funktioniert, legen wir jetzt fest, wie sie miteinander interagieren. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fde/009/821/fde0098218938f714d32a58ad9776ec9.png" alt="Komponenteninteraktion"></p><br><p>  Wie Sie in der Abbildung sehen können, ist die Hauptkomponente für uns die <code>App</code> , die Daten für die untergeordneten Komponenten bereitstellt (aufgrund der Reaktivität weisen wir einfach <code>prop</code> und die untergeordnete Komponente reagiert auf Änderungen), und die untergeordneten Komponenten leiten nacheinander Methodenaufrufe an die <code>App</code> .  Dies ist nicht die beste Architektur, die für ein Produktionsprojekt erstellt werden kann (und sollte), aber für unsere Lektion. </p><br><h2 id="sozdanie-proekta">  Projekterstellung </h2><br><h3 id="sozdaem-vizualnye-komponenty">  Erstellen Sie visuelle Komponenten </h3><br><h4 id="shapka">  Hut </h4><br><ol><li><p>  Zuerst müssen Sie ein neues Projekt erstellen, dafür verwenden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Create-React-App</a> . </p><br><pre> <code class="plaintext hljs">npx create-react-app chatix-chatroom cd chatix-chatroom</code> </pre> <br><p>  Führen Sie das Projekt mit dem Befehl aus </p><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br></li><li><p>  Beginnen wir mit der Erstellung eines Headers. <br>  Fügen Sie der Kopfzeile zunächst ein Logo hinzu.  Erstellen Sie dazu im Ordner src den <strong>Komponentenordner</strong> und darin den Ordner <strong>logo_header</strong> .  Wir laden das Logo in diesen Ordner <strong>hoch</strong> und erstellen 2 <strong>Dateien</strong> <strong>LogoHeader.js</strong> und <strong>LogoHeader.css</strong> </p><br></li></ol><br><p>  <strong>LogoHeader.js</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react' import logo from './chatix_logo.svg'; import './LogoHeader.css'; function LogoHeader(){ return ( &lt;div className="LogoHeader"&gt; &lt;img src={logo} className="App-logo" alt="Chatix logo" /&gt; &lt;/div&gt; ); } export default LogoHeader;</code> </pre> <br><p>  <strong>LogoHeader.css</strong> </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.LogoHeader</span></span>{ <span class="hljs-attribute"><span class="hljs-attribute">flex-basis</span></span>: <span class="hljs-number"><span class="hljs-number">200px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-grow</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-shrink</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Hier ist alles klar, in dieser Komponente wird einfach eine Datei mit einem Logo und Stilen importiert. </p><br><p>  Ich werde den Code für die Stylesheets hier nicht mehr hinzufügen, Sie können sie auf der Seite des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fertigen Projekts sehen</a> </p><br><p>  Zeigen Sie nun den Namen des Chatrooms an.  Erstellen Sie dazu einen <strong>Raumtitelordner</strong> und darin die <strong>RoomTitle-</strong> Komponente.  Wir werden den Namen durch Requisiten in diese Komponente werfen, also schreiben wir <code>props.chatroomName</code> und übertragen ihn jetzt hierher. </p><br><p>  <strong>Zimmertitel</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './RoomTitle.css'; function RoomTitle(props){ return ( &lt;div className="RoomTitle"&gt; &lt;h1&gt;{props.chatroomName}&lt;/h1&gt; &lt;/div&gt; ); } export default RoomTitle;</code> </pre> <br><p>  Dann erstellen wir die Header-Komponente selbst und platzieren das Logo und den Namen des Chatrooms darin.  Werfen Sie den Chat-Namen sofort über prop <code>chatroomName</code> in die untergeordnete Komponente. </p><br><p>  Ich erinnere Sie daran, dass wir vereinbart haben, dass alle Daten (Anwendungsstatus) von der Stammkomponente der <strong>App</strong> gespeichert werden.  Von dort übertragen wir den Header zuerst in den <strong>Header</strong> und vom <strong>Header</strong> in den <strong>RoomTitle</strong> . </p><br><p>  <strong>Komponenten \ Header \ Header.js</strong> </p><br><p>  <strong>Header.js</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './Header.css' import LogoHeader from '../logo_header/LogoHeader'; import RoomTitle from '../room-title/RoomTitle'; function Header(props) { return ( &lt;header&gt; &lt;LogoHeader/&gt; &lt;RoomTitle chatroomName={props.chatroomName} /&gt; &lt;/header&gt; ); } export default Header;</code> </pre> <br><p>  Öffnen Sie als <strong>Nächstes die</strong> Datei <strong>App.js</strong> und fügen Sie die Komponente <strong>Header.js hinzu</strong> . <br>  Dann fügen wir den Namen dem <strong>Status hinzu und</strong> leiten ihn über <strong>Requisiten</strong> an den <strong>Header weiter</strong> . <br>  Außerdem müssen Sie in der Kopfzeile den Namen des aktuellen Benutzers hinzufügen.  Fügen Sie dazu das Benutzerobjekt dem Status hinzu und leiten Sie es auf ähnliche Weise an den Header weiter </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './App.css'; import Header from './components/header/Header'; class App extends React.Component { constructor(props){ super(props); chatroomName: '-', me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } } render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} /&gt; &lt;/div&gt; ); }; } export default App;</code> </pre> <br><p>  Jetzt müssen Sie in der Kopfzeile eine Eingabe mit dem Namen des aktuellen Benutzers hinzufügen und dem Handler eine Änderung zuweisen, damit wir den neuen Benutzernamen an die <strong>App-</strong> Komponente übertragen können. </p><br><p>  Dazu fügen wir der Eingabe mit dem Namen die <code>handleChangeName</code> Funktion <code>props.updateVisitor</code> und rufen die Rückruffunktion <code>props.updateVisitor</code> , in der wir das Benutzerobjekt mit dem aktualisierten Namen übergeben. </p><br><p>  <strong>Header.js</strong> </p><br><pre> <code class="plaintext hljs">function Header(props) { const [name, setName] = useState(props.me.name ? props.me.name : props.me.uuid.substr(-10)) const handleChangeName = (e) =&gt; { setName(e.target.value) let visitor = {...props.me}; visitor.name = e.target.value; props.updateVisitor(visitor) } return ( &lt;header&gt; &lt;LogoHeader/&gt; &lt;RoomTitle chatroomName={props.chatroomName}/&gt; { props.me ? &lt;input className='name-input' value={name} placeholder=' ' onChange={(e) =&gt; handleChangeName(e)} /&gt; : null } &lt;/header&gt; ); }</code> </pre> <br><p>  <code>props.updateVisitor</code> nun diese Funktion <code>props.updateVisitor</code> zur <strong>App hinzu</strong> und <code>props.updateVisitor</code> sie an den <code>props.updateVisitor</code> .  Bisher wird nur das Benutzerobjekt im Status aktualisiert. Anschließend wird der Benutzer auf dem Server aktualisiert. </p><br><pre> <code class="plaintext hljs">onUpdateVisitor = (visitor) =&gt; { this.setState({me: visitor}) }</code> </pre> <br><p>  Jetzt sieht unsere Anwendung so aus und weiß bisher nur, wie man den Namen aktualisiert.  Mach weiter </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/685/7ec/243/6857ec2435f476e8d6dad5201d7909a5.png" alt="Chatroom-Header"></p><br><h4 id="saydbar">  Seitenleiste </h4><br><p>  Lassen Sie uns nun eine Seitenleiste erstellen. <br>  Die Seitenleiste befindet sich innerhalb der Hauptkomponente auf der Seite <strong>Main.js.</strong> <br>  Wir erstellen es <strong>Komponenten \ main \ Main.js</strong> , erstellen dann eine Komponente mit einer Liste der Benutzerkomponenten <strong>\ Mitgliedsliste \ MemberList.js</strong> und erstellen sofort eine Komponente, die die Benutzer selbst <strong>Komponenten \ Mitgliedselement \ MemberItem.js anzeigt</strong> . </p><br><p>  Schauen Sie sich die Projektskizze am Anfang des Artikels an, um die Beziehung zwischen diesen drei Komponenten zu verdeutlichen. </p><br><p>  Die Komponenten werden erstellt, jetzt gehen wir in Reihenfolge. <br>  Fügen Sie zunächst das Benutzerarray zum Status der <strong>App-</strong> Komponente hinzu und fügen Sie die Hauptkomponente hinzu.  Dann werden wir diese Benutzer weiterleiten. </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">class App extends React.Component { constructor(props) { super(props); this.state = { chatroomName: '-', members: [ { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" }, { is_online: true, name: "", uuid: "mnzxcv97zx6chvo" }, { is_online: false, name: "", uuid: "kjuhv987ashdfoua" }, { is_online: false, name: "", uuid: "jdhnf978WEHJSNDL" }, ], me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } }; } render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} /&gt; &lt;Main members={this.state.members} me={this.state.me} /&gt; &lt;/div&gt; ); }; }</code> </pre> <br><p>  <strong>Fügen Sie in der</strong> Hauptkomponente die <strong>MemberList-</strong> Komponente hinzu und leiten Sie das Benutzerarray weiter. </p><br><p>  <strong>Main.js</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList members={props.members} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  In der <strong>MemberList-</strong> Komponente <strong>durchlaufen</strong> wir alle Benutzer und geben für jede Rückgabe die <strong>MemberItem-</strong> Komponente zurück und übergeben das Benutzerobjekt an sie. </p><br><p>  <strong>MemberList.js</strong> </p><br><pre> <code class="plaintext hljs">function MemberList(props) { const members = props.members.map((member) =&gt; &lt;MemberItem key={member.uuid} member={member} /&gt; ); return ( &lt;section className="MemberList"&gt; {members} &lt;/section&gt; ); }</code> </pre> <br><p>  Die <strong>MemberItem-</strong> Komponente zeigt den Benutzer bereits direkt in der Seitenleiste an.  Darin überprüfen wir den Namen des Benutzers, falls dieser nicht installiert ist, und zeigen dann die ersten 10 Zeichen des Bezeichners an.  Wir prüfen auch den Status online / offline und vergleichen die Kennung mit der Kennung des aktuellen Benutzers, so dass ihm gegenüber die Marke "(Sie)" angezeigt wird. </p><br><pre> <code class="plaintext hljs">function MemberItem(props) { function getName(){ let name = '' if (props.member.uuid === props.me.uuid) { if(props.me.name) { name = props.me.name } else { name = props.me.uuid.substring(props.me.uuid.length-10, props.me.uuid.length); } } else { if(props.member.name){ name = props.member.name } else { name = props.member.uuid.substring(props.member.uuid.length-10, props.member.uuid.length); } } return name; } return( &lt;div className="MemberItem"&gt; &lt;img src={ icon } alt={ props.member.name }/&gt; &lt;span&gt; { getName() } { props.member.uuid === props.me.uuid &amp;&amp; " () " } &lt;/span&gt; { props.member.is_online &amp;&amp; &lt;span className="online"&gt;•&lt;/span&gt; } &lt;/div&gt; ); }</code> </pre> <br><p>  Fertig  Jetzt sieht die Anwendung schon so aus </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eba/512/a8b/eba512a8bca7de4b1487567775f7742b.png" alt="Chatroom-Header"></p><br><h4 id="spisok-soobscheniy-i-forma-otpravki">  Nachrichtenliste und Einreichungsformular </h4><br><p>  Jetzt beschäftigen wir uns mit der Nachrichtenliste und dem Sendeformular. <br>  Fügen Sie zunächst dem Status der <strong>App-</strong> Komponente ein Array mit Nachrichten hinzu. </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">this.state = { chatroomName: '-', messages: [ { content: " 1", sender_id: "mnzxcv97zx6chvo", uuid: "dg897sdfg" }, { content: " 2", sender_id: "98s7dfh9a8s7dhf", uuid: "8723hernm" }, { content: "  ", sender_id: "mnzxcv97zx6chvo", uuid: "435nbcv98234" } ], members: [ { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" }, { is_online: true, name: "", uuid: "mnzxcv97zx6chvo" }, { is_online: false, name: "", uuid: "kjuhv987ashdfoua" }, { is_online: false, name: "", uuid: "jdhnf978WEHJSNDL" }, ], me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } };</code> </pre> <br><p>  Und leiten Sie sie an die Hauptkomponente weiter </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs"> &lt;Main members={this.state.members} messages={this.state.messages} me={this.state.me} /&gt;</code> </pre> <br><p>  Erstellen Sie nun die Komponente <strong>conponents / chat-field / ChatField.js</strong> <br>  Verbinden Sie es mit <strong>Main</strong> und leiten Sie die Nachrichten weiter. </p><br><p>  <strong>Main</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList me={props.me} members={props.members} /&gt; &lt;ChatField messages={props.messages} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  Erstellen Sie als Nächstes die Komponente <strong>conponents / message-container / MessageContainer.js</strong> <br>  Verbinden Sie es mit <strong>ChatField</strong> und leiten Sie auch Nachrichten an <strong>ChatField</strong> weiter. </p><br><p>  <strong>Chatfield</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList me={props.me} members={props.members} /&gt; &lt;ChatField messages={props.messages} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  Dann werden wir alle Nachrichten durchlaufen und für jede Rückgabe die Komponente, die sie anzeigt. <br>  Lassen Sie es <strong>uns conponents / message / Message.js erstellen</strong> .  Darin zeigen wir das Symbol des Besuchers, seinen Namen oder seine Kennung, wenn der Name nicht angegeben ist, und den Nachrichtentext selbst an. </p><br><p>  <strong>Nachricht</strong> </p><br><pre> <code class="plaintext hljs">function Message(props) { const getSenderName = () =&gt; { if (props.sender) { return props.sender.name ? props.sender.name : props.sender.uuid.substr(-10); } return "Unknown sender"; }; return( &lt;div className="Message"&gt; &lt;div className="message-sender-icon"&gt; &lt;img src={icon} alt="visitor icon"/&gt; &lt;/div&gt; &lt;div className="message-bubble"&gt; &lt;div className="message-sender-name"&gt;{getSenderName()}&lt;/div&gt; &lt;div className="message-content"&gt;{props.message.content}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); }</code> </pre> <br><p>  In einem <strong>MessageContainer durchlaufen wir nun</strong> alle Nachrichten und geben für jede Rückgabe die <strong>Nachrichtenkomponente zurück</strong> , an die wir das Nachrichtenobjekt übergeben </p><br><p>  <strong>Nachrichtencontainer</strong> </p><br><pre> <code class="plaintext hljs">function MessageContainer(props) { const messageList = props.messages.map(message =&gt; &lt;Message key={message.uuid} sender={props.members.find((member) =&gt; member.uuid === message.sender_id)} message={message} /&gt; ); return ( &lt;section className="MessageContainer" ref={messagesContainer}&gt; {messageList} &lt;/section&gt; ); }</code> </pre> <br><p>  Jetzt sieht das Projekt so aus: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/74d/cad/f22/74dcadf22a3086fa2d7182e1aa791cab.png" alt="Chatroom-nachrichten"></p><br><p>  Erstellen Sie nun eine Komponente mit einem Formular zum Senden von Nachrichten. <strong>Components / send-message-form / SendMessageForm.js</strong> .  Darin erstellen wir eine Eingabe und eine Schaltfläche zum Senden.  Wenn sich die Eingabe ändert, wird der Text in den Status geschrieben, und wenn Sie auf die Schaltfläche klicken, rufen wir die Rückruffunktion <code>onSendNewMessage</code> und übertragen die Nachricht aus dem Status in den Status.  <code>onSendNewMessage</code> werden die <code>onSendNewMessage</code> Funktion etwas später in der <strong>App-</strong> Komponente erstellen und über Requisiten weiterleiten. </p><br><p>  <strong>Meldungsformular senden</strong> </p><br><pre> <code class="plaintext hljs">class SendMessageForm extends React.Component { constructor(props) { super(props); this.state = { message: '' }; } currentMessageChanged = (e) =&gt; { this.setState({message: e.target.value }); } sendMessageClicked = async (e) =&gt; { e.preventDefault(); if (this.state.message.length &gt; 0) { await this.props.onSendNewMessage(this.state.message); this.setState({...this.state, ...{message : ''}}); } } render(){ return ( &lt;section className="SendMessageForm"&gt; &lt;form&gt; &lt;input type="text" value={this.state.message} onChange={this.currentMessageChanged} placeholder="Type message to send"/&gt; &lt;button type="submit" onClick={this.sendMessageClicked} &gt; Send &lt;/button&gt; &lt;/form&gt; &lt;/section&gt; ); } }</code> </pre> <br><p>  Platzieren Sie nun die <strong>SendMessageForm-</strong> Komponente im <strong>ChatField</strong> . </p><br><p>  <strong>Chatfield</strong> </p><br><pre> <code class="plaintext hljs">function ChatField(props) { return( &lt;section className="ChatField"&gt; &lt;MessageContainer members={props.members} messages={props.messages} /&gt; &lt;SendMessageForm onSendNewMessage={props.onSendNewMessage}/&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  In der Hauptkomponente <code>onSendNewMessage</code> wir auch <code>onSendNewMessage</code> Funktion <code>onSendNewMessage</code> im <strong>ChatField weiter</strong> . </p><br><p>  <strong>Main</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatField members={props.members} messages={props.messages} onSendNewMessage={props.onSendNewMessage} /&gt;</code> </pre> <br><p>  Erstellen Sie nun diese Funktion in der <strong>App</strong> und leiten Sie sie an <strong>Main weiter</strong> . </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">onSendNewMessage = async (message) =&gt; { console.log(message) }</code> </pre> <br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">&lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt;</code> </pre> <br><p>  Fertig  Wenn Sie nun auf die Schaltfläche Nachricht senden klicken, wird diese an die <strong>App-</strong> Komponente übertragen. <br>  Jetzt sieht die Anwendung so aus: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e53/89e/d31/e5389ed317bd0fb4bf87db34b05f57a6.png" alt="Chatroom führt"></p><br><p>  Nun wird alles in unserer Anwendung angezeigt und alles funktioniert wie es sollte, aber bisher mit statischen Daten. Um unseren Chat wiederzubeleben, müssen Sie ihn mit dem Backend verbinden. </p><br><h4 id="podklyuchenie-bekenda">  Backend-Verbindung </h4><br><p>  Dazu installieren Sie zunächst das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chatix-Core-</a> Paket. </p><br><pre> <code class="plaintext hljs">npm i chatix-core</code> </pre> <br><p>  Dann erstelle ein Konto bei <strong>Chatix</strong> und erstelle einen Chatraum.  Gehen Sie dazu zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chatix.io</a> und registrieren Sie sich. <br>  Nach der Registrierung können Sie die <strong>websiteId-</strong> Site- <strong>ID</strong> in der Admin-Oberfläche auf der Seite mit den Chat-Einstellungen sehen. </p><br><p>  Jetzt erstellen wir einen neuen Chatraum, mit dem wir arbeiten werden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/38b/26d/034/38b26d03464c1b236beff17c4118ba00.png" alt="Chatroom erstellen"></p><br><p>  Wir kehren zu unserem Projekt zurück und erstellen eine neue Komponente, über die wir mit dem Server arbeiten. <br>  <strong>components \ chatix \ ChatixSDK.js</strong> </p><br><p>  Wir importieren <strong>ChatixCore darin.</strong> </p><br><pre> <code class="plaintext hljs">import ChatixCore from 'chatix-core';</code> </pre> <br><p>  <strong>Erstellen Sie</strong> in der <strong>ChatixSDK-</strong> Komponente eine Instanz der <strong>ChatixCore-</strong> Klasse und übergeben Sie die <strong>websiteId</strong> als Argument. </p><br><pre> <code class="plaintext hljs">const websiteId = "_WEBSITE_ID"; this.sdk = new ChatixCore(websiteId);</code> </pre> <br><p>  Jetzt <strong>können</strong> Sie in <strong>this.sdk</strong> die Methoden zum Arbeiten mit dem Chatraum verwenden.  Sie können die Liste der Methoden auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chatix-Core-</a> Projektseite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzeigen</a> </p><br><p>  Als nächstes müssen wir eine Verbindung zum Server herstellen und Daten über den zuvor erstellten Chatroom abrufen.  <strong>Hierfür</strong> gibt es asynchrone Methoden <strong>start ()</strong> und <strong>getChatroom ()</strong> . </p><br><p>  Nachdem Sie das Chatroom-Objekt erhalten haben, nehmen wir sofort seinen Namen und übertragen ihn in die <strong>App</strong> .  <code>updateChatroomTitle(chatroom.title)</code> Sie dazu die Rückruffunktion <code>updateChatroomTitle(chatroom.title)</code> in die <strong>App ein</strong> und rufen Sie sie im <strong>ChatixSDK auf</strong> . </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">class ChatixSDK extends React.Component { constructor(props){ super(props); const websiteId = "_WEBSITE_ID"; this.chatroomId = "_CHATROOM_ID"; this.sdk = new ChatixCore(websiteId); this.sdk.start() .then( async () =&gt; { try { // refresh information about chatroom and call passed handler const chatroom = await this.sdk.getChatroom(this.chatroomId); if (props.updateChatroomTitle) { props.updateChatroomTitle(chatroom.title); } } catch (err) { console.error(err); } }) .catch((e) =&gt; { console.error(e); }); } render(){ return null; } }</code> </pre> <br><p>  Sie können <code>this.chatroomId</code> in der Manager-Oberfläche <code>this.chatroomId</code> , indem Sie den gewünschten Chatroom öffnen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/57d/309/a77/57d309a77bb226589ba225c52cfe37d6.png" alt="ChatroomID"></p><br><p>  Jetzt verbinden wir in der <strong>App</strong> die <strong>ChatixSDK-</strong> Komponente und werfen die updateChatroomTitle-Funktion hinein, die den Chat-Namen aktualisiert.  Wir fügen auch einen <code>ref</code> Link hinzu, damit wir auf diese Komponente zugreifen können. </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">this.chatixSDK = React.createRef();</code> </pre> <br><pre> <code class="plaintext hljs">setChatroomTitle = (newName) =&gt; { const newStateFragment = { chatroomName: newName}; this.setState({...this.state, ...newStateFragment}); };</code> </pre> <br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} updateVisitor={this.onUpdateVisitor} /&gt; &lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt; &lt;ChatixSDK ref={this.chatixSDK} updateChatroomTitle={this.setChatroomTitle} /&gt; &lt;/div&gt; ); };</code> </pre> <br><p>  Fertig  Unmittelbar nach dem Herstellen der Verbindung zum Server fordern wir Chat-Daten an, rufen deren Namen ab und schreiben sie in den Status der <strong>App-</strong> Komponente. Da Statusänderungen dazu führen, dass die Komponente erneut gerendert wird, wird der Name in der Kopfzeile automatisch aktualisiert.  Jetzt kann der Standardname im Status durch eine leere Zeichenfolge ersetzt werden. </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">chatroomName: ''</code> </pre> <br><p>  Jetzt füllen wir die Seitenleiste mit echten Benutzern. <br>  Bevor Sie jedoch die Liste der Benutzer erhalten, müssen Sie eine Verbindung zum Chat herstellen. Dazu erhalten Sie im <strong>ChatixSDK</strong> in der Funktion <code>this.sdk.start()</code> eine Liste aller Chatrooms des Benutzers. Überprüfen Sie, ob diese mit dem aktuellen verbunden sind, und verbinden Sie sie, wenn nicht. </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">const myChatrooms = await this.sdk.getMyChatrooms(); if (myChatrooms.filter(x =&gt; x.id===this.chatroomId).length === 0) { await this.sdk.connectToChatroom(this.chatroomId); }</code> </pre> <br><p>  Nachdem wir sichergestellt haben, dass unser Benutzer mit dem Chat verbunden ist, können wir eine Liste der Teilnehmer dieses Chats abrufen. </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">// lets get all chatroom members using infinite loop with break on empty server response let membersPage = 1; let allChatroomMembers = []; while(true) { let pagedMembers = await this.sdk.getChatroomMembers(this.chatroomId, membersPage++, 10); allChatroomMembers = [...allChatroomMembers, ...pagedMembers]; if (pagedMembers.length === 0) { break; } }</code> </pre> <br><p>  Hier, in einer Endlosschleife, fordern wir Benutzer Seite für Seite an, bis wir alle erhalten. Sobald wir alle erhalten, unterbrechen wir die Schleife.  Danach leiten wir ihn genau wie den Namen des Chatrooms mithilfe der Rückruffunktion an die übergeordnete Komponente weiter. </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">if (props.setChatroomMembers) { props.setChatroomMembers(allChatroomMembers); }</code> </pre> <br><p>  Erstellen Sie nun in der <strong>App-</strong> Komponente die Rückruffunktion <code>setChatroomMembers</code> der Benutzer nach ihrem Online- / Offline-Status und alphabetisch sortiert und im Status <code>setChatroomMembers</code> werden. </p><br><p>  <strong>App.js.</strong> </p><br><pre> <code class="plaintext hljs">setChatroomMembers = (members) =&gt; { members.sort(this.sortMembers); const newStateFragment = { members: members}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p>  Sortierfunktion <strong>sortMembers hinzufügen</strong> .  Es sortiert Benutzer nach Status und alphabetisch. </p><br><p>  <strong>App.js.</strong> </p><br><pre> <code class="plaintext hljs">sortMembers(a, b) { if (a.is_online === true &amp;&amp; b.is_online === false) { return -1; } else if (b.is_online === true &amp;&amp; a.is_online === false) { return 1; } else { if (a.name &amp;&amp; b.name) { if (a.name.toLocaleUpperCase() &gt; b.name.toLocaleUpperCase()) { return 1; } else if (a.name.toLocaleUpperCase() &lt; b.name.toLocaleUpperCase()) { return -1; } } else if (a.name &amp;&amp; !b.name) { return -1; } else if (!a.name &amp;&amp; b.name) { return 1; } if (a.uuid &gt; b.uuid) { return -1; } else { return 1; } } }</code> </pre> <br><p>  Als nächstes leiten wir die Funktion setChatroomMembers im <strong>ChatixSDK weiter</strong> . </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} updateVisitor={this.onUpdateVisitor} /&gt; &lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt; &lt;ChatixSDK ref={this.chatixSDK} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} /&gt; &lt;/div&gt; ); };</code> </pre> <br><p>  Unmittelbar nach dem Herstellen einer Verbindung zum Server fordern wir zusammen mit dem Header eine Liste aller verbundenen Benutzer an und schreiben sie in den Status der <strong>App-</strong> Komponente.  Und ändern Sie auch den Standardwert der Benutzerliste im Status. </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">members: []</code> </pre> <br><p>  Nach genau demselben Prinzip erhalten wir nun das Objekt des aktuellen Benutzers und eine Reihe von Nachrichten und schreiben sie auch in den <strong>App-</strong> Status </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">// lets load 100 last messages from current chatroom const lastMessages = await this.sdk.getChatroomMessages(this.chatroomId, null, 100); if (props.setChatroomMessages) { props.setChatroomMessages(lastMessages); } if (props.setMe) { const me = this.sdk.getVisitor(); this.props.setMe(me); }</code> </pre> <br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatixSDK ref={this.chatixSDK} setMe={this.setMe} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} setChatroomMessages={this.setChatroomMessages} /&gt;</code> </pre> <br><p>  Als nächstes werden wir Nachrichten senden. </p><br><p>  Wir haben in der <strong>App</strong> bereits eine Funktion <code>onSendNewMessage</code> die anzeigt, dass eine Nachricht an die Konsole gesendet wird.  Stattdessen rufen wir einfach die <code>sendChatroomMessage</code> Methode auf, um eine Nachricht vom <strong>ChatixSDK</strong> zu senden. <br>  Dies ist eine asynchrone Methode, die das Objekt der gesendeten Nachricht in der Antwort zurückgibt, die wir dem Nachrichtenarray im Status sofort hinzufügen.  Bitte beachten Sie übrigens, dass wir <code>this.chatixSDK</code> erstellten Link <code>this.chatixSDK</code> . </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">onSendNewMessage = async (message) =&gt; { let receivedMsg = await this.chatixSDK.current.sendChatroomMessage(message); const currentMessages = this.state.messages; currentMessages.push(receivedMsg); const newStateFragment = {messages: currentMessages}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p>  Da eine Änderung des Status dazu führt, dass er erneut gerendert wird, wird die Liste der Nachrichten automatisch aktualisiert.  Wir müssen jedoch sicherstellen, dass beim Hinzufügen von Nachrichten der Bildlauf im Nachrichtenblock nach unten geht. </p><br><p>  Öffnen Sie dazu die <strong>MessageContainer-</strong> Komponente und verwenden Sie den <strong>useEffect-</strong> Hook <strong>,</strong> überwachen Sie das Nachrichtenarray auf Änderungen. Sobald es sich geändert hat und die Nachrichten hinzugefügt wurden, erhalten wir einen <strong>scrollHeight-</strong> Block mit Nachrichten und scrollen um denselben Betrag </p><br><pre> <code class="plaintext hljs">function MessageContainer(props) { const messagesContainer = React.createRef(); useEffect(() =&gt; { messagesContainer.current.scrollTop = messagesContainer.current.scrollHeight }, [props, messagesContainer]); const messageList = props.messages.map(message =&gt; &lt;Message key={message.uuid} sender={props.members.find((member) =&gt; member.uuid === message.sender_id)} message={message} /&gt; ); return ( &lt;section className="MessageContainer" ref={messagesContainer}&gt; {messageList} &lt;/section&gt; ); }</code> </pre> <br><p>  Lassen Sie uns nun die Aktualisierung des Benutzernamens beenden.  Wir haben bereits eine Eingabe in der Kopfzeile angelegt und leiten beim Ändern das aktualisierte Benutzerobjekt an die <strong>App-</strong> Komponente weiter und zeigen es dort in der Konsole an.  Beenden wir diese Funktion.  <code>this.chatixSDK.current.updateVisitor(user)</code> Sie dazu die Methode <code>this.chatixSDK.current.updateVisitor(user)</code> hinzu. <code>this.chatixSDK.current.updateVisitor(user)</code> werden die Daten auf dem Server aktualisiert.  Und aktualisieren Sie einfach die Daten im lokalen Status. Dazu aktualisieren wir das <code>this.state.me</code> Objekt und im <code>this.state.members</code> Array finden <code>this.state.members</code> auch den aktuellen Benutzer und aktualisieren ihn.  Dies ist erforderlich, um den Namen des aktuellen Benutzers in den an ihn gesendeten Nachrichten zu aktualisieren. </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">onUpdateVisitor = (user) =&gt; { this.chatixSDK.current.updateVisitor(user) this.setMe(user) let currentUser = this.state.members.find((member) =&gt; (member.uuid === user.uuid)) let currentUserIndex = this.state.members.indexOf(currentUser) let newMembers = [...this.state.members] newMembers[currentUserIndex] = user; this.setState({ members: newMembers }) }</code> </pre> <br><p>  Jetzt müssen wir lernen, wie wir auf eingehende Nachrichten reagieren, Benutzer verbinden / trennen und Informationen und verbundene Benutzer ändern können. </p><br><p>  Dazu müssen wir in der Datei <strong>ChatixSDK.js</strong> im Konstruktor die Rückruffunktionen überschreiben.  Die vollständige Liste der Funktionen und Argumente finden Sie auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chatix-Core-</a> Projektseite. </p><br><p>  Wir sind <strong>derzeit</strong> an <strong>onChatroomMessageReceived</strong> , <strong>onMemberConnectedToChatroom</strong> , <strong>onMemberDisconnectedFromChatroom</strong> und <strong>onApplyVisitorInfo interessiert</strong> . </p><br><p>  Wir definieren sie neu und rufen für jede Funktion unseren Rückruf auf, den wir in der <strong>App</strong> erstellen. </p><br><pre> <code class="plaintext hljs">this.sdk.onChatroomMessageReceived = (chatroomId, message) =&gt; { if (chatroomId === this.chatroomId) { this.props.onNewMessageReceived(message); } }; this.sdk.onMemberConnectedToChatroom = (chatroomId, member) =&gt; { if (chatroomId === this.chatroomId &amp;&amp; props.addChatroomMember) { this.props.addChatroomMember(member); } }; this.sdk.onMemberDisconnectedFromChatroom = (chatroomId, member) =&gt; { if (chatroomId === this.chatroomId &amp;&amp; props.removeChatroomMember) { this.props.removeChatroomMember(member); } }; this.sdk.onApplyVisitorInfo = (visitor) =&gt; { this.props.onMemberUpdated(visitor) }</code> </pre> <br><p>  Gehen Sie als Nächstes zur <strong>App</strong> und erstellen Sie diese Funktionen. </p><br><p>  <strong>onNewMessageReceived (Nachricht)</strong> <br>  Diese Funktion nimmt ein Nachrichtenobjekt und fügt es einfach zum Status der übrigen Nachrichten hinzu.          ,        . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">onNewMessageReceived = (message) =&gt; { const currentMessages = this.state.messages; currentMessages.push(message); const newStateFragment = {messages: currentMessages}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>App</strong> <br> <strong>addChatroomMember(member)</strong> <br>            state     members.              . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">addChatroomMember = (member) =&gt; { const newStateFragment = {}; const currentMembers = this.state.members; currentMembers.push(member); currentMembers.sort(this.sortMembers); newStateFragment.members = currentMembers; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>App</strong> <br> <strong>removeChatroomMember(memberId)</strong> <br>         state     <strong>members</strong>  <strong>state</strong> . </p><br><pre> <code class="plaintext hljs">removeChatroomMember = (memberId) =&gt; { const currentMembers = this.state.members; const filteredMembers = currentMembers.filter(x=&gt; x.uuid !== memberId); const newStateFragment = {members: filteredMembers}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>onMemberUpdated(updatedMember)</strong> <br>      .        .       <strong>state</strong>     . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">onMemberUpdated = (updatedMember) =&gt; { let oldMember = this.state.members.find(member =&gt; member.uuid === updatedMember.uuid); oldMember = this.state.members.indexOf(oldMember); let newStateMembers = this.state.members; newStateMembers[oldMember] = updatedMember; this.setState({ members: newStateMembers }) }</code> </pre> <br><p>      <strong>ChatixSDK</strong> </p><br><p> <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatixSDK ref={this.chatixSDK} setMe={this.setMe} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} addChatroomMember={this.addChatroomMember} removeChatroomMember={this.removeChatroomMember} setChatroomMessages={this.setChatroomMessages} onNewMessageReceived={this.onNewMessageReceived} onMemberUpdated={this.onMemberUpdated} /&gt;</code> </pre> <br><p>  Fertig       \ ,   ,    /   . </p><br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">alekseyso</a> <br>  Zusätzliche Materialien: <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SDK Chatix ()</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SDK Chatix (npm)</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">192   -</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474492/">https://habr.com/ru/post/de474492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474478/index.html">Synopsis zum maschinellen Lernen. Mathematische Statistik. Maximum-Likelihood-Methode</a></li>
<li><a href="../de474480/index.html">Wie kann man Kinder dazu erziehen, Technologie richtig einzusetzen, wenn es nicht in Ihrer Kindheit war?</a></li>
<li><a href="../de474484/index.html">Mock ist keine Krücke, Mock ist eine Spezifikation</a></li>
<li><a href="../de474488/index.html">Kostenlose Übertragung von DotNext und HolyJS</a></li>
<li><a href="../de474490/index.html">Es ist soweit: Coclean Nasensauger Übersicht</a></li>
<li><a href="../de474494/index.html">Wie war der Zabbix-Gipfel 2019?</a></li>
<li><a href="../de474496/index.html">Datenbanken unter HighLoad ++ 2019</a></li>
<li><a href="../de474498/index.html">JavaFX Tutorial: Hallo Welt</a></li>
<li><a href="../de474500/index.html">Plugin-Entwicklung für Grafana: die Geschichte der Vollkegel</a></li>
<li><a href="../de474502/index.html">Odnoklassniki-Analyse beim Joker 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>