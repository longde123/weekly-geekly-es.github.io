<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèª üßöüèΩ üë©üèª‚Äçü§ù‚Äçüë®üèø Reagieren Sie auf Mehrbenutzer-Chat mit dem Chatix-Backend üë∂üèº ü§∂üèº üë©üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jetzt zeige ich Ihnen, wie Sie einen Chat f√ºr das Team / die Benutzer / Freunde erstellen, wenn Sie kein Backend haben oder keine Zeit damit verbringe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reagieren Sie auf Mehrbenutzer-Chat mit dem Chatix-Backend</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474492/"><p><img src="https://habrastorage.org/getpro/habr/post_images/d7e/212/ac4/d7e212ac471c99b0cd61dd0e75aab281.png" alt="Chatix Chatroom"></p><br><p>  Jetzt zeige ich Ihnen, wie Sie einen Chat f√ºr das Team / die Benutzer / Freunde erstellen, wenn Sie kein Backend haben oder keine Zeit damit verbringen m√∂chten, es zu entwickeln.  Wir werden einen einfachen Text-Chat machen und es wird ungef√§hr eine Stunde dauern. </p><br><p> Es ist fast unm√∂glich, einen funktionierenden Netzwerk-Chat ohne Backend zu schreiben. Er muss in der einen oder anderen Form vorliegen.  Wir werden Chatix und sein JavaScript SDK verwenden.  Chatix und SDK werden sich mit Nachrichtenspeicherung und Netzwerkaufgaben befassen, und wir werden uns um das Front-End k√ºmmern. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der fertige Projektcode ist auf GitHub verf√ºgbar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> </p><a name="habracut"></a><br><h2 id="struktura-proekta">  Projektstruktur </h2><br><ul><li>  App (die Stammkomponente der Anwendung fungiert als State Custodian, da in dieser Lektion weder Redux noch ein anderer State Manager hinzugef√ºgt wird.) <br><ul><li>  Kopfzeile (die Kopfzeile unserer Anwendung, in der das Logo und der Chatname angezeigt werden und der Benutzer seinen Namen schreiben kann) </li><li>  LogoHeader </li><li>  Raumtitel </li><li>  Main </li><li>  MemberList (Chatliste) <br><ul><li>  MemberItem [] </li></ul></li><li>  ChatField (ein Container f√ºr alles, was mit Chat-Nachrichten zu tun hat) <br><ul><li>  Nachrichtencontainer </li><li>  Nachricht [] (Pr√§sentation der Nachricht; in dieser Lektion werden wir nur mit Textnachrichten arbeiten) </li><li>  SendMessageForm (Formular zum Senden einer neuen Chat-Nachricht) </li></ul></li><li>  ChatixSDK (kopflose Komponente, die f√ºr die Arbeit mit dem Backend verantwortlich ist) </li></ul></li></ul><br><blockquote> Wichtiger Hinweis zur Zustandsspeicherung.  Nat√ºrlich w√§re es bequemer, Redux hier hinzuzuf√ºgen und Status√§nderungen zu verarbeiten, aber um Zeit zu sparen, speichern wir den Status in der Stammkomponente der App und leiten Daten an die untergeordneten Komponenten weiter und rufen deren Eltern √ºber die untergeordneten Methoden auf. <br>  Wenn wir zum Beispiel den Namen des Chats erhalten, speichern wir ihn im Status der App-Komponente und <code>App ‚Üí Header ‚Üí RoomTitle</code> ihn durch <code>props</code> : <code>App ‚Üí Header ‚Üí RoomTitle</code> .  Wenn der Benutzer eine Nachricht schreibt, wird diese von SendMessageForm an die App √ºbertragen: <code>SendMessageForm ‚Üí ChatField ‚Üí Main ‚Üí App</code> . </blockquote><p>  Unser Chat wird im Design ungef√§hr so ‚Äã‚Äãaussehen: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d1e/096/b73/d1e096b7349824c510542cc215ae437e.png" alt="chatix.io"></p><br><h2 id="vzaimodeystvie-mezhdu-komponentami">  Interaktion zwischen Komponenten </h2><br><p>  Unsere Komponenten m√ºssen Daten untereinander √ºbertragen. Damit alles ordnungsgem√§√ü funktioniert, legen wir jetzt fest, wie sie miteinander interagieren. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fde/009/821/fde0098218938f714d32a58ad9776ec9.png" alt="Komponenteninteraktion"></p><br><p>  Wie Sie in der Abbildung sehen k√∂nnen, ist die Hauptkomponente f√ºr uns die <code>App</code> , die Daten f√ºr die untergeordneten Komponenten bereitstellt (aufgrund der Reaktivit√§t weisen wir einfach <code>prop</code> und die untergeordnete Komponente reagiert auf √Ñnderungen), und die untergeordneten Komponenten leiten nacheinander Methodenaufrufe an die <code>App</code> .  Dies ist nicht die beste Architektur, die f√ºr ein Produktionsprojekt erstellt werden kann (und sollte), aber f√ºr unsere Lektion. </p><br><h2 id="sozdanie-proekta">  Projekterstellung </h2><br><h3 id="sozdaem-vizualnye-komponenty">  Erstellen Sie visuelle Komponenten </h3><br><h4 id="shapka">  Hut </h4><br><ol><li><p>  Zuerst m√ºssen Sie ein neues Projekt erstellen, daf√ºr verwenden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Create-React-App</a> . </p><br><pre> <code class="plaintext hljs">npx create-react-app chatix-chatroom cd chatix-chatroom</code> </pre> <br><p>  F√ºhren Sie das Projekt mit dem Befehl aus </p><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br></li><li><p>  Beginnen wir mit der Erstellung eines Headers. <br>  F√ºgen Sie der Kopfzeile zun√§chst ein Logo hinzu.  Erstellen Sie dazu im Ordner src den <strong>Komponentenordner</strong> und darin den Ordner <strong>logo_header</strong> .  Wir laden das Logo in diesen Ordner <strong>hoch</strong> und erstellen 2 <strong>Dateien</strong> <strong>LogoHeader.js</strong> und <strong>LogoHeader.css</strong> </p><br></li></ol><br><p>  <strong>LogoHeader.js</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react' import logo from './chatix_logo.svg'; import './LogoHeader.css'; function LogoHeader(){ return ( &lt;div className="LogoHeader"&gt; &lt;img src={logo} className="App-logo" alt="Chatix logo" /&gt; &lt;/div&gt; ); } export default LogoHeader;</code> </pre> <br><p>  <strong>LogoHeader.css</strong> </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.LogoHeader</span></span>{ <span class="hljs-attribute"><span class="hljs-attribute">flex-basis</span></span>: <span class="hljs-number"><span class="hljs-number">200px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-grow</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-shrink</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Hier ist alles klar, in dieser Komponente wird einfach eine Datei mit einem Logo und Stilen importiert. </p><br><p>  Ich werde den Code f√ºr die Stylesheets hier nicht mehr hinzuf√ºgen, Sie k√∂nnen sie auf der Seite des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fertigen Projekts sehen</a> </p><br><p>  Zeigen Sie nun den Namen des Chatrooms an.  Erstellen Sie dazu einen <strong>Raumtitelordner</strong> und darin die <strong>RoomTitle-</strong> Komponente.  Wir werden den Namen durch Requisiten in diese Komponente werfen, also schreiben wir <code>props.chatroomName</code> und √ºbertragen ihn jetzt hierher. </p><br><p>  <strong>Zimmertitel</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './RoomTitle.css'; function RoomTitle(props){ return ( &lt;div className="RoomTitle"&gt; &lt;h1&gt;{props.chatroomName}&lt;/h1&gt; &lt;/div&gt; ); } export default RoomTitle;</code> </pre> <br><p>  Dann erstellen wir die Header-Komponente selbst und platzieren das Logo und den Namen des Chatrooms darin.  Werfen Sie den Chat-Namen sofort √ºber prop <code>chatroomName</code> in die untergeordnete Komponente. </p><br><p>  Ich erinnere Sie daran, dass wir vereinbart haben, dass alle Daten (Anwendungsstatus) von der Stammkomponente der <strong>App</strong> gespeichert werden.  Von dort √ºbertragen wir den Header zuerst in den <strong>Header</strong> und vom <strong>Header</strong> in den <strong>RoomTitle</strong> . </p><br><p>  <strong>Komponenten \ Header \ Header.js</strong> </p><br><p>  <strong>Header.js</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './Header.css' import LogoHeader from '../logo_header/LogoHeader'; import RoomTitle from '../room-title/RoomTitle'; function Header(props) { return ( &lt;header&gt; &lt;LogoHeader/&gt; &lt;RoomTitle chatroomName={props.chatroomName} /&gt; &lt;/header&gt; ); } export default Header;</code> </pre> <br><p>  √ñffnen Sie als <strong>N√§chstes die</strong> Datei <strong>App.js</strong> und f√ºgen Sie die Komponente <strong>Header.js hinzu</strong> . <br>  Dann f√ºgen wir den Namen dem <strong>Status hinzu und</strong> leiten ihn √ºber <strong>Requisiten</strong> an den <strong>Header weiter</strong> . <br>  Au√üerdem m√ºssen Sie in der Kopfzeile den Namen des aktuellen Benutzers hinzuf√ºgen.  F√ºgen Sie dazu das Benutzerobjekt dem Status hinzu und leiten Sie es auf √§hnliche Weise an den Header weiter </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './App.css'; import Header from './components/header/Header'; class App extends React.Component { constructor(props){ super(props); chatroomName: '-', me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } } render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} /&gt; &lt;/div&gt; ); }; } export default App;</code> </pre> <br><p>  Jetzt m√ºssen Sie in der Kopfzeile eine Eingabe mit dem Namen des aktuellen Benutzers hinzuf√ºgen und dem Handler eine √Ñnderung zuweisen, damit wir den neuen Benutzernamen an die <strong>App-</strong> Komponente √ºbertragen k√∂nnen. </p><br><p>  Dazu f√ºgen wir der Eingabe mit dem Namen die <code>handleChangeName</code> Funktion <code>props.updateVisitor</code> und rufen die R√ºckruffunktion <code>props.updateVisitor</code> , in der wir das Benutzerobjekt mit dem aktualisierten Namen √ºbergeben. </p><br><p>  <strong>Header.js</strong> </p><br><pre> <code class="plaintext hljs">function Header(props) { const [name, setName] = useState(props.me.name ? props.me.name : props.me.uuid.substr(-10)) const handleChangeName = (e) =&gt; { setName(e.target.value) let visitor = {...props.me}; visitor.name = e.target.value; props.updateVisitor(visitor) } return ( &lt;header&gt; &lt;LogoHeader/&gt; &lt;RoomTitle chatroomName={props.chatroomName}/&gt; { props.me ? &lt;input className='name-input' value={name} placeholder=' ' onChange={(e) =&gt; handleChangeName(e)} /&gt; : null } &lt;/header&gt; ); }</code> </pre> <br><p>  <code>props.updateVisitor</code> nun diese Funktion <code>props.updateVisitor</code> zur <strong>App hinzu</strong> und <code>props.updateVisitor</code> sie an den <code>props.updateVisitor</code> .  Bisher wird nur das Benutzerobjekt im Status aktualisiert. Anschlie√üend wird der Benutzer auf dem Server aktualisiert. </p><br><pre> <code class="plaintext hljs">onUpdateVisitor = (visitor) =&gt; { this.setState({me: visitor}) }</code> </pre> <br><p>  Jetzt sieht unsere Anwendung so aus und wei√ü bisher nur, wie man den Namen aktualisiert.  Mach weiter </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/685/7ec/243/6857ec2435f476e8d6dad5201d7909a5.png" alt="Chatroom-Header"></p><br><h4 id="saydbar">  Seitenleiste </h4><br><p>  Lassen Sie uns nun eine Seitenleiste erstellen. <br>  Die Seitenleiste befindet sich innerhalb der Hauptkomponente auf der Seite <strong>Main.js.</strong> <br>  Wir erstellen es <strong>Komponenten \ main \ Main.js</strong> , erstellen dann eine Komponente mit einer Liste der Benutzerkomponenten <strong>\ Mitgliedsliste \ MemberList.js</strong> und erstellen sofort eine Komponente, die die Benutzer selbst <strong>Komponenten \ Mitgliedselement \ MemberItem.js anzeigt</strong> . </p><br><p>  Schauen Sie sich die Projektskizze am Anfang des Artikels an, um die Beziehung zwischen diesen drei Komponenten zu verdeutlichen. </p><br><p>  Die Komponenten werden erstellt, jetzt gehen wir in Reihenfolge. <br>  F√ºgen Sie zun√§chst das Benutzerarray zum Status der <strong>App-</strong> Komponente hinzu und f√ºgen Sie die Hauptkomponente hinzu.  Dann werden wir diese Benutzer weiterleiten. </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">class App extends React.Component { constructor(props) { super(props); this.state = { chatroomName: '-', members: [ { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" }, { is_online: true, name: "", uuid: "mnzxcv97zx6chvo" }, { is_online: false, name: "", uuid: "kjuhv987ashdfoua" }, { is_online: false, name: "", uuid: "jdhnf978WEHJSNDL" }, ], me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } }; } render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} /&gt; &lt;Main members={this.state.members} me={this.state.me} /&gt; &lt;/div&gt; ); }; }</code> </pre> <br><p>  <strong>F√ºgen Sie in der</strong> Hauptkomponente die <strong>MemberList-</strong> Komponente hinzu und leiten Sie das Benutzerarray weiter. </p><br><p>  <strong>Main.js</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList members={props.members} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  In der <strong>MemberList-</strong> Komponente <strong>durchlaufen</strong> wir alle Benutzer und geben f√ºr jede R√ºckgabe die <strong>MemberItem-</strong> Komponente zur√ºck und √ºbergeben das Benutzerobjekt an sie. </p><br><p>  <strong>MemberList.js</strong> </p><br><pre> <code class="plaintext hljs">function MemberList(props) { const members = props.members.map((member) =&gt; &lt;MemberItem key={member.uuid} member={member} /&gt; ); return ( &lt;section className="MemberList"&gt; {members} &lt;/section&gt; ); }</code> </pre> <br><p>  Die <strong>MemberItem-</strong> Komponente zeigt den Benutzer bereits direkt in der Seitenleiste an.  Darin √ºberpr√ºfen wir den Namen des Benutzers, falls dieser nicht installiert ist, und zeigen dann die ersten 10 Zeichen des Bezeichners an.  Wir pr√ºfen auch den Status online / offline und vergleichen die Kennung mit der Kennung des aktuellen Benutzers, so dass ihm gegen√ºber die Marke "(Sie)" angezeigt wird. </p><br><pre> <code class="plaintext hljs">function MemberItem(props) { function getName(){ let name = '' if (props.member.uuid === props.me.uuid) { if(props.me.name) { name = props.me.name } else { name = props.me.uuid.substring(props.me.uuid.length-10, props.me.uuid.length); } } else { if(props.member.name){ name = props.member.name } else { name = props.member.uuid.substring(props.member.uuid.length-10, props.member.uuid.length); } } return name; } return( &lt;div className="MemberItem"&gt; &lt;img src={ icon } alt={ props.member.name }/&gt; &lt;span&gt; { getName() } { props.member.uuid === props.me.uuid &amp;&amp; " () " } &lt;/span&gt; { props.member.is_online &amp;&amp; &lt;span className="online"&gt;‚Ä¢&lt;/span&gt; } &lt;/div&gt; ); }</code> </pre> <br><p>  Fertig  Jetzt sieht die Anwendung schon so aus </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eba/512/a8b/eba512a8bca7de4b1487567775f7742b.png" alt="Chatroom-Header"></p><br><h4 id="spisok-soobscheniy-i-forma-otpravki">  Nachrichtenliste und Einreichungsformular </h4><br><p>  Jetzt besch√§ftigen wir uns mit der Nachrichtenliste und dem Sendeformular. <br>  F√ºgen Sie zun√§chst dem Status der <strong>App-</strong> Komponente ein Array mit Nachrichten hinzu. </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">this.state = { chatroomName: '-', messages: [ { content: " 1", sender_id: "mnzxcv97zx6chvo", uuid: "dg897sdfg" }, { content: " 2", sender_id: "98s7dfh9a8s7dhf", uuid: "8723hernm" }, { content: "  ", sender_id: "mnzxcv97zx6chvo", uuid: "435nbcv98234" } ], members: [ { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" }, { is_online: true, name: "", uuid: "mnzxcv97zx6chvo" }, { is_online: false, name: "", uuid: "kjuhv987ashdfoua" }, { is_online: false, name: "", uuid: "jdhnf978WEHJSNDL" }, ], me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } };</code> </pre> <br><p>  Und leiten Sie sie an die Hauptkomponente weiter </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs"> &lt;Main members={this.state.members} messages={this.state.messages} me={this.state.me} /&gt;</code> </pre> <br><p>  Erstellen Sie nun die Komponente <strong>conponents / chat-field / ChatField.js</strong> <br>  Verbinden Sie es mit <strong>Main</strong> und leiten Sie die Nachrichten weiter. </p><br><p>  <strong>Main</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList me={props.me} members={props.members} /&gt; &lt;ChatField messages={props.messages} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  Erstellen Sie als N√§chstes die Komponente <strong>conponents / message-container / MessageContainer.js</strong> <br>  Verbinden Sie es mit <strong>ChatField</strong> und leiten Sie auch Nachrichten an <strong>ChatField</strong> weiter. </p><br><p>  <strong>Chatfield</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList me={props.me} members={props.members} /&gt; &lt;ChatField messages={props.messages} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  Dann werden wir alle Nachrichten durchlaufen und f√ºr jede R√ºckgabe die Komponente, die sie anzeigt. <br>  Lassen Sie es <strong>uns conponents / message / Message.js erstellen</strong> .  Darin zeigen wir das Symbol des Besuchers, seinen Namen oder seine Kennung, wenn der Name nicht angegeben ist, und den Nachrichtentext selbst an. </p><br><p>  <strong>Nachricht</strong> </p><br><pre> <code class="plaintext hljs">function Message(props) { const getSenderName = () =&gt; { if (props.sender) { return props.sender.name ? props.sender.name : props.sender.uuid.substr(-10); } return "Unknown sender"; }; return( &lt;div className="Message"&gt; &lt;div className="message-sender-icon"&gt; &lt;img src={icon} alt="visitor icon"/&gt; &lt;/div&gt; &lt;div className="message-bubble"&gt; &lt;div className="message-sender-name"&gt;{getSenderName()}&lt;/div&gt; &lt;div className="message-content"&gt;{props.message.content}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); }</code> </pre> <br><p>  In einem <strong>MessageContainer durchlaufen wir nun</strong> alle Nachrichten und geben f√ºr jede R√ºckgabe die <strong>Nachrichtenkomponente zur√ºck</strong> , an die wir das Nachrichtenobjekt √ºbergeben </p><br><p>  <strong>Nachrichtencontainer</strong> </p><br><pre> <code class="plaintext hljs">function MessageContainer(props) { const messageList = props.messages.map(message =&gt; &lt;Message key={message.uuid} sender={props.members.find((member) =&gt; member.uuid === message.sender_id)} message={message} /&gt; ); return ( &lt;section className="MessageContainer" ref={messagesContainer}&gt; {messageList} &lt;/section&gt; ); }</code> </pre> <br><p>  Jetzt sieht das Projekt so aus: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/74d/cad/f22/74dcadf22a3086fa2d7182e1aa791cab.png" alt="Chatroom-nachrichten"></p><br><p>  Erstellen Sie nun eine Komponente mit einem Formular zum Senden von Nachrichten. <strong>Components / send-message-form / SendMessageForm.js</strong> .  Darin erstellen wir eine Eingabe und eine Schaltfl√§che zum Senden.  Wenn sich die Eingabe √§ndert, wird der Text in den Status geschrieben, und wenn Sie auf die Schaltfl√§che klicken, rufen wir die R√ºckruffunktion <code>onSendNewMessage</code> und √ºbertragen die Nachricht aus dem Status in den Status.  <code>onSendNewMessage</code> werden die <code>onSendNewMessage</code> Funktion etwas sp√§ter in der <strong>App-</strong> Komponente erstellen und √ºber Requisiten weiterleiten. </p><br><p>  <strong>Meldungsformular senden</strong> </p><br><pre> <code class="plaintext hljs">class SendMessageForm extends React.Component { constructor(props) { super(props); this.state = { message: '' }; } currentMessageChanged = (e) =&gt; { this.setState({message: e.target.value }); } sendMessageClicked = async (e) =&gt; { e.preventDefault(); if (this.state.message.length &gt; 0) { await this.props.onSendNewMessage(this.state.message); this.setState({...this.state, ...{message : ''}}); } } render(){ return ( &lt;section className="SendMessageForm"&gt; &lt;form&gt; &lt;input type="text" value={this.state.message} onChange={this.currentMessageChanged} placeholder="Type message to send"/&gt; &lt;button type="submit" onClick={this.sendMessageClicked} &gt; Send &lt;/button&gt; &lt;/form&gt; &lt;/section&gt; ); } }</code> </pre> <br><p>  Platzieren Sie nun die <strong>SendMessageForm-</strong> Komponente im <strong>ChatField</strong> . </p><br><p>  <strong>Chatfield</strong> </p><br><pre> <code class="plaintext hljs">function ChatField(props) { return( &lt;section className="ChatField"&gt; &lt;MessageContainer members={props.members} messages={props.messages} /&gt; &lt;SendMessageForm onSendNewMessage={props.onSendNewMessage}/&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  In der Hauptkomponente <code>onSendNewMessage</code> wir auch <code>onSendNewMessage</code> Funktion <code>onSendNewMessage</code> im <strong>ChatField weiter</strong> . </p><br><p>  <strong>Main</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatField members={props.members} messages={props.messages} onSendNewMessage={props.onSendNewMessage} /&gt;</code> </pre> <br><p>  Erstellen Sie nun diese Funktion in der <strong>App</strong> und leiten Sie sie an <strong>Main weiter</strong> . </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">onSendNewMessage = async (message) =&gt; { console.log(message) }</code> </pre> <br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">&lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt;</code> </pre> <br><p>  Fertig  Wenn Sie nun auf die Schaltfl√§che Nachricht senden klicken, wird diese an die <strong>App-</strong> Komponente √ºbertragen. <br>  Jetzt sieht die Anwendung so aus: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e53/89e/d31/e5389ed317bd0fb4bf87db34b05f57a6.png" alt="Chatroom f√ºhrt"></p><br><p>  Nun wird alles in unserer Anwendung angezeigt und alles funktioniert wie es sollte, aber bisher mit statischen Daten. Um unseren Chat wiederzubeleben, m√ºssen Sie ihn mit dem Backend verbinden. </p><br><h4 id="podklyuchenie-bekenda">  Backend-Verbindung </h4><br><p>  Dazu installieren Sie zun√§chst das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chatix-Core-</a> Paket. </p><br><pre> <code class="plaintext hljs">npm i chatix-core</code> </pre> <br><p>  Dann erstelle ein Konto bei <strong>Chatix</strong> und erstelle einen Chatraum.  Gehen Sie dazu zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chatix.io</a> und registrieren Sie sich. <br>  Nach der Registrierung k√∂nnen Sie die <strong>websiteId-</strong> Site- <strong>ID</strong> in der Admin-Oberfl√§che auf der Seite mit den Chat-Einstellungen sehen. </p><br><p>  Jetzt erstellen wir einen neuen Chatraum, mit dem wir arbeiten werden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/38b/26d/034/38b26d03464c1b236beff17c4118ba00.png" alt="Chatroom erstellen"></p><br><p>  Wir kehren zu unserem Projekt zur√ºck und erstellen eine neue Komponente, √ºber die wir mit dem Server arbeiten. <br>  <strong>components \ chatix \ ChatixSDK.js</strong> </p><br><p>  Wir importieren <strong>ChatixCore darin.</strong> </p><br><pre> <code class="plaintext hljs">import ChatixCore from 'chatix-core';</code> </pre> <br><p>  <strong>Erstellen Sie</strong> in der <strong>ChatixSDK-</strong> Komponente eine Instanz der <strong>ChatixCore-</strong> Klasse und √ºbergeben Sie die <strong>websiteId</strong> als Argument. </p><br><pre> <code class="plaintext hljs">const websiteId = "_WEBSITE_ID"; this.sdk = new ChatixCore(websiteId);</code> </pre> <br><p>  Jetzt <strong>k√∂nnen</strong> Sie in <strong>this.sdk</strong> die Methoden zum Arbeiten mit dem Chatraum verwenden.  Sie k√∂nnen die Liste der Methoden auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chatix-Core-</a> Projektseite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzeigen</a> </p><br><p>  Als n√§chstes m√ºssen wir eine Verbindung zum Server herstellen und Daten √ºber den zuvor erstellten Chatroom abrufen.  <strong>Hierf√ºr</strong> gibt es asynchrone Methoden <strong>start ()</strong> und <strong>getChatroom ()</strong> . </p><br><p>  Nachdem Sie das Chatroom-Objekt erhalten haben, nehmen wir sofort seinen Namen und √ºbertragen ihn in die <strong>App</strong> .  <code>updateChatroomTitle(chatroom.title)</code> Sie dazu die R√ºckruffunktion <code>updateChatroomTitle(chatroom.title)</code> in die <strong>App ein</strong> und rufen Sie sie im <strong>ChatixSDK auf</strong> . </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">class ChatixSDK extends React.Component { constructor(props){ super(props); const websiteId = "_WEBSITE_ID"; this.chatroomId = "_CHATROOM_ID"; this.sdk = new ChatixCore(websiteId); this.sdk.start() .then( async () =&gt; { try { // refresh information about chatroom and call passed handler const chatroom = await this.sdk.getChatroom(this.chatroomId); if (props.updateChatroomTitle) { props.updateChatroomTitle(chatroom.title); } } catch (err) { console.error(err); } }) .catch((e) =&gt; { console.error(e); }); } render(){ return null; } }</code> </pre> <br><p>  Sie k√∂nnen <code>this.chatroomId</code> in der Manager-Oberfl√§che <code>this.chatroomId</code> , indem Sie den gew√ºnschten Chatroom √∂ffnen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/57d/309/a77/57d309a77bb226589ba225c52cfe37d6.png" alt="ChatroomID"></p><br><p>  Jetzt verbinden wir in der <strong>App</strong> die <strong>ChatixSDK-</strong> Komponente und werfen die updateChatroomTitle-Funktion hinein, die den Chat-Namen aktualisiert.  Wir f√ºgen auch einen <code>ref</code> Link hinzu, damit wir auf diese Komponente zugreifen k√∂nnen. </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">this.chatixSDK = React.createRef();</code> </pre> <br><pre> <code class="plaintext hljs">setChatroomTitle = (newName) =&gt; { const newStateFragment = { chatroomName: newName}; this.setState({...this.state, ...newStateFragment}); };</code> </pre> <br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} updateVisitor={this.onUpdateVisitor} /&gt; &lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt; &lt;ChatixSDK ref={this.chatixSDK} updateChatroomTitle={this.setChatroomTitle} /&gt; &lt;/div&gt; ); };</code> </pre> <br><p>  Fertig  Unmittelbar nach dem Herstellen der Verbindung zum Server fordern wir Chat-Daten an, rufen deren Namen ab und schreiben sie in den Status der <strong>App-</strong> Komponente. Da Status√§nderungen dazu f√ºhren, dass die Komponente erneut gerendert wird, wird der Name in der Kopfzeile automatisch aktualisiert.  Jetzt kann der Standardname im Status durch eine leere Zeichenfolge ersetzt werden. </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">chatroomName: ''</code> </pre> <br><p>  Jetzt f√ºllen wir die Seitenleiste mit echten Benutzern. <br>  Bevor Sie jedoch die Liste der Benutzer erhalten, m√ºssen Sie eine Verbindung zum Chat herstellen. Dazu erhalten Sie im <strong>ChatixSDK</strong> in der Funktion <code>this.sdk.start()</code> eine Liste aller Chatrooms des Benutzers. √úberpr√ºfen Sie, ob diese mit dem aktuellen verbunden sind, und verbinden Sie sie, wenn nicht. </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">const myChatrooms = await this.sdk.getMyChatrooms(); if (myChatrooms.filter(x =&gt; x.id===this.chatroomId).length === 0) { await this.sdk.connectToChatroom(this.chatroomId); }</code> </pre> <br><p>  Nachdem wir sichergestellt haben, dass unser Benutzer mit dem Chat verbunden ist, k√∂nnen wir eine Liste der Teilnehmer dieses Chats abrufen. </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">// lets get all chatroom members using infinite loop with break on empty server response let membersPage = 1; let allChatroomMembers = []; while(true) { let pagedMembers = await this.sdk.getChatroomMembers(this.chatroomId, membersPage++, 10); allChatroomMembers = [...allChatroomMembers, ...pagedMembers]; if (pagedMembers.length === 0) { break; } }</code> </pre> <br><p>  Hier, in einer Endlosschleife, fordern wir Benutzer Seite f√ºr Seite an, bis wir alle erhalten. Sobald wir alle erhalten, unterbrechen wir die Schleife.  Danach leiten wir ihn genau wie den Namen des Chatrooms mithilfe der R√ºckruffunktion an die √ºbergeordnete Komponente weiter. </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">if (props.setChatroomMembers) { props.setChatroomMembers(allChatroomMembers); }</code> </pre> <br><p>  Erstellen Sie nun in der <strong>App-</strong> Komponente die R√ºckruffunktion <code>setChatroomMembers</code> der Benutzer nach ihrem Online- / Offline-Status und alphabetisch sortiert und im Status <code>setChatroomMembers</code> werden. </p><br><p>  <strong>App.js.</strong> </p><br><pre> <code class="plaintext hljs">setChatroomMembers = (members) =&gt; { members.sort(this.sortMembers); const newStateFragment = { members: members}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p>  Sortierfunktion <strong>sortMembers hinzuf√ºgen</strong> .  Es sortiert Benutzer nach Status und alphabetisch. </p><br><p>  <strong>App.js.</strong> </p><br><pre> <code class="plaintext hljs">sortMembers(a, b) { if (a.is_online === true &amp;&amp; b.is_online === false) { return -1; } else if (b.is_online === true &amp;&amp; a.is_online === false) { return 1; } else { if (a.name &amp;&amp; b.name) { if (a.name.toLocaleUpperCase() &gt; b.name.toLocaleUpperCase()) { return 1; } else if (a.name.toLocaleUpperCase() &lt; b.name.toLocaleUpperCase()) { return -1; } } else if (a.name &amp;&amp; !b.name) { return -1; } else if (!a.name &amp;&amp; b.name) { return 1; } if (a.uuid &gt; b.uuid) { return -1; } else { return 1; } } }</code> </pre> <br><p>  Als n√§chstes leiten wir die Funktion setChatroomMembers im <strong>ChatixSDK weiter</strong> . </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} updateVisitor={this.onUpdateVisitor} /&gt; &lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt; &lt;ChatixSDK ref={this.chatixSDK} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} /&gt; &lt;/div&gt; ); };</code> </pre> <br><p>  Unmittelbar nach dem Herstellen einer Verbindung zum Server fordern wir zusammen mit dem Header eine Liste aller verbundenen Benutzer an und schreiben sie in den Status der <strong>App-</strong> Komponente.  Und √§ndern Sie auch den Standardwert der Benutzerliste im Status. </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">members: []</code> </pre> <br><p>  Nach genau demselben Prinzip erhalten wir nun das Objekt des aktuellen Benutzers und eine Reihe von Nachrichten und schreiben sie auch in den <strong>App-</strong> Status </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">// lets load 100 last messages from current chatroom const lastMessages = await this.sdk.getChatroomMessages(this.chatroomId, null, 100); if (props.setChatroomMessages) { props.setChatroomMessages(lastMessages); } if (props.setMe) { const me = this.sdk.getVisitor(); this.props.setMe(me); }</code> </pre> <br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatixSDK ref={this.chatixSDK} setMe={this.setMe} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} setChatroomMessages={this.setChatroomMessages} /&gt;</code> </pre> <br><p>  Als n√§chstes werden wir Nachrichten senden. </p><br><p>  Wir haben in der <strong>App</strong> bereits eine Funktion <code>onSendNewMessage</code> die anzeigt, dass eine Nachricht an die Konsole gesendet wird.  Stattdessen rufen wir einfach die <code>sendChatroomMessage</code> Methode auf, um eine Nachricht vom <strong>ChatixSDK</strong> zu senden. <br>  Dies ist eine asynchrone Methode, die das Objekt der gesendeten Nachricht in der Antwort zur√ºckgibt, die wir dem Nachrichtenarray im Status sofort hinzuf√ºgen.  Bitte beachten Sie √ºbrigens, dass wir <code>this.chatixSDK</code> erstellten Link <code>this.chatixSDK</code> . </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">onSendNewMessage = async (message) =&gt; { let receivedMsg = await this.chatixSDK.current.sendChatroomMessage(message); const currentMessages = this.state.messages; currentMessages.push(receivedMsg); const newStateFragment = {messages: currentMessages}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p>  Da eine √Ñnderung des Status dazu f√ºhrt, dass er erneut gerendert wird, wird die Liste der Nachrichten automatisch aktualisiert.  Wir m√ºssen jedoch sicherstellen, dass beim Hinzuf√ºgen von Nachrichten der Bildlauf im Nachrichtenblock nach unten geht. </p><br><p>  √ñffnen Sie dazu die <strong>MessageContainer-</strong> Komponente und verwenden Sie den <strong>useEffect-</strong> Hook <strong>,</strong> √ºberwachen Sie das Nachrichtenarray auf √Ñnderungen. Sobald es sich ge√§ndert hat und die Nachrichten hinzugef√ºgt wurden, erhalten wir einen <strong>scrollHeight-</strong> Block mit Nachrichten und scrollen um denselben Betrag </p><br><pre> <code class="plaintext hljs">function MessageContainer(props) { const messagesContainer = React.createRef(); useEffect(() =&gt; { messagesContainer.current.scrollTop = messagesContainer.current.scrollHeight }, [props, messagesContainer]); const messageList = props.messages.map(message =&gt; &lt;Message key={message.uuid} sender={props.members.find((member) =&gt; member.uuid === message.sender_id)} message={message} /&gt; ); return ( &lt;section className="MessageContainer" ref={messagesContainer}&gt; {messageList} &lt;/section&gt; ); }</code> </pre> <br><p>  Lassen Sie uns nun die Aktualisierung des Benutzernamens beenden.  Wir haben bereits eine Eingabe in der Kopfzeile angelegt und leiten beim √Ñndern das aktualisierte Benutzerobjekt an die <strong>App-</strong> Komponente weiter und zeigen es dort in der Konsole an.  Beenden wir diese Funktion.  <code>this.chatixSDK.current.updateVisitor(user)</code> Sie dazu die Methode <code>this.chatixSDK.current.updateVisitor(user)</code> hinzu. <code>this.chatixSDK.current.updateVisitor(user)</code> werden die Daten auf dem Server aktualisiert.  Und aktualisieren Sie einfach die Daten im lokalen Status. Dazu aktualisieren wir das <code>this.state.me</code> Objekt und im <code>this.state.members</code> Array finden <code>this.state.members</code> auch den aktuellen Benutzer und aktualisieren ihn.  Dies ist erforderlich, um den Namen des aktuellen Benutzers in den an ihn gesendeten Nachrichten zu aktualisieren. </p><br><p>  <strong>Die App</strong> </p><br><pre> <code class="plaintext hljs">onUpdateVisitor = (user) =&gt; { this.chatixSDK.current.updateVisitor(user) this.setMe(user) let currentUser = this.state.members.find((member) =&gt; (member.uuid === user.uuid)) let currentUserIndex = this.state.members.indexOf(currentUser) let newMembers = [...this.state.members] newMembers[currentUserIndex] = user; this.setState({ members: newMembers }) }</code> </pre> <br><p>  Jetzt m√ºssen wir lernen, wie wir auf eingehende Nachrichten reagieren, Benutzer verbinden / trennen und Informationen und verbundene Benutzer √§ndern k√∂nnen. </p><br><p>  Dazu m√ºssen wir in der Datei <strong>ChatixSDK.js</strong> im Konstruktor die R√ºckruffunktionen √ºberschreiben.  Die vollst√§ndige Liste der Funktionen und Argumente finden Sie auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chatix-Core-</a> Projektseite. </p><br><p>  Wir sind <strong>derzeit</strong> an <strong>onChatroomMessageReceived</strong> , <strong>onMemberConnectedToChatroom</strong> , <strong>onMemberDisconnectedFromChatroom</strong> und <strong>onApplyVisitorInfo interessiert</strong> . </p><br><p>  Wir definieren sie neu und rufen f√ºr jede Funktion unseren R√ºckruf auf, den wir in der <strong>App</strong> erstellen. </p><br><pre> <code class="plaintext hljs">this.sdk.onChatroomMessageReceived = (chatroomId, message) =&gt; { if (chatroomId === this.chatroomId) { this.props.onNewMessageReceived(message); } }; this.sdk.onMemberConnectedToChatroom = (chatroomId, member) =&gt; { if (chatroomId === this.chatroomId &amp;&amp; props.addChatroomMember) { this.props.addChatroomMember(member); } }; this.sdk.onMemberDisconnectedFromChatroom = (chatroomId, member) =&gt; { if (chatroomId === this.chatroomId &amp;&amp; props.removeChatroomMember) { this.props.removeChatroomMember(member); } }; this.sdk.onApplyVisitorInfo = (visitor) =&gt; { this.props.onMemberUpdated(visitor) }</code> </pre> <br><p>  Gehen Sie als N√§chstes zur <strong>App</strong> und erstellen Sie diese Funktionen. </p><br><p>  <strong>onNewMessageReceived (Nachricht)</strong> <br>  Diese Funktion nimmt ein Nachrichtenobjekt und f√ºgt es einfach zum Status der √ºbrigen Nachrichten hinzu.          ,        . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">onNewMessageReceived = (message) =&gt; { const currentMessages = this.state.messages; currentMessages.push(message); const newStateFragment = {messages: currentMessages}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>App</strong> <br> <strong>addChatroomMember(member)</strong> <br>            state     members.              . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">addChatroomMember = (member) =&gt; { const newStateFragment = {}; const currentMembers = this.state.members; currentMembers.push(member); currentMembers.sort(this.sortMembers); newStateFragment.members = currentMembers; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>App</strong> <br> <strong>removeChatroomMember(memberId)</strong> <br>         state     <strong>members</strong>  <strong>state</strong> . </p><br><pre> <code class="plaintext hljs">removeChatroomMember = (memberId) =&gt; { const currentMembers = this.state.members; const filteredMembers = currentMembers.filter(x=&gt; x.uuid !== memberId); const newStateFragment = {members: filteredMembers}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>onMemberUpdated(updatedMember)</strong> <br>      .        .       <strong>state</strong>     . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">onMemberUpdated = (updatedMember) =&gt; { let oldMember = this.state.members.find(member =&gt; member.uuid === updatedMember.uuid); oldMember = this.state.members.indexOf(oldMember); let newStateMembers = this.state.members; newStateMembers[oldMember] = updatedMember; this.setState({ members: newStateMembers }) }</code> </pre> <br><p>      <strong>ChatixSDK</strong> </p><br><p> <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatixSDK ref={this.chatixSDK} setMe={this.setMe} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} addChatroomMember={this.addChatroomMember} removeChatroomMember={this.removeChatroomMember} setChatroomMessages={this.setChatroomMessages} onNewMessageReceived={this.onNewMessageReceived} onMemberUpdated={this.onMemberUpdated} /&gt;</code> </pre> <br><p>  Fertig       \ ,   ,    /   . </p><br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">alekseyso</a> <br>  Zus√§tzliche Materialien: <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SDK Chatix ()</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SDK Chatix (npm)</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">192   -</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474492/">https://habr.com/ru/post/de474492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474478/index.html">Synopsis zum maschinellen Lernen. Mathematische Statistik. Maximum-Likelihood-Methode</a></li>
<li><a href="../de474480/index.html">Wie kann man Kinder dazu erziehen, Technologie richtig einzusetzen, wenn es nicht in Ihrer Kindheit war?</a></li>
<li><a href="../de474484/index.html">Mock ist keine Kr√ºcke, Mock ist eine Spezifikation</a></li>
<li><a href="../de474488/index.html">Kostenlose √úbertragung von DotNext und HolyJS</a></li>
<li><a href="../de474490/index.html">Es ist soweit: Coclean Nasensauger √úbersicht</a></li>
<li><a href="../de474494/index.html">Wie war der Zabbix-Gipfel 2019?</a></li>
<li><a href="../de474496/index.html">Datenbanken unter HighLoad ++ 2019</a></li>
<li><a href="../de474498/index.html">JavaFX Tutorial: Hallo Welt</a></li>
<li><a href="../de474500/index.html">Plugin-Entwicklung f√ºr Grafana: die Geschichte der Vollkegel</a></li>
<li><a href="../de474502/index.html">Odnoklassniki-Analyse beim Joker 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>