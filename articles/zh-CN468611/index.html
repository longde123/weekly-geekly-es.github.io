<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☘️ ⚰️ 😱 .NET多线程：缺乏性能时 🦑 🤱🏼 📱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".NET平台提供了许多预构建的同步原语和线程安全的集合。 例如，如果在开发应用程序时需要实现线程安全的缓存或请求队列，则通常使用这些现成的解决方案，有时一次使用多个解决方案。 在某些情况下，这会导致性能问题：长时间等待锁，过多的内存消耗和漫长的垃圾回收。 

 如果考虑到标准解决方案的通用性，则可以...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET多线程：缺乏性能时</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/468611/"><img src="https://habrastorage.org/webt/rn/su/tj/rnsutjjvg7sllluahknu8brlnbc.jpeg"><br><br>  .NET平台提供了许多预构建的同步原语和线程安全的集合。 例如，如果在开发应用程序时需要实现线程安全的缓存或请求队列，则通常使用这些现成的解决方案，有时一次使用多个解决方案。 在某些情况下，这会导致性能问题：长时间等待锁，过多的内存消耗和漫长的垃圾回收。 <br><br> 如果考虑到标准解决方案的通用性，则可以解决这些问题-在我们的方案中，它们可能会有多余的开销。 因此，您可以针对特定情况编写例如自己的有效线程安全集合。 <br><br> 过场动画是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DotNext</a>会议报告的视频和抄本，在其中，我分析了使用标准.NET库中的工具（Task.Delay，SemaphoreSlim，ConcurrentDictionary）导致性能下降的一些示例，我提出了针对特定任务量身定制的解决方案，这些缺点。 <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-tNeYjRNJtY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 在撰写报告时，他曾在Kontur工作。  Kontur开发了各种业务应用程序，而我工作的团队与基础架构打交道，并开发了各种支持服务和库，以帮助其他团队的开发人员创建产品服务。 <br><br> 基础架构团队构建其数据仓库，用于Windows的应用程序托管系统以及用于开发微服务的各种库。 我们的应用程序基于微服务体系结构-所有服务都通过网络相互交互，当然，它们使用大量异步和多线程代码。 其中一些应用程序对性能至关重要；它们需要能够处理许多请求。 <br><br> 今天我们要谈什么？ <br><br><ul><li>  .NET中的多线程和异步； </li><li> 填充同步原语和集合； </li><li> 如果标准方法无法应付负载怎么办？ </li></ul><br> 让我们分析在.NET中使用多线程和异步代码的一些功能。 让我们看一些同步原语和并发集合，看看它们是如何安排在内部的。 我们将讨论如果没有足够的性能，标准类无法应付负载以及在这种情况下是否可以解决问题时该怎么办。 <br><br> 我将告诉您我们生产现场发生的四个故事。 <br><br><h2> 历史记录1：Task.Delay和TimerQueue </h2><br> 这个故事已经很广为人知，包括在以前的DotNext上有关它的故事。 但是，它有一个相当有趣的续集，因此我添加了它。 那有什么意义呢？ <br><br><h3>  1.1轮询和长时间轮询 </h3><br> 服务器执行长时间的操作，客户端等待它们。 <br>  <b>轮询：</b>客户端定期向服务器询问结果。 <br>  <b>长轮询：</b>客户端发送超时请求，服务器在操作完成后做出响应。 <br><br> 优点： <br><br><ul><li> 交通减少 </li><li> 客户更快地了解结果 </li></ul><br> 想象一下，我们有一个可以处理一些长请求的服务器，例如，一个将XML文件转换为PDF的应用程序，并且有一些客户端运行这些任务进行处理，并希望异步等待其结果。 如何实现这种期望？ <br><br> 第一种方法是<b>轮询</b> 。 客户端在服务器上启动任务，然后定期检查此任务的状态，而服务器则返回任务的状态（“已完成” /“未完成” /“已完成但有错误”）。 客户端定期发送请求，直到结果出现。 <br><br> 第二种方法是<b>长时间轮询</b> 。 此处的区别在于客户端发送的请求超时。 接收到此类请求的服务器将不会立即报告该任务尚未完成，而是会尝试等待一段时间才能显示结果。 <br> 那么长轮询比常规轮询有什么优势？ 首先，产生的流量较少。 我们发出较少的网络请求-通过网络追踪的流量减少。 而且，与常规轮询相比，客户端将能够更快地找到结果，因为客户端无需等待多个轮询请求之间的间隔。 我们想要得到的是可以理解的。 我们将如何在代码中实现呢？ <br><blockquote> 任务：超时 <br> 我们想等待任务超时 <br> 等待SendAsync（）; </blockquote> 例如，我们有一个Task向服务器发送请求，我们想等待超时的结果，也就是说，我们要么返回此Task的结果，要么发送某种错误。  C＃代码将如下所示： <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sendTask = SendAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delayTask = Task.Delay(timeout); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(sendTask, delayTask); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task == delayTask) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Timeout;</code> </pre> <br> 这段代码启动了我们要等待其结果的Task和Task.Delay。 接下来，使用Task.WhenAny，我们正在等待Task或Task.Delay。 如果事实证明Task.Delay首先执行，那么时间到了，我们超时了，我们必须返回一个错误。 <br><br> 当然，此代码不是完美的，可以改进。 例如，如果SendAsync较早返回，取消Task.Delay不会有什么坏处，但是现在对于我们来说这不是很有趣。 底线是，如果我们编写这样的代码并将其应用于长时间超时的长时间轮询，则会遇到一些性能问题。 <br><br><h3>  1.2长轮询问题 </h3><br><ul><li> 大超时 </li><li> 许多并发查询 </li><li>  =&gt;高CPU使用率 </li></ul><br> 在这种情况下，问题在于处理器资源的高消耗。 可能会发生处理器100％满载的情况，并且应用程序通常会停止运行。 似乎我们根本不消耗处理器资源：我们执行一些异步操作，等待服务器的响应，并且处理器仍被加载。 <br><br> 遇到这种情况时，我们从应用程序中删除了内存转储： <br><br><pre> <code class="cs hljs"> ~*e!clrstack System.Threading.Monitor.Enter(System.Object) System.Threading.TimerQueueTimer.Change(…) System.Threading.Timer.TimerSetup(…) System.Threading.Timer..ctor(…) System.Threading.Tasks.Task.Delay(…)</code> </pre> <br> 为了分析转储，我们使用了WinDbg工具。 我们输入了一个显示所有托管线程的堆栈跟踪的命令，并看到了这样的结果。 我们有很多线程正在等待锁。  Monitor.Enter方法是C＃中的锁构造扩展到的方法。 该锁在称为Timer和TimerQueueTimer的类中捕获。 在Timer中，当我们尝试创建它们时，我们来自Task.Delay。 怎么了  Task.Delay启动时，将捕获TimerQueue内部的锁。 <br><br><h3>  1.3锁车队 </h3><br><ul><li> 许多线程试图锁定一个锁 </li><li> 在锁下，很少执行代码 </li><li> 时间花费在线程同步上，而不是代码执行上。 </li><li> 线程块被阻止-它们不是无限的 </li></ul><br> 在应用程序中，我们有一个锁车队。 许多线程试图捕获相同的锁。 在此锁下，将执行大量代码。 此处的处理器资源不是花在应用程序代码本身上，而是花在在此锁上同步它们之间的线程的操作上。 还应注意与.NET相关的功能：参与锁保护的线程是线程池中的线程。 <br><br> 因此，如果线程池中的线程被阻塞，它们可能会终止-线程池中的线程数受到限制。 可以配置，但是仍然有上限。 到达线程池之后，所有线程池线程都将参与锁定进程，并且涉及线程池的任何代码都将在应用程序中停止执行。 这大大恶化了局势。 <br><br><h3>  1.4 TimerQueue </h3><br><ul><li> 管理.NET应用程序中的计时器。 </li><li> 计时器用于： <br>  -Task.Delay <br>  -CancellationTocken.CancelAfter <br>  -HttpClient </li></ul><br>  TimerQueue是一个类，用于管理.NET应用程序中的所有计时器。 如果您曾经在WinForms中编程过，则可能是手动创建了计时器。 对于那些不知道计时器是什么的人：它们在Task.Delay中使用（这只是我们的情况），它们也在CancellationToken方法的CancelAfter方法中使用。 也就是说，用CancellationToken.CancelAfter替换Task.Delay不会对我们有任何帮助。 此外，许多内部.NET类（例如HttpClient）中都使用了计时器。 <br><br> 据我所知，HttpClient处理程序的某些实现都有计时器。 即使您没有明确使用它们，也不要启动Task.Delay，很可能仍然仍然使用它们。 <br><br> 现在让我们看一下TimerQueue的内部排列方式。 <br><br><ul><li> 全局状态（每个应用程序域）： <br>  -TimerQueueTimer的双链表 <br>  -锁定对象 </li><li> 常规计时器回调 </li><li> 计时器未按响应时间排序 </li><li> 添加计时器：O（1）+锁定 </li><li> 移除计时器：O（1）+锁定 </li><li> 启动计时器：O（N）+锁定 </li></ul><br> 在TimerQueue内部有一个全局状态，它是TimerQueueTimer类型的对象的双向链接列表。  TimerQueueTimer包含一个到其他TimerQueueTimer的链接，该链接在链表中相邻，还包含计时器和回调的时间，当计时器启动时将调用该时间。 这个双重链接列表受一个锁对象的保护，而该锁对象只是在我们的应用程序中发生锁护卫的对象。 在TimerQueue中也有一个例程，该例程启动与我们的计时器相关的回调。 <br><br> 计时器决不会按响应时间排序，整个结构已针对添加/删除新计时器进行了优化。  Routine启动时，它将遍历整个双向链表，选择应该工作的计时器，然后将其回调。 <br><br> 操作的复杂性就是这样。 添加和删​​除计时器会在每个单元中发生O，计时器的启动会在每行中发生。 而且，如果在算法复杂性方面一切都可以接受，则存在一个问题：所有这些操作都捕获了锁，这不是很好。 <br><br> 会发生什么情况？ 我们在TimerQueue中积累了太多的计时器，因此，当Routine启动时，它将锁定其长时间的线性操作，那时那些尝试启动或从TimerQueue中删除计时器的人无法对其进行任何操作。 因此，将发生锁定车队。  .NET Core中已解决此问题。 <br><blockquote> 减少计时器锁定争用（coreclr＃14527） <br><ul><li> 锁定分片 <br>  -Environment.ProcessorCount TimerQueue的TimerQueueTimer </li><li> 短/长寿命计时器的单独队列 </li><li> 短计时器：时间&lt;= 1/3秒 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/dotnet/coreclr/issues/14462</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/dotnet/coreclr/pull/14527</a> <br></blockquote> 它是如何固定的？ 他们突击了TimerQueue：而不是一个TimerQueue（对于整个AppDomain都是静态的），对于整个应用程序，创建了多个TimerQueue。 当线程到达那里并尝试启动它们的计时器时，这些计时器将落入随机的TimerQueue中，并且线程碰撞一次锁的机会较小。 <br><br> 还在.NET Core中应用了一些优化。 计时器分为长寿命和短寿命，现在分别为它们使用TimerQueue。 短时计时器选择为小于1/3秒。 我不知道为什么选择了这样一个常数。 在.NET Core中，我们无法捕获计时器问题。 <br><br><img src="https://habrastorage.org/webt/f_/am/cv/f_amcv6bohiq54ciyuunvtrr0ei.jpeg"><br><br>  <a href="">https://github.com/Microsoft/dotnet-framework-early-access/blob/master/release-notes/NET48/dotnet-48-changes.md</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/dotnet/coreclr/labels/netfx-port-consider</a> <br><br> 此修复程序已反向移植到.NET Framework 4.8版。 上面的链接中指示了netfx-port-consider标记，如果转到.NET Core，CoreCLR，CoreFX存储库，则可以搜索将被反向移植到.NET Framework的问题，现在大约有五十个。 也就是说，开源.NET起到了很大的作用，修复了许多错误。 您可以阅读changelog .NET Framework 4.8：已修复了许多错误，比其他.NET版本中的错误要多得多。 有趣的是，此修补程序在.NET Framework 4.8中默认为关闭。 它包含在您称为App.config的整个文件中 <br><br>  App.config中启用此修复程序的设置称为UseNetCoreTimer。 在.NET Framework 4.8发行之前，为了使我们的应用程序能够正常工作而不进入锁定状态，您必须使用Task.Delay的实现。 在其中，我们尝试使用二进制堆来更有效地了解现在应该调用哪个计时器。 <br><br><h3>  1.5 Task.Delay：本机实现 </h3><br><ul><li> 二进制堆 </li><li> 分片 </li><li> 它有所帮助，但并非在所有情况下 </li></ul><br> 使用二进制堆使您可以优化调用回调的例程，但会使从队列中删除任意计时器所需的时间更糟-为此，您需要重建堆。 这很可能就是.NET使用双向链表的原因。 当然，仅使用二进制堆对我们没有帮助，我们还必须计算TimerQueue。 该解决方案工作了一段时间，但由于计时器不仅在代码中显式运行的地方使用，而且在第三方库和.NET代码中也使用，因此，它仍然再次陷入锁定困境。 若要完全解决此问题，您必须升级到.NET Framework 4.8版并启用.NET开发人员的修复程序。 <br><br><h3>  1.6 Task.Delay：结论 </h3><br><ul><li> 到处都是陷阱-即使是最常用的东西 </li><li> 做压力测试 </li><li> 切换到核心，首先获取错误修复（和新错误）:) </li></ul><br> 整个故事的结论是什么？ 首先，陷阱实际上可以摆在任何地方，即使在您每天都在不加思考的类中使用，例如，相同的Task，Task.Delay。 <br><br> 我建议对您的提案进行压力测试。 我们刚刚在负载测试阶段发现了这个问题。 然后，我们在其他应用程序的生产中将其拍摄了数次，但是，压力测试帮助我们延迟了在实际遇到此问题之前的时间。 <br><br> 切换到.NET Core-您将是第一个接收bug修复（和新bug）的人。 哪里没有新错误？ <br><br> 关于计时器的故事已经结束，我们继续进行下一个。 <br><br><h2> 故事2：SemaphoreSlim </h2><br> 以下是有关著名的SemaphoreSlim的故事。 <br><br><h3>  2.1服务器限制 </h3><br><ul><li> 需要限制服务器上并发处理的请求数 </li></ul><br> 我们想在服务器上实现限制。 这是什么 也许大家都知道CPU的节流阀：当处理器过热时，它会降低冷却频率，这会限制其性能。 就在这里。 我们知道我们的服务器可以并行处理N个请求，并且不会失败。 我们想做什么？ 将同时处理的请求数限制为该常数，并使其保持不变，以便在有更多请求时，它们排队并等待直到执行较早的那些请求。 这个问题怎么解决？ 有必要使用某种同步原语。 <br><br>  Semaphore是一个同步原语，您可以在其上等待N次，此后首先到达N +的人将一直等待，直到更早进入它的人释放Semaphore。 事实证明是这样的：两个执行线程，两个工作人员进入了信号量管理系统，其余人员排队。 <br><br><img src="https://habrastorage.org/webt/6s/bu/h7/6sbuh77p4temzi5yiofjlh-rxoi.png"><br><br> 当然，只是Semaphore不适合我们，它在.NET同步中，因此我们采用SemaphoreSlim并编写了以下代码： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(N); … <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> semaphore.WaitAsync(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> HandleRequestAsync(request); semaphore.Release();</code> </pre> <br> 我们创建SemaphoreSlim，然后等待，在Semaphore下处理您的请求，然后释放Semaphore。 看来这是服务器限制的理想实现，并且再也不能做得更好。 但是，一切都更加复杂。 <br><br><h3>  2.2服务器限制：复杂 </h3><br><ul><li> 按LIFO顺序处理请求 </li><li> 信号量 </li><li> 并发堆栈 </li><li>  TaskCompletionSource </li></ul><br> 我们忘记了一些业务逻辑。 节流的请求是真实的http请求。 通常，他们有一些超时时间（由自动发送此请求的用户设置），或者是一段时间后按F5的用户设置的超时时间。 因此，如果您按照常规信号量之类的队列顺序处理请求，则首先可能已经处理了来自队列的所有那些超时请求。 如果按堆栈顺序工作-首先处理最后出现的所有请求，则不会出现此类问题。 <br><br> 除了SemaphoreSlim之外，我们还必须使用ConcurrentStack，TaskCompletionSource围绕这些内容包装很多代码，以便所有内容都能按我们需要的顺序工作。  TaskCompletionSource就是这样，它与CancellationTokenSource类似，但与CancellationToken无关，但与Task相似。 您可以创建一个TaskCompletionSource，从中提取一个Task，分发出去，然后告诉TaskCompletionSource您需要为该Task设置结果，等待该Task的人将了解此结果。 <br><br> 我们都实现了它。 代码太糟糕了。 最糟糕的是，结果证明它无法正常工作。 <br><br> 在相当重的应用程序中开始使用它的几个月后，我们遇到了一个问题。 与以前的情况相同，CPU消耗已增加到100％。 我们进行了相同的操作，删除了转储，在WinDbg中对其进行了查看，然后再次找到了锁车队。 <br><br><img src="https://habrastorage.org/webt/h_/ef/as/h_efasuul34r0fm7vwopo2hm1bc.jpeg"><br><br> 这次，Lock车队发生在SemaphoreSlim.WaitAsync和SemaphoreSlim.Release内部。 事实证明，SemaphoreSlim内部有一个锁，它不是无锁的。 事实证明，这对我们来说是一个相当严重的缺点。 <br><br><img src="https://habrastorage.org/webt/0h/-k/qq/0h-kqqxojlujm3dglokmacabvwq.jpeg"><br><br> 在SemaphoreSlim内部，存在一个内部状态（一个计数器，该计数器仍可以查看有多少工作人员），以及等待该信号灯的人员的双链表。 这里的想法是相同的：您可以在此信号量上等待，可以取消期望-离开此队列。 有一把锁刚刚毁了我们的生活。 <br><br>  :    ,    . <br><br><img src="https://habrastorage.org/webt/ax/ls/3i/axls3iseuxmgjt-vqkeiqs7hvtq.jpeg"><br><br>    Semaphore,    lock-free        .       . <br><br><img src="https://habrastorage.org/webt/rv/rg/wv/rvrgwv8apebibtiymhxpvm5giti.jpeg"><br><br>   .    currentCount —       Semaphore.    Semaphore  ,        ,     .   ConcurrentStack,   TaskCompletionSource' —     waiter',       .   WaitAsync. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> decrementedCount = Interlocked.Decrement(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (decrementedCount &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.CompletedTask; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(); waiters.Push(waiter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waiter.Task;</code> </pre> <br>    ,      Semaphore,      ,   : «,    Semaphore». <br><br>    Semaphore  ,   TaskCompletionSource,     waiter'      Task'.   ,  Task' ,          Semaphore. <br><br>    Release. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> countBefore = Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countBefore &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waiters.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> waiter)) waiter.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Release   : <br><br><ul><li>     Semaphore </li><li>  currentCount </li></ul><br>   currentCount  ,     waiter',    ,   waiter'     .  waiter —  TaskCompletionSource.    :    ,    ?    ?  ,   ,   continuation'  TaskCompletionSource'. <br><br><img src="https://habrastorage.org/webt/_1/zo/hu/_1zohu07rqeiemrkwrcubv7gwhe.png"><br><br>   .   TaskCompletionSource    Task'.  Task  ,    TaskCompletionSource,      .  Task    TaskCompletionSource,   Task',        . <br><br>   ? Task 2      ,    — continuation,  Thread.Sleep.    TaskCompletionSource,  continuation     ,     Task. ,   Task'   ,       . <br><br>  ,     ,        , continuation         .    continuation      ,    —    —   . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;( TaskCreationOptions.RunContinuationsAsynchronously); <span class="hljs-comment"><span class="hljs-comment">/* OR */</span></span> Task.Run(() =&gt; tcs.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>));</code> </pre> <br>         TaskCompletionSource    RunContinuationsAsynchronously,    TrySetResult  Task.Run/ThreadPool.QueueUserWorkItem,       .       ,      side effect'.     ,    . <br><br><img src="https://habrastorage.org/webt/m9/x8/gx/m9x8gxz7x5tw3mjcps7nygdmkjs.jpeg"><br><br>    WaitAsync  Release      Release   . <br><br>  ,     .   . <br><br><img src="https://habrastorage.org/webt/cs/1e/4q/cs1e4q3yaz4d3084_24z2ucsd6y.jpeg"><br><br>    ,    WaitAsync    .         waiter'  .   ,  Release     ,    ,       .   ,    Release   waiter'  . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> countBefore = Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countBefore &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Waiter waiter; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spinner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!waiter.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> waiter)) spinner.SpinOnce(); waiter.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>      ,       .       ,   SpinWait. <br><br>         .    , waiter    ,      Thread.Sleep,       CPU. <br><br>   , Semaphore  LIFO- —     . <br><blockquote> <b>LowLevelLifoSemaphore</b> <br><ul><li>  </li><li>  Windows     Windows IO Completion port </li></ul><br> <a href="">https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Threading/LowLevelLifoSemaphore.cs</a> </blockquote>  Semaphore    .NET,    CoreCLR,   CoreFX,   CoreRT.        .NET.   Semaphore   LowLevelLifoSemaphore.  Semaphore      :  . <br><br>  ,  Windows    IO Completion-.    ,      ,         LIFO-.    ,   LowLevel. <br><br><h3> 2.3 : </h3><br><ul><li>  ,        </li><li>    ,    </li><li>      </li><li>   </li></ul><br>      ? -,  ,  -   ,      ,    .    ,  SemaphoreSlim ,        . <br><br>       Semaphore   . ,     .      SemaphoreSlim,    ,     . <br><br>  ,    ,     . <br><br> .NET  ,           —   .        lock,  : «    ?»     CPU 100%,     lock', , ,   -  .NET.      . <br><br>    . <br><br><h2>  3: (A)sync IO </h2><br>    /,      . <br><br><img src="https://habrastorage.org/webt/84/qh/sz/84qhsz9je7twmgbswt5so0dfx2q.jpeg"><br><br>    lock convoy,    stack trace     Overlapped  PinnableBufferCache.   lock.     : Overlapped  PinnableBufferCache? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OVERLAPPED</a> —    Windows,      /.      ,        .        ,  .       ,     lock convoy.   ,      lock convoy,    ,   . <br><br><img src="https://habrastorage.org/webt/if/j_/fc/ifj_fclqmvkfgfff7zedxpj63mo.jpeg"><br><br>  ,       ,   .NET 4.5.1  4.5.2.     .NET 4.5.2,     ,    .NET 4.5.2.  .NET 4.5.1     OverlappedDataCache,      Overlapped — ,       ,   .    ,  lock-free,   ConcurrentStack,       .  .NET 4.5.2     :  OverlappedDataCache   PinnableBufferCache. <br><br>   ? PinnableBufferCache     ,   Overlapped     ,    ,       —      . ,     ,      . PinnableBufferCache     .   , lock-free,   ConcurrentStack.     ,      .        ,        ,  -    lock-free    list  lock'. <br><br><h3> 3.1 PinnableBufferCache </h3><br> LockConvoy: <br><br><ul><li>    </li><li>      </li></ul><br>  lock convoy  ,   -     .        list      ,     lock   ,  ,                . <br><br>     PinnableBufferCache  ,         .    : <br><br><pre> <code class="plaintext hljs">PinnableBufferCache_System.ThreadingOverlappedData_MinCount</code> </pre> <br>      ,      .  : « !         -  ».         -: <br><br><pre> <code class="cs hljs">Environment.SetEnvironmentVariable( <span class="hljs-string"><span class="hljs-string">"PinnableBufferCache_System.Threading.OverlappedData_MinCount"</span></span>, <span class="hljs-string"><span class="hljs-string">"10000"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Overlapped().GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);</code> </pre> <br>    ?     ,    Overlapped  ,   ,        .     ,   ,     ,     ,  PinnableBufferCache      lock convoy'.    ,           . <br><br>  .NET Core  PinnableBufferCache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ,   OverlappedData   . ,        , Garbage collector     ,      .     .NET Core  .  .NET Framework,   ,     . <br><br><h3> 3.2 : </h3><br><ul><li>      </li><li>      </li><li>   .NET Core </li></ul><br>      ,     .   ,   .NET            ,       . ,  ,  .NET Core. ,     ,         -. <br><br>    key-value . <br><br><h2>  4: Concurrent key-value collections </h2><br>  .NET   concurrent-.  lock-free  ConcurrentStack  ConcurrentQueu,       .   ConcurrentDictionary,    .   lock-free  ,   ,      .    ConcurrentDictionary? <br><br><h3> 4.1 ConcurrentDictionary </h3><br> : <br><br><ul><li>  </li><li>  </li></ul><br> 优点： <br><br><ul><li>     </li><li>   (TryAdd/TryUpdate/AddOrUpdate) </li><li> Lock-free  </li><li> Lock-free enumeration </li></ul><br>      , memory-,  ,        .    ,    ,    .NET Framework.            . ,  ,      (enumeration) lock-free. ,   . <br><br>  ,   ,   -  .NET.  key-value    -    : <br><br><img src="https://habrastorage.org/webt/ff/9f/g_/ff9fg_qzzuzvafep8c-p3seyigm.jpeg"><br><br>  -,     bucket'.      bucket',    .   ,    bucket   ,       . <br><br>    —   ,  ConcurrentDictionary.  ConcurrentDictionary    «-»   .    ,      ,   ,       memory traffic.     ConcurrentDictionary,   lock'.   —   . <br><br>    ,    Dictionary. <br><br><img src="https://habrastorage.org/webt/-_/dw/jo/-_dwjoxswmd1kecoi3aln8m7bow.jpeg"><br><br>  Dictionary  ,  Concurrent,      .     :  buckets,  entries.   buckets       bucket'   entries.   «-»    entries.          .      «-»   int,     bucket'. <br><br>   memory overhead,     ConcurrentDictionary   Dictionary. <br><br><img src="https://habrastorage.org/webt/em/aa/ch/emaachor-z_xxt7m_1wc7ntqupm.jpeg"><br><br>    Dictionary. Memory overhea'    ,       .    Dictionary  overhead  -    ,  int'.  8 . <br><br>    ConcurrentDictionary.  ConcurrentDictionary     ConcurrentDictionary.Node.   , .     int hashCode        .       ,    table (  16 ),  int hashCode     .      ,   64-    28  overhead'.       Dictionary. <br><br>  memory overhead', ConcurrentDictionary     GC   ,       .     Benchmark.   ConcurrentDictionary  ,       GC.Collect.    ? <br><br><img src="https://habrastorage.org/webt/on/yj/uq/onyjuq1rqgfkv8iav5x4z8nrnq8.jpeg"><br><br>     .       ConcurrentDictionary  10  ,        ,             ,      .   Dictionary   .      ,   ,  ,    .       . <br><br>     ,     ConcurrentDictionary? <br><br><h3> 4.2   </h3><br><ul><li>    </li><li> TTL </li><li> Dictionary+lock </li><li> Sharding </li></ul><br>     .      ConcurrentDictionary.        10  .   ,     .   TTL  ,    .        Dictionary  lock'. ,  ,  lock    .       Dictionary  lock'      ,   -     ,           lock.      ,     . <br><br><h3> 4.3  </h3><br><ul><li>   in-memory  &lt;Guid,Guid&gt; </li><li>   &gt;10 <sup>6</sup>  </li><li>       </li><li>   </li><li>        </li></ul><br>     .      —      ,       in-memory   Guid'  Guid,     .       .     - - ,     .  ,            15    .   .     Semaphore     ConcurrentDictionary. <br><br><img src="https://habrastorage.org/webt/u4/kw/kt/u4kwkttmxwpyelqlqoqp9zxahaa.jpeg"><br><br> ,    lock-free    ,    overhead      GC.   ,          .      ,    ,       ,   .   ,     -  ,       ,    .  ,  ,      Large Object Heap.    ? <br><br>       ,     ,     Dictionary   . <br><br><img src="https://habrastorage.org/webt/kx/yn/oi/kxynoiatsy8zcyrc5dei-xohlk4.jpeg"><br><br>   Dictionary   bucket',  Entry.  Entry  , ,   ,   . <br><br><img src="https://habrastorage.org/webt/n8/7a/5r/n87a5rlkgdk62nw82qysi3fmi18.png"><br><br>  Dictionary   ,   ,      . ,     - . <br><br>      ,  -     ? -,  ,       ,     ,      .     .    Dictionary,     , buckets, entries,              Interlocked. ,         . <br><blockquote> <b>Dictionary</b> <br><ul><li>   ,    </li><li>     ,   ? <br> —  Resize  buckets  entries   <br> —      - <br> —    Dictionary.Entry <br> —   -   </li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://blogs.msdn.microsoft.com/tess/2009/12/21/high-cpu-in-net-app-using-a-static-generic-dictionary/</a> </blockquote>     ,       Dictionary       -  bucket'.       ,      .    ,     ,        .       ,       ,    . <br><br>      Entry  Dictionary.     - -    .  ,     . <br><br><img src="https://habrastorage.org/webt/4p/xb/aq/4pxbaqil2cd4jaxnayxjqz-5yae.jpeg"><br><br>    .NET Framework  1.1.     Hashtable,   Dictionary,    object'.     MSDN ,      .  ,             -.   .  ,  Hashtable  .  ,      . <br><br><h3> 4.4    Dictionary.Entry </h3><br><img src="https://habrastorage.org/webt/y2/ww/rs/y2wwrslyuqpioqcalmpnt8dh6cw.jpeg"><br>    ? Dictionary.Entry ,  ,  8 , ,  ,   ,     .   ? <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; buckets[index] = …; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version++; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>   :  (    ,    )  int-.   ,  .   ,     , ,  ,  . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version; bucket = bickets[index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing || version != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>    ,     ,         .       ,   .       ,  8 . <br><br><h3> 4.5   -   </h3><br>  ,   . <br><br><img src="https://habrastorage.org/webt/hh/bp/0l/hhbp0leb95qndz4bmg-2gtvmeue.jpeg"><br><br>  Dictionary     bucket    ,     . <br><br>  Dictionary,    .      : 0  2.   bucket, 1       2.   ?     0.   ,       ,    2.     .   ,  2,       , , 1. 1       2 —     bucket.   ,      ,   .    1 — ,     bucket.  Hashtable     ,     bucket'  -.        — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">double hashing</a> . <br><br><h3> 4.6   </h3><br><ul><li>     </li><li>      </li></ul><br> <b></b> <br><br><ul><li>        </li><li>    ,  resize </li></ul><br> <b></b> <br><br><ul><li>     ,      </li></ul><br>        .         ,       Buckets,     Entries (   Buckets,     Entries).   -  ,       ,   ,          ,    . <br><br>             .    ,    . <br><br>  :     ,      ,    ,     ,     . ,       ,   . <br><br><img src="https://habrastorage.org/webt/pm/lo/ah/pmloah0wlfbq7ilvlnrvbh3pyuu.png"><br><br>     ,   , —  . <br><br>   ?   ,  -    2.   -   Capacity  ,            .    — 2.       ,   .      2.    ?  ,  ,     ,   .    -  ,        ,       3. ,    ,  ,    ,  ,  . <br><br>  ,    Hashtable,  .   ,     double hashing.     ,       ,   ,     . <br><br>   ,      ,     —   ,            .     Hashtable.   ,    —     —       .                 .  ,     bucket',       -  ,       .  . <br><br>     ,  ,   lock-free      LOH. <br><br><img src="https://habrastorage.org/webt/pg/2b/6b/pg2b6bbfkm_3nnkds27g2krziz8.jpeg"><br><br>   lock-free ?  MSDN    Hashtable ,      .    ,            ,            . <br><br><img src="https://habrastorage.org/webt/yu/sg/he/yusghe0crfu9ywaic0aozpr7wri.jpeg"><br><br>      ,     ,        ,   bucket'.         Dictionary  bucket',  -,   bucket'      .    -    bucket,  bucket  .      ,     . <br><br>  ,       Large Object Heap. <br><br><img src="https://habrastorage.org/webt/wf/po/8o/wfpo8ou1_fpzhdkgcdbjzw-7u9q.jpeg"><br><br>      .  CustomDictionary  CustomDictionarySegment    .   Dictionary,    ,      .   —   Dictionary,      .       ,      Large Object Heap.        ,   bucket'   . ,      ,    ,   bucket,     - - . <br><br>           .       ConcurrentDictionary,     .NET,        ,      . <br><br><h3> 4.7  </h3><br><ul><li> .NET   </li><li>    </li><li>   </li><li> ,     </li><li>   </li><li>   </li></ul><br>     ? .NET  .   .   ,     ,       .    -   —   - .   ,  , ,     . <br><br>  -   , ,   ,     ,   .   ,   ,   ,        , ,          .   —   , ,   . <br><br><h3>   </h3><br><ul><li>   ConcurrentDictionary: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/ru/company/skbkontur/blog/348508/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/vostok/commons.threading</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/epeshk/dotnext-2019-threading</a> </li></ul><br>   —          ConcurrentDictionary. ,      ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Diafilm</a> ),       . <br><br>      GitHub.   —     ,    ,    LIFO-Semaphore,    .       ,    . <br><blockquote> 6-7     <b>DotNext 2019 Moscow</b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">«.NET:  »</a>    ,        .NET Framework  .NET Core,  ,        . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN468611/">https://habr.com/ru/post/zh-CN468611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN468601/index.html">项目期限估算。 为什么几乎总是低估了它以及如何处理</a></li>
<li><a href="../zh-CN468603/index.html">Rutracker已包含eSNI。 DPI时代的终结和锁的终结</a></li>
<li><a href="../zh-CN468605/index.html">指向指针的常量指针...</a></li>
<li><a href="../zh-CN468607/index.html">面向无线电工程师的Android（第二部分）</a></li>
<li><a href="../zh-CN468609/index.html">多重调度的难以理解的表现</a></li>
<li><a href="../zh-CN468615/index.html">应用程式本地化的十大语言</a></li>
<li><a href="../zh-CN468621/index.html">我们将家庭网络转换为DoH，或再次单击过滤鼻子</a></li>
<li><a href="../zh-CN468623/index.html">我要在Habr上发表评论</a></li>
<li><a href="../zh-CN468625/index.html">无服务器：速度降低15％，价格提高8倍</a></li>
<li><a href="../zh-CN468627/index.html">ADAM-6200 I / O模块</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>