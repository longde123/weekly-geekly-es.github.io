<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏻 ⬛️ 🏴󠁧󠁢󠁷󠁬󠁳󠁿 Opérations de comparaison en C ++ 20 🧜 🎯 😟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La réunion à Cologne est passée, la norme C ++ 20 a été réduite à un aspect plus ou moins fini (au moins jusqu'à l'apparition de notes spéciales), et ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Opérations de comparaison en C ++ 20</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/465575/">  La réunion à Cologne est passée, la norme C ++ 20 a été réduite à un aspect plus ou moins fini (au moins jusqu'à l'apparition de notes spéciales), et je voudrais parler d'une des innovations à venir.  Il s'agit d'un mécanisme qui est généralement appelé <i>opérateur &lt;=&gt;</i> (la norme le définit comme un "opérateur de comparaison à trois voies", mais il a le surnom informel de "vaisseau spatial"), mais je pense que sa portée est beaucoup plus large. <br><br>  Nous n'aurons pas seulement un nouvel opérateur - la sémantique des comparaisons subira des changements importants au niveau du langage lui-même. <br><a name="habracut"></a><br>  Même si vous ne pouvez rien retirer d'autre de cet article, n'oubliez pas ce tableau: <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Égalité</b> <br></td><td>  <b>Rationalisation</b> <br></td></tr><tr><td>  <b>Basique</b> <br></td><td>  <i>==</i> <br></td><td>  <i>&lt;=&gt;</i> <br></td></tr><tr><td>  <b>Dérivés</b> <br></td><td>  <i>! =</i> <br></td><td>  <i>&lt;</i> , <i>&gt;</i> , <i>&lt;=</i> , <i>&gt; =</i> <br></td></tr></tbody></table></div><br>  Nous allons maintenant avoir un nouvel opérateur, <i>&lt;=&gt;</i> , mais, plus important encore, les opérateurs sont maintenant systématisés.  Il existe des opérateurs de base et des opérateurs dérivés - chaque groupe a ses propres capacités. <br><br>  Nous parlerons brièvement de ces fonctionnalités dans l'introduction et examinerons plus en détail dans les sections suivantes. <br><br>  Les opérateurs de base peuvent être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>inversés</b></a> (c'est-à-dire réécrits avec l'ordre inverse des paramètres).  Les instructions dérivées peuvent être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>réécrites</b></a> via l'instruction de base correspondante.  Ni les candidats convertis ni réécrits ne génèrent de nouvelles fonctions, ils sont simplement des remplacements au niveau du code source et sont sélectionnés à partir d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>ensemble étendu de candidats</b></a> .  Par exemple, l'expression <i>a &lt;9</i> peut maintenant être évaluée comme <i>a.operator &lt;=&gt; (9) &lt;0</i> et l'expression <i>10! = B</i> as <i>! Operator == (b, 10)</i> .  Cela signifie qu'il sera possible de se passer d'un ou deux opérateurs où, pour obtenir le même comportement, il est désormais nécessaire d'écrire manuellement 2, 4, 6, voire 12 opérateurs.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un bref</a> aperçu des règles sera présenté ci-dessous avec un tableau de toutes les transformations possibles. <br><br>  Les opérateurs de base et dérivés peuvent être définis par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>défaut</b></a> .  Dans le cas des opérateurs de base, cela signifie que l'opérateur sera appliqué à chaque membre dans l'ordre de déclaration;  dans le cas des opérateurs dérivés, les candidats réécrits seront utilisés. <br><br>  Il convient de noter qu'il n'y a pas une telle transformation dans laquelle un opérateur d'un type (c'est-à-dire l'égalité ou l'ordre) pourrait être exprimé par un opérateur d'un autre type.  En d'autres termes, les colonnes de notre tableau ne dépendent en aucune manière les unes des autres.  L'expression <i>a == b</i> ne sera jamais évaluée comme <i>opérateur &lt;=&gt;</i> <i>(a, b) == 0</i> implicitement (mais, bien sûr, rien ne vous empêche de définir votre <i>opérateur == en</i> utilisant l' <i>opérateur &lt;=&gt;</i> si vous le souhaitez). <br><br>  Prenons un petit exemple dans lequel nous montrons à quoi ressemble le code avant et après l'application de la nouvelle fonctionnalité.  Nous allons écrire un type de chaîne non sensible à la casse, <i>CIString</i> , dont les objets peuvent être comparés à la fois entre eux et avec <i>char const *</i> . <br><br>  En C ++ 17, pour notre tâche, nous devons écrire 18 fonctions de comparaison: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CIString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> assize() == bssize() &amp;&amp; ci_compare(asc_str(), bsc_str()) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(asc_str(), bsc_str()) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b &lt; a; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a &lt; b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(b &lt; a); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(asc_str(), b) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(asc_str(), b) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b &lt; a; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a &lt; b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(b &lt; a); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(a, bsc_str()) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(a, bsc_str()) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b &lt; a; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a &lt; b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(b &lt; a); } };</code> </pre> <br>  En C ++ 20, vous ne pouvez effectuer que 4 fonctions: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CIString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.size() == bssize() &amp;&amp; ci_compare(s.c_str(), bsc_str()) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(s.c_str(), bsc_str()) &lt;=&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(s.c_str(), b) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(s.c_str(), b) &lt;=&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } };</code> </pre> <br>  Je vais vous dire ce que tout cela signifie, plus en détail, mais d'abord, revenons un peu en arrière et rappelons-nous comment les comparaisons ont fonctionné avec la norme C ++ 20. <br><br><h2>  Comparaisons dans les normes de C ++ 98 à C ++ 17 </h2><br>  Les opérations de comparaison n'ont pas beaucoup changé depuis la création du langage.  Nous avions six opérateurs: <i>== ,!</i> <i>=</i> , <i>&lt;</i> , <i>&gt;</i> , <i>&lt;=</i> Et <i>&gt; =</i> .  La norme définit chacun d'eux pour les types intégrés, mais en général, ils obéissent aux mêmes règles.  Lors de l'évaluation d' <i>une</i> expression a <i>@ b</i> (où <i>@</i> est l'un des six opérateurs de comparaison), le compilateur recherche les fonctions membres, les fonctions libres et les candidats intégrés nommés <i>operator @</i> , qui peuvent être appelés avec le type <i>A</i> ou <i>B</i> dans l'ordre spécifié.  Le candidat le plus approprié est sélectionné parmi eux.  C’est tout.  En fait, <i>tous les</i> opérateurs fonctionnaient de la même manière: l'opération <i>&lt;</i> ne différait pas de <i>&lt;&lt;</i> . <br><br>  Un ensemble de règles aussi simple est facile à apprendre.  Tous les opérateurs sont absolument indépendants et équivalents.  Peu importe ce que nous, humains, savons de la relation fondamentale entre les opérations <i>==</i> et <i>! =</i> .  En termes de langue, c'est la même chose.  Nous utilisons des idiomes.  Par exemple, nous définissons l'opérateur <i>! =</i> Through <i>==</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; lhs, A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(lhs == rhs); }</code> </pre> <br>  De même, par l'opérateur <i>&lt;</i> nous définissons tous les autres opérateurs de relation.  Nous utilisons ces idiomes car, malgré les règles du langage, nous ne considérons pas vraiment les six opérateurs comme équivalents.  Nous acceptons que deux d'entre eux sont basiques ( <i>==</i> et <i>&lt;</i> ), et à travers eux tous les autres sont déjà exprimés. <br><br>  En fait, la bibliothèque de modèles standard est entièrement construite sur ces deux opérateurs, et le grand nombre de types dans le code exploité contient des définitions d'un seul d'entre eux ou des deux. <br><br>  Cependant, l'opérateur <i>&lt;</i> n'est pas très approprié pour le rôle de base pour deux raisons. <br><br>  Premièrement, il n'est pas garanti que d'autres opérateurs de relations s'expriment à travers elle.  Oui, <i>a&gt; b</i> signifie exactement la même chose que <i>b &lt;a</i> , mais il n'est pas vrai que <i>a &lt;= b</i> signifie exactement la même chose que <i>! (B &lt;a)</i> .  Les deux dernières expressions seront équivalentes s'il existe une propriété de trichotomie dans laquelle, pour deux valeurs quelconques, une seule des trois affirmations est vraie: <i>a &lt;b</i> , <i>a == b</i> ou <i>a&gt; b</i> .  S'il y a une trichotomie, l'expression <i>a &lt;= b</i> signifie que nous avons affaire au premier ou au deuxième cas ... et cela équivaut à l'affirmation selon laquelle nous n'avons pas affaire au troisième cas.  Par conséquent <i>(a &lt;= b) ==! (A&gt; b) ==! (B &lt;a)</i> . <br><br>  Mais que faire si l'attitude n'a pas la propriété de la trichotomie?  Ceci est caractéristique des relations d'ordre partiel.  Un exemple classique est les nombres à virgule flottante pour lesquels l'une des opérations <i>1.f &lt;NaN</i> , <i>1.f == NaN</i> et <i>1.f&gt; NaN</i> donne <i>false</i> .  Par conséquent, <i>1.f &lt;= NaN</i> donne également un <i>mensonge</i> , mais en même temps <i>! (NaN &lt;1.f)</i> est <i>vrai</i> . <br><br>  La seule façon d'implémenter l'opérateur <i>&lt;=</i> en termes généraux via les opérateurs de base est de peindre les deux opérations comme <i>(a == b) ||</i>  <i>(a &lt;b)</i> , ce qui est un grand pas en arrière si nous devons <i>encore</i> faire face à l'ordre linéaire, car alors aucune fonction ne sera appelée, mais deux (par exemple, l'expression <i>«abc..xyz9» &lt;= «abc ..xyz1 "</i> devra être réécrit comme <i>(" abc..xyz9 "==" abc..xyz1 ") || (" abc..xyz9 "&lt;" abc..xyz1 ")</i> et deux fois pour comparer la ligne entière). <br><br>  Deuxièmement, l'opérateur <i>&lt;</i> ne convient pas très bien au rôle de base en raison des particularités de son utilisation dans les comparaisons lexicographiques.  Les programmeurs font souvent cette erreur: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t &lt; rhs.t &amp;&amp; u &lt; rhs.u; } };</code> </pre> <br>  Pour définir l'opérateur == pour une collection d'éléments, il suffit d'appliquer <i>==</i> à chaque membre une fois, mais cela ne fonctionnera pas avec l'opérateur <i>&lt;</i> .  Du point de vue de cette implémentation, les ensembles <i>A {1, 2}</i> et <i>A {2, 1}</i> seront considérés comme équivalents (car aucun d'entre eux n'est inférieur à l'autre).  Pour résoudre ce problème, appliquez l'opérateur <i>&lt;</i> deux fois à chaque membre, sauf le dernier: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &lt; rhs.t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rhs.t &lt; t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u &lt; rhs.u; }</code> </pre> <br>  Enfin, pour garantir le bon fonctionnement des comparaisons d'objets hétérogènes - c'est-à-dire  pour s'assurer que les expressions <i>a == 10</i> et <i>10 == a</i> signifient la même chose - ils recommandent généralement d'écrire des comparaisons en tant que fonctions libres.  En fait, c'est généralement le seul moyen de mettre en œuvre de telles comparaisons.  Cela n'est pas pratique car, d'une part, vous devez surveiller le respect de cette recommandation, et d'autre part, vous devez généralement déclarer ces fonctions amis cachés pour une implémentation plus pratique (c'est-à-dire à l'intérieur du corps de classe). <br><br>  Notez que lors de la comparaison d'objets de différents types, il n'est pas toujours nécessaire d'écrire l' <i>opérateur == (X, int)</i> ;  ils peuvent également signifier des cas où <i>int</i> peut être transtypé implicitement en <i>X.</i> <br><br>  Résumons les règles au standard C ++ 20: <br><br><ul><li>  Toutes les instructions sont traitées de la même manière. </li><li>  Nous utilisons des idiomes pour faciliter la mise en œuvre.  Les opérateurs <i>==</i> et <i>&lt;</i> nous prenons pour les idiomes de base et exprimons les opérateurs de relation restants à travers eux. </li><li>  C'est juste que l'opérateur <i>&lt;n'est</i> pas très adapté au rôle de la base. </li><li>  Il est important (et recommandé) d'écrire des comparaisons d'objets hétérogènes en tant que fonctions libres. </li></ul><br><h2>  Nouvel opérateur de commande de base: &lt;=&gt; </h2><br>  Le changement le plus significatif et le plus notable dans le travail de comparaison en C ++ 20 est l'ajout d'un nouvel opérateur - <i>opérateur &lt;=&gt;</i> , un opérateur de comparaison à trois voies. <br><br>  Nous connaissons déjà les comparaisons <i>tripartites</i> par les fonctions <i>memcmp</i> / <i>strcmp</i> en C et <i>basic_string :: compare ()</i> en C ++.  Ils renvoient tous une valeur de type <i>int</i> , qui est représentée par un nombre positif arbitraire si le premier argument est supérieur au second, <i>0</i> s'ils sont égaux et un nombre négatif arbitraire sinon. <br><br>  L'opérateur «vaisseau spatial» ne renvoie pas une valeur <i>int</i> , mais un objet appartenant à l'une des catégories de comparaison, dont la valeur reflète le type de relation entre les objets comparés.  Il existe trois catégories principales: <br><br><ul><li>  <i>strong_ordering</i> : une relation d'ordre linéaire dans laquelle l'égalité implique l'interchangeabilité des éléments (c'est-à-dire <i>(a &lt;=&gt; b) == strong_ordering :: equal</i> implique que <i>f (a) == f (b)</i> est valable pour toutes les fonctions appropriées <i>f</i> Le terme «fonction appropriée» n'a intentionnellement pas de définition claire, mais celles-ci n'incluent pas les fonctions qui renvoient les adresses de leurs arguments ou la <i>capacité () du</i> vecteur, etc. Nous ne nous intéressons qu'aux propriétés «essentielles», qui sont également très vagues, mais conditionnellement possibles supposons que nous parlons de la <i>valeur</i> du type. La valeur du vecteur y est contenue  m éléments, mais pas son adresse, etc.).  Cette catégorie comprend les valeurs suivantes: <i>strong_ordering :: supérieur</i> , <i>strong_ordering :: égal</i> et <i>strong_ordering :: less</i> . </li><li>  <i>faible_ordre</i> : relation d'ordre linéaire dans laquelle l'égalité ne définit qu'une certaine classe d'équivalence.  Un exemple classique est la comparaison de chaînes insensible à la casse, lorsque deux objets peuvent être <i>low_ordering :: equivalent</i> , mais ne sont pas strictement égaux (cela explique le remplacement du mot <i>égal</i> par <i>équivalent</i> dans le nom de la valeur). </li><li>  <i>partial_ordering</i> : relation d'ordre partiel.  Dans cette catégorie, une valeur supplémentaire est ajoutée aux valeurs <i>supérieures</i> , <i>équivalentes</i> et <i>inférieures</i> (comme dans <i>faible_ordre</i> ) - <i>non</i> <i>classées</i> ("désordonnées").  Il peut être utilisé pour exprimer des relations d'ordre partiel dans un système de types: <i>1.f &lt;=&gt; NaN</i> donne la valeur <i>partial_ordering :: unordered</i> . </li></ul><br>  Vous travaillerez principalement avec la catégorie <i>strong_ordering</i> ;  Il s'agit également de la catégorie optimale à utiliser par défaut.  Par exemple, <i>2 &lt;=&gt; 4</i> renvoie <i>strong_ordering :: less</i> et <i>3 &lt;=&gt; -1</i> <i>renvoie strong_ordering :: Greater</i> . <br><br>  Les catégories d'un ordre supérieur peuvent être implicitement réduites à des catégories d'un ordre plus faible (c'est-à-dire que <i>strong_ordering est</i> réductible à <i>faible_ordering</i> ).  Dans ce cas, le type de relation actuel est conservé (c'est-à-dire que <i>strong_ordering :: equal</i> se transforme en <i>faiblesse_ordering :: equivalent</i> ). <br><br>  Les valeurs des catégories de comparaison peuvent être comparées avec le littéral <i>0</i> (pas avec un <i>int</i> et pas avec un <i>int</i> égal à <i>0</i> , mais simplement avec le littéral <i>0</i> ) en utilisant l'un des six opérateurs de comparaison: <br><br><pre> <code class="cpp hljs">strong_ordering::less &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">// true strong_ordering::less == 0 // false strong_ordering::less != 0 // true strong_ordering::greater &gt;= 0 // true partial_ordering::less &lt; 0 // true partial_ordering::greater &gt; 0 // true // unordered -  ,   //       partial_ordering::unordered &lt; 0 // false partial_ordering::unordered == 0 // false partial_ordering::unordered &gt; 0 // false</span></span></code> </pre> <br>  C'est grâce à une comparaison avec le littéral <i>0 que l'</i> on peut implémenter les opérateurs de relation: <i>a @ b est</i> équivalent à <i>(a &lt;=&gt; b) @ 0</i> pour chacun de ces opérateurs. <br><br>  Par exemple, <i>2 &lt;4</i> peut être calculé comme <i>(2 &lt;=&gt; 4) &lt;0</i> , ce qui se transforme en <i>strong_ordering :: less &lt;0</i> et donne la valeur <i>true</i> . <br><br>  L'opérateur <i>&lt;=&gt;</i> correspond bien mieux au rôle de l'élément de base que l'opérateur <i>&lt;</i> , car il élimine les deux problèmes de ce dernier. <br><br>  Premièrement, l'expression <i>a &lt;= b est</i> garantie d'être équivalente à <i>(a &lt;=&gt; b) &lt;= 0</i> même avec un ordre partiel.  Pour deux valeurs non ordonnées, <i>a &lt;=&gt; b</i> donnera la valeur <i>partial_ordered :: unordered</i> et <i>partial_ordered :: unordered &lt;= 0</i> donnera <i>false</i> , ce dont nous avons besoin.  Cela est possible car <i>&lt;=&gt;</i> peut renvoyer plus de variétés de valeurs: par exemple, la catégorie <i>partial_ordering</i> contient quatre valeurs possibles.  Une valeur de type <i>bool</i> ne peut être <i>vraie</i> ou <i>fausse</i> , donc avant, nous ne pouvions pas distinguer les comparaisons de valeurs ordonnées et non ordonnées. <br><br>  Pour plus de clarté, considérons un exemple de relation d'ordre partiel qui n'est pas liée aux nombres à virgule flottante.  Supposons que nous voulons ajouter un état NaN à un type <i>int</i> , où NaN est juste une valeur qui ne forme pas une paire ordonnée avec une valeur impliquée.  Vous pouvez le faire en utilisant <i>std :: facultatif</i> pour le stocker: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntNan</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; val = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nullopt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(IntNan <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!val || !rhs.val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *val == *rhs.val; } partial_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(IntNan <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!val || !rhs.val) { <span class="hljs-comment"><span class="hljs-comment">//  unordered   //     return partial_ordering::unordered; } // &lt;=&gt;   strong_ordering  int, //        partial_ordering return *val &lt;=&gt; *rhs.val; } }; IntNan{2} &lt;=&gt; IntNan{4}; // partial_ordering::less IntNan{2} &lt;=&gt; IntNan{}; // partial_ordering::unordered //     .    IntNan{2} &lt; IntNan{4}; // true IntNan{2} &lt; IntNan{}; // false IntNan{2} == IntNan{}; // false IntNan{2} &lt;= IntNan{}; // false</span></span></code> </pre> <br>  L'opérateur <i>&lt;=</i> renvoie la valeur correcte car maintenant nous pouvons exprimer plus d'informations au niveau de la langue elle-même. <br><br>  Deuxièmement, pour obtenir toutes les informations nécessaires, il suffit d’appliquer <i>&lt;=&gt;</i> une fois, ce qui facilite la mise en œuvre de la comparaison lexicographique: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    //  t.   != 0 (..  t // ),    //   if (auto c = t &lt;=&gt; rhs.t; c != 0) return c; //     //    return u &lt;=&gt; rhs.u; };</span></span></code> </pre> <br>  Voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P0515</a> , la phrase originale pour ajouter l' <i>opérateur &lt;=&gt;, pour une</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discussion</a> plus détaillée <i>.</i> <br><br><h2>  Nouvelles fonctionnalités opérateur </h2><br>  Nous ne mettons pas seulement à notre disposition un nouvel opérateur.  En fin de compte, si l'exemple montré ci-dessus avec la déclaration de structure <i>A</i> disait seulement qu'au lieu de <i>x &lt;y nous devons</i> maintenant écrire <i>(x &lt;=&gt; y) &lt;0 à</i> chaque fois, personne ne l'aimerait. <br><br>  Le mécanisme de résolution des comparaisons en C ++ 20 diffère sensiblement de l'ancienne approche, mais ce changement est directement lié au nouveau concept de deux opérateurs de comparaison de base: <i>==</i> et <i>&lt;=&gt;</i> .  Si auparavant c'était un idiome (enregistrement via <i>==</i> et <i>&lt;</i> ), que nous avons utilisé, mais que le compilateur ne connaissait pas, maintenant il comprendra cette différence. <br><br>  Encore une fois, je vais vous donner le tableau que vous avez déjà vu au début de l'article: <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Égalité</b> <br></td><td>  <b>Rationalisation</b> <br></td></tr><tr><td>  <b>Basique</b> <br></td><td>  <i>==</i> <br></td><td>  <i>&lt;=&gt;</i> <br></td></tr><tr><td>  <b>Dérivés</b> <br></td><td>  <i>! =</i> <br></td><td>  <i>&lt;</i> , <i>&gt;</i> , <i>&lt;=</i> , <i>&gt; =</i> <br></td></tr></tbody></table></div><br>  Chacun des opérateurs de base et dérivés a reçu une nouvelle capacité, que je dirai quelques mots plus loin. <br><br><h3>  Inversion des opérateurs de base </h3><br>  Par exemple, prenez un type qui ne peut être comparé qu'à <i>int</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i == j; } };</code> </pre> <br>  Du point de vue des anciennes règles, il n'est pas surprenant que l'expression <i>a == 10</i> fonctionne et s'évalue en <i>a.operator == (10)</i> . <br><br>  Mais qu'en est-il de <i>10 == a</i> ?  En C ++ 17, cette expression serait considérée comme une erreur de syntaxe claire.  Il n'y a pas un tel opérateur.  Pour qu'un tel code fonctionne, vous devez écrire un <i>opérateur</i> symétrique <i>==</i> , qui prendrait d'abord la valeur de <i>int</i> , puis <i>A</i> ... et pour l'implémenter, cela devrait être sous la forme d'une fonction libre. <br><br>  En C ++ 20, les opérateurs de base peuvent être inversés.  Pour <i>10 == a, le</i> compilateur trouvera un <i>opérateur</i> candidat <i>== (A, int)</i> (en fait, c'est une fonction membre, mais pour plus de clarté, je l'écris ici comme une fonction libre), puis en plus - une variante avec l'ordre inverse des paramètres, c'est-à-dire .  <i>opérateur == (int, A)</i> .  Ce deuxième candidat coïncide avec notre expression (et idéalement), nous allons donc le choisir.  L'expression <i>10 == a</i> en C ++ 20 est évaluée comme <i>a.operator == (10)</i> .  Le compilateur comprend que l'égalité est symétrique. <br><br>  Nous allons maintenant étendre notre type afin qu'il puisse être comparé à <i>int</i> non seulement via l'opérateur d'égalité, mais aussi via l'opérateur de commande: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i == j; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i &lt;=&gt; j; } };</code> </pre> <br>  Encore une fois, l'expression <i>a &lt;=&gt; 42</i> fonctionne bien et est calculée selon les anciennes règles comme <i>a.operator &lt;=&gt; (42)</i> , mais <i>42 &lt;=&gt;</i> a serait erroné du point de vue de C ++ 17, même si l'opérateur <i>&lt; =&gt;</i> existait déjà dans la langue.  Mais en C ++ 20, l' <i>opérateur &lt;=&gt;</i> , comme l' <i>opérateur ==</i> , est symétrique: il reconnaît les candidats inversés.  Pour <i>42 &lt;=&gt;</i> a, un <i>opérateur de</i> fonction membre <i>&lt;=&gt;</i> <i>(A, int)</i> sera trouvé (encore une fois, je l'écris ici comme une fonction libre juste pour plus de clarté), ainsi qu'un <i>opérateur</i> candidat synthétique <i>&lt;=&gt;</i> <i>(int, A)</i> .  Cette version inversée correspond exactement à notre expression - nous la sélectionnons. <br><br>  Cependant, <i>42 &lt;=&gt;</i> <i>a n'est</i> PAS calculé comme un <i>opérateur</i> <i>&lt;=&gt;</i> <i>(42)</i> .  Ce serait faux.  Cette expression est évaluée à <i>0 &lt;=&gt; a.operator &lt;=&gt; (42)</i> .  Essayez de comprendre pourquoi cette entrée est correcte. <br><br>  Il est important de noter que le compilateur ne crée aucune nouvelle fonction.  Lors du calcul de <i>10 == a</i> , le nouvel opérateur <i>opérateur == (int, A)</i> n'apparaissait pas et lors du calcul de <i>42 &lt;=&gt; a</i> , l' <i>opérateur</i> <i>&lt;=&gt;</i> <i>(int, A)</i> n'apparaissait pas.  Seulement deux expressions sont réécrites par le biais de candidats inversés.  Je le répète: aucune nouvelle fonction n'est créée. <br><br>  Notez également qu'un enregistrement avec l'ordre inverse des paramètres n'est disponible que pour les opérateurs de base, mais pas pour les dérivés.  Soit: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; }; b != <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ok   C++17,   C++20 42 != b; //    C++17,   C++20</span></span></code> </pre> <br><h3>  Réécriture des opérateurs dérivés </h3><br>  Revenons à notre exemple avec la structure <i>A</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i == j; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i &lt;=&gt; j; } };</code> </pre> <br>  Prenez l'expression <i>a! = 17</i> .  En C ++ 17, il s'agit d'une erreur de syntaxe car l' <i>opérateur! =</i> Operator n'existe pas.  Cependant, en C ++ 20, pour les expressions contenant des opérateurs de comparaison de dérivés, le compilateur recherchera également les opérateurs de base correspondants et exprimera des comparaisons de dérivés à travers eux. <br><br>  Nous savons qu'en mathématiques, l'opération <i>! =</i> Signifie essentiellement NON <i>==</i> .  Maintenant, cela est connu du compilateur.  Pour l'expression <i>a! = 17,</i> il cherchera non seulement l' <i>opérateur! = Opérateurs</i> , mais aussi l' <i>opérateur ==</i> (et, comme dans les exemples précédents, l' <i>opérateur</i> inversé <i>==</i> ).  Pour cet exemple, nous avons trouvé un opérateur d'égalité qui nous convient presque - il suffit de le réécrire en fonction de la sémantique souhaitée: <i>a! = 17</i> sera calculé comme <i>! (A == 17)</i> . <br><br>  De même, <i>17! =</i> A est calculé comme <i>! A.operator == (17)</i> , qui est à la fois une version réécrite et une version inversée. <br><br>  Des transformations similaires sont également effectuées pour les opérateurs de commande.  Si nous écrivions <i>un &lt;9</i> , nous essayions (sans succès) de trouver l' <i>opérateur &lt;</i> , et considérions également les candidats de base: l' <i>opérateur &lt;=&gt;</i> .  Le remplacement correspondant pour les opérateurs de relation ressemble à ceci: <i>a @ b</i> (où <i>@</i> est l'un des opérateurs de relation) est calculé comme <i>(a &lt;=&gt; b) @ 0</i> .  Dans notre cas, un <i>opérateur &lt;=&gt; (9) &lt;0</i> .  De même, <i>9 &lt;= a est</i> calculé comme <i>0 &lt;= a.operator &lt;=&gt; (9)</i> . <br><br>  Notez que, comme dans le cas de l'appel, le compilateur ne crée aucune nouvelle fonction pour les candidats réécrits.  Ils sont simplement calculés différemment et toutes les transformations sont effectuées uniquement au niveau du code source. <br><br>  Ce qui précède m'amène aux conseils suivants: <br><br>  <b><i>OPÉRATEURS DE BASE UNIQUEMENT</i></b> <i>: Définissez uniquement les opérateurs de base (== et &lt;=&gt;) dans votre type.</i> <br><br>  Les opérateurs de base donnant l'ensemble des comparaisons, il suffit de les définir uniquement.  Cela signifie que vous n'avez besoin que de 2 opérateurs pour comparer des objets du même type (au lieu de 6, à partir de maintenant) et de seulement 2 opérateurs pour comparer différents types d'objets (au lieu de 12).  Si vous n'avez besoin que de l'opération d'égalité, écrivez simplement 1 fonction pour comparer des objets du même type (au lieu de 2) et 1 fonction pour comparer différents types d'objets (au lieu de 4).  La <i>classe std :: sub_match</i> représente un cas extrême: en C ++ 17, elle utilise 42 opérateurs de comparaison, et en C ++ 20, elle n'en utilise que 8, tandis que la fonctionnalité ne souffre d'aucune façon. <br><br>  Puisque le compilateur considère également les candidats inversés, tous ces opérateurs peuvent être implémentés en tant que fonctions membres.  Vous n'avez plus besoin d'écrire des fonctions libres juste pour comparer des objets de différents types. <br><br><h3>  Règles spéciales pour trouver des candidats </h3><br>  Comme je l'ai déjà mentionné, la recherche de candidats pour <i>un @ b</i> en C ++ 17 a été réalisée selon le principe suivant: on trouve tous les <i>opérateurs @ opérateur</i> et on sélectionne parmi eux le plus approprié. <br><br>  C ++ 20 utilise un ensemble étendu de candidats.  Nous allons maintenant rechercher tous les <i>opérateurs @</i> .  Soit <i>@@</i> l'opérateur de base de <i>@</i> (il peut s'agir du même opérateur).  On retrouve également tous les <i>opérateurs @@</i> et pour chacun d'eux on ajoute sa version inversée.  Parmi tous ces candidats trouvés, nous sélectionnons le plus adapté. <br><br>  Notez que la surcharge de l'opérateur est autorisée en <b>une seule</b> passe.  Nous n'essayons pas de remplacer différents candidats.  D'abord, nous les collectons tous, puis choisissons le meilleur d'entre eux.  Si cela n'existe pas, la recherche, comme précédemment, échoue. <br><br>  Nous avons maintenant beaucoup plus de candidats potentiels, et donc plus d'incertitude.  Prenons l'exemple suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(C <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(C <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(C x, C y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x != y; }</code> </pre> <br>  En C ++ 17, nous n'avions qu'un seul candidat pour <i>x! = Y</i> , et maintenant il y en a trois: <i>x.operator! = (Y),!</i> <i>X.operator == (y)</i> et <i>! Y.operator == (x)</i> .  Que choisir?  Ils sont tous pareils!  (Remarque: le candidat <i>y.operator! = (X)</i> n'existe pas, car seuls les opérateurs de base peuvent être <i>inversés</i> .) <br><br>  Deux règles supplémentaires ont été introduites pour lever cette incertitude.  Les candidats non convertis sont préférables aux convertis;    .  ,  <i>x.operator!=(y)</i> «» <i>!x.operator==(y)</i> ,   «» <i>!y.operator==(x)</i> .      ,   «»   . <br><br>   :           <i>operator@@</i> .    .   ,       . <br><br>        -.    —    (,   <i>x &lt; y</i> ,    —  <i>(x &lt;=&gt; y) &lt; 0</i> ),        (, <i>x &lt;=&gt; y</i>  <i>void</i>  -  ,       DSL),    .          .       ,       <i>bool</i>      (  :  <i>operator==</i>   <i>bool</i> ,        ?) <br><br>  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Base&amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Base&amp;); <span class="hljs-comment"><span class="hljs-comment">// #1 friend bool operator==(const Base&amp;, const Base&amp;); }; struct Derived : Base { friend void operator&lt;=&gt;(const Derived&amp;, const Derived&amp;); // #2 }; bool f(Derived d1, Derived d2) { return d1 &lt; d2; }</span></span></code> </pre> <br>   <i>d1 &lt; d2</i>    : <i>#1</i>  <i>#2</i> .   — <i>#2</i> ,      , ,   .    ,  <i>d1 &lt; d2</i>   <i>(d1 &lt;=&gt; d2) &lt; 0</i> .    ,    <i>void</i>  <i>0</i> — ,    . ,          - ,    <i>#1</i> . <br><br><h3>    </h3><br> ,     ,    C++17,         .    ,  -    .     : <br><br><ul><li>       </li><li>      (  ) </li><li>            ,         </li><li>               ,   . </li></ul><br>         <b>  </b> ,        .     . <br><br>             .          ,    ,  ,   ,   ,      (   ).  ,         : <br><div class="scrollable-table"><table><tbody><tr><td> <b> </b> <br></td><td>  <b>Option 1</b> <br></td><td>  <b>Option 2</b> <br></td></tr><tr><td> <i>a == b</i> <br></td><td> <i>b == a</i> <br></td><td><br></td></tr><tr><td> <i>a != b</i> <br></td><td> <i>!(a == b)</i> <br></td><td> <i>!(b == a)</i> <br></td></tr><tr><td> <i>a &lt;=&gt; b</i> <br></td><td> <i>0 &lt;=&gt; (b &lt;=&gt; a)</i> <br></td><td><br></td></tr><tr><td> <i>a &lt; b</i> <br></td><td> <i>(a &lt;=&gt; b) &lt; 0</i> <br></td><td> <i>(b &lt;=&gt; a) &gt; 0</i> <br></td></tr><tr><td> <i>a &lt;= b</i> <br></td><td> <i>(a &lt;=&gt; b) &lt;= 0</i> <br></td><td> <i>(b &lt;=&gt; a) &gt;= 0</i> <br></td></tr><tr><td> <i>a &gt; b</i> <br></td><td> <i>(a &lt;=&gt; b) &gt; 0</i> <br></td><td> <i>(b &lt;=&gt; a) &lt; 0</i> <br></td></tr><tr><td> <i>a &gt;= b</i> <br></td><td> <i>(a &lt;=&gt; b) &gt;= 0</i> <br></td><td> <i>(b &lt;=&gt; a) &lt;= 0</i> <br></td></tr></tbody></table></div><br>   « »         ,     , .. <i>a &lt; b</i>   <i>0 &lt; (b &lt;=&gt; a)</i> ,       ,   ,      . <br><br><h3>       </h3><br>    C++17       .      .           : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u &amp;&amp; v == rhs.v; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,     , //     ?:  &amp;&amp;/|| if (t &lt; rhs.t) return true; if (rhs.t &lt; t) return false; if (u &lt; rhs.u) return true; if (rhs.u &lt; u) return false; return v &lt; rhs.v; } bool operator&gt; (A const&amp; rhs) const { return rhs &lt; *this; } bool operator&lt;=(A const&amp; rhs) const { return !(rhs &lt; *this); } bool operator&gt;=(A const&amp; rhs) const { return !(*this &lt; rhs); } };</span></span></code> </pre> <br>      - <i>std::tie()</i> ,     . <br><br>       ,   :    : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u &amp;&amp; v == rhs.v; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   T if (auto c = t &lt;=&gt; rhs.t; c != 0) return c; // ...  U if (auto c = u &lt;=&gt; rhs.u; c != 0) return c; // ...  V return v &lt;=&gt; rhs.v; } };</span></span></code> </pre> <br>     .   <i>&lt;=&gt;</i>         <i>&lt;</i> .  ,        .  <i>c != 0</i>    ,      ,          ( <i></i>  <i></i> ),     . <br><br>        <i> </i> .   C++20    ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br>   ,        .     ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br>    .   ,         ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br>   ,     ,     .     :        <i>operator==</i> ,     <i>operator&lt;=&gt;</i> . <br><br><h2>    </h2><br>         C++20:        .          .         ,    ,        ,     . <br><br><h2>   </h2><br>  PVS-Studio      ,            &lt;=&gt;  .         ,       -.   ,     ,            (.  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    </a> ").  ++          . <br><br>      PVS-Studio        &lt;,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t &lt; rhs.t &amp;&amp; u &lt; rhs.u; }</code> </pre> <br>        . ,   -  .  . <br><br> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comparisons in C++20</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465575/">https://habr.com/ru/post/fr465575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465561/index.html">Ce que j'ai appris d'un grand programmeur</a></li>
<li><a href="../fr465567/index.html">Test du code SQL Server avec tSQLt</a></li>
<li><a href="../fr465569/index.html">Carte de développement des développeurs mobiles</a></li>
<li><a href="../fr465571/index.html">Comment vendre des cigarettes aux hommes pour les femmes et protéger les sauvages: des rédacteurs qui pourraient</a></li>
<li><a href="../fr465573/index.html">Toute la puissance d'IntelliJ IDEA sur l'exemple d'une langue (en images)</a></li>
<li><a href="../fr465577/index.html">Nouveaux types de micro-marquage pour les extraits interactifs avancés</a></li>
<li><a href="../fr465579/index.html">Création de chats d'entreprise et de vidéoconférences avec l'équipe Zextras</a></li>
<li><a href="../fr465583/index.html">Les détails d'une campagne malveillante pour les utilisateurs d'iPhone révélés</a></li>
<li><a href="../fr465585/index.html">Comment gérer React Data Grid via Redux</a></li>
<li><a href="../fr465587/index.html">Analyse: qu'est-ce que le marché OTC et quelles transactions y sont effectuées</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>