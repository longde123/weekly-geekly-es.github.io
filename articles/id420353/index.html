<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🎓 👨‍🍳 🤬 Kami menjadikan Shrimp lebih bermanfaat: menambahkan transcoding gambar ke format lain 🦌 👩🏿‍🎨 👩‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sejak awal 2017, tim kecil kami telah mengembangkan pustaka RESTinio OpenSource untuk menyematkan server HTTP dalam aplikasi C ++. Kami sangat terkeju...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menjadikan Shrimp lebih bermanfaat: menambahkan transcoding gambar ke format lain</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420353/"><img src="https://habrastorage.org/webt/7w/iy/b5/7wiyb5u0fpwa1duglcppwofjloa.jpeg"><br><br>  Sejak awal 2017, tim kecil kami telah mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka RESTinio OpenSource</a> untuk menyematkan server HTTP dalam aplikasi C ++.  Kami sangat terkejut, dari waktu ke waktu kami mendapat pertanyaan dari kategori "Dan mengapa server HTTP C ++ yang disematkan diperlukan?"  Sayangnya, pertanyaan sederhana adalah yang paling sulit dijawab.  Terkadang jawaban terbaik adalah kode sampel. <br><br>  Beberapa bulan yang lalu kami memulai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek demo</a> kecil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, Shrimp</a> , yang dengan jelas menunjukkan skenario tipikal, di mana perpustakaan kami "diasah".  Proyek demo adalah layanan Web sederhana yang menerima permintaan untuk menskala gambar yang disimpan di server dan yang mengembalikan gambar ukuran yang dibutuhkan pengguna. <br><br>  Proyek demo ini bagus dalam hal itu, pertama, ia membutuhkan integrasi dengan kode yang sudah lama ditulis dan bekerja dengan benar dalam C atau C ++ (dalam hal ini, ImageMagick).  Oleh karena itu, harus jelas mengapa masuk akal untuk menanamkan server HTTP dalam aplikasi C ++. <br><br>  Dan kedua, dalam hal ini, pemrosesan permintaan yang tidak sinkron diperlukan sehingga server HTTP tidak memblokir ketika gambar sedang diskalakan (dan ini bisa memakan waktu ratusan milidetik atau bahkan detik).  Dan kami memulai pengembangan RESTinio justru karena kami tidak dapat menemukan server tertanam C ++ yang dipusatkan secara khusus pada pemrosesan permintaan asinkron. <br><br>  Kami membangun karya di atas Udang secara berulang: pertama, versi paling sederhana dibuat dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan</a> , yang hanya memperbesar gambar.  Kemudian kami memperbaiki sejumlah kekurangan dari versi pertama dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggambarkannya di artikel kedua</a> .  Akhirnya, kami berkeliling untuk memperluas fungsi udang sekali lagi: konversi gambar dari satu format ke format lainnya ditambahkan.  Tentang bagaimana ini dilakukan dan akan dibahas dalam artikel ini. <br><a name="habracut"></a><br><h1>  Dukungan format target </h1><br>  Jadi, dalam versi udang berikutnya, kami menambahkan kemampuan untuk memberikan gambar berskala dalam format yang berbeda.  Jadi, jika Anda mengeluarkan permintaan udang dari formulir: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920"</span></span></code> </pre> <br>  maka Shrimp akan membuat gambar dalam format JPG yang sama dengan gambar aslinya. <br><br>  Tetapi jika Anda menambahkan parameter format target ke URL, maka Shrimp mengubah gambar ke format target yang ditentukan.  Sebagai contoh: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920&amp;target-format=webp"</span></span></code> </pre> <br>  Dalam hal ini, Udang akan membuat gambar dalam format webp. <br><br>  Udang yang diperbarui mendukung lima format gambar: jpg, png, gif, webp, dan heic (juga dikenal sebagai HEIF).  Anda dapat bereksperimen dengan berbagai format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada halaman web khusus</a> : <br><br><img src="https://habrastorage.org/webt/99/ab/ke/99abkec8ode-lxyxufceqjmwxt8.png"><br><br>  (pada halaman ini tidak ada cara untuk memilih format heic, karena browser desktop biasa tidak mendukung format ini secara default). <br><br>  Untuk mendukung format target dalam udang, diperlukan untuk sedikit mengubah kode udang (yang kami sendiri terkejut, karena memang ada sedikit perubahan).  Tetapi di sisi lain, saya harus bermain dengan perakitan ImageMagick, yang kami bahkan lebih terkejut dengannya  Sebelumnya, kami harus berurusan dengan dapur ini, secara kebetulan.  Tapi mari kita bicara tentang semuanya secara berurutan. <br><br><h2>  ImageMagick harus memahami format yang berbeda </h2><br>  ImageMagick menggunakan pustaka eksternal untuk menyandikan / mendekode gambar: libjpeg, libpng, libgif, dll.  Pustaka ini harus diinstal pada sistem sebelum ImageMagick dikonfigurasi dan dibuat. <br><br>  Hal yang sama harus terjadi agar ImageMagick mendukung format webp dan heic: pertama Anda perlu membangun dan menginstal libwebp dan libheif, kemudian mengkonfigurasi dan menginstal ImageMagick.  Dan jika semuanya sederhana dengan libwebp, maka sekitar libhe jika saya harus menari dengan rebana.  Meskipun setelah beberapa waktu, setelah semuanya akhirnya berkumpul dan bekerja, itu belum jelas: mengapa Anda harus menggunakan rebana, semuanya tampak sepele?  ;) <br><br>  Secara umum, jika seseorang ingin berteman dengan heic dan ImageMagick, Anda harus menginstal: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">x265 dari videolan.org</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libde265</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libheif</a> </li></ul><br>  Ada dalam urutan ini (Anda mungkin harus menginstal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nasm</a> agar x265 bekerja pada kecepatan maksimum).  Kemudian, ketika mengeluarkan perintah <i>./configure</i> , ImageMagick akan dapat menemukan semua yang diperlukan untuk mendukung file .heic. <br><br><h2>  Dukungan untuk format target dalam string kueri permintaan yang masuk </h2><br>  Setelah kami berteman dengan ImageMagick dengan format webp dan heic, saatnya untuk memodifikasi kode Shrimp.  Pertama-tama, kita perlu belajar bagaimana mengenali argumen format-target dalam permintaan HTTP yang masuk. <br><br>  Dari sudut pandang RESTinio, ini sama sekali bukan masalah.  Nah, argumen lain muncul di string kueri, jadi apa?  Namun dari sudut pandang Shrimp, situasinya ternyata agak lebih rumit, sehingga kode fungsi yang bertanggung jawab untuk mem-parsing permintaan HTTP menjadi lebih rumit. <br><br>  Faktanya adalah bahwa sebelum itu perlu untuk membedakan hanya dua situasi: <br><br><ul><li>  datang permintaan berupa "/filename.ext" tanpa parameter lainnya.  Jadi Anda hanya perlu memberikan file "filename.ext" apa adanya; </li><li>  Permintaan datang dalam bentuk "/filename.ext?op=resize &amp; ...".  Dalam hal ini, Anda perlu skala gambar dari file "filename.ext". </li></ul><br>  Tetapi setelah menambahkan format target, kita perlu membedakan antara empat situasi: <br><br><ul><li>  datang permintaan berupa "/filename.ext" tanpa parameter lainnya.  Jadi Anda hanya perlu memberikan file "filename.ext" apa adanya, tanpa scaling dan tanpa transcoding ke format lain; </li><li>  datang permintaan berupa "/filename.ext?target-format=fmt" tanpa parameter lainnya.  Ini berarti untuk mengambil gambar dari file "filename.ext" dan transcode ke dalam format "fmt" sambil mempertahankan ukuran aslinya; </li><li>  permintaan datang dari formulir "/filename.ext?op=resize &amp; ..." tetapi tanpa format target.  Dalam hal ini, Anda perlu skala gambar dari file "filename.ext" dan berikan dalam format asli; </li><li>  Permintaan datang dari formulir "/filename.ext?op=resize&amp;...&amp;target-format=fmt".  Dalam hal ini, Anda perlu melakukan penskalaan, dan kemudian mentranskode hasilnya ke format "fmt". </li></ul><br>  Akibatnya, fungsi untuk menentukan parameter kueri mengambil <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">bentuk berikut</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> add_transform_op_handler( const app_params_t &amp; app_params, http_req_router_t &amp; router, so_5::mbox_t req_handler_mbox ) { router.http_get( R"(/:path(.*)\.:ext(.{3,4}))", restinio::path2regex::options_t{}.<span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ), [req_handler_mbox, &amp;app_params]( auto req, auto params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( has_illegal_path_components( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().path() ) ) { //     . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } //   . const auto qp = restinio::parse_query( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().query() ); const auto target_format = qp.get_param( "target-format"sv ); //        // .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>,    //   .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>  // ,    ,  //    . const auto image_format = try_detect_target_image_format( params[ "ext" ], target_format ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !image_format ) { //     .   . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !qp.size() ) { //    ,    . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serve_as_regular_file( app_params.m_storage.m_root_dir, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ), *image_format ); } const auto operation = qp.get_param( "op"sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( operation &amp;&amp; "resize"sv != *operation ) { //    ,     resize. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !operation &amp;&amp; !target_format ) { //      op=resize, //   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>=something. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } handle_resize_op_request( req_handler_mbox, *image_format, qp, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } ); }</code> </pre> <br>  Di udang versi sebelumnya, di mana Anda tidak perlu mentranskode gambar, bekerja dengan parameter permintaan <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/3e8beeeb8935f84e492af188dd6fc6f2ba785657/dev/shrimp/">tampak sedikit lebih mudah</a> . <br><br><h2>  Permintaan antrian dan cache gambar yang disesuaikan dengan format target </h2><br>  Poin berikutnya dalam implementasi dukungan format-target adalah pekerjaan pada antrian permintaan tunggu dan cache gambar yang sudah jadi di agen a_transform_manager.  Kami berbicara tentang hal-hal ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara</a> lebih rinci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di artikel sebelumnya</a> , tetapi mari kita sedikit mengingatkan Anda tentang apa itu. <br><br>  Ketika permintaan untuk konversi gambar tiba, mungkin ternyata gambar yang sudah jadi dengan parameter tersebut sudah ada dalam cache.  Dalam hal ini, Anda tidak perlu melakukan apa pun, cukup kirim gambar dari cache sebagai tanggapan.  Jika gambar perlu diubah, maka mungkin ternyata tidak ada pekerja gratis saat ini dan Anda perlu menunggu sampai muncul.  Untuk melakukan ini, informasi permintaan harus diantrikan.  Tetapi pada saat yang sama, perlu untuk memeriksa keunikan permintaan - jika kami memiliki tiga permintaan yang identik menunggu untuk diproses (mis., Kami perlu mengonversi gambar yang sama dengan cara yang sama), maka kami harus memproses gambar hanya sekali, dan memberikan hasil pemrosesan sebagai tanggapan untuk tiga permintaan ini.  Yaitu  Dalam antrian tunggu, permintaan identik harus dikelompokkan. <br><br>  Sebelumnya di Shrimp, kami menggunakan kunci komposit sederhana untuk mencari cache gambar dan antrian tunggu: <a href="">kombinasi nama file asli + opsi pengubahan ukuran gambar</a> .  Sekarang, dua faktor baru harus diperhitungkan: <br><br><ul><li>  pertama, format gambar target (mis., gambar asli bisa dalam jpg, dan gambar yang dihasilkan bisa di png); </li><li>  kedua, fakta bahwa memperbesar gambar mungkin tidak perlu.  Ini terjadi dalam situasi di mana klien hanya memesan konversi gambar dari satu format ke format lain, tetapi dengan ukuran asli gambar dipertahankan. </li></ul><br>  Saya harus mengatakan bahwa di sini kami menyusuri jalan yang paling sederhana, tanpa berusaha mengoptimalkan apa pun.  Misalnya, seseorang dapat mencoba membuat dua cache: satu akan menyimpan gambar dalam format asli, tetapi diskalakan ke ukuran yang diinginkan, dan yang kedua, gambar skala dikonversi ke format target. <br><br>  Mengapa caching ganda seperti itu dibutuhkan?  Faktanya adalah ketika mengubah gambar, dua operasi termahal dalam waktu adalah mengubah ukuran dan membuat serial gambar ke format target.  Oleh karena itu, jika kami menerima permintaan untuk mengubah skala gambar example.jpg ke ukuran 1920 dan mengubahnya menjadi format webp, maka kami dapat menyimpan dua gambar dalam memori kami: example_1920px_width.jpg dan example_1920px_width.webp.  Kami akan memberikan gambar example_1920px_width.webp ketika kami menerima permintaan kedua.  Tetapi gambar example_1920px_width.jpg dapat digunakan ketika menerima permintaan untuk menskalakan example.jpg dengan ukuran 1920 lebar dan mengubahnya menjadi format heic.  Kami dapat melewati operasi pengubahan ukuran dan hanya melakukan konversi format (mis., Gambar yang sudah selesai example_1920px_width.jpg akan ditranskode ke dalam format heic). <br><br>  Peluang potensial lain: ketika permintaan datang untuk mentranskode gambar ke format lain tanpa mengubah ukuran, Anda dapat menentukan ukuran sebenarnya dari gambar dan menggunakan ukuran ini di dalam kunci komposit.  Misalnya, misalkan example.jpg memiliki ukuran 3000x2000 piksel.  Jika kami selanjutnya menerima permintaan untuk menskalakan example.jpg hingga ketinggian 2000px, maka kami dapat segera menentukan bahwa kami sudah memiliki gambar dalam ukuran ini. <br><br>  Secara teori, semua pertimbangan ini patut mendapat perhatian.  Tetapi dari sudut pandang praktis, tidak jelas seberapa tinggi kemungkinan perkembangan peristiwa tersebut.  Yaitu  seberapa sering kita akan menerima permintaan untuk penskalaan example.jpg ke 1920px dengan konversi ke webp, dan kemudian permintaan untuk penskalaan yang sama dari gambar yang sama, tetapi dengan konversi ke png?  Tidak memiliki statistik nyata sulit untuk dikatakan.  Oleh karena itu, kami memutuskan untuk tidak mempersulit kehidupan kami dalam proyek demo kami, tetapi untuk pergi dulu di jalan yang paling sederhana.  Dengan harapan bahwa jika seseorang membutuhkan skema caching yang lebih canggih, maka ini dapat ditambahkan nanti, mulai dari skenario nyata, bukan fiktif, untuk menggunakan udang. <br><br>  Akibatnya, dalam versi udang yang diperbarui, kami sedikit memperluas kunci, menambahkannya juga parameter seperti format target: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resize_request_key_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_path; <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> m_format; <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> m_params; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format, <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params ) : m_path{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(path) } , m_format{ format } , m_params{ params } {} [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> &amp; o ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( m_path, m_format, m_params ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( o.m_path, o.m_format, o.m_params ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_path; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_format; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_params; } };</code> </pre> <br>  Yaitu  permintaan untuk mengubah ukuran example.jpg hingga 1920px dengan konversi ke png berbeda dari pengubahan ukuran yang sama, tetapi dengan konversi ke webp atau heic. <br><br>  Tetapi fokus utama bersembunyi <a href="">di implementasi baru dari kelas resize_params_t</a> , yang menentukan ukuran baru dari gambar yang diskalakan.  <a href="">Sebelumnya, kelas ini</a> mendukung tiga opsi: hanya lebar yang ditetapkan, hanya tinggi yang ditetapkan, atau sisi panjang yang ditetapkan (tinggi atau lebar ditentukan oleh ukuran gambar saat ini).  Dengan demikian, metode <a href="">resize_params_t :: value ()</a> selalu mengembalikan beberapa nilai nyata (nilai apa yang ditentukan oleh metode <a href="">resize_params_t :: mode ()</a> ). <br><br>  Tetapi dalam udang baru, mode lain ditambahkan - keep_original, yang berarti bahwa penskalaan tidak dilakukan dan gambar ditampilkan dalam ukuran aslinya.  Untuk mendukung mode ini, resize_params_t harus membuat beberapa perubahan.  Pertama, sekarang metode <a href="">resize_params_t :: make ()</a> menentukan apakah mode keep_original digunakan (dianggap bahwa mode ini digunakan jika tidak ada parameter lebar, tinggi dan maks dalam string kueri permintaan yang masuk ditentukan).  Ini memungkinkan kami untuk tidak menulis ulang fungsi <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">handle_resize_op_request ()</a> , yang mendorong permintaan untuk menskala gambar yang akan dieksekusi. <br><br>  Kedua, metode <a href="">resize_params_t :: value ()</a> sekarang dapat dipanggil tidak selalu, tetapi hanya ketika mode penskalaan berbeda dari keep_original. <br><br>  Tetapi yang paling penting adalah bahwa <a href="">resize_params_t :: operator &lt;()</a> terus bekerja seperti yang dimaksudkan. <br><br>  Berkat semua perubahan ini di a_transform_manager, cache gambar yang diskalakan dan antrian permintaan tunggu tetap sama.  Tetapi sekarang, informasi tentang berbagai pertanyaan disimpan dalam struktur data ini.  Jadi, kunci {"example.jpg", "jpg", keep_original} akan berbeda dari kunci {"example.jpg", "png", keep_original}, dan dari kunci {"example.jpg", "jpg", lebar = 1920px}. <br><br>  Ternyata setelah sedikit manja dengan definisi struktur data sederhana seperti resize_params_t dan resize_params_key_t, kami menghindari mengubah struktur yang lebih kompleks seperti cache gambar yang dihasilkan dan antrian permintaan tunggu. <br><br><h2>  Dukungan untuk format target di a_transformer </h2><br>  Nah, langkah terakhir dalam mendukung format target adalah untuk memperluas logika agen a_transformer sehingga gambar, mungkin sudah diskalakan, kemudian dikonversi ke format target. <br><br>  Ternyata menjadi yang paling mudah untuk melakukan ini, yang diperlukan hanyalah memperluas kode metode <a href="">a_transform_t :: handle_resize_request ()</a> : <br><br><pre> <code class="hljs pgsql">[[nodiscard]] a_transform_manager_t::resize_result_t::result_t a_transformer_t::handle_resize_request( const <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_request_key_t &amp; key ) { try { m_logger-&gt;trace( "transformation started; request_key={}", key ); auto image = load_image( key.path() ); const auto resize_duration = measure_duration( [&amp;]{ //       //    keep_original. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_params_t::mode_t::keep_original != key.params().mode() ) { <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize( key.params(), total_pixel_count, image ); } } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "resize finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( resize_duration).count() ); image.magick( magick_from_image_format( key.format() ) ); datasizable_blob_shared_ptr_t blob; const auto serialize_duration = measure_duration( [&amp;] { blob = make_blob( image ); } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "serialization finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( serialize_duration).count() ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::successful_resize_t{ std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(blob), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( resize_duration), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( serialize_duration) }; } catch( const std::<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> &amp; x ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::failed_resize_t{ x.what() }; } }</code> </pre> <br>  Dibandingkan <a href="">dengan versi sebelumnya,</a> ada dua tambahan mendasar. <br><br>  Pertama, memanggil metode image.magick () yang benar-benar ajaib setelah mengubah ukuran.  Metode ini memberi tahu ImageMagick format gambar yang dihasilkan.  Pada saat yang sama, representasi gambar dalam memori tidak berubah - ImageMagick terus menyimpannya sesuai keinginan.  Tetapi kemudian nilai yang ditetapkan oleh metode magick () akan diperhitungkan selama panggilan berikutnya ke Image :: write (). <br><br>  Kedua, versi yang diperbarui mencatat waktu yang diperlukan untuk membuat serialisasi gambar ke format yang ditentukan.  Versi baru dari Udang sekarang secara terpisah memperbaiki waktu yang dihabiskan untuk penskalaan, dan waktu yang dihabiskan untuk mengonversi ke format target. <br><br>  Sisa agen a_transformer_t belum mengalami perubahan apa pun. <br><br><h1>  Paralelisasi ImageMagick </h1><br>  Secara default, ImageMagic dibangun dengan dukungan OpenMP.  Yaitu  dimungkinkan untuk memparalelkan operasi pada gambar yang dilakukan ImageMagick.  Anda dapat mengontrol jumlah alur kerja yang digunakan ImageMagick dalam hal ini menggunakan variabel lingkungan MAGICK_THREAD_LIMIT. <br><br>  Misalnya, pada mesin pengujian saya dengan nilai MAGICK_THREAD_LIMIT = 1 (mis., Tanpa paralelisasi nyata), saya mendapatkan hasil berikut: <br><br><pre> <code class="hljs powershell">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> &gt; /dev/null &gt; GET /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep<span class="hljs-literal"><span class="hljs-literal">-alive</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; Server: Shrimp draft server &lt; Date: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Last<span class="hljs-literal"><span class="hljs-literal">-Modified</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Allow</span></span><span class="hljs-literal"><span class="hljs-literal">-Origin</span></span>: * &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Expose</span></span><span class="hljs-literal"><span class="hljs-literal">-Headers</span></span>: Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: image/jpeg &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span>: transform &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">1323</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">1086.72</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">236.276</span></span></code> </pre><br>  Waktu yang dihabiskan untuk mengubah ukuran ditunjukkan di tajuk Shrimp-Resize-Time.  Dalam hal ini, adalah 1086,72 ms. <br><br>  Tetapi jika Anda menetapkan MAGICK_THREAD_LIMIT = 3 pada mesin yang sama dan menjalankan Shrimp, maka kami mendapatkan nilai yang berbeda: <br><br><pre> <code class="hljs powershell">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> &gt; /dev/null &gt; GET /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep<span class="hljs-literal"><span class="hljs-literal">-alive</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; Server: Shrimp draft server &lt; Date: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Last<span class="hljs-literal"><span class="hljs-literal">-Modified</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Allow</span></span><span class="hljs-literal"><span class="hljs-literal">-Origin</span></span>: * &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Expose</span></span><span class="hljs-literal"><span class="hljs-literal">-Headers</span></span>: Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: image/jpeg &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span>: transform &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">779.901</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">558.246</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">221.655</span></span></code> </pre> <br>  Yaitu  mengubah ukuran waktu dikurangi menjadi 558,25 ms. <br><br>  Karena itu, karena ImageMagick menyediakan kemampuan untuk memparalelkan perhitungan, Anda dapat menggunakan kesempatan ini.  Tetapi pada saat yang sama, diinginkan untuk dapat mengontrol berapa banyak benang kerja yang dibutuhkan udang untuk dirinya sendiri.  Dalam versi udang sebelumnya, tidak mungkin untuk mempengaruhi berapa banyak alur kerja yang diciptakan udang.  Dan dalam versi udang yang diperbarui, ini bisa dilakukan.  Atau melalui variabel lingkungan, misalnya: <br><br><pre> <code class="hljs tex">SHRIMP_IO_THREADS=1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>SHRIMP_WORKER_THREADS=3 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>MAGICK_THREAD_LIMIT=4 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>shrimp.app -p 8080 -i ...</code> </pre> <br>  Atau melalui argumen baris perintah, misalnya: <br><br><pre> <code class="hljs powershell">MAGICK_THREAD_LIMIT=<span class="hljs-number"><span class="hljs-number">4</span></span> \ shrimp.app <span class="hljs-literal"><span class="hljs-literal">-p</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-literal"><span class="hljs-literal">-i</span></span> ... -<span class="hljs-literal"><span class="hljs-literal">-io</span></span><span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-literal"><span class="hljs-literal">-worker</span></span><span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Nilai yang ditentukan melalui baris perintah memiliki prioritas yang lebih tinggi. <br><br>  Harus ditekankan bahwa MAGICK_THREAD_LIMIT hanya memengaruhi operasi yang dilakukan ImageMagick sendiri.  Misalnya, pengubahan ukuran dilakukan oleh ImageMagick.  Tetapi konversi dari satu format ke delegasi ImageMagick lain ke perpustakaan eksternal.  Dan bagaimana operasi di perpustakaan eksternal ini diparalelkan adalah masalah terpisah yang tidak kami pahami. <br><br><h1>  Kesimpulan </h1><br>  Mungkin, dalam versi udang ini, kami membawa proyek demo kami ke kondisi yang dapat diterima.  Mereka yang ingin melihat dan bereksperimen dapat menemukan teks sumber Shrimp di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BitBucket</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Anda juga dapat menemukan Dockerfile di sana untuk membuat udang untuk percobaan Anda. <br><br>  Secara umum, kami telah mencapai tujuan kami yang kami tetapkan sendiri dengan memulai proyek demo ini.  Sejumlah ide muncul untuk pengembangan lebih lanjut dari RESTinio dan SObjectizer, dan beberapa dari mereka telah menemukan perwujudan mereka.  Oleh karena itu, apakah udang akan berkembang di suatu tempat lebih lanjut sepenuhnya tergantung pada pertanyaan dan keinginan.  Jika ada, maka udang bisa berkembang.  Jika tidak, maka Shrimp akan tetap menjadi proyek demo dan tempat pelatihan untuk bereksperimen dengan versi baru RESTinio dan SObjectizer. <br><br>  Sebagai penutup, saya ingin mengucapkan terima kasih khusus kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">aensidhe</a> atas bantuan dan saran mereka, yang tanpanya tarian kami dengan rebana akan jauh lebih lama dan sedih. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420353/">https://habr.com/ru/post/id420353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420343/index.html">Lampu LED OK</a></li>
<li><a href="../id420345/index.html">Ikhtisar pusat data IXcellerate (ruang mesin terbesar di Federasi Rusia)</a></li>
<li><a href="../id420347/index.html">Pelajari cara membuat perintah bash Anda sendiri dalam waktu kurang dari 4 menit</a></li>
<li><a href="../id420349/index.html">Daftar periksa outsourcing IT: bekerja tanpa risiko</a></li>
<li><a href="../id420351/index.html">Cara melakukan pencarian pengguna di GitHub menggunakan Vue</a></li>
<li><a href="../id420355/index.html">Smart watch Pebble: bagaimana menjadi langka dalam semalam</a></li>
<li><a href="../id420357/index.html">Vuex: menyusun proyek-proyek besar dan bekerja dengan modul</a></li>
<li><a href="../id420359/index.html">Var, biarkan atau const? Masalah Lingkup Variabel dan ES6</a></li>
<li><a href="../id420361/index.html">Bug saat menjalankan TextBox.GetLineText di .NET WPF</a></li>
<li><a href="../id420363/index.html">Webinar HPE pada Agustus-Oktober: topik baru (+ SHD, praktik AI, penyimpanan turnkey petabyte)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>