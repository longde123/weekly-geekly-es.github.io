<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏼 🤛🏻 ♓️ Portierungsbeben 3 nach Rust 👼🏻 🖖🏾 😺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unser Team Immunant liebt Rust und arbeitet aktiv an C2Rust, einem Migrationsframework, das sich um die gesamte Routine der Migration nach Rust kümmer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Portierungsbeben 3 nach Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483142/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2c/61d/a4f/d2c61da4f8dfcdfb39d9fbd7787070a4.png"></div><br>  Unser Team Immunant liebt Rust und arbeitet aktiv an C2Rust, einem Migrationsframework, das sich um die gesamte Routine der Migration nach Rust kümmert.  Wir bemühen uns, automatisch Sicherheitsverbesserungen im konvertierten Rust-Code einzuführen und dem Programmierer zu helfen, dies selbst zu tun, wenn das Framework ausfällt.  Zunächst müssen wir jedoch einen zuverlässigen Übersetzer erstellen, mit dem Benutzer mit Rust beginnen können.  Da das Testen mit kleinen CLI-Programmen langsam veraltet ist, haben wir uns entschlossen, Quake 3 auf Rust zu übertragen. Nach ein paar Tagen waren wir höchstwahrscheinlich die Ersten, die Quake3 auf Rust spielten! <br><br><h2>  Vorbereitung: 3 Quellen beben </h2><br>  Nachdem wir den Quellcode des ursprünglichen Quake 3 und verschiedener Gabeln studiert hatten, entschieden wir uns für <a href="https://ioquake3.org/">ioquake3</a> .  Dies ist eine von der Community erstellte Abzweigung von Quake 3, die weiterhin auf modernen Plattformen unterstützt und aufgebaut wird. <br><a name="habracut"></a><br>  Als Ausgangspunkt haben wir uns entschieden, sicherzustellen, dass wir das Projekt in seiner ursprünglichen Form zusammenstellen können: <br><br><pre><code class="bash hljs">$ make release</code> </pre> <br>  Beim Erstellen von ioquake3 werden mehrere Bibliotheken und ausführbare Dateien erstellt: <br><br><pre> <code class="bash hljs">$ tree --prune -I missionpack -P <span class="hljs-string"><span class="hljs-string">"*.so|*x86_64"</span></span> . └── build └── debug-linux-x86_64 ├── baseq3 │ ├── cgamex86_64.so <span class="hljs-comment"><span class="hljs-comment"># client │ ├── qagamex86_64.so # game server │ └── uix86_64.so # ui ├── ioq3ded.x86_64 # dedicated server binary ├── ioquake3.x86_64 # main binary ├── renderer_opengl1_x86_64.so # opengl1 renderer └── renderer_opengl2_x86_64.so # opengl2 renderer</span></span></code> </pre> <br>  Unter diesen Bibliotheken können die Benutzeroberflächen-, Client- und Serverbibliotheken entweder als <a href="https://fabiensanglard.net/quake3/qvm.php">Quake VM-</a> Assembly oder als native gemeinsam genutzte X86-Bibliotheken kompiliert werden.  In unserem Projekt haben wir uns für native Versionen entschieden.  Das Übersetzen von VMs nach Rust und die Verwendung von QVM-Versionen wären viel einfacher, aber wir wollten C2Rust gründlich testen. <br><br>  In unserem Transferprojekt haben wir uns auf die Benutzeroberfläche, das Spiel, den Client, den OpenGL1-Renderer und die ausführbare Hauptdatei konzentriert.  Wir könnten den OpenGL2-Renderer auch übersetzen, haben uns jedoch dafür entschieden, dies zu überspringen, da er eine erhebliche Menge von <code>.glsl</code> Shader- <code>.glsl</code> , die das Build-System als String-Literale in den C-Quellcode einbettet GLSL-Code in Rust-Strings, aber es gibt immer noch keine gute automatisierte Möglichkeit, diese automatisch generierten temporären Dateien zu transponieren.  Stattdessen haben wir einfach die OpenGL1-Renderer-Bibliothek übersetzt und das Spiel gezwungen, sie anstelle des Standard-Renderers zu verwenden.  Darüber hinaus haben wir beschlossen, die dedizierten Server- und verpackten Missionsdateien zu überspringen, da sie nicht schwer zu übertragen sind und für unsere Demonstration nicht erforderlich sind. <br><br><h2>  Transponieren Sie Quake 3 </h2><br>  Um die in Quake 3 verwendete Verzeichnisstruktur beizubehalten und den Quellcode nicht zu ändern, mussten genau die gleichen Binärdateien wie in der nativen Assembly abgerufen werden, d. H. Vier gemeinsam genutzte Bibliotheken und eine ausführbare Datei. <br><br>  Da C2Rust die Cargo-Assembly-Dateien erstellt, benötigt jede Binärdatei eine eigene Rust-Kiste mit der entsprechenden <code>Cargo.toml</code> Datei. <br><br>  Damit C2Rust eine Kiste pro Ausgabebinärdatei erstellen kann, wird außerdem eine Liste der Binärdateien mit den entsprechenden Objekt- oder Quelldateien sowie ein Linkaufruf zum Erstellen jeder Binärdatei benötigt (um andere Details zu bestimmen, z. B. Bibliotheksabhängigkeiten). <br><br>  Wir stießen jedoch schnell auf eine Einschränkung, die dadurch verursacht wurde, dass C2Rust den systemeigenen Erstellungsprozess abfängt: C2Rust empfängt am Eingang eine <a href="https://sarcasm.github.io/notes/dev/compilation-database.html">Kompilierungsdatenbankdatei</a> , die eine Liste der Kompilierungsbefehle enthält, die während der Erstellung ausgeführt werden.  Diese Datenbank enthält jedoch <strong>nur</strong> Kompilierungsbefehle ohne Linker-Aufrufe.  Die meisten Tools, die diese Datenbank erstellen, haben diese absichtliche Einschränkung, z. B. <code>cmake</code> with <code>CMAKE_EXPORT_COMPILE_COMMANDS</code> , <code>bear</code> und <code>compiledb</code> .  Unserer Erfahrung nach ist das einzige Tool, das <a href="https://github.com/Ericsson/codechecker/tree/master/analyzer/tools/build-logger"><code>build-logger</code></a> Befehle enthält <a href="https://github.com/Ericsson/codechecker/tree/master/analyzer/tools/build-logger"><code>build-logger</code></a> der von <code>CodeChecker</code> erstellte <a href="https://github.com/Ericsson/codechecker/tree/master/analyzer/tools/build-logger"><code>build-logger</code></a> , den wir nicht verwendet haben, weil wir erst nach dem Schreiben unserer eigenen Wrapper davon erfahren haben (sie werden unten beschrieben).  Dies bedeutete, dass wir zum Kompilieren eines C-Programms mit mehreren Binärdateien nicht die Datei <code>compile_commands.json</code> verwenden konnten, die mit einem der gängigen Tools erstellt wurde. <br><br>  Aus diesem Grund haben wir unsere eigenen <a href="https://github.com/immunant/c2rust/blob/master/scripts/cc-wrappers/cc">Compiler-</a> und <a href="https://github.com/immunant/c2rust/blob/master/scripts/cc-wrappers/ld">Linker-</a> Wrapper-Skripts geschrieben, die alle Aufrufe des Compilers und des Linkers an die Datenbank <code>compile_commands.json</code> und anschließend in die erweiterte <code>compile_commands.json</code> .  Anstelle der üblichen Montage mit einem Befehl wie: <br><br><pre> <code class="bash hljs">$ make release</code> </pre> <br>  Wir haben Wrapper hinzugefügt, um die Assembly abzufangen mit: <br><br><pre> <code class="bash hljs">$ make release CC=/path/to/C2Rust/scripts/cc-wrappers/cc</code> </pre> <br>  Wrapper erstellen ein Verzeichnis mit mehreren JSON-Dateien, eine pro Aufruf.  Das zweite <a href="https://github.com/immunant/c2rust/blob/master/scripts/convert_build_commands.py">Skript</a> sammelt alle in einer neuen <code>compile_commands.json</code> Datei, die sowohl Kompilierungs- als auch Kompilierungsbefehle enthält.  Dann haben wir C2Rust so erweitert, dass es die Build-Befehle aus der Datenbank liest und für jede verknüpfte Binärdatei eine separate Kiste erstellt.  Darüber hinaus liest C2Rust jetzt auch Bibliotheksabhängigkeiten für jede Binärdatei und fügt sie automatisch der <code>build.rs</code> Datei der entsprechenden Kiste hinzu. <br><br>  Zur Verbesserung der Benutzerfreundlichkeit können alle Binärdateien gleichzeitig erfasst werden, indem sie im <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">Arbeitsbereich abgelegt werden</a> .  C2Rust erstellt die <code>Cargo.toml</code> Datei des Arbeitsbereichs der obersten Ebene, sodass wir das Projekt mit dem einzigen <code>cargo build</code> zum <code>quake3-rs</code> <code>cargo build</code> im <code>quake3-rs</code> : <br><br><pre> <code class="bash hljs">$ tree -L 1 . ├── Cargo.lock ├── Cargo.toml ├── cgamex86_64 ├── ioquake3 ├── qagamex86_64 ├── renderer_opengl1_x86_64 ├── rust-toolchain └── uix86_64 $ cargo build --release</code> </pre> <br><h2>  Rauheit beseitigen </h2><br>  Als wir zum ersten Mal versuchten, den übersetzten Code zu kompilieren, hatten wir einige Probleme mit den Quake 3-Quellen: Es gab Grenzfälle, die C2Rust nicht handhaben konnte (weder richtig noch irgendwie). <br><br><h3>  Array-Zeiger </h3><br>  Mehrere Stellen im ursprünglichen Quellcode enthalten Ausdrücke, die auf das nächste Element nach dem letzten Array-Element verweisen.  Hier ist ein vereinfachtes C-Codebeispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p; <span class="hljs-comment"><span class="hljs-comment">// ... if (p &gt;= &amp;array[1024]) { // error... }</span></span></code> </pre> <br>  Der C-Standard (siehe z. B. <a href="http://www.iso-9899.info/n1570.html">C11, Abschnitt 6.5.6</a> ) ermöglicht es Zeigern auf ein Element, über das Ende eines Arrays hinauszugehen.  Rust verbietet dies jedoch, auch wenn wir nur die Adresse des Elements nehmen.  Beispiele für ein solches Muster haben wir in der Funktion <a href=""><code>AAS_TraceClientBBox</code></a> . <br><br>  Der Rust-Compiler signalisierte auch ein ähnliches, aber tatsächlich <a href=""><code>G_TryPushingEntity</code></a> Beispiel in <a href=""><code>G_TryPushingEntity</code></a> , wo die bedingte Anweisung die Form <code>&gt;</code> , nicht <code>&gt;=</code> .  Ein außerhalb der Grenzen liegender Zeiger wird dann nach dem bedingten Konstrukt dereferenziert, bei dem es sich um einen Speicher-Sicherheitsfehler handelt. <br><br>  Um dieses Problem in Zukunft zu vermeiden, haben wir den C2Rust-Transpiler so korrigiert, dass er Zeigerarithmetik verwendet, um die Adresse eines Array-Elements zu berechnen, anstatt die Array-Indizierungsoperation zu verwenden.  Dank dieses Fixes wird Code, der das ähnliche Muster "Elementadresse am Ende des Arrays" verwendet, jetzt korrekt übersetzt und ohne Änderungen ausgeführt. <br><br><h3>  Array-Elemente mit variabler Länge </h3><br>  Wir haben das Spiel gestartet, um alles zu testen und haben sofort Panik von Rust bekommen: <br><br><pre> <code class="cpp hljs">thread <span class="hljs-string"><span class="hljs-string">'main'</span></span> panicked at <span class="hljs-string"><span class="hljs-string">'index out of bounds: the len is 4 but the index is 4'</span></span>, quake3-client/src/cm_polylib.rs:<span class="hljs-number"><span class="hljs-number">973</span></span>:<span class="hljs-number"><span class="hljs-number">17</span></span></code> </pre> <br>  Bei einem Blick auf <code>cm_polylib.c</code> haben wir festgestellt, dass das Feld <code>p</code> in der folgenden Struktur dereferenziert wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numpoints; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> p[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// variable sized } winding_t;</span></span></code> </pre> <br>  Das <code>p</code> Feld in der Struktur ist eine Version des flexiblen Array-Members, die vom C99-Standard nicht unterstützt wird, aber dennoch von <code>gcc</code> akzeptiert wird.  C2Rust erkennt Elemente von Arrays variabler Länge mit der Syntax C99 ( <code>vec3_t p[]</code> ) und implementiert eine einfache <a href="">Heuristik,</a> um auch Versionen dieses Musters vor C99 zu identifizieren (Arrays der Größen 0 und 1 am Ende von Strukturen; wir haben auch mehrere solche Beispiele im Quellcode von ioquake3 gefunden). <br><br>  <a href="https://github.com/immunant/ioq3/commit/ace1fae43e736613544c8d33cc69dee794f5124a">Durch Ändern</a> der obigen Struktur in C99-Syntax wurde die Panik beseitigt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numpoints; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> p[]; <span class="hljs-comment"><span class="hljs-comment">// variable sized } winding_t;</span></span></code> </pre> <br>  Ein Versuch, dieses Muster im allgemeinen Fall (mit von 0 und 1 verschiedenen Arraygrößen) automatisch zu korrigieren, ist äußerst schwierig, da zwischen gewöhnlichen Arrays und Elementen von Arrays variabler Länge beliebiger Größen unterschieden werden muss.  Aus diesem Grund empfehlen wir Ihnen, den ursprünglichen C-Code manuell zu korrigieren, wie wir es mit ioquake3 getan haben. <br><br><h3>  Gebundene Operanden im Inline-Assembler-Code </h3><br>  Eine weitere <code>/usr/include/bits/select.h</code> war der folgende C-Assembler-Assembler-Code aus dem <code>/usr/include/bits/select.h</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __FD_ZERO(fdsp) \ do { \ int __d0, __d1; \ __asm__ __volatile__ (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cld; rep; "</span></span></span><span class="hljs-meta"> __FD_ZERO_STOS \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=c"</span></span></span><span class="hljs-meta"> (__d0), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=D"</span></span></span><span class="hljs-meta"> (__d1) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"a"</span></span></span><span class="hljs-meta"> (0), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"0"</span></span></span><span class="hljs-meta"> (sizeof (fd_set) \ / sizeof (__fd_mask)), \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1"</span></span></span><span class="hljs-meta"> (&amp;__FDS_BITS (fdsp)[0]) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"memory"</span></span></span><span class="hljs-meta">); \ } while (0)</span></span></code> </pre> <br>  Definieren der internen Version des <code>__FD_ZERO</code> .  Diese Definition wirft einen seltenen Grenzfall für <code>gcc</code> : <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">tied-Operanden-E / A</a> mit unterschiedlichen Größen auf.  Der Ausgabeoperator <code>"=D" (__d1)</code> bindet das <code>edi</code> Register als 32-Bit-Wert an die Variable <code>__d1</code> , und <code>"1" (&amp;__FDS_BITS (fdsp)[0])</code> bindet dasselbe Register an die Adresse <code>fdsp-&gt;fds_bits</code> als 64-Bit-Zeiger.  <code>gcc</code> und <code>clang</code> beheben dieses Missverhältnis.  <code>rdi</code> das 64-Bit- <code>rdi</code> Register verwenden und dessen Wert <code>__d1</code> , bevor Sie den Wert <code>__d1</code> , verwendet Rust standardmäßig die LLVM-Semantik, in der ein solcher Fall nicht definiert ist.  In den Debug-Builds (nicht in den Release-Builds, die sich gut verhalten haben) haben wir gesehen, dass beide Operanden dem <code>edi</code> Register zugewiesen werden können, wodurch der Zeiger vor dem eingebauten Assembler-Code auf 32 Bit gekürzt wird, was zu Fehlern führt. <br><br>  Da <code>rustc</code> den eingebauten Rust-Assembler-Code mit nur geringen Änderungen an LLVM weitergibt, haben wir uns entschlossen, diesen speziellen Fall in C2Rust zu beheben.  Wir haben eine neue Kiste <a href="https://github.com/immunant/c2rust/tree/master/c2rust-asm-casts"><code>c2rust-asm-casts</code></a> implementiert, die dieses Problem dank des Rust-Typ-Systems <a href="https://github.com/immunant/c2rust/tree/master/c2rust-asm-casts"><code>c2rust-asm-casts</code></a> Dabei werden <a href="">Eigenschaften-</a> und Hilfsfunktionen verwendet, die gebundene Operanden automatisch erweitern und auf eine interne Größe <a href="https://github.com/immunant/c2rust/tree/master/c2rust-asm-casts"><code>c2rust-asm-casts</code></a> , die groß genug ist, um beide Operanden aufzunehmen.  Der obige Code wird korrekt in Folgendes übersetzt: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> __d0: c_int = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> __d1: c_int = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Reference to the output value of the first operand let fresh5 = &amp;mut __d0; // The internal storage for the first tied operand let fresh6; // Reference to the output value of the second operand let fresh7 = &amp;mut __d1; // The internal storage for the second tied operand let fresh8; // Input value of the first operand let fresh9 = (::std::mem::size_of::&lt;fd_set&gt;() as c_ulong).wrapping_div(::std::mem::size_of::&lt;__fd_mask&gt;() as c_ulong); // Input value of the second operand let fresh10 = &amp;mut *fdset.__fds_bits.as_mut_ptr().offset(0) as *mut __fd_mask; asm!("cld; rep; stosq" : "={cx}" (fresh6), "={di}" (fresh8) : "{ax}" (0), // Cast the input operands into the internal storage type // with optional zero- or sign-extension "0" (AsmCast::cast_in(fresh5, fresh9)), "1" (AsmCast::cast_in(fresh7, fresh10)) : "memory" : "volatile"); // Cast the operands out (types are inferred) with truncation AsmCast::cast_out(fresh5, fresh9, fresh6); AsmCast::cast_out(fresh7, fresh10, fresh8);</span></span></code> </pre> <br>  Es ist anzumerken, dass für diesen Code keine Typen für Eingabe- und Ausgabewerte in der Assembly des Assembler-Codes <code>fresh8</code> . <code>fresh6</code> <code>fresh8</code> lösen, verlassen Sie sich stattdessen auf diese, um Rust-Typen (hauptsächlich <code>fresh6</code> und <code>fresh8</code> ) <code>fresh8</code> . <br><br><h3>  Ausgerichtete globale Variablen </h3><br>  Die letzte Fehlerquelle war die folgende globale Variable, in der die SSE-Konstante gespeichert ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ssemask[<span class="hljs-number"><span class="hljs-number">16</span></span>] __attribute__((aligned(<span class="hljs-number"><span class="hljs-number">16</span></span>))) = { <span class="hljs-string"><span class="hljs-string">"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x00\x00\x00\x00"</span></span> };</code> </pre> <br>  Rust unterstützt derzeit das Ausrichtungsattribut für Strukturtypen, jedoch nicht für globale Variablen, d. H.  <code>static</code> Elemente.  Wir haben überlegt, wie wir dieses Problem im allgemeinen Fall lösen können, entweder in Rust oder in C2Rust. In ioquake3 haben wir uns jedoch entschieden, es manuell mit einer kurzen <a href="https://github.com/immunant/ioq3/blob/master/asm-snapvector.patch">Patch-</a> Datei zu beheben.  Diese Patch-Datei ersetzt die Entsprechung von Rust <code>ssemask</code> Folgendes: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C, align(16))]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SseMask</span></span></span></span>([<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">16</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ssemask: SseMask = SseMask([ <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ]);</code> </pre> <br><h2>  Laufen quake3-rs </h2><br>  Beim <code>cargo build --release</code> werden Binärdateien erstellt, die jedoch unter <code>target/release</code> mit einer Verzeichnisstruktur erstellt werden, die von der <code>ioquake3</code> Binärdatei nicht erkannt wird.  Wir haben ein <a href="">Skript geschrieben</a> , das symbolische Links im aktuellen Verzeichnis erstellt, um die korrekte Verzeichnisstruktur wiederherzustellen (einschließlich Links zu <code>.pk3</code> Dateien, die <code>.pk3</code> enthalten): <br><br><pre> <code class="bash hljs">$ /path/to/make_quake3_rs_links.sh /path/to/quake3-rs/target/release /path/to/paks</code> </pre> <br>  Der Pfad <code>/path/to/paks</code> sollte auf das Verzeichnis verweisen, das die <code>.pk3</code> Dateien enthält. <br><br>  Jetzt lass uns das Spiel starten!  Wir müssen <code>+set vm_game 0</code> usw. übergeben, damit wir diese Module als gemeinsam genutzte Rust-Bibliotheken laden und nicht als QVM-Assembly sowie als <code>cl_renderer</code> , um den OpenGL1-Renderer zu verwenden. <br><br><pre> <code class="bash hljs">$ ./ioquake3 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> sv_pure 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_game 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_cgame 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_ui 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> cl_renderer <span class="hljs-string"><span class="hljs-string">"opengl1"</span></span></code> </pre> <br>  Und ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18e/fb3/94c/18efb394c9f33f6a1cbe78503a25bb4c.png"></div><br>  Wir haben Quake3 auf Rust gestartet! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2c/61d/a4f/d2c61da4f8dfcdfb39d9fbd7787070a4.png"></div><br>  Hier ist ein Video, wie wir Quake 3 transponieren, das Spiel herunterladen und ein bisschen davon spielen: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lQjvSJLDXW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Sie können die <a href="https://github.com/immunant/ioq3/tree/transpiled/quake3-rs">transpilierten Quellen</a> in der <code>transpiled</code> Filiale unseres <code>transpiled</code> studieren.  Es gibt auch einen <code>refactored</code> Zweig, der dieselben <a href="https://github.com/immunant/ioq3/tree/refactored/quake3-rs">Quellen</a> mit mehreren vorab angewendeten <a href="https://github.com/immunant/ioq3/blob/transpiled/refactor_commands.txt">Umgestaltungsbefehlen enthält</a> . <br><br><h2>  Wie transponieren </h2><br>  Wenn Sie versuchen möchten, Quake 3 zu transponieren und selbst auszuführen, müssen Sie Ihre eigenen Quake 3-Spiel- oder Demo-Ressourcen aus dem Internet bereitstellen.  Sie müssen auch C2Rust installieren (zum Zeitpunkt des Schreibens ist die erforderliche nächtliche Version <code>nightly-2019-12-05</code> , es wird jedoch empfohlen, <a href="https://github.com/immunant/c2rust">im</a> C2Rust- <a href="https://github.com/immunant/c2rust">Repository</a> oder in <a href="https://crates.io/crates/c2rust">crates.io</a> nach der neuesten Version zu suchen): <br><br><pre> <code class="bash hljs">$ cargo +nightly-2019-12-05 install c2rust</code> </pre> <br>  und Kopien unserer C2Rust- und ioquake3-Repositorys: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> &lt;a href=<span class="hljs-string"><span class="hljs-string">"/cdn-cgi/l/email-protection"</span></span> class=<span class="hljs-string"><span class="hljs-string">"__cf_email__"</span></span> data-cfemail=<span class="hljs-string"><span class="hljs-string">"dcbbb5a89cbbb5a8b4a9bef2bfb3b1"</span></span>&gt;[email protected]&lt;/a&gt;:immunant/c2rust.git $ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> &lt;a href=<span class="hljs-string"><span class="hljs-string">"/cdn-cgi/l/email-protection"</span></span> class=<span class="hljs-string"><span class="hljs-string">"__cf_email__"</span></span> data-cfemail=<span class="hljs-string"><span class="hljs-string">"dcbbb5a89cbbb5a8b4a9bef2bfb3b1"</span></span>&gt;[email protected]&lt;/a&gt;:immunant/ioq3.git</code> </pre> <br>  Alternativ zur Installation von <code>c2rust</code> mit dem obigen Befehl können Sie C2Rust manuell mit <code>cargo build --release</code> .  In jedem Fall wird das C2Rust-Repository weiterhin benötigt, da es die Compiler-Wrapper-Skripte enthält, die zur Transponierung von ioquake3 erforderlich sind. <br><br>  Wir haben ein <a href="">Skript veröffentlicht</a> , das automatisch C-Code transportiert und den <code>ssemask</code> Patch <code>ssemask</code> .  Führen Sie dazu den folgenden Befehl auf der obersten Ebene des <code>ioq3</code> Repositorys aus: <br><br><pre> <code class="bash hljs">$ ./transpile.sh &lt;/path/to/C2Rust repository&gt; &lt;/path/to/c2rust binary&gt;</code> </pre> <br>  Dieser Befehl sollte ein Unterverzeichnis <code>quake3-rs</code> mit Rust-Code erstellen, für das Sie dann den <code>cargo build --release</code> und die übrigen oben beschriebenen Schritte ausführen können. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483142/">https://habr.com/ru/post/de483142/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483130/index.html">Was tun, wenn der Code für das Kofferschloss vergessen wurde?</a></li>
<li><a href="../de483132/index.html">Design und Herstellung eines Teleskops</a></li>
<li><a href="../de483134/index.html">Testen der Zwei-Faktor-Authentifizierung und mögliche Problemumgehungen</a></li>
<li><a href="../de483136/index.html">Überprüfung des verwendeten MacBook vor dem Kauf - Checkliste</a></li>
<li><a href="../de483140/index.html">Polygone eine andere Welt: Amiga 500</a></li>
<li><a href="../de483144/index.html">Der Wissenschaftler He Jiankui ist ein Held, kein Verbrecher</a></li>
<li><a href="../de483146/index.html">DEFCON 27. Konferenz Kraken Wireless WiFi Hacking Tool</a></li>
<li><a href="../de483148/index.html">Wir diskutieren digitale Zwillinge und Simulationen mit dem Gründer eines Beratungsunternehmens</a></li>
<li><a href="../de483154/index.html">Ich gab 40.000 Dollar aus und ruinierte eine großartige Idee für ein Startup</a></li>
<li><a href="../de483156/index.html">Stellen Sie die Katze auf die Füße</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>