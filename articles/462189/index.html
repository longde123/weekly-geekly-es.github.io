<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüöí üöè üàÅ Grabado de datos con travajs üë¶üèæ ‚åõÔ∏è üëø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En mi publicaci√≥n anterior, describ√≠ los puntos principales al desarrollar otra biblioteca de c√≥digo abierto . Olvid√© mencionar una cosa m√°s: si no le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grabado de datos con travajs</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462189/"><img src="https://habrastorage.org/webt/kb/fw/tm/kbfwtmm5xe1jxdaa1l2avw8geuo.jpeg"><br><br>  En mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n anterior,</a> describ√≠ los puntos principales al desarrollar otra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca de c√≥digo abierto</a> .  Olvid√© mencionar una cosa m√°s: si no le cuenta a nadie sobre la biblioteca, sea lo que sea, lo m√°s probable es que nadie lo sepa. <br><br>  Entonces, conozca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trava.js</a> : validaci√≥n jugosa para el beneficio del proyecto.  Por cierto, hemos estado usando hierba durante m√°s de seis meses, y pens√© que era hora de informarle sobre los beneficios de usarla.  Ya est√° seco, as√≠ que aguanta la respiraci√≥n.  Y adelante. <br><a name="habracut"></a><br><h2>  Concepto </h2><br>  A primera vista, parece que la validaci√≥n es un tema trivial que no requiere atenci√≥n especial.  El valor es verdadero o no, lo que podr√≠a ser m√°s simple: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// any checking... if (!check(value)) return false; return true; }</span></span></code> </pre> <br>  Pero generalmente ser√≠a bueno saber qu√© sali√≥ mal exactamente: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check1(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'ERROR_1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check2(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'ERROR_2'</span></span>; }</code> </pre><br>  En realidad eso es todo, el problema est√° resuelto. <br><br>  Si no fuera por un "pero". <br><br>  Por la experiencia de desarrollar aplicaciones reales, se not√≥ que el asunto no termina con la validaci√≥n.  Por lo general, estos datos tambi√©n deben convertirse a un formato espec√≠fico, por alguna raz√≥n que el serializador no admite, por ejemplo, fechas, conjuntos u otros tipos de datos personalizados.  Dado que esto es principalmente JSON, en la pr√°ctica resulta que tienes que hacer un doble paso a trav√©s de la estructura de datos de entrada durante la validaci√≥n y la transformaci√≥n.  La idea surgi√≥, ¬øpor qu√© no combinar estas dos etapas en una sola?  Una posible ventaja tambi√©n ser√≠a la presencia de un esquema expl√≠cito de datos declarativos. <br><br>  Para admitir la conversi√≥n de un valor a un formato espec√≠fico, el validador debe poder devolver no solo un error, sino tambi√©n un valor reducido.  En el mundo js, ‚Äã‚Äãvarias opciones de interfaz son bastante comunes con posibles retornos de error. <br><br><ol><li>  Probablemente el m√°s com√∫n es el retorno de la tupla [error, datos]: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check1(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'ERROR_1'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check2(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'ERROR_2'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, value]; }</code> </pre> <br>  Tambi√©n hay una opci√≥n similar donde no se devuelve una matriz, sino el objeto <i>{error, data}</i> , pero no hay diferencias fundamentales.  La ventaja de este enfoque es la obviedad, lo negativo es que ahora en todas partes necesita mantener este contrato.  Para la validaci√≥n, esto no causa inconvenientes, pero para las transformaciones esto es claramente superfluo. <br></li><li>  Use excepciones.  Aunque en mi opini√≥n un error de validaci√≥n es una situaci√≥n est√°ndar en la aplicaci√≥n, nada es excepcional.  Honestamente, creo que las excepciones se usan mejor solo cuando algo realmente sali√≥ mal.  Adem√°s, las excepciones se pueden invocar accidentalmente en los validadores, y es posible que no sepa en absoluto que fue un error en el c√≥digo y no en el valor.  La ventaja del enfoque es la simplificaci√≥n de la interfaz: ahora siempre se devuelve el valor de la manera habitual y el error se arroja como una excepci√≥n. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hay una opci√≥n</a> para poner un error en una variable global.  Pero no sacar√≠a al estado innecesariamente. <br></li><li>  Use un tipo separado para los errores.  Parece la opci√≥n con excepciones, si les quitas el tipo de error, pero no lo descartes. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check1(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Trava.ValidationError({ <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-number"><span class="hljs-number">401</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check2(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Trava.ValidationError({ <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-number"><span class="hljs-number">405</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseOrTransform(value); <span class="hljs-comment"><span class="hljs-comment">// apply some parse or transform }</span></span></code> </pre> <br></li></ol>  Me decid√≠ por la √∫ltima opci√≥n, aunque esto tambi√©n es un compromiso, pero en general no est√° mal.  <i>Trava.ValidationError se</i> propone como un tipo para el error, que hereda del <i>error</i> est√°ndar y agrega la capacidad de usar un tipo de datos arbitrario para informar un error.  No es necesario usar <i>Trava.ValidationError</i> , puede usar el <i>error</i> est√°ndar, pero no olvide que el mensaje de error es solo cadenas. <br><br>  Para resumir, podemos decir que el validador es una funci√≥n limpia y sincr√≥nica que, adem√°s del valor, puede devolver un error.  Extremadamente simple  Y esta teor√≠a funciona bien sin bibliotecas.  En la pr√°ctica, los validadores se combinan en cadenas y jerarqu√≠as, y aqu√≠ la hierba definitivamente ser√° √∫til. <br><br><h2>  Composici√≥n </h2><br>  Quiz√°s la composici√≥n es el caso m√°s com√∫n de trabajar con validadores.  La implementaci√≥n de la composici√≥n puede ser diferente.  Por ejemplo, en las famosas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bibliotecas</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">joi</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">v8n,</a> esto se hace a trav√©s de un objeto y una cadena de m√©todos: <br><br><pre> <code class="javascript hljs">Joi.string().alphanum().min(<span class="hljs-number"><span class="hljs-number">0</span></span>).max(<span class="hljs-number"><span class="hljs-number">255</span></span>)</code> </pre> <br>  Aunque se ve hermoso a primera vista, este enfoque tiene varios inconvenientes, y uno es fatal.  Y aqu√≠ est√° la cosa.  En mi experiencia, un validador siempre es una cosa para una aplicaci√≥n espec√≠fica, por lo que el enfoque principal en la biblioteca debe estar en la conveniencia de expandir los validadores y la integraci√≥n con el enfoque existente, y no en el n√∫mero de primitivas b√°sicas, que, en mi opini√≥n, solo agregan peso a la biblioteca, pero la mayor√≠a no ser√° utilizada.  Tomemos, por ejemplo, el mismo validador para la cadena.  Luego resulta que necesita recortar los espacios desde los extremos, luego, de repente, debe permitir el uso de caracteres especiales en un solo caso, y en alg√∫n lugar debe llevar a min√∫sculas, etc.  De hecho, puede haber infinitas primitivas de este tipo, y no veo el punto de siquiera comenzar a agregarlas a la biblioteca.  En mi opini√≥n, el uso de objetos tambi√©n es redundante y conduce a un aumento de la complejidad durante la expansi√≥n, aunque a primera vista parece facilitar la vida.  Por ejemplo, c <i>joi</i> no <i>es</i> tan f√°cil <a href="">de escribir su validador</a> . <br><br>  Un enfoque funcional y una hierba aqu√≠ pueden ayudar.  El mismo ejemplo de validaci√≥n de un n√∫mero especificado en el rango de 0 a 255: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    const isNumber = n =&gt; typeof n == 'number' &amp;&amp; !isNaN(n); //  const numberValidator = Trava.Check(isNumber); const byteValidator = Trava.Compose([ numberValidator, Trava.Check(n =&gt; 0 &lt;= n &amp;&amp; n &lt; 256), ]); byteValidator(-1); // !</span></span></code> </pre><br>  La declaraci√≥n de <b>verificaci√≥n</b> hace un validador de la verificaci√≥n de la verdad (valor =&gt; verdadero / falso).  Y <b>Compose encadena los</b> validadores.  Cuando se ejecuta, la cadena se interrumpe despu√©s del primer error.  Lo importante es que las funciones ordinarias se usan en todas partes, que son muy simples de expandir y usar.  Es esta facilidad de expansi√≥n, en mi opini√≥n, que es una caracter√≠stica clave de una biblioteca de validaci√≥n v√°lida. <br><br>  Tradicionalmente, un lugar separado en la validaci√≥n se ocupa comprobando si hay <i>valores nulos</i> e <i>indefinidos</i> .  Hay operadores auxiliares en la hierba para esto: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   null  undefined const requiredNumberValidator = Trava.Required(numberValidator); requiredNumberValidator(undefined); // ! const optNumberValidator = Trava.Optional(numberValidator, 2); // 2 is default optNumberValidator(undefined); // 2 optNumberValidator(null); // null const nullNumberValidator = Trava.Nullable(numberValidator, 3); // 3 is default nullNumberValidator(undefined); // 3 nullNumberValidator(null); // 3</span></span></code> </pre><br>  Hay varios operadores auxiliares m√°s en el c√©sped, y todos componen maravillosamente y sorprendentemente simplemente se expanden.  Como funciones ordinarias :) <br><br><h2>  Jerarqu√≠a </h2><br>  Los tipos de datos simples se organizan en una jerarqu√≠a.  Los casos m√°s comunes son objetos y matrices.  Hay operadores en la hierba que hacen que sea m√°s f√°cil trabajar con ellos: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const byteArrayValidator = Trava.Each(byteValidator); byteArrayValidator([1, -1, 2, -3]); // ValidationError: {"1":"Incorrect value","3":"Incorrect value"} //   const pointValidator = Trava.Keys({ x: numberValidator, y: numberValidator, }); pointValidator({x: 1, y: 'a'}); // ValidationError: {"y":"Incorrect value"}</span></span></code> </pre><br>  Al validar los objetos, se decidi√≥ enfatizar la gravedad de la definici√≥n: todas las claves son obligatorias de forma predeterminada (incluidas en <b>Obligatorio</b> ).  Las claves no especificadas en el validador se descartan. <br><br>  Algunas soluciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jsonschema</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuarteto</a> prefieren describir validadores en forma de datos, por ejemplo {x: 'n√∫mero', y: 'n√∫mero'}, pero esto conlleva las mismas dificultades al expandirse.  Una ventaja significativa de este enfoque es la posibilidad de serializaci√≥n e intercambio de circuitos, lo cual es imposible con las funciones.  Sin embargo, esto se puede implementar f√°cilmente sobre la interfaz funcional.  ¬°No es necesario ocultar funciones detr√°s de las l√≠neas!  Las funciones ya tienen nombres y eso es todo lo que se necesita. <br><br>  Para facilitar el uso dentro de los validadores, se pueden omitir los operadores <b>Compose</b> y <b>Keys</b> ; tambi√©n es conveniente envolver el validador ra√≠z en <b>Trava</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pointValidator = Trava({ <span class="hljs-comment"><span class="hljs-comment">//  -&gt; Keys x: [numberValidator, Trava.Check(v =&gt; v &gt; 180)], //  -&gt; Compose y: [numberValidator, Trava.Check(v =&gt; v &lt; 180)], });</span></span></code> </pre> <br>  Si llama a <b>Trava</b> con el segundo argumento, el valor de retorno ser√° el resultado de aplicar el validador: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = Trava({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: [numberValidator, Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">180</span></span>)], <span class="hljs-attr"><span class="hljs-attr">y</span></span>: [numberValidator, Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &lt; <span class="hljs-number"><span class="hljs-number">180</span></span>)], }, <span class="hljs-comment"><span class="hljs-comment">//      { x: 200, y: 100, }); // { x: 200, y: 100 }</span></span></code> </pre> <br>  Hasta ahora, el soporte se ha implementado solo para matrices y objetos, como  b√°sicamente envenena a JSON y eso es suficiente.  ¬°Solicitudes de extracci√≥n para Wellcome! <br><br><h2>  Contexto </h2><br>  Al usar el validador como √∫ltimo par√°metro, puede pasar el contexto al que se podr√° acceder desde todos los validadores llamados como el √∫ltimo par√°metro.  Personalmente, esta oportunidad a√∫n no me ha resultado √∫til, pero es posible. <br><br>  Para algunos validadores que pueden devolver un error, es posible definir un mensaje de error en diferentes niveles.  Un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pos = Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); pos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ValidationError: "Incorrect value" (by default)</span></span></code> </pre><br>  Anular para un solo caso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pos = Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"    "</span></span>); pos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ValidationError: "    "</span></span></code> </pre><br>  Anulaci√≥n para todos los casos: <br><br><pre> <code class="javascript hljs">Trava.Check.ErrorMessage = <span class="hljs-string"><span class="hljs-string">" "</span></span>; pos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ValidationError: " "</span></span></code> </pre><br>  Adem√°s, para una configuraci√≥n m√°s detallada, puede transferir una funci√≥n en el lugar del error que deber√≠a devolver un error y se llamar√° con los par√°metros del validador. <br><br><h2>  Caso de uso </h2><br>  Principalmente envenenamos a JSON en el backend junto con koa.  La interfaz tambi√©n se sienta lentamente.  Es conveniente tener validadores comunes en ambos extremos.  Y ahora mostrar√© un caso de uso casi real.  Suponga que desea implementar una API para crear y actualizar datos de pacientes. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// validators.js const trava = require('trava'); const { isFilledString, isDate, isNumber } = require('../common/validators'); const patientSchema = { name: isFilledString, dateOfBirth: isDate, height: isNumber, } //        //      const patientNew = trava(patientSchema); //      const patientPatch = trava(mapValues(patientSchema, trava.Optional)); module.exports = { patientNew, patientPatch, }; // controllers.js const validate = require('./validators'); const { ValidationError } = require('../common/errors'); function create (ctx) { const patientData = validate.patientNew(ctx.request.body); //       Error,             Error if (patientData instanceof Error) return ValidationError(ctx, patientData); // ...create new patient } function update (ctx) { const patientData = validate.patientPatch(ctx.request.body); if (patientData instanceof Error) return ValidationError(ctx, patientData); // ...update patient data }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">common / errors.js</b> <div class="spoiler_text">  const trava = require ('trava'); <br><br>  function ValidationError (ctx, params) { <br>  if (params instanceof Error) { <br>  params = trava.ValidationError.extractData (params); <br>  } <br>  ctx.body = { <br>  c√≥digo: 'VALIDATION_ERROR', <br>  params <br>  }; <br>  ctx.status = HttpStatus.BAD_REQUEST; <br>  } <br></div></div><br>  Aunque el ejemplo es muy simple, no se puede llamar simplificado.  En una aplicaci√≥n real, solo los validadores ser√°n complicados.  Tambi√©n puede realizar la validaci√≥n en el middleware: el validador se aplica completamente al contexto o al cuerpo de la solicitud. <br><br>  En el proceso de trabajar y usar la validaci√≥n, llegamos a la conclusi√≥n de que los validadores s√≠ncronos simples y los mensajes de error simples son suficientes.  De hecho, llegamos a la conclusi√≥n de que usamos solo dos mensajes: "REQUERIDO" e "NO V√ÅLIDO", que se localizan en la interfaz junto con las indicaciones de los campos.  Otras verificaciones que requieren acciones adicionales (por ejemplo, en el registro para verificar que dicho correo ya existe) est√°n fuera del alcance de la validaci√≥n.  En cualquier caso, la hierba no se trata de este caso. <br><br><h2>  En conclusi√≥n </h2><br>  En este breve art√≠culo, describ√≠ casi toda la funcionalidad de la biblioteca, fuera del alcance del art√≠culo hay varios ayudantes que simplifican la vida.  Solicito detalles en github <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/uNmAnNeR/travajs</a> . <br><br>  Necesit√°bamos una herramienta que se pueda personalizar tanto como sea posible, en la que no haya nada superfluo, pero al mismo tiempo hay todo lo necesario para el trabajo diario.  Y creo que en general esto se logr√≥, espero que alguien tambi√©n haga la vida m√°s f√°cil.  Estar√© encantado de deseos y sugerencias. <br>  A la salud. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/462189/">https://habr.com/ru/post/462189/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../462175/index.html">Nos ocupamos de las abreviaturas y frases latinas en ingl√©s</a></li>
<li><a href="../462177/index.html">Recorrido fotogr√°fico por el Museo Mineral√≥gico que lleva el nombre de Fersman</a></li>
<li><a href="../462179/index.html">F-strings o c√≥mo hacer que el c√≥digo sea un poco m√°s r√°pido y m√°s legible</a></li>
<li><a href="../462181/index.html">Reglas para una comunicaci√≥n efectiva en chats grupales</a></li>
<li><a href="../462185/index.html">La revoluci√≥n ha terminado. ¬øExiste una alternativa a una bater√≠a de iones de litio?</a></li>
<li><a href="../462191/index.html">DataArt Museum: un recorrido por el norte de Italia</a></li>
<li><a href="../462197/index.html">Consejos sobre c√≥mo liberar tu mente y aumentar tu creatividad</a></li>
<li><a href="../462203/index.html">KVM (bajo) VDI con m√°quinas virtuales √∫nicas que usan bash</a></li>
<li><a href="../462205/index.html">PHDays 9 ganadores The Standoff: la cr√≥nica del equipo True0xA3</a></li>
<li><a href="../462209/index.html">Soluciones de videoconferencia de Polycom. Recuerdos 6 a√±os despu√©s ... Etapa 2. Parte 1. RMX1500</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>