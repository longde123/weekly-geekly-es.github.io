<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèº üò∫ ‚òùüèΩ Mengambil level dari Super Mario Bros menggunakan Python üê• üöÉ üî™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Untuk proyek baru, saya perlu mengekstraksi data level dari video game klasik Super Mario Bros (SMB) 1985. Lebih khusus lagi, saya ingin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengambil level dari Super Mario Bros menggunakan Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416241/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/a7a/80a/707a7a80afb88c419beb17be9e108272.png"></div><br><h2>  Pendahuluan </h2><br>  Untuk proyek baru, saya perlu mengekstraksi data level dari video game klasik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Super Mario Bros (SMB)</a> 1985.  Lebih khusus lagi, saya ingin mengekstraksi latar belakang grafis dari setiap level permainan tanpa antarmuka, memindahkan sprite, dll. <br><br>  Tentu saja, saya hanya bisa merekatkan gambar dari permainan dan, mungkin, mengotomatiskan proses menggunakan teknik visi mesin.  Tetapi bagi saya tampaknya lebih menarik metode yang dijelaskan di bawah ini, yang memungkinkan Anda untuk menjelajahi elemen-elemen level yang tidak dapat diperoleh menggunakan screenshot. <br><br>  Pada tahap pertama proyek, kita akan mempelajari bahasa assembler 6502 dan emulator yang ditulis dengan Python.  Kode sumber lengkap tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><a name="habracut"></a><br><h2>  Analisis kode sumber </h2><br>  Membalikkan rekayasa program apa pun jauh lebih sederhana jika Anda memiliki kode sumbernya, dan kami memiliki sumber SMB dalam bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">17 ribu baris kode assembler 6502 (prosesor NES) yang</a> diterbitkan oleh doppelganger.  Karena Nintendo tidak pernah merilis rilis sumber resmi, kode tersebut dibuat dengan membongkar kode mesin SMB, dengan susah payah menguraikan makna setiap bagian, menambahkan komentar dan nama simbol yang bermakna. <br><br>  Setelah melakukan pencarian cepat pada file, saya menemukan sesuatu yang mirip dengan data level yang kami butuhkan: <br><br> <code>;level 1-1 <br> L_GroundArea6: <br> .db $50, $21 <br> .db $07, $81, $47, $24, $57, $00, $63, $01, $77, $01 <br> .db $c9, $71, $68, $f2, $e7, $73, $97, $fb, $06, $83 <br> .db $5c, $01, $d7, $22, $e7, $00, $03, $a7, $6c, $02 <br> .db $b3, $22, $e3, $01, $e7, $07, $47, $a0, $57, $06 <br> .db $a7, $01, $d3, $00, $d7, $01, $07, $81, $67, $20 <br> .db $93, $22, $03, $a3, $1c, $61, $17, $21, $6f, $33 <br> .db $c7, $63, $d8, $62, $e9, $61, $fa, $60, $4f, $b3 <br> .db $87, $63, $9c, $01, $b7, $63, $c8, $62, $d9, $61 <br> .db $ea, $60, $39, $f1, $87, $21, $a7, $01, $b7, $20 <br> .db $39, $f1, $5f, $38, $6d, $c1, $af, $26 <br> .db $fd</code> <br> <br>  Jika Anda tidak terbiasa dengan assembler, maka saya akan menjelaskan: semua ini hanya berarti "memasukkan set byte seperti itu ke dalam program yang dikompilasi, dan kemudian mengizinkan bagian lain dari program untuk merujuknya menggunakan simbol <code>L_GroundArea6</code> ".  Anda bisa mengambil fragmen ini sebagai array di mana setiap elemen adalah byte. <br><br>  Hal pertama yang dapat Anda perhatikan adalah bahwa volume data sangat kecil (sekitar 100 byte).  Oleh karena itu, kami mengecualikan semua jenis pengkodean, memungkinkan Anda untuk secara acak menempatkan blok pada level.  Setelah mencari sedikit, saya menemukan bahwa data ini dibaca (setelah beberapa operasi pengalamatan tidak langsung) di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AreaParserCore</a> .  <code>RowOfBricks</code> ini, pada gilirannya, memanggil banyak <code>RowOfBricks</code> lainnya, yang pada akhirnya meminta <code>RowOfBricks</code> khusus untuk setiap jenis objek yang diperbolehkan dalam adegan (misalnya, <code>StaircaseObject</code> , <code>VerticalPipe</code> , <code>RowOfBricks</code> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e5/385/954/4e538595409be651da11d5166c97b130.png"></div><br>  <i>Grafik panggilan <code>AreaParserCore</code> untuk <code>AreaParserCore</code></i> <br><br>  Prosedur menulis ke <code>MetatileBuffer</code> : bagian memori 13-byte, yang merupakan satu kolom blok di level, masing-masing byte mewakili blok yang terpisah.  Metatile adalah blok 16x16 dari mana latar belakang gim SMB dibuat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c27/d0b/bd9/c27d0bbd9fdce9bf86b56ce181b2747d.png"></div><br>  <i>Tingkat dengan persegi panjang mengelilingi metatile</i> <br><br>  Mereka disebut meta-file, karena masing-masing terdiri dari empat petak 8x8-piksel, tetapi lebih dari itu di bawah ini. <br><br>  Fakta bahwa dekoder bekerja dengan objek yang telah ditentukan menjelaskan ukuran kecil level: level data harus merujuk hanya pada jenis objek dan lokasinya, misalnya, "posisikan pipa pada titik (20, 16), sejumlah blok pada titik (10, 5), ... ".  Namun, ini berarti bahwa dibutuhkan banyak kode untuk mengubah data level mentah menjadi file meta. <br><br>  Mem-Porting jumlah kode ini untuk membuat unpacker level Anda sendiri akan memakan waktu terlalu banyak, jadi mari kita coba pendekatan yang berbeda. <br><br><h2>  py65emu </h2><br>  Jika kami memiliki antarmuka antara Python dan bahasa assembler 6502, kita bisa memanggil subprocedure <code>AreaParserCore</code> untuk setiap kolom level, dan kemudian menggunakan Python yang lebih dimengerti untuk mengubah informasi blok menjadi gambar yang diinginkan. <br><br>  Kemudian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">py65emu</a> muncul di tempat kejadian - sebuah emulator 6502 ringkas dengan antarmuka Python.  Inilah cara konfigurasi memori yang sama dikonfigurasi di py65emu seperti pada NES: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> py65emu.cpu <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CPU <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> py65emu.mmu <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MMU <span class="hljs-comment"><span class="hljs-comment">#  ROM  (..  ) with open("program.bin", "rb") as f: prg_rom = f.read() #   . mmu = MMU([ #  2K ,    0x0. (0x0, 2048, False, []), #  ROM   0x8000. (0x8000, len(prg_rom), True, list(prg_rom)) ]) #     ,       0x8000 cpu = CPU(mmu, 0x8000)</span></span></code> </pre> <br>  Setelah itu, kita dapat menjalankan instruksi individual menggunakan metode <code>cpu.step()</code> , memeriksa memori menggunakan <code>mmu.read()</code> , mempelajari register mesin menggunakan <code>cpu.ra</code> , <code>cpu.r.pc</code> , dll.  Selain itu, kita dapat menulis ke memori menggunakan <code>mmu.write()</code> . <br><br>  Perlu dicatat bahwa ini hanyalah emulator prosesor NES: tidak meniru perangkat keras lain, seperti PPU (Picture Processing Unit), sehingga tidak dapat digunakan untuk meniru seluruh permainan.  Namun, itu seharusnya cukup untuk memanggil subprocedure parsing, karena tidak menggunakan perangkat perangkat keras lain kecuali CPU dan memori. <br><br>  Rencananya adalah untuk mengkonfigurasi CPU seperti yang ditunjukkan di atas, dan kemudian untuk setiap kolom level, inisialisasi partisi memori dengan nilai input yang diperlukan untuk <code>AreaParserCore</code> , panggil <code>AreaParserCore</code> , dan kemudian baca kembali data kolom.  Setelah menyelesaikan operasi ini, kami menggunakan Python untuk mengumpulkan hasilnya menjadi gambar yang sudah jadi. <br><br>  Tetapi sebelum itu, kita perlu mengkompilasi daftar dalam bahasa assembly ke dalam kode mesin. <br><br><h2>  x816 </h2><br>  Seperti ditunjukkan dalam kode sumber, assembler dikompilasi menggunakan x816.  x816 adalah assembler MS-DOS 6502 yang digunakan oleh komunitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">homebrew</a> untuk peretas NES dan ROM.  Ini berfungsi dengan baik di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DOSBox</a> . <br><br>  Bersamaan dengan ROM program, yang diperlukan untuk py65emu, assembler x816 membuat file karakter yang memetakan karakter ke lokasi mereka dalam memori di ruang alamat CPU.  Berikut cuplikan file: <br><br> <code>AREAPARSERCORE = $0093FC ; &lt;&gt; 37884, statement #3154 <br> AREAPARSERTASKCONTROL = $0086E6 ; &lt;&gt; 34534, statement #1570 <br> AREAPARSERTASKHANDLER = $0092B0 ; &lt;&gt; 37552, statement #3035 <br> AREAPARSERTASKNUM = $00071F ; &lt;&gt; 1823, statement #141 <br> AREAPARSERTASKS = $0092C8 ; &lt;&gt; 37576, statement #3048</code> <br> <br>  Di sini kita melihat bahwa fungsi <code>AreaParserCore</code> dalam kode sumber dapat diakses di <code>0x93fc</code> . <br><br>  Untuk kenyamanan, saya menulis parser file simbol yang cocok dengan nama dan alamat simbol: <br><br><pre> <code class="python hljs">sym_file = SymbolFile(<span class="hljs-string"><span class="hljs-string">'SMBDIS.SYM'</span></span>) print(<span class="hljs-string"><span class="hljs-string">"0x{:x}"</span></span>.format(sym_file[<span class="hljs-string"><span class="hljs-string">'AREAPARSERCORE'</span></span>])) <span class="hljs-comment"><span class="hljs-comment">#  0x93fc print(sym_file.lookup_address(0x93fc)) #  "AREAPARSERCORE"</span></span></code> </pre> <br><h2>  Sub-prosedur </h2><br>  Seperti yang dinyatakan dalam rencana di atas, kami ingin mempelajari cara memanggil subprocedure <code>AreaParserCore</code> dari Python. <br><br>  Untuk memahami mekanisme sub-prosedur, mari kita periksa sub-prosedur singkat dan tantangan terkait: <br><br><pre> <code class="python hljs">WritePPUReg1: sta PPU_CTRL_REG1 ;  A   <span class="hljs-number"><span class="hljs-number">1</span></span> PPU sta Mirror_PPU_CTRL_REG1 ;    rts ... jsr WritePPUReg1</code> </pre> <br>  <code>jsr</code> (lompat ke subrutin, ‚Äúlompat ke subrutin‚Äù) <code>jsr</code> register PC ke stack dan memberikannya nilai alamat yang <code>WritePPUReg1</code> oleh <code>WritePPUReg1</code> .  Register PC memberitahu prosesor alamat instruksi berikutnya untuk memuat, sehingga instruksi berikutnya dijalankan setelah instruksi <code>jsr</code> adalah baris pertama dari <code>WritePPUReg1</code> . <br><br>  Pada akhir subrutin, pernyataan <code>rts</code> dieksekusi (kembali dari subrutin, "kembali dari subrutin").  Perintah ini menghilangkan nilai yang tersimpan dari tumpukan dan menyimpannya dalam register PC, yang memaksa CPU untuk menjalankan instruksi mengikuti panggilan <code>jsr</code> . <br><br>  Fitur hebat dari sub-prosedur adalah bahwa Anda dapat membuat panggilan inline, yaitu, panggilan sub-prosedur dalam sub-prosedur.  Alamat pengembalian akan didorong ke tumpukan dan muncul dalam urutan yang benar, dengan cara yang sama seperti dengan pemanggilan fungsi dalam bahasa tingkat tinggi. <br><br>  Berikut adalah kode untuk menjalankan subrutin dari Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute_subroutine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cpu, addr)</span></span></span><span class="hljs-function">:</span></span> s_before = cpu.rs cpu.JSR(addr) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> cpu.rs != s_before: cpu.step() execute_subroutine(cpu, sym_file[<span class="hljs-string"><span class="hljs-string">'AREAPARSERCORE'</span></span>])</code> </pre> <br>  Kode menyimpan nilai saat ini dari register penunjuk tumpukan, mengemulasi panggilan <code>jsr</code> , dan kemudian mengeksekusi instruksi sampai tumpukan kembali ke ketinggian aslinya, yang terjadi hanya setelah kembalinya dari <code>jsr</code> - <code>jsr</code> pertama.  Ini akan berguna, karena sekarang kita memiliki cara untuk secara langsung memanggil 6502 subrutin dari Python. <br><br>  Namun, kami lupa sesuatu: bagaimana cara melewatkan nilai input untuk sub-prosedur ini?  Kita perlu memberi tahu prosedur level mana yang ingin kita render dan kolom mana yang perlu kita uraikan. <br><br>  Tidak seperti fungsi dalam bahasa tingkat tinggi, subrutin bahasa assembly 6502 tidak dapat menerima data input yang ditentukan secara eksplisit.  Sebagai gantinya, input ditransmisikan dengan menentukan lokasi memori di suatu tempat sebelum panggilan, yang kemudian dibaca di dalam panggilan sub-prosedur.  Mengingat ukuran <code>AreaParserCore</code> , rekayasa balik input yang diperlukan dengan hanya melihat kode sumber akan sangat kompleks dan rawan kesalahan. <br><br><h2>  Valgrind untuk NES? </h2><br>  Untuk menemukan cara menentukan nilai input <code>AreaParserCore</code> , saya menggunakan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memcheck</a> untuk Valgrind sebagai contoh.  Memcheck mengenali operasi akses ke memori yang tidak diinisialisasi dengan menyimpan memori bayangan secara paralel dengan setiap fragmen dari memori yang dialokasikan sebenarnya.  Memori bayangan merekam apakah perekaman dilakukan ke memori nyata yang sesuai.  Jika program membaca ke alamat yang tidak pernah ditulisnya, maka kesalahan memori yang tidak diinisialisasi akan muncul.  Kita bisa menjalankan <code>AreaParserCore</code> dengan alat yang memberi tahu kita apa input yang perlu ditetapkan sebelum menjalankan subprocedure. <br><br>  Sebenarnya, menulis versi memcheck sederhana untuk py65emu sangat mudah: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">format_addr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: symbol_name = sym_file.lookup_address(addr) s = <span class="hljs-string"><span class="hljs-string">"0x{:04x} ({}):"</span></span>.format(addr, symbol_name) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: s = <span class="hljs-string"><span class="hljs-string">"0x{:04x}:"</span></span>.format(addr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemCheckMMU</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MMU)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self._uninitialized = array.array(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">2048</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, addr)</span></span></span><span class="hljs-function">:</span></span> val = super().read(addr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr &lt; <span class="hljs-number"><span class="hljs-number">2048</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._uninitialized[addr]: print(<span class="hljs-string"><span class="hljs-string">"Uninitialized read! {}"</span></span>.format(format_addr(addr))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, addr, val)</span></span></span><span class="hljs-function">:</span></span> super().write(addr, val) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr &lt; <span class="hljs-number"><span class="hljs-number">2048</span></span>: self._uninitialized[addr] = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Di sini kami membungkus unit manajemen memori (MMU) py65emu.  Kelas ini berisi larik <code>_uninitialized</code> , elemen yang memberi tahu kami apakah pernah ditulis ke byte yang sesuai dari RAM yang ditiru.  Jika terjadi pembacaan yang tidak diinisialisasi, alamat operasi pembacaan yang tidak valid dan nama karakter yang sesuai akan ditampilkan. <br><br>  Berikut ini adalah hasil dari MMU yang <code>execute_subroutine(sym_file['AREAPARSERCORE'])</code> ketika memanggil <code>execute_subroutine(sym_file['AREAPARSERCORE'])</code> : <br><br> <code>Uninitialized read! 0x0728 (BACKLOADINGFLAG): <br> Uninitialized read! 0x0742 (BACKGROUNDSCENERY): <br> Uninitialized read! 0x0741 (FOREGROUNDSCENERY): <br> Uninitialized read! 0x074e (AREATYPE): <br> Uninitialized read! 0x075f (WORLDNUMBER): <br> Uninitialized read! 0x0743 (CLOUDTYPEOVERRIDE): <br> Uninitialized read! 0x0727 (TERRAINCONTROL): <br> Uninitialized read! 0x0743 (CLOUDTYPEOVERRIDE): <br> Uninitialized read! 0x074e (AREATYPE): <br> ...</code> <br> <br>  Dengan melihat kode, Anda dapat melihat bahwa banyak dari nilai-nilai ini ditetapkan oleh subprocedure <code>InitializeArea</code> , jadi mari kita jalankan skrip lagi, memanggil fungsi ini terlebih dahulu.  Mengulangi proses ini, kami sampai pada urutan panggilan berikut, yang hanya membutuhkan nomor dunia dan nomor area: <br><br><pre> <code class="python hljs">mmu.write(sym_file[<span class="hljs-string"><span class="hljs-string">'WORLDNUMBER'</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    1 mmu.write(sym_file['AREANUMBER'], 0) #    1 execute_subroutine(sym_file['LOADAREAPOINTER']) execute_subroutine(sym_file['INITIALIZEAREA']) metatile_data = [] for column_pos in range(48): execute_subroutine(sym_file['AREAPARSERCORE']) metatile_data.append([mmu.read_no_debug(sym_file['METATILEBUFFER'] + i) for i in range(13)]) execute_subroutine(sym_file['INCREMENTCOLUMNPOS'])</span></span></code> </pre> <br>  Kode menulis 48 kolom pertama dari tingkat World 1-1 ke <code>metatile_data</code> , menggunakan subprocedure <code>IncrementColumnPos</code> untuk meningkatkan variabel internal yang diperlukan untuk melacak kolom saat ini. <br><br>  Dan di sini adalah isi dari <code>metatile_data</code> ditumpangkan pada screenshot dari game (byte dengan nilai 0 tidak ditampilkan): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/a7a/80a/707a7a80afb88c419beb17be9e108272.png"></div><br>  Jelas, <code>metatile_data</code> dengan jelas cocok dengan informasi latar belakang. <br><br><h2>  Grafik Meta </h2><br>  (Untuk melihat hasil akhir, Anda dapat langsung melanjutkan ke bagian "Menghubungkan semuanya bersama".) <br><br>  Sekarang mari kita cari tahu cara mengubah jumlah file meta yang diterima menjadi gambar nyata.  Langkah-langkah yang dijelaskan di bawah ini diciptakan dengan menganalisis sumber dan membaca dokumentasi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wiki Nesdev yang</a> menakjubkan. <br><br>  Untuk memahami cara membuat setiap metatile, pertama-tama kita perlu berbicara tentang palet warna NES.  PPU konsol NES umumnya dapat membuat 64 warna berbeda, tetapi hitam digandakan beberapa kali (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nesdev</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">detailnya</a> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdf/997/328/cdf9973289e05f09899c36ca04cb6a4d.png"></div><br>  Setiap level Mario hanya dapat menggunakan 10 dari 64 warna ini untuk latar belakang, dibagi menjadi 4 palet empat warna;  Warna pertama selalu sama.  Berikut adalah empat palet untuk World 1-1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/15d/821/69915d821a10f3e7c668abe2894bc7a3.png"></div><br>  Sekarang mari kita lihat contoh biner dari nomor file meta.  Berikut adalah nomor metatile ubin batu retak, yang merupakan tanah tingkat Dunia 1-1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85f/1a1/9ae/85f1a19aea1e39a511dc2bfe31e72d05.png"></div><br>  Indeks palet memberi tahu kita palet mana yang akan digunakan saat me-render metatile (dalam kasus kami, palet 1).  Indeks palet juga merupakan indeks dari dua array berikut: <br><br> <code>MetatileGraphics_Low: <br> .db &lt;Palette0_MTiles, &lt;Palette1_MTiles, &lt;Palette2_MTiles, &lt;Palette3_MTiles <br> <br> MetatileGraphics_High: <br> .db &gt;Palette0_MTiles, &gt;Palette1_MTiles, &gt;Palette2_MTiles, &gt;Palette3_MTiles</code> <br> <br>  Kombinasi kedua array ini memberi kami alamat 16-bit, yang dalam contoh kami menunjukkan ke <code>Palette1_Mtiles</code> : <br><br> <code>Palette1_MTiles: <br> .db $a2, $a2, $a3, $a3 ;vertical rope <br> .db $99, $24, $99, $24 ;horizontal rope <br> .db $24, $a2, $3e, $3f ;left pulley <br> .db $5b, $5c, $24, $a3 ;right pulley <br> .db $24, $24, $24, $24 ;blank used for balance rope <br> .db $9d, $47, $9e, $47 ;castle top <br> .db $47, $47, $27, $27 ;castle window left <br> .db $47, $47, $47, $47 ;castle brick wall <br> .db $27, $27, $47, $47 ;castle window right <br> .db $a9, $47, $aa, $47 ;castle top w/ brick <br> .db $9b, $27, $9c, $27 ;entrance top <br> .db $27, $27, $27, $27 ;entrance bottom <br> .db $52, $52, $52, $52 ;green ledge stump <br> .db $80, $a0, $81, $a1 ;fence <br> .db $be, $be, $bf, $bf ;tree trunk <br> .db $75, $ba, $76, $bb ;mushroom stump top <br> .db $ba, $ba, $bb, $bb ;mushroom stump bottom <br> .db $45, $47, $45, $47 ;breakable brick w/ line <br> .db $47, $47, $47, $47 ;breakable brick <br> .db $45, $47, $45, $47 ;breakable brick (not used) <br> .db $b4, $b6, $b5, $b7 ;cracked rock terrain &lt;--- This is the 20th line <br> .db $45, $47, $45, $47 ;brick with line (power-up) <br> .db $45, $47, $45, $47 ;brick with line (vine) <br> .db $45, $47, $45, $47 ;brick with line (star) <br> .db $45, $47, $45, $47 ;brick with line (coins) <br> ...</code> <br> <br>  Ketika Anda mengalikan indeks metatile dengan 4, itu menjadi indeks dari array ini.  Data diformat dalam 4 catatan per baris, jadi contoh metatile kami merujuk ke baris kedua puluh, ditandai dengan komentar <code>cracked rock terrain</code> . <br><br>  Keempat entri dari baris ini sebenarnya adalah pengidentifikasi ubin: setiap metatile terdiri dari empat ubin 8x8-piksel yang disusun dalam urutan berikut - kiri atas, kiri bawah, kanan atas dan kanan bawah.  Pengidentifikasi ini diteruskan langsung ke konsol PES NES.  Pengidentifikasi mengacu pada 16 byte data di konsol CHR-ROM, dan setiap catatan dimulai dengan alamat <code>0x1000 + 16 * &lt; &gt;</code> : <br><br> <code>0x1000 + 16 * 0xb4: 0b01111111 0x1000 + 16 * 0xb5: 0b11011110 <br> 0x1001 + 16 * 0xb4: 0b10000000 0x1001 + 16 * 0xb5: 0b01100001 <br> 0x1002 + 16 * 0xb4: 0b10000000 0x1002 + 16 * 0xb5: 0b01100001 <br> 0x1003 + 16 * 0xb4: 0b10000000 0x1003 + 16 * 0xb5: 0b01100001 <br> 0x1004 + 16 * 0xb4: 0b10000000 0x1004 + 16 * 0xb5: 0b01110001 <br> 0x1005 + 16 * 0xb4: 0b10000000 0x1005 + 16 * 0xb5: 0b01011110 <br> 0x1006 + 16 * 0xb4: 0b10000000 0x1006 + 16 * 0xb5: 0b01111111 <br> 0x1007 + 16 * 0xb4: 0b10000000 0x1007 + 16 * 0xb5: 0b01100001 <br> 0x1008 + 16 * 0xb4: 0b10000000 0x1008 + 16 * 0xb5: 0b01100001 <br> 0x1009 + 16 * 0xb4: 0b01111111 0x1009 + 16 * 0xb5: 0b11011111 <br> 0x100a + 16 * 0xb4: 0b01111111 0x100a + 16 * 0xb5: 0b11011111 <br> 0x100b + 16 * 0xb4: 0b01111111 0x100b + 16 * 0xb5: 0b11011111 <br> 0x100c + 16 * 0xb4: 0b01111111 0x100c + 16 * 0xb5: 0b11011111 <br> 0x100d + 16 * 0xb4: 0b01111111 0x100d + 16 * 0xb5: 0b11111111 <br> 0x100e + 16 * 0xb4: 0b01111111 0x100e + 16 * 0xb5: 0b11000001 <br> 0x100f + 16 * 0xb4: 0b01111111 0x100f + 16 * 0xb5: 0b11011111 <br> <br> 0x1000 + 16 * 0xb6: 0b10000000 0x1000 + 16 * 0xb7: 0b01100001 <br> 0x1001 + 16 * 0xb6: 0b10000000 0x1001 + 16 * 0xb7: 0b01100001 <br> 0x1002 + 16 * 0xb6: 0b11000000 0x1002 + 16 * 0xb7: 0b11000001 <br> 0x1003 + 16 * 0xb6: 0b11110000 0x1003 + 16 * 0xb7: 0b11000001 <br> 0x1004 + 16 * 0xb6: 0b10111111 0x1004 + 16 * 0xb7: 0b10000001 <br> 0x1005 + 16 * 0xb6: 0b10001111 0x1005 + 16 * 0xb7: 0b10000001 <br> 0x1006 + 16 * 0xb6: 0b10000001 0x1006 + 16 * 0xb7: 0b10000011 <br> 0x1007 + 16 * 0xb6: 0b01111110 0x1007 + 16 * 0xb7: 0b11111110 <br> 0x1008 + 16 * 0xb6: 0b01111111 0x1008 + 16 * 0xb7: 0b11011111 <br> 0x1009 + 16 * 0xb6: 0b01111111 0x1009 + 16 * 0xb7: 0b11011111 <br> 0x100a + 16 * 0xb6: 0b11111111 0x100a + 16 * 0xb7: 0b10111111 <br> 0x100b + 16 * 0xb6: 0b00111111 0x100b + 16 * 0xb7: 0b10111111 <br> 0x100c + 16 * 0xb6: 0b01001111 0x100c + 16 * 0xb7: 0b01111111 <br> 0x100d + 16 * 0xb6: 0b01110001 0x100d + 16 * 0xb7: 0b01111111 <br> 0x100e + 16 * 0xb6: 0b01111111 0x100e + 16 * 0xb7: 0b01111111 <br> 0x100f + 16 * 0xb6: 0b11111111 0x100f + 16 * 0xb7: 0b01111111</code> <br> <br>  CHR-ROM adalah memori yang hanya dapat dibaca yang hanya dapat diakses oleh PPU.  Ini dipisahkan dari PRG-ROM, yang menyimpan kode program.  Oleh karena itu, data di atas tidak tersedia dalam kode sumber dan harus diperoleh dari dump ROM game. <br><br>  16 byte untuk setiap ubin membuat ubin 8-bit 2-bit: bit pertama adalah 8 byte pertama, dan yang kedua adalah 8 byte kedua: <br><br> <code>21111111 13211112 <br> 12222222 23122223 <br> 12222222 23122223 <br> 12222222 23122223 <br> 12222222 23132223 <br> 12222222 23233332 <br> 12222222 23111113 <br> 12222222 23122223 <br> <br> 12222222 23122223 <br> 12222222 23122223 <br> 33222222 31222223 <br> 11332222 31222223 <br> 12113333 12222223 <br> 12221113 12222223 <br> 12222223 12222233 <br> 23333332 13333332</code> <br> <br>  Bind data ini ke palet 1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02e/32a/ad5/02e32aad5717393bd296dd35983e294b.png"></div><br>  ... dan menggabungkan potongan-potongan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/950/86a/103/95086a103b16d361c72c0250781ebfd5.png"></div><br>  Akhirnya kami mendapat ubin yang diberikan. <br><br><h2>  Menyatukan semuanya </h2><br>  Mengulangi prosedur ini untuk setiap file meta, kami mendapatkan tingkat yang sepenuhnya diberikan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/322/45d/a3b/32245da3b8b4707764cef5231e040474.png"></div><br>  Dan berkat ini, kami dapat mengekstraksi grafik level SMB menggunakan Python! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416241/">https://habr.com/ru/post/id416241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416229/index.html">10 buku tentang pemasaran dan topik terkait yang harus dibaca oleh seorang desainer</a></li>
<li><a href="../id416231/index.html">Memantau ruang Zadarma Zabbix</a></li>
<li><a href="../id416235/index.html">Membuat Komponen Kustom untuk Bootstrap 4</a></li>
<li><a href="../id416237/index.html">Menjadi seorang desainer: dari lepas dari sebuah asrama hingga bekerja dengan perusahaan-perusahaan top dan meluncurkan produk Anda</a></li>
<li><a href="../id416239/index.html">Peran dan fungsi PMO dalam perusahaan desain</a></li>
<li><a href="../id416243/index.html">Alternatif kobalt, berlian berdarah ini dari baterai</a></li>
<li><a href="../id416245/index.html">Kami membuat bot di Aimylogic untuk mengotomatiskan toko online</a></li>
<li><a href="../id416247/index.html">Bagaimana cara mempersiapkan perjalanan bisnis? Kiat dari ISPsystem bizdedev</a></li>
<li><a href="../id416251/index.html">Pencetakan 3D pada t-shirt</a></li>
<li><a href="../id416253/index.html">Sketchfab, Unity, Blend4Web, PlayCanvas, dan sekarang Verge3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>