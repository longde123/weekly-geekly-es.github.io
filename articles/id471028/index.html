<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚§µÔ∏è üì≤ üëí Troli truk ROS. Bagian 6. Odometri dengan enkoder roda, peta ruang, lidar üíî ü•ò üë©üèº‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Posting dalam seri: 
 8. Kami mengontrol dari ponsel-ROS Control, GPS-node 
 7. Lokalisasi robot: gmapping, AMCL, titik referensi pada peta kamar 
 6....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Troli truk ROS. Bagian 6. Odometri dengan enkoder roda, peta ruang, lidar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471028/"> Posting dalam seri: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8. Kami mengontrol dari ponsel-ROS Control, GPS-node</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7. Lokalisasi robot: gmapping, AMCL, titik referensi pada peta kamar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6. Odometri dengan enkoder roda, peta ruang, lidar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5. Kami bekerja di rviz dan gazebo: xacro, sensor baru.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4. Buat simulasi robot menggunakan editor rviz dan gazebo.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3. Mempercepat, mengganti kamera, memperbaiki gaya berjalan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2. Perangkat Lunak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1. Besi</a> <br><br>  Terakhir kali, kami merancang proyek sebagai modul xacro terpisah, menambahkan kamera video virtual dan imu (gyroscope). <br><br>  Dalam posting ini kami akan bekerja dengan odometry dari encoders optik yang dipasang pada poros roda, memuat peta ruang dan mengendarainya dengan troli robot asli. <br><a name="habracut"></a><br><h3>  Odometri dan tf </h3><br>  Apa itu odometry dan tf dan bagaimana mereka biasanya diimplementasikan dalam ROS sudah dijelaskan dengan baik pada sumber daya, jadi kami merujuk pada artikel yang relevan di bagian teori, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br>  Setelah memulai dari landasan teori, kami akan bekerja dengan latihan. <br><br>  Mari kita mulai dengan mengerjakan robot troli dengan menghubungkannya melalui VNC. <br><br>  Buka folder rosbots_driver dan buat simpul file.  File ini akan menghasilkan odometry, menerimanya dari pengkode optik, yang pada gilirannya mengirimkannya ke arduino uno dan kemudian ke raspberry pi. <br><br><pre><code class="plaintext hljs">cd /home/pi/rosbots_catkin_ws/src/rosbots_driver/scripts/rosbots_driver touch diff-tf.py</code> </pre> <br>  Kami memasukkan kode ke dalam file: <br><br><div class="spoiler">  <b class="spoiler_title">diff_tf.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python """ diff_tf.py - follows the output of a wheel encoder and creates tf and odometry messages. some code borrowed from the arbotix diff_controller script A good reference: http://rossum.sourceforge.net/papers/DiffSteer/ Copyright (C) 2012 Jon Stephan. """ import rospy #import roslib #roslib.load_manifest('differential_drive') from math import sin, cos, pi from geometry_msgs.msg import Quaternion from geometry_msgs.msg import Twist from geometry_msgs.msg import Vector3 from nav_msgs.msg import Odometry import tf from tf.broadcaster import TransformBroadcaster from std_msgs.msg import Int16, Int32, Int64, UInt32 ############################################################################# class DiffTf: ############################################################################# ############################################################################# def __init__(self): ############################################################################# rospy.init_node("diff_tf") self.nodename = rospy.get_name() rospy.loginfo("-I- %s started" % self.nodename) #### parameters ####### #Wheel radius : 0.0325 # wheel circum = 2* 3.14 * 0.0325 = 0.2041 # One rotation encoder ticks : 8 ticks # For 1 meter: 8 * ( 1 / 0.2041) = 39 ticks self.rate = rospy.get_param('~rate',10.0) # the rate at which to publish the transform self.ticks_meter = float(rospy.get_param('ticks_meter', 190)) # The number of wheel encoder ticks per meter of travel self.base_width = float(rospy.get_param('~base_width', 0.11)) # The wheel base width in meters self.base_frame_id = rospy.get_param('~base_frame_id','base_link') # basefootprint /the name of the base frame of the robot self.odom_frame_id = rospy.get_param('~odom_frame_id', 'odom') # the name of the odometry reference frame self.encoder_min = rospy.get_param('encoder_min', -2147483648) self.encoder_max = rospy.get_param('encoder_max', 2147483648) self.encoder_low_wrap = rospy.get_param('wheel_low_wrap', (self.encoder_max - self.encoder_min) * 0.3 + self.encoder_min ) self.encoder_high_wrap = rospy.get_param('wheel_high_wrap', (self.encoder_max - self.encoder_min) * 0.7 + self.encoder_min ) self.t_delta = rospy.Duration(1.0/self.rate) self.t_next = rospy.Time.now() + self.t_delta # internal data self.enc_left = None # wheel encoder readings self.enc_right = None self.left = 0 # actual values coming back from robot self.right = 0 self.lmult = 0 self.rmult = 0 self.prev_lencoder = 0 self.prev_rencoder = 0 self.x = 0 # position in xy plane self.y = 0 self.th = 0 self.dx = 0 # speeds in x/rotation self.dr = 0 self.yaw = 0.01 self.pitch = 0.01 self.roll = 0.01 self.then = rospy.Time.now() self.quaternion_1 = Quaternion() # subscriptions rospy.Subscriber("wheel_ticks_left", UInt32, self.lwheelCallback) rospy.Subscriber("wheel_ticks_right", UInt32, self.rwheelCallback) #rospy.Subscriber("imu_data", Vector3, self.imu_value_update) self.odomPub = rospy.Publisher("odom", Odometry,queue_size=10) self.odomBroadcaster = TransformBroadcaster() ############################################################################# def spin(self): ############################################################################# r = rospy.Rate(self.rate) while not rospy.is_shutdown(): self.update() r.sleep() ############################################################################# def update(self): ############################################################################# now = rospy.Time.now() if now &gt; self.t_next: elapsed = now - self.then self.then = now elapsed = elapsed.to_sec() # calculate odometry if self.enc_left == None: d_left = 0 d_right = 0 else: d_left = (self.left - self.enc_left) / self.ticks_meter d_right = (self.right - self.enc_right) / self.ticks_meter self.enc_left = self.left self.enc_right = self.right # distance traveled is the average of the two wheels d = ( d_left + d_right ) / 2 # this approximation works (in radians) for small angles th = ( d_right - d_left ) / self.base_width # calculate velocities self.dx = d / elapsed self.dr = th / elapsed if (d != 0): # calculate distance traveled in x and y x = cos( th ) * d y = -sin( th ) * d # calculate the final position of the robot self.x = self.x + ( cos( self.th ) * x - sin( self.th ) * y ) self.y = self.y + ( sin( self.th ) * x + cos( self.th ) * y ) if( th != 0): self.th = self.th + th # publish the odom information quaternion = Quaternion() quaternion.x = 0.0 quaternion.y = 0.0 quaternion.z = sin( self.th / 2 ) quaternion.w = cos( self.th / 2 ) ''' try: quaternion.z = self.quaternion_1[2] quaternion.w = self.quaternion_1[3] except: quaternion.z = sin( self.th / 2 ) quaternion.w = cos( self.th / 2 ) pass ''' self.odomBroadcaster.sendTransform( (self.x, self.y, 0), (quaternion.x, quaternion.y, quaternion.z, quaternion.w), rospy.Time.now(), self.base_frame_id, self.odom_frame_id ) odom = Odometry() odom.header.stamp = now odom.header.frame_id = self.odom_frame_id odom.pose.pose.position.x = self.x odom.pose.pose.position.y = self.y odom.pose.pose.position.z = 0 odom.pose.pose.orientation = quaternion odom.child_frame_id = self.base_frame_id odom.twist.twist.linear.x = self.dx odom.twist.twist.linear.y = 0 odom.twist.twist.angular.z = self.dr self.odomPub.publish(odom) def imu_value_update(self, imu_data): orient = Vector3() orient = imu_data self.yaw = orient.x self.pitch = orient.y self.roll = orient.z try: self.quaternion_1 = tf.transformations.quaternion_from_euler(self.yaw, self.pitch, self.roll) #print self.quaternion_1[0] #print self.quaternion_1[1] #print self.quaternion_1[2] #print self.quaternion_1[3] except: rospy.logwarn("Unable to get quaternion values") pass ############################################################################# def lwheelCallback(self, msg): ############################################################################# enc = msg.data if (enc &lt; self.encoder_low_wrap and self.prev_lencoder &gt; self.encoder_high_wrap): self.lmult = self.lmult + 1 if (enc &gt; self.encoder_high_wrap and self.prev_lencoder &lt; self.encoder_low_wrap): self.lmult = self.lmult - 1 self.left = 1.0 * (enc + self.lmult * (self.encoder_max - self.encoder_min)) self.prev_lencoder = enc ############################################################################# def rwheelCallback(self, msg): ############################################################################# enc = msg.data if(enc &lt; self.encoder_low_wrap and self.prev_rencoder &gt; self.encoder_high_wrap): self.rmult = self.rmult + 1 if(enc &gt; self.encoder_high_wrap and self.prev_rencoder &lt; self.encoder_low_wrap): self.rmult = self.rmult - 1 self.right = 1.0 * (enc + self.rmult * (self.encoder_max - self.encoder_min)) self.prev_rencoder = enc ############################################################################# ############################################################################# if __name__ == '__main__': """ main """ diffTf = DiffTf() diffTf.spin()</span></span></code> </pre><br></div></div><br>  Simpan file dan buat itu dapat dieksekusi: <br> <code>CTRL+X <br> chmod +x diff-tf.py</code> <br> <br>  Sekarang pada robot, jalankan 2 node - driver dan diff-tf: <br>  Terminal 1: <br><br><pre> <code class="plaintext hljs">python diff_tf.py</code> </pre> <br>  2: <br><br><pre> <code class="plaintext hljs">rosrun rosbots_driver part2_cmr.py</code> </pre> <br>  Di terminal ke-3, kami akan memverifikasi bahwa ada topik odom dan tf baru: <br><br><img src="https://habrastorage.org/webt/zy/tc/rw/zytcrwcee_4-ygvgiwipil9jyxm.png"><br><br>  Mari kita lihat dengan perintah oost rostopic odom apa yang diterbitkan dalam topik (dan apakah itu diterbitkan sama sekali). <br>  Outputnya kira-kira sebagai berikut: <br><br><img src="https://habrastorage.org/webt/c2/f0/-o/c2f0-onzf3-8gdjtvegw7axrgtw.png"><br><br>  Sekarang, tanpa menutup node yang berjalan pada robot, kami akan meluncurkan komputer kontrol dengan lingkungan grafis rviz dan gazebo. <br><br>  * Gambar (mesin virtual VMWare dengan Ubuntu 16.04 + ROS Kinetic), yang sebelumnya ditawarkan untuk diunduh, berisi semua yang Anda butuhkan. <br><br>  Pada komputer kontrol (selanjutnya disebut "Komputer"), jalankan model di rviz: <br><br><pre> <code class="plaintext hljs">roslaunch rosbots_description rviz.launch</code> </pre> <br>  Model robot yang dimuat dengan yang bekerja di posting sebelumnya akan memuat: <br><br><img src="https://habrastorage.org/webt/e2/xf/kb/e2xfkbeuzqsl8g9vcl_ffiz2caa.png"><br><br>  Tambahkan dua tampilan ke rviz dengan mengklik Tambah.  Layar dengan odometri dan layar dengan tf, centang kotak untuk memvisualisasikannya. <br><br>  Di jendela tempat model robot digambarkan, grafik karakteristik akan muncul: <br><br><img src="https://habrastorage.org/webt/i_/p3/r1/i_p3r1fflodksrj2vowmldcmxl0.png"><br>  * Untuk membuatnya lebih terlihat, Anda dapat mematikan tampilan Robotmodel. <br><br>  Kami mengontrol robot dari keyboard Komputer dan melihat bagaimana visualisasi perubahan dan odometri. <br><br>  Tanpa menutup rviz di terminal ke-2, kami akan memulai kontrol dari keyboard: <br><br><pre> <code class="plaintext hljs">rosrun teleop_twist_keyboard teleop_twist_keyboard.py /cmd_vel:=/part2_cmr/cmd_vel</code> </pre> <br>  Saat mengendalikan robot, jendela dengan visualisasi akan menunjukkan: panah merah (visualisasi topik odom), garis vektor (topik tf). <br><br>  Jika panah merah dari topik odom menunjukkan arah pergerakan robot, garis vektor jika menunjukkan bagaimana elemen individu robot berada di ruang: <br><br><div class="spoiler">  <b class="spoiler_title">videonya</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/CC6CO5VIDUA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  Sekarang, untuk melanjutkan, Anda perlu "menyetel" odometri. <br>  Untuk melakukan ini, tutup editor rviz dan mulai lagi, hanya tanpa memvisualisasikan model dengan perintah: <br><br><pre> <code class="plaintext hljs">rosrun rviz rviz</code> </pre> <br>  Ini diperlukan agar hanya base_link dan odom tetap dari vektor topik tf: <br><br><img src="https://habrastorage.org/webt/x6/qn/fn/x6qnfnbvkzstivryymtyovdnmuw.gif"><br><br>  Di rviz, satu sel adalah 1 meter.  Karena itu, pada kenyataannya, robot juga harus melewati 1 meter agar data dapat dibandingkan. <br><br>  Kami akan melewati 1 meter pada robot, mengendalikannya dari keyboard.  Di rviz, robot juga harus menggerakkan 1 meter - satu sel. <br><br>  Jika robot melakukan perjalanan lebih lama dari yang seharusnya di rviz, atau sebaliknya, jarak yang lebih pendek dari kenyataannya, maka Anda perlu mengedit file diff_tf.py yang sebelumnya dibuat, yaitu blok ini: <br><br><div class="spoiler">  <b class="spoiler_title">diff_tf.py</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> #### parameters ####### #Wheel radius : 0.0325 # wheel circum = 2* 3.14 * 0.0325 = 0.2041 # One rotation encoder ticks : 8 ticks # For 1 meter: 8 * ( 1 / 0.2041) = 39 ticks self.rate = rospy.get_param('~rate',10.0) # the rate at which to publish the transform self.ticks_meter = float(rospy.get_param('ticks_meter', 190)) # The number of wheel encoder ticks per meter of travel self.base_width = float(rospy.get_param('~base_width', 0.11)) # The wheel base width in meters</code> </pre> <br></div></div><br><h3>  Peta </h3><br>  Untuk pergi ke suatu tempat, Anda memerlukan peta.  Untuk keperluan robot kami - kami membutuhkan peta kamar. <br>  Mari kita bekerja dengannya. <br><br>  Untuk mengunggah peta ke rviz, Anda perlu membuat folder peta di proyek (rosbots_description) di Komputer (bukan di robot) dan memasukkan dua file ke dalamnya yang membentuk peta: map.pgm dan map.yaml. <br>  * Faktanya, mungkin ada beberapa file peta dalam folder, tetapi Anda hanya dapat mengunggah satu ke wizard. <br><br>  Peta di ROS terdiri dari dua file, salah satunya adalah gambar PGM, di mana setiap pikselnya adalah: <br><br><ul><li>  ruang putih gratis; </li><li>  ruang hitam ditempati oleh penghalang; </li><li>  abu - abu - ruang belum dieksplorasi. </li></ul><br>  File .yaml kedua adalah file dengan pengaturan peta, di mana dimensinya, hunian piksel dengan berbagai jenis (tercantum di atas), parameter lainnya ditunjukkan. <br><br>  Jalankan node di komputer yang akan menerbitkan kartu: <br><br><pre> <code class="plaintext hljs">rosrun map_server map_server /home/pi/catkin_ws/src/rosbots_description/maps/rail_lab.pgm 0.05</code> </pre> <br>  Di terminal tetangga, jalankan model di rviz: <br><br><pre> <code class="plaintext hljs">roslaunch rosbots_description rviz.launch</code> </pre> <br>  Di rviz, tambahkan tampilan Peta. <br><br>  Di rviz, robot tersebut ternyata berukuran sangat besar, dan terletak di luar peta: <br><br><img src="https://habrastorage.org/webt/h6/ob/8g/h6ob8gyq_u11omb3bzneqczgkra.gif"><br><br>  Untuk memperbaiki ini, Anda perlu menjalankan peta di mana ukuran sel akan 1 meter.  Mulai ulang kartu dengan parameter 1 di akhir: <br><br><pre> <code class="plaintext hljs">rosrun map_server map_server /home/pi/catkin_ws/src/rosbots_description/maps/rail_lab.pgm 1</code> </pre> <br>  Sekarang Anda bisa naik peta di rviz, mengendalikan robot dari keyboard: <br><br><div class="spoiler">  <b class="spoiler_title">videonya</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/bbsn97FUNnI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  <b>Jadi, apa yang dicapai</b> : <br><br><ul><li>  menerima data odometry dari enkoder roda optik robot dan mengirimkannya ke topik untuk ditampilkan di rviz; </li><li>  mengkonfigurasi robot odometri agar sesuai dengan jarak tempuh langsung dan hampir; </li><li>  memuat dan menampilkan peta ruang. </li></ul><br>  Namun, terlepas dari kenyataan bahwa peta ditampilkan dan robot dapat naik di atasnya dengan odometry "disetel", pada kenyataannya robot itu buta.  Dia tidak melihat rintangan dan akan menemukan mereka.  Kekurangan kedua adalah peta ruang virtual yang dimuat di rviz memungkinkan Anda untuk berkendara sendiri ke segala arah, bahkan di tempat-tempat di mana hambatan ditampilkan dengan jelas. <br><br>  Bagaimana cara membuat robot "melihat" hambatan dalam kenyataan dan secara virtual? <br><br>  Dengan lingkungan virtual lebih sederhana.  Semuanya di sini didasarkan pada emulator-editor gazebo.  Dan dalam posting sebelumnya ini disebutkan. <br><br>  Ini lebih rumit dengan kenyataan.  Kami membutuhkan elemen (sensor) yang akan menunjukkan hambatan dan melaporkannya ke sistem. <br><br>  Salah satu opsi adalah dengan meletakkan lidar pada robot. <br><br><h3>  Lidar RPlidar A1 </h3><br>  Kami akan menggunakan solusi anggaran yang terjangkau dan menempatkan Lidar pada robot.  Mungkin solusi ini akan lebih mahal daripada menggunakan Kinect yang sama, tetapi, seperti yang telah ditunjukkan oleh praktik, ini lebih efektif dalam hal kecepatan, ketepatan dan kemudahan pemasangan (kurang rumit).  Selain itu, lebih mudah untuk mulai bekerja dengan LIDAR, seperti  Tidak diperlukan refleksi tentang cara menyalakannya dan menghubungkannya ke proyek (https://habr.com/en/company/tod/blog/210252/). <br><br>  Kami membutuhkan paket ros untuk bekerja dengan lidar - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki.ros.org/rplidar</a> . <br>  Dengan bantuan lidar, kami akan membangun peta ruangan, dan juga menggunakannya dalam navigasi. <br><br>  Cara menginstal rplidar di ROS memiliki banyak artikel, misalnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Kami akan menggunakan pengetahuan pria tua berambut abu-abu dan menginstal paket dengan LIDAR dalam sistem <u>pada robot</u> : <br><br><pre> <code class="plaintext hljs">cd /home/pi/rosbots_catkin_ws/src git clone https://github.com/robopeak/rplidar_ros.git cd .. catkin_make</code> </pre> <br>  Di <u>komputer,</u> instal paket untuk bekerja dengan kartu: <br><br><pre> <code class="plaintext hljs">cd /home/pi/rosbots_catkin_ws/src git clone https://github.com/tu-darmstadt-ros-pkg/hector_slam &lt;/code&gt; cd .. catkin_make</code> </pre> <br>  Jalankan paket pada robot dan periksa apakah lidar berfungsi: <br><br><pre> <code class="plaintext hljs">sudo chmod a+rw /dev/ttyUSB0 roslaunch rplidar_ros rplidar.launch</code> </pre> <br>  * Perintah pertama memberikan akses ke port usb di mana LIDAR terhubung. <br><br>  Jika semuanya berjalan lancar, maka akan menampilkan baris ke konsol: <br><br><pre> <code class="plaintext hljs">[ INFO] [1570900184.874891236]: RPLIDAR running on ROS package rplidar_ros. SDK Version:1.9.0 RPLIDAR S/N: ---------------- [ INFO] [1570900187.397858270]: Firmware Ver: 1.24 [ INFO] [1570900187.398081809]: Hardware Rev: 5 [ INFO] [1570900187.401749476]: RPLidar health status : 0 [ INFO] [1570900188.014285166]: current scan mode: Express, max_distance: 12.0 m, Point number: 4.0K , angle_compensate: 1</code> </pre> <br>  Di sini kita segera mengkonfigurasi Lidar kecil, karena  situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">web</a> resmi mengatakan bahwa itu (LIDAR) dapat bekerja lebih baik. <br><br>  Kita perlu mencapai output saat pemindaian bukan 4.0K poin, yang dikeluarkan secara default, tetapi 8.0K.  Opsi ini akan sedikit meningkatkan kualitas pemindaian. <br><br>  Untuk ini, kita akan menetapkan satu parameter lagi dalam paket rplidar - mode pindai: <br><br><pre> <code class="plaintext hljs">cd /rosbots_catkin_ws/src/rplidar_ros/launch nano nano rplidar.launch</code> </pre> <br>  Dan sesudahnya <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"angle_compensate"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"bool"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre>  tambahkan baris: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"scan_mode"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"string"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Boost"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  Baris kedua yang perlu diperbaiki di sini: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"frame_id"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"string"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"laser"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  Ganti nilai laser dengan base_link. <br><br>  * Sekarang, jika Anda me-restart node dengan perintah roslaunch rplidar_ros rplidar.launch, hasilnya akan berbeda: <br><br><pre> <code class="plaintext hljs">[ INFO] [1570900188.014285166]: current scan mode: Boost, max_distance: 12.0 m, Point number: 8.0K , angle_compensate: 1</code> </pre> <br>  Lihatlah.  yang menampilkan LIDAR di rviz. <br><br>  Untuk melakukan ini, jalankan di robot: <br><br><pre> <code class="plaintext hljs">roslaunch rplidar_ros rplidar.launch</code> </pre> <br>  Di Komputer: <br><br><pre> <code class="plaintext hljs">roslaunch rosbots_description rviz.launch</code> </pre> <br>  Di rviz, tambahkan tampilan LaserScan dan pilih topik pemindaian.  Lebih lanjut akan terlihat bahwa pesan masuk ke dalam topik: <br><br><img src="https://habrastorage.org/webt/mg/mo/6p/mgmo6p_pyjzofzrfyxwj5ollnrw.gif"><br><br>  Di jendela dengan visualisasi robot, robot itu ternyata raksasa.  Dengan ukurannya, kita akan mencari tahu nanti.  Sekarang mari kita membangun peta ruang. <br><br>  Untuk melakukan ini, buat paket dengan simpul: <br><br><pre> <code class="plaintext hljs">catkin_create_pkg my_hector_mapping rospy cd my_hector_mapping mkdir launch cd launch nano hector.launch</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">hector.launch</b> <div class="spoiler_text"><pre> <code class="python hljs">&lt;?xml version=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>?&gt; &lt;launch&gt; &lt;node pkg=<span class="hljs-string"><span class="hljs-string">"tf"</span></span> type=<span class="hljs-string"><span class="hljs-string">"static_transform_publisher"</span></span> name=<span class="hljs-string"><span class="hljs-string">"laser_link"</span></span> args=<span class="hljs-string"><span class="hljs-string">"0.0 0.0 0.0 0.0 0.0 0.0 /base_link /laser 50"</span></span> /&gt; &lt;node pkg=<span class="hljs-string"><span class="hljs-string">"hector_mapping"</span></span> type=<span class="hljs-string"><span class="hljs-string">"hector_mapping"</span></span> name=<span class="hljs-string"><span class="hljs-string">"hector_mapping"</span></span> output=<span class="hljs-string"><span class="hljs-string">"screen"</span></span>&gt; &lt;!-- Frame names --&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_frame"</span></span> value=<span class="hljs-string"><span class="hljs-string">"map"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"odom_frame"</span></span> value=<span class="hljs-string"><span class="hljs-string">"base_link"</span></span> /&gt; &lt;!-- Map size / start point --&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_resolution"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.050"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_size"</span></span> value=<span class="hljs-string"><span class="hljs-string">"1024"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_start_x"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>/&gt; //  &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_start_y"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.5"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_multi_res_levels"</span></span> value=<span class="hljs-string"><span class="hljs-string">"2"</span></span> /&gt; &lt;!-- Map update parameters --&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"update_factor_free"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.4"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"update_factor_occupied"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.9"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_update_distance_thresh"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.4"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_update_angle_thresh"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.06"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"laser_z_min_value"</span></span> value=<span class="hljs-string"><span class="hljs-string">"-1.0"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"laser_z_max_value"</span></span> value=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span> /&gt; &lt;!-- Advertising config --&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"advertise_map_service"</span></span> value=<span class="hljs-string"><span class="hljs-string">"true"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"scan_subscriber_queue_size"</span></span> value=<span class="hljs-string"><span class="hljs-string">"5"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"scan_topic"</span></span> value=<span class="hljs-string"><span class="hljs-string">"scan"</span></span>/&gt; &lt;/node&gt; &lt;/launch&gt;</code> </pre><br></div></div><br><pre> <code class="plaintext hljs">cd ~/rosbots_catkin_ws catkin_make</code> </pre> <br>  Mari kita jalankan. <br><br>  Pada robot: <br><br>  Terminal 1: <code>roslaunch rplidar_ros rplidar.launch</code> <br>  2: <code>rosrun rosbots_driver part2_cmr.py</code> <br><br>  Di Komputer: <br><br>  Terminal 1: <code>roslaunch my_hector_mapping hector.launch</code> <br>  2: <code>roslaunch rosbots_description rviz.launch</code> <br>  3: <code>rosrun teleop_twist_keyboard teleop_twist_keyboard.py /cmd_vel:=/part2_cmr/cmd_vel</code> <br><br>  Di layar Anda perlu menambahkan peta, dan Tetap bingkai pilih base_link.  Kemudian Anda dapat mengamati secara real time bagaimana lidar "menyinari" ruang di sekitarnya: <br><br><img src="https://habrastorage.org/webt/-6/gv/gq/-6gvgqgtmggjf7ffvnwlr1w6gwa.jpeg"><br><br>  Pada langkah saat ini, untuk membangun peta, Anda harus berkeliling ruangan, "berhenti" pada sudut yang berbeda sehingga Lidar menandainya di peta. <br><br>  Jadi rekomendasikan buku pelajaran.  Tetapi saran kami adalah untuk mengambil robot dan berjalan dengannya, memegangnya di depan Anda.  Jadi kecepatan membangun peta akan lebih besar dalam arti bahwa Anda tidak perlu terganggu dan melihat di mana robot melaju di kamar sebelah tanpa adanya kontak visual. <br><br>  Selain itu, ketika memutar robot di sekitar porosnya selama perjalanan, Lidar meninggalkan karakteristik artefak hitam di tempat-tempat di mana sebenarnya tidak ada hambatan: <br><br><img src="https://habrastorage.org/webt/wf/tn/0y/wftn0yxvutj6keza4jhqngsasai.jpeg"><br><br>  Setelah membangun peta, simpan dengan perintah: <br><br><pre> <code class="plaintext hljs">rosrun map_server map_saver -f map-1</code> </pre> <br>  Membangun peta yang sempurna dengan anggaran lidar adalah mitos.  Oleh karena itu, kami akan membantu Lidar di Photoshop.  Kami akan menghapus artefak hitam dari peta, di mana sebenarnya tidak ada hambatan, dan sejajarkan dinding dengan garis hitam: <br><br><img src="https://habrastorage.org/webt/-k/xv/fo/-kxvfoxyjflij37fvy_ntw2d-ic.jpeg"><br><br>  Jangan lupa untuk menyimpan peta dalam format .pgm. <br><br>  Sekarang kita ulangi di komputer perintah yang ada di awal posting, tetapi dengan peta baru: <br>  Terminal 1: <code>rosrun map_server maserver /home/pi/catkin_ws/src/rosbots_description/maps/map-1.pgm 0.05</code> <br>  2: <code>roslaunch rosbots_description rviz.launch</code> <br><br>  Hasil dalam rviz: <br><br><img src="https://habrastorage.org/webt/g1/g9/mj/g1g9mjpl0nwsgfumdmpmrvvem4q.jpeg"><br><br>  Peta baru dimuat, seperti model robot di atasnya, tetapi robot di luar peta. <br><br>  Kami akan membicarakan ini nanti, tetapi untuk sekarang, mari kita simpulkan: <br><br><ul><li>  menguasai lidar RP-lidar A1 </li><li>  membangun peta kamar menggunakan lidar, menyesuaikannya dan memuatnya ke editor visual rviz. </li></ul><br>  File untuk diunduh: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peta kamar</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471028/">https://habr.com/ru/post/id471028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471018/index.html">Perbandingan kinerja PC dan smartphone, termasuk iPhone 11</a></li>
<li><a href="../id471020/index.html">Cara menemukan bug di mikroprosesor yang dirilis tiga puluh lima tahun yang lalu</a></li>
<li><a href="../id471022/index.html">Mengungkap rahasia fisika berusia 140 tahun</a></li>
<li><a href="../id471024/index.html">Analisis: apa masa depan dan bagaimana menggunakannya untuk investasi pertukaran</a></li>
<li><a href="../id471026/index.html">TypeScript Kekuasaan tidak pernah</a></li>
<li><a href="../id471032/index.html">Foto yang tak terlihat</a></li>
<li><a href="../id471034/index.html">Wawancara dengan Pornhub Web Developer</a></li>
<li><a href="../id471036/index.html">Hidup dan belajar. Bagian 5. Pendidikan mandiri: kumpulkan diri Anda</a></li>
<li><a href="../id471038/index.html">File deskriptor Linux dengan contoh</a></li>
<li><a href="../id471040/index.html">[bookmark] React manual versi PDF dan ePUB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>