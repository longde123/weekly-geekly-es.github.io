<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèª üêâ üôÜüèΩ TrustZone: Vertrauensw√ºrdiges Betriebssystem und seine Anwendungen üí® üîÆ ‚ñ∂Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In fr√ºheren Artikeln haben wir uns mit dem TrustZone-Hardwareger√§t und der Funktionsweise des Secure Monitor-Mechanismus befasst. Heute konzentrieren ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TrustZone: Vertrauensw√ºrdiges Betriebssystem und seine Anwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/aladdinrd/blog/428311/">  In fr√ºheren Artikeln haben wir uns mit dem TrustZone-Hardwareger√§t und der Funktionsweise des Secure Monitor-Mechanismus befasst.  Heute konzentrieren wir uns auf das vertrauensw√ºrdige Betriebssystem (TEE) und seine Anwendungen.  Und wenn es beim letzten Mal ziemlich niedrige Dinge gab, wird jetzt alles auf einem sehr hohen Niveau sein - auf der Ebene des Betriebssystems. <a name="habracut"></a><br><br><h2>  Was ist TEE? </h2><br>  Was ist TEE?  Dies ist in erster Linie die vertrauensw√ºrdige Ausf√ºhrungsumgebung (Trusted Execution Environment) - dies ist die Ausf√ºhrungsumgebung von Programmen.  Wir beschreiben es in Bezug auf Funktion und Eigenschaften, aber nicht im Sinne der Programmierung, sondern im philosophischen Sinne. <br><br>  Zum Beispiel haben ein Fernzug, ein Zug und ein Taxi eine der wichtigsten Funktionen - den Transport von Menschen.  Aber je nach ihren Eigenschaften unterscheiden sie sich zum Beispiel: Ein Zug f√§hrt zwischen St√§dten, ein elektrischer Zug - au√üerhalb der Stadt und ein Taxi - haupts√§chlich in der Stadt.  Zug und Zug f√ºr Fahrkarten, Taxi - Nr.  Usw. <br><br>  Die TEE-Funktion besteht darin, einige Daten sicher f√ºr uns zu speichern und Anwendungen f√ºr uns zu starten.  Wir wollen TEE-Befehle √ºbertragen: Starten Sie diese und jene Anwendung, nehmen Sie diese und jene Daten und tun Sie dies und das mit ihnen.  Gleichzeitig k√∂nnen wir den Anwendungscode sowie die Daten nicht sehen.  Wir werden nur das Ergebnis bekommen.  Die Interaktion mit TEE ist RPC sehr √§hnlich. <br><br>  Diese Funktion ist ideal f√ºr verschiedene Kryptografien, beispielsweise f√ºr die elektronische Signatur: Schl√ºssel werden in TEE gespeichert, und wir bitten TEE, die √ºbertragenen Daten mit einem in TEE gespeicherten Schl√ºssel zu signieren.  Wir erhalten das Ergebnis, haben aber keinen Zugriff auf den Schl√ºssel. <br><br>  TEE hat eine Reihe von Eigenschaften, aber die wichtigsten sind: a) Wir vertrauen auf seine Implementierung und b) es ist zuverl√§ssig vom Hauptbetriebssystem des Ger√§ts getrennt, gesch√ºtzt, es ist schwer zu brechen oder zu brechen.  Es gibt andere Eigenschaften, aber wir nennen es ein vertrauensw√ºrdiges Betriebssystem f√ºr genau das.  Eigenschaft b) Das Wichtigste ist, dass TEE getrennt und schwer zu brechen ist, das hei√üt, es ist gesch√ºtzt. <br><br>  Wenn Sie TEE durch das Prisma von Funktionen und Eigenschaften betrachten, wird klar, dass es bei TEE nicht einmal um TrustZone geht.  TrustZone ist eine der M√∂glichkeiten, TEE vom Hauptbetriebssystem (Gastbetriebssystem) zu trennen. <br><br><h2>  TEE-Implementierungsoptionen </h2><br>  Wenn die Haupteigenschaften von TEE darin bestehen, dass es getrennt und schwer zu brechen ist, k√∂nnen wir verschiedene Optionen f√ºr die Implementierung von TEE finden: <br><br><ul><li>  Verwenden Sie TrustZone - wir erhalten die Trennung von TEE und dem Hauptbetriebssystem innerhalb desselben Prozessorkerns. </li><li>  F√ºhren Sie TEE auf einem separaten Kern innerhalb des Systems auf einem Chip aus und kommunizieren Sie mit ihm √ºber eine Hardwareschnittstelle.  Einige spezialisierte Prozessoren verf√ºgen √ºber separate vertrauensw√ºrdige Kerne, um TEE auszuf√ºhren, aber Sie k√∂nnen sie leider nicht im Gesch√§ft kaufen.  Sie k√∂nnen jedoch einen Doppelkernkristall, z. B. Cortex-A + Cortex-M0 / M4, auf Cortex-M TEE ausf√ºhren. </li><li>  F√ºhren Sie TEE in einem separaten Chip aus und stellen Sie √ºber eine externe Schnittstelle, z. B. SPI oder SMbus, eine sichere Verbindung her.  Verwenden Sie zum Schutz der Kommunikation kryptografische Methoden. <br>  Diese Methode wird verwendet, wenn Sie eine Verbindung mit einer Smartcard herstellen, z. B. einer Chip-on-Chip-Kunststoff-Zahlungskarte.  In gewisser Weise wird TEE im Chip ausgef√ºhrt, da es auf unsere Anfrage sehr sicher Finanztransaktionen durchf√ºhrt, Daten speichert usw. <br>  Die gleiche Methode wird in TPM (Trusted Platform Module) der modernen PC-Architektur verwendet. </li></ul><br>  Wir werden nur √ºber die Implementierung von TEE in TrustZone sprechen, da dies eine sehr h√§ufige Version der Implementierung von TEE ist.  Viele der oben genannten Punkte gelten jedoch allgemein f√ºr TEE. <br><br><h2>  TEE als OS </h2><br>  In fr√ºheren Artikeln haben wir TEE immer als vertrauensw√ºrdiges Betriebssystem bezeichnet und gesagt, dass es realen Betriebssystemen sehr √§hnlich ist. <br><br>  Ohne vorzugeben, allgemein zu sein, sagen wir, dass der Gro√üteil der TEE: <br><ul><li>  Anwendungen und Prozesse: TEE kann Anwendungen herunterladen und ausf√ºhren. </li><li>  Trennung von Prozess- und Kernelspeicher: Wird von der MMU verwendet, um den Prozessspeicherplatz und den TEE-Kernspeicher zu sch√ºtzen. </li><li>  Threads, Prozessinteraktionen; </li><li>  Datenspeicherung. </li></ul><br>  Sie k√∂nnen mehr abgeschnittene Versionen von TEE entwickeln, z. B. ohne dynamisches Laden von Anwendungen, ohne Prozessinteraktion, ohne Threads, aber die Anwendungen selbst, die Datenspeicherung und die Trennung von Prozessspeicher und Kernelspeicher bleiben erhalten. <div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text">  Ein Beispiel f√ºr ein abgeschnittenes TEE ist jetzt im ARM Trusted Firmware-M-Projekt f√ºr die neue Generation von Cortex-M-Mikrocontrollern auf der ARMv8-M-Plattform zu sehen.  Dies ist ein abgespecktes TEE. Jetzt werden Mikrocontroller auf den Cortex-M23- und Cortex-M33-Kernen unterst√ºtzt.  Hierbei handelt es sich um Flash-basierte Mikrocontroller, die in etwa Cortex-M0 und Cortex-M3 entsprechen, jedoch TrustZone-Unterst√ºtzung bieten.  Sie haben wenig RAM, das Programm l√§uft haupts√§chlich √ºber Flash und daher gibt es in TEE kein dynamisches Laden von Programmen.  Im Moment ist TF-M auch Single-Threaded. <br></div></div><br><h2>  TEE-Softwareschnittstelle </h2><br>  F√ºr die Interaktion mit anderen Softwarekomponenten verf√ºgt TEE √ºber eine API: <br><br><ul><li>  TEE bietet eine API f√ºr Programme √ºber Systemaufrufe (Supervisor Call, SVC-Befehl). </li><li>  TEE stellt die API f√ºr Normal World durch Aufrufe von Secure Monitor (SMC-Befehl) bereit. </li></ul><br>  Durch Systemaufrufe speichern Programme Daten und rufen Betriebssystemfunktionen auf.  Wie jedes anst√§ndige Betriebssystem versucht TEE, Programme von der Hardware bis zu dem einen oder anderen Grad zu abstrahieren. <br>  Beispielsweise arbeiten Linux-Abstracts mit Dateien durch √ñffnen, Lesen, Schreiben und Schlie√üen von Aufrufen - alle stdio-Funktionen fallen grunds√§tzlich auf die Systemaufrufe des Betriebssystems.  TEE erm√∂glicht seinen Anwendungen auch die Arbeit mit gespeicherten Daten durch Aufrufe, mit denen Objekte (Datenbl√∂cke) abstrakt gespeichert und in den Speicher geladen werden.  TEE kann auch einige kryptografische Funktionen auf Systemebene usw. bereitstellen. <br><br>  Es gibt eine Reihe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GlobalPlatform-</a> Spezifikationen f√ºr TEE, die APIs, Anforderungen, Verwendungsszenarien usw. beschreiben. <br>  Die Kern-TEE-APIs f√ºr seine Programme sind in der internen Kern-API-Spezifikation von TEE beschrieben.  Es beschreibt Datenspeicherfunktionen, kryptografische Funktionen usw. Und die ‚ÄûTEE Client API‚Äú beschreibt das Aufrufen von Anwendungen aus Normal World. <br><br>  Wenn Ihr TEE diese APIs implementiert, ist das Schreiben einer Anwendung daf√ºr recht einfach.  Dank einer API wird auch die Portabilit√§t von Programmen implementiert. <br><br><h2>  Unterschiede zwischen TEE und regul√§rem Betriebssystem </h2><br>  Die beiden Hauptunterschiede zwischen TEE und Linux und anderen uns bekannten Betriebssystemen sind: <br><br><ol><li>  TEE f√ºhrt Aktionen nicht auf Befehl des Benutzers aus, sondern auf Befehl von Normal World. </li><li>  TEE in TrustZone hat keinen eigenen Scheduler. </li></ol><br>  In einem normalen Betriebssystem generiert der Benutzer einige Eingaben - gibt Befehle ein, klickt auf die Symbole, und das Betriebssystem verarbeitet diese Eingaben, √ºbertr√§gt sie an Programme und Programme verarbeiten sie.  In der Serverversion stammt die Eingabe nicht vom Benutzer, sondern von bestimmten Clients, h√∂chstwahrscheinlich √ºber das Netzwerk.  Das Betriebssystem handelt jedoch auf der Grundlage externer Eingaben. <br><br>  TEE verarbeitet keine externen Daten und √ºbertr√§gt sie nicht an Anwendungen.  Stattdessen verarbeitet es die Befehle und Daten, die von Normal World √ºber die TEE-Client-API √ºbertragen werden, und das ist fast alles.  Es stellt sich heraus, dass TEE f√ºr das Betriebssystem als eine Bibliothek mit einer RPC-Schnittstelle fungiert, deren Funktionen aufgerufen werden.  Nach der Verarbeitung der Funktionen kann TEE nichts tun. <br><br>  Der zweite Unterschied ergibt sich aus dem ersten.  Das TEE des Treuh√§nders teilt die CPU-Zeit mit Normal World und wird als Bibliothek aufgerufen.  TEE weist sich nicht st√§ndig Prozessorzeit zu, sondern verbringt so viel Zeit wie n√∂tig, um die Anforderung abzuschlie√üen, und √ºbertr√§gt dann die Kontrolle an Normal World.  Und wenn ja, dann sollte sie keinen eigenen Scheduler haben - sie braucht einen Scheduler f√ºr das Gastbetriebssystem. <br><br>  Der Haupt-OS-Scheduler √ºbertr√§gt die Kontrolle indirekt an TEE: <br><br><ul><li>  Der Scheduler legt die zu erledigende Aufgabe fest. </li><li>  Die Task ruft den Kernel-Systemaufruf auf. </li><li>  ein Systemaufruf ruft bei Bedarf TEE auf; </li><li>  TEE arbeitet so lange wie n√∂tig, um die Anforderung abzuschlie√üen, und gibt die Kontrolle an Normal World zur√ºck. </li></ul><br><h2>  TEE-Anwendungen </h2><br>  Anwendungen, die auf TEE ausgef√ºhrt werden, werden als Trustlets bezeichnet - √§hnlich wie Applets, die auf Smartcards ausgef√ºhrt werden. <br>  Zitat aus Wikipedia: <br><blockquote>  Applet (engl. Applet aus Anwendung - Anwendung und -let - Diminutivsuffix) ist eine nicht eigenst√§ndige Softwarekomponente, die im Kontext einer anderen, vollgewichteten Anwendung arbeitet, f√ºr eine enge Aufgabe konzipiert ist und keinen Wert isoliert von der Basisanwendung hat. </blockquote><br>  Trustlet ist ein vertrauensw√ºrdiges Applet.  Dies ist ein Programm f√ºr TEE, wie wir bereits herausgefunden haben, es kommuniziert mit TEE √ºber Systemaufrufe, es hat einen Lebenszyklus usw. <br><br>  Der Name weist jedoch darauf hin, dass es sich um eine nicht eigenst√§ndige Komponente handelt.  Hier dr√ºckt sich die Unabh√§ngigkeit darin aus, dass das Trustlet Anrufe von Normal World t√§tigt und dann zusammen mit TEE die Verbindung trennt.  Wenn es sich in einer Endlosschleife dreht, funktioniert der Prozessorkern nicht mehr als Betriebssystem, und irgendwann h√§ngt alles.  Aber das Programm f√ºr ein regul√§res Betriebssystem kann sich in einer Endlosschleife drehen und meine, um einige Aufgaben zu z√§hlen. Dies ist f√ºr das Programm v√∂llig normal.  In dieser Hinsicht ist es unabh√§ngig vom Trustlet. <br><br>  Das Trustlet muss eine Art Kennung haben, damit Normal World es aufrufen kann.  Es ist √ºblich, Trustlets als UUIDs anzugeben - eindeutige Bezeichner. <br><br><h2>  Trustlet-Lebenszyklus </h2><br>  √úberlegen Sie, wie das Trastlet gestartet und die Befehle ausgef√ºhrt werden. <br><br>  Es w√§re logisch, das Trustlet in den Speicher zu laden und mit der Arbeit zu beginnen. In der GlobalPlatform TEE Client-API m√ºssen Sie jedoch zum Starten des Trustlets einen Kontext erstellen und eine Sitzung mit dem Trustlet einrichten. <br><br>  Das Erstellen eines Kontexts ist das Herstellen einer Verbindung zwischen Normal World und TEE.  In diesem Fall wird in der GlobalPlatform-Spezifikation davon ausgegangen, dass das Ger√§t mehrere TEEs haben kann. Zum Zeitpunkt der Erstellung des Kontexts k√∂nnen Sie ausw√§hlen, an welches TEE Sie sich wenden m√∂chten. <br><br>  In der GlobalPlatform TEE Client API wird hierf√ºr eine Funktion bereitgestellt: <br><br><pre> TEEC_Result TEEC_InitializeContext (const char * name, TEEC_Context * context)
</pre><br>  Diese Funktion wird von der Normal World-Anwendung aufgerufen.  Hier gibt der Name das ausw√§hlbare TEE an.  Wenn wir standardm√§√üig TEE m√∂chten oder sicher sind, dass wir nur ein TEE haben, ersetzen wir NULL.  Im Kontext wird der erstellte Kontext gespeichert. <br><br>  Nach dem Erstellen des Kontexts m√ºssen Sie eine Sitzung mit der Vertrauensstellung einrichten.  Hier ist die UUID des Trustlets f√ºr uns n√ºtzlich.  Dazu hei√üt die Funktion: <br><br><pre> TEEC_Result TEEC_OpenSession (
	 TEEC_Context * -Kontext, TEEC_Session * -Sitzung,
	 const TEEC_UUID * Ziel, uint32_t connectionMethod,
	 const void * connectionData, TEEC_Operation * operation,
	 uint32_t * returnOrigin)
</pre><br>  Eine Sitzung entspricht der Arbeit mit einer Programminstanz in einem regul√§ren Betriebssystem: Es k√∂nnen viele Instanzen desselben Programms im Betriebssystem vorhanden sein, die unabh√§ngig voneinander arbeiten.  Es gibt jedoch viele Sitzungen in TEE, und im Wesentlichen handelt es sich dabei um Verbindungen zu eindeutigen Instanzen des Trustlets im Speicher.  In diesem Fall ist der Codebereich h√∂chstwahrscheinlich derselbe, der √ºber die MMU dem Speicher verschiedener Prozesse zugeordnet wird.  Jeder Prozess verf√ºgt jedoch √ºber einen eigenen Datenbereich, sodass Instanzen unabh√§ngig voneinander arbeiten k√∂nnen.  Genau wie unter Linux. <br><br>  Beim Aufruf von TEEC_OpenSession werden der Kontext und die UUID der Zielvertrauensstellung als Eingabe √ºbertragen.  Die eingerichtete Sitzung wird in "Sitzung" gespeichert.  Einige Parameter, die wir im Folgenden nicht ber√ºcksichtigen werden, sind f√ºr das Verst√§ndnis nicht so wichtig. <br><br>  Zum Zeitpunkt der Erstellung der Sitzung kann das Trustlet in den Speicher geladen werden.  Dies geschieht mit Anwendungen auf dem Betriebssystem.  Bei gro√üen TEE ist der Linker daf√ºr verantwortlich, er l√§dt das Bin√§rbild des Trustlets herunter, dies ist eine solche signierte ELF-Datei.  Wenn es sich um ein kleines TEE handelt, sollte das Trustlet bereits in den Speicher geladen sein. Es kann statisch verkn√ºpft oder bei Flash-Mikrocontrollern unter der angegebenen Adresse in den Flash-Speicher geschrieben werden. <br><br>  Nehmen wir an, wir haben ein gro√ües TEE und m√ºssen das Trustlet in den Speicher laden.  Woher kommt er?  Im Prinzip ben√∂tigt TEE zum Zeitpunkt des Ladens ein Objekt mit einer bestimmten UUID, und der Mechanismus zum Erhalten dieses Objekts kann folgender sein: <br><br><ul><li>  Das Objekt befindet sich m√∂glicherweise bereits im Speicher. </li><li>  Das Objekt kann statisch im Flash-Speicher abgelegt werden (f√ºr Flash-Mikrocontroller). </li><li>  Das Objekt kann statisch mit TEE verkn√ºpft werden - f√ºr System-Trustlets. </li><li>  Schlie√ülich k√∂nnen Sie die Datei vom Dateisystem oder sogar √ºber das Netzwerk in den RAM herunterladen. </li></ul><br>  Fragen Sie sich sp√§ter, wie dieses TEE Daten aus einem Dateisystem oder √ºber ein Netzwerk herunterl√§dt? !!! <br><br>  Nach dem Herunterladen des Image des Trustlets wird seine digitale Signatur √ºberpr√ºft.  Es wird ein Zertifikatsystem verwendet, und TEE √ºberpr√ºft, ob die Vertrauensstellung von einer Partei unterzeichnet wurde, der TEE vertraut.  Dies ist sehr wichtig, da dadurch die M√∂glichkeit ausgeschlossen wird, ein gef√§lschtes Trustlet mit Malware herunterzuladen. <br><br>  Wenn das Trustlet-Image empfangen und die Signatur √ºberpr√ºft wurde, erstellt TEE den Adressraum f√ºr die Trustlet-Instanz in der MMU, und der Linker l√§dt den Codebereich in den Speicher, ordnet ihn dem Adressraum des Trustlets zu und initialisiert den Datenbereich.  Das Ergebnis ist eine vollst√§ndig initialisierte Instanz des Trustlets f√ºr die Arbeit mit der spezifischen aufrufenden Anwendung. Dies ist die Erstellung der Sitzung. <br><br>  Nachdem die Sitzung erstellt wurde, ist das Trustlet vollst√§ndig bereit und kann Anforderungen von der aufrufenden Anwendung ausf√ºhren.  Um die Trustlet-Funktionen vom Betriebssystem aus aufzurufen, wird die folgende Funktion verwendet: <br><br><pre> TEEC_Result TEEC_InvokeCommand (
	 TEEC_Session * Sitzung,
	 uint32_t commandID,
	 TEEC_Operation * Operation,
	 uint32_t * returnOrigin) 
</pre><br>  Hier gibt "Sitzung" unsere Sitzung an, dh die TEE-Instanz und die Trustlet-Instanz, mit der wir arbeiten. <br><br>  "CommandID" gibt die aufgerufene Funktion des Trustlets an.  Dies ist die Trustlet-Funktion, nicht die TEE-Funktion.  Alles, was TEE interessiert, ist das Starten des Trustlets und das Senden von Befehlen. Welche Befehls-ID-Nummern f√ºr die Kommunikation mit dem Trustlet zugewiesen werden m√ºssen, liegt bei Ihnen. Es gibt keine Regel oder globale Liste von Funktionen. <br><br>  Wenn Sie Parameter an die aufgerufene Funktion √ºbergeben m√ºssen, werden diese durch die Operation √ºbergeben - dies ist ein Zeiger auf die Struktur TEEC_Operation.  Wir werden jetzt nicht zu sehr in die Tiefe gehen. Beachten Sie nur, dass diese Struktur bis zu 4 Funktionsparameter enth√§lt (Typ TEEC_Parameter).  Parameter k√∂nnen ein einfacher TEEC_Value oder ein Zeiger auf den Speicher sein.  Die Parameter haben auch eine Typisierung in der Richtung: TEEC_VALUE_INPUT (Eingabe), TEEC_VALUE_OUTPUT (Ausgabe) oder TEEC_VALUE_INOUT (bidirektional). <br><br>  Wenn wir einen Zeiger auf die TEEC_Operation-Struktur √ºbergeben, m√ºssen wir ihn zuerst initialisieren: Setzen Sie alle Werte und Richtungen.  Nach Abschluss des Aufrufs k√∂nnen wir die zur√ºckgegebenen Werte in dieser Struktur √ºberpr√ºfen (f√ºr TEEC_VALUE_OUTPUT und TEEC_VALUE_INOUT). <br><br>  W√§hrend der Sitzung k√∂nnen wir die Trustlet-Funktionen so oft aufrufen, wie wir ben√∂tigen.  Am Ende der Arbeit m√ºssen Sie die Sitzung beenden und den Kontext freigeben, indem Sie TEEC_CloseSession und TEEC_FinalizeContext aufrufen. <br><br>  Das alles erinnert sehr an RPC, oder?  Im Prinzip sind alle Operationen mit TEE als RPC konzipiert. Dank dieser Funktion k√∂nnen Sie mit einer Vielzahl von TEE-Implementierungen arbeiten: in TrustZone in einem separaten Kern, in einem separaten Chip. <br><br><h2>  Supplicant </h2><br>  Oben haben wir uns gefragt: Wie l√§dt TEE Daten aus einem Dateisystem oder √ºber ein Netzwerk herunter? <br>  Wenn Sie dar√ºber nachdenken, hat TEE selbst keinen Zugriff auf das Betriebssystem-Dateisystem.  Das hei√üt, in TrustZone implementiertes TEE k√∂nnte einen solchen Zugriff haben, m√ºsste es dann aber mit Normal World teilen, und dies ist nicht so einfach.  Beispielsweise arbeitet Linux st√§ndig mit dem Dateisystem, und sein aktueller Status befindet sich nur im Linux-Kernelspeicher und nicht auf der Festplatte.  Wenn TEE eingreifen und parallel mit dem Dateisystem arbeiten m√∂chte, ist dies sehr schwierig.  Mit Netzwerkfreigabe das gleiche. <br><br>  Dar√ºber hinaus ist TEE ein eher kleines Betriebssystem, und es w√§re unrentabel, Treiber auf niedriger Ebene f√ºr die Arbeit mit Medien, einen Netzwerkcontroller und die Unterst√ºtzung eines Netzwerkstapels oder FS-Treibers zu implementieren.  Dar√ºber hinaus erh√∂ht dies die Angriffsfl√§che erheblich - es besteht die M√∂glichkeit, TEE zu knacken, indem eine ungew√∂hnliche Inode auf ext2 oder √§hnliches verschoben wird.  Das wollen wir nicht. <br>  Daher wird beim Start des Betriebssystems der sogenannte Supplicant geladen - ein Hilfsprogramm.  Es ist immer mit TEE verbunden und TEE verwendet es, um auf Ressourcen der normalen Welt zuzugreifen. <br><br>  Wenn TEE das Trustlet-Image aus dem Dateisystem herunterladen m√∂chte, ruft es Supplicant auf: <br><br>  <i>TEE: Was ist mit einem Objekt mit einer solchen UUID?</i> <i><br></i>  <i>Supplicant: (L√§dt ein Objekt aus dem Dateisystem) Entschuldigung, Sir!</i> <br><br>  Nat√ºrlich sollten solche Anrufe auf Sicherheit √ºberpr√ºft werden.  In diesem Fall √ºberpr√ºfen wir die Signatur im Trustlet und gehen fast kein Risiko ein - entweder ist die Signatur korrekt und das Trustlet funktioniert oder die Signatur ist falsch.  Das hei√üt, wir riskieren es - es gibt m√∂glicherweise kein Trustlet, Supplicant wird m√∂glicherweise nicht gestartet, aber dies ist ein weiterer Teil des Bedrohungsmodells. <br><br><h2>  Userspace-Bibliothek </h2><br>  Die Programmschnittstelle (Aufrufe von TEEC_OpenSession usw.) wird mithilfe einer Bibliothek implementiert, die einen Aufruf von der Anwendungsebene an TEE √ºbertr√§gt. <br><br>  Bei der Implementierung von TEE in TrustZone muss die Bibliothek dazu zun√§chst den Aufruf an die OS-Kernel-Ebene weiterleiten, da nur der OS-Kernel SMC (Secure Monitor Call) aufrufen kann. <br>  Im Linux + OP-TEE-Bundle lautet die Userspace-Bibliothek libteec.  Es √ºbersetzt Aufrufe der GlobalPlatform TEE Client API √ºber ioctl-Operationen an der Ger√§tedatei an den Kerneltreiber: Wenn das Betriebssystem gestartet wird, wird das Kernelmodul (Treiber) geladen, der Treiber erstellt die Ger√§tedatei.  Durch √ñffnen der Ger√§tedatei mit libteec kann das Anwenderprogramm mit der TEE-Client-API arbeiten. <br><br>  Das hei√üt, dieses Design funktioniert: <br><blockquote>  <b>Anwendung&gt; libteec&gt; Ger√§tedatei&gt; Kerneltreiber&gt; SMC&gt; TEE&gt; Vertrauen.</b> </blockquote><br><h2>  Ein Beispiel f√ºr ein Trustlet </h2><br>  So funktioniert es in einer realen Anwendung: <br><img src="https://habrastorage.org/webt/td/yg/s6/tdygs6hnze62ralshuabjivepr4.png" alt="Bild"><br>  Hier wird das Trustlet zum elektronischen Signieren von Dokumenten verwendet.  Ein Programm von Linux ruft das Trustlet auf. Zu diesem Zweck wird ein TEE-Kontext erstellt, eine Sitzung mit dem Trustlet erstellt, Daten zum Signieren √ºbertragen und die elektronische Signatur zur√ºckgegeben. <br><br><h2>  Fazit </h2><br>  In diesem Artikel haben wir herausgefunden, was TEE und Trustlets sind.  Wir haben uns mit der TEE-API getroffen und erfahren, wie Trustlets aufgerufen werden. <br><br>  Wir haben bewusst viele Dinge beiseite gelassen, z. B. die Verwendung von Shared Memory und das Schreiben von Trastlets, da der Artikel keine ersch√∂pfende Anleitung darstellt. <br><br>  Wenn Sie sich f√ºr das Thema TEE interessieren, lernen Sie weiter auf eigene Faust: Sie k√∂nnen zun√§chst die GlobalPlatform-Spezifikationen studieren oder OP-TEE erkunden.         ¬´TrustZone¬ª. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428311/">https://habr.com/ru/post/de428311/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428299/index.html">Messenger vs soziale Netzwerke vs ... - Fortsetzung</a></li>
<li><a href="../de428301/index.html">Kaspersky Start Russia: Wettbewerb der Projekte der Zukunft</a></li>
<li><a href="../de428303/index.html">Ein Tag im Leben eines Systemingenieurs</a></li>
<li><a href="../de428305/index.html">Lernst du englisch Comics zur Rettung</a></li>
<li><a href="../de428307/index.html">Java Challengers # 1: Methoden√ºberladung in der JVM</a></li>
<li><a href="../de428313/index.html">Telegramm unter MacOS speichert [vermutlich] auch lokal Korrespondenz in einer zug√§nglichen Form</a></li>
<li><a href="../de428315/index.html">5 √Ñngste vor Entwicklern, die wir √ºberwunden haben</a></li>
<li><a href="../de428317/index.html">Haken reagieren - gewinnen oder verlieren?</a></li>
<li><a href="../de428321/index.html">Predictive Data Analytics - Modellierung und Validierung</a></li>
<li><a href="../de428327/index.html">Worauf Sie achten sollten: Europ√§ische eIDAS-Verordnung zur elektronischen Identifizierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>