<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå¨Ô∏è üë©üèæ üì® Programmation h√©t√©rog√®ne et oneAPI Toolkit. Une conf√©rence improvis√©e d'experts Intel r√©pond √† vos questions üëßüèº üìú üë∏üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le cadre de la rubrique ¬´Poser une question √† un expert Intel¬ª, nous avons demand√© au principal sp√©cialiste Intel Konstantin Vladimirov de r√©pond...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmation h√©t√©rog√®ne et oneAPI Toolkit. Une conf√©rence improvis√©e d'experts Intel r√©pond √† vos questions</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/479486/"><img src="https://habrastorage.org/webt/tz/b5/gv/tzb5gvt-1m1z3yvd4tjzot84ao4.jpeg"><br><br>  Dans le cadre de la rubrique ¬´Poser une question √† un expert Intel¬ª, nous avons demand√© au principal sp√©cialiste Intel Konstantin Vladimirov de r√©pondre aux questions li√©es √† la programmation h√©t√©rog√®ne, √† la <a href="https//software.intel.com/en-us/oneapi">bo√Æte √† outils oneAPI</a> et √† des choses int√©ressantes connexes.  Le r√©sultat a d√©pass√© toutes nos attentes.  Konstantin n'a pas perdu de temps et a donn√© des r√©ponses d√©taill√©es et justifi√©es, sans craindre d'√™tre pol√©mique.  En fait, nous avons eu une petite conf√©rence sur la programmation inter-architecturale sous toutes ses formes: nuances de d√©chargement, optimisations, normes, etc. <br>  Nous transf√©rons le microphone √† l'expert.  Eh bien, les commentaires sont donn√©s au public. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="image">  Question <a href="https://habr.com/ru/users/soarex16/" class="user_link">Soarex16</a> <br><blockquote>  Dans quelle mesure la transition d'OpenCL √† oneAPI sera-t-elle laborieuse et quels avantages en retirer? </blockquote><br>  <b>La r√©ponse.</b>  Passer √† DPC ++ peut √™tre d√©licat, mais √† mon avis, cela en vaut la peine.  Il y a deux √©tapes principales. <br><br>  Tout d'abord, il s'agit d'une transition de votre langage de programmation h√©t√©rog√®ne (OpenCL, Vulkan compute), qui, tr√®s probablement, est bas√© sur l'API.  Ici, vous avez une longueur d'avance dans le fait que vous connaissez d√©j√† le sujet, et la difficult√© est de faire passer la r√©flexion du contr√¥le direct via l'API √† des constructions de langage l√©g√®rement plus implicites. <br>  Deuxi√®mement, il s'agit d'une transition de votre langue h√¥te.  Si vous avez d√©charg√© toute votre vie du C pur, le seuil d'entr√©e est √©gal au seuil de passage du C au C ++, qui est assez √©lev√©. <br><br>  Pourquoi essayer? <br><br>  Premi√®rement, DPC ++ fait un excellent travail pour un programmeur.  Vous oublierez tr√®s rapidement, comme un cauchemar, tous ces appels explicites √† clXXXYYY, et ce que signifie le sixi√®me argument, et si vous avez oubli√© le code retour.  De nombreux wrappers orient√©s objet ne cachent pas la routine, mais g√©n√©ralement au prix du passage de l'API OpenCL standard √† l'API wrapper pas si standard (j'ai √©galement vu ces v√©los).  Dans le cas de DPC ++, vous √©crivez simplement le SYCL standard avec des extensions Intel (qui pourraient bient√¥t devenir aussi le SYCL standard). <br><br>  Deuxi√®mement, DPC ++ pr√©voit une compilation conjointe, c'est-√†-dire que vous pouvez √™tre s√ªr des types et vous n'aurez pas de probl√®mes aux fronti√®res de l'API avec les dimensions, le remplissage, l'alignement.  Vous √©crivez le noyau et le code h√¥te dans un fichier, et c'est le m√™me code.  En utilisant USM, vous pouvez √©galement travailler avec des structures de donn√©es complexes beaucoup plus facilement. <br><br>  Troisi√®mement, DPC ++ est un vrai C ++, c'est-√†-dire qu'il permet une programmation g√©n√©ralis√©e.  Par exemple, le noyau le plus simple pour ajouter deux vecteurs: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> kern = [A, B, C](cl::sycl::id&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; wiID) { C[wiID] = A[wiID] + B[wiID]; <span class="hljs-comment"><span class="hljs-comment">//   A, B  C?  ! };</span></span></code> </pre> <br>  M√™me chose sur OpenCL: <br><br><pre> <code class="cpp hljs">_<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *A, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *B, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *C)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>); C[i] = A[i] + B[i]; }</code> </pre> <br>  Vous voyez, j'ai √©t√© oblig√© de pointer vers un type OpenCL int.  Si j'ai besoin d'un flottant, je devrai soit √©crire un autre noyau, soit utiliser un pr√©processeur, ou une g√©n√©ration de code externe.  Mettre presque toutes les fonctionnalit√©s de C ++ √† votre disposition peut √™tre un peu effrayant si vous n'avez pas d'exp√©rience avec C ++.  Mais c'est une chose courante quand il s'agit d'un changement technologique majeur. <br><br>  Et tous les avantages ne se limitent pas √† cela.  Je mentionnerai autre chose dans les r√©ponses suivantes. <br><br>  J'aurais donc t√©l√©charg√© le compilateur √† votre place et je l'aurais essay√©, car ce n'est pas difficile de le faire avec le package <a href="https://software.intel.com/en-us/oneapi">OneAPI</a> . <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="image">  Question <a href="https://habr.com/ru/users/juster/" class="user_link">Juster</a> <br><blockquote>  OpenVINO et oneAPI seront-ils li√©s d'une mani√®re ou d'une autre? </blockquote><br>  <b>La r√©ponse.</b>  La distribution OpenVINO fait maintenant partie de la distribution OneAPI.  L'apprentissage et l'utilisation des r√©seaux de neurones sont des t√¢ches difficiles √† calculer qui b√©n√©ficient grandement d'une programmation h√©t√©rog√®ne.  Je pense que t√¥t ou tard tous les composants OneAPI permettront d'utiliser toutes les ressources informatiques √† votre disposition: acc√©l√©rateurs graphiques et acc√©l√©rateurs sp√©ciaux comme Nervana et FPGA.  Et tout cela sans quitter le paradigme du langage et le syst√®me de type de votre programme C ++. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="image">  Questions du courrier <br><blockquote>  J'essaie de comprendre √† quoi ressemblera l'acc√©l√©rateur mat√©riel AI dans 3 ans, aidez-moi.  Il existe une soci√©t√© int√©ressante Graphcore et son IPU - cet appareil n'est pas moins efficace que FPGA, mais il est beaucoup plus facile √† programmer - Python avec le support de TensorFlow et d'autres frameworks.  Il s'av√®re que si les promesses de Graphcore sont remplies, il n'y aura pas besoin de FPGA sur le march√© de l'apprentissage automatique.  Python est beaucoup plus pratique pour les datascientists que C ++. <br>  √ätes-vous d'accord pour dire que FPGA n'est pas adapt√© au march√© de l'apprentissage automatique par rapport aux solutions programmables Python?  Si le march√© ML est perdu, quelles autres applications FPGA r√©pandues voyez-vous? <br>  Dans quelles applications voyez-vous le besoin in√©vitable d'une programmation h√©t√©rog√®ne, o√π vous ne pouvez pas vous en sortir avec des outils plus pratiques comme Python? </blockquote><br>  <b>La r√©ponse.</b>  J'ai jet√© un coup d'≈ìil sur le type d'UIP.  Encore un morceau de fer sur lequel tout le monde se d√©chargera.  Ces gars-l√† rivalisent avec le GPU et avec des acc√©l√©rateurs sp√©ciaux, et non avec le FPGA. <br><br>  Dans les t√¢ches pour lesquelles un mat√©riel sp√©cialis√© est aff√ªt√©, il battra toujours FPGA, par exemple, le rendu vid√©o est meilleur sur une carte vid√©o, etc.  Mais dans le monde (y compris dans le monde du ML), il y a beaucoup de t√¢ches pour lesquelles rien de sp√©cial n'a √©t√© invent√© ou publi√©, et ici le FPGA sera toujours indispensable.  Par exemple, parce qu'il y a une question de prix et, pour √™tre bon march√©, un mat√©riel sp√©cialis√© doit √™tre massif. <br><br>  Supposons maintenant que l'UIP sp√©cifi√©e est vraiment cool.  Cela n'annulera pas la programmation h√©t√©rog√®ne, au contraire, la pr√©sence d'un tel excellent acc√©l√©rateur le stimulera.  Et cela donnera √©galement une longueur d'avance g√©ante √† OneAPI et DPC ++, car t√¥t ou tard, quelqu'un dira "Je veux utiliser √† la fois votre IPU et mon GPU √† partir d'un seul programme."  Assez t√¥t parce que la programmation h√©t√©rog√®ne est √† ce sujet.  Sa signification est le d√©chargement d'une t√¢che appropri√©e vers un appareil appropri√©.  Une t√¢che peut venir de n'importe o√π.  Et cet appareil peut √™tre n'importe quoi, il peut m√™me √™tre le m√™me appareil sur lequel le programme s'ex√©cute.  Par exemple, si vous d√©chargez le noyau √©crit en ISPC et utilisez au maximum les fonctionnalit√©s vectorielles de Xeon, vous pouvez le d√©charger vous-m√™me tout en √©tant un gain significatif.  Le crit√®re principal ici est la performance.  Eh bien, il n'y aura jamais trop de productivit√© dans ce monde.  M√™me avec les meilleurs acc√©l√©rateurs du monde. <br><br>  Quant √† Python et sa commodit√© ... Je dois admettre tout de suite que je n'aime pas les langages typ√©s dynamiquement: ils sont lents et au lieu d'une erreur de compilation normale, vous devez attendre deux heures avant de tomber dans le runtime en raison du mauvais type.  Mais je ne vois pas √† quel point il est mauvais de faire les m√™mes d√©chargements sous Python.  Soit dit en passant, OneAPI comprend d√©j√† Intel Distribution for Python, ce qui est extr√™mement pratique pour diverses critiques. <br><br>  Autrement dit, dans le monde de r√™ve des amateurs de Python, vous √©crivez un programme dessus et le d√©chargez sur tous les acc√©l√©rateurs que vous pouvez trouver en utilisant OneAPI, et non pas sur un tas de biblioth√®ques sp√©cifiques au fournisseur.  Une autre chose est qu'avec cette approche, vous manquez de taper de bout en bout et revenez dans le monde extr√™mement pr√©caire de la programmation bas√©e sur API.  Peut-√™tre que le d√©veloppement de DPC ++ encouragera la communaut√© √† utiliser plus activement des outils plus appropri√©s, tels que C ++. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="image">  Question du courrier <br><blockquote>  Performance contre OpenCL.  Il doit y avoir des taxes sur le luxe - c'est-√†-dire  les frais g√©n√©raux.  Y a-t-il des mesures? </blockquote><br>  <b>La r√©ponse.</b>  Sur Internet, vous pouvez trouver de nombreuses mesures avec une vari√©t√© de r√©sultats, selon le compilateur, la t√¢che et la qualit√© de la mise en ≈ìuvre.  √Ä titre de recherche personnelle, j'ai mesur√© sur des t√¢ches simples (SGEMM, DGEMM) sur mon ordinateur portable (graphiques Skylake int√©gr√©s), et j'ai vu que jusqu'√† pr√©sent, il y a un certain rabattement (en pourcentage).  Mais il me semble que c'est une cons√©quence du fait que tout cela est jusqu'√† pr√©sent en version b√™ta. <br><br>  En th√©orie, le r√©sultat devrait √™tre une acc√©l√©ration, pas une d√©c√©l√©ration, c'est-√†-dire qu'en principe tout ce luxe devrait avoir une valeur n√©gative.  Tout tourne autour du compilateur.  Lorsque votre programme se compose d'une seule source et est trait√© comme un seul programme, le compilateur offre des possibilit√©s d'optimisation fantastiques et incroyables: pr√©sentation de code commun, inversion de boucles, r√©organisation des sections de code et tout ce que le compilateur ne peut tout simplement pas faire dans l'approche bas√©e sur l'API, mais t√¥t ou tard, elle apprendra certainement avec un mod√®le √† source unique. <br><br>  De plus, DPC ++ aura un co√ªt n√©gatif en termes de temps de d√©veloppement.  Un exemple simple est les accesseurs SYCL, que le compilateur utilise d√©j√† pour organiser les √©v√©nements et g√©rer les files d'attente asynchrones. <br><br><pre> <code class="cpp hljs">deviceQueue.submit([&amp;](cl::sycl::handler &amp;cgh) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> A = bufferA.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> B = bufferB.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> C = bufferC.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_write&gt;(cgh); .... deviceQueue.submit([&amp;](cl::sycl::handler &amp;cgh) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> A = bufferA.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> B = bufferB.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> D = bufferD.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_write&gt;(cgh);</code> </pre><br>  Ici, le compilateur voit que les deux packages ne lisent que A et B et √©crivent des tampons ind√©pendants C et D, par cons√©quent, il voit la possibilit√© de les envoyer en parall√®le s'il y a suffisamment de tailles globales. <br><br>  Bien s√ªr, un programme OpenCL √©crit de mani√®re p√©dante peut le faire aussi bien, mais le temps de d√©veloppement pass√© avec un noyau non trivial ne sera pas comparable. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="image">  Question du courrier <br><blockquote>  Toutes les fa√ßons d'optimiser les applications OpenCL pour DPC ++ sont-elles pertinentes?  Quoi de neuf √† y ajouter? </blockquote><br>  <b>La r√©ponse.</b>  Je dirais que le compilateur peut et devrait faire la plupart de l'optimisation manuelle fine qui est effectu√©e par les auteurs du noyau.  De la m√™me mani√®re, par exemple, je consid√®re comme une pratique n√©faste d'installer manuellement un assembleur en ligne dans des programmes C ++, car m√™me s'il donne des avantages tactiques, il interf√®re avec les optimisations et agit comme un facteur n√©gatif dans le d√©veloppement et le transfert d'un produit.  Eh bien, OpenCL est maintenant √©galement assembleur. <br><br>  Quant √† la r√©ponse plus d√©taill√©e, j'ai peur de l'ab√Æme ici.  Par exemple, il existe un document Intel bien connu "OpenCL Developer Guide for Intel Processor Graphics".  Et il y a une <a href="https://software.intel.com/en-us/iocl-opg-avoiding-needless-synchronization">section</a> sur la fa√ßon d'essayer, afin de ne pas mettre o√π la synchronisation excessive. <br><br>  Donc, de mon point de vue, c'est une t√¢che non humaine en principe.  Les gens sont extr√™mement pauvres pour raisonner sur la synchronisation multi-thread et ont tendance √† sculpter la synchronisation de mani√®re conservatrice ou incorrecte, ou les deux √† la fois - je mets des virgules comme √ßa ( <i>mais nous l'avons corrig√© - note √©ditoriale</i> ). <br><br>  D'un autre c√¥t√©, en DPC ++, au lieu d'√©crire du code avec des barri√®res explicites, comme ceci: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (t = <span class="hljs-number"><span class="hljs-number">0</span></span>; t &lt; numTiles; t++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tiledRow = TS * t + row; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tiledCol = TS * t + col; Asub[col][row] = A[globalRow * AY + tiledCol]; Bsub[col][row] = B[tiledRow * BY + globalCol]; <span class="hljs-comment"><span class="hljs-comment">// Synchronise to make sure the tile is loaded barrier(CLK_LOCAL_MEM_FENCE); // .... etc ....</span></span></code> </pre> <br>  Vous √©crirez tr√®s probablement une it√©ration explicite de <i>parallel_for_work_group</i> , dans laquelle <i>group.parallel_for_work_item</i> <br><br><pre> <code class="cpp hljs">cgh.parallel_for_work_group&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mxm_kernel</span></span></span><span class="hljs-class">&gt;( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cl</span></span></span><span class="hljs-class">:</span></span>:sycl::range&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;{BIG_AX / TS, BIG_BY / TS}, cl::sycl::range&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;{TS, TS}, [=](cl::sycl::group&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; group) { <span class="hljs-comment"><span class="hljs-comment">// .... etc .... for (int t = 0; t &lt; numTiles; t++) { group.parallel_for_work_item([&amp;](cl::sycl::h_item&lt;2&gt; it) { // .... etc .... Asub[col][row] = A[globalRow][tiledCol]; Bsub[col][row] = B[tiledRow][globalCol]; }); //      ,   </span></span></code> </pre> <br>  Par cons√©quent, vous n'avez pas du tout besoin de d√©finir la synchronisation √† la main et la section enti√®re peut √™tre supprim√©e. <br><br>  Et vous pouvez donc marcher dans toutes les sections.  Quelque chose survivra, quelque chose partira.  Je pr√©vois l'√©mergence d'un nouveau document ¬´Optimisation pour DPC ++¬ª, mais le temps devrait passer, car toutes les techniques r√©ellement efficaces ne sont d√©velopp√©es que plus tard et avec du sang <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="image">  Question du courrier <br><blockquote>  Il y a une limitation dans OpenCL - vous ne pouvez pas utiliser des "donn√©es distantes" dans le noyau, c'est-√†-dire, par exemple, impl√©menter un "filtre large" qui utilise les donn√©es d'entr√©e d'un grand groupe de pixels plus grand que le groupe de travail OpenCL dans un calcul.  Que propose DPC ++ √† cet √©gard? </blockquote><br>  <b>La r√©ponse.</b>  Eh bien, c‚Äôest impossible.  Bien s√ªr, je n'√©cris pas particuli√®rement les noyaux ... Mais il est absolument certain que vous pouvez utiliser toute la m√©moire globale telle quelle, il vous suffit de vous assurer que vous travaillez avec les op√©rations atomiques (ou synchronisez les noyaux hi√©rarchiques en externe).  Et vous pouvez √©galement connecter le syst√®me SVM (enfin, ou l'USM en DPC ++). <br><br>  H√©las, tout cela est extr√™mement inefficace, et je n'aime pas toutes ces astuces.  De plus, ils sont difficiles √† optimiser par le compilateur. <br><br>  Et donc, si nous parlons de solutions directes et efficaces, alors, bien s√ªr, il n'y a pas de magie dans DPC ++.  Votre programme √† la fin est toujours divis√© en parties: le code h√¥te et le code de l'appareil, et toutes les restrictions de l'appareil affectent le code de l'appareil.  La taille maximale du groupe de travail est ce v√©ritable parall√©lisme dont votre mat√©riel est capable.  Tout cela n'est que des moyens de sortir, ce qui affecte consid√©rablement les performances.  C'est pourquoi DPC ++ offre une opportunit√© de le faire: <i>device.get_info &lt;sycl :: info :: device :: max_work_group_size&gt; ()</i> , puis de d√©cider comment vivre avec le nombre r√©sultant. <br><br>  Il serait tentant, bien s√ªr, de cr√©er un mod√®le en DPC ++, lorsque le programmeur fonctionne comme vous le souhaitez avec des boucles de n'importe quelle longueur, et que le compilateur regarde quoi faire ensuite, mais ce serait une erreur mortelle, car cela cacherait des constantes, voire des asymptotiques d'une complexit√© accrue l'informatique apparaissant de nulle part.  Pour une autre raison, Alexandrescu a √©crit que ¬´l'encapsulation de la complexit√© devrait √™tre consid√©r√©e comme un crime¬ª, et cela s'applique √©galement. <br><br>  Parfois, la r√©vision de l'algorithme lui-m√™me est utile.  Ici, DPC ++ facilite les choses car un code plus structur√© est plus facile √† refactoriser.  Mais c'est une consolation. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="image">  Question du courrier <br><blockquote>  DPC ++ est bas√© sur SYCL.  Mais que se passe-t-il si vous allez plus loin sous le capot, quelles sont les diff√©rences d'OpenCL dans la mise en ≈ìuvre du back-end, le cas √©ch√©ant.  Par exemple, le m√©canisme de distribution entre les appareils h√©t√©rog√®nes est-il le m√™me qu'OpenCL? </blockquote><br>  <b>La r√©ponse.</b>  Si vous vous mettez sous le capot, c'est OpenCL.  Tous les avantages et les points forts de SYCL sont les avantages et les points forts du langage, c'est-√†-dire le frontend.  De la partie frontale vient le bon vieux SPIRV qui va au backend et l√† il est optimis√© (souvent d√©j√† au moment de l'ex√©cution, c'est-√†-dire, c'est JIT) d√©j√† pour une carte vid√©o sp√©cifique de la m√™me mani√®re qu'OpenCL serait optimis√© pour elle. <br><br>  Une autre chose est que le m√©canisme de distribution du travail entre les appareils h√©t√©rog√®nes est juste plus frontal que principal, car c'est le code h√¥te qui d√©cide quoi envoyer et o√π.  Et le code h√¥te est obtenu √† partir de DPC ++.  J'ai d√©j√† montr√© un exemple un peu plus haut comment le compilateur peut, sur la base d'accesseurs, prendre une d√©cision sur la parall√©lisation de paquets.  Et ce n'est que la pointe de l'iceberg. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="image">  Question du courrier <br><blockquote>  Biblioth√®ques  Oui, nous ne parlons pas de CUDA.  Mais nous savons que pour les d√©veloppeurs CUDA, il existe des biblioth√®ques tr√®s utiles qui fonctionnent avec de hautes performances sur le GPU.  OneAPI contient √©galement certaines biblioth√®ques, mais, par exemple, <a href="https://software.intel.com/en-us/ipp">IPP</a> - il n'y a rien d'archivage utile pour travailler avec des images dans oneAPI / OpenCL.  Y aura-t-il quelque chose, et comment dans ce cas passer de CUDA √† oneAPI? </blockquote><br>  <b>La r√©ponse.</b>  La transition de CUDA √† un standard ouvert unique sera difficile, mais in√©vitable.  Bien s√ªr, CUDA dispose d√©sormais d'une infrastructure plus mature.  Mais les caract√©ristiques de sa licence sont un inconv√©nient bloquant, car de plus en plus d'acteurs apparaissent sur le march√© des syst√®mes h√©t√©rog√®nes, de plus en plus de cartes et d'acc√©l√©rateurs int√©ressants de diff√©rents fabricants. <br><br>  La diversit√© des API existantes rend difficile l'utilisation de ce monde de possibilit√©s pour les programmeurs ayant une exp√©rience du CPU classique.  Ce qui conduit √† OneAPI ou quelque chose comme √ßa.  Ici, la magie n'est pas dans la perc√©e d'Intel dans les graphiques, mais dans le fait qu'Intel ouvre la porte √† DPC ++ √† tout le monde.  Nous ne poss√©dons m√™me pas la norme SYCL, elle appartient au groupe Khronos et toutes les extensions Intel sont des extensions de Khronos o√π tout le monde peut s'engager (et il y a des repr√©sentants de tous les principaux acteurs l√†-bas).  Et cela signifie (les biblioth√®ques) et la communaut√© appara√Ætront (apparaissent d√©j√†), et beaucoup de postes vacants dans cette direction. <br><br>  Et bien s√ªr, IPP sera r√©√©crit pour de nouvelles r√©alit√©s.  Je n'ai rien √† voir avec IPP, mais utiliser DPC ++ est du bon sens, et des gens sens√©s sont assis l√†. <br><br>  Mais plus important encore, c'est maintenant le moment de l'histoire o√π vous pouvez √©crire votre propre biblioth√®que, qui d√©passera IPP et que le monde entier utilisera ensuite.  Parce que les standards ouverts gagnent toujours. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="image">  Question du courrier <br><blockquote>  Si nous comparons le lancement d'algorithmes de formation et d'inf√©rence de r√©seaux neuronaux sur Nervana et FPGA - quelles sont les diff√©rences de programmation et l'efficacit√© qui en r√©sulte? </blockquote><br>  <b>La r√©ponse.</b>  Je ne sais rien des d√©tails de la programmation FPGA, j'√©cris des compilateurs.  Mais j'ai une contre-question.  Et comment allons-nous comparer?  Sur les rep√®res standard, c'est antisportif, Nervana a l√©ch√© sous eux.  Mais si vous avez quelque chose d'int√©ressant, le FPGA vous d√©liera les mains, et mettre ce quelque chose sur Nervana peut √™tre long, cher, c'est tout. <br><br>  Il s'av√®re que la question elle-m√™me est, pour ainsi dire, issue de la s√©rie ¬´qui est plus fort qu'un √©l√©phant ou une baleine¬ª.  Mais ce n'est pas une vraie question.  La vraie question est: comment atteler √† la fois un √©l√©phant et une baleine dans une charrette?  Eh bien, ou du moins distribuez, disons, un √©l√©phant pour le tirer par terre et une baleine par mer. <br><br>  Dans le cas de OneAPI, vous aurez le m√™me programme en g√©n√©ral en C ++ standard.  Et vous pouvez l'√©crire vous-m√™me et l'ex√©cuter avec d√©chargement dans les deux sens.  Ce sera la t√¢che m√™me qui vous int√©resse, sur laquelle vous pouvez vous-m√™me mesurer et optimiser les performances.  Un standard unique et une interface unique pour les appareils h√©t√©rog√®nes constitueront une √©tape vers la comparaison des pommes avec les pommes dans ces domaines. <br><br>  Par exemple: "quoi de mieux pour% de ma t√¢che% du point de vue de la facilit√© de programmation et d'efficacit√© - mettre cette partie sur FPGA, laisser celle-ci sur Nervana ou diviser cette partie en deux, et r√©√©crire cette partie pour le GPU?" <br><br>  Et toute l'histoire avec OneAPI - c'est juste pour vous de dire, "pourquoi y penser longtemps, je vais l'essayer maintenant rapidement, C'EST SIMPLE". <br><br>  Pas encore, pas facile.  Mais il y en aura. <br><br><hr><br>  <b>Mot de l'expert</b> <br><br>  Merci √† tous pour vos questions.  Il est possible et m√™me probable que je me sois tromp√©, inexact et fait des erreurs.  Cela arrive, sur Internet, constamment quelqu'un a tort. <br><br>  J'esp√®re que j'ai pu int√©resser quelqu'un √† la programmation h√©t√©rog√®ne et au DPC ++.  Je veux recommander √† tous le site <a href="https://sycl.tech/">sycl.tech</a> , o√π se trouvent des tonnes de rapports, y compris d'experts de renomm√©e mondiale (l'anglais est requis) <br><br>  Bon √† tous! <br><br>  <i>PS de l'√©diteur.</i>  <i>Cette fois, par d√©cision unanime du comit√© de r√©daction, il a √©t√© d√©cid√© d'attribuer le prix de la meilleure question ... √† l'auteur des r√©ponses.</i>  <i>Je pense que vous conviendrez que c'est juste.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479486/">https://habr.com/ru/post/fr479486/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479468/index.html">Edge of Honesty et John Doe</a></li>
<li><a href="../fr479474/index.html">Pourquoi l'auto-organisation des √©quipes est-elle si importante dans Scrum et pourquoi il ne peut y avoir de managers</a></li>
<li><a href="../fr479478/index.html">Plug-in Java sans douleur</a></li>
<li><a href="../fr479480/index.html">SDK SARIF et ses erreurs</a></li>
<li><a href="../fr479482/index.html">SDK SARIF et ses erreurs</a></li>
<li><a href="../fr479488/index.html">D'un ordinateur portable - un serveur domestique avec alimentation redondante au routeur Mikrotik</a></li>
<li><a href="../fr479492/index.html">Informatique sans serveur bas√©e sur OpenWhisk, partie 3</a></li>
<li><a href="../fr479496/index.html">Analyse des t√¢ches WTF en JavaScript</a></li>
<li><a href="../fr479498/index.html">Comment le temps lin√©aire se transforme en Windows en O (n¬≤)</a></li>
<li><a href="../fr479502/index.html">Comment survivre √† la p√©riode glaciaire la plus s√©v√®re de l'histoire de la Terre?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>