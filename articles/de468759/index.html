<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⬆️ 👩🏿‍🚒 👍🏻 Über trivial_abi in Clang 🚵🏽 🏿 👦🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schließlich schrieb ich einen Beitrag über [[trivial_abi]]! 

 Dies ist eine neue proprietäre Funktion im Clang-Trunk, die ab Februar 2018 neu ist. Di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Über trivial_abi in Clang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468759/">  Schließlich schrieb ich einen Beitrag über [[trivial_abi]]! <br><br>  Dies ist eine neue proprietäre Funktion im Clang-Trunk, die ab Februar 2018 neu ist. Dies ist eine Herstellererweiterung der C ++ - Sprache, es handelt sich nicht um Standard-C ++, es wird vom GCC-Trunk nicht unterstützt, und es gibt meines Wissens keine aktiven Vorschläge von WG21, sie in den C ++ - Standard aufzunehmen. <br><br><img src="https://habrastorage.org/webt/ie/do/9e/iedo9ep8gzdeliscehwljy0clnq.jpeg"><br><br>  Ich habe an der Implementierung dieser Funktion nicht teilgenommen.  Ich habe mir nur die Patches auf der Mailingliste von cfe-commit angesehen und mir schweigend applaudiert.  Aber das ist so eine coole Funktion, dass ich denke, jeder sollte davon wissen. <br><a name="habracut"></a><br>  Als erstes beginnen wir also: Dies ist kein Standardattribut, und der Clang-Trunk unterstützt nicht die Standardschreibweise des Attributs [[trivial_abi]].  Stattdessen sollten Sie es im alten Stil schreiben, wie unten gezeigt: <br><br><pre><code class="cpp hljs">__attribute__((trivial_abi)) __attribute__((__trivial_abi__)) [[clang::trivial_abi]]</code> </pre> <br>  Und da dies ein Attribut ist, ist der Compiler sehr wählerisch, wo Sie es einfügen, und stillschweigend aggressiv, wenn Sie es an der falschen Stelle einfügen (da nicht erkannte Attribute einfach ohne Nachrichten ignoriert werden).  Dies ist kein Fehler, dies ist eine Funktion.  Die richtige Syntax lautet: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) class TRIVIAL_ABI Widget { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ... };</span></span></span></span></code> </pre> <br><br><h3>  Welches Problem löst das? </h3><br><br>  Erinnerst du dich an meinen Beitrag vom 17.04.2008, in dem ich zwei Versionen der Klasse gezeigt habe? <br><br><blockquote>  Hinweis  perev: Da der Beitrag vom 17.04.2008 ein kleines Volumen hat, habe ich ihn nicht separat veröffentlicht, sondern direkt hier unter dem Spoiler eingefügt. <br></blockquote><div class="spoiler">  <b class="spoiler_title">Beitrag vom 17.04.2008</b> <div class="spoiler_text"><h3>  Nachteile eines fehlenden Trivial Destructor Call </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Siehe die C ++ Standard-Angebots-Mailingliste.</a>  Welche der beiden Funktionen, foo oder bar, hat den besten vom Compiler generierten Code? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Integer() {} <span class="hljs-comment"><span class="hljs-comment">// deliberately non-trivial }; void foo(std::vector&lt;int&gt;&amp; v) { v.back() *= 0xDEADBEEF; v.pop_back(); } void bar(std::vector&lt;Integer&gt;&amp; v) { v.back().value *= 0xDEADBEEF; v.pop_back(); }</span></span></code> </pre><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kompilieren</a> mit GCC und libstdc ++.  Ratet mal, richtig? <br><br><pre> <code class="cpp hljs">foo: movq <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi), %rax imull $<span class="hljs-number"><span class="hljs-number">-559038737</span></span>, <span class="hljs-number"><span class="hljs-number">-4</span></span>(%rax), %edx subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, %rax movl %edx, (%rax) movq %rax, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret bar: subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret</code> </pre> <br><br>  Folgendes passiert hier: GCC ist intelligent genug, um zu verstehen, dass beim Starten eines Destruktors für einen Speicherbereich seine Lebensdauer endet und alle vorherigen Einträge in diesen Speicherbereich "tot" sind.  GCC ist aber auch klug genug zu verstehen, dass ein trivialer Destruktor (wie der Pseudo-Destruktor ~ int ()) nichts tut und keine Effekte erzeugt. <br><br>  Die Balkenfunktion ruft also pop_back auf, das ~ Integer () ausführt, wodurch vec.back () tot ist, und GCC entfernt die Multiplikation mit 0xDEADBEEF vollständig. <br><br>  Auf der anderen Seite ruft foo pop_back auf, wodurch der Pseudo-Destruktor ~ int () gestartet wird (der Aufruf kann vollständig übersprungen werden, aber nicht). GCC erkennt, dass er leer ist, und vergisst ihn.  Daher sieht GCC nicht, dass vec.back () tot ist, und entfernt die Multiplikation mit 0xDEADBEEF nicht. <br><br>  Dies geschieht für einen trivialen Destruktor, jedoch nicht für einen Pseudo-Destruktor wie ~ int ().  Ersetzen Sie unsere ~ Integer () {} durch ~ Integer () = default;  und sehen Sie, wie die imull Anweisung wieder erschien! <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Foo() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// trivial }; struct Bar { int value; ~Bar() {} // deliberately non-trivial };</span></span></code> </pre> <br>  In diesem Beitrag wird der Code angegeben, in dem der Compiler Code für Foo schlechter als für Bar generiert hat.  Es lohnt sich zu diskutieren, warum dies unerwartet war.  Programmierer erwarten intuitiv, dass "trivialer" Code besser ist als "nichttrivialer" Code.  Dies ist in den meisten Situationen der Fall.  Dies ist insbesondere dann der Fall, wenn wir einen Funktionsaufruf durchführen oder zurückkehren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">incr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class">) {</span></span> obj.value += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; }</code> </pre> <br>  incr wird mit folgendem Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kompiliert</a> : <br><br><pre> <code class="cpp hljs">leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %eax retq</code> </pre> <br>  (leal ist der x86- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Befehl</a> , der "add" bedeutet.) Wir sehen, dass unser 4-Byte-Objekt im% edi-Register an incr übergeben wird, und wir addieren 1 zu seinem Wert und geben ihn an% eax zurück.  Vier Bytes am Eingang, vier Bytes am Ausgang, einfach und unkompliziert. <br><br>  Schauen wir uns nun incr an (der Fall mit einem nicht trivialen Destruktor). <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rsi) movl %eax, (%rdi) movq %rdi, %rax retq</code> </pre> <br>  Hier wird obj nicht im Register übergeben, obwohl hier die gleichen 4 Bytes mit der gleichen Semantik sind.  Hier wird obj übergeben und an die Adresse zurückgegeben.  Hier reserviert der Aufrufer etwas Platz für den Rückgabewert und übergibt uns einen Zeiger auf diesen Platz in rdi, und der Aufrufer gibt uns einen Zeiger für den Rückgabewert obj im nächsten Argumentregister% rsi.  Wir extrahieren den Wert aus (% rsi), addieren 1, speichern ihn zurück in (% rsi), um den Wert von obj selbst zu aktualisieren, und kopieren dann (trivial) 4 Bytes von obj in den Steckplatz für den Rückgabewert, auf den% rdi zeigt.  Schließlich kopieren wir den vom Aufrufer übergebenen ursprünglichen Zeiger von% rdi nach% rax, da das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">x86-64-ABI-</a> Dokument (S. 22) uns dazu auffordert. <br><br>  Der Grund, warum Bar so anders ist als Foo, ist, dass Bar einen nicht trivialen Destruktor hat und der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">x86-64 ABI</a> (S. 19) speziell angibt: <br><br><blockquote>  Wenn ein C ++ - Objekt einen nichttrivialen Kopierkonstruktor oder einen nichttrivialen Destruktor hat, wird es über einen unsichtbaren Link übergeben (das Objekt wird in der Parameterliste durch einen Zeiger [...] ersetzt). </blockquote><br>  Ein späteres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Itanium C ++ ABI-</a> Dokument definiert Folgendes: <br><blockquote>  Wenn der Parametertyp für den Zweck des Aufrufs nicht trivial ist, muss der Anrufer einen temporären Ort zuweisen und einen Link zu diesem temporären Ort übergeben: <br>  [...] <br>  Ein Typ wird für den Zweck des Aufrufs als nicht trivial betrachtet, wenn: <br><br>  Es verfügt über einen nichttrivialen Kopierkonstruktor, einen sich bewegenden Konstruktor, einen Destruktor oder alle seine Verschiebungs- und Kopierkonstruktoren werden gelöscht. </blockquote><br>  Das erklärt also alles: Bar hat eine schlechtere Codegenerierung, weil sie über einen unsichtbaren Link geleitet wird.  Es wird über eine unsichtbare Verbindung übertragen, da eine unglückliche Kombination zweier unabhängiger Umstände eingetreten ist: <br><ul><li>  Laut ABI-Dokument werden Objekte mit nicht trivialem Destruktor über unsichtbare Links weitergeleitet </li><li>  Bar hat einen nicht trivialen Destruktor. </li></ul><br>  Dies ist ein klassischer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Syllogismus</a> : Der erste Punkt ist die Hauptprämisse, der zweite ist privat.  Infolgedessen wird Bar über eine unsichtbare Verbindung übertragen. <br><br>  Lassen Sie uns einen Syllogismus geben: <br><ul><li>  Alle Menschen sind sterblich </li><li>  Sokrates ist ein Mann. </li><li>  Folglich ist Sokrates sterblich. </li></ul><br><br>  Wenn wir die Schlussfolgerung „Sokrates ist sterblich“ widerlegen wollen, müssen wir eine der Prämissen widerlegen: entweder um die Hauptsache zu widerlegen (vielleicht sind einige Menschen nicht sterblich) oder um das Private zu widerlegen (vielleicht ist Sokrates keine Person). <br><br>  Damit Bar in ein Register (wie Foo) aufgenommen werden kann, müssen wir eine von zwei Prämissen widerlegen.  Der Standard-C ++ - Pfad besteht darin, Bar einen trivialen Destruktor zu geben, der die private Prämisse zerstört.  Aber es gibt noch einen anderen Weg! <br><br><h3>  Wie [[trivial_abi]] das Problem löst </h3><br>  Das neue Clang-Attribut zerstört die Hauptprämisse.  Clang erweitert das ABI-Dokument wie folgt: <br><blockquote>  Wenn der Parametertyp für den Zweck des Aufrufs nicht trivial ist, muss der Anrufer einen temporären Ort zuweisen und einen Link zu diesem temporären Ort übergeben: <br>  [...] <br>  Ein Typ wird für den Zweck des Aufrufs als nicht trivial betrachtet, wenn er als [[trivial_abi]] markiert ist und: <br>  Es verfügt über einen nichttrivialen Kopierkonstruktor, einen sich bewegenden Konstruktor, einen Destruktor oder alle seine Verschiebungs- und Kopierkonstruktoren werden gelöscht. <br></blockquote><br>  Selbst wenn eine Klasse mit einem nichttrivial bewegten Konstruktor oder Destruktor für den Zweck des Aufrufs als trivial betrachtet werden kann, wenn sie als [[trivial_abi]] markiert ist. <br><br>  Mit Clang können wir jetzt folgendermaßen schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) struct TRIVIAL_ABI Baz { int value; ~Baz() {} </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// deliberately non-trivial };</span></span></span></span></code> </pre> <br>  Kompilieren Sie incr &lt;Baz&gt; und erhalten Sie den gleichen Code wie incr &lt;Foo&gt;! <br><h3>  Warnung Nr. 1: [[trivial_abi]] macht manchmal nichts </h3><br>  Ich würde hoffen, dass wir Wrapper für Standardbibliothekstypen wie folgt "trivial für Aufrufzwecke" machen können: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trivial_unique_ptr</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt;::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>; };</code> </pre> <br>  Leider funktioniert das nicht.  Wenn Ihre Klasse über Basisklassen oder nicht statische Felder verfügt, die für den Zweck des Aufrufs "nicht trivial" sind, macht die Clang-Erweiterung in der Form, in der sie jetzt geschrieben ist, Ihre Klasse "irreversibel nicht trivial", und das Attribut hat keine Auswirkung.  (Es werden keine Diagnosemeldungen ausgegeben. Dies bedeutet, dass Sie [[trivial_abi]] in der Klassenvorlage als optionales Attribut verwenden können und die Klasse "bedingt trivial" ist, was manchmal nützlich ist. Der Nachteil ist natürlich, dass Sie dies können Markieren Sie die Klasse als trivial und stellen Sie dann fest, dass der Compiler sie leise behoben hat.) <br><br>  Das Attribut wird ohne Nachrichten ignoriert, wenn Ihre Klasse über eine virtuelle Basisklasse oder virtuelle Funktionen verfügt.  In diesen Fällen passt es möglicherweise nicht in die Register, und ich weiß nicht, was Sie erhalten möchten, indem Sie es als Wert übergeben, aber Sie wissen es wahrscheinlich. <br><br>  Soweit ich weiß, ist die einzige Möglichkeit, TRIVIAL_ABI für „Standard-Utility-Typen“ wie optional &lt;T&gt;, unique_ptr &lt;T&gt; und shared_ptr &lt;T&gt; zu verwenden, die <br><ul><li>  Implementieren Sie sie selbst von Grund auf neu und wenden Sie das Attribut an, oder </li><li>  Brechen Sie in Ihre lokale Kopie von libc ++ ein und fügen Sie das Attribut dort mit Ihren Händen ein </li></ul><br>  (In der Open Source-Welt sind beide Methoden im Wesentlichen gleich.) <br><br><h3>  Warnung Nr. 2: Verantwortung des Zerstörers </h3><br>  Im Beispiel mit Foo / Bar hat die Klasse einen leeren Destruktor.  Lassen Sie unsere Klasse tatsächlich einen nichttrivialen Destruktor haben. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Up1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; Up1(Up1&amp;&amp; u) : value(u.value) { u.value = <span class="hljs-number"><span class="hljs-number">0</span></span>; } ~Up1() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"destroyed"</span></span>); } };</code> </pre> <br>  Dies sollte Ihnen bekannt sein. Dies ist unique_ptr &lt;int&gt;, bis zum Limit vereinfacht, wobei die Nachricht beim Löschen gedruckt wird. <br><br>  Ohne TRIVIAL_ABI sieht Inkr &lt;Up1&gt; wie Inkr &lt;Bar&gt; aus: <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rdi) movl $<span class="hljs-number"><span class="hljs-number">0</span></span>, (%rsi) movq %rdi, %rax retq</code> </pre> <br><br>  Mit TRIVIAL_ABI sieht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inkr größer und beängstigender aus</a> ! <br><br><pre> <code class="cpp hljs">pushq %rbx leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %ebx movl $.L.str, %edi callq <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span> movl %ebx, %eax popq %rbx retq</code> </pre> <br><br>  In der traditionellen Aufrufkonvention werden Typen mit einem nicht trivialen Destruktor immer von einer unsichtbaren Verknüpfung übergeben, was bedeutet, dass die empfangende Seite (in diesem Fall inkr) immer einen Zeiger auf ein Parameterobjekt akzeptiert, ohne dieses Objekt zu besitzen.  Das Objekt gehört dem Anrufer. Dadurch funktioniert die Elisionsarbeit! <br><br>  Wenn ein Typ mit [[trivial_abi]] in Registern übergeben wird, erstellen wir im Wesentlichen eine Kopie des Parameterobjekts. <br><br>  Da x86-64 nur ein Register zurückgeben kann (Applaus), kann die aufgerufene Funktion das Objekt am Ende nicht zurückgeben.  Die aufgerufene Funktion sollte das Eigentum an dem Objekt übernehmen, das wir an sie übergeben haben!  Dies bedeutet, dass die aufgerufene Funktion den Destruktor des Parameterobjekts aufrufen muss, wenn es beendet ist. <br><br>  In unserem vorherigen Beispiel, Foo / Bar / Baz, heißt der Destruktor, aber er war leer und wir haben es nicht bemerkt.  In Inkr &lt;Up2&gt; sehen wir nun zusätzlichen Code, der vom Destruktor auf der Seite der aufgerufenen Funktion generiert wird. <br><br>  Es kann davon ausgegangen werden, dass dieser zusätzliche Code in einigen Benutzerfällen generiert wird.  Im Gegenteil, der Ruf des Zerstörers erscheint nirgendwo!  Es wird in incr aufgerufen, weil es in der aufrufenden Funktion <i>nicht</i> aufgerufen wird.  Im Allgemeinen werden Preis und Nutzen ausgewogen sein. <br><br><h3>  Warnung Nr. 3: Zerstörerreihenfolge </h3><br>  Der Destruktor für einen Parameter mit einem trivialen ABI wird von der aufgerufenen Funktion aufgerufen und nicht von der aufrufenden (Warnung Nr. 2).  Richard Smith weist darauf hin, dass dies bedeutet, dass er nicht in der Reihenfolge aufgerufen wird, in der sich die Destruktoren der anderen Parameter befinden. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alpha</span></span></span><span class="hljs-class"> {</span></span> alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha constructed"</span></span>); } ~alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha destroyed"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">beta</span></span></span><span class="hljs-class"> {</span></span> beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta constructed"</span></span>); } ~beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta destroyed"</span></span>); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alpha, beta)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foo(alpha{}, beta{}); }</code> </pre> <br>  Dieser Code druckt: <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed alpha destroyed beta destroyed</code> </pre> <br>  Wenn TRIVIAL_ABI als [[clang :: trivial_abi]] definiert ist, wird Folgendes ausgegeben: <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed beta destroyed alpha destroyed</code> </pre> <br><h3>  Beziehung zu einem "trivial verschiebbaren" / "verschiebbaren" Objekt </h3><br>  Keine Beziehung ..., was? <br><br>  Wie Sie sehen, gibt es für die Klasse [[trivial_abi]] keine Anforderungen an eine bestimmte Semantik für einen sich bewegenden Konstruktor, Destruktor oder Standardkonstruktor.  Eine bestimmte Klasse ist wahrscheinlich trivial verlagerbar, einfach weil die meisten Klassen trivial verlagerbar sind. <br><br>  Wir können die Offset_ptr-Klasse einfach so machen, dass sie nicht trivial verschiebbar ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">offset_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span> value_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: offset_ptr(T *p) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)p - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} offset_ptr(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} <span class="hljs-function"><span class="hljs-function">T *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T *)((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + value_); } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) { value_ = ((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff) { value_ += (diff * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ offset_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; top = &amp;a[<span class="hljs-number"><span class="hljs-number">4</span></span>]; top = incr(top); assert(top.get() == &amp;a[<span class="hljs-number"><span class="hljs-number">5</span></span>]); }</code> </pre> <br>  <a href="">Hier ist der vollständige Code.</a> <br>  Wenn TRIVIAL_ABI definiert ist, besteht der Clang-Trunk diesen Test bei -O0 und -O1, aber bei -O2 (d. H. Sobald er versucht, Aufrufe an trivial_offset_ptr :: operator + = und den Kopierkonstruktor zu inline), stürzt er beim Assert ab. <br><br>  Also noch eine Warnung.  Wenn Ihr Typ mit diesem Zeiger etwas so Verrücktes macht, möchten Sie ihn wahrscheinlich nicht in Registern übergeben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bug 37319</a> , in der Tat eine Anfrage nach Dokumentation.  In diesem Fall stellt sich heraus, dass es keine Möglichkeit gibt, den Code so zu gestalten, wie es der Programmierer wünscht.  Wir sagen, dass der Wert von value_ vom Wert dieses Zeigers abhängen sollte, aber von der Grenze zwischen der aufrufenden und der aufgerufenen Funktion befindet sich das Objekt in Registern und der Zeiger darauf existiert nicht!  Daher schreibt die aufrufende Funktion es in den Speicher und übergibt diesen Zeiger erneut. Wie sollte die aufgerufene Funktion den richtigen Wert berechnen, um ihn in value_ zu schreiben?  Vielleicht ist es besser zu fragen, wie es überhaupt bei -O0 funktioniert?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Code sollte überhaupt nicht funktionieren.</a> <br><br>  Wenn Sie also [[trivial_abi]] verwenden möchten, sollten Sie Mitgliedsfunktionen (nicht nur spezielle, sondern generell) vermeiden, die stark von der eigenen Adresse des Objekts abhängen (mit einer undefinierten Bedeutung des Wortes "wesentlich"). <br><br>  Wenn eine Klasse als [[trivial_abi]] markiert ist und Sie eine Kopie erwarten, können Sie intuitiv copy plus memcpy erhalten.  Und in ähnlicher Weise können Sie, wenn Sie einen Umzug erwarten, den Umzug plus memcpy erhalten. <br><br>  Wenn ein Typ "trivial verschiebbar" ist (wie von mir in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Now definiert</a> ), können Sie immer dann, wenn Sie mit Kopieren und Zerstören rechnen, tatsächlich memcpy erhalten.  Und wenn Sie Vertreibung und Zerstörung erwarten, können Sie tatsächlich Memcpy bekommen.  Tatsächlich gehen Aufrufe von Sonderfunktionen verloren, wenn wir von „trivialer Verlagerung“ sprechen, aber wenn die Klasse das Attribut [[trivial_abi]] von Clang hat, gehen Aufrufe nicht verloren.  Sie erhalten nur (sozusagen) memcpy zusätzlich zu den erwarteten Anrufen.  Diese Art von Memcpy ist der Preis, den Sie für eine schnellere Anrufregisterkonvention zahlen. <br><br><h3>  Links zur weiteren Lektüre: </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Akira Hatanakas cfe-dev Thread vom November 2017</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Clang-Dokumentation</a> <br>  <a href="">Die Einheit testet auf trivial_abi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler 37319: trivial_offset_ptr kann unmöglich funktionieren</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468759/">https://habr.com/ru/post/de468759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468741/index.html">Internet in der Smart City</a></li>
<li><a href="../de468747/index.html">Wie ich den Sommer auf VK verbracht habe</a></li>
<li><a href="../de468749/index.html">Android LiveData-Ereignisse</a></li>
<li><a href="../de468753/index.html">Farbenblind - Freund des Menschen (Gesundheitsministerium ist nicht richtig)</a></li>
<li><a href="../de468757/index.html">MySQL-Verbindung nach Fehler 1040: zu viele Verbindungen</a></li>
<li><a href="../de468761/index.html">Problemlösung mit pwnable.kr 24 - einfaches Login. Stapelrahmenüberlagerung</a></li>
<li><a href="../de468765/index.html">Die Wichtigkeit der Bestätigung von Steuerbefehlen am Beispiel von Delimobile</a></li>
<li><a href="../de468767/index.html">Holzspielzeug, Teil zwei - 1986-1988</a></li>
<li><a href="../de468769/index.html">Xavier Noria auf Rails 6, Beratung und mehr</a></li>
<li><a href="../de468773/index.html">Das indische Energieunternehmen NTPC baut einen 5.000-Megawatt-Solarpark</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>