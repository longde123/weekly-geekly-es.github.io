<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨ÜÔ∏è üë©üèø‚Äçüöí üëçüèª √úber trivial_abi in Clang üöµüèΩ üèø üë¶üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schlie√ülich schrieb ich einen Beitrag √ºber [[trivial_abi]]! 

 Dies ist eine neue propriet√§re Funktion im Clang-Trunk, die ab Februar 2018 neu ist. Di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úber trivial_abi in Clang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468759/">  Schlie√ülich schrieb ich einen Beitrag √ºber [[trivial_abi]]! <br><br>  Dies ist eine neue propriet√§re Funktion im Clang-Trunk, die ab Februar 2018 neu ist. Dies ist eine Herstellererweiterung der C ++ - Sprache, es handelt sich nicht um Standard-C ++, es wird vom GCC-Trunk nicht unterst√ºtzt, und es gibt meines Wissens keine aktiven Vorschl√§ge von WG21, sie in den C ++ - Standard aufzunehmen. <br><br><img src="https://habrastorage.org/webt/ie/do/9e/iedo9ep8gzdeliscehwljy0clnq.jpeg"><br><br>  Ich habe an der Implementierung dieser Funktion nicht teilgenommen.  Ich habe mir nur die Patches auf der Mailingliste von cfe-commit angesehen und mir schweigend applaudiert.  Aber das ist so eine coole Funktion, dass ich denke, jeder sollte davon wissen. <br><a name="habracut"></a><br>  Als erstes beginnen wir also: Dies ist kein Standardattribut, und der Clang-Trunk unterst√ºtzt nicht die Standardschreibweise des Attributs [[trivial_abi]].  Stattdessen sollten Sie es im alten Stil schreiben, wie unten gezeigt: <br><br><pre><code class="cpp hljs">__attribute__((trivial_abi)) __attribute__((__trivial_abi__)) [[clang::trivial_abi]]</code> </pre> <br>  Und da dies ein Attribut ist, ist der Compiler sehr w√§hlerisch, wo Sie es einf√ºgen, und stillschweigend aggressiv, wenn Sie es an der falschen Stelle einf√ºgen (da nicht erkannte Attribute einfach ohne Nachrichten ignoriert werden).  Dies ist kein Fehler, dies ist eine Funktion.  Die richtige Syntax lautet: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) class TRIVIAL_ABI Widget { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ... };</span></span></span></span></code> </pre> <br><br><h3>  Welches Problem l√∂st das? </h3><br><br>  Erinnerst du dich an meinen Beitrag vom 17.04.2008, in dem ich zwei Versionen der Klasse gezeigt habe? <br><br><blockquote>  Hinweis  perev: Da der Beitrag vom 17.04.2008 ein kleines Volumen hat, habe ich ihn nicht separat ver√∂ffentlicht, sondern direkt hier unter dem Spoiler eingef√ºgt. <br></blockquote><div class="spoiler">  <b class="spoiler_title">Beitrag vom 17.04.2008</b> <div class="spoiler_text"><h3>  Nachteile eines fehlenden Trivial Destructor Call </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Siehe die C ++ Standard-Angebots-Mailingliste.</a>  Welche der beiden Funktionen, foo oder bar, hat den besten vom Compiler generierten Code? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Integer() {} <span class="hljs-comment"><span class="hljs-comment">// deliberately non-trivial }; void foo(std::vector&lt;int&gt;&amp; v) { v.back() *= 0xDEADBEEF; v.pop_back(); } void bar(std::vector&lt;Integer&gt;&amp; v) { v.back().value *= 0xDEADBEEF; v.pop_back(); }</span></span></code> </pre><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kompilieren</a> mit GCC und libstdc ++.  Ratet mal, richtig? <br><br><pre> <code class="cpp hljs">foo: movq <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi), %rax imull $<span class="hljs-number"><span class="hljs-number">-559038737</span></span>, <span class="hljs-number"><span class="hljs-number">-4</span></span>(%rax), %edx subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, %rax movl %edx, (%rax) movq %rax, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret bar: subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret</code> </pre> <br><br>  Folgendes passiert hier: GCC ist intelligent genug, um zu verstehen, dass beim Starten eines Destruktors f√ºr einen Speicherbereich seine Lebensdauer endet und alle vorherigen Eintr√§ge in diesen Speicherbereich "tot" sind.  GCC ist aber auch klug genug zu verstehen, dass ein trivialer Destruktor (wie der Pseudo-Destruktor ~ int ()) nichts tut und keine Effekte erzeugt. <br><br>  Die Balkenfunktion ruft also pop_back auf, das ~ Integer () ausf√ºhrt, wodurch vec.back () tot ist, und GCC entfernt die Multiplikation mit 0xDEADBEEF vollst√§ndig. <br><br>  Auf der anderen Seite ruft foo pop_back auf, wodurch der Pseudo-Destruktor ~ int () gestartet wird (der Aufruf kann vollst√§ndig √ºbersprungen werden, aber nicht). GCC erkennt, dass er leer ist, und vergisst ihn.  Daher sieht GCC nicht, dass vec.back () tot ist, und entfernt die Multiplikation mit 0xDEADBEEF nicht. <br><br>  Dies geschieht f√ºr einen trivialen Destruktor, jedoch nicht f√ºr einen Pseudo-Destruktor wie ~ int ().  Ersetzen Sie unsere ~ Integer () {} durch ~ Integer () = default;  und sehen Sie, wie die imull Anweisung wieder erschien! <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Foo() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// trivial }; struct Bar { int value; ~Bar() {} // deliberately non-trivial };</span></span></code> </pre> <br>  In diesem Beitrag wird der Code angegeben, in dem der Compiler Code f√ºr Foo schlechter als f√ºr Bar generiert hat.  Es lohnt sich zu diskutieren, warum dies unerwartet war.  Programmierer erwarten intuitiv, dass "trivialer" Code besser ist als "nichttrivialer" Code.  Dies ist in den meisten Situationen der Fall.  Dies ist insbesondere dann der Fall, wenn wir einen Funktionsaufruf durchf√ºhren oder zur√ºckkehren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">incr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class">) {</span></span> obj.value += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; }</code> </pre> <br>  incr wird mit folgendem Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kompiliert</a> : <br><br><pre> <code class="cpp hljs">leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %eax retq</code> </pre> <br>  (leal ist der x86- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Befehl</a> , der "add" bedeutet.) Wir sehen, dass unser 4-Byte-Objekt im% edi-Register an incr √ºbergeben wird, und wir addieren 1 zu seinem Wert und geben ihn an% eax zur√ºck.  Vier Bytes am Eingang, vier Bytes am Ausgang, einfach und unkompliziert. <br><br>  Schauen wir uns nun incr an (der Fall mit einem nicht trivialen Destruktor). <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rsi) movl %eax, (%rdi) movq %rdi, %rax retq</code> </pre> <br>  Hier wird obj nicht im Register √ºbergeben, obwohl hier die gleichen 4 Bytes mit der gleichen Semantik sind.  Hier wird obj √ºbergeben und an die Adresse zur√ºckgegeben.  Hier reserviert der Aufrufer etwas Platz f√ºr den R√ºckgabewert und √ºbergibt uns einen Zeiger auf diesen Platz in rdi, und der Aufrufer gibt uns einen Zeiger f√ºr den R√ºckgabewert obj im n√§chsten Argumentregister% rsi.  Wir extrahieren den Wert aus (% rsi), addieren 1, speichern ihn zur√ºck in (% rsi), um den Wert von obj selbst zu aktualisieren, und kopieren dann (trivial) 4 Bytes von obj in den Steckplatz f√ºr den R√ºckgabewert, auf den% rdi zeigt.  Schlie√ülich kopieren wir den vom Aufrufer √ºbergebenen urspr√ºnglichen Zeiger von% rdi nach% rax, da das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">x86-64-ABI-</a> Dokument (S. 22) uns dazu auffordert. <br><br>  Der Grund, warum Bar so anders ist als Foo, ist, dass Bar einen nicht trivialen Destruktor hat und der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">x86-64 ABI</a> (S. 19) speziell angibt: <br><br><blockquote>  Wenn ein C ++ - Objekt einen nichttrivialen Kopierkonstruktor oder einen nichttrivialen Destruktor hat, wird es √ºber einen unsichtbaren Link √ºbergeben (das Objekt wird in der Parameterliste durch einen Zeiger [...] ersetzt). </blockquote><br>  Ein sp√§teres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Itanium C ++ ABI-</a> Dokument definiert Folgendes: <br><blockquote>  Wenn der Parametertyp f√ºr den Zweck des Aufrufs nicht trivial ist, muss der Anrufer einen tempor√§ren Ort zuweisen und einen Link zu diesem tempor√§ren Ort √ºbergeben: <br>  [...] <br>  Ein Typ wird f√ºr den Zweck des Aufrufs als nicht trivial betrachtet, wenn: <br><br>  Es verf√ºgt √ºber einen nichttrivialen Kopierkonstruktor, einen sich bewegenden Konstruktor, einen Destruktor oder alle seine Verschiebungs- und Kopierkonstruktoren werden gel√∂scht. </blockquote><br>  Das erkl√§rt also alles: Bar hat eine schlechtere Codegenerierung, weil sie √ºber einen unsichtbaren Link geleitet wird.  Es wird √ºber eine unsichtbare Verbindung √ºbertragen, da eine ungl√ºckliche Kombination zweier unabh√§ngiger Umst√§nde eingetreten ist: <br><ul><li>  Laut ABI-Dokument werden Objekte mit nicht trivialem Destruktor √ºber unsichtbare Links weitergeleitet </li><li>  Bar hat einen nicht trivialen Destruktor. </li></ul><br>  Dies ist ein klassischer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Syllogismus</a> : Der erste Punkt ist die Hauptpr√§misse, der zweite ist privat.  Infolgedessen wird Bar √ºber eine unsichtbare Verbindung √ºbertragen. <br><br>  Lassen Sie uns einen Syllogismus geben: <br><ul><li>  Alle Menschen sind sterblich </li><li>  Sokrates ist ein Mann. </li><li>  Folglich ist Sokrates sterblich. </li></ul><br><br>  Wenn wir die Schlussfolgerung ‚ÄûSokrates ist sterblich‚Äú widerlegen wollen, m√ºssen wir eine der Pr√§missen widerlegen: entweder um die Hauptsache zu widerlegen (vielleicht sind einige Menschen nicht sterblich) oder um das Private zu widerlegen (vielleicht ist Sokrates keine Person). <br><br>  Damit Bar in ein Register (wie Foo) aufgenommen werden kann, m√ºssen wir eine von zwei Pr√§missen widerlegen.  Der Standard-C ++ - Pfad besteht darin, Bar einen trivialen Destruktor zu geben, der die private Pr√§misse zerst√∂rt.  Aber es gibt noch einen anderen Weg! <br><br><h3>  Wie [[trivial_abi]] das Problem l√∂st </h3><br>  Das neue Clang-Attribut zerst√∂rt die Hauptpr√§misse.  Clang erweitert das ABI-Dokument wie folgt: <br><blockquote>  Wenn der Parametertyp f√ºr den Zweck des Aufrufs nicht trivial ist, muss der Anrufer einen tempor√§ren Ort zuweisen und einen Link zu diesem tempor√§ren Ort √ºbergeben: <br>  [...] <br>  Ein Typ wird f√ºr den Zweck des Aufrufs als nicht trivial betrachtet, wenn er als [[trivial_abi]] markiert ist und: <br>  Es verf√ºgt √ºber einen nichttrivialen Kopierkonstruktor, einen sich bewegenden Konstruktor, einen Destruktor oder alle seine Verschiebungs- und Kopierkonstruktoren werden gel√∂scht. <br></blockquote><br>  Selbst wenn eine Klasse mit einem nichttrivial bewegten Konstruktor oder Destruktor f√ºr den Zweck des Aufrufs als trivial betrachtet werden kann, wenn sie als [[trivial_abi]] markiert ist. <br><br>  Mit Clang k√∂nnen wir jetzt folgenderma√üen schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) struct TRIVIAL_ABI Baz { int value; ~Baz() {} </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// deliberately non-trivial };</span></span></span></span></code> </pre> <br>  Kompilieren Sie incr &lt;Baz&gt; und erhalten Sie den gleichen Code wie incr &lt;Foo&gt;! <br><h3>  Warnung Nr. 1: [[trivial_abi]] macht manchmal nichts </h3><br>  Ich w√ºrde hoffen, dass wir Wrapper f√ºr Standardbibliothekstypen wie folgt "trivial f√ºr Aufrufzwecke" machen k√∂nnen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trivial_unique_ptr</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt;::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>; };</code> </pre> <br>  Leider funktioniert das nicht.  Wenn Ihre Klasse √ºber Basisklassen oder nicht statische Felder verf√ºgt, die f√ºr den Zweck des Aufrufs "nicht trivial" sind, macht die Clang-Erweiterung in der Form, in der sie jetzt geschrieben ist, Ihre Klasse "irreversibel nicht trivial", und das Attribut hat keine Auswirkung.  (Es werden keine Diagnosemeldungen ausgegeben. Dies bedeutet, dass Sie [[trivial_abi]] in der Klassenvorlage als optionales Attribut verwenden k√∂nnen und die Klasse "bedingt trivial" ist, was manchmal n√ºtzlich ist. Der Nachteil ist nat√ºrlich, dass Sie dies k√∂nnen Markieren Sie die Klasse als trivial und stellen Sie dann fest, dass der Compiler sie leise behoben hat.) <br><br>  Das Attribut wird ohne Nachrichten ignoriert, wenn Ihre Klasse √ºber eine virtuelle Basisklasse oder virtuelle Funktionen verf√ºgt.  In diesen F√§llen passt es m√∂glicherweise nicht in die Register, und ich wei√ü nicht, was Sie erhalten m√∂chten, indem Sie es als Wert √ºbergeben, aber Sie wissen es wahrscheinlich. <br><br>  Soweit ich wei√ü, ist die einzige M√∂glichkeit, TRIVIAL_ABI f√ºr ‚ÄûStandard-Utility-Typen‚Äú wie optional &lt;T&gt;, unique_ptr &lt;T&gt; und shared_ptr &lt;T&gt; zu verwenden, die <br><ul><li>  Implementieren Sie sie selbst von Grund auf neu und wenden Sie das Attribut an, oder </li><li>  Brechen Sie in Ihre lokale Kopie von libc ++ ein und f√ºgen Sie das Attribut dort mit Ihren H√§nden ein </li></ul><br>  (In der Open Source-Welt sind beide Methoden im Wesentlichen gleich.) <br><br><h3>  Warnung Nr. 2: Verantwortung des Zerst√∂rers </h3><br>  Im Beispiel mit Foo / Bar hat die Klasse einen leeren Destruktor.  Lassen Sie unsere Klasse tats√§chlich einen nichttrivialen Destruktor haben. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Up1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; Up1(Up1&amp;&amp; u) : value(u.value) { u.value = <span class="hljs-number"><span class="hljs-number">0</span></span>; } ~Up1() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"destroyed"</span></span>); } };</code> </pre> <br>  Dies sollte Ihnen bekannt sein. Dies ist unique_ptr &lt;int&gt;, bis zum Limit vereinfacht, wobei die Nachricht beim L√∂schen gedruckt wird. <br><br>  Ohne TRIVIAL_ABI sieht Inkr &lt;Up1&gt; wie Inkr &lt;Bar&gt; aus: <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rdi) movl $<span class="hljs-number"><span class="hljs-number">0</span></span>, (%rsi) movq %rdi, %rax retq</code> </pre> <br><br>  Mit TRIVIAL_ABI sieht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inkr gr√∂√üer und be√§ngstigender aus</a> ! <br><br><pre> <code class="cpp hljs">pushq %rbx leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %ebx movl $.L.str, %edi callq <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span> movl %ebx, %eax popq %rbx retq</code> </pre> <br><br>  In der traditionellen Aufrufkonvention werden Typen mit einem nicht trivialen Destruktor immer von einer unsichtbaren Verkn√ºpfung √ºbergeben, was bedeutet, dass die empfangende Seite (in diesem Fall inkr) immer einen Zeiger auf ein Parameterobjekt akzeptiert, ohne dieses Objekt zu besitzen.  Das Objekt geh√∂rt dem Anrufer. Dadurch funktioniert die Elisionsarbeit! <br><br>  Wenn ein Typ mit [[trivial_abi]] in Registern √ºbergeben wird, erstellen wir im Wesentlichen eine Kopie des Parameterobjekts. <br><br>  Da x86-64 nur ein Register zur√ºckgeben kann (Applaus), kann die aufgerufene Funktion das Objekt am Ende nicht zur√ºckgeben.  Die aufgerufene Funktion sollte das Eigentum an dem Objekt √ºbernehmen, das wir an sie √ºbergeben haben!  Dies bedeutet, dass die aufgerufene Funktion den Destruktor des Parameterobjekts aufrufen muss, wenn es beendet ist. <br><br>  In unserem vorherigen Beispiel, Foo / Bar / Baz, hei√üt der Destruktor, aber er war leer und wir haben es nicht bemerkt.  In Inkr &lt;Up2&gt; sehen wir nun zus√§tzlichen Code, der vom Destruktor auf der Seite der aufgerufenen Funktion generiert wird. <br><br>  Es kann davon ausgegangen werden, dass dieser zus√§tzliche Code in einigen Benutzerf√§llen generiert wird.  Im Gegenteil, der Ruf des Zerst√∂rers erscheint nirgendwo!  Es wird in incr aufgerufen, weil es in der aufrufenden Funktion <i>nicht</i> aufgerufen wird.  Im Allgemeinen werden Preis und Nutzen ausgewogen sein. <br><br><h3>  Warnung Nr. 3: Zerst√∂rerreihenfolge </h3><br>  Der Destruktor f√ºr einen Parameter mit einem trivialen ABI wird von der aufgerufenen Funktion aufgerufen und nicht von der aufrufenden (Warnung Nr. 2).  Richard Smith weist darauf hin, dass dies bedeutet, dass er nicht in der Reihenfolge aufgerufen wird, in der sich die Destruktoren der anderen Parameter befinden. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alpha</span></span></span><span class="hljs-class"> {</span></span> alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha constructed"</span></span>); } ~alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha destroyed"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">beta</span></span></span><span class="hljs-class"> {</span></span> beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta constructed"</span></span>); } ~beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta destroyed"</span></span>); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alpha, beta)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foo(alpha{}, beta{}); }</code> </pre> <br>  Dieser Code druckt: <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed alpha destroyed beta destroyed</code> </pre> <br>  Wenn TRIVIAL_ABI als [[clang :: trivial_abi]] definiert ist, wird Folgendes ausgegeben: <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed beta destroyed alpha destroyed</code> </pre> <br><h3>  Beziehung zu einem "trivial verschiebbaren" / "verschiebbaren" Objekt </h3><br>  Keine Beziehung ..., was? <br><br>  Wie Sie sehen, gibt es f√ºr die Klasse [[trivial_abi]] keine Anforderungen an eine bestimmte Semantik f√ºr einen sich bewegenden Konstruktor, Destruktor oder Standardkonstruktor.  Eine bestimmte Klasse ist wahrscheinlich trivial verlagerbar, einfach weil die meisten Klassen trivial verlagerbar sind. <br><br>  Wir k√∂nnen die Offset_ptr-Klasse einfach so machen, dass sie nicht trivial verschiebbar ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">offset_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span> value_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: offset_ptr(T *p) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)p - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} offset_ptr(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} <span class="hljs-function"><span class="hljs-function">T *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T *)((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + value_); } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) { value_ = ((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff) { value_ += (diff * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ offset_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; top = &amp;a[<span class="hljs-number"><span class="hljs-number">4</span></span>]; top = incr(top); assert(top.get() == &amp;a[<span class="hljs-number"><span class="hljs-number">5</span></span>]); }</code> </pre> <br>  <a href="">Hier ist der vollst√§ndige Code.</a> <br>  Wenn TRIVIAL_ABI definiert ist, besteht der Clang-Trunk diesen Test bei -O0 und -O1, aber bei -O2 (d. H. Sobald er versucht, Aufrufe an trivial_offset_ptr :: operator + = und den Kopierkonstruktor zu inline), st√ºrzt er beim Assert ab. <br><br>  Also noch eine Warnung.  Wenn Ihr Typ mit diesem Zeiger etwas so Verr√ºcktes macht, m√∂chten Sie ihn wahrscheinlich nicht in Registern √ºbergeben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bug 37319</a> , in der Tat eine Anfrage nach Dokumentation.  In diesem Fall stellt sich heraus, dass es keine M√∂glichkeit gibt, den Code so zu gestalten, wie es der Programmierer w√ºnscht.  Wir sagen, dass der Wert von value_ vom Wert dieses Zeigers abh√§ngen sollte, aber von der Grenze zwischen der aufrufenden und der aufgerufenen Funktion befindet sich das Objekt in Registern und der Zeiger darauf existiert nicht!  Daher schreibt die aufrufende Funktion es in den Speicher und √ºbergibt diesen Zeiger erneut. Wie sollte die aufgerufene Funktion den richtigen Wert berechnen, um ihn in value_ zu schreiben?  Vielleicht ist es besser zu fragen, wie es √ºberhaupt bei -O0 funktioniert?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Code sollte √ºberhaupt nicht funktionieren.</a> <br><br>  Wenn Sie also [[trivial_abi]] verwenden m√∂chten, sollten Sie Mitgliedsfunktionen (nicht nur spezielle, sondern generell) vermeiden, die stark von der eigenen Adresse des Objekts abh√§ngen (mit einer undefinierten Bedeutung des Wortes "wesentlich"). <br><br>  Wenn eine Klasse als [[trivial_abi]] markiert ist und Sie eine Kopie erwarten, k√∂nnen Sie intuitiv copy plus memcpy erhalten.  Und in √§hnlicher Weise k√∂nnen Sie, wenn Sie einen Umzug erwarten, den Umzug plus memcpy erhalten. <br><br>  Wenn ein Typ "trivial verschiebbar" ist (wie von mir in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Now definiert</a> ), k√∂nnen Sie immer dann, wenn Sie mit Kopieren und Zerst√∂ren rechnen, tats√§chlich memcpy erhalten.  Und wenn Sie Vertreibung und Zerst√∂rung erwarten, k√∂nnen Sie tats√§chlich Memcpy bekommen.  Tats√§chlich gehen Aufrufe von Sonderfunktionen verloren, wenn wir von ‚Äûtrivialer Verlagerung‚Äú sprechen, aber wenn die Klasse das Attribut [[trivial_abi]] von Clang hat, gehen Aufrufe nicht verloren.  Sie erhalten nur (sozusagen) memcpy zus√§tzlich zu den erwarteten Anrufen.  Diese Art von Memcpy ist der Preis, den Sie f√ºr eine schnellere Anrufregisterkonvention zahlen. <br><br><h3>  Links zur weiteren Lekt√ºre: </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Akira Hatanakas cfe-dev Thread vom November 2017</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Clang-Dokumentation</a> <br>  <a href="">Die Einheit testet auf trivial_abi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler 37319: trivial_offset_ptr kann unm√∂glich funktionieren</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468759/">https://habr.com/ru/post/de468759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468741/index.html">Internet in der Smart City</a></li>
<li><a href="../de468747/index.html">Wie ich den Sommer auf VK verbracht habe</a></li>
<li><a href="../de468749/index.html">Android LiveData-Ereignisse</a></li>
<li><a href="../de468753/index.html">Farbenblind - Freund des Menschen (Gesundheitsministerium ist nicht richtig)</a></li>
<li><a href="../de468757/index.html">MySQL-Verbindung nach Fehler 1040: zu viele Verbindungen</a></li>
<li><a href="../de468761/index.html">Probleml√∂sung mit pwnable.kr 24 - einfaches Login. Stapelrahmen√ºberlagerung</a></li>
<li><a href="../de468765/index.html">Die Wichtigkeit der Best√§tigung von Steuerbefehlen am Beispiel von Delimobile</a></li>
<li><a href="../de468767/index.html">Holzspielzeug, Teil zwei - 1986-1988</a></li>
<li><a href="../de468769/index.html">Xavier Noria auf Rails 6, Beratung und mehr</a></li>
<li><a href="../de468773/index.html">Das indische Energieunternehmen NTPC baut einen 5.000-Megawatt-Solarpark</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>