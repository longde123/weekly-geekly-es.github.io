<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏿 🛴 🔯 Kaskadierende Cache-Ungültigmachung. Teil 2 👐🏿 🏰 👩🏼‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil der Übersetzung von Material, das sich mit der kaskadierenden Ungültigmachung des Caches befasst, haben wir die Art des Problems erörte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kaskadierende Cache-Ungültigmachung. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/472862/">  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil der</a> Übersetzung von Material, das sich mit der kaskadierenden Ungültigmachung des Caches befasst, haben wir die Art des Problems erörtert und eine der Möglichkeiten zur Lösung des Problems in Betracht gezogen, nämlich die Verwendung von Importkarten.  Das Plus ist die einfache Implementierung.  Und Minus - schlechte Browserunterstützung.  Heute werden wir über andere Möglichkeiten zur Lösung dieses Problems sprechen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ft/lh/jx/ftlhjxkkxoeswh7akykdb6fcfoq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ansatz 2: Servicemitarbeiter</font> </h2><br>  Die zweite Lösung des Problems besteht darin, die Funktionalität von Importkarten mithilfe eines Servicemitarbeiters zu reproduzieren. <br><br>  Mithilfe eines Servicemitarbeiters können Sie beispielsweise Abrufereignisse abhören, die darauf abzielen, Materialien an Adressen zu laden, die den Schlüsseln der Importkarte entsprechen.  Durch Ausführen dieser Anforderungen können Sie Dateien hochladen, deren Namen Hashes ihres Inhalts enthalten: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> importMap = {  <span class="hljs-string"><span class="hljs-string">'/main.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/main-1a2b.mjs'</span></span>,  <span class="hljs-string"><span class="hljs-string">'/dep1.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep1-b2c3.mjs'</span></span>,  <span class="hljs-string"><span class="hljs-string">'/dep2.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep2-3c4d.mjs'</span></span>,  <span class="hljs-string"><span class="hljs-string">'/dep3.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep3-d4e5.mjs'</span></span>,  <span class="hljs-string"><span class="hljs-string">'/vendor.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/vendor-5e6f.mjs'</span></span>, }; addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, (event) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oldPath = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(event.request.url, location).pathname;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (importMap.hasOwnProperty(oldPath)) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newPath = importMap[oldPath];    event.respondWith(fetch(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(newPath, event.request)));  } });</code> </pre> <br>  Unter Berücksichtigung der Tatsache, dass der Service Worker-Code oben angegeben ist, müssen Sie jedoch verstehen, dass dieser Code erst funktioniert, nachdem der Service Worker installiert und aktiviert wurde.  Dies bedeutet, dass beim ersten Laden der Site Dateien angefordert werden, deren Namen keine Hashes enthalten.  Dateien mit Hashes in den Namen werden bei nachfolgenden Site-Downloads angefordert.  Mit anderen Worten, hier geht es um das doppelte Laden jeder Datei. <br><br>  Wenn Sie dies berücksichtigen, scheint der Service Worker keine geeignete Lösung für das Problem der Kaskadierung der Cache-Ungültigkeit zu sein. <br><br>  Hier möchte ich Sie jedoch bitten, mir zu erlauben, langjährige Ansätze zum Caching kurz zu kritisieren.  Lassen Sie uns darüber nachdenken, was passiert, wenn wir keine Content-Hashes mehr in den Dateinamen verwenden, anstatt die Hash-Informationen in den Service Worker-Code einzufügen. <br><br>  So funktionieren Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Workbox</a> , mit denen Ressourcen vorab zwischengespeichert werden.  Sie generieren Hashes des Inhalts jeder Datei aus der Assembly und speichern die Entsprechung der Dateinamen im Servicemitarbeiter (es stellt sich heraus, dass es sich um eine externe Importkarte handelt).  Darüber hinaus zwischenspeichern sie Ressourcen während der ersten Installation eines Service Workers und fügen Listener für Abrufereignisse hinzu, die zwischengespeicherte Dateien als Antwort auf Anforderungen zurückgeben, deren Adressen denen in der Importzuordnung entsprechen. <br><br>  Obwohl die Idee, dass der Client Dateien empfängt, die keine Informationen über die Versionen ihres Inhalts enthalten, beängstigend erscheint (und allem widerspricht, was Ihnen beigebracht wurde), wird die Anforderung zum Herunterladen der entsprechenden Ressource nur ausgeführt, wenn der Service Worker installiert ist.  Weitere Anforderungen zum Herunterladen einer solchen Ressource werden über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Cache-Speicher-API</a> (die keine Caching-Header verwendet) ausgeführt. Neue Anforderungen an den Server werden nur ausgeführt, wenn eine neue Version des Service Workers bereitgestellt wird (und Sie ohnehin eine neue Version dieser Dateien benötigen). <br><br>  Bis Sie mit der Bereitstellung neuer Versionen von Modulen beginnen, ohne den Service Worker zu aktualisieren (und dies wird definitiv nicht empfohlen), werden Sie daher niemals auf einen Konflikt oder eine Versionsinkongruenz stoßen. <br><br>  Um das vorläufige Zwischenspeichern von Dateien mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Workbox-Precaching-Bibliothek zu organisieren, können</a> Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateiadressen</a> und Zeichenfolgen mit den Versionsinformationen dieser Dateien an die Bibliotheksmethode <code>precacheAndRoute()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {preacacheAndRoute} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'workbox-precaching'</span></span>; precacheAndRoute([  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/main.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'1a2b'</span></span>},  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep1.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'b2c3'</span></span>},  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep2.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'3c4d'</span></span>},  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep3.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'d4e5'</span></span>},  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/vendor.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'5e6f'</span></span>}, ]);</code> </pre> <br>  Wie genau Zeilen mit Versionen generiert werden, ist Sache des Entwicklers.  Wenn er sie jedoch nicht selbst erstellen möchte, vereinfacht die Erstellung eines Pre-Cache-Manifests die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Workbox-Build-</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Workbox-Cli-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Workbox-Webpack-Plugin-Pakete</a> (sie können sogar den gesamten Service Worker-Code generieren). <br><br>  Mein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-</a> Projekt enthält ein Beispiel für die Implementierung des vorläufigen Caching mithilfe eines Servicemitarbeiters in einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rollup-Anwendung</a> (mithilfe von <code>workbox-cli</code> ) und in einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webpack-Anwendung</a> (mithilfe von <code>workbox-webpack-plugin</code> ). <br><br><h2>  <font color="#3AC1EF">Ansatz 3: Benutzerdefinierte Skripte zum Laden von Ressourcen</font> </h2><br>  Wenn Ihre Site weder Importkarten noch Servicemitarbeiter verwenden kann, finden Sie hier den dritten Ansatz zur Lösung des Problems.  Es besteht darin, die Funktionalität des Importierens von Karten mithilfe eines eigenen Skripts zum Laden von Ressourcen zu implementieren. <br><br>  Wenn Sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modulladern im</a> AMD-Stil (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SystemJS</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RequireJS</a> ) vertraut sind, wissen Sie möglicherweise auch, dass diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modullader normalerweise Modulaliasnamen</a> unterstützen.  Tatsächlich <a href="">unterstützt</a> SystemJS Aliasing mithilfe der Importzuordnungssyntax.  Infolgedessen lässt sich unser Problem leicht so lösen, dass diese Lösung zukunftsorientiert ist (und außerdem in allen vorhandenen Browsern funktioniert). <br><br>  Wenn Sie Rollup verwenden, können Sie die Option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">output.format</a> auf <code>system</code> .  In diesem Fall wird das Erstellen einer Importzuordnung für die Anwendung auf die gleiche Weise durchgeführt, wie in der Beschreibung des ersten Ansatzes zur Lösung des Problems der kaskadierenden Cache-Ungültigkeit beschrieben. <br><br>  Meine Demoanwendung verfügt über eine Beispielsite, auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rollup</a> zum Erstellen von Materialien in einem für SystemJS geeigneten Format und zum Erstellen einer Importzuordnung zum Herunterladen von Hash-Versionen von Dateien verwendet wird. <br><br><h3>  <font color="#3AC1EF">▍Webpacken und Laden von Ressourcen mithilfe von Skripten</font> </h3><br>  Webpack kann Ihnen auch beim Laden von Ressourcen mithilfe Ihres eigenen Skripts helfen. Der von Webpack generierte Loader ist jedoch im Gegensatz zu den klassischen AMD-Loadern für jedes spezifische Bundle einzigartig. <br><br>  Der Vorteil dieses Ansatzes besteht darin, dass die Webpack-Laufzeit (und damit funktioniert sie tatsächlich) eigene Zuordnungen zwischen den Namen / Bezeichnern der Fragmente und ihren Adressen enthalten kann (dies ähnelt dem, was ich hier empfehle).  Dies bedeutet, dass Webpack-Bundles, die Codeaufteilung verwenden, weniger wahrscheinlich eine kaskadierende Cache-Ungültigkeit erleiden. <br><br>  Die gute Nachricht für Webpack-Benutzer ist, dass eine Änderung des Codes eines einzelnen Moduls nicht zu einer Ungültigmachung führen sollte, wenn sie die Projektassembly mithilfe von Webpack korrekt konfiguriert haben (Aufteilen des Codes in Fragmente, wie im Webpack-Caching- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Handbuch beschrieben</a> ) mehr als zwei Fragmente (eines enthält das modifizierte Modul, das zweite enthält die Laufzeit). <br><br>  Aber ich habe einige schlechte Nachrichten für diejenigen, die Webpack verwenden, um Projekte zu erstellen.  Tatsache ist, dass das interne Mapping-System dieses Bundlers nicht dem Standard entspricht.  Dies bedeutet, dass es nicht in vorhandene Tools integriert werden kann und dass der Benutzer es nicht konfigurieren kann.  Sie können beispielsweise keine Ausgabedateien unabhängig generieren (dh wie in der Geschichte über den ersten Ansatz zur Lösung des Problems beschrieben) und keine eigenen Hashes in das Mapping einfügen.  Dies ist ein Minus des Webpacks, da die von diesem Bundler verwendeten Hashes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht auf dem Inhalt der Ausgabedateien</a> basieren, sondern auf dem Inhalt der Quelldateien und der Build-Konfiguration.  Und dies kann zu kleinen und subtilen Fehlern führen (zum Beispiel - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> - Meldungen über solche Fehler). <br><br>  Wenn Sie Webpack verwenden, um eine Anwendung zu erstellen, die auch einen Servicemitarbeiter verwendet, würde ich die Verwendung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Workbox-Webpack-Plugin-</a> und Caching-Strategie empfehlen, die im zweiten Ansatz zur Lösung des Problems beschrieben wurde.  Das Plugin generiert Hashes basierend auf dem Inhalt der Webpack-Ausgabe. Sie müssen sich also keine Gedanken über die oben genannten Fehler machen.  Darüber hinaus ist das Arbeiten mit Dateinamen ohne Hashes normalerweise einfacher als das Arbeiten mit Namen ohne Hashes. <br><br><h2>  <font color="#3AC1EF">Andere Webprojektressourcen</font> </h2><br>  Zuvor habe ich darüber gesprochen, wie die Arbeit in JavaScript-Programmen mit "gehashten" Dateinamen, die Programmcode enthalten, zu einer kaskadierenden Cache-Ungültigkeit führen kann.  Dieses Problem betrifft jedoch auch andere Webprojektmaterialien. <br><br>  Daher verweisen CSS- und SVG-Dateien häufig auf andere Ressourcen (z. B. Bilder), deren Namen Informationen zu den Versionen der entsprechenden Dateien in Form von Hashes enthalten können.  Wie bei JS-Dateien können Sie Importkarten oder Servicemitarbeiter verwenden, um das Problem der Kaskadierung der Cache-Ungültigkeit zu lösen, die durch Änderungen der Namen ähnlicher Ressourcen verursacht wird. <br><br>  Für Ressourcen wie Bilder und Videodateien ist dies kein Problem.  Hier gelten alle bestehenden Empfehlungen. <br><br>  Die Hauptsache hierbei ist, sich daran zu erinnern, dass immer dann, wenn Datei A Datei B herunterlädt und zusätzlich Informationen über die Version von Datei B als Hash ihres Inhalts enthält, die Ungültigmachung des Caches für Datei B auch eine Ungültigmachung des Caches für Datei A verursacht. Wenn Sie mit Ressourcen arbeiten, deren Verwendung unterschiedlich organisiert ist, können Sie die in diesem Material gegebenen Ratschläge einfach ignorieren. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Ich hoffe, dieser Artikel hat Sie dazu inspiriert, sich Ihre Website genauer anzusehen und herauszufinden, ob sich das Problem der kaskadierenden Cache-Ungültigkeit darauf auswirkt.  Der einfachste Weg, dies zu überprüfen, besteht darin, die Site zusammenzustellen, eine Codezeile in einer Datei zu ändern, die von vielen Modulen importiert wird, und dann die Site neu zu erstellen.  Wenn sich in dem Verzeichnis, in dem sich die Assembly-Ergebnisse befinden, die Namen für mehr als eine Datei geändert haben, bedeutet dies, dass Sie ein Zeichen für eine kaskadierende Cache-Ungültigkeit haben.  In diesem Fall müssen Sie möglicherweise über einen der hier beschriebenen Ansätze nachdenken, um dieses Problem in Ihrem Projekt zu lösen. <br><br>  Wenn wir darüber sprechen, was besser zu wählen ist, dann hängt es ehrlich gesagt von vielem ab. <br><br>  Wenn Importkarten von Browsern weitgehend unterstützt werden, haben wir die einfachste und perfekteste Möglichkeit, mit der Kaskadierung der Cache-Ungültigkeit umzugehen.  Bis eine solche Unterstützung verfügbar ist, ist dieser Mechanismus in der Praxis nicht anwendbar. <br><br>  Wenn Sie bereits Servicemitarbeiter einsetzen, insbesondere wenn Sie Workbox verwenden, würde ich den zweiten Ansatz zur Lösung des hier beschriebenen Problems empfehlen.  Auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Site,</a> auf der das Original dieses Materials veröffentlicht wird, wurde die Aufgabe des vorläufigen Zwischenspeicherns von Ressourcen auf diese Weise gelöst. <br><br>  Darüber hinaus sind Servicemitarbeiter die einzige Option für diejenigen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript-Module</a> in der Produktion verwenden.  (Angesichts der Tatsache, dass 98% meiner Benutzer Browser haben, die sowohl Servicemitarbeiter als auch JS-Module unterstützen, war es für mich nicht schwierig, diese Option zu wählen.) <br><br>  Wenn Servicemitarbeiter nicht für Sie geeignet sind, würde ich den dritten der hier diskutierten Ansätze empfehlen, der die Verwendung von SystemJS beinhaltet.  Dieser Ansatz ist besser als andere, basierend auf Bootloader-Skripten, die auf die Zukunft ausgerichtet sind.  Von dort aus können Sie problemlos zu Importkarten wechseln, wenn deren Unterstützung in allen Browsern angezeigt wird. <br><br>  Wenn wir über Produktivität sprechen, hängt die Wahl der Richtung der Optimierung von jedem spezifischen Projekt ab.  Vor der Optimierung der Leistung ist es wichtig, diese zu messen und dann zu entscheiden, ob ein Problem vorliegt und ob es bekämpft werden soll.  Wenn Sie selten neue Projektversionen veröffentlichen und die am Projekt vorgenommenen Änderungen normalerweise recht umfangreich sind, ist das Problem der Kaskadierung der Cache-Ungültigmachung für Sie möglicherweise nicht relevant. <br><br>  Wenn Sie jedoch häufig kleine Projektänderungen bereitstellen, können Ihre wiederkehrenden Benutzer auf das Problem stoßen, große Mengen an Code zu laden, die bereits in ihren Caches vorhanden sind.  Die Lösung dieses Problems bedeutet für diese Benutzer eine erhebliche Steigerung der Leistung beim Laden von Seiten. <br><br>  <b>Liebe Leser!</b>  Beeinflusst die kaskadierende Cache-Ungültigmachung Ihr Projekt?  Wenn ja, teilen Sie uns bitte mit, wie Sie das Problem lösen möchten. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472862/">https://habr.com/ru/post/de472862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472850/index.html">Beruf oder Leben: Gewinnen Sie einen Netologiekurs, wenn Sie keine Angst haben</a></li>
<li><a href="../de472852/index.html">GitLab nimmt Änderungen für Benutzer von Cloud- und kommerziellen Produkten vor</a></li>
<li><a href="../de472854/index.html">Unity UI Profiling: Wer verdirbt meine Stapelverarbeitung?</a></li>
<li><a href="../de472858/index.html">Python und schnelle HTTP-Clients</a></li>
<li><a href="../de472860/index.html">Kaskadierende Cache-Ungültigmachung. Teil 1</a></li>
<li><a href="../de472864/index.html">Prüfpunkt: CPU- und RAM-Optimierung</a></li>
<li><a href="../de472868/index.html">Verwaltung des Telefonservers: RUVDS Mobile Client</a></li>
<li><a href="../de472870/index.html">Warum Agile zum Stillstand kommt, ohne Architektur und Entwicklungstools zu verändern - Konferenzpräsentation</a></li>
<li><a href="../de472872/index.html">Wie man das Startup auf 50 Mitarbeiter erhöht, ohne die Kultur zu verlieren</a></li>
<li><a href="../de472876/index.html">Komplexität Wasserfall und Architektur auf Abruf</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>