<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüéì ü•ò üë≤üèΩ Visualizaci√≥n y optimizaci√≥n de la salida del terminal en la web. üåô üêì üôèüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No hace mucho tiempo, me encontr√© con una tarea bastante simple y al mismo tiempo interesante: implementar un terminal de solo lectura en una aplicaci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Visualizaci√≥n y optimizaci√≥n de la salida del terminal en la web.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448030/"><p>  No hace mucho tiempo, me encontr√© con una tarea bastante simple y al mismo tiempo interesante: implementar un terminal de solo lectura en una aplicaci√≥n web.  El inter√©s en la tarea estuvo dado por tres aspectos importantes: </p><br><ul><li>  soporte para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">secuencias de escape ANSI</a> b√°sicas </li><li>  soporte para al menos 50,000 l√≠neas de datos </li><li>  mostrar datos a medida que est√©n disponibles. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ku/fa/rk/kufarkakkmxskpfqqokeixh_ste.png"></div><br><p>  En este art√≠culo hablar√© sobre c√≥mo se implement√≥ y c√≥mo lo optimiz√≥ todo. </p><a name="habracut"></a><br><p>  <em>Descargo de responsabilidad: no soy un desarrollador web experimentado, por lo que algunas cosas pueden parecer obvias y las conclusiones o decisiones son incorrectas.</em>  <em>Para correcciones y aclaraciones, se lo agradecer√©.</em> </p><br><h2 id="dlya-chego-eto-zatevalos">  ¬øPor qu√© fue hasta </h2><br><p>  Toda la tarea es la siguiente: se ejecuta un script en el servidor (bash, python, etc.) y escribe algo en stdout.  Y esta conclusi√≥n debe mostrarse en la p√°gina web a medida que llega.  Al mismo tiempo, deber√≠a verse como en el terminal (con formato, transferencias de cursor, etc.) <br>  No controlo el script en s√≠ y su salida de ninguna manera y lo visualizo en forma pura. </p><br><p>  Por supuesto, entre la interfaz web y el script debe haber un intermediario: un servidor web.  Y si no es para disimular, ya tengo una aplicaci√≥n web y un servidor, y de alguna manera trabajo.  El esquema se parece a esto: <br><img src="https://habrastorage.org/webt/ww/kb/ei/wwkbei13_tv9n6w6vcw_6c4e5dm.png"></p><br><p>  Pero antes, el servidor era responsable del procesamiento y el formateo.  Y quer√≠a mejorarlo por una gran cantidad de razones: </p><br><ul><li>  doble procesamiento de datos: primero an√°lisis en el servidor, luego transformaci√≥n en componentes html en el cliente </li><li>  algoritmo no √≥ptimo debido a la preparaci√≥n de datos para el cliente </li><li>  carga pesada en el servidor: el procesamiento de la salida de un solo script podr√≠a cargar completamente un solo hilo en el servidor </li><li>  soporte incompleto para secuencias de escape ANSI </li><li>  errores sutiles </li><li>  al cliente le fue muy mal mostrando incluso 10k l√≠neas formateadas </li></ul><br><p>  Por lo tanto, se decidi√≥ transferir toda la l√≥gica de an√°lisis a la aplicaci√≥n web y dejar solo la transmisi√≥n de datos en bruto al servidor </p><br><h2 id="postanovka-zadachi">  Declaraci√≥n del problema. </h2><br><p>  Partes del texto llegan al cliente.  El cliente debe analizarlos en componentes: texto sin formato, avance de l√≠nea, retorno de carro y comandos ANSI especiales.  No hay garant√≠as en la integridad de las partes: un comando o una palabra pueden venir en diferentes paquetes. </p><br><p>  Los comandos ANSI pueden afectar el formato del texto (color, fondo, estilo), la posici√≥n del cursor (desde donde se debe mostrar el texto posterior) o borrar parte de la pantalla. <br>  Un ejemplo de c√≥mo se ve: <br><img src="https://habrastorage.org/webt/5u/3c/tt/5u3cttwmep44kv8c9gysh5bn9ig.png"></p><br><p>  Adem√°s, puede haber URL entre el texto que tambi√©n deben reconocerse y resaltarse. </p><br><h2 id="beryom-gotovuyu-biblioteku-i-">  Tomamos la biblioteca terminada y ... </h2><br><p>  Comprend√≠ que el procesamiento correcto y r√°pido de todos los comandos no es una tarea f√°cil.  Por lo tanto, decid√≠ buscar una biblioteca preparada.  Y, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">he aqu√≠</a> , inmediatamente me top√© con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">xterm.js</a> .  Un componente listo para usar del terminal, que ya se usa en muchos lugares y, adem√°s, <em>"es realmente r√°pido, incluso incluye un procesador acelerado por GPU"</em> .  Este √∫ltimo fue el m√°s importante para m√≠, porque  Finalmente quer√≠a obtener un cliente muy r√°pido. </p><br><p>  A pesar de que me gusta escribir mis propias bicicletas, me alegr√© much√≠simo de poder no solo ahorrar tiempo, sino tambi√©n obtener un mont√≥n de funcionalidades √∫tiles de forma gratuita. </p><br><p>  Me llev√≥ 2 pm intentar conectar el terminal y no <strong>pude</strong> hacer frente.  Absolutamente <br>  Diferentes alturas de l√≠nea, selecci√≥n torcida, tama√±o adaptativo del terminal, una API muy extra√±a, falta de documentaci√≥n sensata ... </p><br><p>  Pero todav√≠a ten√≠a un poco de inspiraci√≥n y cre√≠a que pod√≠a lidiar con estos problemas. <br>  Hasta que alimente mis l√≠neas de prueba de 10k a la terminal ... Muri√≥.  Y enterr√≥ conmigo los restos de mis esperanzas. </p><br><h2 id="opisanie-itogovogo-algoritma">  Descripci√≥n del algoritmo final. </h2><br><p>  En primer lugar, copi√© el algoritmo actual implementado en python y lo adapt√© para javascript (solo quit√© las llaves y otro para la sintaxis). </p><br><p>  Conoc√≠a todos los principales pros y contras del antiguo algoritmo, por lo que solo necesitaba mejorar los lugares ineficaces en √©l. </p><br><p>  Despu√©s de deliberaci√≥n, prueba y error, me decid√≠ por la siguiente opci√≥n: dividimos el algoritmo en 2 componentes: </p><br><ul><li>  modelo para analizar texto y almacenar el estado actual de la "terminal" </li><li>  mapeo que traduce el modelo a HTML </li></ul><br><h4 id="model-struktura-i-algoritm">  Modelo (estructura y algoritmo) </h4><br><ul><li>  Todas las filas se almacenan en una matriz (n√∫mero de fila = √≠ndice en la matriz) </li><li>  Los estilos de texto se almacenan en una matriz separada. </li><li>  La posici√≥n actual del cursor se almacena y se puede cambiar mediante comandos. </li><li>  El algoritmo mismo verifica los datos de entrada car√°cter por car√°cter: <br><ul><li>  Si esto es solo texto, agr√©guelo a la l√≠nea actual </li><li>  Si se produce un salto de l√≠nea, aumente el √≠ndice de fila actual </li><li>  Si este es uno de los caracteres del comando, lo colocamos en el b√∫fer del comando y esperamos el siguiente car√°cter </li><li>  Si el b√∫fer de comando es correcto, ejecute este comando, de lo contrario, escribiremos este b√∫fer como texto </li></ul></li><li>  El modelo notifica a los oyentes qu√© l√≠neas han cambiado despu√©s del procesamiento de texto entrante </li></ul><br><p>  En mi implementaci√≥n, la complejidad del algoritmo es O ( <em>n</em> log <em>n</em> ), donde log <em>n</em> es la preparaci√≥n de l√≠neas cambiadas para notificaci√≥n (unicidad y clasificaci√≥n).  Al momento de escribir esto, me di cuenta de que para un caso especial, puede deshacerse de log <em>n</em> , ya que las l√≠neas se agregan con mayor frecuencia al final. </p><br><h4 id="otobrazhenie">  Display </h4><br><ul><li>  Muestra texto como elementos HTML. </li><li>  Si la cadena ha cambiado, reemplaza completamente todos los elementos de la cadena </li><li>  Rompe cada l√≠nea en funci√≥n de los estilos: cada segmento estilizado tiene su propio elemento </li></ul><br><p>  Con tal estructura, la prueba es una tarea bastante simple: transferimos el texto al modelo (en un solo paquete o en partes) y simplemente verificamos el estado actual de todas las l√≠neas y estilos en √©l.  Y para mostrar solo algunas pruebas, porque  siempre vuelve a dibujar las l√≠neas cambiadas. </p><br><p>  Una ventaja importante es tambi√©n cierta pereza de la pantalla.  Si en un texto sobrescribimos la misma l√≠nea (por ejemplo, barra de progreso), luego de que el modelo funcione, para mostrarlo se ver√° como una l√≠nea cambiada. </p><br><h4 id="dom-vs-canvas">  DOM vs lienzo </h4><br><p>  Me gustar√≠a detenerme un poco en por qu√© eleg√≠ el DOM, aunque el objetivo era el rendimiento.  La respuesta es simple: pereza.  Para m√≠, representar todo en Canvas por mi cuenta parece una tarea bastante desalentadora.  Mientras se mantiene la usabilidad: resaltar, copiar, cambiar el tama√±o de la pantalla, verse ordenado, etc.  El ejemplo de xterm.js me mostr√≥ claramente que esto no es nada f√°cil.  Su representaci√≥n en lienzo estaba lejos de ser ideal. </p><br><p>  Adem√°s, la depuraci√≥n del √°rbol DOM en el navegador y la capacidad de cubrir pruebas unitarias es una ventaja importante. </p><br><p>  Al final, mi objetivo era 50k l√≠neas, y sab√≠a que el DOM ten√≠a que lidiar con esto, basado en el trabajo del antiguo algoritmo. </p><br><h2 id="optimizacii">  Optimizaciones </h2><br><p>  El algoritmo estaba listo, depurado y funcionaba lenta pero seguramente.  Era hora de abrir el perfilador y optimizarlo.  Mirando hacia el futuro, dir√© que la mayor√≠a de las optimizaciones fueron una sorpresa para m√≠ (como suele suceder). </p><br><p>  La creaci√≥n de perfiles se realiz√≥ en 10k l√≠neas, cada una de las cuales conten√≠a elementos estilizados.  El n√∫mero total de elementos DOM es de aproximadamente 100k. </p><br><p>  No se utilizaron enfoques y herramientas especiales.  Solo Chrome Dev Tools y un par de lanzamientos para cada medici√≥n.  En la pr√°ctica, en los lanzamientos, solo difer√≠an los valores absolutos de las mediciones (cu√°ntos segundos completar), pero no la proporci√≥n porcentual entre los m√©todos.  Por lo tanto, considero esta t√©cnica condicionalmente suficiente. </p><br><p>  A continuaci√≥n, me gustar√≠a profundizar en m√°s detalles sobre las mejoras m√°s interesantes.  Y para empezar, una gr√°fica de lo que fue: <br><img src="https://habrastorage.org/webt/me/xk/ot/mexkotdhezc4pwxhw4xczkzv9ie.png"></p><br><p>  <em>Todos los gr√°ficos de creaci√≥n de perfiles se crearon despu√©s de la implementaci√≥n, desoptimizando el c√≥digo de la memoria.</em> </p><br><h4 id="stringtrim">  string.trim </h4><br><p>  En primer lugar, me encontr√© con un string.trim incomprensible que consum√≠a una cantidad muy notable de CPU (me parece que esto era alrededor del 10-20%) <br><img src="https://habrastorage.org/webt/ue/nq/6b/uenq6brmlm8fxzxxjklulp7ccly.png"></p><br><p>  trim () es la funci√≥n b√°sica del lenguaje.  ¬øPor qu√© est√° usando alg√∫n tipo de biblioteca?  E incluso si se trata de alg√∫n tipo de polyfill, ¬øpor qu√© activ√≥ la √∫ltima versi√≥n de Chrome? </p><br><p> Se busca un poco en Google y se encuentra la respuesta: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://babeljs.io/docs/en/babel-preset-env</a> .  Por defecto, habilita polyfill para un n√∫mero bastante grande de navegadores, y lo hace en la etapa de compilaci√≥n.  La soluci√≥n para m√≠ fue especificar <code>'targets': '&gt; 0.25%, not dead'</code> <br>  Pero al final, elimin√© la llamada de recorte por completo, ya que no es necesario. </p><br><h4 id="vuejs">  Vue.js </h4><br><p>  El a√±o pasado, transfer√≠ el componente terminal a Vue.js.  Ahora tuve que transferirlo de nuevo a vainilla, la raz√≥n est√° en la captura de pantalla a continuaci√≥n (vea el n√∫mero de l√≠neas que involucran Vue.js): </p><br><p><img src="https://habrastorage.org/webt/ll/oq/i8/lloqi8k2igkme2q616eooswyogg.png"></p><br><p>  Dej√© solo el envoltorio, los estilos y el procesamiento del mouse en el componente Vue.  Todo lo relacionado con la creaci√≥n de elementos DOM entr√≥ en JS puro, que est√° conectado al componente Vue como un campo normal (que no es monitoreado por el marco). </p><br><pre> <code class="plaintext hljs">created() { this.terminalModel = new TerminalModel(); this.terminal = new Terminal(this.terminalModel); },</code> </pre> <br><p>  No considero esto un menos o un defecto en Vue.js.  Es solo que los marcos y el rendimiento en s√≠ mismos no se mezclan bien.  Bueno, cuando sueltas decenas y cientos de miles de objetos en un marco reactivo, es muy dif√≠cil esperar que se procese en un par de milisegundos.  Y para ser sincero, incluso me sorprende que Vue.js lo haya hecho bastante bien. </p><br><h4 id="dobavlenie-novyh-elementov">  Agregar nuevos elementos </h4><br><p>  Aqu√≠ todo es simple: si tiene varios miles de elementos nuevos y desea agregarlos al componente principal, hacer appendChild no es una buena idea.  El navegador tiene que hacer el procesamiento un poco m√°s a menudo y dedicar m√°s tiempo a la representaci√≥n.  Uno de los efectos secundarios en mi caso fue una desaceleraci√≥n en el desplazamiento autom√°tico, ya que  fuerza un recuento de todos los componentes agregados. </p><br><p><img src="https://habrastorage.org/webt/v_/5k/uj/v_5kujs_plen-j5zoxhq0ixv9um.png"></p><br><p>  Para resolver el problema, hay un DocumentFragment.  Primero, le agregamos todos los elementos, y luego lo agregamos al componente padre.  El navegador se encargar√° de la l√≠nea de los componentes entrantes. </p><br><p>  Este enfoque reduce la cantidad de tiempo que el navegador dedica a renderizar y organizar elementos. <br>  Tambi√©n prob√© otras formas de acelerar la adici√≥n de elementos.  Ninguno de ellos pudo agregar nada encima del DocumentFragment. </p><br><h4 id="span-vs-div">  span vs div </h4><br><p>  De hecho, esto podr√≠a llamarse <code>display:inline</code> (span) vs <code>display:block</code> (div). </p><br><p>  Inicialmente, ten√≠a cada l√≠nea en el lapso y terminaba con un car√°cter de salto de l√≠nea.  Sin embargo, en t√©rminos de rendimiento, esto no es muy efectivo: el navegador tiene que descubrir d√≥nde comienza y d√≥nde termina el elemento.  Con display: block, tales c√°lculos son mucho m√°s simples. </p><br><p>  Reemplazar con una representaci√≥n acelerada div por casi 2 veces. </p><br><p>  Desafortunadamente, en el caso de <code>display:block</code> resaltar varias l√≠neas de texto se ve peor: </p><br><p><img src="https://habrastorage.org/webt/dm/kj/nq/dmkjnq9up61pc-ic0jalnfi3jw8.png"></p><br><p>  Durante mucho tiempo no pude decidir cu√°l es mejor: 2 segundos adicionales de renderizado o selecci√≥n humana.  Como resultado, la practicidad venci√≥ a la belleza. </p><br><h4 id="master-css-10-go-urovnya">  Asistente de CSS de nivel 10 </h4><br><p>  Otro ~ 10% del tiempo de representaci√≥n se cort√≥ mediante la "optimizaci√≥n" CSS, que utilizo para formatear el texto. </p><br><p>  La inexperiencia en el desarrollo web y la comprensi√≥n de los conceptos b√°sicos jugaron en mi contra.  Pens√© que cuanto m√°s precisos fueran los selectores, mejor, pero espec√≠ficamente en mi caso, esto no fue as√≠. </p><br><p>  Para formatear el texto en el terminal, utilic√© los siguientes selectores: </p><br><pre> <code class="plaintext hljs">#script-panel-container .log-content &gt; div &gt; span.text_color_green,</code> </pre> <br><p>  Pero (en Chrome), la siguiente opci√≥n es un poco m√°s r√°pida: </p><br><pre> <code class="plaintext hljs">span.text_color_green</code> </pre> <br><p>  Realmente no me gusta este selector, porque  demasiado global, pero el rendimiento es m√°s costoso. </p><br><h4 id="stringsplit">  string.split </h4><br><p>  Si tiene un deja vu debido a uno de los puntos anteriores, entonces es falso.  Esta vez no se trata de polyfill, sino de la implementaci√≥n est√°ndar en Chrome: </p><br><p><img src="https://habrastorage.org/webt/i8/jk/lh/i8jklht2lc0hhc9h6p1la3zuk6o.png"></p><br><p>  <em>(Envolv√≠ string.split en defSplit para que la funci√≥n aparezca en el generador de perfiles)</em> </p><br><p>  1% son insignificantes.  Pero el ciclista idealista en m√≠ estaba embrujado.  En mi caso, la divisi√≥n siempre se realiza un personaje a la vez y sin ning√∫n habitual.  Por lo tanto, implement√© una opci√≥n simple.  Aqu√≠ est√° el resultado: </p><br><p><img src="https://habrastorage.org/webt/hu/fd/_r/hufd_rbij0khcfqcudcnpfkjisa.png"></p><br><div class="spoiler">  <b class="spoiler_title">fastSplit</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">function fastSplit(str, separatorChar) { if (str === '') { return ['']; } let result = []; let lastIndex = 0; for (let i = 0; i &lt; str.length; i++) { const char = str[i]; if (char === separatorChar) { const chunk = str.substr(lastIndex, i - lastIndex); lastIndex = i + 1; result.push(chunk); } } if (lastIndex &lt; str.length) { const lastChunk = str.substr(lastIndex, str.length - lastIndex); result.push(lastChunk); } return result; }</code> </pre> </div></div><br><p>  Creo que despu√©s de esto, est√°n obligados a llevarme al equipo de Google Chrome sin una entrevista. </p><br><h4 id="optimizaciya-posleslovie">  Optimizaci√≥n, ep√≠logo </h4><br><p>  La optimizaci√≥n es un proceso sin fin y algo puede mejorarse indefinidamente.  Especialmente considerando que diferentes casos de uso requieren optimizaciones diferentes (y conflictivas). </p><br><p>  Para mi caso, eleg√≠ el caso de uso principal y optimic√© su tiempo de operaci√≥n de 15 segundos a 5 segundos.  En esto decid√≠ parar. <br><img src="https://habrastorage.org/webt/ol/ri/j3/olrij3u8nfgpdrbm5-0db4vkpra.png"></p><br><p>  Todav√≠a hay un par de lugares que planeo mejorar, pero esto es gracias a la experiencia adquirida. </p><br><h2 id="bonus-mutacionnoe-testirovanie">  Bono  Prueba de mutaci√≥n. </h2><br><p>  Dio la casualidad de que en los √∫ltimos meses a menudo me encontr√© con el t√©rmino "pruebas mutacionales".  Y decid√≠ que esta tarea es una excelente manera de probar esta bestia.  Especialmente despu√©s de que no obtuve cobertura de c√≥digo en Webstorm, para pruebas de karma. </p><br><p>  Dado que tanto la t√©cnica como la biblioteca son nuevas para m√≠, decid√≠ sobrevivir con un poco de sangre: probar solo un componente: el modelo.  En este caso, puede indicar claramente qu√© archivo estamos probando y qu√© conjunto de pruebas est√° destinado para ello. </p><br><p>  Pero sea lo que sea que uno diga, tuve que jugar mucho para lograr la integraci√≥n con karma y webpack. </p><br><p>  Al final, todo comenz√≥ y despu√©s de media hora vi resultados tristes: aproximadamente la mitad de los mutantes sobrevivieron.  Mat√© parte inmediatamente, parte restante para el futuro (cuando implement√© los comandos ANSI faltantes). </p><br><p>  Despu√©s de eso, la pereza gan√≥, y en este momento los resultados son los siguientes (para 128 pruebas): </p><br><pre> <code class="plaintext hljs">Ran 79.04 tests per mutant on average. ------------------|---------|----------|-----------|------------|---------| File | % score | # killed | # timeout | # survived | # error | ------------------|---------|----------|-----------|------------|---------| terminal_model.js | 73.10 | 312 | 25 | 124 | 1 | ------------------|---------|----------|-----------|------------|---------| 23:01:08 (18212) INFO Stryker Done in 26 minutes 32 seconds.</code> </pre> <br><p>  En general, este enfoque me pareci√≥ muy √∫til (obviamente mejor que la cobertura del c√≥digo) y divertido.  Lo √∫nico negativo es un tiempo terriblemente largo: 30 minutos por clase es demasiado. </p><br><p>  Y lo m√°s importante, este enfoque me hizo pensar de nuevo sobre el 100% de cobertura y si vale la pena cubrir todo con pruebas: ahora mi opini√≥n est√° a√∫n m√°s cerca de "s√≠" al responder esta pregunta. </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  La optimizaci√≥n del rendimiento, en mi opini√≥n, es una buena manera de aprender algo m√°s profundo.  Tambi√©n es un buen ejercicio para el cerebro.  Y es muy lamentable que esto rara vez sea realmente necesario (al menos en mis proyectos). </p><br><p>  Y como siempre, el enfoque de "primer perfil, luego optimizaci√≥n" funciona mucho mejor que la intuici√≥n. </p><br><h4 id="ssylki">  Referencias </h4><br><p>  Implementaci√≥n anterior: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">terminal_formatter.py</a> </li><li>  <a href="">log_panel.vue</a> </li></ul><br><p>  Nueva implementaci√≥n: </p><br><ul><li>  <a href="">terminal_model.js</a> </li><li>  <a href="">terminal_view.js</a> </li></ul><br><p>  Lamentablemente, no hay una demostraci√≥n de componentes web, por lo que no podr√° introducirla.  As√≠ que me disculpo de antemano </p><br><p>  ¬°Gracias por su tiempo, me complacer√° comentarios, sugerencias y cr√≠ticas razonables! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448030/">https://habr.com/ru/post/448030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448016/index.html">An√°lisis cl√≠nico de orina en el hogar en tiras reactivas: pros y contras</a></li>
<li><a href="../448018/index.html">Eventos digitales en Mosc√∫ del 15 al 21 de abril.</a></li>
<li><a href="../448022/index.html">Compilador angular de 200 l√≠neas</a></li>
<li><a href="../448024/index.html">Los reguladores europeos se oponen a las pancartas de cookies</a></li>
<li><a href="../448026/index.html">Proyecto de software y evoluci√≥n de OOP</a></li>
<li><a href="../448032/index.html">M√°s robots: Walmart presenta miles de m√°quinas para operar en sus tiendas</a></li>
<li><a href="../448034/index.html">B√∫squeda de tareas en JIRA (lenguaje simple). Parte 1: B√∫squeda r√°pida y b√°sica</a></li>
<li><a href="../448036/index.html">Importar a J. Connect desde el archivo de lista de usuarios a trav√©s de API</a></li>
<li><a href="../448038/index.html">Nuevas caracter√≠sticas para autores de extensiones en Visual Studio 2019 v.16.1</a></li>
<li><a href="../448040/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 294 (del 8 al 14 de abril)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>