<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèä üë©üèΩ‚Äçü§ù‚Äçüë®üèø ü§≤ Singleton menempatkan objek dalam ROM dan variabel statis (C ++ menggunakan mikrokontroler Cortex M4 sebagai contoh) üôä ‚úäüèæ üï∫üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya, Di mana konstanta Anda disimpan pada mikrokontroler CortexM (menggunakan kompiler C ++ IAR sebagai contoh) , pertanyaan tent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Singleton menempatkan objek dalam ROM dan variabel statis (C ++ menggunakan mikrokontroler Cortex M4 sebagai contoh)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455477/"><img src="https://habrastorage.org/webt/4e/6g/sw/4e6gswsjjz0liihmy5ptbivomuu.jpeg" alt="gambar"><br><br>  Dalam artikel sebelumnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di mana konstanta Anda disimpan pada mikrokontroler CortexM (menggunakan kompiler C ++ IAR sebagai contoh)</a> , pertanyaan tentang bagaimana menempatkan objek konstan dalam ROM telah dibahas.  Sekarang, saya ingin memberi tahu Anda bagaimana Anda dapat menggunakan pola lone generator untuk membuat objek dalam ROM. <br><a name="habracut"></a><br><br><h3>  Pendahuluan </h3><br>  Banyak yang telah ditulis tentang Singleton (selanjutnya disebut Singleton) sisi positif dan negatifnya.  Namun terlepas dari kekurangannya, ia memiliki banyak properti yang berguna, terutama dalam konteks firmware untuk mikrokontroler. <br><br>  Untuk memulainya, untuk perangkat lunak mikrokontroler yang andal, objek tidak direkomendasikan untuk dibuat secara dinamis, dan oleh karena itu tidak perlu untuk menghapusnya.  Seringkali objek dibuat sekali dan hidup dari saat perangkat dimulai, sampai dimatikan.  Objek semacam itu bahkan bisa menjadi port leg, di mana LED terhubung, itu dibuat sekali, dan tentu saja tidak akan pergi ke mana pun saat aplikasi sedang berjalan, dan jelas itu bisa Singleton.  Seseorang harus membuat objek seperti itu dan itu bisa saja Singleton. <br><br>  Singleton juga akan memberi Anda jaminan bahwa objek yang sama yang menggambarkan kaki pelabuhan tidak akan dibuat dua kali jika tiba-tiba digunakan di beberapa tempat. <br><br>  Lain, menurut pendapat saya, properti luar biasa Singleton adalah kemudahan penggunaannya.  Misalnya, seperti dalam kasus interrupt handler, sebuah contoh yang ada di akhir artikel.  Tapi untuk sekarang, kita akan berurusan dengan Singleton sendiri. <br><br><h3>  Singleton membuat objek dalam RAM </h3><br>  Secara umum, cukup banyak artikel yang telah ditulis tentang mereka, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Singleton (Loner) atau kelas statis?</a>  , atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Three Age of Singleton Pattern</a> .  Oleh karena itu, saya tidak akan fokus pada apa itu Singleton dan menjelaskan semua banyak opsi untuk penerapannya.  Sebaliknya, saya akan fokus pada dua opsi yang dapat digunakan dalam firmware. <br>  Untuk mulai dengan, saya akan mengklarifikasi apa perbedaan antara firmware untuk mikrokontroler dari yang biasa dan mengapa beberapa implementasi tunggal untuk perangkat lunak ini "lebih baik" daripada yang lain.  Beberapa kriteria berasal dari persyaratan untuk firmware, dan beberapa hanya dari pengalaman saya: <br><br><ul><li>  Dalam firmware tidak disarankan untuk membuat objek secara dinamis </li><li>  Seringkali dalam firmware, suatu objek dibuat secara statis dan tidak pernah dihancurkan. </li><li>  Nah, jika lokasi objek diketahui pada tahap kompilasi </li></ul><br>  Berdasarkan asumsi-asumsi ini, kami mempertimbangkan dua varian Singleton dengan objek yang dibuat secara statis, dan mungkin yang paling terkenal dan umum adalah Meyers Singleton, omong-omong, meskipun harus seaman dengan standar C ++, kompiler untuk firmware membuatnya seperti ini (misalnya, IAR), hanya ketika opsi khusus diaktifkan: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; } ;</code> </pre> <br>  Ini menggunakan inisialisasi tertunda, mis.  Inisialisasi objek terjadi hanya saat pertama kali <code>GetInstance()</code> dipanggil, anggap ini sebagai inisialisasi dinamis. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   Timer1      auto&amp; objRef = Singleton&lt;Timer1&gt;::GetInstance(); //  ,      auto&amp; objRef1 = Singleton&lt;Timer1&gt;::GetInstance(); return 0; }</span></span></code> </pre> <br>  Dan Singleton tanpa penundaan inisialisasi: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; <span class="hljs-comment"><span class="hljs-comment">//      } ;</span></span></code> </pre> <br>  Kedua Singleton membuat objek dalam RAM, perbedaannya adalah untuk yang kedua, inisialisasi terjadi segera setelah program dimulai, dan yang pertama diinisialisasi pada panggilan pertama. <br><br>  Bagaimana mereka bisa digunakan dalam kehidupan nyata.  Menurut tradisi lama, saya akan mencoba menunjukkan ini menggunakan contoh LED.  Jadi, anggaplah kita perlu membuat objek kelas <code>Led1</code> , yang sebenarnya hanyalah alias dari kelas <code>Pin&lt;PortA, 5&gt;</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GreenLed = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; Led1 myLed ; <span class="hljs-comment"><span class="hljs-comment">//        RAM constexpr GreenLed greenLed ; //        ROM int main() { static GreenLed myGreenLed ; //     RAM Led1 led1; //     myGreenLed.Toggle(); led1.Toggle() ; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Untuk jaga-jaga, kelas Port dan Pin terlihat seperti ini</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> OdrAddrShift = <span class="hljs-number"><span class="hljs-number">20U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(addr ) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit) ; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Singleton   ,     friend class Singleton&lt;Pin&gt; ; public: __forceinline inline void Toggle() const { T::Toggle(pinNum) ; } //  = const Pin &amp; operator=(const Pin &amp;) = delete ; private: // ,      constexpr Pin() {} ; //  ,      //   ,      constexpr Pin(const Pin &amp;) = default ; } ;</span></span></code> </pre> <br></div></div><br>  Dalam contoh ini, saya membuat sebanyak 4 objek berbeda dari jenis yang sama di RAM dan ROM, yang sebenarnya bekerja dengan output yang sama dari port A. Yang tidak terlalu baik di sini: <br>  Nah, hal pertama yang saya tampaknya lupa bahwa <code>GreenLed</code> dan <code>Led1</code> adalah tipe yang sama dan membuat beberapa objek identik mengambil ruang di alamat yang berbeda.  Bahkan, saya bahkan lupa bahwa saya telah membuat objek global kelas <code>Led1</code> dan <code>GreenLed</code> , dan juga menciptakannya secara lokal. <br><br>  Kedua, umumnya menyatakan objek global tidak diterima, <br><br><div class="spoiler">  <b class="spoiler_title">Pedoman Pemrograman untuk Optimalisasi Kompiler Lebih Baik</b> <div class="spoiler_text">  <i>Variabel modul-lokal - variabel yang dinyatakan statis - lebih disukai daripada</i> <i><br></i>  <i>variabel global (non-statis).</i>  <i>Juga hindari mengambil alamat variabel statis yang sering diakses.</i> <i><br></i> </div></div><br>  dan objek lokal hanya tersedia dalam lingkup fungsi main (). <br><br>  Oleh karena itu, kami menulis ulang contoh ini menggunakan Singleton: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GreenLed = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        GreenLed //   GreenLed&amp; myGreenLed = Singleton&lt;GreenLed&gt;::GetInstance(); //            Led1&amp; led1 = Singleton&lt;Led1&gt;::GetInstance(); myGreenLed.Toggle() ; led1.Toggle() ; //  , Singleton&lt;Led1&gt;::GetInstance().Toggle() }</span></span></code> </pre> <br>  Dalam hal ini, apa pun yang saya lupakan, tautan saya akan selalu mengarah ke objek yang sama.  Dan saya bisa mendapatkan tautan ini di mana saja dalam program ini, dalam metode apa pun, termasuk, misalnya, dalam metode statis interrupt handler, tetapi lebih lanjut tentang itu nanti.  Dalam keadilan, saya harus mengatakan bahwa kode tidak melakukan apa-apa, dan kesalahan dalam logika program belum hilang.  Baiklah, mari kita cari tahu di mana dan bagaimana secara umum objek statis yang dibuat oleh Singleton ini ditemukan dan bagaimana ia diinisialisasi? <br><br><h3>  Objek statis </h3><br>  Sebelum mencari tahu, akan lebih baik untuk memahami apa objek statis itu. <br><br>  Jika Anda mendeklarasikan anggota kelas dengan kata kunci statis, ini berarti bahwa anggota kelas tidak terikat dengan instance kelas, mereka adalah variabel independen dan Anda dapat mengakses bidang tersebut tanpa membuat objek kelas.  Tidak ada yang mengancam kehidupan mereka sejak saat kelahiran sampai program dirilis. <br><br>  Saat digunakan dalam deklarasi objek, specifier statis hanya menentukan masa pakai objek.  Secara kasar, memori untuk objek semacam itu dialokasikan ketika program dimulai dan dibebaskan ketika program berakhir, ketika dimulai, ia juga menginisialisasi.  Pengecualian hanya objek statis lokal, yang, meskipun "mati" hanya di akhir program, pada dasarnya "lahir", atau lebih tepatnya, diinisialisasi saat pertama kali mereka melewati deklarasi. <br><br><blockquote>  Inisialisasi dinamis dari variabel lokal dengan penyimpanan statis dilakukan untuk pertama kalinya pada saat bagian pertama melalui deklarasi;  variabel semacam itu dianggap diinisialisasi setelah selesainya inisialisasi.  Jika satu utas melewati deklarasi variabel pada saat inisialisasi oleh utas lain, maka ia harus menunggu inisialisasi selesai. </blockquote><br>  Dalam panggilan berikut, inisialisasi tidak terjadi.  Semua hal di atas dapat direduksi menjadi frasa, <u>hanya satu contoh objek statis yang bisa ada.</u> <br><br>  Kesulitan seperti itu mengarah pada fakta bahwa penggunaan variabel statis lokal dan objek dalam firmware akan mengarah ke overhead tambahan.  Anda dapat memverifikasi ini dengan contoh sederhana: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test1</span></span></span><span class="hljs-class">{</span></span> Test1(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value): j(value) {} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; } ; <span class="hljs-function"><span class="hljs-function">Test1 &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Test1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i) { foo().j ++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Di sini, pertama kali fungsi <code>foo()</code> dipanggil, kompiler harus memeriksa bahwa objek statis lokal <code>test1</code> belum diinisialisasi dan memanggil konstruktor objek <code>Test1(10)</code> , dan pada lintasan kedua dan selanjutnya, ia harus memastikan bahwa objek sudah diinisialisasi dan melewati langkah ini. akan langsung <code>return test</code> . <br><br>  Untuk melakukan ini, kompiler cukup menambahkan flag <code>foo()::static guard for test 0x00100004 0x1 Data Lc main.o</code> pelindung tambahan <code>foo()::static guard for test 0x00100004 0x1 Data Lc main.o</code> dan menyisipkan kode verifikasi.  Pada deklarasi pertama dari variabel statis, flag pelindung ini tidak disetel dan oleh karena itu objek harus diinisialisasi dengan memanggil konstruktor; selama pass berikutnya, flag ini sudah ditetapkan, sehingga tidak ada lagi kebutuhan untuk inisialisasi dan panggilan konstruktor dilewati.  Selain itu, pemeriksaan ini akan dilakukan terus menerus dalam for loop. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/gb/aq/r1/gbaqr1fpbmihpghun28epsnvoou.png"></a> <br><br>  Dan jika Anda mengaktifkan opsi yang akan menjamin Anda inisialisasi dalam aplikasi multi-ulir, maka akan ada lebih banyak kode ... (lihat panggilan untuk mengambil dan melepaskan sumber daya selama inisialisasi digarisbawahi dalam oranye) <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/rq/5y/ko/rq5ykodk6pngj1esrz8bgx5-79u.png" alt="gambar"></a> <br><br>  Dengan demikian, harga menggunakan variabel statis atau objek dalam firmware meningkat baik dalam ukuran RAM dan ukuran kode.  Dan fakta ini akan baik untuk diingat dan dipertimbangkan ketika berkembang. <br><br>  Kerugian lain adalah kenyataan bahwa bendera pelindung dilahirkan bersama dengan variabel statis, masa pakainya sama dengan umur objek statis, itu dibuat oleh kompiler itu sendiri dan Anda tidak memiliki akses ke sana selama pengembangan.  Yaitu  jika tiba-tiba karena suatu alasan <br><br><div class="spoiler">  <b class="spoiler_title">lihat kecelakaan acak</b> <div class="spoiler_text">  Penyebab kesalahan acak adalah: (1) partikel alfa yang dihasilkan dari proses peluruhan, (2) neutron, (3) sumber eksternal radiasi elektromagnetik, dan (4) crosstalk internal. <br></div></div><br>  Jika flag dari 1 pergi ke 0, maka inisialisasi dengan nilai awal dipanggil lagi.  Ini tidak baik, dan orang juga harus ingat.  Untuk meringkas variabel statis: <br><blockquote>  Untuk objek statis apa pun (baik itu variabel lokal atau atribut kelas), memori dialokasikan satu kali dan tidak akan berubah sepanjang aplikasi. <br><br>  Variabel statis lokal diinisialisasi selama melewati pertama melalui deklarasi variabel. <br><br>  Atribut kelas statis, serta variabel global statis, diinisialisasi segera setelah aplikasi dimulai.  Selain itu, pesanan ini tidak ditentukan </blockquote>  Sekarang kembali ke Singleton. <br><br><h3>  Singleton menempatkan objek dalam ROM </h3><br>  Dari semua hal di atas, kita dapat menyimpulkan bahwa bagi kita, Singleton Mayers mungkin memiliki kelemahan berikut: RAM tambahan dan biaya ROM, bendera keamanan yang tidak terkendali dan ketidakmampuan untuk menempatkan objek dalam ROM karena inisialisasi dinamis. <br><br>  Tetapi ia memiliki satu kelebihan yang indah: Anda mengontrol waktu inisialisasi objek.  Hanya pengembang yang memanggil <code>GetInstance()</code> pertama kalinya saat ia membutuhkannya. <br><br>  Untuk menghilangkan tiga kekurangan pertama, itu sudah cukup untuk digunakan <br><br><div class="spoiler">  <b class="spoiler_title">Singleton tanpa inisialisasi tertunda</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enable</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class">&lt;T,Enable&gt;:</span></span>:instance ;</code> </pre><br></div></div><br>  Di sini, tentu saja, ada masalah lain, kita tidak dapat mengontrol waktu inisialisasi objek <code>instance</code> , dan kita harus entah bagaimana memberikan inisialisasi yang sangat transparan.  Tapi ini masalah terpisah, kita tidak akan memikirkannya sekarang. <br><br>  Singleton ini dapat diulang sehingga inisialisasi objek benar-benar statis pada waktu kompilasi dan instance dari objek <code>T</code> dibuat dalam ROM menggunakan <code>static constexpr T instance</code> alih-alih <code>static T instance</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// constexpr  constexpr   //           T static constexpr T instance{T()}; } ; template&lt;typename T&gt; constexpr T Singleton&lt;T&gt;::instance ;</span></span></code> </pre><br>  Di sini, pembuatan dan inisialisasi objek akan dilakukan oleh kompiler pada tahap kompilasi dan objek akan jatuh ke dalam segmen .readonly saja.  Benar, kelas itu sendiri harus memenuhi aturan berikut: <br><blockquote><ul><li>  Inisialisasi objek kelas ini harus statis.  (Konstruktor harus berupa constexpr) </li><li>  Kelas harus memiliki konstruktor salinan constexpr </li><li>  Metode kelas objek kelas tidak boleh mengubah data objek kelas (semua metode const) </li></ul></blockquote><br>  Sebagai contoh, opsi ini sangat mungkin: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class">&lt;A&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test2.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ test.SetB(v); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: B&amp; test; <span class="hljs-comment"><span class="hljs-comment">//    RAM const C&amp; test2; //    ROM //      constexpr A(const A &amp;) = default ; //     RAM  ROM,  Singleton constexpr A() : test(Singleton&lt;B&gt;::GetInstance()), test2(Singleton&lt;C&gt;::GetInstance()) { } }; int main() { //      ROM auto&amp; myObject = Singleton&lt;A&gt;::GetInstance() ; //           myObject.Set(myObject.Get()) ; cout&lt;&lt;"Singleton&lt;A&gt; - address: "&lt;&lt; &amp;myObject &lt;&lt;std::endl; }</span></span></code> </pre><br>  Hebat, Anda bisa menggunakan Singleton untuk membuat objek dalam ROM, tetapi bagaimana jika beberapa objek harus dalam RAM?  Jelas, Anda perlu entah bagaimana menyimpan dua spesialisasi untuk Singleton, satu untuk objek RAM, yang lainnya untuk objek dalam ROM.  Anda dapat melakukan ini dengan memasukkan, misalnya, untuk semua objek yang harus ditempatkan di kelas dasar ROM: <br><br><div class="spoiler">  <b class="spoiler_title">Spesialisasi untuk Singleton membuat objek dalam ROM dan RAM</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,     ROM class RomObject{}; //  ROM  template&lt;typename T&gt; class Singleton&lt;T, typename std::enable_if_t&lt;std::is_base_of&lt;RomObject, T&gt;::value&gt;&gt; { public: Singleton(const Singleton&amp;) = delete; Singleton&amp; operator = (const Singleton&amp;) = delete; Singleton() = delete; static constexpr const T&amp; GetInstance() { return instance; } private: static constexpr T instance{T()}; }; template&lt;typename T&gt; constexpr T Singleton&lt;T, typename std::enable_if_t&lt;std::is_base_of&lt;RomObject, T&gt;::value&gt;&gt;::instance ; //  RAM  template&lt;typename T, class Enable = void&gt; class Singleton { public: Singleton(const Singleton&amp;) = delete; Singleton&amp; operator = (const Singleton&amp;) = delete; Singleton() = delete; constexpr static T&amp; GetInstance() { return instance; } private: static T instance ; }; template&lt;typename T, class Enable&gt; T Singleton&lt;T,Enable&gt;::instance ;</span></span></code> </pre><br></div></div><br>  Dalam hal ini, Anda dapat menggunakannya seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      RAM,   SetB()    (j) class B { friend class Singleton&lt;B&gt;; public: const B &amp; operator=(const B &amp;) = delete ; void SetB(int value) { j = value ; } private: // ,        B(const B &amp;) = default ; B() = default; int j = 0; } //      ROM class A: public RomObject{ friend class Singleton&lt;A&gt;; public: const A &amp; operator=(const A &amp;) = delete ; int Get() const { return test2.Get(); } //     B,    void Set(int v) const { test.SetB(v); } private: B&amp; test; //    RAM const C&amp; test2; //    ROM //        A(const A &amp;) = default ; //     RAM  ROM,  Singleton constexpr A() : test(Singleton&lt;B&gt;::GetInstance()), test2(Singleton&lt;C&gt;::GetInstance()) { } }; int main() { //      ROM auto&amp; romObject = Singleton&lt;A&gt;::GetInstance() ; //    B  RAM auto&amp; ramObject = Singleton&lt;B&gt;::GetInstance() ; //           ramObject.SetB(romObject.Get()) ; cout&lt;&lt;"Singleton&lt;A&gt; - address: "&lt;&lt; &amp;romObject &lt;&lt;std::endl; cout&lt;&lt;"Singleton&lt;B&gt; - address: "&lt;&lt; &amp;ramObject &lt;&lt;std::endl; }</span></span></code> </pre> <br>  Bagaimana Anda bisa menggunakan Singleton dalam kehidupan nyata? <br><br><h3>  Contoh singleton </h3><br>  Saya akan mencoba menunjukkan ini pada contoh timer dan LED.  Tugasnya sederhana, kedipkan LED pada timer.  Timer dapat diatur. <br><br>  Prinsip operasi adalah sebagai berikut, ketika interupsi dipanggil, metode <code>OnInterrupt()</code> dari timer akan dipanggil, yang pada gilirannya akan memanggil metode switching LED melalui antarmuka pelanggan. <br><br>  Jelas, objek LED harus dalam ROM, karena tidak ada gunanya membuatnya dalam RAM, bahkan tidak ada data di dalamnya.  Pada prinsipnya, saya sudah menjelaskannya di atas, jadi tambahkan saja pewarisan dari <code>RomObject</code> , buat konstruktor constexpr dan juga pewarisi antarmuka untuk memproses peristiwa dari timer. <br><br><div class="spoiler">  <b class="spoiler_title">Objek LED</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      class ITimerSubscriber { public: virtual void OnTimeOut() const = 0; } ; template &lt;typename T, std::uint8_t pinNum&gt; class Pin: public RomOject, public ITimerSubscriber { // Singleton   ,     friend class Singleton&lt;Pin&gt; ; public: __forceinline inline void Toggle() const { T::Toggle(pinNum) ; } //       __forceinline inline void OnTimeOut() const override { Toggle() ; } //  = const Pin &amp; operator=(const Pin &amp;) = delete ; private: // ,      constexpr Pin() = default ; Pin(const Pin &amp;) = default ; } ;</span></span></code> </pre> </div></div><br>  Tetapi saya akan membuat Timer secara khusus dalam RAM dengan sedikit waybill, saya akan menyimpan tautan ke struktur <code>TIM_TypeDef</code> , periode dan tautan pelanggan, dan saya akan mengonfigurasi timer di konstruktor (Meskipun mungkin juga Timer akan masuk ke ROM): <br><br><div class="spoiler">  <b class="spoiler_title">Timer kelas</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Timer &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Timer &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPeriod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ period = value ; timer.PSC = TimerClockSpeed / <span class="hljs-number"><span class="hljs-number">1000U</span></span> - <span class="hljs-number"><span class="hljs-number">1U</span></span> ; timer.ARR = value ; } <span class="hljs-comment"><span class="hljs-comment">//      __forceinline inline void OnInterrupt() { if ((timer.SR &amp; TIM_SR_UIF) &amp;&amp; (timer.DIER &amp; TIM_DIER_UIE)) { //   ,     OnTimeOut //       Toggle() subscriber-&gt;OnTimeOut() ; timer.SR &amp;=~ TIM_SR_UIF ; } } //    TimeOut  ,   ITimerSubscriber,   __forceinline inline void Subscribe(const ITimerSubscriber&amp; obj) { subscriber = &amp;obj ; } inline void Start() { timer.CR1 |= TIM_CR1_URS ; timer.DIER |= TIM_DIER_UIE ; SetPeriod(period) ; timer.CR1 &amp;=~TIM_CR1_OPM ; timer.EGR |= TIM_EGR_UG ; timer.CR1 |= TIM_CR1_CEN ; } protected: // ,         explicit Timer(TIM_TypeDef&amp; tim): timer{tim} {}; const ITimerSubscriber * subscriber = nullptr ; TIM_TypeDef&amp; timer ; std::uint16_t period = 1000; } ;</span></span></code> </pre> <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       class BlinkTimer: public Timer { friend class Singleton&lt;BlinkTimer&gt; ; public: const BlinkTimer &amp; operator=(const BlinkTimer &amp;) = delete ; private: BlinkTimer(const BlinkTimer &amp;) = default ; inline BlinkTimer(): Timer{*TIM2} { } } ; int main() { BlinkTimer &amp; blinker = Singleton&lt;BlinkTimer&gt;::GetInstance() ; using Led1 = Pin&lt;PortA, 5&gt; ; // Led1,   ROM,      blinker.Subscribe(Singleton&lt;Led1&gt;::GetInstance()) ; blinker.Start() ; }</span></span></code> </pre><br>  Dalam contoh ini, objek kelas <code>BlinkTimer</code> terletak di RAM, dan objek kelas <code>Led1</code> terletak di ROM.  Tidak ada objek global tambahan dalam kode.  Di tempat instance kelas diperlukan, kami cukup memanggil <code>GetInstance()</code> untuk kelas ini <br><br>  Tetap menambahkan pengendali interupsi ke tabel vektor interupsi.  Dan di sini, sangat nyaman menggunakan Singleton.  Dalam metode statis kelas yang bertanggung jawab untuk menangani interupsi, Anda dapat memanggil metode objek yang dibungkus Singleton. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __iar_program_start(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterruptHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DummyHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) {} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer2Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   BlinkTimer Singleton&lt;BlinkTimer&gt;::GetInstance().OnInterrupt(); } }; using tIntFunct = void(*)(); using tIntVectItem = union {tIntFunct __fun; void * __ptr;}; #pragma segment = "CSTACK" #pragma location = ".intvec" const tIntVectItem __vector_table[] = { { .__ptr = __sfe( "CSTACK" ) }, //    __iar_program_start, //      InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, 0, 0, 0, 0, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, 0, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, //External Interrupts InterruptHandler::DummyHandler, //Window Watchdog InterruptHandler::DummyHandler, //PVD through EXTI Line detect/EXTI16 .... InterruptHandler::Timer2Handler, //      BlinkTimer InterruptHandler::DummyHandler, //TIM3 ... InterruptHandler::DummyHandler, //SPI 5 global interrupt }; extern "C" void __cmain(void) ; extern "C" __weak void __iar_init_core(void) ; extern "C" __weak void __iar_init_vfp(void) ; #pragma required = __vector_table void __iar_program_start(void) { __iar_init_core() ; __iar_init_vfp() ; __cmain() ; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Sedikit tentang tabel itu sendiri, cara kerjanya:</b> <div class="spoiler_text">  Segera setelah power-up atau setelah reset, reset diinterupsi dengan <i>angka -8</i> , dalam tabel itu adalah elemen nol, menurut sinyal reset, program beralih ke vektor elemen nol, di mana penunjuk ke atas tumpukan diinisialisasi terlebih dahulu.  Alamat ini diambil dari lokasi segmen STACK yang Anda konfigurasikan dalam pengaturan tautan.  Segera setelah pointer diinisialisasi, pergi ke titik entri program, dalam hal ini, di alamat fungsi <code>__iar_program_start</code> .  Selanjutnya, kode diinisialisasi menginisialisasi variabel global dan statis Anda, menginisialisasi coprocessor dengan floating point, jika dimasukkan dalam pengaturan, dan sebagainya.  Jika terjadi interupsi, pengendali interupsi dengan nomor interupsi dalam tabel menuju ke alamat interrupt handler.  Dalam kasus kami, ini adalah <code>InterruptHandler::Timer2Handler</code> , yang, melalui Singleton, memanggil metode <code>OnInterrupt()</code> dari blink timer kami, yang, pada gilirannya, <code>OnTimeOut()</code> metode <code>OnTimeOut()</code> kaki port. <br></div></div><br>  Sebenarnya itu saja, Anda bisa menjalankan program.  Contoh kerja untuk IAR 8.40 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terletak di sini</a> . <br>  Contoh yang lebih rinci tentang penggunaan Singleton untuk objek dalam ROM dan RAM dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditemukan di sini</a> . <br><br>  Tautan dokumentasi: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GOST R mek61508-7‚Äî2012</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Pengembangan C / C ++ untuk EWARM</a> </li></ul><br>  PS Dalam gambar di awal artikel, semua sama, Singleton bukan ROM, tapi BERBUNYI. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455477/">https://habr.com/ru/post/id455477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455467/index.html">Jika Anda tidak menulis program, jangan gunakan bahasa pemrograman</a></li>
<li><a href="../id455469/index.html">Menjadi tumpukan penuh dan tidak menjadi</a></li>
<li><a href="../id455471/index.html">Terjemahan Menggunakan Google Analytics dengan R (Michal Brys)</a></li>
<li><a href="../id455473/index.html">Generics dalam TypeScript: Getting Together</a></li>
<li><a href="../id455475/index.html">Intisari Desain Makanan, Mei 2019</a></li>
<li><a href="../id455479/index.html">Bagaimana kami menerapkan navigasi dari Jetpack ke dalam aplikasi pertempuran. Yandex. Laporan Makanan</a></li>
<li><a href="../id455481/index.html">Tiga cerita tentang perburuan liar</a></li>
<li><a href="../id455483/index.html">Artis Ai-Da: robot humanoid mempersiapkan pameran solo pertamanya</a></li>
<li><a href="../id455485/index.html">Check Point Scripts - jalankan skrip langsung dari Smart Console</a></li>
<li><a href="../id455489/index.html">Menghubungkan solusi audio dan video pihak ketiga ke Tim Microsoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>