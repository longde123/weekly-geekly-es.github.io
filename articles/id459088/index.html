<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏓 ℹ️ 👋🏿 Metode segmentasi titik dalam Point Clouds 🌊 👩🏼‍⚖️ 💧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Beberapa waktu yang lalu, saya perlu menyelesaikan masalah segmentasi titik dalam Point Cloud (awan titik adalah data yang diperoleh d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metode segmentasi titik dalam Point Clouds</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459088/"><h4 id="vvedenie">  Pendahuluan </h4><br><p>  Beberapa waktu yang lalu, saya perlu menyelesaikan masalah segmentasi titik dalam Point Cloud (awan titik adalah data yang diperoleh dari lidar). </p><br><p>  Contoh data dan tugas yang harus diselesaikan: <br><img src="https://habrastorage.org/webt/4m/af/zd/4mafzdmkubse90xn2vgxazge90y.png" alt="sampel data"></p><br><p>  Pencarian untuk ikhtisar umum dari metode yang ada tidak berhasil, jadi saya harus mengumpulkan informasi sendiri.  Anda dapat melihat hasilnya: di sini dikumpulkan artikel yang paling penting dan menarik (menurut saya) selama beberapa tahun terakhir.  Semua model yang dipertimbangkan menyelesaikan masalah segmentasi awan titik (yang termasuk dalam kelas mana setiap titik). </p><br><p>  Artikel ini akan berguna bagi mereka yang akrab dengan jaringan saraf dan ingin memahami bagaimana menerapkannya pada data yang tidak terstruktur (misalnya, grafik). </p><a name="habracut"></a><br><h4 id="suschestvuyuschie-datasety">  Kumpulan data yang ada </h4><br><p>  Sekarang di domain publik ada dataset berikut tentang topik ini: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stanford Skala Besar 3DIndoor Spaces Dataset (S3DIS)</a> - Adegan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berlabel</a> Di Dalam Bangunan </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ScanNet</a> - Adegan Berlabel Di Dalam Bangunan </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NYUV2</a> - Adegan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Marked Up</a> Inside Buildings </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ShapeNet</a> - objek dari berbagai bentuk </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ModelNet40</a> - objek dari berbagai bentuk </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SHREC15</a> - berbagai pose hewan dan manusia </li></ul><br><h4 id="osobennosti-raboty-s-point-clouds">  Fitur kerja dengan Point Clouds </h4><br><p>  Jaringan saraf telah datang ke daerah ini baru-baru ini.  Dan arsitektur standar seperti jaringan yang sepenuhnya terhubung dan konvolusional tidak berlaku untuk menyelesaikan masalah ini.  Mengapa </p><br><p>  Karena urutan poin tidak penting di sini.  Objek adalah sekumpulan titik dan tidak masalah urutan urutannya.  Jika setiap piksel memiliki tempat pada gambar, maka kita dapat dengan aman mencampurkan titik-titik dan objek tidak berubah.  Hasil dari jaringan saraf standar, sebaliknya, tergantung pada lokasi data.  Jika Anda mencampur piksel ke dalam gambar, Anda mendapatkan objek baru. </p><br><p>  Sekarang mari kita lihat bagaimana jaringan saraf diadaptasi untuk memecahkan masalah ini. </p><br><h4 id="naibolee-vazhnye-stati">  Artikel Paling Penting </h4><br><p>  Tidak banyak arsitektur dasar di daerah ini.  Jika Anda bermaksud untuk bekerja dengan grafik atau data yang tidak terstruktur, Anda perlu memiliki gagasan tentang model-model berikut: </p><br><ul><li>  Pointnet </li><li>  PointNet ++ </li><li>  DGCNN </li></ul><br><p>  Mari kita pertimbangkan secara lebih detail. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PointNet: Pembelajaran mendalam tentang Point Sets untuk Klasifikasi dan Segmentasi 3D</a> <br>  Pelopor dalam bekerja dengan data yang tidak terstruktur. <br><ul><li>  bagaimana mereka memutuskan: Artikel ini menjelaskan dua model: untuk segmentasi poin dan klasifikasi suatu objek.  Bagian umum terdiri dari blok-blok berikut: <br><ul><li>  jaringan untuk menentukan transformasi (terjemahan sistem koordinat), yang kemudian berlaku untuk semua poin </li><li>  transformasi diterapkan ke setiap titik secara individual (persepsi reguler) </li><li>  maxpooling, yang menggabungkan informasi dari berbagai titik dan membuat vektor fitur global untuk seluruh objek. </li><li>  maka perbedaan antara model dimulai: <br><ol><li>  model klasifikasi: vektor fitur global pergi ke input dari lapisan yang terhubung sepenuhnya untuk menentukan kelas cloud titik keseluruhan </li><li>  model untuk segmentasi: vektor fitur global dan fitur yang dihitung untuk setiap titik pergi ke input dari lapisan yang terhubung penuh yang mendefinisikan kelas untuk setiap titik. </li></ol></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> </li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/fu/pv/wi/fupvwi8uf8d2pcvxbvh9ahttf5s.png" alt="Arsitektur PointNet"></p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PointNet ++: Pembelajaran Fitur Hirarki Dalam pada Point Sets di Metric Space</a> <br>  Orang-orang yang sama dari Stanford yang menggambarkan PointNet. <br><ul><li>  bagaimana mereka memutuskan: pointNet diterapkan secara rekursif ke sub-cloud yang lebih kecil, mirip dengan jaringan konvolusi.  Artinya, kubus membagi ruang, PointNet diterapkan untuk masing-masing, kemudian kubus baru terdiri dari kubus ini.  Ini memungkinkan Anda untuk menyoroti tanda-tanda lokal bahwa versi sebelumnya dari jaringan itu hilang. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> </li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/py/pj/it/pypjitwxitebw0losh7ucvr43fu.png" alt="Arsitektur PointNet ++"></p><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grafik Dinamis CNN untuk Belajar pada Point Awan</a> </p><br><ul><li><p>  bagaimana mereka memutuskan: berdasarkan titik yang tersedia, grafik dibuat: simpul adalah titik, tepi hanya ada antara titik saat ini dan titik k terdekat dengan titik tersebut.  Selanjutnya, Edge conv didefinisikan - konvolusi khusus pada edge yang berasal dari titik saat ini.  Artikel ini menawarkan beberapa opsi untuk konvolusi ini.  Sebagai hasilnya, kami menggunakan yang berikut: untuk setiap titik <em>x [i] di</em> sepanjang semua titik bertetangga <em>J</em> -nya, tanda M dianggap sebagai <em>fitur [i, m] = max_j (Relu (θ [m] ∗ (x [i] −x [j]) + φ [m] ∗ x [i])))</em> .  Nilai yang diterima diingat sebagai embedding titik baru.  Di sini, koordinat lokal <em>(x [j] −x [i])</em> dan global <em>(x [j])</em> digunakan sebagai input untuk konvolusi. <br>  Setelah konvolusi didefinisikan pada grafik, sebuah jaringan konvolusi dibangun.  Anda juga dapat melihat jumlah transformasi dan aplikasinya untuk setiap titik, mirip dengan PointNet. <br>  Pada artikel ini Anda akan menemukan tinjauan yang sangat baik dari metode solusi lain. </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> </p><br></li></ul><br></li></ul><br><p><img src="https://habrastorage.org/webt/0w/lp/hm/0wlphmzbejgym-a_suxjd38tea4.png" alt="Arsitektur DGCNN"></p><br><h4 id="stati-na-osnove-pointnet-i-pointnet">  Artikel berdasarkan PointNet dan PointNet ++: </h4><br><p>  Sebagian besar artikel berbeda dalam hal jumlah kesalahan atau kedalaman dan kompleksitas blok kompleks. </p><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PointWise: Jaringan Pembelajaran Fitur Point-wise Tanpa Pengawasan</a> <br>  Fitur pekerjaan - pelatihan tanpa guru </p><br><ul><li>  bagaimana mereka memutuskan: untuk setiap titik, vektor embeddings dilatih, dimana mereka kemudian disegmentasi. <br>  Postulat utama artikel ini adalah bahwa benda-benda yang serupa harus memiliki embeddings yang serupa (misalnya, dua kaki kursi yang berbeda), meskipun letaknya jauh.  PointNet digunakan sebagai model dasar.  Inovasi utama adalah fungsi kesalahan.  Ini terdiri dari dua bagian: kesalahan rekonstruksi dan kesalahan kelancaran. <br>  Kesalahan rekonstruksi menggunakan informasi konteks titik.  Tugasnya adalah membuat embedding poin dengan konteks geometris yang sama serupa.  Untuk menghitungnya, berdasarkan vektor embedding untuk titik yang dipilih, titik baru di dekatnya dihasilkan.  Artinya, deskripsi fitur titik harus berisi informasi tentang bentuk objek di sekitar titik.  Selanjutnya, pertimbangkan berapa banyak titik yang dihasilkan jatuh dari bentuk nyata objek. <br>  Kesalahan kelancaran diperlukan agar embed serupa pada titik yang berdekatan dan tidak seperti pada titik yang jauh.  Hal yang paling indah di sini adalah pengukuran kedekatan, tidak hanya sebagai norma antara dua titik dalam ruang Euclidean, tetapi menghitung jarak melalui titik-titik objek.  Untuk setiap titik, satu titik dipilih dari k terdekat dan dari k lebih lanjut. <br>  Penyematan saat ini harus lebih dekat ke minimum terdekat dengan <em>margin</em> tertentu daripada sebelumnya. </li></ul><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SGPN: Jaringan Proposal Grup Kesamaan untuk Segmentasi 3D Point Cloud Instance</a> </p><br><ul><li>  bagaimana mereka memutuskan: seperti dalam PointWise, hal yang paling menarik dalam menghitung kesalahan ada di sini.  PointNet ++ adalah dasar, pertama-tama kita mempertimbangkan vektor fitur dan objek milik masing-masing titik secara individu, dengan analogi dengan PointNet ++. <br>  Selanjutnya, berdasarkan karakteristik, kami mempertimbangkan 3 matriks (kesamaan, kepercayaan dan segmentasi). <br>  Kesalahan pembelajaran akan menjadi jumlah dari tiga kesalahan yang dihitung oleh matriks yang sesuai: <em>L = L1 + L2 + L3</em> <br>  Biarkan N menjadi jumlah poin <br>  Matriks kesamaan - persegi, ukuran N * N.  Elemen di persimpangan baris ke-i dan kolom ke-j menunjukkan apakah titik-titik ini milik objek yang sama atau tidak.  Poin yang dimiliki oleh objek yang sama harus memiliki vektor fitur yang serupa.  Elemen matriks dapat mengambil salah satu dari tiga nilai: titik i dan j milik satu objek, poin milik satu kelas objek, tetapi untuk objek yang berbeda (baik ini dan itu kursi, tetapi kursi berbeda), atau ini umumnya poin dari objek dari kelas yang berbeda.  Matriks ini dihitung berdasarkan nilai sebenarnya. <br><img src="https://habrastorage.org/webt/s2/wl/uj/s2wlujchehww4peistxr6_l79go.png" alt="Kesalahan Kesamaan"><br>  Matriks kepercayaan adalah vektor dengan panjang N. Untuk setiap titik, persimpangan atas persatuan (IoU) antara himpunan titik-titik yang dimiliki oleh objek sesuai dengan pekerjaan algoritma kami dan himpunan titik-titik yang benar-benar milik objek dengan titik saat ini dipertimbangkan.  Kesalahannya hanyalah norma L2 antara kebenaran dan matriks yang dihitung.  Artinya, jaringan sedang mencoba untuk memprediksi seberapa percaya dirinya dalam prediksi kelas untuk poin pada suatu objek. <br>  Matriks segmentasi memiliki ukuran - N * jumlah kelas.  Kesalahan di sini dianggap sebagai cross-entropy dalam masalah klasifikasi multi-kelas. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> </li></ul><br></li></ul><br><p><img src="https://habrastorage.org/webt/m8/6r/ra/m86rrazo6hfvzrufhy5uyihgnui.png" alt="Arsitektur SGPN"></p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ketahui Apa Yang Dilakukan Tetangga Anda: Segmentasi 3D Semantik Point Clouds</a> <br><ul><li>  bagaimana mereka memutuskan: Pada awalnya, mereka mempertimbangkan tanda-tanda untuk waktu yang lama, lebih rumit daripada di PointNet, dengan banyak koneksi residual, dan jumlah, tetapi secara umum - hal yang sama.  Sedikit perbedaan - mereka menghitung tanda untuk setiap titik dalam koordinat global dan lokal. <br>  Perbedaan utama di sini adalah kesalahan menghitung lagi.  Ini bukan crossentropy standar, tetapi jumlah dari dua kesalahan: <br><ol><li>  kehilangan jarak berpasangan - titik dari satu objek harus lebih dekat dari <em>τ_near</em> dan titik dari objek yang berbeda harus lebih panjang dari <em>τ_far</em> . <br><img src="https://habrastorage.org/webt/xu/4j/ye/xu4jyel_d_sf9biwtupxtlultzu.png" alt="kehilangan jarak berpasangan"></li><li>  loss centroid - poin dari satu objek harus dekat satu sama lain </li></ol></li></ul></li></ul><br><h4 id="stati-na-osnove-dgcnn">  Artikel berbasis DGCNN: </h4><br><p>  DGCNN diterbitkan baru-baru ini (2018), jadi ada beberapa artikel berdasarkan arsitektur ini.  Saya ingin menarik perhatian Anda pada satu hal: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Linked Dynamic Graph CNN: Mempelajari Point Cloud melalui Menautkan hierarki hirarki</a> <br><ul><li>  bagaimana mereka memutuskan: rumit arsitektur asli, menambahkan koneksi residual ke dalamnya </li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/ov/zk/h7/ovzkh78zz0cnczzdp0notx8u6ea.png" alt="Arsitektur DGCNN yang terhubung"></p><br><h4 id="zaklyuchenie">  Kesimpulan </h4><br><p>  Di sini Anda dapat menemukan informasi singkat tentang metode modern untuk menyelesaikan masalah klasifikasi dan segmentasi di Point Clouds.  Ada dua model utama (PointNet ++, DGCNN), modifikasi yang sekarang digunakan untuk menyelesaikan masalah ini.  Paling sering, untuk modifikasi, fungsi kesalahan diubah dan arsitektur ini rumit dengan menambahkan lapisan dan tautan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459088/">https://habr.com/ru/post/id459088/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459078/index.html">CERN beralih ke perangkat lunak sumber terbuka - mengapa?</a></li>
<li><a href="../id459080/index.html">Fitur HttpUrlConnection dari java.net</a></li>
<li><a href="../id459082/index.html">Siapa eidetik, bagaimana ingatan salah bekerja, dan tiga mitos populer tentang ingatan</a></li>
<li><a href="../id459084/index.html">Sedikit tentang Google Home Hub, atau bagaimana saya membeli bingkai foto seharga 130 Euro</a></li>
<li><a href="../id459086/index.html">Distribusi statis objek FreeRTOS</a></li>
<li><a href="../id459090/index.html">Bawa pengalaman pengembangan Linux Anda di Windows ke level berikutnya dengan WSL dan Visual Studio Code Remote</a></li>
<li><a href="../id459092/index.html">X.Spectator - pemantauan negara dalam .NET</a></li>
<li><a href="../id459094/index.html">C # atau Java? TypeScript atau JavaScript? Pembelajaran berbasis mesin klasifikasi bahasa pemrograman</a></li>
<li><a href="../id459098/index.html">Registry Paket GitHub akan mendukung paket Swift</a></li>
<li><a href="../id459100/index.html">Registry Paket GitHub akan mendukung paket Swift</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>