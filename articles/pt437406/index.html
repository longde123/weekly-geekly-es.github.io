<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò£Ô∏è üë®üèº‚Äçüç≥ üìñ Microkernel seL4. Verifica√ß√£o formal de programas no mundo real ‚ñ∂Ô∏è üßôüèª üßñüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um artigo cient√≠fico foi publicado em Communications of the ACM , outubro de 2018, volume 61, n√∫mero 10, pp. 68‚àí77, doi: 10.1145 / 3230627 

 Em fever...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microkernel seL4. Verifica√ß√£o formal de programas no mundo real</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437406/">  <font color="gray">Um artigo cient√≠fico foi publicado em <i>Communications of the ACM</i> , outubro de 2018, volume 61, n√∫mero 10, pp. 68‚àí77, doi: 10.1145 / 3230627</font> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/549/555/096/549555096952b991fe97a964cd19d97b.jpg" align="left">  Em fevereiro de 2017, um helic√≥ptero decolou da pista de pouso da Boeing no Arizona com a miss√£o usual: voar pelas colinas mais pr√≥ximas.  Ele voou completamente de forma aut√¥noma.  De acordo com os requisitos de seguran√ßa da Administra√ß√£o Federal de Avia√ß√£o dos EUA, o piloto n√£o tocou nos controles.  Este n√£o foi o primeiro v√¥o aut√¥nomo AH-6, que a empresa chama de Passarinho n√£o tripulado (ULB).  Ele voa assim h√° muitos anos.  No entanto, desta vez no meio do voo, o helic√≥ptero sofreu um ataque cibern√©tico.  O computador de bordo atacou o software malicioso da c√¢mera de v√≠deo, bem como o v√≠rus transmitido pela unidade flash infectada, que foi inserida durante a manuten√ß√£o.  O ataque amea√ßou alguns subsistemas, mas n√£o p√¥de afetar a opera√ß√£o segura da aeronave. <br><a name="habracut"></a><br><h1>  Ideias-chave </h1><br><ul><li>  A evid√™ncia formal da arquitetura de software de um microkernel verificado pode ser dimensionada de forma barata para sistemas reais. </li><li>  Diferentes n√≠veis de seguran√ßa e confiabilidade dentro do mesmo sistema s√£o poss√≠veis e desej√°veis.  N√£o √© necess√°rio garantir a m√°xima confiabilidade de todo o c√≥digo. </li><li>  Um redesenho e refatora√ß√£o moderados s√£o suficientes para elevar os sistemas existentes ao n√≠vel de c√≥digo altamente confi√°vel. </li></ul><br>  Voc√™ pode pensar que a avia√ß√£o militar pode facilmente repelir um ataque cibern√©tico.  Na realidade, uma equipe de agentes profissionais encomendados pela DARPA como parte de um programa para desenvolver sistemas de computadores militares altamente confi√°veis ‚Äã‚Äãem 2013, os Sistemas Militares Cibern√©ticos de Alta Garantia (HACMS) invadiram com √™xito a primeira vers√£o do software ULB, que foi originalmente desenvolvida para garantir a seguran√ßa de v√¥o, n√£o a prote√ß√£o de ataques cibern√©ticos.  Os hackers tiveram a oportunidade de bater em um helic√≥ptero ou aterriss√°-lo em qualquer lugar que desejassem.  Portanto, o risco de tais ataques com um passageiro a bordo dificilmente pode ser superestimado, e uma tentativa malsucedida de hacking em fevereiro de 2017 indica algumas mudan√ßas fundamentais no software. <br><br>  Este artigo explica essas altera√ß√µes e a tecnologia que as tornou poss√≠veis.  Essa √© uma tecnologia desenvolvida como parte do programa HACMS, que visa garantir a opera√ß√£o segura de sistemas cr√≠ticos em um ambiente cibern√©tico hostil - neste caso, v√°rios ve√≠culos aut√¥nomos.  A tecnologia √© baseada na verifica√ß√£o formal de software - s√£o programas com provas matem√°ticas verificadas automaticamente que funcionam de acordo com suas especifica√ß√µes.  Embora o artigo n√£o seja dedicado aos m√©todos formais, ele explica como usar a verifica√ß√£o de artefato para proteger sistemas reais na pr√°tica. <br><br>  Talvez o resultado mais impressionante do HACMS seja que a tecnologia possa ser estendida aos sistemas reais existentes, melhorando consideravelmente sua prote√ß√£o contra ataques cibern√©ticos.  Esse processo √© chamado de "retrofit de seguran√ßa s√≠smica", semelhante √†s atualiza√ß√µes de constru√ß√£o s√≠smica.  Al√©m disso, a maior parte da reengenharia foi realizada por engenheiros da Boeing, e n√£o por especialistas formais de verifica√ß√£o. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6f/fbc/1ac/e6ffbc1ac1fb4083ac3961fe43bf8f6e.jpg"><br>  <font color="gray">"P√°ssaro" durante um voo de teste n√£o tripulado</font> <br><br>  Nem todo software de helic√≥ptero √© constru√≠do com base em modelos e evid√™ncias matem√°ticas.  O campo da verifica√ß√£o formal ainda n√£o est√° pronto para essa escala.  No entanto, o programa HACMS demonstrou que a aplica√ß√£o estrat√©gica de m√©todos formais nas partes mais importantes do sistema geral melhora muito a prote√ß√£o.  A abordagem HACMS funciona para sistemas nos quais o recurso de seguran√ßa desejado pode ser alcan√ßado por meio de uma aplica√ß√£o puramente no n√≠vel da arquitetura.  √â baseado no nosso microkernel verificado no sel4, sobre o qual falaremos abaixo.  Garante o isolamento entre os subsistemas, com exce√ß√£o dos canais de comunica√ß√£o claramente definidos e sujeitos √†s pol√≠ticas de seguran√ßa do sistema.  Esse isolamento √© garantido no n√≠vel da arquitetura com a estrutura verificada do CAmkES para componentes do sistema.  Usando linguagens espec√≠ficas de dom√≠nio da Galois Inc.  O CAmkES se integra √†s ferramentas de an√°lise de arquitetura da Rockwell Collins e da Universidade de Minnesota, al√©m de componentes de software altamente confi√°veis. <br><br>  As realiza√ß√µes do HACMS s√£o baseadas no velho amigo fiel de um engenheiro de software - modulariza√ß√£o.  A inova√ß√£o √© que m√©todos formais provam a observabilidade de interfaces e o encapsulamento de componentes internos do m√≥dulo.  Essa ader√™ncia garantida √† modularidade permite que engenheiros que n√£o s√£o especialistas em m√©todos formais (como na Boeing) criem novos ou mesmo atualizem sistemas existentes e obtenham alta estabilidade.  Embora as ferramentas ainda n√£o forne√ßam evid√™ncias completas da seguran√ßa do sistema. <br><br><h1>  Verifica√ß√£o formal </h1><br>  As evid√™ncias da corre√ß√£o matem√°tica dos programas datam de pelo menos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a d√©cada de 1960</a> , mas por um longo tempo seus reais benef√≠cios para o desenvolvimento de software foram limitados em escopo e profundidade.  No entanto, nos √∫ltimos anos, houve v√°rias descobertas impressionantes na verifica√ß√£o formal no n√≠vel de c√≥digo de sistemas reais, do compilador C <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CompCert</a> verificado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ao</a> microkernel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seL4</a> verificado (consulte os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cient√≠ficos a</a> respeito), o sistema de confer√™ncia verificado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CoCon</a> , o compilador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CakeML</a> ML verificado, programas verificados para provar os teoremas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Milawa</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Candle</a> , o sistema de arquivos √† prova de falhas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FSCQ</a> verificado, o sistema distribu√≠do IronFleet verificado e a estrutura verificada do kernel paralelo CertiKOS, al√©m de importantes  teoremas matem√°ticos, incluindo os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">problemas de quatro cores</a> , a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">prova</a> autom√°tica <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">da hip√≥tese de Kepler</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o teorema de Faith - Thompson em ordem √≠mpar</a> .  Todos estes s√£o sistemas reais.  Por exemplo, o CompCert √© um produto comercial, o microkernel seL4 √© usado em aeronaves aeroespaciais e n√£o tripuladas, como plataforma da Internet das coisas, e o sistema CoCon tem sido usado em in√∫meras grandes confer√™ncias cient√≠ficas. <br><br>  Esses projetos de verifica√ß√£o exigem um esfor√ßo consider√°vel.  Para disponibilizar publicamente m√©todos formais, esses esfor√ßos precisam ser reduzidos.  Aqui, demonstramos como uma combina√ß√£o estrat√©gica de m√©todos formais e informais, automa√ß√£o parcial de m√©todos formais e desenvolvimento cuidadoso de software para maximizar os benef√≠cios de componentes isolados nos permitiu aumentar significativamente a confiabilidade de sistemas cujo tamanho e complexidade gerais s√£o ordens de magnitude maiores do que as mencionadas acima. <br><br>  Observe que aplicamos a verifica√ß√£o formal principalmente para o c√≥digo do qual a seguran√ßa do sistema depende.  Mas h√° outros benef√≠cios.  Por exemplo, a evid√™ncia de que o c√≥digo est√° correto faz suposi√ß√µes sobre o contexto em que √© executado (por exemplo, comportamento de hardware e configura√ß√£o de software).  A verifica√ß√£o formal torna essas suposi√ß√µes expl√≠citas, o que ajuda os desenvolvedores a se concentrarem em outras ferramentas de verifica√ß√£o, como testes.  Al√©m disso, em muitos casos, o sistema inclui c√≥digo verificado e n√£o verificado.  Durante as an√°lises de c√≥digo, teste e depura√ß√£o, a verifica√ß√£o formal age como uma lente, concentrando-se no c√≥digo cr√≠tico e n√£o verificado do sistema. <br><br><h1>  seL4 </h1><br>  Vamos come√ßar com a base para a constru√ß√£o de sistemas comprovadamente confi√°veis ‚Äã‚Äã- o kernel do sistema operacional (SO).  Essa √© a parte mais importante que garante a confiabilidade de todo o sistema de maneira econ√¥mica. <br><br>  O microkernel seL4 fornece um conjunto m√≠nimo formalmente verificado de mecanismos para implementar sistemas seguros.  Ao contr√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dos kernels padr√£o</a> , √© propositalmente universal e, portanto, adequado para implementar v√°rias pol√≠ticas de seguran√ßa e requisitos de sistema. <br><br>  Um dos principais objetivos do desenvolvimento do seL4 √© fornecer um forte isolamento entre os componentes que desconfiam mutuamente e que s√£o executados no topo do kernel.  Ele suporta seu trabalho como um hipervisor, por exemplo, para sistemas operacionais Linux inteiros, mantendo-os isolados de componentes cr√≠ticos de seguran√ßa que podem funcionar juntos, como mostra a Figura 1. Em particular, essa fun√ß√£o permite que os desenvolvedores de sistemas usem componentes legados com recursos ocultos. vulnerabilidades pr√≥ximas a componentes altamente confi√°veis. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c8c/e73/dfe/c8ce73dfe32eec8ecbef90268fd802d3.jpg"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">1. Isolamento e comunica√ß√µes controladas em seL4</font></i> <br><br>  O n√∫cleo seL4 ocupa uma posi√ß√£o especial entre os micron√∫cleos de uso geral.  Al√©m de oferecer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">melhor desempenho em sua classe</a> , suas 10.000 linhas de c√≥digo C passaram por uma verifica√ß√£o formal mais rigorosa do que qualquer outro software dispon√≠vel publicamente na hist√≥ria humana em termos n√£o apenas de linhas de prova, mas tamb√©m da for√ßa de propriedades comprovadas.  Baseia-se na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">prova da ‚Äúcorre√ß√£o funcional‚Äù da implementa√ß√£o principal em C.</a>  Ele garante que qualquer comportamento do kernel seja previsto por sua especifica√ß√£o abstrata formal: consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aplicativo online</a> para ter uma id√©ia de como essas evid√™ncias s√£o exibidas.  Ap√≥s essa garantia, adicionamos evid√™ncias adicionais que explicaremos ap√≥s a introdu√ß√£o aos mecanismos b√°sicos do n√∫cleo. <br><br><h3>  API seL4 </h3><br>  O kernel seL4 fornece um conjunto m√≠nimo de mecanismos para a implementa√ß√£o de sistemas seguros: fluxos, gerenciamento de capacidade, espa√ßos de endere√ßo virtual, comunica√ß√£o entre processos (IPC), sinaliza√ß√£o e interrup√ß√£o de entrega. <br><br>  O kernel mant√©m seu estado nos "objetos do kernel".  Por exemplo, para cada encadeamento no sistema, existe um "objeto de fluxo" que armazena informa√ß√µes sobre descarte, execu√ß√£o e controle de acesso.  Os programas de espa√ßo do usu√°rio podem se referir apenas aos objetos do kernel indiretamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">por meio dos chamados "recursos"</a> ou "recursos", que combinam um link para um objeto com um conjunto de direitos de acesso a ele.  Por exemplo, um encadeamento n√£o pode iniciar ou parar outro encadeamento se n√£o tiver a "capacidade" para o objeto de encadeamento correspondente. <br><br>  Os threads interagem e sincronizam enviando mensagens atrav√©s dos "pontos finais" de comunica√ß√£o entre processos.  Um encadeamento com capacidade de enviar para o terminal correspondente pode enviar uma mensagem para outro encadeamento que tem a capacidade de receber para esse terminal.  Os objetos de notifica√ß√£o fornecem sincroniza√ß√£o entre conjuntos de sem√°foros bin√°rios.  A convers√£o de endere√ßo virtual √© controlada por objetos do kernel que representam diret√≥rios de p√°ginas, tabelas de p√°ginas e objetos de quadro ou abstra√ß√µes sutis sobre os objetos de arquitetura do processador correspondentes.  Cada fluxo possui uma certa capacidade de "VSpace", que aponta para a raiz da √°rvore dos objetos de convers√£o de endere√ßo de fluxo.  Os recursos em si s√£o gerenciados pelo kernel e armazenados nos objetos do kernel "CNodes", localizados na estrutura do gr√°fico, que mapeia links para objetos com direitos de acesso, semelhante √† compara√ß√£o de tabelas de p√°ginas virtuais com endere√ßos f√≠sicos na mem√≥ria.  Cada thread tem sua pr√≥pria capacidade de identificar o CNode raiz.  O conjunto de recursos dispon√≠veis nessa raiz, chamamos de "CSpace Stream".  As habilidades podem ser transferidas atrav√©s de terminais com transfer√™ncia de tarefas e tamb√©m podem ser declaradas compartilhadas usando o CSpace comum.  A Figura 2 mostra esses objetos do kernel. <br><br> <a href=""><img src="https://habrastorage.org/webt/cy/vr/ea/cyvreajptf3s4kcvgrlj7oyjfw8.png"></a> <br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">2. Objetos do kernel em um sistema seL4 com dois threads interagindo atrav√©s de um n√≥ de extremidade</font></i> <br><br><h3>  Evid√™ncia de seguran√ßa </h3><br>  Devido √† sua versatilidade, as APIs do kernel seL4 s√£o de baixo n√≠vel e suportam arquiteturas de sistema altamente din√¢micas.  Portanto, √© dif√≠cil obter evid√™ncias diretas dessas APIs. <br><br>  O conceito de alto n√≠vel de pol√≠ticas de controle de acesso abstrai de objetos individuais e recursos do kernel, capturando a configura√ß√£o de controle de acesso do sistema usando um conjunto de "assuntos" (componentes) abstratos e os poderes que cada um deles tem sobre outros (por exemplo, para ler dados e enviar mensagens) .  No exemplo da fig.  2, os componentes A e B obtiveram autoridade sobre o terminal. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sewell e colegas</a> provaram que as pol√≠ticas de controle de acesso seL4 garantem o respeito de dois recursos b√°sicos de seguran√ßa: restri√ß√£o de privil√©gios e integridade. <br><br>  A restri√ß√£o de autoridade significa que a pol√≠tica de controle de acesso √© uma aproxima√ß√£o segura est√°tica (inalterada) de recursos espec√≠ficos e objetos do kernel no sistema para qualquer estado futuro.  Essa propriedade implica que, n√£o importa como o sistema evolua, nenhum componente receber√° mais autoridade do que a pol√≠tica de controle de acesso prev√™.  Na Figura 2, a pol√≠tica para o componente B n√£o possui acesso de grava√ß√£o ao componente A. Portanto, o componente B nunca poder√° obter esse acesso no futuro.  Essa propriedade implica que o racioc√≠nio no n√≠vel da pol√≠tica √© uma aproxima√ß√£o segura ao racioc√≠nio sobre o estado espec√≠fico do controle de acesso no sistema. <br><br>  Integridade significa que, n√£o importa o que o componente fa√ßa, ele nunca poder√° alterar dados no sistema (incluindo quaisquer chamadas do sistema que possa fazer) que claramente n√£o tem permiss√£o para alterar a pol√≠tica de controle de acesso.  Por exemplo, na fig.  2, o √∫nico componente da autoridade de A sobre outro componente √© o direito de enviar dados para o terminal de onde o componente B. recebe informa√ß√µes. Isso significa que o componente A s√≥ pode alterar seu estado, o estado do encadeamento B e o estado do buffer de mensagens.  N√£o pode alterar outras partes do sistema. <br><br>  Um efeito colateral da integridade √© a confidencialidade, quando um componente √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">incapaz de ler informa√ß√µes de outro componente sem permiss√£o</a> : √© uma propriedade forte comprovada da n√£o interfer√™ncia n√£o transitiva e n√£o transit√≥ria.  Ou seja, em um sistema configurado corretamente (com restri√ß√µes mais rigorosas do que apenas para integridade), nenhum dos componentes pode, sem permiss√£o, descobrir informa√ß√µes sobre outro componente ou sua execu√ß√£o.  A prova expressa essa propriedade em termos da pol√≠tica de fluxo de informa√ß√µes, que pode ser extra√≠da da pol√≠tica de controle de acesso usada na prova de integridade.  As informa√ß√µes ser√£o transmitidas somente quando explicitamente permitido pela pol√≠tica.  A prova cobre fluxos de informa√ß√µes expl√≠citos, bem como poss√≠veis canais de armazenamento ocultos no kernel.  Mas os canais de sincroniza√ß√£o est√£o fora de sua √°rea e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">devem ser processados ‚Äã‚Äãpor outros meios</a> . <br><br>  Outras evid√™ncias no seL4 incluem uma extens√£o da corre√ß√£o funcional e, portanto, teoremas de seguran√ßa para um n√≠vel bin√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">da arquitetura ARMv7</a> e um perfil de tempo de execu√ß√£o do pior caso para o kernel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a> ), necess√°rio para sistemas em tempo real.  O n√∫cleo seL4 est√° dispon√≠vel para v√°rias arquiteturas: ARMv6, ARMv7 ARMv7a, ARMv8, RISC-V, Intel x86 e Intel x64.  No momento, ele passou no teste da m√°quina na arquitetura do ARMv7 para toda a pilha de verifica√ß√£o, bem como no ARMv7a com extens√µes de hipervisor para corre√ß√£o funcional. <br><br><h1>  Arquitetura Seguran√ßa </h1><br>  A se√ß√£o anterior descreveu os m√©todos de programa√ß√£o pelos quais o kernel seL4 cria uma base s√≥lida para sistemas comprovadamente confi√°veis.  O kernel forma uma base de computa√ß√£o confi√°vel (TCB) - um componente essencial do software que deve funcionar corretamente para garantir a seguran√ßa do sistema.  Em sistemas reais, essa base √© muito mais ampla do que apenas um microkernel.  √â necess√°rio verificar uma pilha de software adicional para obter o mesmo n√≠vel de confian√ßa do kernel.  No entanto, existem classes de sistemas para as quais n√£o h√° necessidade dessa verifica√ß√£o: eles precisam de teoremas de isolamento no n√≠vel do kernel para derivar certas propriedades de seguran√ßa no n√≠vel do sistema.  Esta se√ß√£o fornece um exemplo desse sistema. <br><br>  Esses s√£o sistemas nos quais as arquiteturas de componentes j√° implementaram uma propriedade cr√≠tica, talvez junto com v√°rios pequenos componentes confi√°veis.  Nosso exemplo √© o software de controle de v√¥o quadcopter, um dispositivo de demonstra√ß√£o no programa HACMS mencionado anteriormente. <br><br>  A Figura 3 mostra os principais componentes de hardware do quadroc√≥ptero.  A arquitetura √© intencionalmente mais complexa do que a exigida pelo quadcopter, pois deveria representar o ULB e, nesse n√≠vel de abstra√ß√£o, √© semelhante √† arquitetura do ULB. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f4/a7d/3bd/0f4a7d3bd00cb793457c03e11db9bd08.jpg"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">3. Arquitetura de uma aeronave aut√¥noma</font></i> <br><br>  A figura mostra dois computadores principais: um computador de bordo que interage com a esta√ß√£o terrestre e controla o software a bordo (por exemplo, a c√¢mera) e um computador de navega√ß√£o para controlar o voo do ve√≠culo, ler dados do sensor e controlar os motores.  Os computadores s√£o conectados atrav√©s de uma rede interna ou barramento CAN em um quadrocopter, Ethernet em ULB.  O quadrocopter tamb√©m possui um ponto WiFi desprotegido, o que possibilita demonstrar m√©todos de prote√ß√£o adicionais. <br><br>  Neste exemplo, considere um computador de bordo.  Quatro propriedades b√°sicas devem ser cumpridas para isso: <br><br><ul><li>  autentica√ß√£o adequada de comandos da esta√ß√£o terrestre; <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> privacidade de chaves criptogr√°ficas; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nenhuma mensagem adicional para o computador de navega√ß√£o; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o software n√£o confi√°vel de outros sistemas de bordo n√£o pode afetar o voo do dispositivo. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A hip√≥tese de trabalho √© que a c√¢mera n√£o √© confi√°vel, potencialmente comprometida ou maliciosa, que seus drivers e software desatualizado est√£o potencialmente comprometidos, bem como quaisquer canais de comunica√ß√£o externos. </font><font style="vertical-align: inherit;">Neste exemplo, assumimos a criptografia correta e forte, ou seja, que a chave n√£o pode ser apanhada e vamos al√©m do escopo da tarefa para suprimir as radiocomunica√ß√µes do inimigo com uma esta√ß√£o terrestre.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Figura 4 mostra como a arquitetura do quadroc√≥ptero √© projetada para fornecer essas propriedades. </font><font style="vertical-align: inherit;">A m√°quina virtual (VM) do Linux serve como um cont√™iner para software de dispositivo de bordo herdado, drivers de c√¢mera e pontos de acesso WiFi. </font><font style="vertical-align: inherit;">Isolamos o m√≥dulo de controle de criptografia em seu pr√≥prio componente, com conex√µes ao barramento CAN, ao canal da esta√ß√£o terrestre e √† m√°quina virtual Linux para enviar dados para a esta√ß√£o terrestre. </font><font style="vertical-align: inherit;">A tarefa do componente criptogr√°fico √© transmitir (apenas) mensagens autorizadas para o computador de bordo atrav√©s da interface CAN da pilha e enviar dados de diagn√≥stico de volta √† esta√ß√£o terrestre. </font><font style="vertical-align: inherit;">O componente de r√°dio envia e recebe mensagens brutas que s√£o criptografadas e descriptografadas (com autentica√ß√£o) pelo componente criptogr√°fico.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c50/909/098/c5090909891798d51b0af4045fc2d19a.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 4. </font><font style="vertical-align: inherit;">Arquitetura simplificada do computador de bordo com quadcopter</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A configura√ß√£o das propriedades desejadas do sistema √© reduzida apenas √†s propriedades de isolamento e ao comportamento da arquitetura em termos de fluxos de informa√ß√µes, bem como ao comportamento de um √∫nico componente criptogr√°fico confi√°vel. Assumindo o comportamento correto desse componente, as chaves n√£o podem ser comprometidas, pois nenhum outro componente tem acesso a elas. O canal entre o Linux e o componente criptogr√°fico na Fig. 4 destina-se apenas a mensagens e n√£o d√° acesso √† mem√≥ria. Somente mensagens autorizadas podem entrar no barramento CAN, porque o componente criptogr√°fico √© a √∫nica comunica√ß√£o com o barramento. Software n√£o confi√°vel e WiFi, como parte da m√°quina virtual Linux, s√£o encapsulados pelo isolamento de componentes e s√≥ podem interagir com o restante do sistema por meio de um componente criptogr√°fico confi√°vel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â f√°cil imaginar que essa an√°lise da arquitetura possa ser automatizada em grande parte, verificando modelos e ferramentas de racioc√≠nio mec√¢nico de n√≠vel superior. Conforme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">observado nos sistemas MILS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , os limites dos componentes dessa arquitetura n√£o s√£o apenas uma ferramenta conveniente para particionamento e gerenciamento de c√≥digo, mas o isolamento for√ßado fornece limites efetivos para o racioc√≠nio formal sobre o comportamento do sistema. No entanto, tudo depende da aplica√ß√£o adequada dos limites dos componentes em tempo de execu√ß√£o na implementa√ß√£o final do sistema bin√°rio.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os mecanismos discutidos anteriormente do kernel seL4 s√£o capazes de fornecer tal implementa√ß√£o, mas o n√≠vel de abstra√ß√£o de mecanismos contrasta fortemente com os blocos e as setas do esquema arquitetural: uma pol√≠tica de controle de acesso ainda mais abstrata ainda cont√©m muito mais detalhes do que o esquema de arquitetura. </font><font style="vertical-align: inherit;">Em um sistema real desse tamanho, dezenas de milhares de objetos e "habilidades" do kernel s√£o criados por software, e erros de configura√ß√£o podem levar a viola√ß√µes de seguran√ßa. </font><font style="vertical-align: inherit;">Em seguida, discutiremos como n√£o apenas automatizamos a configura√ß√£o e a cria√ß√£o desse c√≥digo, mas tamb√©m como provar automaticamente a conformidade com os limites da arquitetura.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifica√ß√£o de exibi√ß√£o de componente </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como as evid√™ncias de seguran√ßa s√£o simplificadas com abstra√ß√µes formais de pol√≠ticas de seguran√ßa, a abstra√ß√£o tamb√©m ajuda no design do sistema. </font><font style="vertical-align: inherit;">A plataforma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camkes do</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> componente </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">√©</font></a><font style="vertical-align: inherit;"> executada em abstra√ß√µes seL4 sobre os mecanismos de baixo n√≠vel do kernel, fornecendo primitivas de comunica√ß√£o e decompondo o sistema em unidades funcionais, conforme mostrado na Fig. </font><font style="vertical-align: inherit;">5. Usando essa plataforma, os arquitetos de sistemas podem projetar e construir sistemas baseados no seL4 em termos de componentes de alto n√≠vel que interagem entre si e com dispositivos de hardware por meio de conectores, como chamadas de procedimento remoto (RPC), dataports e eventos. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/887/212/48b/88721248b5536a3f3b80501ba3a11d1c.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">5. Fluxo de trabalho do CAmkES</font></font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gera√ß√£o de c√≥digo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internamente, o CAmkES implementa essas abstra√ß√µes usando objetos de kernel de baixo n√≠vel no seL4. Cada componente cont√©m (pelo menos) um fluxo, CSpace e VSpace. Os conectores RPC usam objetos de terminal e o CAmkES gera c√≥digo intermedi√°rio para processar mensagens e envi√°-las aos terminais do IPC. Da mesma forma, o conector do dataport √© implementado atrav√©s da mem√≥ria compartilhada - quadros comuns presentes nos espa√ßos de endere√ßo de dois componentes - e, opcionalmente, pode limitar a dire√ß√£o da transfer√™ncia de dados. Finalmente, o conector de evento √© implementado usando o mecanismo de notifica√ß√£o seL4. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O CAmkES tamb√©m gera no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capDL uma</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> especifica√ß√£o de baixo n√≠vel da configura√ß√£o inicial de objetos e dos recursos do kernel do sistema. Essa especifica√ß√£o se torna entrada para o inicializador seL4, que</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele inicia primeiro ap√≥s o carregamento e executa as opera√ß√µes seL4 necess√°rias para criar uma inst√¢ncia e inicializar o sistema</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, a plataforma de componentes gera c√≥digo sem esfor√ßo adicional por parte do desenvolvedor. </font><font style="vertical-align: inherit;">A arquitetura de componentes descreve um conjunto de blocos e setas, e a tarefa de implementa√ß√£o resume-se a simplesmente preencher os campos. </font><font style="vertical-align: inherit;">A plataforma gera o restante, fornecendo a implementa√ß√£o da arquitetura descrita. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em uma plataforma com componentes tradicionais, o c√≥digo gerado expandir√° a base de computa√ß√£o confi√°vel do sistema, pois pode afetar a funcionalidade dos componentes. </font><font style="vertical-align: inherit;">No entanto, o CAmkES tamb√©m gera evid√™ncias.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evid√™ncia autom√°tica </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao gerar o c√≥digo "intermedi√°rio", o CAmkES produz provas formais em Isabelle / HOL, executando a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valida√ß√£o durante a tradu√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e demonstrando que o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√≥digo "intermedi√°rio" gerado obedece √† especifica√ß√£o de alto n√≠vel, e a especifica√ß√£o capDL gerada √© a especifica√ß√£o correta da descri√ß√£o do CAmkES</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tamb√©m provamos que o inicializador seL4 configura corretamente o sistema na configura√ß√£o inicial necess√°ria. Ao mesmo tempo, automatizamos a maior parte da constru√ß√£o do sistema sem expandir a base de computa√ß√£o confi√°vel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os desenvolvedores raramente olham para a emiss√£o de geradores de c√≥digo; eles est√£o interessados ‚Äã‚Äãapenas na funcionalidade e na l√≥gica de neg√≥cios. </font><font style="vertical-align: inherit;">Tamb√©m assumimos que as evid√™ncias do c√≥digo intermedi√°rio n√£o precisam ser verificadas, ou seja, os desenvolvedores podem se concentrar em provar a corre√ß√£o de seu pr√≥prio c√≥digo. </font><font style="vertical-align: inherit;">Assim como o cabe√ßalho CAmkES gerado fornece ao desenvolvedor uma API para o c√≥digo gerado, os operadores de lema de n√≠vel superior produzem uma API para prova. </font><font style="vertical-align: inherit;">Os lemas descrevem o comportamento esperado dos conectores. </font><font style="vertical-align: inherit;">No exemplo de middleware RPC na Figura </font><font style="vertical-align: inherit;">6 fun√ß√£o gerada</font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fornece uma maneira de chamar uma fun√ß√£o remota</font></font><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.279ex" height="2.419ex" viewBox="0 -780.1 550.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgtF4M21nPIW3B7TqiVh4QDpecrFg#MJMATHI-66" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> f </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em outro componente. </font><font style="vertical-align: inherit;">Para salvar a abstra√ß√£o, chame</font></font><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgtF4M21nPIW3B7TqiVh4QDpecrFg#MJMATHI-67" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> g </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deve ser equivalente a chamar</font></font><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.279ex" height="2.419ex" viewBox="0 -780.1 550.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgtF4M21nPIW3B7TqiVh4QDpecrFg#MJMATHI-66" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> f </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgtF4M21nPIW3B7TqiVh4QDpecrFg#MJMATHI-67" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> g </script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O lema gerado pelo sistema garante que </font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do c√≥digo RPC gerado se comporta como uma chamada direta</font></font><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.279ex" height="2.419ex" viewBox="0 -780.1 550.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgtF4M21nPIW3B7TqiVh4QDpecrFg#MJMATHI-66" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> f </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgtF4M21nPIW3B7TqiVh4QDpecrFg#MJMATHI-67" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> g </script>  . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61e/b0f/111/61eb0f111ab2d64688c3c42aadaba3ab.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">6. C√≥digo RPC gerado</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para o uso real das evid√™ncias geradas pelo sistema, elas devem ser compostas por evid√™ncias (quase) arbitr√°rias fornecidas pelo usu√°rio, como para uma fun√ß√£o</font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e para contextos em que</font></font><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgtF4M21nPIW3B7TqiVh4QDpecrFg#MJMATHI-67" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> g </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgtF4M21nPIW3B7TqiVh4QDpecrFg#MJMATHI-67" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8"> g </script>  e <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.279ex" height="2.419ex" viewBox="0 -780.1 550.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgtF4M21nPIW3B7TqiVh4QDpecrFg#MJMATHI-66" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-9"> f </script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para alcan√ßar essa composi√ß√£o, a especifica√ß√£o do conector √© parametrizada atrav√©s das especifica√ß√µes fornecidas pelo usu√°rio para fun√ß√µes remotas. Dessa maneira, os engenheiros podem raciocinar sobre sua arquitetura fornecendo especifica√ß√µes e evid√™ncias para seus componentes e confiar nas especifica√ß√µes do c√≥digo gerado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© o momento, demonstramos esse processo do come√ßo ao fim usando o conector RPC CAmkES especial ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Como os modelos para outros conectores (dataports e eventos) s√£o muito mais simples que os RPCs, n√£o ser√° dif√≠cil expandir o gerador de evid√™ncias para suportar esses conectores, o que permitir√° criar sistemas verificados mais diversos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s o c√≥digo de comunica√ß√£o, o CAmkES cria a configura√ß√£o inicial de controle de acesso para aplicar os limites da arquitetura. Para provar que essas duas descri√ß√µes do sistema - capDL e CAmkES - coincidem, considere a descri√ß√£o do CAmkES como uma abstra√ß√£o da descri√ß√£o do capDL. Usamos a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estrutura testada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anteriormente </font><font style="vertical-align: inherit;">para derivar a autoridade de um objeto sobre outro da descri√ß√£o do capDL. Ent√£o, aumentaremos as evid√™ncias para o n√≠vel da pol√≠tica. Al√©m disso, definimos regras para retirar autoridade entre componentes na descri√ß√£o do CAmkES. Essa prova garante que os objetos capDL representados como um gr√°fico de privil√©gios com objetos agrupados por componentes tenham </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">os mesmos limites entre os grupos que no gr√°fico equivalente do componente CAmkES</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Intuitivamente, essa correspond√™ncia de limites significa que a an√°lise da arquitetura de pol√≠tica da descri√ß√£o do CAmkES salvar√° a pol√≠tica da descri√ß√£o gerada pelo capDL, que, por sua vez, √© garantida para atender aos requisitos de restri√ß√£o de autoridade, integridade e confidencialidade, conforme mencionado anteriormente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por fim, para provar a inicializa√ß√£o correta, o CAmkES usa um inicializador universal que inicia como a primeira tarefa do usu√°rio ap√≥s o carregamento. No seL4, essa primeira (e √∫nica) tarefa do usu√°rio tem acesso a toda a mem√≥ria dispon√≠vel, usando-a para criar objetos e ‚Äúhabilidades‚Äù de acordo com a descri√ß√£o detalhada do capDL, que ele aceita como entrada. Est√° provado que</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O estado ap√≥s a execu√ß√£o do inicializador satisfaz o estado descrito na especifica√ß√£o especificada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Essa prova √© verdadeira para o modelo inicializador exato, mas ainda n√£o no n√≠vel de implementa√ß√£o. </font><font style="vertical-align: inherit;">Comparada √† profundidade do restante da cadeia de evid√™ncias, essa limita√ß√£o pode parecer fraca, mas j√° √© uma evid√™ncia mais formal do que a exigida no n√≠vel mais alto (EAL7) dos crit√©rios gerais de avalia√ß√£o de seguran√ßa.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atualiza√ß√£o de seguran√ßa s√≠smica </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na pr√°tica, √© dif√≠cil garantir o desenvolvimento de um sistema do zero por quest√µes de seguran√ßa; portanto, a capacidade de atualizar software antigo √© crucial para o desenvolvimento de sistemas seguros. Nossa estrutura baseada em seL4 suporta um processo iterativo que chamamos de "atualiza√ß√µes de seguran√ßa s√≠smica", pois um arquiteto regular atualiza edif√≠cios existentes para maior estabilidade s√≠smica. Ilustramos o processo pelo exemplo de adapta√ß√£o gradual da arquitetura de software existente de um helic√≥ptero n√£o tripulado, passando do esquema de teste tradicional para um sistema altamente confi√°vel com teoremas suportados por m√©todos formais. Embora este exemplo seja baseado em um projeto ULB real, ele √© simplificado aqui e n√£o inclui todos os detalhes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A arquitetura original do helic√≥ptero coincide com a arquitetura descrita na Fig. </font><font style="vertical-align: inherit;">3. Sua funcionalidade √© fornecida por dois computadores separados: o computador de navega√ß√£o controla o voo real e o computador de bordo executa tarefas de alto n√≠vel (como se comunicar com uma esta√ß√£o terrestre e navegar pela imagem da c√¢mera). </font><font style="vertical-align: inherit;">A vers√£o inicial do computador de bordo era um aplicativo monol√≠tico para Linux. </font><font style="vertical-align: inherit;">Durante o processo de moderniza√ß√£o, os engenheiros da Boeing aplicaram os m√©todos, ferramentas e componentes fornecidos pelos parceiros do HACMS.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Etapa 1. Virtualiza√ß√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira etapa foi tomar o sistema como ele √© e execut√°-lo em uma m√°quina virtual sobre um hipervisor seguro (veja a Figura 7). Na met√°fora da moderniza√ß√£o s√≠smica, isso corresponde a colocar o sistema em uma base mais m√≥vel. Uma m√°quina virtual sobre o seL4 neste sistema consiste em um componente CAmkES, que inclui um monitor de m√°quina virtual (VMM) e um sistema operacional convidado, neste caso o Linux. O kernel fornece abstra√ß√µes de hardware de virtualiza√ß√£o e o VMM gerencia essas abstra√ß√µes para a m√°quina virtual. O kernel seL4 limita n√£o apenas o sistema operacional convidado, mas tamb√©m o VMM, portanto, voc√™ n√£o precisa confiar na implementa√ß√£o do VMM para fornecer isolamento for√ßado. Uma falha no VMM resultar√° em uma falha do sistema operacional convidado, mas n√£o em todo o sistema. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e55/a43/855/e55a4385528bb6b66ed266100f601341.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 7. Todas as funcionalidades em uma m√°quina virtual</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependendo da configura√ß√£o do sistema, a m√°quina virtual pode ter acesso aos dispositivos por meio de drivers paravirtualizados, drivers de passagem ou ambos. </font><font style="vertical-align: inherit;">No caso de drivers de passagem, os desenvolvedores podem usar o MMU ou IOMMU do sistema para evitar a viola√ß√£o dos limites de isolamento por dispositivos e drivers de hardware no sistema convidado. </font><font style="vertical-align: inherit;">Observe que simplesmente iniciar o sistema em uma m√°quina virtual n√£o adiciona benef√≠cios adicionais de seguran√ßa ou confiabilidade. </font><font style="vertical-align: inherit;">A etapa 1 √© necess√°ria apenas para se preparar para a etapa 2.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Etapa 2. V√°rias m√°quinas virtuais </font></font></h3><br>  O segundo passo da moderniza√ß√£o s√≠smica fortalece os muros existentes.  No software, um desenvolvedor pode aumentar a seguran√ßa e a confiabilidade dividindo o sistema de origem em v√°rios subsistemas, cada um dos quais consiste em uma m√°quina virtual que executa apenas parte do c√≥digo do sistema de origem.  Cada combina√ß√£o VM / VMM √© realizada em um componente CAmkES separado, que introduz isolamento entre diferentes subsistemas, n√£o permitindo que eles se influenciem e, em seguida, permite a coexist√™ncia de diferentes n√≠veis de seguran√ßa. <br><br>  Em geral, as se√ß√µes seguem a arquitetura de software existente, embora se a arquitetura n√£o for suficiente para um isolamento efetivo, pode ser necess√°rio um novo design. <br><br>  Como regra, as se√ß√µes devem interagir entre si, portanto, neste ponto, tamb√©m adicionaremos canais de comunica√ß√£o.  Para garantir a seguran√ßa, √© imperativo que essas interfaces sejam estreitas, limitando a conex√£o entre parti√ß√µes apenas ao que √© absolutamente necess√°rio.  Al√©m disso, os protocolos de interface devem ser eficientes, com um n√∫mero m√≠nimo de mensagens ou volume de dados.  √â fundamental que o seL4 permita controlar e limitar a troca de mem√≥ria entre parti√ß√µes para minimizar a quantidade de dados. <br><br>  Al√©m das m√°quinas virtuais que representam os subsistemas do sistema de origem, tamb√©m extra√≠mos e implementamos componentes para quaisquer recursos compartilhados (como uma interface de rede). <br><br>  Voc√™ pode repetir a etapa 2 at√© alcan√ßarmos os detalhes desejados das se√ß√µes.  O detalhamento correto √© um compromisso entre a resist√™ncia do isolamento, por um lado, e os custos gerais de comunica√ß√£o e reconstru√ß√£o, por outro. <br><br>  Em nosso exemplo, temos tr√™s se√ß√µes: uma m√°quina virtual que implementa as fun√ß√µes de comunica√ß√£o de uma esta√ß√£o terrestre executando o Linux;  outra m√°quina virtual que implementa fun√ß√µes de navega√ß√£o baseada em c√¢mera (tamb√©m executando o Linux);  e um componente de compartilhamento de rede nativo, como mostrado na fig.  8) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a25/bd9/760/a25bd97602571f9b3b485b156767a4ec.jpg"><br>  <i><font color="gray">Fig. 8.</font></i>  <i><font color="gray">Funcionalidade dividida em v√°rias m√°quinas virtuais</font></i> <br><br><h3>  Etapa 3. Componentes Nativos </h3><br>  Quando um sistema √© decomposto em se√ß√µes separadas de uma m√°quina virtual, algumas ou todas as se√ß√µes individuais podem ser reimplementadas como componentes nativos, em vez de m√°quinas virtuais.  Isso reduzir√° significativamente a superf√≠cie de ataque para a mesma funcionalidade.  Uma vantagem adicional de converter um componente em c√≥digo de m√°quina √© reduzir a carga e aumentar a produtividade, removendo o SO convidado e a sobrecarga de execu√ß√£o de c√≥digo e comunica√ß√£o do VMM. <br><br>  Os componentes nativos tamb√©m aumentam o potencial de aplica√ß√£o da verifica√ß√£o formal e outros m√©todos para aumentar a confiabilidade de um componente.  As op√ß√µes s√£o diferentes: da verifica√ß√£o funcional completa do c√≥digo nativo √† gera√ß√£o conjunta de c√≥digo e evid√™ncia, verifica√ß√£o do modelo, uso de linguagens de programa√ß√£o com seguran√ßa de tipo, an√°lise est√°tica ou teste rigoroso tradicional de uma base de c√≥digo menor. <br><br>  Gra√ßas ao isolamento fornecido pelo seL4 e pela arquitetura dos componentes, √© poss√≠vel trabalhar juntos em um sistema de componentes com diferentes n√≠veis de confiabilidade.  Nesse caso, os componentes de baixa confiabilidade n√£o reduzem a confiabilidade geral do sistema, e os desenvolvedores se beneficiam do fato de que voc√™ n√£o precisa se esfor√ßar para verificar esse c√≥digo. <br><br>  Em nosso exemplo, analisaremos a m√°quina virtual para o canal de comunica√ß√£o entre o computador de bordo e a esta√ß√£o terrestre em m√≥dulos nativos.  Nos componentes nativos, as fun√ß√µes de comunica√ß√£o, criptografia e controle (gerenciador de miss√£o) s√£o implementadas.  Deixaremos a c√¢mera e o Wi-Fi na m√°quina virtual como um componente obsoleto n√£o confi√°vel (veja a Fig. 9).  Essa separa√ß√£o se tornou um compromisso entre os esfor√ßos para refazer os subsistemas e os benef√≠cios do uso de componentes nativos em termos de desempenho e confiabilidade. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f10/86b/5fb/f1086b5fbf5aa5bd1c0f8b73e0c2207b.jpg"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">9. Funcionalidade implementada em componentes nativos</font></i> <br><br><h3>  Etapa 4. Confiabilidade do sistema como um todo </h3><br>  Tendo recebido todos os m√≥dulos necess√°rios, daremos o passo final: an√°lise de todo o sistema como um todo, com base na confiabilidade da arquitetura e nos componentes individuais. <br><br>  Na estrutura do HACMS, a comunica√ß√£o, a criptografia e um m√≥dulo de controle s√£o implementados na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">linguagem orientada a objetos</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">provavelmente segura para o tipo Ivory</a> , com aloca√ß√£o de uma quantidade fixa de mem√≥ria no heap.  Sem verifica√ß√£o adicional, o Ivory n√£o nos d√° garantias de corre√ß√£o funcional, mas confia na toler√¢ncia a falhas e na confiabilidade de emerg√™ncia.  Dado o isolamento dos componentes, acreditamos que essas garantias permane√ßam na presen√ßa de componentes n√£o confi√°veis ‚Äã‚Äã(como a m√°quina virtual da c√¢mera). <br><br>  O componente de rede √© implementado no c√≥digo C padr√£o, que consiste no c√≥digo do usu√°rio da plataforma e no c√≥digo da biblioteca existente.  Seu n√≠vel de confiabilidade corresponde ao n√≠vel obtido atrav√©s da implementa√ß√£o cuidadosa de c√≥digos conhecidos.  A confiabilidade pode ser aprimorada sem muita despesa, usando m√©todos como a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">s√≠ntese do driver</a> , al√©m de usar linguagens de tipo seguro como o Ivory.  Em uma an√°lise geral da seguran√ßa do sistema, qualquer comprometimento de um componente de rede afetar√° apenas pacotes de rede.  Como o tr√°fego √© criptografado, esse ataque n√£o comprometer√° a condi√ß√£o das especifica√ß√µes de que apenas os comandos autorizados entram no computador de bordo. <br><br>  A m√°quina virtual da c√¢mera de v√≠deo √© a parte mais fraca do sistema, pois √© executada no sistema Linux e deve conter vulnerabilidades.  Mas a VM est√° isolada; portanto, se os invasores a quebrarem, n√£o poder√£o passar para outros componentes.  A pior coisa que um invasor pode fazer √© enviar os dados incorretos para o componente de controle.  Como no quadroc√≥ptero, esse componente verifica os dados recebidos da c√¢mera.  E ele resistiu com sucesso ao ataque cibern√©tico mencionado no in√≠cio do artigo.  Foi um ataque de ‚Äúcaixa branca‚Äù, onde a equipe de Pentesters teve acesso a todo c√≥digo e documenta√ß√£o, bem como a todos os canais de comunica√ß√£o externos.  Ela recebeu intencionalmente acesso root √† m√°quina virtual da c√¢mera, simulando um ataque bem-sucedido a software desatualizado.  A conten√ß√£o de ataques e a capacidade de defesa contra esse cen√°rio muito poderoso se tornaram um teste valioso de nossos requisitos de seguran√ßa e a identifica√ß√£o de quaisquer suposi√ß√µes perdidas, problemas de interface ou outros problemas de seguran√ßa que a equipe de pesquisa possa n√£o reconhecer. <br><br><h1>  Limita√ß√µes e trabalhos futuros </h1><br>  Este artigo fornece uma vis√£o geral do m√©todo para alcan√ßar n√≠veis muito altos de seguran√ßa para sistemas nos quais o recurso de seguran√ßa √© aplic√°vel por meio da arquitetura de componentes.  Provamos teoremas para o n√≠vel do kernel e sua configura√ß√£o correta, bem como teoremas que garantem que a plataforma do componente defina corretamente os limites de seguran√ßa de acordo com a descri√ß√£o de sua arquitetura e que gere o c√≥digo correto para chamadas de procedimentos remotos.  A conex√£o com a an√°lise de seguran√ßa de alto n√≠vel do sistema permanece informal, e os teoremas do c√≥digo de comunica√ß√£o n√£o cobrem todas as primitivas de comunica√ß√£o fornecidas pela plataforma.  Para obter automaticamente um teorema que cubra todo o sistema do come√ßo ao fim, √© necess√°rio trabalho adicional.  No entanto, nesta fase, √© claro que esta √© uma tarefa vi√°vel. <br><br>  O principal objetivo do trabalho apresentado √© reduzir drasticamente os esfor√ßos de verifica√ß√£o para classes espec√≠ficas de sistemas.  A abordagem puramente arquitetural descrita aqui pode ser estendida a outros sistemas que n√£o o ULB, mas √© claramente limitada pelo fato de poder apenas expressar propriedades determinadas pela arquitetura de componentes do sistema.  Os retornos diminuir√£o se essa arquitetura for alterada durante a execu√ß√£o do programa e se as propriedades forem criticamente dependentes do comportamento de muitos componentes confi√°veis ‚Äã‚Äãou componentes de tamanho muito grande. <br><br>  O primeiro passo para diminuir essas limita√ß√µes √© criar uma biblioteca de componentes pr√©-testados com um alto n√≠vel de confiabilidade para uso como blocos de constru√ß√£o confi√°veis ‚Äã‚Äãnessas arquiteturas.  Essa biblioteca pode incluir padr√µes de seguran√ßa (como desinfec√ß√£o de dados de entrada, filtros de sa√≠da, privacidade e monitores de tempo de execu√ß√£o) potencialmente gerados a partir de especifica√ß√µes de n√≠vel superior, al√©m de componentes de infraestrutura como m√≥dulos criptogr√°ficos reutiliz√°veis, armazenamento de chaves, sistemas de arquivos, Pilhas e drivers de rede altamente confi√°veis.  Se a seguran√ßa depende de mais de um desses componentes, √© necess√°rio justificar a confiabilidade de sua intera√ß√£o e compartilhamento.  Os principais problemas t√©cnicos aqui s√£o discuss√µes sobre simultaneidade e protocolos, bem como fluxo de informa√ß√µes na presen√ßa de componentes confi√°veis.  Apesar dessas limita√ß√µes, o trabalho demonstra o r√°pido desenvolvimento de sistemas reais altamente confi√°veis ‚Äã‚Äãbaseados no seL4.  Atualmente, a cria√ß√£o de tais sistemas √© poss√≠vel a um custo menor do que os testes tradicionais. <br><br><h1>  Aplica√ß√£o: custos trabalhistas </h1><br>  O desenvolvimento do design e c√≥digo do seL4 levou dois anos-homem.  Se adicionarmos todas as evid√™ncias espec√≠ficas do sorotipo, um total de 18 pessoas-ano ser√° obtido para 8700 linhas de c√≥digo para C. Para compara√ß√£o, o desenvolvimento de um microkernel L4Ka :: Pistachio de tamanho compar√°vel da fam√≠lia seL4 levou seis homens-ano e n√£o forneceu um n√≠vel significativo de confiabilidade.  Isso significa uma diferen√ßa na velocidade de desenvolvimento de apenas 3,3 vezes entre o software verificado e o tradicional.  De acordo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">com o m√©todo de avalia√ß√£o de Colbert e Bohm</a> , a certifica√ß√£o segundo os crit√©rios tradicionais da EAL7 para 8700 linhas de c√≥digo C levar√° mais de 45,9 pessoas-ano.  Isso significa que a verifica√ß√£o formal da implementa√ß√£o no n√≠vel bin√°rio j√° √© 2,3 vezes mais barata que o n√≠vel mais alto de certifica√ß√£o, de acordo com os crit√©rios gerais, enquanto fornece confiabilidade significativamente mais alta. <br><br>  Para compara√ß√£o, a abordagem HACMS descrita aqui usa apenas evid√™ncias existentes para cada novo sistema, incluindo evid√™ncias geradas pelas ferramentas.  Assim, o esfor√ßo geral de prova para um sistema que combina com essa abordagem se resume a semanas-homem, n√£o anos, e o teste se resume apenas a validar suposi√ß√µes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437406/">https://habr.com/ru/post/pt437406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437386/index.html">Entrevistas - Look do entrevistador</a></li>
<li><a href="../pt437390/index.html">DPAPI "Segredos". Olhe para o burro</a></li>
<li><a href="../pt437396/index.html">Por que o CarPrice √© impulsionado por intelig√™ncia artificial?</a></li>
<li><a href="../pt437400/index.html">Os gastos com nuvem excederam os gastos com infraestrutura tradicional pela primeira vez - o que significa</a></li>
<li><a href="../pt437402/index.html">Como eu ensinei o rob√¥ a rodar nos v√≠deos do YouTube</a></li>
<li><a href="../pt437408/index.html">802.1x, EX2200, NPS e tudo-tudo-tudo ...</a></li>
<li><a href="../pt437410/index.html">Introdu√ß√£o ao Spring Boot com o Spring Data Mongo</a></li>
<li><a href="../pt437414/index.html">Onde mais de 20 milh√µes de cart√µes de transporte s√£o vulner√°veis ‚Äã‚Äãna R√∫ssia: desmontamos e desenvolvemos o MIFARE Classic</a></li>
<li><a href="../pt437416/index.html">Gerenciamento de capacidade: encontrando o equil√≠brio perfeito</a></li>
<li><a href="../pt437418/index.html">Sobre entidades, DTO, ORM e carga lenta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>