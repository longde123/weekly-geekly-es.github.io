<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐮 💯 🕋 Vue 3 será más rápido ⌚️ 🏭 🤸🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Uno de los eventos más llamativos en el mundo de Frontend este año fue la publicación del próximo repositorio de Vue , parte de la funcionalidad de la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vue 3 será más rápido</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477228/"><img src="https://habrastorage.org/getpro/habr/post_images/06f/124/556/06f124556abe1bec9eb55bccae58e759.png" alt="Captura de pantalla-1"><br>  Uno de los eventos más llamativos en el mundo de Frontend este año fue la publicación del <a href="https://github.com/vuejs/vue-next">próximo</a> repositorio de <a href="https://github.com/vuejs/vue-next">Vue</a> , parte de la funcionalidad de la tercera versión de VueJS.  Este artículo proporciona una descripción general de las nuevas características asesinas de VueJS.  En el momento de la publicación del artículo, el repositorio estaba en estado <i>Pre-Alpha</i> .  Los planes de lanzamiento se pueden ver en <a href="https://github.com/vuejs/vue/projects/6">Roadmap</a> <br><a name="habracut"></a><br><h3>  Antecedentes </h3><br>  En febrero de 2018, Evan You, el creador de Vue.js, <a href="https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf">compartió sus planes</a> para la versión 3 del popular marco: <br><br><ul><li>  Divida la funcionalidad en paquetes para aislar el alcance </li><li>  TypeScript aparece en la base de código </li><li>  Vue 3 será compatible con versiones anteriores de la segunda versión (es decir, no romperá el código anterior) </li><li> Los observadores en la versión 3.0 se basan en Proxy, lo que aumentará la velocidad de representación y eliminará una serie de restricciones impuestas por <code>Object.defineProperty</code> </li><li>  Podrá debutar con los nuevos ganchos <code>renderTracked</code> y <code>renderTriggered</code> </li><li>  Gracias a la introducción de la sacudida del árbol (excluyendo las directivas no utilizadas de la compilación), el tamaño del marco será inferior a 10 kb en forma comprimida </li><li>  Optimización de tragamonedas </li><li>  El rendimiento en vue 3 mejorará 100% </li></ul><br><blockquote>  <i>Las características como los componentes integrados y los asistentes de tiempo de ejecución de directivas (modelo v) ahora se importan a pedido y se pueden sacudir en árbol.</i> <br>  Evan tu </blockquote>  El compilador rastreará la existencia de directivas y las incluirá en la compilación en la etapa de compilación. <br><br>  En el proceso de trabajar en Vue 3, Evan se negó a reescribir componentes en clases y en su lugar implementó una API funcional. <br><br>  Dado que la nueva versión utilizará proxies que no son compatibles con IE, Evan planea crear una compilación separada para IE11.  En total, 4 fases prometen: <br><br><ol><li>  Alpha Phase - etapa de finalización del compilador y ssr-rendering </li><li>  Fase Beta: etapa de finalización de las bibliotecas principales (Vue Router, Vuex, Vue CLI, Vue DevTools) </li><li>  Fase RC - Etapa de prelanzamiento que incluye Vue 2.0 </li><li>  IE11 build </li><li>  Lanzamiento final </li></ol><br>  Evan ha planeado un lanzamiento final para 2019, pero el proyecto aún está en etapa pre-alfa. <br><br><h2>  Vue 3 será más rápido </h2><br>  Gracias a una serie de innovaciones, Vue 3 será 2 veces más rápido que la versión anterior. <br><br><h3>  Observación basada en proxy y reactividad </h3><br>  Una de las principales innovaciones fue el cambio en el mecanismo para monitorear objetos de getters y setters de Object.defineProperty a Proxy.  Ahora Vue puede rastrear la eliminación y la adición de propiedades de objetos reactivos sin usar Vue.set y Vue.delete.  ¡La innovación aumentó la velocidad de renderizado y scripting y redujo el consumo de memoria en 2 veces!  Puede comparar el rendimiento de Vue 2 y Vue 3 <a href="https://gitlab.com/javascript-ninja/demos/vue3-performance-test">descargando el repositorio de Ilya Klimov</a> <br><br>  <i>Comparación de rendimiento de Vue 2 (izquierda) y Vue 3 (etapa pre-alfa, derecha)</i> <br> <a href="https://ibb.co/HBgft8C"><img src="https://habrastorage.org/getpro/habr/post_images/951/84a/318/95184a318fbf8d76a644ef2f23fdb206.png" alt="Captura de pantalla-1"></a> <br><br>  Gracias a los proxies, la reactividad no se perderá al cambiar las manipulaciones de objetos que no se rastrean en Vue 2.  Ahora Vue no recorre recursivamente las propiedades de un objeto para calcular los cambios. <br><br>  Lo que se hace de las promesas: <br><br><ul><li>  Los descendientes y los padres se vuelven a dibujar independientemente </li><li>  El tamaño del Vue 3 disminuyó de 20 kb a 10 kb en forma comprimida </li><li>  TypeScript agregado </li></ul><br>  Otras optimizaciones: <br><br><ul><li>  Vue 3 recordará contenido estático y parcheará solo datos dinámicos </li><li>  Los accesorios estáticos aumentan el alcance </li><li>  Para facilitar el desarrollo, el código Vue 3 se divide en paquetes modulares. </li><li>  El paquete runtime-core se hace multiplataforma </li><li>  En lugar de clases, Evan agregó una función de configuración y ganchos que hacen que el código sea limpio, organizado y reutilizable * </li><li>  Corte de tiempo *.  La ejecución del código JS se corta en pedazos sin bloquear la interacción del usuario con la aplicación </li></ul><br>  <i>Los asteriscos indican la API experimental</i> . <br>  Actualización: más <a href="https://github.com/vuejs/rfcs/issues/89">tarde, Evan decidió abandonar el <i>tiempo.</i></a> <br><br>  Inspirado por el HOC, Reacta Evan implementó funciones de configuración con lógica reutilizable y ganchos personalizados.  A diferencia de los mixins, los ganchos de ciclo de vida no se sobrescriben entre sí. <br><br><h3>  Parche VDom mejorado </h3><br>  <i>Joystick de contenido estático</i> <br><br> <a href="https://ibb.co/b5GXQsq"><img src="https://habrastorage.org/getpro/habr/post_images/9cb/415/c75/9cb415c752e339ffec2664b23cf31ad2.png" alt="Captura de pantalla-2"></a> <br><br>  El contenido estático se mueve fuera del parche VDom al compilar la plantilla.  Vue se inspiró en Svelte para hacer esto: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>Hello, {{name}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Aquí, se pasan el objeto y el contexto <i>modificados</i> .  Si se <i>modifica</i> contiene una variable reactiva, se actualiza en contexto. <br><br><pre> <code class="javascript hljs">p(changed, ctx) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(changed.name) { set_data(t1, ctx.name); } }</code> </pre><br>  En la implementación anterior, el compilador de Vue pasó por todos los nodos, incluidos los estáticos: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> children = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { children.push(h(<span class="hljs-string"><span class="hljs-string">'p'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">class</span></span>: <span class="hljs-string"><span class="hljs-string">'text'</span></span> }, i === <span class="hljs-number"><span class="hljs-number">2</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message : <span class="hljs-string"><span class="hljs-string">'Lorem upsum'</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h(<span class="hljs-string"><span class="hljs-string">'div'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'content'</span></span> }, children) }</code> </pre><br><h4>  Nueva estrategia de compilación de plantillas </h4><br>  En la nueva versión, la plantilla se divide en bloques: <br><br> <a href="https://imgbb.com/"><img src="https://habrastorage.org/getpro/habr/post_images/c0f/a65/25e/c0fa6525eca7377713ef1f6fae4bdb79.png" alt="Selección-002"></a> <br><br><ul><li>  La plantilla se divide en bloques. </li><li>  La estructura de los nodos dentro de cada bloque es completamente estática. </li><li>  Para rastrear valores dinámicos en un bloque, solo se requiere 1 matriz plana, donde se colocan </li></ul><br>  Con la nueva estrategia, el rendimiento depende directamente de la cantidad de contenido dinámico en lugar del tamaño de la plantilla. <br><br><h3>  Vue 3 se adaptará mejor a grandes proyectos </h3><br>  Los proyectos grandes enfrentan los siguientes problemas cuando usan Vue: <br><br><ol><li>  No es compatible con TypeScript </li><li>  Componentes masivos y difíciles de soportar </li><li>  Falta de un patrón simple para reutilizar el código </li></ol><br>  Inicialmente, se planeó agregar clases para admitir TS.  Pero el equipo de Vue tuvo problemas: <br><br><ul><li>  Mezclar accesorios y otros atributos con <i>esto es</i> problemático </li><li>  <a href="https://github.com/tc39/proposal-decorators">Los decoradores para las clases de ES6 en TC39 son</a> inestables </li></ul><br>  El equipo de Evan solicitó ayuda de los expertos de TC39 y descubrió que una implementación similar podría entrar en conflicto con los complementos que mezclan varios accesorios y atributos en el contexto Vue. <br><br>  Potencialmente, estos problemas podrían ser resueltos por los decoradores, pero todavía están en desarrollo. <br><br><h4>  API de composición </h4><br>  El equipo de Vue se inspiró en los ganchos React y decidió crear una API similar.  Es opcional y está en desarrollo y discusión, por lo que algunos nombres pueden cambiar. <br>  El concepto principal de este cambio es organizar el código del componente de manera más lógica, dividiéndolo en bloques semánticos.  Puede leer más sobre la <i>composición API</i> en la <a href="https://vue-composition-api-rfc.netlify.com/">documentación</a> . <br><br>  Un ejemplo de uso de Vue 3. Un componente se divide en funciones lógicas, dentro de las cuales puede usar reactividad y ganchos de ciclo de vida. <br><br>  Importe los nuevos ganchos de la API de composición: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { reactive, computed, onMounted } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@vue/composition-api'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { setup() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { state } = countAnimal(<span class="hljs-string"><span class="hljs-string">"rabbit"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { getType, anotherState } = anotherCount() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { state, getType, anotherState } } }</code> </pre><br>  La función <i>countAnimal</i> tiene propiedades reactivas <i>count, animal</i> y el método de <i>incremento</i> .  Con un contador extraño, el nombre del animal cambia.  El contador comienza cuando se monta el componente. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countAnimal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = reactive({ <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">animal</span></span>: computed(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> state.count % <span class="hljs-number"><span class="hljs-number">2</span></span> ? name : <span class="hljs-string"><span class="hljs-string">'bear'</span></span>) }) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { state.count++; increment() }, <span class="hljs-number"><span class="hljs-number">1000</span></span>) } onMounted(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { increment() }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { state } }</code> </pre><br>  Creamos otra función <i>anotherCount</i> , que también contiene el método de <i>incremento</i> y <i>estado</i> con el contador y el nombre del animal.  El método <i>getType</i> pasa el nombre del animal de la plantilla. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anotherCount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anotherState = reactive({ <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">animal</span></span>: <span class="hljs-string"><span class="hljs-string">'fox'</span></span> }) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name == <span class="hljs-string"><span class="hljs-string">'bear'</span></span> ? <span class="hljs-string"><span class="hljs-string">'slow'</span></span> : <span class="hljs-string"><span class="hljs-string">'fast'</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { anotherState.count+=<span class="hljs-number"><span class="hljs-number">10</span></span>; increment() }, <span class="hljs-number"><span class="hljs-number">1000</span></span>) } onMounted(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { increment() }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { getType, anotherState } }</code> </pre><br>  La plantilla muestra 2 contadores y 2 nombres de animales.  El tipo de carrera varía según el nombre del animal. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>Count {{state.animal}}: {{ state.count }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>{{state.animal}} runs {{getType(state.animal)}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>Another: Count {{anotherState.animal}}: {{ anotherState.count }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Se utilizan nuevos ganchos dentro de la <i>configuración</i> <b>sin romper la</b> antigua API.  Tenga en cuenta que <i>onMounted se</i> refiere a un <i>enlace de</i> ciclo de vida de un solo componente. <br><br>  Esta API tiene varias ventajas: <br><br><ul><li>  Los ganchos de ciclo de vida no se rozan entre sí </li><li>  Fuente clara de propiedades </li><li>  No se crean instancias de componentes adicionales </li></ul><br><h3>  Conclusión </h3><br>  Los cambios más importantes en Vue 3 se enumeran arriba. La mayoría de las mejoras estarán ocultas bajo el capó del código generado por el compilador. <br><br>  Grandes mejoras: <br><br><ul><li>  El código generado es óptimo para el compilador JS </li><li>  Paquete generado más fácil </li><li>  Los componentes padre / hijo se vuelven a dibujar gracias al algoritmo de parche mejorado </li></ul><br>  Vue se ha establecido como uno de los marcos más rápidos y óptimos.  La nueva versión será aún más rápida y fácil.  Vue 3 es ideal para la web móvil y orientada al rendimiento actual.  Los comentarios sobre cambios futuros se pueden dejar en el <a href="https://github.com/vuejs/rfcs">RFC</a> oficial (solicitud de comentarios). <br>  PD: Gracias por corregir errores tipográficos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477228/">https://habr.com/ru/post/477228/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477210/index.html">Mi grito Yaroslavna</a></li>
<li><a href="../477214/index.html">Configuración de la aplicación en Angular. Mejores prácticas</a></li>
<li><a href="../477222/index.html">Fórmulas y Combinadores Perezosos</a></li>
<li><a href="../477224/index.html">"El ruido mata": lo que necesita saber sobre la contaminación acústica</a></li>
<li><a href="../477226/index.html">La elección entre fácil y correcto</a></li>
<li><a href="../477230/index.html">La historia del software educativo: las primeras computadoras personales, juegos educativos y software para estudiantes</a></li>
<li><a href="../477234/index.html">El ratón que puso fin a los hermanos de alambre</a></li>
<li><a href="../477236/index.html">La corte de EE. UU. Permite a los estados devolver la neutralidad de la red</a></li>
<li><a href="../477238/index.html">Además de Karma: por qué se critica el desbordamiento de pila y por qué muchos se quejan de la toxicidad comunitaria</a></li>
<li><a href="../477242/index.html">Cómo elegimos ServiceDesk. Parte 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>