<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ô®Ô∏è üëÉüèΩ ‚ôàÔ∏è Das Problem des h√§ufigen Erstellens und L√∂schens von Objekten in C ++ üë©üèΩ‚Äçüíª üë®üèª‚Äçüî¨ üÜó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Firma, f√ºr die ich arbeite, schreibt ein eigenes Verkehrsfiltersystem und sch√ºtzt das Gesch√§ft damit vor DDoS-Angriffen, Bots, Parsern und vielem ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Problem des h√§ufigen Erstellens und L√∂schens von Objekten in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477404/"><img src="https://habrastorage.org/webt/fb/bt/53/fbbt53apqltc7isyigy39vkizmk.jpeg" alt="Bild"><br><br>  Die Firma, f√ºr die ich arbeite, schreibt ein eigenes Verkehrsfiltersystem und sch√ºtzt das Gesch√§ft damit vor DDoS-Angriffen, Bots, Parsern und vielem mehr.  Das Produkt basiert auf einem Prozess wie <a href="https://en.wikipedia.org/wiki/Reverse_proxy" rel="nofollow">Reverse Proxying</a> , mit dessen Hilfe wir gro√üe Verkehrsmengen in Echtzeit analysieren und letztendlich nur legitime Benutzeranforderungen zulassen und alle b√∂swilligen herausfiltern. <br><br>  Das Hauptmerkmal ist, dass unsere Dienste mit unbegrenztem eingehendem Datenverkehr arbeiten. Daher ist es sehr wichtig, alle Ressourcen von Arbeitsstationen so effizient wie m√∂glich zu nutzen.  Dabei helfen uns viele Entwicklungserfahrungen in modernem C ++, einschlie√ülich der neuesten Standards und einer Reihe von Bibliotheken namens Boost. <br><a name="habracut"></a><br><h3>  Reverse Proxy </h3><br>  Kehren wir zum Reverse-Proxying zur√ºck und sehen, wie Sie es in C ++ und boost.asio implementieren k√∂nnen.  Zun√§chst ben√∂tigen wir zwei Objekte, die als Server- und Clientsitzungen bezeichnet werden.  Die Serversitzung stellt eine Verbindung zum Browser her und h√§lt diese aufrecht, die Clientsitzung stellt eine Verbindung zum Dienst her und h√§lt sie aufrecht.  Sie ben√∂tigen au√üerdem einen Datenstrompuffer, der die Arbeit mit dem Arbeitsspeicher kapselt, in den die Serversitzung vom Socket liest und aus dem die Clientsitzung in den Socket schreibt.  Beispiele f√ºr Server- und Client-Sitzungen finden Sie in der Dokumentation zu boost.asio.  Wie Sie mit dem Stream Buffer arbeiten, erfahren Sie dort. <br><br>  Nachdem wir den Reverse-Proxy-Prototyp aus den Beispielen gesammelt haben, wird klar, dass eine solche Anwendung wahrscheinlich nicht unbegrenzten eingehenden Datenverkehr bedienen wird.  Dann werden wir beginnen, die Komplexit√§t des Codes zu erh√∂hen.  Denken wir an Multithreading, Woker und Pools f√ºr io-Kontexte und vieles mehr.  Insbesondere zu vorzeitigen Optimierungen beim Kopieren des Arbeitsspeichers zwischen Server- und Clientsitzungen. <br><br>  Um welche Art von Speicherkopie handelt es sich?  Tatsache ist, dass beim Filtern der Verkehr nicht immer unver√§ndert √ºbertragen wird.  Schauen Sie sich das folgende Beispiel an: In diesem entfernen wir einen Header und f√ºgen stattdessen zwei hinzu.  Die Anzahl der Benutzerabfragen, f√ºr die √§hnliche Aktionen ausgef√ºhrt werden, steigt mit der Komplexit√§t der Logik innerhalb des Dienstes.  In keinem Fall k√∂nnen Sie in solchen F√§llen sinnlos Daten kopieren!  Wenn sich nur 1% der gesamten Anforderung √§ndert und 99% unver√§ndert bleiben, sollten Sie nur f√ºr diese 1% neuen Speicher zuweisen.  Es wird Ihnen bei diesem boost :: asio :: const_buffer und boost :: asio :: mutable_buffer helfen, mit deren Hilfe Sie mehrere zusammenh√§ngende Speicherbl√∂cke mit einer Entit√§t darstellen k√∂nnen. <br><br>  Userwunsch: <br><br><pre><code class="plaintext hljs">Browser -&gt; Proxy: &gt; POST / HTTP/1.1 &gt; User-Agent: curl/7.29.0 &gt; Host: 127.0.0.1:50080 &gt; Accept: */* &gt; Content-Length: 5888903 &gt; Content-Type: application/x-www-form-urlencoded &gt; ... Proxy -&gt; Service: &gt; POST / HTTP/1.1 &gt; User-Agent: curl/7.29.0 &gt; Host: 127.0.0.1:50080 &gt; Accept: */* &gt; Transfer-Encoding: chunked &gt; Content-Type: application/x-www-form-urlencoded &gt; Expect: 100-continue &gt; ... Service -&gt; Proxy: &lt; HTTP/1.1 200 OK Proxy -&gt; Browser &lt; HTTP/1.1 200 OK</code> </pre> <br><h3>  Das problem </h3><br>  Als Ergebnis haben wir eine fertige Anwendung erhalten, die sich gut skalieren l√§sst und mit allen m√∂glichen Optimierungen ausgestattet ist.  Als wir es in die Produktion einf√ºhrten, waren wir ziemlich froh, wie lange es gut und stabil funktionierte. <br><br>  Im Laufe der Zeit haben wir immer mehr Kunden, mit der Zeit ist auch der Verkehr gewachsen.  Irgendwann waren wir mit dem Problem der mangelnden Leistung bei der Abwehr gro√üer Angriffe konfrontiert.  Nach der Analyse des Dienstes mit dem Dienstprogramm <a href="https://perf.wiki.kernel.org/index.php/Tutorial" rel="nofollow">perf</a> haben wir festgestellt, dass alle Vorg√§nge mit dem Heap unter Last ganz oben stehen.  Dann haben wir eine √§hnliche Situation auf der Teststrecke mit <a href="https://github.com/yandex/yandex-tank" rel="nofollow">Yandex-Panzern</a> und Patronen <a href="https://github.com/yandex/yandex-tank" rel="nofollow">nachgebildet</a> , die auf dem tats√§chlichen Verkehr basieren.  Als wir einen Service √ºber einen <a href="https://software.intel.com/en-us/vtune" rel="nofollow">Verst√§rker</a> ansahen <a href="https://software.intel.com/en-us/vtune" rel="nofollow">,</a> sahen wir das folgende Bild ... <br><br>  Screenshot des Verst√§rkers (woslab): <br><br><img src="https://habrastorage.org/webt/tz/ks/d9/tzksd9oddf-rhcfphtkxkun-pdg.png"><br><br>  Im Screenshot hat der Operator new 67 Sekunden gearbeitet und der Operator delete noch mehr - 97 Sekunden. <br><br>  Diese Situation hat uns ver√§rgert.  Wie kann die Anwendungsverweilzeit im Operator Neu und im Operator L√∂schen verk√ºrzt werden?  Es ist logisch, dass dies getan werden kann, indem konstante Zuordnungen von h√§ufig erstellten und gel√∂schten Objekten auf dem Heap aufgegeben werden.  Wir haben uns f√ºr drei Ans√§tze entschieden.  Zwei davon sind Standard: <a href="https://en.wikipedia.org/wiki/Object_pool_pattern" rel="nofollow">Objektpool</a> und <a href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation" rel="nofollow">Stapelzuordnung</a> .  Clientsitzungen, die beim Start der Anwendung in einem Pool organisiert werden, sind f√ºr den ersten Ansatz gut geeignet.  Der zweite Ansatz wird √ºberall dort verwendet, wo eine Benutzeranforderung von Anfang bis Ende im selben Stapel verarbeitet wird, dh im selben io-Kontext-Handler.  Wir werden darauf nicht n√§her eingehen.  Wir sollten besser √ºber den dritten Ansatz als den komplexesten und interessantesten sprechen.  Dies wird als <a href="https://en.wikipedia.org/wiki/Slab_allocation" rel="nofollow">Plattenzuordnung</a> oder Plattenverteilung bezeichnet. <br><br>  Die Idee der Plattenverteilung ist nicht neu.  Es wurde in Solaris erfunden und implementiert, sp√§ter auf den Linux-Kernel migriert und besteht darin, dass h√§ufig verwendete Objekte desselben Typs leichter im Pool gespeichert werden k√∂nnen.  Wir nehmen das Objekt nur dann aus dem Pool, wenn wir es brauchen, und geben es nach Abschluss der Arbeiten wieder zur√ºck.  Keine Anrufe an Betreiber neu und Betreiber l√∂schen!  Dar√ºber hinaus ein Minimum an Initialisierung.  Im Plattenkern wird die Verteilung f√ºr Semaphoren, Dateideskriptoren, Prozesse und Threads verwendet.  In unserem Fall war es perfekt f√ºr Server- und Client-Sitzungen sowie f√ºr alles, was in ihnen enthalten ist. <br><br>  Diagramm (Plattenverteilung): <br><br><img src="https://habrastorage.org/webt/zb/k2/u8/zbk2u8m0jexhso3nmkttzxkvrw0.png"><br><br>  Zus√§tzlich zu der Tatsache, dass sich die Plattenzuordnungen im Kernel befinden, sind ihre Implementierungen auch im Benutzerbereich vorhanden.  Es gibt nur wenige von ihnen, und diejenigen, die sich aktiv entwickeln, sind im Allgemeinen wenige.  Wir haben uns f√ºr eine Bibliothek namens <a href="https://github.com/tarantool/small" rel="nofollow">libsmall entschieden</a> , die Teil von <a href="https://github.com/tarantool/tarantool" rel="nofollow">tarantool ist</a> .  Es hat alles was Sie brauchen. <br><br><ul><li>  small :: allocator </li><li>  small :: slab_cache (thread local) </li><li>  klein :: platte </li><li>  klein :: Arena </li><li>  small :: quota </li></ul><br>  Die small :: slab-Struktur ist ein Pool mit einem bestimmten Objekttyp.  Die Struktur small :: slab_cache ist ein Cache, der verschiedene Listen von Pools mit einem bestimmten Objekttyp enth√§lt.  Die Struktur small :: allocator ist ein Code, der den erforderlichen Cache ausw√§hlt, in dem nach einem geeigneten Pool gesucht wird, in dem das angeforderte Objekt verteilt wird.  Was small :: arena- und small :: quota-Objekte tun, wird aus den folgenden Beispielen deutlich. <br><br><h3>  Wickeln </h3><br>  Die libsmall-Bibliothek ist in C und nicht in C ++ geschrieben, daher mussten wir mehrere Wrapper f√ºr die transparente Integration in die Standard-C ++ - Bibliothek entwickeln. <br><br><ul><li>  variti :: slab_allocator </li><li>  variti :: platte </li><li>  variti :: thread_local_slab </li><li>  variti :: slab_allocate_shared </li></ul><br>  Die Klasse variti :: slab_allocator implementiert die Mindestanforderungen, die der Standard beim Schreiben eines eigenen Allokators festlegt.  In variti :: slab-Klassen ist die gesamte Arbeit mit der libsmall-Bibliothek gekapselt.  Warum wird variti :: thread_local_slab ben√∂tigt?  Tatsache ist, dass Verteilungs-Slab-Caches Thread-lokale Objekte sind.  Dies bedeutet, dass jeder Thread einen eigenen Satz von Caches hat.  Dies geschieht, um die Anzahl der gesperrten Vorg√§nge beim Verteilen eines neuen Objekts auf Null zu reduzieren.  Daher platzieren wir im Speicher jedes Threads unsere Instanz der Klasse variti :: slab, und der Zugriff darauf wird mithilfe des Wrappers variti :: thread_local_slab gesteuert.  Ich werde Ihnen sp√§ter etwas √ºber die Template-Funktion variti :: slab_allocate_shared erz√§hlen. <br><br>  In der Klasse variti :: slab_allocator ist alles ganz einfach.  Er hat die F√§higkeit, sich von einem Typ zu einem anderen zu binden, zum Beispiel von der Leere zur Saibling.  Interessanterweise k√∂nnen Sie auf die Pr√§valenz von nullptr bis zur Ausnahme std :: bad_alloc achten, wenn der Arbeitsspeicher auf der Verteilungsplatte knapp wird.  Der Rest leitet Anrufe innerhalb des Wrappers variti :: thread_local_slab weiter. <br><br>  Snippet (slab_allocator.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab_allocator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = T; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> pointer = value_type*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_pointer = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value_type*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> reference = value_type&amp;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_reference = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value_type&amp;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebind</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> other = slab_allocator&lt;U&gt;; }; slab_allocator() {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; slab_allocator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> slab_allocator&lt;U&gt;&amp; other) {} <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(thread_local_slab::allocate(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) * n)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p &amp;&amp; n) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_alloc(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ thread_local_slab::deallocate(p, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) * n); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab_allocator</span></span></span><span class="hljs-class">&lt;void&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> pointer = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_pointer = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebind</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> slab_allocator&lt;U&gt; other; }; };</code> </pre> <br>  Mal sehen, wie der Konstruktor und Destruktor variti :: slab implementiert wird.  Im Konstruktor weisen wir allen Objekten insgesamt nicht mehr als 1 GB Speicher zu.  Die Gr√∂√üe jedes Pools √ºberschreitet in unserem Fall 1 MiB nicht.  Das kleinste Objekt, das wir verteilen k√∂nnen, ist 2 Bytes gro√ü (in der Tat wird es von libsmall auf das erforderliche Minimum erh√∂ht - 8 Bytes).  Die verbleibenden Objekte, die √ºber unsere Plattenverteilung verf√ºgbar sind, sind ein Vielfaches von zwei (festgelegt durch die Konstante 2.f).  Insgesamt k√∂nnen Sie Objekte der Gr√∂√üe 8, 16, 32 usw. verteilen.  Wenn das angeforderte Objekt eine Gr√∂√üe von 24 Byte hat, tritt ein Overhead aus dem Speicher auf.  Die Verteilung gibt dieses Objekt an Sie zur√ºck, es wird jedoch in einem Pool abgelegt, der einem Objekt mit einer Gr√∂√üe von 32 Byte entspricht.  Die verbleibenden 8 Bytes sind inaktiv. <br><br>  Snippet (slab.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_to_virt_p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(p) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_to_virt_n</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">virt_to_phys_p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(p) - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">virt_to_phys_n</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::<span class="hljs-function"><span class="hljs-function">id&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_thread_id</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id*&gt;(p); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> noncopyable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: slab() { small::quota_init(&amp; quota_, <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); small::slab_arena_create(&amp;arena_, &amp; quota_, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>, MAP_PRIVATE); small::slab_cache_create(&amp;cache_, &amp;arena_); small::allocator_create(&amp;allocator_, &amp;cache_, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>); } ~slab() { small::allocator_destroy(&amp;allocator_); small::slab_cache_destroy(&amp;cache_); small::slab_arena_destroy(&amp;arena_); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_n = virt_to_phys_n(n); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_p = small::<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(&amp;allocator_, phys_n); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!phys_p) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; phys_thread_id(phys_p) = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> phys_to_virt_p(phys_p); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_p = virt_to_phys_p(<span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(p)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_n = virt_to_phys_n(n); assert(phys_thread_id(phys_p) == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id()); small::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(&amp;allocator_, phys_p, phys_n); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: small::quota quota_; small::slab_arena arena_; small::slab_cache cache_; small::allocator allocator_; };</code> </pre> <br>  Alle diese Einschr√§nkungen gelten f√ºr eine bestimmte Instanz der Klasse variti :: slab.  Da jeder Thread einen eigenen Thread hat (denken Sie an thread local), betr√§gt das Gesamtlimit f√ºr den Prozess nicht 1 GB, sondern ist direkt proportional zur Anzahl der Threads, die die Plattenverteilung verwenden. <br><br>  Diagramm (std :: thread :: id): <br><br><img src="https://habrastorage.org/webt/_8/65/jy/_865jyoyp0qqoz7-tgsgmjsc9b0.png"><br><br>  Durch die Verwendung von thread local k√∂nnen Sie einerseits die Arbeit der Plattenverteilung in einer Multithread-Anwendung beschleunigen und andererseits die Architektur der asynchronen Anwendung erheblich einschr√§nken.  Sie m√ºssen ein Objekt im selben Stream anfordern und zur√ºckgeben.  Dies im Rahmen von boost.asio zu tun, ist manchmal sehr problematisch.  Um offensichtlich fehlerhafte Situationen zu verfolgen, platzieren wir am Anfang jedes Objekts den Bezeichner des Streams, in dem die Methode allocate aufgerufen wird.  Diese Kennung wird dann in der Freigabemethode √ºberpr√ºft.  Die Helfer phys_to_virt_p und virt_to_phys_p helfen dabei. <br><br>  Snippet (thread_local_slab.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_local_slab</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> noncopyable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finalize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; };</code> </pre> <br>  Snippet (thread_local_slab.cpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">thread_local</span></span> slab* slab_; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::initialize() { slab_ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> slab(slab_cfg_); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::finalize() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> slab_; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* thread_local_slab::<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> slab_-&gt;<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(n); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) { slab_-&gt;<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(p, n); }</code> </pre> <br>  Wenn die Kontrolle √ºber den Stream verloren geht (beim √úbertragen eines Objekts zwischen verschiedenen io-Kontexten), erm√∂glicht ein intelligenter Zeiger die korrekte Freigabe des Objekts.  Alles, was er tut, ist, das Objekt zu verteilen, sich an seinen io-Kontext zu erinnern und es dann in std :: shared_ptr mit einem benutzerdefinierten Teiler zu verpacken, der das Objekt nicht sofort an die Verteilung zur√ºckgibt, sondern im zuvor gespeicherten io-Kontext.  Dies funktioniert gut, wenn jeder io-Kontext auf einem einzelnen Thread ausgef√ºhrt wird.  Ansonsten ist dieser Ansatz leider nicht anwendbar. <br><br>  Snippet (slab_helper.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Allocator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; slab_allocate_shared(Allocator allocator, Args... args) { T* p = allocator.allocate(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)p) T(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; ptr(p, [allocator](T* p) { p-&gt;~T(); allocator.deallocate(p); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Allocator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; slab_allocate_shared(Allocator allocator, boost::asio::io_service* io, Args... args) { T* p = allocator.allocate(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)p) T(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; ptr(p, [allocator, io](T* p) { io-&gt;post([allocator, p]() { p-&gt;~T(); allocator.deallocate(p); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; };</code> </pre> <br><h3>  L√∂sung </h3><br>  Nachdem die libsmall-Wrapping-Arbeit abgeschlossen war, haben wir zuerst die Chun-Allokatoren im Stream-Puffer auf die Platte verschoben.  Das war ziemlich einfach.  Nachdem wir ein positives Ergebnis erhalten hatten, haben wir zun√§chst den Stream-Puffer selbst und dann alle Objekte in den Server- und Client-Sitzungen mit Plattenzuordnungen versehen. <br><br><ul><li>  variti :: chunk </li><li>  variti :: streambuf </li><li>  variti :: server_session </li><li>  variti :: client_session </li></ul><br>  Gleichzeitig mussten zus√§tzliche Probleme gel√∂st werden, n√§mlich die √úbertragung einfacher Objekte, zusammengesetzter Objekte und Sammlungen an Plattenzuordner.  Und wenn es bei den ersten beiden Klassen von Objekten keine ernsthaften Schwierigkeiten gab (zusammengesetzte Objekte werden auf einfache reduziert), stie√üen wir bei der √úbersetzung von Sammlungen auf ernsthafte Schwierigkeiten. <br><br><ul><li>  std :: liste </li><li>  std :: deque </li><li>  std :: vector </li><li>  std :: string </li><li>  std :: map </li><li>  std :: unordered_map </li></ul><br>  Eine der Haupteinschr√§nkungen beim Arbeiten mit der Plattenverteilung besteht darin, dass die Anzahl der Objekte unterschiedlicher Typen nicht zu gro√ü sein sollte (je kleiner, desto besser).  In diesem Zusammenhang fallen einige Sammlungen m√∂glicherweise unter das Konzept der Plattenverteiler, w√§hrend andere dies m√∂glicherweise nicht tun. <br><br>  F√ºr die Platte std :: list funktionieren die Zuweiser hervorragend.  Diese Auflistung wird intern mithilfe einer verkn√ºpften Liste implementiert, deren Elemente jeweils eine feste Gr√∂√üe haben.  Mit dem Hinzuf√ºgen neuer Daten zur std :: -Liste in der Plattenverteilung werden daher keine neuen Objekttypen angezeigt.  Die oben angegebene Bedingung ist erf√ºllt!  Die std :: map ist √§hnlich aufgebaut.  Der einzige Unterschied besteht darin, dass es sich nicht um eine verkn√ºpfte Liste handelt, sondern um einen Baum. <br><br>  Bei std :: deque sind die Dinge komplizierter.  Diese Sammlung wird durch einen zusammenh√§ngenden Speicherblock implementiert, der Zeiger auf Bl√∂cke enth√§lt.  W√§hrend die Bl√∂cke ziemlich genau sind, verh√§lt sich std :: deque genauso wie std :: list, aber wenn sie enden, wird derselbe Speicherblock neu verteilt.  Aus der Sicht von Plattenzuordnern ist jede Speicherumverteilung ein Objekt mit einem neuen Typ.  Die Anzahl der Objekte, die der Sammlung direkt hinzugef√ºgt werden, h√§ngt vom Benutzer ab und kann unkontrolliert zunehmen.  Diese Situation ist nicht akzeptabel, daher haben wir entweder die Gr√∂√üe von std :: deque vorl√§ufig begrenzt, wo dies m√∂glich war, oder std :: list vorgezogen. <br><br>  Wenn wir std :: vector und std :: string nehmen, sind sie noch komplizierter.  Die Implementierung dieser Auflistungen √§hnelt etwas der von std :: deque, nur dass ihr kontinuierlicher Speicherblock erheblich schneller w√§chst.  Wir haben std :: vector und std :: string durch std :: deque und im schlimmsten Fall durch std :: list ersetzt.  Ja, wir haben an Funktionalit√§t und sogar an Leistung verloren, aber dies wirkte sich weniger auf das endg√ºltige Bild aus als auf die Optimierungen, f√ºr die alles gedacht war. <br><br>  Wir haben genau dasselbe mit std :: unordered_map gemacht und es zugunsten der selbst geschriebenen variti :: flat_map aufgegeben, die mit std :: deque implementiert wurde.  Gleichzeitig haben wir die h√§ufig verwendeten Schl√ºssel einfach in separaten Variablen zwischengespeichert, wie dies beispielsweise bei den HTTP-Anforderungs-Headern in nginx der Fall ist. <br><br><h3>  Fazit </h3><br>  Nachdem die Server- und Client-Sitzungen vollst√§ndig an die Plattenzuweiser √ºbertragen wurden, haben wir die Zeit f√ºr die Arbeit mit einer Gruppe um mehr als das Eineinhalbfache reduziert. <br><br>  Screenshot des Verst√§rkers (coldslab): <br><br><img src="https://habrastorage.org/webt/ls/yx/l_/lsyxl_b6xngl5xap-t5erwn4now.png"><br><br>  Im Screenshot hat der Operator new 32 Sekunden gearbeitet und der Operator delete - 24 Sekunden.  Zu diesem Zeitpunkt wurden weitere Funktionen f√ºr die Arbeit mit dem Heap hinzugef√ºgt: smalloc - 21 Sekunden, mslab_alloc - 37 Sekunden, smfree - 8 Sekunden, mslab_free - 21 Sekunden.  Insgesamt 143 Sekunden gegen√ºber 161 Sekunden. <br><br>  Diese Messungen wurden jedoch sofort nach dem Start des Dienstes durchgef√ºhrt, ohne die Caches in der Plattenverteilung zu initialisieren.  Nach mehrmaligem Abfeuern aus einem Yandex-Panzer verbesserte sich das Gesamtbild. <br><br>  Screenshot des Verst√§rkers (hotslab): <br><br><img src="https://habrastorage.org/webt/gc/zj/kt/gczjkt5r8yedhniu5afswdjqk2y.png"><br><br>  Im Screenshot arbeitete der Operator new 20 Sekunden, smalloc - 16 Sekunden, mslab_alloc - 27 Sekunden, operator delete - 16 Sekunden, smfree - 7 Sekunden, mslab_free - 17 Sekunden.  Insgesamt 103 Sekunden gegen 161 Sekunden. <br><br>  Ma√ütabelle: <br><br><pre> <code class="plaintext hljs"> woslab coldslab hotslab operator new 67s 32s 20s smalloc - 21s 16s mslab_alloc - 37s 27s operator delete 94s 24s 16s smfree - 8s 7s mslab_free - 21s 17s summary 161s 143s 103s</code> </pre><br>  Im wirklichen Leben sollte das Ergebnis sogar noch besser sein, da Plattenzuweiser nicht nur das Problem der langen Speicherzuweisung und -freigabe l√∂sen, sondern auch die Fragmentierung reduzieren.  Ohne Platte sollte sich der Vorgang von Operator Neu und Operator L√∂schen im Laufe der Zeit nur verlangsamen.  Bei Platten bleibt sie immer auf dem gleichen Niveau. <br><br>  Wie wir sehen k√∂nnen, l√∂sen Plattenzuordner erfolgreich das Speicherzuordnungsproblem h√§ufig verwendeter Objekte.  Achten Sie darauf, wenn das Problem des h√§ufigen Erstellens und Entfernens von Objekten f√ºr Sie relevant ist.  Vergessen Sie jedoch nicht die Einschr√§nkungen, die sie der Architektur Ihrer Anwendung auferlegen!  Nicht alle komplexen Objekte k√∂nnen einfach in die Plattenverteilung eingef√ºgt werden.  Manchmal muss man viel aufgeben!  Je komplexer die Architektur Ihrer Anwendung ist, desto h√§ufiger m√ºssen Sie daf√ºr sorgen, dass das Objekt im Hinblick auf Multithreading wieder in den richtigen Cache gestellt wird.  Es kann einfach sein, wenn Sie die Anwendungsarchitektur unter Ber√ºcksichtigung der Verwendung von Plattenzuordnern sofort ausgearbeitet haben, aber es wird definitiv Schwierigkeiten bereiten, wenn Sie sich f√ºr eine sp√§tere Integration entscheiden. <br><br><h3>  App </h3><br>  Hier geht es zum Quellcode! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477404/">https://habr.com/ru/post/de477404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477390/index.html">Debuggen von Netzwerkverz√∂gerungen in Kubernetes</a></li>
<li><a href="../de477392/index.html">Mikrofon √∂ffnen: Backend. Wir laden Referenten ein</a></li>
<li><a href="../de477396/index.html">Wie melde ich mich f√ºr einen Kurs an und ... gehe zum Ende</a></li>
<li><a href="../de477400/index.html">√úber den Beruf des Produktmanagers: Wie erreicht man das Ideal?</a></li>
<li><a href="../de477402/index.html">Bereitstellen des Keras Deep Learning-Modells als Python-Webanwendung</a></li>
<li><a href="../de477406/index.html">Technischer Support und Support. Gute Recherche auf dem Arbeitsmarkt und bei den Geh√§ltern. Was hat sich in 2 Jahren ver√§ndert?</a></li>
<li><a href="../de477408/index.html">JavaFX Tutorial: Erweiterte Layouts</a></li>
<li><a href="../de477414/index.html">Data Engineer - Der sexyste Beruf des 21. Jahrhunderts</a></li>
<li><a href="../de477416/index.html">Wann ist es sch√§dlich f√ºr Hash</a></li>
<li><a href="../de477418/index.html">Dreiseitige Refraktion in drei Schritten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>