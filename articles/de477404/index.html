<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♨️ 👃🏽 ♈️ Das Problem des häufigen Erstellens und Löschens von Objekten in C ++ 👩🏽‍💻 👨🏻‍🔬 🆗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Firma, für die ich arbeite, schreibt ein eigenes Verkehrsfiltersystem und schützt das Geschäft damit vor DDoS-Angriffen, Bots, Parsern und vielem ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Problem des häufigen Erstellens und Löschens von Objekten in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477404/"><img src="https://habrastorage.org/webt/fb/bt/53/fbbt53apqltc7isyigy39vkizmk.jpeg" alt="Bild"><br><br>  Die Firma, für die ich arbeite, schreibt ein eigenes Verkehrsfiltersystem und schützt das Geschäft damit vor DDoS-Angriffen, Bots, Parsern und vielem mehr.  Das Produkt basiert auf einem Prozess wie <a href="https://en.wikipedia.org/wiki/Reverse_proxy" rel="nofollow">Reverse Proxying</a> , mit dessen Hilfe wir große Verkehrsmengen in Echtzeit analysieren und letztendlich nur legitime Benutzeranforderungen zulassen und alle böswilligen herausfiltern. <br><br>  Das Hauptmerkmal ist, dass unsere Dienste mit unbegrenztem eingehendem Datenverkehr arbeiten. Daher ist es sehr wichtig, alle Ressourcen von Arbeitsstationen so effizient wie möglich zu nutzen.  Dabei helfen uns viele Entwicklungserfahrungen in modernem C ++, einschließlich der neuesten Standards und einer Reihe von Bibliotheken namens Boost. <br><a name="habracut"></a><br><h3>  Reverse Proxy </h3><br>  Kehren wir zum Reverse-Proxying zurück und sehen, wie Sie es in C ++ und boost.asio implementieren können.  Zunächst benötigen wir zwei Objekte, die als Server- und Clientsitzungen bezeichnet werden.  Die Serversitzung stellt eine Verbindung zum Browser her und hält diese aufrecht, die Clientsitzung stellt eine Verbindung zum Dienst her und hält sie aufrecht.  Sie benötigen außerdem einen Datenstrompuffer, der die Arbeit mit dem Arbeitsspeicher kapselt, in den die Serversitzung vom Socket liest und aus dem die Clientsitzung in den Socket schreibt.  Beispiele für Server- und Client-Sitzungen finden Sie in der Dokumentation zu boost.asio.  Wie Sie mit dem Stream Buffer arbeiten, erfahren Sie dort. <br><br>  Nachdem wir den Reverse-Proxy-Prototyp aus den Beispielen gesammelt haben, wird klar, dass eine solche Anwendung wahrscheinlich nicht unbegrenzten eingehenden Datenverkehr bedienen wird.  Dann werden wir beginnen, die Komplexität des Codes zu erhöhen.  Denken wir an Multithreading, Woker und Pools für io-Kontexte und vieles mehr.  Insbesondere zu vorzeitigen Optimierungen beim Kopieren des Arbeitsspeichers zwischen Server- und Clientsitzungen. <br><br>  Um welche Art von Speicherkopie handelt es sich?  Tatsache ist, dass beim Filtern der Verkehr nicht immer unverändert übertragen wird.  Schauen Sie sich das folgende Beispiel an: In diesem entfernen wir einen Header und fügen stattdessen zwei hinzu.  Die Anzahl der Benutzerabfragen, für die ähnliche Aktionen ausgeführt werden, steigt mit der Komplexität der Logik innerhalb des Dienstes.  In keinem Fall können Sie in solchen Fällen sinnlos Daten kopieren!  Wenn sich nur 1% der gesamten Anforderung ändert und 99% unverändert bleiben, sollten Sie nur für diese 1% neuen Speicher zuweisen.  Es wird Ihnen bei diesem boost :: asio :: const_buffer und boost :: asio :: mutable_buffer helfen, mit deren Hilfe Sie mehrere zusammenhängende Speicherblöcke mit einer Entität darstellen können. <br><br>  Userwunsch: <br><br><pre><code class="plaintext hljs">Browser -&gt; Proxy: &gt; POST / HTTP/1.1 &gt; User-Agent: curl/7.29.0 &gt; Host: 127.0.0.1:50080 &gt; Accept: */* &gt; Content-Length: 5888903 &gt; Content-Type: application/x-www-form-urlencoded &gt; ... Proxy -&gt; Service: &gt; POST / HTTP/1.1 &gt; User-Agent: curl/7.29.0 &gt; Host: 127.0.0.1:50080 &gt; Accept: */* &gt; Transfer-Encoding: chunked &gt; Content-Type: application/x-www-form-urlencoded &gt; Expect: 100-continue &gt; ... Service -&gt; Proxy: &lt; HTTP/1.1 200 OK Proxy -&gt; Browser &lt; HTTP/1.1 200 OK</code> </pre> <br><h3>  Das problem </h3><br>  Als Ergebnis haben wir eine fertige Anwendung erhalten, die sich gut skalieren lässt und mit allen möglichen Optimierungen ausgestattet ist.  Als wir es in die Produktion einführten, waren wir ziemlich froh, wie lange es gut und stabil funktionierte. <br><br>  Im Laufe der Zeit haben wir immer mehr Kunden, mit der Zeit ist auch der Verkehr gewachsen.  Irgendwann waren wir mit dem Problem der mangelnden Leistung bei der Abwehr großer Angriffe konfrontiert.  Nach der Analyse des Dienstes mit dem Dienstprogramm <a href="https://perf.wiki.kernel.org/index.php/Tutorial" rel="nofollow">perf</a> haben wir festgestellt, dass alle Vorgänge mit dem Heap unter Last ganz oben stehen.  Dann haben wir eine ähnliche Situation auf der Teststrecke mit <a href="https://github.com/yandex/yandex-tank" rel="nofollow">Yandex-Panzern</a> und Patronen <a href="https://github.com/yandex/yandex-tank" rel="nofollow">nachgebildet</a> , die auf dem tatsächlichen Verkehr basieren.  Als wir einen Service über einen <a href="https://software.intel.com/en-us/vtune" rel="nofollow">Verstärker</a> ansahen <a href="https://software.intel.com/en-us/vtune" rel="nofollow">,</a> sahen wir das folgende Bild ... <br><br>  Screenshot des Verstärkers (woslab): <br><br><img src="https://habrastorage.org/webt/tz/ks/d9/tzksd9oddf-rhcfphtkxkun-pdg.png"><br><br>  Im Screenshot hat der Operator new 67 Sekunden gearbeitet und der Operator delete noch mehr - 97 Sekunden. <br><br>  Diese Situation hat uns verärgert.  Wie kann die Anwendungsverweilzeit im Operator Neu und im Operator Löschen verkürzt werden?  Es ist logisch, dass dies getan werden kann, indem konstante Zuordnungen von häufig erstellten und gelöschten Objekten auf dem Heap aufgegeben werden.  Wir haben uns für drei Ansätze entschieden.  Zwei davon sind Standard: <a href="https://en.wikipedia.org/wiki/Object_pool_pattern" rel="nofollow">Objektpool</a> und <a href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation" rel="nofollow">Stapelzuordnung</a> .  Clientsitzungen, die beim Start der Anwendung in einem Pool organisiert werden, sind für den ersten Ansatz gut geeignet.  Der zweite Ansatz wird überall dort verwendet, wo eine Benutzeranforderung von Anfang bis Ende im selben Stapel verarbeitet wird, dh im selben io-Kontext-Handler.  Wir werden darauf nicht näher eingehen.  Wir sollten besser über den dritten Ansatz als den komplexesten und interessantesten sprechen.  Dies wird als <a href="https://en.wikipedia.org/wiki/Slab_allocation" rel="nofollow">Plattenzuordnung</a> oder Plattenverteilung bezeichnet. <br><br>  Die Idee der Plattenverteilung ist nicht neu.  Es wurde in Solaris erfunden und implementiert, später auf den Linux-Kernel migriert und besteht darin, dass häufig verwendete Objekte desselben Typs leichter im Pool gespeichert werden können.  Wir nehmen das Objekt nur dann aus dem Pool, wenn wir es brauchen, und geben es nach Abschluss der Arbeiten wieder zurück.  Keine Anrufe an Betreiber neu und Betreiber löschen!  Darüber hinaus ein Minimum an Initialisierung.  Im Plattenkern wird die Verteilung für Semaphoren, Dateideskriptoren, Prozesse und Threads verwendet.  In unserem Fall war es perfekt für Server- und Client-Sitzungen sowie für alles, was in ihnen enthalten ist. <br><br>  Diagramm (Plattenverteilung): <br><br><img src="https://habrastorage.org/webt/zb/k2/u8/zbk2u8m0jexhso3nmkttzxkvrw0.png"><br><br>  Zusätzlich zu der Tatsache, dass sich die Plattenzuordnungen im Kernel befinden, sind ihre Implementierungen auch im Benutzerbereich vorhanden.  Es gibt nur wenige von ihnen, und diejenigen, die sich aktiv entwickeln, sind im Allgemeinen wenige.  Wir haben uns für eine Bibliothek namens <a href="https://github.com/tarantool/small" rel="nofollow">libsmall entschieden</a> , die Teil von <a href="https://github.com/tarantool/tarantool" rel="nofollow">tarantool ist</a> .  Es hat alles was Sie brauchen. <br><br><ul><li>  small :: allocator </li><li>  small :: slab_cache (thread local) </li><li>  klein :: platte </li><li>  klein :: Arena </li><li>  small :: quota </li></ul><br>  Die small :: slab-Struktur ist ein Pool mit einem bestimmten Objekttyp.  Die Struktur small :: slab_cache ist ein Cache, der verschiedene Listen von Pools mit einem bestimmten Objekttyp enthält.  Die Struktur small :: allocator ist ein Code, der den erforderlichen Cache auswählt, in dem nach einem geeigneten Pool gesucht wird, in dem das angeforderte Objekt verteilt wird.  Was small :: arena- und small :: quota-Objekte tun, wird aus den folgenden Beispielen deutlich. <br><br><h3>  Wickeln </h3><br>  Die libsmall-Bibliothek ist in C und nicht in C ++ geschrieben, daher mussten wir mehrere Wrapper für die transparente Integration in die Standard-C ++ - Bibliothek entwickeln. <br><br><ul><li>  variti :: slab_allocator </li><li>  variti :: platte </li><li>  variti :: thread_local_slab </li><li>  variti :: slab_allocate_shared </li></ul><br>  Die Klasse variti :: slab_allocator implementiert die Mindestanforderungen, die der Standard beim Schreiben eines eigenen Allokators festlegt.  In variti :: slab-Klassen ist die gesamte Arbeit mit der libsmall-Bibliothek gekapselt.  Warum wird variti :: thread_local_slab benötigt?  Tatsache ist, dass Verteilungs-Slab-Caches Thread-lokale Objekte sind.  Dies bedeutet, dass jeder Thread einen eigenen Satz von Caches hat.  Dies geschieht, um die Anzahl der gesperrten Vorgänge beim Verteilen eines neuen Objekts auf Null zu reduzieren.  Daher platzieren wir im Speicher jedes Threads unsere Instanz der Klasse variti :: slab, und der Zugriff darauf wird mithilfe des Wrappers variti :: thread_local_slab gesteuert.  Ich werde Ihnen später etwas über die Template-Funktion variti :: slab_allocate_shared erzählen. <br><br>  In der Klasse variti :: slab_allocator ist alles ganz einfach.  Er hat die Fähigkeit, sich von einem Typ zu einem anderen zu binden, zum Beispiel von der Leere zur Saibling.  Interessanterweise können Sie auf die Prävalenz von nullptr bis zur Ausnahme std :: bad_alloc achten, wenn der Arbeitsspeicher auf der Verteilungsplatte knapp wird.  Der Rest leitet Anrufe innerhalb des Wrappers variti :: thread_local_slab weiter. <br><br>  Snippet (slab_allocator.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab_allocator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = T; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> pointer = value_type*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_pointer = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value_type*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> reference = value_type&amp;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_reference = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value_type&amp;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebind</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> other = slab_allocator&lt;U&gt;; }; slab_allocator() {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; slab_allocator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> slab_allocator&lt;U&gt;&amp; other) {} <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(thread_local_slab::allocate(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) * n)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p &amp;&amp; n) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_alloc(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ thread_local_slab::deallocate(p, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) * n); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab_allocator</span></span></span><span class="hljs-class">&lt;void&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> pointer = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_pointer = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebind</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> slab_allocator&lt;U&gt; other; }; };</code> </pre> <br>  Mal sehen, wie der Konstruktor und Destruktor variti :: slab implementiert wird.  Im Konstruktor weisen wir allen Objekten insgesamt nicht mehr als 1 GB Speicher zu.  Die Größe jedes Pools überschreitet in unserem Fall 1 MiB nicht.  Das kleinste Objekt, das wir verteilen können, ist 2 Bytes groß (in der Tat wird es von libsmall auf das erforderliche Minimum erhöht - 8 Bytes).  Die verbleibenden Objekte, die über unsere Plattenverteilung verfügbar sind, sind ein Vielfaches von zwei (festgelegt durch die Konstante 2.f).  Insgesamt können Sie Objekte der Größe 8, 16, 32 usw. verteilen.  Wenn das angeforderte Objekt eine Größe von 24 Byte hat, tritt ein Overhead aus dem Speicher auf.  Die Verteilung gibt dieses Objekt an Sie zurück, es wird jedoch in einem Pool abgelegt, der einem Objekt mit einer Größe von 32 Byte entspricht.  Die verbleibenden 8 Bytes sind inaktiv. <br><br>  Snippet (slab.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_to_virt_p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(p) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_to_virt_n</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">virt_to_phys_p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(p) - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">virt_to_phys_n</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::<span class="hljs-function"><span class="hljs-function">id&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_thread_id</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id*&gt;(p); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> noncopyable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: slab() { small::quota_init(&amp; quota_, <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); small::slab_arena_create(&amp;arena_, &amp; quota_, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>, MAP_PRIVATE); small::slab_cache_create(&amp;cache_, &amp;arena_); small::allocator_create(&amp;allocator_, &amp;cache_, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>); } ~slab() { small::allocator_destroy(&amp;allocator_); small::slab_cache_destroy(&amp;cache_); small::slab_arena_destroy(&amp;arena_); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_n = virt_to_phys_n(n); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_p = small::<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(&amp;allocator_, phys_n); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!phys_p) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; phys_thread_id(phys_p) = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> phys_to_virt_p(phys_p); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_p = virt_to_phys_p(<span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(p)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_n = virt_to_phys_n(n); assert(phys_thread_id(phys_p) == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id()); small::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(&amp;allocator_, phys_p, phys_n); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: small::quota quota_; small::slab_arena arena_; small::slab_cache cache_; small::allocator allocator_; };</code> </pre> <br>  Alle diese Einschränkungen gelten für eine bestimmte Instanz der Klasse variti :: slab.  Da jeder Thread einen eigenen Thread hat (denken Sie an thread local), beträgt das Gesamtlimit für den Prozess nicht 1 GB, sondern ist direkt proportional zur Anzahl der Threads, die die Plattenverteilung verwenden. <br><br>  Diagramm (std :: thread :: id): <br><br><img src="https://habrastorage.org/webt/_8/65/jy/_865jyoyp0qqoz7-tgsgmjsc9b0.png"><br><br>  Durch die Verwendung von thread local können Sie einerseits die Arbeit der Plattenverteilung in einer Multithread-Anwendung beschleunigen und andererseits die Architektur der asynchronen Anwendung erheblich einschränken.  Sie müssen ein Objekt im selben Stream anfordern und zurückgeben.  Dies im Rahmen von boost.asio zu tun, ist manchmal sehr problematisch.  Um offensichtlich fehlerhafte Situationen zu verfolgen, platzieren wir am Anfang jedes Objekts den Bezeichner des Streams, in dem die Methode allocate aufgerufen wird.  Diese Kennung wird dann in der Freigabemethode überprüft.  Die Helfer phys_to_virt_p und virt_to_phys_p helfen dabei. <br><br>  Snippet (thread_local_slab.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_local_slab</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> noncopyable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finalize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; };</code> </pre> <br>  Snippet (thread_local_slab.cpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">thread_local</span></span> slab* slab_; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::initialize() { slab_ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> slab(slab_cfg_); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::finalize() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> slab_; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* thread_local_slab::<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> slab_-&gt;<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(n); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) { slab_-&gt;<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(p, n); }</code> </pre> <br>  Wenn die Kontrolle über den Stream verloren geht (beim Übertragen eines Objekts zwischen verschiedenen io-Kontexten), ermöglicht ein intelligenter Zeiger die korrekte Freigabe des Objekts.  Alles, was er tut, ist, das Objekt zu verteilen, sich an seinen io-Kontext zu erinnern und es dann in std :: shared_ptr mit einem benutzerdefinierten Teiler zu verpacken, der das Objekt nicht sofort an die Verteilung zurückgibt, sondern im zuvor gespeicherten io-Kontext.  Dies funktioniert gut, wenn jeder io-Kontext auf einem einzelnen Thread ausgeführt wird.  Ansonsten ist dieser Ansatz leider nicht anwendbar. <br><br>  Snippet (slab_helper.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Allocator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; slab_allocate_shared(Allocator allocator, Args... args) { T* p = allocator.allocate(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)p) T(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; ptr(p, [allocator](T* p) { p-&gt;~T(); allocator.deallocate(p); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Allocator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; slab_allocate_shared(Allocator allocator, boost::asio::io_service* io, Args... args) { T* p = allocator.allocate(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)p) T(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; ptr(p, [allocator, io](T* p) { io-&gt;post([allocator, p]() { p-&gt;~T(); allocator.deallocate(p); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; };</code> </pre> <br><h3>  Lösung </h3><br>  Nachdem die libsmall-Wrapping-Arbeit abgeschlossen war, haben wir zuerst die Chun-Allokatoren im Stream-Puffer auf die Platte verschoben.  Das war ziemlich einfach.  Nachdem wir ein positives Ergebnis erhalten hatten, haben wir zunächst den Stream-Puffer selbst und dann alle Objekte in den Server- und Client-Sitzungen mit Plattenzuordnungen versehen. <br><br><ul><li>  variti :: chunk </li><li>  variti :: streambuf </li><li>  variti :: server_session </li><li>  variti :: client_session </li></ul><br>  Gleichzeitig mussten zusätzliche Probleme gelöst werden, nämlich die Übertragung einfacher Objekte, zusammengesetzter Objekte und Sammlungen an Plattenzuordner.  Und wenn es bei den ersten beiden Klassen von Objekten keine ernsthaften Schwierigkeiten gab (zusammengesetzte Objekte werden auf einfache reduziert), stießen wir bei der Übersetzung von Sammlungen auf ernsthafte Schwierigkeiten. <br><br><ul><li>  std :: liste </li><li>  std :: deque </li><li>  std :: vector </li><li>  std :: string </li><li>  std :: map </li><li>  std :: unordered_map </li></ul><br>  Eine der Haupteinschränkungen beim Arbeiten mit der Plattenverteilung besteht darin, dass die Anzahl der Objekte unterschiedlicher Typen nicht zu groß sein sollte (je kleiner, desto besser).  In diesem Zusammenhang fallen einige Sammlungen möglicherweise unter das Konzept der Plattenverteiler, während andere dies möglicherweise nicht tun. <br><br>  Für die Platte std :: list funktionieren die Zuweiser hervorragend.  Diese Auflistung wird intern mithilfe einer verknüpften Liste implementiert, deren Elemente jeweils eine feste Größe haben.  Mit dem Hinzufügen neuer Daten zur std :: -Liste in der Plattenverteilung werden daher keine neuen Objekttypen angezeigt.  Die oben angegebene Bedingung ist erfüllt!  Die std :: map ist ähnlich aufgebaut.  Der einzige Unterschied besteht darin, dass es sich nicht um eine verknüpfte Liste handelt, sondern um einen Baum. <br><br>  Bei std :: deque sind die Dinge komplizierter.  Diese Sammlung wird durch einen zusammenhängenden Speicherblock implementiert, der Zeiger auf Blöcke enthält.  Während die Blöcke ziemlich genau sind, verhält sich std :: deque genauso wie std :: list, aber wenn sie enden, wird derselbe Speicherblock neu verteilt.  Aus der Sicht von Plattenzuordnern ist jede Speicherumverteilung ein Objekt mit einem neuen Typ.  Die Anzahl der Objekte, die der Sammlung direkt hinzugefügt werden, hängt vom Benutzer ab und kann unkontrolliert zunehmen.  Diese Situation ist nicht akzeptabel, daher haben wir entweder die Größe von std :: deque vorläufig begrenzt, wo dies möglich war, oder std :: list vorgezogen. <br><br>  Wenn wir std :: vector und std :: string nehmen, sind sie noch komplizierter.  Die Implementierung dieser Auflistungen ähnelt etwas der von std :: deque, nur dass ihr kontinuierlicher Speicherblock erheblich schneller wächst.  Wir haben std :: vector und std :: string durch std :: deque und im schlimmsten Fall durch std :: list ersetzt.  Ja, wir haben an Funktionalität und sogar an Leistung verloren, aber dies wirkte sich weniger auf das endgültige Bild aus als auf die Optimierungen, für die alles gedacht war. <br><br>  Wir haben genau dasselbe mit std :: unordered_map gemacht und es zugunsten der selbst geschriebenen variti :: flat_map aufgegeben, die mit std :: deque implementiert wurde.  Gleichzeitig haben wir die häufig verwendeten Schlüssel einfach in separaten Variablen zwischengespeichert, wie dies beispielsweise bei den HTTP-Anforderungs-Headern in nginx der Fall ist. <br><br><h3>  Fazit </h3><br>  Nachdem die Server- und Client-Sitzungen vollständig an die Plattenzuweiser übertragen wurden, haben wir die Zeit für die Arbeit mit einer Gruppe um mehr als das Eineinhalbfache reduziert. <br><br>  Screenshot des Verstärkers (coldslab): <br><br><img src="https://habrastorage.org/webt/ls/yx/l_/lsyxl_b6xngl5xap-t5erwn4now.png"><br><br>  Im Screenshot hat der Operator new 32 Sekunden gearbeitet und der Operator delete - 24 Sekunden.  Zu diesem Zeitpunkt wurden weitere Funktionen für die Arbeit mit dem Heap hinzugefügt: smalloc - 21 Sekunden, mslab_alloc - 37 Sekunden, smfree - 8 Sekunden, mslab_free - 21 Sekunden.  Insgesamt 143 Sekunden gegenüber 161 Sekunden. <br><br>  Diese Messungen wurden jedoch sofort nach dem Start des Dienstes durchgeführt, ohne die Caches in der Plattenverteilung zu initialisieren.  Nach mehrmaligem Abfeuern aus einem Yandex-Panzer verbesserte sich das Gesamtbild. <br><br>  Screenshot des Verstärkers (hotslab): <br><br><img src="https://habrastorage.org/webt/gc/zj/kt/gczjkt5r8yedhniu5afswdjqk2y.png"><br><br>  Im Screenshot arbeitete der Operator new 20 Sekunden, smalloc - 16 Sekunden, mslab_alloc - 27 Sekunden, operator delete - 16 Sekunden, smfree - 7 Sekunden, mslab_free - 17 Sekunden.  Insgesamt 103 Sekunden gegen 161 Sekunden. <br><br>  Maßtabelle: <br><br><pre> <code class="plaintext hljs"> woslab coldslab hotslab operator new 67s 32s 20s smalloc - 21s 16s mslab_alloc - 37s 27s operator delete 94s 24s 16s smfree - 8s 7s mslab_free - 21s 17s summary 161s 143s 103s</code> </pre><br>  Im wirklichen Leben sollte das Ergebnis sogar noch besser sein, da Plattenzuweiser nicht nur das Problem der langen Speicherzuweisung und -freigabe lösen, sondern auch die Fragmentierung reduzieren.  Ohne Platte sollte sich der Vorgang von Operator Neu und Operator Löschen im Laufe der Zeit nur verlangsamen.  Bei Platten bleibt sie immer auf dem gleichen Niveau. <br><br>  Wie wir sehen können, lösen Plattenzuordner erfolgreich das Speicherzuordnungsproblem häufig verwendeter Objekte.  Achten Sie darauf, wenn das Problem des häufigen Erstellens und Entfernens von Objekten für Sie relevant ist.  Vergessen Sie jedoch nicht die Einschränkungen, die sie der Architektur Ihrer Anwendung auferlegen!  Nicht alle komplexen Objekte können einfach in die Plattenverteilung eingefügt werden.  Manchmal muss man viel aufgeben!  Je komplexer die Architektur Ihrer Anwendung ist, desto häufiger müssen Sie dafür sorgen, dass das Objekt im Hinblick auf Multithreading wieder in den richtigen Cache gestellt wird.  Es kann einfach sein, wenn Sie die Anwendungsarchitektur unter Berücksichtigung der Verwendung von Plattenzuordnern sofort ausgearbeitet haben, aber es wird definitiv Schwierigkeiten bereiten, wenn Sie sich für eine spätere Integration entscheiden. <br><br><h3>  App </h3><br>  Hier geht es zum Quellcode! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477404/">https://habr.com/ru/post/de477404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477390/index.html">Debuggen von Netzwerkverzögerungen in Kubernetes</a></li>
<li><a href="../de477392/index.html">Mikrofon öffnen: Backend. Wir laden Referenten ein</a></li>
<li><a href="../de477396/index.html">Wie melde ich mich für einen Kurs an und ... gehe zum Ende</a></li>
<li><a href="../de477400/index.html">Über den Beruf des Produktmanagers: Wie erreicht man das Ideal?</a></li>
<li><a href="../de477402/index.html">Bereitstellen des Keras Deep Learning-Modells als Python-Webanwendung</a></li>
<li><a href="../de477406/index.html">Technischer Support und Support. Gute Recherche auf dem Arbeitsmarkt und bei den Gehältern. Was hat sich in 2 Jahren verändert?</a></li>
<li><a href="../de477408/index.html">JavaFX Tutorial: Erweiterte Layouts</a></li>
<li><a href="../de477414/index.html">Data Engineer - Der sexyste Beruf des 21. Jahrhunderts</a></li>
<li><a href="../de477416/index.html">Wann ist es schädlich für Hash</a></li>
<li><a href="../de477418/index.html">Dreiseitige Refraktion in drei Schritten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>