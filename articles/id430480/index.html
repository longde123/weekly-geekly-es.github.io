<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏿 🥙 👩🏽‍🤝‍👨🏿 Ketika kami menulis aplikasi di NASA Space Apps Challenge hackathon 👨🏽‍⚖️ 👩‍👩‍👦‍👦 👩🏻‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada 20-21 Oktober, NASA Space Apps Challenge hackathon internasional diadakan di Moskow. Penyelenggaranya di Rusia adalah orang-orang dari komunitas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ketika kami menulis aplikasi di NASA Space Apps Challenge hackathon</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/singularis/blog/430480/">  Pada 20-21 Oktober, <strong>NASA Space Apps Challenge</strong> hackathon internasional diadakan di Moskow.  Penyelenggaranya di Rusia adalah orang-orang dari komunitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rusia</a> .  Sebagai bagian dari acara tersebut, para peserta diminta untuk menyelesaikan 20 kasus tentang berbagai topik: mulai dari pembuatan film tentang hackathon hingga mengembangkan aplikasi pemantauan dan merancang pesawat terbang otonom.  Daftar lengkap topik dapat dipelajari dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">referensi</a> atau dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tentang Habré</a> . <br><img src="https://habrastorage.org/webt/zb/xr/n8/zbxrn8ng1jnvhth73omf4dgorbe.png"><br>  Tim kami "Space Monkeys", yang termasuk Oleg Borodin (Pengembang front-end di laboratorium Singularis), Vladislav Plotnikov (insinyur QA di laboratorium Singularis), Yegor Shvetsov, Dmitry Petrov, Yuri Bederov dan Nikolai Denisenko, memutuskan untuk menyelesaikan masalah di bawah kondisi yang menarik. berjudul “Spot that fire!”, yang diucapkan sebagai berikut: “ <em>Terapkan crowdsourcing sehingga orang dapat berkontribusi untuk deteksi, konfirmasi, dan pelacakan kebakaran hutan.</em>  <em>Solusinya bisa berupa aplikasi seluler atau web.</em>  ” <br><br>  Karena fakta bahwa tim mengumpulkan 5 pengembang dengan pengalaman dalam mengembangkan untuk berbagai platform, segera diputuskan bahwa prototipe aplikasi kami akan diimplementasikan untuk platform Web dan Mobile. <br><a name="habracut"></a><br>
<h2>  Data NASA apa yang kami gunakan? </h2><br><p>  Tetap saja, hackathon diadakan di bawah naungan Badan Penerbangan dan Antariksa Nasional, sehingga tidak benar untuk tidak menggunakan data terbuka dari dapur NASA.  Selain itu, kami segera menemukan dataset <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Data Api Aktif yang</a> kami butuhkan.  Dataset ini berisi informasi tentang koordinat kebakaran di seluruh dunia (Anda dapat mengunduh informasi di benua tertentu).  Data diperbarui setiap hari (Anda dapat menerima data selama 24 jam, 48 jam, 7 hari). </p><br><p>  File tersebut berisi informasi tentang bidang-bidang berikut: lintang, bujur, kecerahan, pindai, lacak, acq_date, acq_time, satelit, kepercayaan diri, versi, bright_t31, frp, daynight, di mana kami hanya menggunakan koordinat titik api (lintang dan bujur). </p><br><h2>  Prinsip aplikasi </h2><br><p>  Karena aplikasi ini adalah crowdsourced, idealnya itu harus digunakan oleh sejumlah besar pengguna.  Prinsip aplikasi adalah sebagai berikut: </p><br><ol><li><p>  Pengguna, setelah mendeteksi kebakaran, memotretnya (dengan penandaan geografis) dan memuatnya menggunakan layanan.  Foto dengan tag geo dan koordinat pengiriman ke server aplikasi.  Fotografi dapat diunduh dari versi aplikasi Web atau Mobile. </p></li><li><p>  Foto yang dihasilkan diproses di server oleh jaringan saraf terlatih untuk mengkonfirmasi bahwa foto tersebut benar-benar terbakar.  Hasil skrip adalah akurasi prediksi, jika&gt; 0,7, maka foto benar-benar menyala.  Kalau tidak, kami tidak merekam informasi ini dan meminta pengguna untuk mengunggah foto lain. </p></li><li><p>  Jika skrip analisis gambar memberikan hasil positif, maka koordinat dari geotag ditambahkan ke dataset dengan semua koordinat.  Selanjutnya, jarak antara titik ke-1 dari dataset NASA dan titik dari pengguna dihitung.  Jika jarak antara titik adalah <strong>≤</strong> 3 km, maka titik dari set NASA ditambahkan ke kamus.  Jadi kita membahas semua poin.  Setelah itu, kembalikan json dengan koordinat yang memenuhi kondisi ke sisi klien aplikasi.  Jika tidak ada koordinat yang ditemukan oleh kondisi yang diberikan, maka kami mengembalikan satu-satunya titik yang kami terima dari pengguna. </p></li><li><p>  Jika server mengembalikan array poin, maka bagian klien dari aplikasi menggambar zona api di peta.  Jika server mengembalikan satu titik, itu ditandai pada peta dengan label khusus. </p></li></ol><br><h2>  Tumpukan teknologi yang digunakan </h2><br><h3>  <em>Bagian ujung depan aplikasi web</em> </h3><br><p>  Aplikasi web, dapat diakses dari browser, fokus pada layar komputer, dan tidak adaptif, namun, teknologi yang digunakan dengan mudah memungkinkan untuk memperbaiki aspek ini untuk perangkat seluler.  Kami menggunakan tumpukan teknologi berikut di sisi web: </p><br><ul><li>  Kerangka 6 TipeScript Angular Google </li><li>  CSS &amp; JS Framework Terwujud </li><li>  modul untuk mengunduh file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ng2-file-upload</a> </li><li>  Peta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenStreetMap</a> , perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Leaflet</a> </li></ul><br><h4>  Skenario kerja </h4><br><p>  Pengguna membuka aplikasi dan melihat lokasinya: </p><br><img src="https://habrastorage.org/webt/p2/j1/uk/p2j1ukxxirwd_5ch-rsaje4sflc.jpeg"><br><br><p>  Inisialisasi peta dan geo pengguna: </p><br><pre><code class="plaintext hljs">this.map = L.map('map').setView([latitude, longitude], 17); L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&amp; copy; &lt;a href="https://www.openstreetmap.org/copyright"&gt;OpenStreetMap&lt;/a&gt; contributors' }).addTo(this.map); L.circle([latitude, longitude]).addTo(this.map) .bindPopup('You are here') .openPopup();</code> </pre> <br><p>  Jika ada api di jari-jari <em>n</em> (variabel ubahsuaian) kilometer, maka akan ditampilkan dalam bentuk poligon dengan ringkasan informasi tambahan: </p><br><img src="https://habrastorage.org/webt/6q/1e/k5/6q1ek54slbxacie85pqrdsuwzko.jpeg"><br><br><p>  Pengguna memilih lokasi api di peta: </p><br><img src="https://habrastorage.org/webt/1t/qv/p9/1tqvp9ytbpe3r1kmwogvtviii34.jpeg"><br><br><p>  Pengaturan tag api: </p><br><pre> <code class="plaintext hljs">let marker; this.map.on('click', function (e) { if (marker) { self.map.removeLayer(marker); } marker = L.circle([e.latlng.lat, e.latlng.lng], { color: 'red', fillColor: '#f03', fillOpacity: 0.5, radius: 15 }).addTo(self.map) .bindPopup(' ') .openPopup(); self.appService.coordinatesStorage.latitude = e.latlng.lat; self.appService.coordinatesStorage.longitude = e.latlng.lng; console.log('fire', self.appService.coordinatesStorage); });</code> </pre><br><p>  Selanjutnya, pengguna mengunggah foto api menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ng2-file-upload</a> . </p><br><p>  Sebagai hasil dari tindakan ini, data berikut ditransfer ke server: </p><br><ul><li>  koordinat pengguna </li><li>  koordinat api yang ditentukan </li><li>  foto api </li></ul><br><p>  Output dari aplikasi adalah hasil pengakuan. </p><br><br><h3>  <em>Aplikasi aplikasi seluler</em> </h3><br><h4>  Teknologi yang digunakan </h4><br><ul><li>  Bereaksi asli - kerangka kerja untuk mengembangkan aplikasi lintas platform untuk iOS dan Android </li><li>  Redux - aplikasi kontrol aliran data </li><li>  Redux-saga - perpustakaan menggunakan efek samping di Redux </li></ul><br><h4>  Skenario kerja </h4><br><table><tbody><tr><td><p>  Pilih foto api <br><img src="https://habrastorage.org/webt/m_/n0/ex/m_n0exwfthzn0-yl3so514frun4.jpeg"><br></p><br></td><td><p>  Komentar dari pengguna <br><img src="https://habrastorage.org/webt/wg/u5/yd/wgu5ydugmpmcr0j5yaqg52721ia.jpeg"><br></p><br></td><td><p>  Tanda api <br><img src="https://habrastorage.org/webt/4g/hc/et/4ghceta2dtzzj3mwb8ry2ikc5ws.jpeg"><br></p><br></td></tr></tbody></table><br><h3>  <em>Bagian belakang aplikasi</em> </h3><br><ul><li><p>  Bahasa Pemrograman - JAVA 8 </p></li><li><p>  Platform Cloud - Microsoft Azure </p></li><li><p>  Kerangka kerja aplikasi web - Kerangka Mainkan </p></li><li><p>  Pemetaan objek-relasional - Kerangka Ebean </p></li></ul><br><p>  Server memiliki 2 skrip yang ditulis dalam Python: predict.py dan getZone.py, pustaka Python berikut diinstal untuk pekerjaan mereka: </p><br><ul><li>  panda - untuk pemrosesan dan analisis data </li><li>  geopanda - untuk bekerja dengan geodata </li><li>  numpy - untuk bekerja dengan array multidimensi </li><li>  matplotlib - untuk visualisasi data grafik dua dimensi (2D) (grafik 3D juga didukung) </li><li>  rupawan - untuk manipulasi dan analisis objek geometri datar. </li></ul><br><p>  API Server: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fire.iconx.app/api</a> </p><br><ul><li>  memuat koordinat </li></ul><br><pre> <code class="plaintext hljs">post /pictures {} return { id }</code> </pre><br><ul><li>  unggah gambar </li></ul><br><pre> <code class="plaintext hljs">post /pictures/:id</code> </pre><br><p>  <strong>Script predict.py</strong> </p><br><p>  Sebuah skrip input menerima gambar, sebuah preprocessing gambar sederhana terjadi (lebih lanjut tentang ini di bagian "Model Training") dan berdasarkan pada file yang disimpan dengan bobot, yang juga terletak di server, sebuah prediksi dikeluarkan.  Jika model menghasilkan akurasi&gt; 0,7, maka api tetap, jika tidak - tidak. </p><br><p>  Script dijalankan dengan cara klasik. </p><pre> <code class="plaintext hljs">$ python predict.py image.jpg</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Daftar kode:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">import keras import sys from keras.layers import Dense from keras.models import model_from_json from sklearn.externals import joblib from PIL import Image import numpy as np from keras import models, layers, optimizers from keras.applications import MobileNet from keras.models import Sequential from keras.layers import Dense, Dropout, Flatten from keras.layers import Conv2D, MaxPooling2D def crop_resize(img_path, img_size_square): # Get dimensions mysize = img_size_square image = Image.open(img_path) width, height = image.size # resize if (width and height) &gt;= img_size_square: if width &gt; height: wpercent = (mysize/float(image.size[1])) vsize = int((float(image.size[0])*float(wpercent))) image = image.resize((vsize, mysize), Image.ANTIALIAS) else: wpercent = (mysize/float(image.size[0])) hsize = int((float(image.size[1])*float(wpercent))) image = image.resize((mysize, hsize), Image.ANTIALIAS) # crop width, height = image.size left = (width - mysize)/2 top = (height - mysize)/2 right = (width + mysize)/2 bottom = (height + mysize)/2 image=image.crop((left, top, right, bottom)) return image conv_base = MobileNet(weights='imagenet', include_top=False, input_shape=(224, 224, 3)) def build_model(): model = models.Sequential() model.add(conv_base) model.add(layers.Flatten()) model.add(layers.Dense(256, activation='relu')) model.add(layers.Dense(64, activation='relu')) model.add(layers.Dense(1, activation='sigmoid')) model.compile(loss='binary_crossentropy', optimizer=optimizers.RMSprop(lr=2e-5), metrics=['acc']) return model image=crop_resize(sys.argv[1],224) image = np.reshape(image,[1,224,224,3]) #Loading models and text processing model = build_model() print('building a model') model.load_weights('./models/mobile_weights.h5') print('model loaded') pred_cat=model.predict(image) if pred_cat &gt; 0.7: print('fire {}'.format(pred_cat)) else: print('no fire {}'.format(pred_cat))</code> </pre><br></div></div><br><br><p>  <strong>Script getZone.py</strong> </p><br><p>  Input ke skrip adalah koordinat titik yang berasal dari sisi klien dari aplikasi.  Script mempererat semua koordinat dari NASA, menambahkan lintang dan bujur baru ke file ini, menimpa file asli dan mulai mencari titik terdekat.  Jarak antar titik dihitung menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rumus Haversine</a> . </p><br><p>  Untuk melakukan ini, garis lintang dan bujur titik dikonversi ke radian: </p><br><pre> <code class="plaintext hljs">pt1_lon, pt1_lat, pt2_lon, pt2_lat = map(radians, [pt1_lon, pt1_lat, pt2_lon, pt2_lat])</code> </pre><br><p>  Ada perbedaan antara garis lintang dan garis bujur untuk masing-masing titik: </p><br><pre> <code class="plaintext hljs">d_lon = pt2_lon - pt1_lon d_lat = pt2_lat - pt1_lat</code> </pre><br><p>  Semua ini disubstitusi ke dalam formula haversine: </p><br><pre> <code class="plaintext hljs">a = sin(d_lat/2)**2 + cos(pt1_lat) * cos(pt2_lat) * sin(d_lon/2)**2</code> </pre><br><p>  Kami mengambil akar dari hasil perhitungan, menghitung arcsine dan mengalikan hasilnya dengan 2. </p><br><pre> <code class="plaintext hljs">c = 2 * asin(sqrt(a))</code> </pre><br><p>  Jaraknya akan menjadi produk jari-jari Bumi (6371 km) dan hasil perhitungan sebelumnya. </p><br><h2>  Pelatihan model </h2><br><p>  Untuk menganalisis gambar untuk api, kami membutuhkan satu set pelatihan foto dengan api.  Foto dikumpulkan oleh skrip dari situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.flickr.com/</a> dan ditandai secara manual. </p><br><p>  Pengunduhan dilakukan menggunakan FlikerAPI.  Script melakukan operasi preprocessing standar dengan gambar: cropping - square dengan centering (rasio 1: 1), dan mengubah ukuran ke format 256 × 256. </p><br><div class="spoiler">  <b class="spoiler_title">Daftar kode:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">import flickrapi import urllib.request from PIL import Image import pathlib import os from tqdm import tqdm # Flickr api access key flickr=flickrapi.FlickrAPI('your API key', 'your secret key', cache=True) def get_links(): search_term = input("Input keywords for images: ") keyword = search_term max_pics=2000 photos = flickr.walk(text=keyword, tag_mode='all', tags=keyword, extras='url_c', per_page=500, # mb you can try different numbers.. sort='relevance') urls = [] for i, photo in enumerate(photos): url = photo.get('url_c') if url is not None: urls.append(url) if i &gt; max_pics: break num_of_pics=len(urls) print('total urls:',len(urls)) # print number of images available for a keywords return urls, keyword, num_of_pics #resizing and cropping output images will be besquare def crop_resize(img_path, img_size_square): # Get dimensions mysize = img_size_square image = Image.open(img_path) width, height = image.size # resize if (width and height) &gt;= img_size_square: if width &gt; height: wpercent = (mysize/float(image.size[1])) vsize = int((float(image.size[0])*float(wpercent))) image = image.resize((vsize, mysize), Image.ANTIALIAS) else: wpercent = (mysize/float(image.size[0])) hsize = int((float(image.size[1])*float(wpercent))) image = image.resize((mysize, hsize), Image.ANTIALIAS) # crop width, height = image.size left = (width - mysize)/2 top = (height - mysize)/2 right = (width + mysize)/2 bottom = (height + mysize)/2 image=image.crop((left, top, right, bottom)) return image def download_images(urls_,keyword_, num_of_pics_): num_of_pics=num_of_pics_ keyword=keyword_ urls=urls_ i=0 base_path='./flickr_data/' # your base folder to save pics for item in tqdm(urls): name=''.join([keyword,'_',str(i),'.jpg']) i+=1 keyword_=''.join([keyword,'_',str(num_of_pics)]) dir_path= os.path.join(base_path,keyword_) file_path=os.path.join(dir_path,name) pathlib.Path(dir_path).mkdir(parents=True, exist_ok=True) urllib.request.urlretrieve(item, file_path) resized_img=crop_resize(file_path, 256) #set output image size try: resized_img.save(file_path) except: pass urls, keyword, num_of_pics =get_links() continue = input("continue or try other keywords (y,n): ") if continue =='y': download_images(urls, keyword, num_of_pics) elif continue =='n': get_links() else: pass</code> </pre><br></div></div><br><p>  Secara alami, arsitektur konvolusional dari jaringan saraf, di mana model pra-dilatih digunakan, digunakan untuk bekerja dengan gambar.  Pilihan jatuh pada (diharapkan) di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MobileNet</a> , karena: </p><br><ul><li>  Ringan - Penting agar waktu respons aplikasi minimal. </li><li>  Cepat - Penting agar waktu respons aplikasi minimal. </li><li>  Tepat - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>MobileNet</em></a> memprediksi dengan akurasi yang diperlukan. </li></ul><br><p>  Setelah pelatihan, jaringan menghasilkan akurasi ~ 0,85. </p><br><p>  Untuk membangun model, pelatihan dan prediksi, sekelompok <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Keras</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tensorflow digunakan</a> .  Pekerjaan dengan data dilakukan melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panda</a> . </p><br><p>  Karena NASA DataSet adalah data geografis, kami ingin menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GeoPandas</a> .  Perpustakaan ini adalah perpanjangan dari kemampuan Pandas untuk menyediakan metode spasial dan operasi pada tipe geometris.  Operasi geometrik diimplementasikan melalui pustaka bentuk, bekerja dengan file - fiona, grafik - matplotlib. </p><br><p>  Setelah menghabiskan hampir satu setengah hari mencoba mencari tahu perpustakaan ini, kami meninggalkannya karena kami tidak dapat menemukan di mana perpustakaan itu dapat memberi kami keuntungan nyata dari bekerja dengannya.  Tugas kami menghitung koordinat sangat kecil, jadi pada akhirnya, semuanya dilaksanakan secara asli. </p><br><h2>  Apa selanjutnya </h2><br><p>  Secara alami, semua yang kami dapatkan adalah aplikasi yang sangat tidak stabil dan kasar, yang memiliki hak untuk diselesaikan. </p><br><p>  Kami telah berhasil: </p><br><ol><li>  Terapkan prototipe aplikasi seluler dan Web yang dapat mengambil foto (hanya versi seluler), unggah, dan kirim ke server.  Juga, koordinat pengiriman berhasil datang ke server. </li><li>  Di server, dimungkinkan untuk menggunakan 2 skrip yang mengimplementasikan logika utama aplikasi.  Alur data input ke skrip ini dan penerimaan data output dengan pengiriman berikutnya ke bagian klien diatur. </li><li>  Terapkan "prototipe" nyata dari aplikasi kita. </li></ol><br><p>  Kami tidak berhasil mengimplementasikannya, tetapi saya ingin menyelesaikan masalah berikut dan menambahkan fitur (item sesuai dengan prioritas tugas): </p><br><ol><li>  Atur rekaman semua koordinat dari dataset ke database untuk berinteraksi langsung dengan database. </li><li>  Kelola unggahan otomatis file baru dari situs web NASA, mis.  mengatur pembaruan koordinat harian otomatis. </li><li>  Tambahkan notifikasi kepada pengguna yang berada di area dekat api. </li><li>  Tambahkan registrasi (diperlukan untuk mengimplementasikan paragraf pertama). </li><li>  Tulis ulang algoritma perhitungan zona api. </li><li>  Selesaikan tugas desain - menghadirkan keindahan ke versi seluler dan web aplikasi. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430480/">https://habr.com/ru/post/id430480/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430470/index.html">Mengapa mempertahankan konteks pada akun klien - jujur ​​dan menguntungkan</a></li>
<li><a href="../id430472/index.html">Jaringan DECT DIY mulus</a></li>
<li><a href="../id430474/index.html">CephFS vs GlusterFS</a></li>
<li><a href="../id430476/index.html">NCBI Genome Workbench: Endangered Research</a></li>
<li><a href="../id430478/index.html">Trading bot untuk pasar cryptocurrency. Di mana untuk memulai?</a></li>
<li><a href="../id430482/index.html">Tema pelat baja dalam budaya Timur dan Barat</a></li>
<li><a href="../id430484/index.html">Skenario Implementasi NGFW yang tipikal</a></li>
<li><a href="../id430486/index.html">Bagaimana freelancer tinggal: dari pengembang ke copywriter teknis</a></li>
<li><a href="../id430488/index.html">Pertukaran data asinkron dengan aplikasi jarak jauh melalui SSH</a></li>
<li><a href="../id430490/index.html">Mengantisipasi, mendidik, memutuskan: bagaimana dan mengapa EPAM membangun Java Competency Center</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>