<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏽 🧙🏼 🎟️ Réseaux de neurones et philosophie du langage 👩🏿‍🏭 💱 🈶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pourquoi les théories de Wittgenstein restent le fondement de toute la PNL moderne 

 La représentation vectorielle des mots est peut-être l'une des i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Réseaux de neurones et philosophie du langage</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435984/"> <font color="gray">Pourquoi les théories de Wittgenstein restent le fondement de toute la PNL moderne</font> <br><br>  La représentation vectorielle des mots est peut-être l'une des idées les plus belles et les plus romantiques de l'histoire de l'intelligence artificielle.  La philosophie du langage est une branche de la philosophie qui explore la relation entre le langage et la réalité et comment rendre la parole significative et compréhensible.  Une représentation vectorielle des mots est une méthode très spécifique dans le traitement moderne du langage naturel (PNL).  En un sens, il s'agit d'une preuve empirique des théories de Ludwig Wittgenstein, l'un des philosophes les plus pertinents du siècle dernier.  Pour Wittgenstein, l'utilisation des mots est un mouvement dans un <i>jeu de</i> langage social joué par des membres de la communauté qui se comprennent.  Le sens d'un mot ne dépend que de son utilité dans un contexte, il ne correspond pas un à un avec un objet du monde réel. <br><br><blockquote>  Pour une grande classe de cas dans lesquels nous utilisons le mot «sens», il peut être défini comme le <b>sens du mot est son utilisation dans la langue</b> . </blockquote><a name="habracut"></a><br>  Bien sûr, il est très difficile de comprendre la signification exacte d'un mot.  Il y a plusieurs aspects à considérer: <br><br><ul><li>  à quel objet le mot peut faire référence; </li><li>  quelle partie du discours est-ce; </li><li>  s'il s'agit d'une expression idiomatique; </li><li>  toutes les nuances de sens; </li><li>  et ainsi de suite. </li></ul><br>  Tous ces aspects, au final, se résument à une chose: savoir utiliser le mot. <br><br>  Le concept de <i>signification</i> et la raison pour laquelle un ensemble ordonné de caractères a une connotation précise dans la langue n'est pas seulement une question philosophique, mais aussi probablement le plus gros problème auquel les spécialistes de l'IA travaillant avec la PNL doivent faire face.  Il est assez évident pour une personne russophone qu'un «chien» est un «animal», et il ressemble plus à un «chat» qu'à un «dauphin», mais cette tâche est loin d'être simple pour une solution systématique. <br><br>  Ayant légèrement corrigé les théories de Wittgenstein, nous pouvons dire que les chiens ressemblent à des chats car ils apparaissent souvent dans les mêmes contextes: vous pouvez probablement trouver des chiens et des chats associés aux mots "maison" et "jardin" qu'aux mots "mer" et "l'océan".  C'est cette intuition qui sous-tend <b>Word2Vec</b> , l'une des implémentations les plus célèbres et réussies de la représentation vectorielle des mots.  Aujourd'hui, les machines sont loin d'une réelle <i>compréhension des</i> textes et passages longs, mais la représentation vectorielle des mots est sans doute la seule méthode qui nous a permis de faire le plus grand pas dans cette direction au cours de la dernière décennie. <br><br><h1>  De BoW à Word2Vec </h1><br>  Dans de nombreux problèmes informatiques, le premier problème est de présenter les données sous forme numérique;  les mots et les phrases sont probablement les plus difficiles à imaginer sous cette forme.  Dans notre configuration, les mots <b>D</b> sont sélectionnés dans le dictionnaire et chaque mot peut se voir attribuer un index numérique <b>i</b> . <br><br>  Pendant de nombreuses décennies, une approche classique a été adoptée pour représenter chaque mot comme un vecteur numérique de dimension D de tous les zéros sauf un en position i.  À titre d'exemple, considérons un dictionnaire de trois mots: «chien», «chat» et «dauphin» (D = 3).  Chaque mot peut être représenté comme un vecteur tridimensionnel: «chien» correspond à [1,0,0], «chat» à [0,1,0] et «dauphin», évidemment, [0,0,1].  Le document peut être représenté comme un vecteur dimensionnel D, où chaque élément compte les occurrences du i-ème mot dans le document.  Ce modèle est appelé Bag-of-words (BoW), et il est utilisé depuis des décennies. <br><br>  Malgré son succès dans les années 90, BoW n'avait pas la seule fonction intéressante des mots: leur signification.  Nous savons que deux mots très différents peuvent avoir des significations similaires, même s'ils sont complètement différents du point de vue de l'orthographe.  «Chat» et «chien» sont tous deux des animaux domestiques, «roi» et «reine» sont proches l'un de l'autre, «pomme» et «cigarette» sont totalement indépendants.  Nous le <i>savons</i> , mais dans le modèle BoW, tous ces mots sont à la même distance dans l'espace vectoriel: 1. <br><br>  Le même problème s'applique aux documents: en utilisant BoW, nous pouvons conclure que les documents ne sont similaires que s'ils contiennent le même mot un certain nombre de fois.  Et voici Word2Vec, introduisant dans les termes de l'apprentissage automatique de nombreuses questions philosophiques dont Wittgenstein a discuté dans ses <i>études philosophiques</i> il y a 60 ans. <br><br>  Dans un dictionnaire de taille D, où le mot est identifié par son indice, le but est de calculer la représentation vectorielle à N dimensions de chaque mot pour N &lt;&lt; D.  Idéalement, nous voulons que ce soit un vecteur dense représentant certains aspects sémantiquement spécifiques de la signification.  Par exemple, nous voulons idéalement que «chien» et «chat» aient des représentations similaires, et «pomme» et «cigarette» sont très éloignées dans l'espace vectoriel. <br><br>  Nous voulons effectuer quelques opérations algébriques de base sur des vecteurs, tels que <code>+−=</code> .  Je veux que la distance entre les vecteurs «acteur» et «actrice» coïncide sensiblement avec la distance entre le «prince» et la «princesse».  Bien que ces résultats soient assez utopiques, les expériences montrent que les vecteurs Word2Vec présentent des propriétés très proches de celles-ci. <br><br>  Word2Vec n'apprend pas directement les vues de cela, mais les reçoit en tant que sous-produit de la classification sans enseignant.  L'ensemble de données du corpus de mots NLP moyen se compose d'un ensemble de phrases;  chaque mot d'une phrase apparaît dans le contexte des mots environnants.  Le classificateur a pour but de prédire le mot cible, en considérant les mots contextuels comme entrée.  Pour la phrase «chien brun joue dans le jardin», les mots [brun, joue, dans, jardin] sont fournis au modèle en entrée, et elle doit prédire le mot «chien».  Cette tâche est considérée comme l'apprentissage sans professeur, car le corpus n'a pas besoin d'être marqué avec une source externe de vérité: si vous avez un ensemble de phrases, vous pouvez toujours créer automatiquement des exemples positifs et négatifs.  En regardant «chien brun jouant dans le jardin» comme exemple positif, nous pouvons créer de nombreux modèles négatifs, tels que «plan brun jouant dans le jardin» ou «raisin brun jouant dans le jardin», en remplaçant le mot cible «chien» par des mots aléatoires de l'ensemble de données. <br><br>  Et maintenant, l'application des théories de Wittgenstein est parfaitement claire: le contexte est crucial pour la représentation vectorielle des mots, car il est important d'attacher un sens au mot dans ses théories.  Si deux mots ont des significations similaires, ils auront des représentations similaires (une petite distance dans l'espace à N dimensions) uniquement parce qu'ils apparaissent souvent dans des contextes similaires.  Ainsi, le "chat" et le "chien" finiront par avoir des vecteurs proches car ils apparaissent souvent dans les mêmes contextes: il est utile que le modèle utilise des représentations vectorielles similaires pour eux, car c'est la chose la plus pratique qu'elle puisse faire, pour obtenir de meilleurs résultats en prédisant deux mots en fonction de leur contexte. <br><br>  L'article original propose deux architectures différentes: CBOW et Skip-gram.  Dans les deux cas, les représentations verbales sont enseignées avec une tâche de classification spécifique, fournissant les meilleures représentations vectorielles possibles des mots qui maximisent les performances du modèle. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b9/e32/ee7/2b9e32ee767ad0c402e214a566d848a0.png"><br>  <i><font color="gray">Figure 1. Comparaison des architectures CBOW et Skip-gram</font></i> <br><br>  <b>CBOW</b> signifie Continuous Bag of Words, et sa tâche est de deviner un mot avec le contexte en tête comme entrée.  Les entrées et les sorties sont représentées comme des vecteurs dimensionnels D projetés dans un espace dimensionnel N avec des poids communs.  Nous recherchons uniquement des poids de projection.  En fait, la représentation vectorielle des mots est des matrices D × N, où chaque ligne représente un mot de dictionnaire.  Tous les mots de contexte sont projetés dans une position et leurs représentations vectorielles sont moyennées;  par conséquent, l'ordre des mots n'affecte pas le résultat. <br><br>  <b>Skip-gram</b> fait la même chose, mais vice versa: il essaie de prédire les mots de contexte <b>C</b> , en prenant le mot cible en entrée.  La tâche de prédire plusieurs mots contextuels peut être reformulée en un ensemble de problèmes de classification binaire indépendants, et maintenant l'objectif est de prédire la présence (ou l'absence) de mots contextuels. <br><br>  En règle générale, Skip-gram nécessite plus de temps pour la formation et donne souvent des résultats légèrement meilleurs, mais, comme d'habitude, différentes applications ont des exigences différentes, et il est difficile de prédire à l'avance lesquelles afficheront le meilleur résultat.  Malgré la simplicité du concept, l'apprentissage de ce type d'architecture est un véritable cauchemar en raison de la quantité de données et de la puissance de traitement nécessaires pour optimiser les poids.  Heureusement, sur Internet, vous pouvez trouver des représentations vectorielles pré-entraînées de mots, et vous pouvez étudier l'espace vectoriel - le plus intéressant - avec seulement quelques lignes de code Python. <br><br><h1>  Améliorations possibles: GloVe et fastText </h1><br>  Au cours du Word2Vec classique ces dernières années, de nombreuses améliorations possibles ont été proposées.  Les deux plus intéressants et les plus couramment utilisés sont GloVe (Stanford University) et fastText (développé par Facebook).  Ils essaient d'identifier et de surmonter les limites de l'algorithme d'origine. <br><br>  Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article scientifique original</a> , les auteurs de GloVe soulignent que la formation de modèles sur un contexte local séparé fait un mauvais usage des statistiques globales du corpus.  La première étape pour surmonter cette limitation est de créer une matrice globale <b>X</b> , où chaque élément <b>i, j</b> compte le nombre de références au mot <b>j</b> dans le contexte du mot <b>i</b> .  La deuxième idée importante de ce document est de comprendre que seules les probabilités seules ne suffisent pas pour une prédiction fiable des valeurs, et une matrice de cooccurrence est également nécessaire, à partir de laquelle certains aspects des valeurs peuvent être directement extraits. <br><br><blockquote>  Considérons deux mots i et j qui présentent un intérêt particulier.  Pour le concret, supposons que nous nous intéressions au concept d'état thermodynamique, pour lequel nous pouvons prendre <code>i = </code> et <code>j = </code> .  La relation de ces mots peut être étudiée en étudiant le rapport de leurs probabilités d'occurrence conjointe en utilisant différents mots qui sonnent, k.  Pour les mots k liés à la glace mais pas à la vapeur, disons <code>k = </code> [solide, état de la matière], nous nous attendons à ce que le rapport Pik / Pjk soit supérieur.  De même, pour les mots k associés à la vapeur, mais pas à la glace, disons <code>k = </code> , le rapport doit être petit.  Pour des mots comme «eau» ou «mode», qui sont soit également liés à la glace et à la vapeur, soit sans relation avec eux, ce rapport doit être proche de l'unité. </blockquote><br>  Ce rapport de probabilités devient le point de départ pour étudier la représentation vectorielle des mots.  Nous voulons pouvoir calculer des vecteurs qui, en combinaison avec une fonction spécifique <b>F,</b> maintiennent ce rapport constant dans l'espace de représentation vectorielle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/d5d/137/4dcd5d13763ca26ad997565ec2e6e513.jpg"></div><br>  <i><font color="gray">Figure 2. La formule la plus courante pour la représentation vectorielle des mots dans le modèle GloVe</font></i> <br><br>  La fonction F et la dépendance au mot k peuvent être simplifiées en remplaçant les exponentielles et les décalages fixes, ce qui donne la fonction de minimiser les erreurs par la méthode des moindres carrés <b>J</b> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/049/738/e48049738a71657b998f5630dac792c4.jpg"></div><br>  <i><font color="gray">Figure 3. La fonction finale du calcul de la représentation vectorielle des mots dans le modèle GloVe</font></i> <br><br>  La fonction <b>f</b> est une fonction de comptage qui essaie de ne pas surcharger les correspondances très fréquentes et rares, tandis que <b>bi</b> et <b>bj</b> sont des décalages pour restaurer la symétrie de la fonction.  Dans les derniers paragraphes de l'article, il est montré que la formation de ce modèle n'est finalement pas très différente de la formation du modèle Skip-gram classique, bien que dans les tests empiriques GloVe soit supérieur aux deux implémentations de Word2Vec. <br><br>  D'un autre côté, <b>fastText</b> corrige un inconvénient complètement différent de Word2Vec: si l'apprentissage du modèle commence par le codage direct d'un vecteur dimensionnel D, alors la structure interne des mots est ignorée.  Au lieu d'encoder directement le codage des mots apprenant des représentations verbales, fastText propose d'étudier N-grammes de caractères et de représenter les mots comme la somme des vecteurs N-grammes.  Par exemple, avec N = 3, le mot "fleur" est codé comme 6 grammes différents [&lt;fl, flo, low, Debt, wer, er&gt;] plus une séquence spéciale &lt;flower&gt;.  Remarquez comment les parenthèses angulaires sont utilisées pour indiquer le début et la fin d'un mot.  Ainsi, un mot est représenté par son index dans le dictionnaire des mots et l'ensemble des N-grammes qu'il contient, mappé en entiers à l'aide de la fonction de hachage.  Cette amélioration simple vous permet de diviser les représentations N-gramme entre les mots et de calculer les représentations vectorielles des mots qui n'étaient pas dans le cas d'apprentissage. <br><br><h1>  Expériences et applications possibles </h1><br>  Comme nous l'avons déjà dit, pour <b>utiliser</b> ces représentations vectorielles, vous n'avez besoin que de quelques lignes de code Python.  J'ai mené plusieurs expériences avec le <a href="">modèle GloVe à 50 dimensions</a> , formé sur 6 milliards de mots de phrases Wikipédia, ainsi qu'avec le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modèle fastText à 300 dimensions, formé sur Common Crawl</a> (qui a donné 600 milliards de jetons).  Cette section fournit des liens vers les résultats des deux expériences uniquement pour prouver les concepts et donner une compréhension générale du sujet. <br><br>  Tout d'abord, je voulais vérifier quelques similitudes de base des mots, la caractéristique la plus simple mais la plus importante de leur représentation vectorielle.  Comme prévu, les mots les plus similaires avec le mot «chien» étaient «chat» (0,92), «chiens» (0,85), «cheval» (0,79), «chiot» (0,78) et «animal de compagnie» (0,77).  Notez que le pluriel a presque la même signification que le singulier.  Encore une fois, c'est assez banal pour nous de dire cela, mais pour une voiture, ce n'est absolument pas un fait.  Maintenant nourriture: les mots les plus similaires pour «pizza» sont «sandwich» (0,87), «sandwichs» (0,86), «collation» (0,81), «produits de boulangerie» (0,79), «frites» (0,79) et «hamburgers» ( 0,78).  C'est logique, les résultats sont satisfaisants et le modèle se comporte plutôt bien. <br><br>  L'étape suivante consiste à effectuer des calculs de base dans l'espace vectoriel et à vérifier dans quelle mesure le modèle a acquis certaines propriétés importantes.  En effet, à la suite du calcul des vecteurs <code>+-</code> , le résultat est «actrice» (0,94), et à la suite du calcul de l' <code>+-</code> , le mot «roi» (0,86) est obtenu.  De manière générale, si la valeur est <code>a:b=c:d</code> , alors le mot <b>d</b> doit être obtenu comme <code>d=b-a+c</code> .  Passant au niveau suivant, il est impossible d'imaginer comment ces opérations vectorielles décrivent même des aspects géographiques: nous savons que Rome est la capitale de l'Italie, puisque Berlin est la capitale de l'Allemagne, en fait <code>+-= (0.88)</code> et <code>+-= (0.83)</code> . <br><br>  Et maintenant pour la partie amusante.  En suivant la même idée, nous allons essayer d'ajouter et de soustraire des concepts.  Par exemple, quel est l'équivalent américain de la pizza pour les Italiens?  <code>+-= (0.60)</code> , puis <code> (0.59)</code> .  Depuis mon arrivée aux Pays-Bas, je dis toujours que ce pays est un mélange de trois choses: un peu de capitalisme américain, le froid suédois et la qualité de vie, et, enfin, une pincée d' <i>abondance</i> napolitaine.  En modifiant légèrement le théorème d'origine, en supprimant un peu de précision suisse, nous obtenons la Hollande (0,68) comme résultat des <code>++-</code> - <code>++-</code> : assez impressionnant, pour être honnête. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd8/f76/e41/fd8f76e41d78598394d1613652f44f26.png"><br>  <i><font color="gray">Figure 4. Pour tous les lecteurs néerlandais: prenez cela comme un compliment, d'accord?</font></i> <br><br>  De bonnes ressources pratiques peuvent être trouvées <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> pour utiliser ces représentations vectorielles pré-entraînées.  <b>Gensim</b> est une bibliothèque Python simple et complète avec des fonctions algébriques et de similitude prêtes à l'emploi.  Ces représentations vectorielles pré-entraînées peuvent être utilisées de diverses manières (et utiles), par exemple, pour améliorer les performances des analyseurs d'humeur ou des modèles de langage.  Quelle que soit la tâche, l'utilisation de vecteurs à N dimensions améliorera considérablement l'efficacité du modèle par rapport au codage direct.  Bien sûr, une formation aux représentations vectorielles dans une zone spécifique améliorera encore le résultat, mais cela peut nécessiter, peut-être, un effort et un temps excessifs. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435984/">https://habr.com/ru/post/fr435984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435970/index.html">Guide du débutant pour le développement de serveurs Web avec Node.js</a></li>
<li><a href="../fr435972/index.html">Présentation de la programmation réactive au printemps</a></li>
<li><a href="../fr435974/index.html">Three.js - faire des contrôles pour l'espace ou le planétarium</a></li>
<li><a href="../fr435976/index.html">WebAssembly en production et le «champ de mines» de la Smart TV: un entretien avec Andrei Nagikh</a></li>
<li><a href="../fr435978/index.html">Solutions de contournement de la protection biométrique</a></li>
<li><a href="../fr435986/index.html">Windows réservera 7 Go pour les mises à jour du système afin d'éviter de manquer d'espace sur le disque dur</a></li>
<li><a href="../fr435988/index.html">Une introduction aux annotations de type Python. Continuation</a></li>
<li><a href="../fr435990/index.html">Comment faire un changement?</a></li>
<li><a href="../fr435992/index.html">Les joueurs Fallout 76, qui seront capturés dans un endroit secret des développeurs, seront interdits</a></li>
<li><a href="../fr435994/index.html">Est-ce Karma, bébé, ou pourquoi l'attaque sur les réseaux sans fil qui devait sombrer dans l'oubli est toujours vivante</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>