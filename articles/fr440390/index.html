<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♻️ 👩🏻‍🔧 🕜 Le monde diversifié des systèmes embarqués et la place d'Embox dans celui-ci 🧑🏼 😇 🍤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le projet Embox a déjà 9 ans, mais beaucoup ne comprennent pas de quoi il s'agit et avec quoi il est mangé et pourquoi il est nécessaire. Certains de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le monde diversifié des systèmes embarqués et la place d'Embox dans celui-ci</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/440390/"><img src="https://habrastorage.org/webt/ep/jc/qp/epjcqpyctt_7bt0cwewzqkz1iyg.jpeg" align="right" width="320">  Le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Embox</a> a déjà 9 ans, mais beaucoup ne comprennent pas de quoi il s'agit et avec <s>quoi il est mangé et</s> pourquoi il est nécessaire.  Certains de ceux qui ont entendu parler du projet et savent qu'il s'agit d'un système d'exploitation, pensent qu'Embox est un «système d'exploitation domestique».  En effet, Embox a été conçu comme une tentative de faire «leur» OS avec «blackjack et bateaux», mais l'essentiel est «blackjack et bateaux».  C'est-à-dire que certaines caractéristiques ou leur combinaison, qui faisaient défaut dans d'autres projets, ont été mises en avant. <br><br>  Bien sûr, personne n'allait écrire un système d'exploitation universel, même avec des puces.  Le slogan Embox - «Boîte à outils essentielle pour le développement embarqué» - implique que le projet vise les systèmes embarqués.  Cependant, ce concept est très large, il comprend: l'Internet des objets (IoT) et les robots, diverses framboises (RaPi) et systèmes embarqués, arduinki et ASU-TP, ...  La liste, comme vous le savez, peut durer très longtemps, il y a des endroits où Linux vit bien, et il y a des endroits où Linux est redondant et divers petits RTOS sont utilisés.  Dans cet article, je voudrais parler du monde embarqué dans toute sa diversité, et aussi de la place d'Embox en lui. <br><a name="habracut"></a><br><h2>  Ordinateurs à carte unique </h2><br><h3>  Ordinateurs industriels </h3><br>  Commençons par les ordinateurs à carte unique.  Beaucoup d'entre eux sont fabriqués en design industriel.  La plupart sont construits sur des processeurs avec des architectures ARM et x86.  Beaucoup de gens pensent que les processeurs x86 ne sont pas utilisés dans ce segment, et tout est limité aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">framboises</a> , aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">beagleboards</a> , aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bananes</a> , etc.  Mais bien avant RaPi, il y avait d'autres machines à carte unique destinées au segment des PC industriels, ce qu'on appelle le facteur de forme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PC / 104</a> .  Ils étaient inférieurs en termes de performances aux ordinateurs de bureau conventionnels, car ils étaient destinés à des tâches dans lesquelles la fiabilité l'emporte sur la fonctionnalité.  Pour la même raison, Linux n'était pas souvent utilisé comme système d'exploitation pour ces plates-formes matérielles; il existait divers systèmes d'exploitation propriétaires avec des propriétés en temps réel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VxWorks</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">QNX</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LynxOS,</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">etc.</a> ).  Je n'ai pas écrit «RTOS» (auquel j'inclus tous les trois de ces systèmes d'exploitation) pour la raison que, souvent, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Windows CE</a> et son développement de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Windows Embedded</a> étaient situés sur ces plates-formes matérielles.  Et je ne tourne pas la langue pour attribuer tout ce zoo au RTOS. <br><br><h3>  Payeur unique consommateur </h3><br>  Malinki a établi une tendance complètement différente.  En effet, ils ne visent pas les systèmes industriels en temps réel, mais le segment de la consommation, dans lequel le rapport prix / fonctionnalité est valorisé, et les framboises (et analogues) sont nettement en avance sur leurs concurrents dans ce paramètre.  Après tout, lorsque vous achetez pour un prix conditionnel de 30 à 50 $, vous obtenez une unité centrale à part entière, avec laquelle vous pouvez facilement créer un appareil avec des fonctionnalités plutôt compliquées en utilisant des outils Linux.  Ceci est très utile pour le prototypage ou le bricolage.  De plus, bien sûr, la framboise peut être utilisée comme un PC ou un petit serveur.  Par conséquent, les distributions Linux prêtes à l'emploi sont souvent utilisées comme système d'exploitation, tout d'abord, bien sûr, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Raspbian</a> - Debian pour Raspberry Pi, ou une distribution avec un nom amusant pour les russophones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pidora</a> - Fedora pour RaspberryPi.  Pour d'autres plates-formes similaires, il existe également des distributions prêtes à l'emploi fournies par les fabricants d'équipements et les communautés de systèmes d'exploitation (fabricants).  D'accord, lorsque vous devez créer un prototype, le moyen le plus simple est de prendre des packages d'instructions prêts à l'emploi, d'écrire des fonctionnalités en python.  En conséquence, obtenez rapidement un prototype fonctionnel.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un exemple est un robot qui reconnaît une ligne à l'aide d'OpenCV</a> . <br><br><h2>  Linux dans les appareils embarqués </h2><br>  Mais le monde intégré est beaucoup plus large que les cartes à carte unique ARM standard.  De plus, ils constituent une part relativement petite des appareils, et leur principale contribution est la vulgarisation et la simplification de l'entrée dans le développement des appareils de cette classe.  Les périphériques série sont créés sur la base des mêmes processeurs (systèmes sur puce) ou similaires, mais les cartes sont conçues pour la tâche (projet, périphérique).  Par conséquent, les distributions standard sont au moins redondantes, car elles utilisent souvent une sorte de gestionnaire de packages, et vous pouvez facilement fournir beaucoup d'intéressants (mais inutiles pour résoudre une tâche spécifique).  Les appareils intégrés sont généralement livrés avec des fonctionnalités complètes, et il est même appelé firmware.  Il existe une autre classe de distributions Linux pour la création de firmware.  De telles distributions vous permettent «d'installer» les packages nécessaires de manière statique - en les assemblant dans le système de fichiers racine, et non de manière dynamique - à l'aide du gestionnaire de packages du référentiel.  En règle générale, ces distributions peuvent être construites non seulement pour les applications et bibliothèques d'application, mais également pour le noyau dans une configuration donnée.  Et souvent aussi un compilateur croisé, car la compilation sur le périphérique lui-même n'est au moins pas efficace. <br><br><h3>  Projet Yocto </h3><br>  À ce jour, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet Yocto</a> est la distribution la plus connue (un projet de création de distributions).  À son tour, il est basé sur un autre projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenEmbedded</a> bien connu, qui est une sorte de système de construction pour les distributions Linux.  Si vous souhaitez utiliser le Raspberry Pi non pas comme un petit système prêt à l'emploi, mais comme un appareil personnalisé avec Linux, alors <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Yocto</a> ou ses analogues seront une excellente option.  Personnellement, je ne vois pas de grands avantages à utiliser des distributions Linux non standard avec des morceaux de fer standard, mais si vous prévoyez de développer des appareils similaires ou si vous souhaitez apprendre les technologies elles-mêmes, cette approche semble la plus prometteuse.  Après tout, alors qu'un matériel spécialisé est en cours de développement, les programmeurs peuvent développer et déboguer leurs parties du système (algorithmes, pilotes, bibliothèques, ...).  Ce qui réduit considérablement le temps de développement, et donc le fameux TTM (time to market). <br><br><h3>  Openwrt </h3><br>  Un autre célèbre projet de micrologiciel basé sur Linux est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenWRT</a> .  Je suis sûr que ceux qui s'amusent avec la personnalisation des routeurs ont entendu parler de lui.  Sur la base de ce projet, le micrologiciel est conçu pour divers routeurs, qui sont un binaire, comprenant à la fois le noyau et le système de fichiers racine.  L'utilisation du firmware (plutôt que des distributions universelles) dans les systèmes embarqués est liée à l'idée que la fonctionnalité du système final est connue au moment de son développement, c'est-à-dire que même si la version du routeur est mise à jour, le firmware change entièrement avec toutes les fonctionnalités (ou une partie de ce firmware est remplacée de manière spéciale )  Installer, par exemple, des suites bureautiques, n'est généralement pas nécessaire, et souvent généralement interdit, car cela peut introduire sa propre incertitude.  Cette approche permet, entre autres, d'économiser considérablement sur le matériel.  Les mêmes routeurs, par exemple, ont un processeur beaucoup moins puissant et beaucoup moins de mémoire que les glandes universelles. <br><br><h2>  Systèmes en temps réel </h2><br>  Revenant au sujet des calculatrices industrielles, il est nécessaire de discuter du terme «système en temps réel».  Beaucoup de gens pensent que les systèmes en temps réel sont plus rapides.  Ceci est une erreur.  Probablement, il est lié à des locaux historiques.  Après tout, le terme lui-même est né lorsque les voitures étaient lentes.  Et l'utilisateur a remarqué que la réaction du système pouvait être à la traîne de ses actions.  Le terme «temps réel» signifiait que le système devait être sensible à toutes les influences, y compris les actions de l'opérateur.  Mais sur les ordinateurs modernes, il est peu probable que l'utilisateur (opérateur) remarque une inhibition.  Dans la grande majorité des cas, lorsque vous cliquez sur le menu, l'icône, le bouton, nous verrons immédiatement une refonte de l'écran, à moins bien sûr que tout soit en ordre (Internet est là, le processus ne se bloque pas, etc.).  Mais si quelque chose d'inattendu se produit, par exemple, la connexion est perdue, nous verrons comment les systèmes en temps réel diffèrent (devraient différer).  Nous redémarrerons simplement le smartphone normal.  Mais si ce système contrôle la centrale électrique, alors vous comprenez vous-même, ce n'est pas toujours possible.  Nous en concluons que le système en temps réel devrait répondre de manière prévisible et non rapide à tout événement ou ensemble d'événements, quels que soient son état et son environnement. <br><br><h3>  Linux dans les systèmes en temps réel </h3><br>  Naturellement, il y a eu (et il y aura) des tentatives pour créer un système en temps réel à partir de Linux.  Le plus célèbre est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTLinux</a> , à l'origine c'était un correctif pour Linux, remplaçant le " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">planificateur complètement honnête</a> " original, plus précisément, en insérant le sien, l'une des tâches définies par le planificateur Linux.  Ce planificateur a fonctionné sur les priorités de tâches statiques; en conséquence, il a fonctionné de manière beaucoup plus prévisible.  Mais ce n'était plus Linux, ou plutôt, la fonctionnalité Linux n'était pas en temps réel. <br><br><h3>  ARINC-653 </h3><br>  Une autre approche pour fournir en temps réel, quelque peu similaire au patch RT pour Linux, est l'approche requise par la norme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ARINC653</a> ou l'approche dite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MILS</a> .  Cette approche implique que le système est conçu en couches, la couche inférieure implique un hyperviseur très léger, basé sur les tâches de degrés de criticité variables qui sont effectuées dans des sections définies statiquement.  J'ai appelé l'hyperviseur très léger car cela implique qu'il a la plus haute criticité et donc son code (algorithmes) doit être vérifié aussi complètement que possible (idéalement, l'absence de situations non traitées doit être prouvée mathématiquement).  Par conséquent, le code doit être aussi petit que possible.  Eh bien, et Linux, comme vous l'avez probablement compris, se trouve dans sa propre section. <br><br><h3>  uCLinux </h3><br>  Les tentatives d'utilisation de Linux dans des systèmes embarqués ont commencé il y a longtemps.  L'une des premières a été une tentative d'utilisation de Linux dans des systèmes où il n'y a pas de support matériel pour la mémoire virtuelle (MMU).  Ce projet s'appelait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">uCLinux</a> et sa contribution au noyau Linux était le mode sans <a href="">NOMMU</a> ou MMU. <br><br><h3>  Linux dans les systèmes en temps réel </h3><br>  Pour résumer les tentatives d'utilisation de Linux dans les systèmes en temps réel, vous devez répondre à la question de savoir pourquoi cela se produit.  Autrement dit, d'une part, Linux n'est pas particulièrement (pour le moment et dans sa forme pure) adapté aux systèmes en temps réel, et d'autre part, il y a des tentatives constantes de le faire.  Et cela se produit en raison de l'introduction de restrictions (remplacement du planificateur, introduction d'un hyperviseur, restrictions sur l'utilisation de la mémoire virtuelle, etc.).  La réponse, à mon avis, réside dans la présence de Linux une gigantesque base de code.  Ce sont des pilotes, ce sont des applications et des bibliothèques fonctionnelles.  Évidemment, si vous voulez créer un système fiable, vous devez utiliser autant que possible des pièces prêtes à l'emploi, car le développement de nouvelles pièces, que ce soit la logique fonctionnelle ou un pilote, contient toujours la probabilité d'introduire une erreur.  Et comme les systèmes modernes en temps réel ont des exigences fonctionnelles assez élevées, la réutilisation de fonctionnalités prêtes à l'emploi sous Linux devient de plus en plus tentante.  En d'autres termes, la mise à niveau de Linux vers un système en temps réel ne semble pas si coûteuse par rapport au développement de fonctionnalités, bien que basée sur un système d'exploitation en temps réel, car la fiabilité de l'ensemble du système, et pas seulement sa partie sous la forme du noyau du système d'exploitation, doit être fiable. <br><br><h3>  Windows dans les appareils intégrés </h3><br>  Je veux revenir à Windows pendant un certain temps.  À l'aube de ma carrière, j'ai eu une discussion avec un développeur plus expérimenté que Windows ne peut pas être utilisé dans des systèmes fiables.  À quoi il s'est opposé, si vous testez un système déjà terminé avec le logiciel fonctionnel nécessaire et interdisez tout changement: mises à jour, installation de logiciel, etc., le système sera suffisamment fiable pour de nombreuses tâches, dont celle que décidé.  Maintenant, je n'ai aucun doute que mon adversaire avait raison, pas moi.  De plus, même l'ancien MS-DOS est utilisé dans les systèmes industriels depuis très longtemps.  Le fait est que le multitâche, qui semble si nécessaire, introduit de l'incertitude.  Et si vous exécutez un logiciel qui contrôle complètement l'ensemble du système, vous pouvez obtenir un comportement beaucoup plus déterministe.  En d'autres termes, si un nombre indéfini de tâches tournent dans le système, il est peu probable qu'il soit possible d'obtenir une certitude dans le travail de toutes les fonctions du système.  Par conséquent, le moyen le plus simple d'augmenter la prévisibilité du système est de limiter sa fonctionnalité, et donc le rejet de l'universalité lors de l'exécution.  Ce que nous observons en fait dans les exemples d'utilisation de Linux dans les systèmes temps réel mentionnés ci-dessus. <br><br><h2>  Microcontrôleurs </h2><br>  L'exemple de MS-DOS comme système d'exploitation de base pour les systèmes temps réel industriels nous amène à l'idée que si vous utilisez uniquement votre propre logiciel, vous pouvez obtenir un comportement prévisible de l'ensemble du système.  Et ça l'est vraiment!  Certes, vous devez faire une réservation que cela n'est possible que si la fonctionnalité du système est petite et clairement fixée.  Si toutes les fonctionnalités du système consistent à contrôler le moteur à l'aide du GPIO et à recevoir (transmettre) un ensemble limité de commandes via l'interface UART, alors il n'est pas nécessaire d'utiliser le système d'exploitation, vous pouvez créer un firmware (ce qu'on appelle le bare-metal).  Cette approche est souvent utilisée dans les microcontrôleurs.  Mais depuis que les microcontrôleurs sont devenus volumineux (ARM 32 bits avec plusieurs Ko de RAM contre AVR-ok 8 bits avec cent octets de RAM), les demandes de fonctionnalités ont augmenté.  Désormais, lors du développement de micrologiciels, ils utilisent au moins des logiciels de fabricants, ce qui vous permet d'utiliser des exemples prêts à l'emploi pour travailler avec un microcontrôleur, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">STM32Cube</a> . <br><br><h3>  RTOS </h3><br>  Mais comme les exigences de fonctionnalité sont en constante augmentation, le micrologiciel des microcontrôleurs est de plus en plus fabriqué sur la base du soi-disant RTOS.  Contrairement aux grands systèmes d'exploitation en temps réel, il s'agit de projets open source relativement petits offrant un accès complet à tout le code du système.  Autrement dit, il existe une combinaison de concepts: d'une part, du code prêt à l'emploi est utilisé, et d'autre part, le développeur a un accès complet à tout dans le système, vous pouvez dire un micrologiciel nu. <br><br>  Il y a beaucoup de RTOS pour les microcontrôleurs.  Par conséquent, il est impossible de parler de tous.  Je ne citerai que quelques-uns, à mon avis, des projets intéressants et parlerai brièvement de leurs caractéristiques. <br><br><h4>  FreeRTOS </h4><br>  L'un des projets RTOS les plus populaires est probablement maintenant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FreeRTOS</a> .  Certains disent que ce n'est pas un système d'exploitation complet, mais seulement un planificateur.  Mais compte tenu des discussions ci-dessus sur le bare-metal, le grand nombre de microcontrôleurs pris en charge et le fait que de nombreux logiciels d'application sont écrits et intégrés, la petite fonctionnalité ressemble plus à une vertu qu'à un inconvénient.  Cela nous a permis de devenir une norme de facto pour les microcontrôleurs, comme cela est écrit sur le site Web du projet. <br><br><h4>  Contiki </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contiki</a> - RTOS développé par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Adam Dunkels</a> , créateur de piles TCP / IP bien connues comme lwIP et uIP.  Je dirais que l'ensemble du système d'exploitation est construit autour de la pile réseau.  La présence de la prise en charge IPv6 et les faibles besoins en ressources rendent ce projet intéressant pour la création de différents types d'appareils sans fil. <br><br><h4>  RTEMS </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTEMS</a> Real-Time Executive pour systèmes multiprocesseurs.  Développé à l'origine pour les militaires, l'acronyme signifie Real-Time Executive pour les systèmes de missiles, puis Real-Time Executive pour les systèmes militaires.  Projet open source assez ancien mais toujours vivant.  Représentant brillant de l'approche libOS.  Lorsque le logiciel développé est lié à un OS déjà assemblé, qui n'est pas seulement le noyau, mais aussi tous les services disponibles.  Il est compilé et fourni sous forme de bibliothèque au compilateur, ce qui est assez pratique dans les premiers stades de développement. <br><br><h4>  eCos </h4><br>  Système d'exploitation configurable intégré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">eCos</a> .  Également un projet assez ancien, auparavant très populaire.  L'idée principale est de créer un système d'exploitation très configurable, c'est-à-dire d'inclure dans le noyau uniquement ce dont vous avez besoin. <br><br><h4>  Autres RTOS </h4><br>  La liste continue depuis un certain temps.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Je</a> mentionnerai un autre projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NuttX</a> ci-dessous.  Et pour ceux qui sont intéressés par une liste plus détaillée, je vous conseille de regarder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipedia</a> .  Pour les microcontrôleurs, je <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mentionnerais</a> également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ChibiOS / RT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MicroC / OS (µC / OS)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nut / OS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RIOT</a> .  Mais bien sûr, tout dépend de la tâche. <br><br><h2>  Arduino </h2><br>  Je pense que parler d'embarqué serait incomplet sans mentionner Arduino.  Après tout, comme RaPi, ils sont très courants et ont grandement contribué à la popularisation des microcontrôleurs.  Je suis moi-même plutôt sceptique sur le thème de l'arduino, donc je vais ignorer les critiques des fans de cette technologie.  Mais sur le fait qu'il s'agit d'une technologie très intéressante, je peux donner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple de machine à pain, décrite sur un hub</a>  Très belle solution.  Eh bien, ou l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> déjà cité <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avec un robot qui reconnaît une ligne par openCV</a> , mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arduino y</a> est également utilisé. <br><br><h2>  Microkernel </h2><br>  Je n'ai jamais mentionné le concept d'un micro-noyau qui, comme beaucoup le savent, rend le système fiable et prévisible.  D'un côté, c'est vrai, mais de l'autre, comme toujours, pas tout à fait.  Plus précisément, bien sûr, c'est vrai, mais croire que ce concept (architecture) transformera immédiatement votre système en un système dur en temps réel est une illusion.  C’est plutôt un slogan marketing: «nous sommes un système en temps réel car nous sommes construits sur le principe d’un micronoyau».  Mais le principe d'un micro-noyau permet simplement de simplifier le développement logiciel, puisque la plupart des pièces sont réalisées dans l'espace utilisateur.  Mais que faire si vous avez un serveur cassé, ce qui est nécessaire pour travailler?  Vous le redémarrez, mais cela prend du temps, et si vous ne l’avez pas?  De plus, l'architecture micro-noyau classique a ses inconvénients!  Par exemple, c'est lent, car il y a beaucoup d'appels système (transferts de messages entre serveurs et logiciels d'application).  Sinon, tout le monde serait passé à une architecture micro-noyau pure depuis longtemps, et qui, par exemple, a vu des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projets sur L4</a> , mais ils le sont.  Eh bien, et bien sûr, beaucoup se souviennent de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">argument de Linus Torvalds avec Andrew Tanenbaum</a> . <br><br>  Autrement dit, le concept de micronoyau n'est pas une solution miracle.  Mais comme une très bonne idée, elle est appliquée à un degré ou à un autre dans la plupart des systèmes d'exploitation modernes.  Et la création d'un système fiable à la fin dépend toujours du développeur final et des capacités que le système d'exploitation fournit pour sa construction. <br><br><h2>  La place d'Embox dans les systèmes embarqués </h2><br>  J'ai déjà beaucoup parlé de divers aspects du monde embarqué, mais je n'y suis jamais allé à la place d'Embox.  Eh bien, je peux dire que dans les exemples décrits ci-dessus, il peut ne pas être nécessaire d'utiliser Embox.  De plus, nous demandons généralement aux utilisateurs pourquoi ils ont besoin d'Embox?  Si l'utilisation d'Embox ne donne aucun avantage, nous vous recommandons d'essayer quelque chose dans la liste ci-dessus ou autre chose (par exemple, Android).  Mais il existe un certain nombre de cas dans lesquels l'utilisation d'Embox donne un gain tangible. <br><br><h3>  Système de développement d'équipement </h3><br>  Je vais commencer par la première utilisation d'Embox.  Il n'était même pas un Embox à l'époque, mais était une sorte de code C et assembleur, qui vous permettait de démarrer très rapidement et d'exécuter du code utilitaire.  À ce moment, c'était un projet pour aider les ingénieurs à déboguer les équipements développés dans les FPGA.     ,  ,   ,      RTEMS.  ,         .        “”,      ,     .     ,      TCL,      .             (   ),        . <br><br><h3>  Linux </h3><br>            .   ,   ,   :    (UDP),  ,    .          Linux.     x86   ARM.   .   ,    ,        .    Linux,    500 .  ,      #ifdef   .  ,     ,    . Embox       ,            .        Mybuild,         ,   .     ,          (  ) ,          . <br><br><h3> Linux  Linux </h3><br>      .       Linux,   -         .  Embox             Linux.       ,  Qt (embedded-)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   SIP-</a> .  ,    Embox    ,      . <br><br>   POSIX-             — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NuttX</a> .  -     Embox,  - — .   Qt  SIP-,   , NuttX   .     . <br><br>   ,   RTOS    POSIX. , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FreeRTOS</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://archive.today/20130103183712/">RTEMS,       POSIX Profile 52,  « ,  ,  »</a> .  RTEMS       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qt  </a> <br><br><h3>  Linux </h3><br>            RTOS,        ,   ,       ,   . ,  Linux      ,  -         ( ,  ,     .).  ,    ,  ,  ,      ,    .            . , ,       - , , ,    ,      . ,      ,  ,  .        ,      . <br><br><h3> Linux   </h3><br>       Linux     .     ,     .  ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">     OpenCV</a> .    ,    ,  OpenCV   RaPi,        Arduino.     :  — ,  — ,      ,     Linux    .    ,  Embox         Linux.          OpenCV ,   . <br><br>   ,      Linux     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> —  ,    -,     </a> .         ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . <br><br><h3> Internet of Things </h3><br> Embox,     RTOS  ,     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>        stm32vl-discovery.  Embox   16- MSP-430 c 512  .   , ,      ,  ,      POSIX-,      (light threads). ,        , ,        .  “”       IoT.         .      - .         Embox,   ,   ,  ,    .  -,  ,        ,    ,            .  -,        ,      . <br><br>                <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   CodeFreeze</a> . <br><br><h2>  Conclusion </h2><br>         embedded .        , , , -.       ,       “”   embedded. ,    ,   ,   - !        . <br><br> PS   , Embox   “embedded”,    “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">opensource</a> ”.  ,        ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440390/">https://habr.com/ru/post/fr440390/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440374/index.html">Les fonctions Yandex envoient du courrier</a></li>
<li><a href="../fr440378/index.html">Retour aux microservices avec Istio. 2e partie</a></li>
<li><a href="../fr440382/index.html">200 est-il bon ou mauvais?</a></li>
<li><a href="../fr440386/index.html">Libérer la gestion des erreurs en éliminant les erreurs</a></li>
<li><a href="../fr440388/index.html">Intervalles: la prochaine évolution C ++</a></li>
<li><a href="../fr440392/index.html">WebRTC sur votre site - pas de bugs et pas de budget</a></li>
<li><a href="../fr440394/index.html">PostgreSQL elévation de privilèges - CVE-2018-10915 parsing</a></li>
<li><a href="../fr440398/index.html">Historique de la participation (et de la victoire) à la Russian AI Cup 2018 - CodeBall</a></li>
<li><a href="../fr440400/index.html">Apache Kafka + Spring Boot: Bonjour, microservices</a></li>
<li><a href="../fr440402/index.html">Développeur SearchFace sur les fonctionnalités de l'algorithme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>