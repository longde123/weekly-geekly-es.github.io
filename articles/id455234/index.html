<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☑️ 🗒️ 🥐 Jenis referensi dapat dihapus dalam C # 8.0 dan analisis statis 💴 🤱🏽 👨‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bukan rahasia lagi bahwa Microsoft telah bekerja pada versi ke-8 bahasa C # selama beberapa waktu. Versi bahasa baru (C # 8.0) sudah tersedia dalam ri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jenis referensi dapat dihapus dalam C # 8.0 dan analisis statis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/455234/"><p><img src="https://habrastorage.org/getpro/habr/post_images/523/17b/496/52317b4960a8b063bc7b6541e4e2666d.png" alt="Gambar 9"></p><br>  Bukan rahasia lagi bahwa Microsoft telah bekerja pada versi ke-8 bahasa C # selama beberapa waktu.  Versi bahasa baru (C # 8.0) sudah tersedia dalam rilis Visual Studio 2019 baru-baru ini, tetapi masih dalam versi beta.  Versi baru ini akan menerapkan beberapa fitur dengan cara yang agak tidak jelas, atau agak tak terduga.  Jenis Referensi Nullable adalah salah satunya.  Fitur ini diumumkan sebagai sarana untuk melawan Pengecualian Referensi Null (NRE). <br><a name="habracut"></a><br>  Sangat bagus melihat bahasa berkembang dan mendapatkan fitur baru untuk membantu pengembang.  Secara kebetulan, beberapa waktu lalu, kami secara signifikan meningkatkan kemampuan penganalisis C # PVS-Studio untuk mendeteksi NRE.  Dan sekarang kita bertanya-tanya apakah analisa statis pada umumnya dan PVS-Studio pada khususnya masih harus repot-repot untuk mendiagnosis potensi referensi kosong karena, setidaknya dalam kode baru yang akan menggunakan Referensi Nullable, referensi semacam itu akan menjadi "mustahil"?  Mari kita coba membersihkannya. <br><br><h2>  Pro dan kontra dari fitur baru </h2><br>  Satu pengingat sebelum kita melanjutkan: versi beta terbaru dari C # 8.0, tersedia saat menulis posting ini, telah menonaktifkan jenis Referensi Nullable secara default, yaitu perilaku tipe referensi tidak berubah. <br><br>  Jadi, apa jenis referensi nullable yang sebenarnya ada di C # 8.0 jika kita mengaktifkan opsi ini?  Mereka pada dasarnya adalah tipe referensi lama yang sama baik kecuali bahwa sekarang Anda harus menambahkan '?'  setelah nama tipe (misalnya, <i>string?</i> ), mirip dengan <i>Nullable &lt;T&gt;</i> , mis. jenis nilai nullable (misalnya, <i>int?</i> ).  Tanpa '?', Tipe <i>string</i> kami sekarang akan ditafsirkan sebagai referensi yang tidak dapat <i>dibatalkan</i> , yaitu jenis referensi yang tidak dapat ditetapkan <i>nol</i> . <br><br>  Null Reference Exception adalah salah satu pengecualian yang paling menjengkelkan untuk masuk ke program Anda karena tidak banyak berbicara tentang sumbernya, terutama jika metode melempar berisi sejumlah operasi dereferensi secara berurutan.  Kemampuan untuk melarang penetapan nol ke variabel tipe referensi terlihat keren, tetapi bagaimana dengan kasus-kasus di mana melewatkan <i>null</i> ke suatu metode memiliki beberapa logika eksekusi tergantung padanya?  Alih-alih <i>nol</i> , kita bisa, tentu saja, menggunakan nilai literal, konstan, atau hanya "tidak mungkin" yang secara logis tidak dapat ditugaskan ke variabel di tempat lain.  Tapi ini menimbulkan risiko mengganti crash program dengan "silent", tetapi eksekusi salah, yang seringkali lebih buruk daripada menghadapi kesalahan segera. <br><br>  Bagaimana kalau melempar pengecualian?  Pengecualian yang berarti yang dilemparkan ke lokasi di mana terjadi kesalahan selalu lebih baik daripada <i>NRE di</i> suatu tempat di atas atau di bawah tumpukan.  Tapi itu hanya baik dalam proyek Anda sendiri, di mana Anda dapat memperbaiki konsumen dengan memasukkan blok <i>uji coba</i> dan itu semata-mata tanggung jawab Anda.  Saat mengembangkan pustaka menggunakan Referensi (non) Nullable, kami perlu menjamin bahwa metode tertentu selalu mengembalikan nilai.  Bagaimanapun, itu tidak selalu mungkin (atau paling tidak mudah) bahkan dalam kode Anda sendiri untuk mengganti kembalinya <i>nol</i> dengan melempar pengecualian (karena dapat mempengaruhi terlalu banyak kode). <br><br>  Referensi Nullable dapat diaktifkan baik di tingkat proyek global dengan menambahkan properti <i>NullableContextOptions</i> dengan nilai <i>diaktifkan,</i> atau pada tingkat file dengan menggunakan arahan preprosesor: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable string cantBeNull = string.Empty; string? canBeNull = null; cantBeNull = canBeNull!;</span></span></code> </pre> <br>  Fitur Referensi Nullable akan membuat tipe lebih informatif.  Tanda tangan metode memberi Anda petunjuk tentang perilakunya: apakah cek nol atau tidak, apakah bisa mengembalikan <i>nol</i> atau tidak.  Sekarang, ketika Anda mencoba menggunakan variabel referensi nullable tanpa memeriksanya, kompiler akan mengeluarkan peringatan. <br><br>  Ini cukup nyaman saat menggunakan pustaka pihak ketiga, tetapi juga menambah risiko menyesatkan pengguna pustaka, karena masih mungkin untuk melewati <i>null</i> menggunakan operator null-forgiving baru (!).  Artinya, menambahkan hanya satu tanda seru dapat mematahkan semua asumsi lebih lanjut tentang antarmuka menggunakan variabel seperti: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length;</span></span></code> </pre> <br>  Ya, Anda dapat berargumen bahwa ini adalah pemrograman yang buruk dan tidak ada yang akan menulis kode seperti itu secara nyata, tetapi selama ini berpotensi dilakukan, Anda tidak dapat merasa aman hanya mengandalkan kontrak yang diberlakukan oleh antarmuka metode yang diberikan ( mengatakan bahwa itu tidak dapat mengembalikan <i>nol</i> ). <br><br>  Omong-omong, Anda bisa menulis kode yang sama menggunakan beberapa <i>!</i>  operator, seperti C # sekarang memungkinkan Anda untuk melakukannya (dan kode tersebut dapat dikompilasi dengan sempurna): <br><br><pre> <code class="cpp hljs">cantBeNull = canBeNull!!!!!!!;</code> </pre> <br>  Dengan menulis seperti ini, kami dapat menekankan ide, “lihat, ini mungkin <i>nol</i> !!!”  (kami di tim kami, kami menyebutnya pemrograman "emosional").  Bahkan, ketika membangun pohon sintaks, kompiler (dari Roslyn) menafsirkan <i>!</i>  Operator dengan cara yang sama seperti menafsirkan tanda kurung biasa, yang berarti Anda dapat menulis sebanyak mungkin <i>!</i>  Terserah Anda - seperti halnya dengan tanda kurung.  Tetapi jika Anda cukup menulisnya, Anda dapat "merobohkan" kompiler.  Mungkin ini akan diperbaiki di rilis final C # 8.0. <br><br>  Demikian pula, Anda dapat menghindari peringatan kompiler saat mengakses variabel referensi yang tidak dapat dibatalkan tanpa centang: <br><br><pre> <code class="cpp hljs">canBeNull!.ToString();</code> </pre> <br>  Mari kita tambahkan lebih banyak emosi: <br><br><pre> <code class="cpp hljs">canBeNull!!!?.ToString();</code> </pre> <br>  Anda tidak akan pernah melihat sintaks seperti itu dalam kode nyata.  Dengan menulis operator <i>pengampunan nol,</i> kami memberi tahu kompiler, "Kode ini baik-baik saja, periksa tidak diperlukan."  Dengan menambahkan operator Elvis, kami memberi tahu, “Atau mungkin tidak;  mari kita periksa untuk berjaga-jaga. " <br><br>  Sekarang, Anda dapat dengan wajar bertanya mengapa Anda masih dapat menetapkan <i>nol</i> untuk variabel tipe referensi yang tidak dapat <i>dibatalkan</i> dengan mudah jika konsep tipe ini menyiratkan bahwa variabel tersebut tidak dapat memiliki nilai <i>nol</i> ?  Jawabannya adalah bahwa "di bawah tenda", pada tingkat kode IL, tipe referensi tidak dapat dibatalkan masih ... jenis referensi "biasa" yang lama dan bagus, dan seluruh sintaks nullabilitas sebenarnya hanyalah anotasi untuk built-in kompiler analyzer (yang, kami percaya, tidak cukup nyaman untuk digunakan, tapi saya akan menguraikannya nanti).  Secara pribadi, kami tidak menganggapnya sebagai solusi "rapi" untuk memasukkan sintaks baru hanya sebagai anotasi untuk alat pihak ketiga (bahkan dibangun ke dalam kompiler) karena fakta bahwa ini hanya anotasi mungkin tidak jelas sama sekali untuk programmer, karena sintaks ini sangat mirip dengan sintaks untuk struct nullable namun bekerja dengan cara yang sama sekali berbeda. <br><br>  Kembali ke cara lain untuk memecahkan jenis Referensi Nullable.  Pada saat penulisan artikel ini, ketika Anda memiliki solusi yang terdiri dari beberapa proyek, melewati variabel tipe referensi, katakanlah, <i>String</i> dari metode yang dideklarasikan dalam satu proyek ke metode di proyek lain yang memiliki <i>NullableContext</i> kompiler menganggap itu berurusan dengan String yang tidak dapat dibatalkan dan kompiler akan tetap diam.  Dan itu terlepas dari banyak atribut <i>[Nullable (1)] yang</i> ditambahkan ke setiap bidang dan metode dalam kode IL saat mengaktifkan Referensi Nullable <i>.</i>  Atribut ini, omong-omong, harus diperhitungkan jika Anda menggunakan refleksi untuk menangani atribut dan menganggap bahwa kode hanya berisi yang Anda kustom. <br><br>  Situasi seperti itu dapat menyebabkan masalah tambahan saat mengadaptasi basis kode besar dengan gaya Referensi Nullable.  Proses ini kemungkinan akan berjalan untuk sementara waktu, proyek demi proyek.  Jika Anda berhati-hati, tentu saja, Anda dapat secara bertahap mengintegrasikan fitur baru, tetapi jika Anda sudah memiliki proyek yang berfungsi, setiap perubahan itu berbahaya dan tidak diinginkan (jika berfungsi, jangan menyentuhnya!).  Itu sebabnya kami memastikan bahwa Anda tidak perlu mengubah kode sumber Anda atau menandainya untuk mendeteksi potensi <i>NRE</i> saat menggunakan penganalisa PVS-Studio.  Untuk memeriksa lokasi yang bisa melempar <i>NullReferenceException,</i> cukup jalankan alat analisa dan cari peringatan V3080.  Tidak perlu mengubah properti proyek atau kode sumber.  Tidak perlu menambahkan arahan, atribut, atau operator.  Tidak perlu mengubah kode lawas. <br><br>  Ketika menambahkan dukungan Referensi Nullable ke PVS-Studio, kami harus memutuskan apakah penganalisa harus mengasumsikan bahwa variabel tipe referensi yang tidak dapat dibatalkan selalu memiliki nilai yang bukan nol.  Setelah menyelidiki cara jaminan ini dapat dilanggar, kami memutuskan bahwa PVS-Studio tidak boleh membuat asumsi seperti itu.  Bagaimanapun, bahkan jika suatu proyek menggunakan tipe referensi yang tidak dapat dibatalkan sepanjang jalan, penganalisa dapat menambah fitur ini dengan mendeteksi situasi spesifik di mana variabel tersebut dapat memiliki nilai <i>nol</i> . <br><br><h2>  Bagaimana PVS-Studio mencari Pengecualian Referensi Null </h2><br>  Mekanisme aliran data dalam C # analyzer PVS-Studio melacak kemungkinan nilai variabel selama proses analisis.  Ini juga termasuk analisis antar-prosedur, yaitu melacak kemungkinan nilai yang dikembalikan oleh suatu metode dan metode yang disarangkan, dan seterusnya.  Selain itu, PVS-Studio mengingat variabel yang dapat diberi nilai <i>nol</i> .  Setiap kali ia melihat variabel seperti itu dereferensi tanpa cek, apakah itu dalam kode saat ini dalam analisis, atau di dalam metode yang dipanggil dalam kode ini, ia akan mengeluarkan peringatan V3080 tentang potensi Null Reference Exception. <br><br>  Gagasan di balik diagnostik ini adalah membuat penganalisa marah hanya ketika melihat tugas <i>nol</i> .  Ini adalah perbedaan utama dari perilaku diagnostik kami dari perilaku penganalisa bawaan kompiler yang menangani jenis Referensi Nullable.  Alat analisis bawaan akan menunjuk pada setiap dan setiap dereferensi variabel referensi yang tidak dapat dicentang - mengingat bahwa itu belum disesatkan oleh penggunaan <i>!</i>  operator atau bahkan hanya pemeriksaan rumit (perlu dicatat, bahwa benar-benar ada penganalisa statis, PVS-Studio tidak terkecuali di sini, dapat "disesatkan" dengan satu atau lain cara, terutama jika Anda bermaksud melakukannya). <br><br>  PVS-Studio, di sisi lain, memperingatkan Anda hanya jika ia melihat <i>nol</i> (apakah dalam konteks lokal atau konteks metode luar).  Bahkan jika variabel adalah tipe referensi yang tidak dapat dibatalkan, penganalisis akan terus menunjuk padanya jika ia melihat penugasan <i>nol</i> untuk variabel itu.  Pendekatan ini, kami percaya, lebih tepat (atau setidaknya lebih nyaman bagi pengguna) karena tidak menuntut "mengolesi" seluruh kode dengan pemeriksaan nol untuk melacak referensi potensial - setelah semua, opsi ini tersedia bahkan sebelum Nullable Reference diperkenalkan, misalnya, melalui penggunaan kontrak.  Terlebih lagi, penganalisa sekarang dapat memberikan kontrol yang lebih baik atas variabel referensi yang tidak dapat dibatalkan sendiri.  Jika variabel seperti itu digunakan "cukup" dan tidak pernah ditugaskan <i>nol</i> , PVS-Studio tidak akan mengatakan apa-apa.  Jika variabel ditetapkan <i>nol</i> dan kemudian direferensikan tanpa pemeriksaan sebelumnya, PVS-Studio akan mengeluarkan peringatan V3080: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length; &lt;== V3080: Possible null dereference. Consider inspecting </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'str'</span></span></span></span></code> </pre> <br>  Sekarang mari kita lihat beberapa contoh yang menunjukkan bagaimana diagnostik ini dipicu oleh kode Roslyn itu sendiri.  Kami sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memeriksa proyek ini</a> baru-baru ini, tetapi kali ini kami hanya akan melihat potensi Pengecualian Referensi Null yang tidak disebutkan dalam artikel sebelumnya.  Kita akan melihat bagaimana PVS-Studio mendeteksi potensi NRE dan bagaimana mereka dapat diperbaiki menggunakan sintaks Referensi Nullable yang baru. <br><br>  <i>V3080 [CWE-476] Kemungkinan null dereference di dalam metode.</i>  <i>Pertimbangkan memeriksa argumen 2: chainedTupleType.</i>  <i>Microsoft.CodeAnalysis.CSharp TupleTypeSymbol.cs 244</i> <br><br><pre> <code class="cpp hljs">NamedTypeSymbol chainedTupleType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_underlyingType.Arity &lt; TupleTypeSymbol.RestPosition) { .... chainedTupleType = null; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Create(ConstructTupleUnderlyingType(firstTupleType, chainedTupleType, newElementTypes), elementNames: _elementNames);</code> </pre> <br>  Seperti yang Anda lihat, variabel <i>chainedTupleType</i> dapat diberi nilai <i>nol</i> di salah satu cabang eksekusi.  Ini kemudian diteruskan ke metode <i>ConstructTupleUnderlyingType</i> dan digunakan di sana setelah pemeriksaan <i>Debug.Assert</i> .  Ini adalah pola yang sangat umum di Roslyn, tetapi perlu diingat bahwa <i>Debug.Assert</i> dihapus dalam versi rilis.  Itu sebabnya penganalisa masih menganggap dereferensi di dalam metode <i>ConstructTupleUnderlyingType</i> berbahaya.  Inilah inti dari metode itu, di mana dereference berlangsung: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NamedTypeSymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstructTupleUnderlyingType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NamedTypeSymbol firstTupleType, NamedTypeSymbol chainedTupleTypeOpt, ImmutableArray&lt;TypeWithAnnotations&gt; elementTypes)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert (chainedTupleTypeOpt is null == elementTypes.Length &lt; RestPosition); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loop &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... currentSymbol = chainedTupleTypeOpt.Construct(chainedTypes); loop--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentSymbol; }</code> </pre> <br>  Ini sebenarnya masalah perselisihan apakah penganalisis harus mempertimbangkan Asserts seperti itu (beberapa pengguna kami ingin melakukannya) - setelah semua, penganalisa memang mengambil kontrak dari System.Diagnostics.Contracts ke akun.  Berikut adalah satu contoh kecil kehidupan nyata dari pengalaman kami menggunakan Roslyn di penganalisa kami sendiri.  Sambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menambahkan dukungan dari Visual Studio versi terbaru baru-</a> baru ini, kami juga memperbarui Roslyn ke versi ke-3.  Setelah itu, PVS-Studio mulai crash pada kode tertentu yang belum pernah crash sebelumnya.  Kecelakaan, disertai dengan Pengecualian Referensi Null, akan terjadi bukan dalam kode kami tetapi dalam kode Roslyn.  Debugging mengungkapkan bahwa fragmen kode di mana Roslyn sekarang crash memiliki jenis <i>Debug</i> yang sangat baik. <i>Assert</i> berbasis nol memeriksa beberapa baris lebih tinggi - dan pemeriksaan itu jelas tidak membantu. <br><br>  Ini adalah contoh grafis tentang bagaimana Anda bisa mendapatkan masalah dengan Referen Nullable karena kompiler memperlakukan <i>Debug. Masukkan</i> sebagai cek yang dapat diandalkan dalam konfigurasi apa pun.  Yaitu, jika Anda menambahkan <i>#nullable aktifkan</i> dan tandai argumen <i>chainedTupleTypeOpt</i> sebagai referensi yang dapat <i>dibatalkan</i> <i>,</i> kompiler tidak akan mengeluarkan peringatan apa pun pada dereferensi di dalam metode <i>ConstructTupleUnderlyingType</i> . <br><br>  Pindah ke contoh peringatan lainnya oleh PVS-Studio. <br><br>  <i>V3080 Kemungkinan null dereference.</i>  <i>Pertimbangkan untuk memeriksa 'efektifRuleset'.</i>  <i>RuleSet.cs 146</i> <br><br><pre> <code class="cpp hljs">var effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, ....)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre><br>  Peringatan ini mengatakan bahwa panggilan metode <i>WithEffectiveAction</i> dapat mengembalikan <i>nol</i> , sedangkan nilai kembali yang ditetapkan ke variabel <i>efektifRuleset</i> tidak diperiksa sebelum digunakan ( <i>efektifRuleset.GeneralDiagnosticOption</i> ).  Inilah tubuh metode <i>WithEffectiveAction</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RuleSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithEffectiveAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_includes.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(....); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuleSet(....); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br>  Dengan Referensi Nullable diaktifkan untuk metode <i>GetEffectiveRuleSet</i> , kita akan mendapatkan dua lokasi di mana perilaku kode harus diubah.  Karena metode yang ditunjukkan di atas dapat melempar pengecualian, masuk akal untuk menganggap bahwa panggilan itu dibungkus dalam blok <i>try-catch</i> dan akan benar untuk menulis ulang metode untuk melempar pengecualian daripada mengembalikan <i>nol</i> .  Namun, jika Anda melacak beberapa panggilan kembali, Anda akan melihat bahwa kode penangkapan terlalu jauh untuk memprediksi konsekuensinya.  Mari kita lihat konsumen dari variabel <i>efektifRuleset,</i> metode <i>IsStricterThan</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStricterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action1, ReportDiagnostic action2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action2) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: ....; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Warn: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action1 == ReportDiagnostic.Error; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Seperti yang Anda lihat, ini adalah pernyataan beralih sederhana yang memilih antara dua enumerasi, dengan <i>ReportDiagnostic.Default</i> sebagai nilai default.  Jadi akan lebih baik untuk menulis ulang panggilan sebagai berikut: <br><br>  Tanda tangan <i>WithEffectiveAction</i> akan berubah: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public RuleSet? WithEffectiveAction(ReportDiagnostic action)</span></span></code> </pre> <br>  Ini akan menjadi seperti apa panggilan itu: <br><br><pre> <code class="cpp hljs">RuleSet? effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset?.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset?.GeneralDiagnosticOption ?? ReportDiagnostic.Default, effectiveGeneralOption)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre> <br>  Karena <i>IsStricterThan</i> hanya melakukan perbandingan, kondisinya dapat ditulis ulang - misalnya, seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effectiveRuleset == null || IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, effectiveGeneralOption))</code> </pre> <br>  Contoh selanjutnya. <br><br>  <i>V3080 Kemungkinan null dereference.</i>  <i>Pertimbangkan untuk memeriksa 'propertySymbol'.</i>  <i>BinderFactory.BinderFactoryVisitor.cs 372</i> <br><br><pre> <code class="cpp hljs">var propertySymbol = GetPropertySymbol(parent, resultBinder); var accessor = propertySymbol.GetMethod; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)accessor != null) resultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMethodBinder(accessor, resultBinder);</code> </pre> <br>  Untuk memperbaiki peringatan ini, kita perlu melihat apa yang terjadi pada variabel <i>propertySymbol</i> selanjutnya. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SourcePropertySymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertySymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)</span></span></span><span class="hljs-function"> </span></span>{ .... NamedTypeSymbol container = GetContainerType(outerBinder, basePropertyDeclarationSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)container == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SourcePropertySymbol)GetMemberSymbol(propertyName, basePropertyDeclarationSyntax.Span, container, SymbolKind.Property); }</code> </pre> <br>  Metode <i>GetMemberSymbol</i> juga dapat mengembalikan <i>nol</i> dalam kondisi tertentu. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Symbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMemberSymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memberName, TextSpan memberSpan, NamedTypeSymbol container, SymbolKind kind)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Symbol sym in container.GetMembers(memberName)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind != kind) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind == SymbolKind.Method) { .... var implementation = ((MethodSymbol)sym).PartialImplementationPart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)implementation != null) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(implementation.Locations[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> implementation; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(sym.Locations, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sym; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br>  Jika jenis referensi nullable diaktifkan, panggilan akan berubah menjadi ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable SourcePropertySymbol? propertySymbol = GetPropertySymbol(parent, resultBinder); MethodSymbol? accessor = propertySymbol?.GetMethod; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((object)accessor != null) resultBinder = new InMethodBinder(accessor, resultBinder);</span></span></code> </pre> <br>  Sangat mudah untuk memperbaikinya ketika Anda tahu di mana mencarinya.  Analisis statis dapat menangkap potensi kesalahan ini tanpa usaha dengan mengumpulkan semua kemungkinan nilai lapangan dari semua rantai panggilan prosedur. <br><br>  <i>V3080 Kemungkinan null dereference.</i>  <i>Pertimbangkan untuk memeriksa 'simpleName'.</i>  <i>CSharpCommandLineParser.cs 1556</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> simpleName; simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)); outputFileName = simpleName + outputKind.GetDefaultExtension(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (simpleName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !outputKind.IsNetModule()) ....</code> </pre> <br>  Masalahnya adalah sejalan dengan pemeriksaan <i>simpleName.Length</i> .  Variabel <i>simpleName</i> hasil dari mengeksekusi serangkaian metode yang panjang dan dapat ditugaskan <i>nol</i> .  Ngomong-ngomong, jika Anda penasaran, Anda bisa melihat metode <i>RemoveExtension</i> untuk melihat perbedaannya dari <i>Path.GetFileNameWithoutExtension.</i>  <i>SimpleName! =</i> Pemeriksaan <i>kosong</i> akan cukup, tetapi dengan jenis referensi yang tidak dapat dibatalkan, kode akan berubah menjadi seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public static string? RemoveExtension(string path) { .... } string simpleName;</span></span></code> </pre> <br>  Seperti inilah bentuk panggilannya: <br><br><pre> <code class="cpp hljs">simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)) ?? String.Empty;</code> </pre> <br><h2>  Kesimpulan </h2><br>  Jenis referensi Nullable bisa sangat membantu ketika mendesain arsitektur dari awal, tetapi pengerjaan ulang kode yang ada mungkin membutuhkan banyak waktu dan perawatan, karena dapat menyebabkan sejumlah bug yang sulit dipahami.  Artikel ini tidak bertujuan untuk mencegah Anda menggunakan jenis Referensi Nullable.  Kami menemukan fitur baru ini secara umum berguna walaupun cara penerapannya mungkin kontroversial. <br><br>  Namun, selalu ingat tentang keterbatasan pendekatan ini dan perlu diingat bahwa mengaktifkan mode Referensi Nullable tidak melindungi Anda dari NRE dan bahwa, ketika disalahgunakan, itu sendiri dapat menjadi sumber kesalahan ini.  Kami menyarankan Anda melengkapi fitur Referensi Nullable dengan alat analisis statis modern, seperti PVS-Studio, yang mendukung analisis antar-prosedur untuk melindungi program Anda dari NRE.  Masing-masing pendekatan ini - analisis antar-prosedur yang mendalam dan tanda tangan metode anotasi (yang sebenarnya apa yang dilakukan mode Referensi Nullable) - memiliki pro dan kontra.  Penganalisa akan memberi Anda daftar lokasi yang berpotensi berbahaya dan membiarkan Anda melihat konsekuensi dari memodifikasi kode yang ada.  Jika ada penugasan nol di suatu tempat, penganalisa akan menunjuk pada setiap konsumen dari variabel di mana dereferensi tanpa cek. <br><br>  Anda dapat memeriksa proyek ini atau proyek Anda sendiri untuk cacat lainnya - cukup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">unduh</a> PVS-Studio dan cobalah. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455234/">https://habr.com/ru/post/id455234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455218/index.html">Pendekatan Ekosistem untuk Teknologi Bisnis</a></li>
<li><a href="../id455224/index.html">Musik Jari: Mainkan Apa Pun Dengan Sphero's SpecDrums</a></li>
<li><a href="../id455226/index.html">Mengapa menerapkan ahli bahasa terapan?</a></li>
<li><a href="../id455228/index.html">The One Who Resurrected Duke Nukem: Wawancara dengan Randy Pitchford, Gearbox Wizard</a></li>
<li><a href="../id455230/index.html">Jenis Referensi Nullable dalam C # 8.0 dan Analisis Statis</a></li>
<li><a href="../id455236/index.html">Comodo mencabut sertifikat tanpa alasan</a></li>
<li><a href="../id455240/index.html">Menggunakan tingkat cacat yang ditolak untuk meningkatkan pelaporan kesalahan</a></li>
<li><a href="../id455242/index.html">Kurang telinga atau bagaimana tidak merusak suara dalam game dari awal</a></li>
<li><a href="../id455244/index.html">Komik "Soldering is Easy" dalam versi yang diperbarui (2019)</a></li>
<li><a href="../id455248/index.html">Kesalahan pengembangan teratas saat bekerja dengan PostgreSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>