<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜô ü§òüèº üëÑ DBA: ketika VACUUM lewat - kami membersihkan tabel secara manual üëõ üêû üàÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="VACUUM dapat "membersihkan" dari tabel di PostgreSQL hanya yang tidak dapat dilihat oleh siapa pun - yaitu, tidak ada satu pun permintaan aktif yang d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DBA: ketika VACUUM lewat - kami membersihkan tabel secara manual</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/481866/">  <a href="https://postgrespro.ru/docs/postgresql/12/routine-vacuuming">VACUUM</a> dapat "membersihkan" dari tabel di PostgreSQL hanya yang <b>tidak dapat dilihat</b> oleh <b>siapa pun</b> - yaitu, tidak ada satu pun permintaan aktif yang dimulai lebih awal dari catatan-catatan ini diubah. <br><br>  Tetapi jika ada jenis yang tidak menyenangkan (beban OLAP jangka panjang pada basis OLTP)?  Bagaimana cara <b>membersihkan meja yang aktif berubah</b> dikelilingi oleh pertanyaan panjang dan tidak menginjak menyapu? <br><br><img src="https://habrastorage.org/webt/ny/ux/jf/nyuxjfgkp2c4vvbi0j-jjhypski.png"><br><a name="habracut"></a><br><h2>  Kami menyebarkan menyapu </h2><br>  Pertama, kami menentukan apa itu dan bagaimana masalah yang ingin kami selesaikan dapat muncul. <br><br>  Biasanya situasi ini terjadi di <u>atas meja yang relatif kecil</u> , tetapi di mana ada <b>banyak perubahan</b> .  Biasanya, ini adalah <u>penghitung / agregat / peringkat yang berbeda</u> , di mana UPDATE sering-sering dieksekusi, atau <u>antrian penyangga</u> untuk memproses semacam aliran acara yang terus berjalan, catatan tentang yang selalu INSERT / HAPUS. <br><br>  Mari kita coba mereproduksi opsi dengan peringkat: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl(k <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, v <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl(v <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>); <span class="hljs-comment"><span class="hljs-comment">--       INSERT INTO tbl SELECT chr(ascii('a'::text) + i) k , 0 v FROM generate_series(0, 25) i;</span></span></code> </pre> <br>  Dan secara paralel, dalam koneksi yang berbeda, permintaan lama dimulai, mengumpulkan beberapa statistik kompleks, tetapi <b>tidak mempengaruhi tabel kami</b> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_sleep(<span class="hljs-number"><span class="hljs-number">10000</span></span>);</code> </pre> <br>  Sekarang kami memperbarui nilai salah satu penghitung berkali-kali.  Untuk kemurnian percobaan, kami akan melakukan ini <a href="https://habr.com/post/481610/">dalam transaksi terpisah menggunakan dblink</a> , karena ini akan terjadi dalam kenyataan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; tsb timestamp; tse timestamp; d double precision; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> PERFORM dblink_connect(<span class="hljs-string"><span class="hljs-string">'dbname='</span></span> || current_database() || <span class="hljs-string"><span class="hljs-string">' port='</span></span> || current_setting(<span class="hljs-string"><span class="hljs-string">'port'</span></span>)); FOR i IN 1..10000 LOOP tsb = clock_timestamp(); PERFORM dblink($e$<span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> v = v + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> k = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;$e$); tse = clock_timestamp(); IF i % 1000 = 0 THEN d = (extract('epoch' from tse) - extract('epoch' from tsb)) * 1000; RAISE NOTICE 'i = %, exectime = %', lpad(i::text, 5), lpad(d::text, 5); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; PERFORM dblink_disconnect(); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $$ LANGUAGE plpgsql;</code> </pre> <br><pre> <code class="plaintext hljs">NOTICE: i = 1000, exectime = 0.524 NOTICE: i = 2000, exectime = 0.739 NOTICE: i = 3000, exectime = 1.188 NOTICE: i = 4000, exectime = 2.508 NOTICE: i = 5000, exectime = 1.791 NOTICE: i = 6000, exectime = 2.658 NOTICE: i = 7000, exectime = 2.318 NOTICE: i = 8000, exectime = 2.572 NOTICE: i = 9000, exectime = 2.929 NOTICE: i = 10000, exectime = 3.808</code> </pre> <br>  Apa yang terjadi  Mengapa, bahkan untuk UPDATE paling sederhana dari satu catatan <b>, runtime terdegradasi sebanyak 7 kali</b> - dari 0,524 ms ke 3,808 ms?  Dan peringkat kami sedang dibangun lebih lambat dan lebih lambat. <br><br><h2>  MVCC yang harus disalahkan </h2><br>  Ini semua tentang <a href="https://habr.com/ru/company/postgrespro/blog/445820/">mekanisme MVCC</a> , yang memaksa permintaan untuk melihat semua versi catatan sebelumnya.  Jadi mari kita bersihkan meja kita dari versi "mati": <br><br><pre> <code class="sql hljs">VACUUM VERBOSE tbl;</code> </pre> <br><pre> <code class="plaintext hljs">INFO: vacuuming "public.tbl" INFO: "tbl": found 0 removable, 10026 nonremovable row versions in 45 out of 45 pages DETAIL: 10000 dead row versions cannot be removed yet, oldest xmin: 597439602</code> </pre> <br>  Oh, tidak ada yang perlu dibersihkan!  <b>Permintaan</b> paralel <b>mengganggu kita</b> - setelah semua, suatu hari dia mungkin ingin merujuk ke versi ini (bagaimana jika?), Dan mereka harus tersedia baginya.  Dan bahkan VACUUM FULL tidak akan membantu kami. <br><br><h2>  "Menjepit" meja </h2><br>  Tetapi kami tahu pasti bahwa tabel kami tidak membutuhkan kueri kami.  Oleh karena itu, mari kita coba mengembalikan kinerja sistem ke kerangka kerja yang memadai, setelah membuang semuanya berlebihan dari tabel - setidaknya "secara manual", sejak VACUUM berlalu. <br><br>  Untuk membuatnya lebih jelas, mari kita perhatikan contoh tabel buffer.  Artinya, ada aliran INSERT / DELETE besar, dan kadang-kadang tabel benar-benar kosong.  Tetapi jika tidak kosong di sana, kita harus <b>menyimpan isinya saat ini</b> . <br><br><h4>  # 0: evaluasi situasinya </h4><br>  Jelas bahwa Anda dapat mencoba melakukan sesuatu dengan tabel bahkan setelah setiap operasi, tetapi tidak masuk akal - overhead pemeliharaan akan jelas lebih besar daripada throughput dari permintaan yang ditargetkan. <br><br>  Kami merumuskan kriteria - "saatnya untuk bertindak", jika: <br><br><ul><li>  VACUUM sudah berjalan lama <br>  Kami mengharapkan beban yang besar, jadi biarlah <b>60 detik</b> dari VACUUM [otomatis] terakhir. </li><li>  ukuran tabel fisik lebih besar dari target <br>  Kami mendefinisikannya sebagai jumlah halaman berlipat ganda (blok 8KB) relatif terhadap ukuran minimum - <b>1 blk per heap + 1 blk untuk masing-masing indeks</b> - untuk tabel yang berpotensi kosong.  Jika kami berharap bahwa sejumlah data tertentu akan selalu tetap dalam buffer "secara normal", masuk akal untuk mengencangkan formula ini. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Permintaan Verifikasi</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relpages , (( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indrelid = cl.oid ) + <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">13</span></span> size_norm <span class="hljs-comment"><span class="hljs-comment">--    * current_setting('block_size')::bigint,     ?.. , pg_total_relation_size(oid) size , coalesce(extract('epoch' from (now() - greatest( pg_stat_get_last_vacuum_time(oid) , pg_stat_get_last_autovacuum_time(oid) ))), 1 &lt;&lt; 30) vaclag FROM pg_class cl WHERE oid = $1::regclass -- tbl LIMIT 1;</span></span></code> </pre> <br><pre> <code class="plaintext hljs">relpages | size_norm | size | vaclag ------------------------------------------- 0 | 24576 | 1105920 | 3392.484835</code> </pre> </div></div><br><h4>  # 1: Pokoknya VACUUM </h4><br>  Kami tidak dapat mengetahui sebelumnya apakah permintaan paralel benar-benar menghambat kami - persis berapa banyak rekaman yang ‚Äúkedaluwarsa‚Äù sejak awal.  Oleh karena itu, ketika kami memutuskan untuk memproses tabel tersebut, bagaimanapun, Anda harus terlebih dahulu menjalankan <b>VACUUM</b> di atasnya - itu, tidak seperti VACUUM FULL, tidak mengganggu proses paralel dengan data baca-tulis. <br><br>  Pada saat yang sama, dia dapat segera membersihkan sebagian besar dari apa yang ingin kita hapus.  Ya, dan permintaan selanjutnya untuk tabel ini akan diberikan kepada kami <b>dalam "hot cache"</b> , yang akan mengurangi durasinya - dan, karenanya, total waktu untuk memblokir orang lain dengan transaksi penayangan kami. <br><br><h4>  # 2: Apakah ada orang di rumah? </h4><br>  Mari kita periksa - apakah ada sesuatu di tabel: <br><br><pre> <code class="sql hljs">TABLE tbl LIMIT 1;</code> </pre> <br>  Jika tidak ada satu catatan pun yang tersisa, maka kita dapat menghemat banyak pada pemrosesan - hanya dengan melakukan <a href="https://postgrespro.ru/docs/postgresql/12/sql-truncate">TRUNCATE</a> <br><br><blockquote>  Kerjanya dengan cara yang sama seperti perintah DELETE tanpa syarat untuk setiap tabel, tetapi jauh lebih cepat, karena sebenarnya tidak memindai tabel.  Selain itu, ia segera membebaskan ruang disk, jadi tidak perlu melakukan operasi VACUUM setelahnya. </blockquote>  Apakah Anda perlu mengatur ulang penghitung urutan tabel (RESTART IDENTITY) secara bersamaan - putuskan sendiri. <br><br><h4>  # 3: Semuanya - pada gilirannya! </h4><br>  Karena kami bekerja dalam kondisi daya saing tinggi, sementara kami memeriksa di sini untuk tidak adanya entri dalam tabel, seseorang sudah bisa menulis sesuatu di sana.  Kita tidak boleh kehilangan informasi ini, jadi apa?  Itu benar, itu harus dilakukan agar tidak ada yang bisa merekam dengan pasti. <br><br>  Untuk melakukan ini, kita perlu mengaktifkan isolasi <b>SERIALIZABLE</b> untuk transaksi kita (ya, di sini kita memulai transaksi) dan mengunci tabel "erat": <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">LOCK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ACCESS</span></span> EXCLUSIVE <span class="hljs-keyword"><span class="hljs-keyword">MODE</span></span>;</code> </pre> <br>  Tingkat pemblokiran ini disebabkan oleh operasi yang ingin kami lakukan di atasnya. <br><br><h4>  # 4: Konflik Kepentingan </h4><br>  Kami datang ke sini dan kami ingin "mengunci" tablet - dan jika seseorang aktif pada saat itu, misalnya, membacanya?  Kami akan "menunggu" untuk mengantisipasi pemblokiran ini, sementara orang lain yang ingin membaca sudah terkubur di dalam kita ... <br><br>  Untuk mencegah hal ini terjadi, ‚Äúkorbankan diri kita sendiri‚Äù - jika kita masih tidak bisa mendapatkan kunci untuk waktu tertentu (diizinkan kecil), maka kita akan mendapatkan pengecualian dari database, tetapi setidaknya kita tidak akan mengganggu sisanya. <br><br>  Untuk melakukan ini, setel variabel sesi <a href="https://www.postgresql.org/docs/current/runtime-config-client.html">lock_timeout</a> (untuk versi 9.3+) atau / dan <a href="https://www.postgresql.org/docs/current/runtime-config-client.html">statement_timeout</a> .  Hal utama yang perlu diingat adalah bahwa nilai statement_timeout hanya berlaku dari pernyataan berikutnya.  Yaitu, seperti ini dalam mengelem, <u>itu tidak akan bekerja</u> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> statement_timeout = ...;<span class="hljs-keyword"><span class="hljs-keyword">LOCK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ...;</code> </pre> <br>  Agar tidak berurusan dengan pemulihan selanjutnya dari nilai "lama" variabel, kami menggunakan formulir <b>SET LOCAL</b> , yang membatasi ruang lingkup pengaturan untuk transaksi saat ini. <br><br>  Ingat bahwa statement_timeout berlaku untuk semua permintaan berikutnya sehingga transaksi tidak dapat mencapai nilai yang tidak dapat diterima jika ada banyak data dalam tabel. <br><br><h4>  # 5: menyalin data </h4><br>  Jika tabel ternyata tidak sepenuhnya kosong, data harus disimpan kembali melalui label sementara tambahan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TEMPORARY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> _tmp_swap <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl;</code> </pre><br>  Tanda tangan <b>ON COMMIT DROP</b> berarti bahwa pada saat transaksi berakhir, tabel sementara tidak akan ada lagi, dan Anda tidak perlu menghapusnya secara manual dalam konteks koneksi. <br><br>  Karena kami berasumsi bahwa tidak ada banyak data "langsung", operasi ini harus berjalan cukup cepat. <br><br>  Yah, itu saja!  Ingatlah <a href="https://habr.com/post/479656/">untuk menjalankan ANALYZE</a> setelah transaksi selesai untuk menormalkan statistik tabel, jika perlu. <br><br><h2>  Kami mengumpulkan skrip terakhir </h2><br>  Kami menggunakan "pseudo python" seperti: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     stat &lt;- SELECT relpages , (( SELECT count(*) FROM pg_index WHERE indrelid = cl.oid ) + 1) &lt;&lt; 13 size_norm , pg_total_relation_size(oid) size , coalesce(extract('epoch' from (now() - greatest( pg_stat_get_last_vacuum_time(oid) , pg_stat_get_last_autovacuum_time(oid) ))), 1 &lt;&lt; 30) vaclag FROM pg_class cl WHERE oid = $1::regclass -- table_name LIMIT 1; #      VACUUM   if stat.size &gt; 2 * stat.size_norm and stat.vaclag is None or stat.vaclag &gt; 60: -&gt; VACUUM %table; try: -&gt; BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE; #         1s -&gt; SET LOCAL statement_timeout = '1s'; SET LOCAL lock_timeout = '1s'; -&gt; LOCK TABLE %table IN ACCESS EXCLUSIVE MODE; #          row &lt;- TABLE %table LIMIT 1; #       ""  -   ,    - ""      if row is None: -&gt; TRUNCATE TABLE %table RESTART IDENTITY; else: #      - -&gt; CREATE TEMPORARY TABLE _tmp_swap ON COMMIT DROP AS TABLE %table; #      -&gt; TRUNCATE TABLE %table; #         -&gt; INSERT INTO %table TABLE _tmp_swap; -&gt; COMMIT; except Exception as e: #    ,     "" -   if not isinstance(e, InterfaceError): -&gt; ROLLBACK;</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Dan bisakah Anda tidak menyalin data untuk kedua kalinya?</b> <div class="spoiler_text">  Pada prinsipnya, dimungkinkan jika oid dari tabel itu sendiri tidak terikat dengan aktivitas lain dari sisi BL atau FK dari sisi DB: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> _swap_%<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> %<span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INCLUDING</span></span> ALL); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> _swap_%<span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> %<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> %<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> _swap_%<span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RENAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> %<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>;</code> </pre> </div></div><br>  Mari kita jalankan skrip pada tabel sumber dan periksa metrik: <br><pre> <code class="sql hljs">VACUUM tbl; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOCAL</span></span> statement_timeout = <span class="hljs-string"><span class="hljs-string">'1s'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOCAL</span></span> lock_timeout = <span class="hljs-string"><span class="hljs-string">'1s'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">LOCK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ACCESS</span></span> EXCLUSIVE <span class="hljs-keyword"><span class="hljs-keyword">MODE</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TEMPORARY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> _tmp_swap <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> _tmp_swap; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">relpages | size_norm | size | vaclag ------------------------------------------- 0 | 24576 | 49152 | 32.705771</code> </pre> <br>  Semuanya berhasil!  Tabel telah menyusut sebanyak 50 kali, dan semua UPDATE berjalan cepat lagi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481866/">https://habr.com/ru/post/id481866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481852/index.html">Ulasan Printer 3D Anet N4 // Bagaimana Warna Karakter Jiwa Gelap yang Realistis</a></li>
<li><a href="../id481854/index.html">Menguji gagasan melalui prototipe dasbor</a></li>
<li><a href="../id481858/index.html">Ulang tahun di Kalender Google dengan usia</a></li>
<li><a href="../id481860/index.html">Apa yang harus dilakukan TI pada tahun 2020?</a></li>
<li><a href="../id481862/index.html">Sistem Pembelajaran Mesin Tertanam Nvidia Jetson</a></li>
<li><a href="../id481868/index.html">Dagaz: Awal yang baru</a></li>
<li><a href="../id481874/index.html">Metrik - indikator kesehatan proyek</a></li>
<li><a href="../id481880/index.html">Fisika untuk penembak PvP seluler dan bagaimana kami berteman dengan ECS</a></li>
<li><a href="../id481882/index.html">4. Fortinet Memulai v6.0. Kebijakan firewall</a></li>
<li><a href="../id481884/index.html">Persimpangan jalan senior: ke mana harus pergi berikutnya?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>