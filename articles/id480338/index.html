<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏻 🔮 🕖 Cara kerja rendering game 3D: rasterization dan ray tracing ♑️ 🤾 💤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian 1: pemrosesan simpul 

 Pada artikel ini, kita akan melihat lebih dekat apa yang terjadi pada dunia 3D setelah semua simpulnya diproses. Kita l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara kerja rendering game 3D: rasterization dan ray tracing</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480338/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/2f0/8c9/3ad2f08c927f84fd66245141de4ad34d.png" alt="gambar"></div><br>  <a href="https://habr.com/ru/post/472688/">Bagian 1: pemrosesan simpul</a> <br><br>  Pada artikel ini, kita akan melihat lebih dekat apa yang terjadi pada dunia 3D setelah semua simpulnya diproses.  Kita lagi harus menyingkirkan debu dari buku teks matematika, membiasakan diri dengan geometri piramida pemotongan dan memecahkan misteri perspektif.  Kami juga akan terjun sebentar ke fisika ray tracing, pencahayaan, dan material. <br><br>  Topik utama dari artikel ini adalah tahap render yang penting, di mana dunia tiga dimensi titik, segmen, dan segitiga menjadi kotak dua dimensi blok multi-warna.  Sangat sering proses ini tampaknya tidak terlihat, karena konversi dari 3D ke 2D tidak terlihat, berbeda dengan proses yang dijelaskan dalam <a href="https://www.techspot.com/article/1857-how-to-3d-rendering-vertex-processing/">artikel sebelumnya</a> , di mana kita dapat langsung melihat pengaruh vertex shaders dan tessellation.  Jika Anda belum siap untuk ini, Anda bisa mulai dengan artikel <a href="https://www.techspot.com/article/1851-3d-game-rendering-explained/">3D Game Rendering 101 kami</a> . <br><br><h2>  Mempersiapkan dua pengukuran </h2><br>  Sebagian besar pembaca membaca situs web ini pada layar monitor atau smartphone yang benar-benar datar;  tetapi bahkan jika Anda memiliki teknik modern - monitor melengkung, maka gambar yang ditampilkan juga terdiri dari kotak datar piksel multi-warna.  Namun, saat Anda memainkan Call of Mario yang baru: Deathduty Battleyard, gambarnya tampak tiga dimensi.  Objek bergerak di sekitar adegan, menjadi lebih besar atau lebih kecil, mendekati dan menjauh dari kamera. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46b/506/855/46b506855796dd802382dc4fde347751.jpg"></div><br>  Mengambil contoh <a href="https://www.techspot.com/review/1089-fallout-4-benchmarks/">Falles 4</a> dari Bethesda, yang dirilis pada tahun 2014, kita dapat dengan mudah melihat bagaimana puncak diproses, menciptakan rasa kedalaman dan jarak;  Ini terutama terlihat dalam mode wireframe (lihat di atas). <br><br>  Jika Anda mengambil game 3D apa pun selama dua dekade terakhir, hampir setiap game melakukan urutan tindakan yang sama untuk mengubah dunia simpul 3D menjadi array piksel 2D.  Konversi ini sering disebut <em>rasterisasi</em> , tetapi ini hanya satu dari banyak langkah dalam keseluruhan proses. <br><br>  Kita perlu menganalisis berbagai tahapan dan mempelajari teknik dan perhitungan yang digunakan di dalamnya.  Sebagai referensi, kami akan menggunakan urutan yang digunakan dalam Direct3D.  Gambar di bawah ini menunjukkan apa yang terjadi dengan setiap simpul dunia: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/774/621/43c/77462143c6d436fe0ad9145815956cf5.png"></div><br>  <i>Pipa Konversi Direct3D</i> <br><br>  Dalam <a href="https://www.techspot.com/article/1857-how-to-3d-rendering-vertex-processing/">artikel pertama</a> [ <a href="https://habr.com/ru/post/472688/">terjemahan</a> Habré] kita melihat apa yang terjadi di ruang dunia (World space): di sini, menggunakan berbagai perhitungan matriks, simpul-simpulnya ditransformasikan dan diwarnai.  Kami akan melewati langkah berikutnya, karena di ruang kamera hanya simpul yang dikonversi dan disesuaikan setelah bergerak, sehingga kamera menjadi titik referensi. <br><br>  Langkah-langkah berikut ini terlalu rumit untuk dilewati, karena itu mutlak diperlukan untuk transisi dari 3D ke 2D - jika diimplementasikan dengan benar, otak kita akan melihat layar datar, tetapi “melihat” pemandangan dengan kedalaman dan skala.  Jika semuanya dilakukan dengan salah, gambarnya akan sangat aneh! <br><br><h2>  Ini semua tentang perspektif </h2><br>  Langkah pertama dalam urutan ini adalah mengatur ruang lingkup dari sudut pandang kamera.  Untuk melakukan ini, pertama-tama Anda perlu mengatur sudut pandang bidang horisontal dan vertikal - yang pertama sering berubah dalam permainan, karena orang-orang telah mengembangkan penglihatan tepi horisontal lebih baik daripada vertikal. <br><br>  Kami dapat mengetahuinya dengan melihat gambar dengan bidang pandang seseorang: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/754/37e/69b/75437e69be055c93670bb139fc2e47d9.png"></div><br>  Dua sudut bidang pandang (bidang pandang, fov) mendefinisikan bentuk piramida <em>frustum</em> - piramida 3D dengan basis persegi yang berasal dari kamera.  Sudut pertama mengatur fov <em>vertikal</em> , <em>horizontal</em> kedua;  kami menunjukkannya dengan simbol <em>α</em> dan <em>β</em> .  Faktanya, kita melihat dunia tidak seperti itu, tetapi dari sudut pandang perhitungan, jauh lebih mudah untuk bekerja dengan piramida pemotongan daripada mencoba menghasilkan jumlah visibilitas yang realistis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cc/62f/e5f/0cc62fe5fdb171e47cc3428fa5bdd427.png"></div><br>  Anda juga perlu menentukan dua parameter lagi - lokasi <em>pesawat kliping</em> dekat (atau depan) dan jauh (belakang) <em>(pesawat kliping)</em> .  Yang pertama memotong bagian atas piramida, tetapi pada dasarnya menentukan seberapa dekat dengan posisi kamera semuanya digambar;  yang terakhir melakukan hal yang sama, tetapi menentukan seberapa jauh dari kamera primitif akan diberikan. <br><br>  Ukuran dan lokasi bidang pemotongan dekat sangat penting karena menjadi apa yang disebut <em>viewport</em> .  Sebenarnya, ini yang kita lihat di monitor, mis.  diberikan bingkai, dan di sebagian besar API grafik, viewport diambil dari sudut kiri atas.  Pada gambar di bawah ini, titik (a1, b2) akan menjadi asal pesawat: lebar dan tinggi pesawat diukur relatif terhadapnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf8/d66/f95/cf8d66f95ab085a290a35d996f94ed3d.png"></div><br>  <em>Rasio aspek</em> viewport penting tidak hanya untuk menampilkan dunia yang ditampilkan, tetapi juga agar sesuai dengan rasio aspek monitor.  Selama bertahun-tahun, standarnya adalah 4: 3 (atau 1,3333 ... dalam desimal).  Namun, saat ini mayoritas bermain dalam rasio aspek 16: 9 atau 21: 9, disebut layar lebar dan layar lebar ultra. <br><br>  Koordinat setiap titik di ruang kamera harus ditransformasikan sehingga semuanya cocok pada bidang pemotongan dekat, seperti yang ditunjukkan di bawah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba3/73f/69c/ba373f69c98de8b0000785606d1d56df.png"></div><br>  <i>Memotong sisi piramida dan atas</i> <br><br>  Transformasi dilakukan menggunakan matriks lain yang disebut <em>matriks proyeksi perspektif</em> .  Dalam contoh di bawah ini, untuk melakukan transformasi, kami menggunakan sudut ruang lingkup dan posisi bidang pemotongan;  namun, Anda dapat menggunakan ukuran viewport sebagai gantinya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d76/32e/2e1/d7632e2e15dd515df9f624a62f8fdce9.png"></div><br>  Vektor posisi vertex dikalikan dengan matriks ini, yang memberi kita seperangkat koordinat yang diubah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/267/8d6/a1d/2678d6a1d623c710e22675d54d05eaa2.png"></div><br>  Voila!  Sekarang semua simpul ditulis sedemikian rupa sehingga dunia sumber disajikan sebagai perspektif 3D, dan primitif di dekat bidang pemotongan depan tampak lebih besar daripada yang lebih dekat ke pesawat jauh. <br><br>  Meskipun ukuran viewport dan sudut pandang terkait, mereka dapat diproses secara individual.  Dengan kata lain, Anda dapat mengatur piramida pemotongan sedemikian rupa untuk mendapatkan bidang pemotongan dekat yang berbeda dalam ukuran dan rasio aspek dari viewport.  Untuk melakukan ini, langkah tambahan diperlukan dalam rantai operasi, di mana simpul dalam bidang pemotongan dekat harus diubah lagi untuk memperhitungkan perbedaan ini. <br><br>  Namun, ini dapat menyebabkan distorsi dari perspektif yang terlihat.  Menggunakan game Bethesda <a href="https://www.techspot.com/products/pc-games/the-elder-scrolls-5-skyrim.4195/">Skyrim 2011 sebagai</a> contoh <a href="https://www.techspot.com/products/pc-games/the-elder-scrolls-5-skyrim.4195/">,</a> kita dapat melihat bagaimana mengubah sudut horizontal wilayah visibilitas <em>β</em> sambil mempertahankan rasio aspek yang sama dari viewport sangat memengaruhi pemandangan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe9/2b8/4f7/fe92b84f7381a559d307517a2d46258a.jpg"></div><br>  Pada gambar pertama ini, kami mengatur <em>β</em> = 75 °, dan adegan terlihat sangat normal.  Mari kita coba sekarang untuk mengatur <em>β</em> = 120 °: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e0/bf9/a3b/4e0bf9a3b44c400447fb73393a26916d.jpg"></div><br>  Dua perbedaan segera terlihat - pertama, sekarang kita melihat lebih banyak pada sisi "bidang penglihatan" kita;  kedua, objek sekarang tampak lebih jauh (terutama pepohonan).  Namun, efek visual pada permukaan air sekarang terlihat salah, karena prosesnya tidak dirancang untuk area visibilitas seperti itu. <br><br>  Sekarang mari kita bayangkan bahwa karakter kita memiliki mata alien, dan atur <em>β</em> = 180 °! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6e/548/b9f/a6e548b9faa9cba6e3fa80a33a95444d.jpg"></div><br>  Area penglihatan seperti itu menciptakan pemandangan yang hampir seperti panorama, tetapi Anda harus membayarnya dengan sejumlah besar distorsi objek yang dibuat di tepinya.  Ini lagi terjadi karena fakta bahwa para perancang game tidak melihat situasi seperti itu dan tidak menciptakan sumber daya dan efek visual game untuk sudut pandang seperti itu (nilai standarnya sekitar 70 °). <br><br>  Mungkin terlihat bahwa dalam gambar di atas kamera telah bergerak, tetapi tidak demikian - satu-satunya perubahan adalah memodifikasi piramida pemotongan, yang pada gilirannya mengubah dimensi pesawat pemotongan dekat.  Pada setiap gambar, rasio aspek viewport tetap sama, sehingga penskalaan matriks diterapkan pada simpul sehingga semuanya cocok ke dalamnya. <br><br><h2>  Jadi, apakah Anda tinggal atau pergi? </h2><br>  Setelah melakukan transformasi pada tahap proyeksi, kami beralih ke apa yang disebut <em>ruang klip</em> .  Meskipun ini dilakukan <em>setelah</em> proyeksi, lebih mudah untuk menunjukkan apa yang terjadi jika kami melakukan operasi sebelumnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d1/5aa/921/8d15aa92153b56847f0a3eaba62000a0.png"></div><br>  Pada gambar di atas, kita melihat bahwa dalam bebek karet, salah satu kelelawar dan bagian dari pohon, segitiga berada di dalam piramida pemotongan;  Namun, kelelawar lainnya dan pohon terjauh berada di luar batas piramida pemotongan.  Meskipun simpul yang membentuk objek ini telah diproses, kami tidak akan melihatnya di viewport.  Ini berarti bahwa mereka <em>terpotong</em> . <br><br>  Ketika <em>memotong sepanjang piramida (kliping frustum),</em> semua primitif di luar piramida pemotongan sepenuhnya dihapus, dan mereka yang berbaring di perbatasan diubah menjadi primitif baru.  Pemotongan tidak sangat meningkatkan kinerja, karena semua simpul tak terlihat ini telah diproses sebelum tahap ini dalam vertex shaders, dll.  Jika perlu, seluruh langkah pemotongan bahkan dapat sepenuhnya dilewati, tetapi fitur ini tidak didukung oleh semua API (misalnya, OpenGL standar tidak akan membiarkannya dilewati, tetapi ini dapat dilakukan menggunakan ekstensi API). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e07/57c/7a5e0757c7f8368a6d419c59468ec03e.png"></div><br>  Perlu dicatat bahwa posisi pesawat terpotong jauh dalam permainan tidak selalu sama dengan <em>jarak imbang</em> , karena yang terakhir dikendalikan oleh mesin permainan itu sendiri.  Mesin juga melakukan <em>pemangkasan pada piramida (frustum culling)</em> - menjalankan kode yang menentukan apakah objek akan ditarik dalam piramida pemotongan dan apakah itu akan mempengaruhi objek yang terlihat;  jika jawabannya <em>tidak</em> , maka objek tidak ditransfer ke rendering.  Ini tidak sama dengan kliping frustrasi karena ia juga membuang primitif di luar piramida, tetapi mereka telah melewati tahap pemrosesan vertex.  Ketika pemusnahan, mereka tidak diproses sama sekali, yang menghemat banyak sumber daya. <br><br>  Kami telah melakukan semua transformasi dan pemotongan, dan tampaknya simpul akhirnya siap untuk langkah selanjutnya dalam urutan rendering.  Tetapi pada kenyataannya, ini tidak demikian, karena semua perhitungan dilakukan pada tahap pemrosesan verteks dan dalam operasi konversi dari ruang dunia ke ruang pemotongan harus dilakukan dalam sistem koordinat yang seragam (mis. Masing-masing titik memiliki 4 komponen, bukan 3) .  Namun, viewport benar-benar dua dimensi, yaitu, API mengharapkan bahwa informasi titik hanya berisi nilai untuk <em>x, y</em> (meskipun nilai kedalaman <em>z</em> disimpan). <br><br>  Untuk menghilangkan komponen keempat, <em>divisi perspektif</em> dilakukan, di mana setiap komponen dibagi dengan nilai <em>w</em> .  Operasi ini membatasi <em>x</em> dan <em>y ke</em> interval nilai yang mungkin [-1.1], dan <em>z</em> ke interval [0.1].  Ini disebut <em>koordinat perangkat dinormalisasi</em> (NDC). <br><br>  Jika Anda ingin mempelajari lebih lanjut tentang apa yang baru saja kami jelaskan, dan Anda menyukai matematika, maka bacalah <a href="http://www.songho.ca/opengl/gl_transform.html">tutorial yang sangat bagus</a> tentang topik ini Song Ho An.  Sekarang mari kita ubah simpul-simpul ini menjadi piksel! <br><br><h2>  Kami menguasai rasterisasi </h2><br>  Seperti dalam kasus transformasi, kita akan melihat aturan dan proses yang digunakan untuk mengubah viewport menjadi grid piksel, menggunakan Direct3D sebagai contoh.  Tabel ini menyerupai lembar kerja Excel dengan baris dan kolom, di mana setiap sel berisi nilai data yang berbeda (seperti warna, nilai kedalaman, koordinat tekstur, dll.).  Biasanya kisi ini disebut <em>gambar raster</em> , dan proses pembuatannya disebut <em>rasterisasi</em> .  Dalam artikel <a href="https://www.techspot.com/article/1851-3d-game-rendering-explained/">3D rendering 101,</a> kami menyederhanakan prosedur ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b6/01f/0e7/3b601f0e71774ce64eeb0a8f75a83f67.png"></div><br>  Gambar di atas memberi kesan bahwa primitif hanya dipotong menjadi blok-blok kecil, tetapi pada kenyataannya ada lebih banyak operasi.  Langkah pertama adalah menentukan apakah primitif menghadap kamera - misalnya, pada gambar di atas dengan piramida pemotongan, primitif yang membentuk bagian belakang kelinci abu-abu tidak akan terlihat.  Oleh karena itu, meskipun mereka hadir di viewport, mereka tidak perlu dirender. <br><br>  Kita dapat membayangkan kira-kira seperti apa dengan melihat diagram di bawah ini.  Kubus mengalami berbagai transformasi untuk menempatkan model 3D di ruang 2D layar dan dari sudut pandang kamera, beberapa wajah kubus tidak terlihat.  Jika kita mengasumsikan bahwa semua permukaan buram, maka beberapa primitif ini dapat diabaikan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/693/60a/bf9/69360abf9888e28d60622cf189cbb6c3.png"></div><br>  <i>Dari kiri ke kanan: ruang dunia&gt; ruang kamera&gt; ruang proyeksi&gt; ruang layar</i> <br><br>  Dalam Direct3D, ini dapat diimplementasikan dengan memberi tahu sistem seperti apa <em>keadaan renderingnya</em> , dan instruksi ini akan memberi tahu bahwa perlu untuk menghapus ( <em>memotong</em> ) sisi-sisi masing-masing primitif yang melihat ke depan atau ke belakang (atau tidak memotong sepenuhnya, misalnya, dalam mode <em>wireframe</em> ) .  Tapi bagaimana dia tahu sisi mana yang melihat ke depan atau ke belakang?  Ketika kami memeriksa <a href="https://www.techspot.com/article/1857-how-to-3d-rendering-vertex-processing/">matematika pemrosesan simpul</a> , kami melihat bahwa segitiga (atau lebih tepatnya simpul) memiliki vektor normal yang memberitahu sistem ke arah mana ia terlihat.  Berkat informasi ini, Anda dapat melakukan pemeriksaan sederhana, dan jika primitif gagal, maka dihapus dari rantai render. <br><br>  Sekarang saatnya menerapkan grid pixel.  Lagi-lagi ini adalah proses yang sangat kompleks, karena sistem harus memahami apakah piksel berada di dalam primitif - sepenuhnya, sebagian, atau tidak sama sekali.  Untuk melakukan ini, proses <em>pengujian cakupan</em> dilakukan.  Gambar di bawah ini menunjukkan bagaimana segitiga dirasterisasi dalam Direct3D 11: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/858/967/ee6/858967ee6e11144896c35c2c726ec606.png"></div><br>  Aturannya cukup sederhana: piksel dianggap berada di dalam segitiga jika pusat piksel melewati tanda centang, yang oleh Microsoft disebut aturan <a href="https://docs.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules">"kiri atas"</a> .  "Top" mengacu pada memeriksa garis horizontal;  pusat piksel harus berada <em>di</em> baris ini.  "Kiri" mengacu pada garis non-horisontal, dan pusat piksel harus di sebelah kiri garis tersebut.  Ada aturan lain yang terkait dengan non-primitif, misalnya, segmen dan titik sederhana, dan saat menggunakan <em>multisampling</em> , tambahan jika kondisi muncul dalam aturan. <br><br>  Jika Anda melihat dengan cermat pada dokumentasi Microsoft, Anda dapat melihat bahwa bentuk yang dibuat oleh piksel tidak sangat mirip dengan primitif asli.  Ini karena pikselnya terlalu besar untuk membuat segitiga realistis - gambar bitmap tidak mengandung cukup data tentang objek asli, yang menyebabkan fenomena yang disebut <em>aliasing</em> . <br><br>  Mari kita lihat aliasing dengan contoh <a href="https://benchmarks.ul.com/legacy-benchmarks">UL Benchmark 3DMark03</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f11/9d2/289/f119d2289c67082f66e4467385bc07be.jpg"></div><br>  <i>Rasterisasi 720 x 480 piksel</i> <br><br>  Pada gambar pertama, gambar raster memiliki resolusi yang sangat rendah - 720 x 480 piksel.  Aliasing terlihat jelas di pagar dan bayangan yang dilemparkan oleh senjata-senjata prajurit atas.  Bandingkan ini dengan hasil yang diperoleh selama rasterisasi dengan peningkatan 24 kali lipat dalam jumlah piksel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea8/eba/d3a/ea8ebad3a86c108326f069fc343baed7.jpg"></div><br>  <i>Rasterisasi 3840 x 2160 piksel</i> <br><br>  Di sini kita melihat bahwa aliasing di pagar dan bayangan telah sepenuhnya menghilang.  Tampaknya Anda harus selalu menggunakan bitmap yang besar, tetapi ukuran kisi harus didukung oleh monitor tempat bingkai akan ditampilkan.  Dan dengan mempertimbangkan fakta bahwa semua piksel ini perlu diproses, jelas bahwa akan ada penurunan kinerja. <br><br>  Multisampling dapat membantu di sini.  Begini cara kerjanya di Direct3D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/79e/62f/64b79e62fbcd12197ba9ff2c769045ae.png"></div><br>  Alih-alih memeriksa apakah pusat piksel cocok dengan aturan rasterisasi, beberapa titik di dalam setiap piksel (disebut sampel subpiksel atau sub-sampel) <em>dicentang</em> , dan jika beberapa di antaranya memenuhi persyaratan, mereka membentuk bagian dari gambar.  Kelihatannya tidak ada manfaatnya dan aliasing bahkan ditingkatkan, tetapi ketika menggunakan multisampling, informasi tentang sub-sampel mana yang dicakup oleh primitif dan hasil pemrosesan piksel disimpan dalam buffer dalam memori. <br><br>  Buffer ini kemudian digunakan untuk mencampur sub-sampel dan piksel ini sehingga ujung-ujung primitif tidak terlalu sobek.  Kami akan melihat aliasing dalam artikel lain secara lebih rinci, tetapi untuk saat ini informasi ini cukup bagi kami untuk memahami apa yang dapat dilakukan multisampling ketika digunakan untuk merasterisasi terlalu sedikit piksel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/703/466/b61/703466b61fe655bfe9956003b707d9d5.jpg"></div><br>  Seperti yang Anda lihat, jumlah aliasing di tepi berbagai bentuk telah menurun secara signifikan.  Rasterisasi resolusi yang lebih tinggi jelas lebih baik, tetapi penurunan kinerja dapat mendorong Anda untuk menggunakan multisampling. <br><br>  Juga selama rasterisasi, <em>pengujian oklusi</em> dilakukan.  Ini perlu karena viewport akan diisi dengan primitif ditumpangkan satu sama lain - misalnya, pada gambar di atas, segitiga berwawasan ke depan yang membentuk prajurit di latar depan tumpang tindih dengan segitiga yang sama dari prajurit lain.  Selain memeriksa apakah primitif mencakup piksel, Anda juga dapat membandingkan kedalaman relatif, dan jika satu permukaan berada di belakang yang lain, maka itu harus dihapus dari proses rendering yang tersisa. <br><br>  Namun, jika primitif dekat transparan, maka primitif jauh akan tetap terlihat, meskipun tidak akan lulus uji tumpang tindih.  Itulah sebabnya hampir semua mesin 3D melakukan pemeriksaan tumpang tindih <em>sebelum</em> mengirim data ke GPU dan sebaliknya menciptakan sesuatu yang disebut <em>z-buffer</em> , yang merupakan bagian dari proses rendering.  Di sini bingkai dibuat dengan cara biasa, tetapi alih-alih menyimpan warna piksel yang sudah jadi dalam memori, GPU hanya menyimpan nilai kedalaman.  Kemudian mereka dapat digunakan dalam shader untuk memeriksa visibilitas dan dengan kontrol dan akurasi aspek yang berkaitan dengan objek yang tumpang tindih. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/2bc/c01/f532bcc017258005f427aaed4e3e482e.png"></div><br>  Pada gambar yang ditunjukkan di atas, semakin gelap warna pikselnya, semakin dekat subjek ke kamera.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frame diberikan sekali untuk membuat buffer-z, dan kemudian di-render lagi, tapi kali ini selama pemrosesan piksel, shader diluncurkan, memeriksa nilai-nilai di buffer-z. Jika tidak terlihat, maka warna piksel tidak ditulis ke buffer bingkai jadi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini, langkah terakhir utama kami adalah </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpolasi atribut vertex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - dalam skema yang disederhanakan asli, primitif adalah segitiga lengkap, tetapi jangan lupa bahwa jendela tampilan diisi hanya dengan sudut-sudut gambar, dan bukan dengan angka-angka itu sendiri. Artinya, sistem harus menentukan warna, kedalaman, dan tekstur primitif apa yang harus berada di antara simpul, dan operasi ini disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpolasi</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Seperti yang sudah Anda tebak, ini adalah perhitungan lain, dan ini tidak sesederhana itu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terlepas dari kenyataan bahwa layar raster disajikan dalam 2D, struktur di dalamnya mewakili perspektif 3D. </font><font style="vertical-align: inherit;">Jika garis benar-benar dua dimensi, maka kita dapat menggunakan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">persamaan linear</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sederhana untuk menghitung warna dan hal lainnya </font><font style="vertical-align: inherit;">, karena kita berpindah dari satu titik ke titik lainnya. </font><font style="vertical-align: inherit;">Tetapi karena aspek 3D dari adegan, interpolasi harus mempertimbangkan perspektif ini; </font><font style="vertical-align: inherit;">Untuk mempelajari lebih lanjut tentang proses ini, baca </font></font><a href="http://simonstechblog.blogspot.com/2012/04/software-rasterizer-part-2.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel yang bagus dari Simon Young</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, tugas selesai - sehingga dunia 3D simpul berubah menjadi kotak 2D blok warna-warni. </font><font style="vertical-align: inherit;">Tapi kita belum selesai.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depan ke belakang (dengan beberapa pengecualian) </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum kita selesai mempertimbangkan rasterisasi, kita perlu berbicara tentang urutan urutan rendering. Kami tidak berbicara tentang tahap di mana, misalnya, tessellation muncul dalam urutan pemrosesan; kami maksud urutan di mana primitif diproses. Objek biasanya diproses dalam urutan di mana mereka berada di buffer indeks (blok memori memberitahu sistem bagaimana simpul dikelompokkan bersama) dan ini dapat secara signifikan mempengaruhi cara objek transparan dan efek diproses.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alasan untuk ini adalah bahwa primitif diproses satu per satu, dan jika Anda pertama kali membuat yang di depan, maka semua orang di belakang mereka tidak akan terlihat (ini adalah tempat oklusi pemusnahan ikut bermain) dan dapat dikeluarkan dari proses (membantu menyelamatkan kinerja). Ini biasanya disebut rendering dari </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depan ke belakang</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan untuk proses ini, buffer indeks harus dipesan dengan cara ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, jika beberapa primitif ini transparan di depan kamera, maka rendering dari depan ke belakang akan menyebabkan hilangnya objek yang berada di belakang transparan. Salah satu solusinya adalah membuat kembali ke depan, di mana primitif dan efek transparan dihitung terakhir.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/c02/6f7/3cac026f78b545088b8de84fcdd11ee4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari kiri ke kanan: urutan dalam adegan, render depan ke belakang, render kembali ke depan</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Artinya, dalam semua game modern, rendering dilakukan kembali ke depan? Apapun masalahnya - jangan lupa bahwa rendering setiap primitif individu akan menyebabkan penurunan kinerja yang jauh lebih besar dibandingkan dengan rendering hanya apa yang kita lihat. Ada cara lain untuk memproses objek transparan, tetapi dalam kasus umum tidak ada solusi ideal yang cocok untuk sistem apa pun, dan setiap situasi perlu dipertimbangkan secara terpisah.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faktanya, ini memungkinkan kita untuk memahami pro dan kontra utama dari rasterisasi - pada peralatan modern ini adalah proses yang cepat dan efisien, tetapi ini masih merupakan refleksi perkiraan dari apa yang kita lihat. </font><font style="vertical-align: inherit;">Di dunia nyata, setiap objek dapat menyerap, memantulkan, dan terkadang membiaskan cahaya, dan semua ini memengaruhi penampilan akhir dari adegan yang ditampilkan. </font><font style="vertical-align: inherit;">Membagi dunia menjadi primitif dan menjadikan sebagian dari mereka, kita menjadi cepat. </font><font style="vertical-align: inherit;">tetapi hasilnya sangat kasar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, jika ada cara lain ...</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cara lain adalah: ray tracing! </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hampir lima puluh tahun yang lalu, seorang ilmuwan komputer bernama Arthur Eppel bekerja pada sistem untuk merender gambar pada komputer di mana satu berkas cahaya dipancarkan dari kamera dalam garis lurus hingga bertabrakan dengan objek. Setelah tabrakan, sifat material (warna, reflektifitas, dll.) Mengubah kecerahan sinar cahaya. Untuk setiap piksel dalam gambar yang diberikan, ada satu sinar yang dipancarkan, dan algoritma melakukan rangkaian perhitungan untuk menentukan warna piksel. Proses Eppel disebut </font></font><a href="https://en.wikipedia.org/wiki/Ray_casting"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengecoran sinar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekitar sepuluh tahun kemudian, ilmuwan lain bernama </font></font><a href="https://en.wikipedia.org/wiki/J._Turner_Whitted"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">John Whited</font></font></a>   ,   ,          ,    ,    .            ,           ;          ,     ,   .    <em>  (ray tracing)</em> ( ,  <em></em>  ,        ,    )             <a href="https://graphics.pixar.com/library/RayTracingCars/paper.pdf"></a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f0/733/8a8/5f07338a8846abdebe390b99bd364ff8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari gambar di atas, Anda dapat memahami cara kerja algoritma Whited. Untuk setiap piksel dalam bingkai, satu sinar dipancarkan dari kamera dan bergerak hingga mencapai permukaan. Dalam contoh ini, permukaannya tembus cahaya, sehingga cahaya dapat dipantulkan dan dibiaskan melaluinya. Dalam kedua kasus, sinar sekunder dihasilkan yang bergerak sampai mereka bertabrakan dengan permukaan. Sinar sekunder baru juga dihasilkan untuk menjelaskan warna sumber cahaya dan bayangan yang mereka buat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sifat rekursif dari proses ini adalah bahwa sinar sekunder dapat dihasilkan setiap kali sinar yang dipancarkan memotong permukaan. Ini dapat dengan cepat lepas kendali, sehingga jumlah sinar sekunder yang dihasilkan selalu terbatas. Setelah menyelesaikan jalur balok, warna pada setiap titik akhir dihitung berdasarkan sifat material permukaan ini. Nilai ini kemudian ditransmisikan sepanjang sinar sebelumnya, mengubah warna untuk permukaan ini, dan seterusnya, hingga kita mencapai titik awal dari sinar primer, yaitu piksel dalam bingkai.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem seperti itu bisa sangat rumit dan bahkan adegan sederhana dapat menghasilkan sejumlah besar perhitungan. Untungnya, ada trik yang menyederhanakan pekerjaan - pertama, Anda dapat menggunakan peralatan yang dirancang khusus untuk mempercepat operasi matematika ini, mirip dengan bagaimana hal itu terjadi dengan matriks matematika dalam pemrosesan simpul (lebih lanjut tentang ini nanti). Trik penting lainnya adalah upaya untuk mempercepat proses penentuan objek ke mana sinar jatuh dan tempat persilangan yang tepat - jika objek terdiri dari banyak segitiga, maka tugas ini bisa sangat sulit:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de4/3f8/dac/de43f8dac76ca9bda84700c168cde9ff.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber: Real-time ray tracing dengan Nvidia RTX</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alih-alih memeriksa setiap segitiga individu di setiap objek, daftar volume pengikat (BV) dihasilkan sebelum melakukan ray tracing - ini adalah parallelepipeds biasa yang menggambarkan suatu objek. Untuk berbagai struktur di dalam objek, volume pembatas yang lebih kecil dibuat secara siklikal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, BV pertama adalah seluruh kelinci. Pasangan berikutnya akan menggambarkan kepala, kaki, tubuh, ekor, dll. setiap volume pada gilirannya akan menjadi kumpulan volume untuk struktur kepala, badan, dll yang lebih kecil, dan tingkat volume terakhir akan berisi sejumlah kecil segitiga untuk verifikasi. Semua volume ini sering disusun dalam daftar yang diurutkan (disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hirarki BV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau BVH); </font><font style="vertical-align: inherit;">berkat ini, sistem memeriksa jumlah BV yang relatif kecil setiap kali:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/345/319/454/3453194547f780d91a4231529f6f68b4.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun penggunaan BVH, secara tegas, tidak mempercepat penelusuran sinar itu sendiri, menghasilkan hierarki dan algoritma pencarian berikutnya yang diperlukan dalam kasus umum jauh lebih cepat daripada memeriksa persimpangan satu sinar dengan salah satu dari jutaan segitiga di dunia 3D. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini, program seperti </font></font><a href="https://www.blender.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blender</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="http://www.povray.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POV-ray</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menggunakan ray tracing dengan algoritma tambahan (seperti foton tracing dan radiositas) untuk menghasilkan gambar yang sangat realistis:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfa/b2c/bf6/cfab2cbf6216eaa3e007bdd38f867cd6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertanyaan yang jelas mungkin muncul: jika penelusuran ray sangat baik, mengapa itu tidak digunakan di mana-mana? Jawabannya ada di dua bidang: pertama, bahkan penelusuran sinar sederhana menghasilkan jutaan sinar yang perlu dihitung berulang-ulang. Sistem dimulai dengan hanya satu berkas per piksel layar, yaitu dengan resolusi 800 x 600, ia menghasilkan 480.000 sinar primer, dan kemudian masing-masing menghasilkan banyak sinar sekunder. Ini adalah pekerjaan yang sangat sulit, bahkan untuk PC desktop modern. Masalah kedua adalah bahwa penelusuran sinar sederhana tidak terlalu realistis dan untuk implementasinya yang tepat, Anda memerlukan banyak persamaan tambahan yang sangat kompleks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan dengan peralatan modern, jumlah pekerjaan dalam game 3D tidak dapat dicapai untuk implementasi waktu nyata. Dalam </font></font><a href="https://www.techspot.com/article/1851-3d-game-rendering-explained/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rendering 3D 101</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami melihat bahwa tolok ukur ray tracing memerlukan waktu puluhan detik untuk membuat satu gambar beresolusi rendah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana </font></font><a href="https://www.techspot.com/downloads/5842-wolfenstein-3d.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolfenstein 3D</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pertama </font><font style="vertical-align: inherit;">melakukan pengecoran sinar pada tahun 1992, dan mengapa game seperti </font></font><a href="https://www.techspot.com/review/1759-ray-tracing-benchmarks-vol-2/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Battlefield V</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://www.techspot.com/article/1793-metro-exodus-ray-tracing-benchmark/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metro Exodus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dirilis pada 2019, menawarkan kemampuan ray tracing? </font><font style="vertical-align: inherit;">Apakah mereka melakukan rasterisasi atau penelusuran sinar? </font><font style="vertical-align: inherit;">Sedikit demi sedikit keduanya.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pendekatan hibrida untuk saat ini dan masa depan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bulan Maret 2018, Microsoft mengumumkan rilis ekstensi API baru untuk Direct3D 12 yang disebut DXR (DirectX Raytracing). </font><font style="vertical-align: inherit;">Itu adalah pipa grafis baru yang melengkapi pipa rasterisasi dan komputasi standar. </font><font style="vertical-align: inherit;">Fungsionalitas tambahan disediakan oleh penambahan shader, struktur data, dan sebagainya, tetapi tidak memerlukan dukungan perangkat keras, kecuali yang sudah dibutuhkan untuk Direct3D 12.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c9/b88/e83/7c9b88e83184b2412b431ff990e39f89.png"></div><br>  Pada Konferensi Pengembang Game yang sama, di mana <a href="https://devblogs.microsoft.com/directx/wp-content/uploads/sites/42/2018/03/GDC_DXR_deck.pdf">Microsoft berbicara tentang DXR</a> , Electronic Arts berbicara tentang <a href="https://www.ea.com/seed/news/seed-project-picapica">Proyek Pica Pica</a> - sebuah eksperimen dengan mesin 3D menggunakan DXR.  Perusahaan telah menunjukkan bahwa ray tracing dapat digunakan, tetapi tidak untuk rendering seluruh frame.  Sebagian besar pekerjaan menggunakan teknik rasterisasi tradisional dan bayangan komputasi, sedangkan DXR digunakan di daerah tertentu.  Artinya, jumlah sinar yang dihasilkan jauh lebih sedikit daripada seluruh adegan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/2f0/8c9/3ad2f08c927f84fd66245141de4ad34d.png"></div><br>  Pendekatan hibrida ini telah digunakan di masa lalu, meskipun pada tingkat lebih rendah.  Misalnya, Wolfenstein 3D <a href="https://permadi.com/1996/05/ray-casting-tutorial-table-of-contents/">menggunakan pengecoran sinar</a> untuk membuat bingkai, tetapi itu dilakukan dengan satu balok per kolom piksel, bukan piksel.  Ini mungkin masih tampak mengesankan, kecuali jika Anda ingat bahwa gim ini bekerja dengan resolusi 640 x 480 [kira-kira.  transl .: sebenarnya 320 x 200], yaitu, pada saat yang sama tidak lebih dari 640 sinar yang dipancarkan. <br><br>  Kartu grafis awal 2018 seperti AMD Radeon RX 580 atau Nvidia GeForce 1080 Ti memenuhi persyaratan DXR, tetapi bahkan dengan kemampuan komputasi mereka, ada kekhawatiran bahwa mereka tidak akan cukup kuat untuk membuat DXR bermakna. <br><br>  Situasi berubah pada Agustus 2018 ketika Nvidia merilis arsitektur GPU terbarunya <a href="http://www.techspot.com/news/75952-nvidia-turing-here-next-gen-architecture-first-real.html">, yang diberi nama kode Turing</a> .  Fitur yang paling penting dari chip ini adalah penampilan yang disebut RT Cores: blok logika terpisah untuk mempercepat perhitungan persimpangan segitiga-ray dan berlalunya hirarki volume pembatas (BVH).  Kedua proses ini adalah prosedur yang memakan waktu untuk menentukan titik-titik interaksi cahaya dengan segitiga yang membentuk objek pemandangan.  Mengingat bahwa RT Cores adalah unit prosesor Turing yang unik, akses ke mereka hanya dapat dilakukan melalui API eksklusif Nvidia. <br><br>  Game pertama yang mendukung fitur ini adalah Battlefield V. EA  <a href="https://www.techspot.com/review/1749-battlefield-ray-tracing-benchmarks/">Ketika kami menguji DXR di dalamnya</a> , kami terkesan dengan peningkatan refleksi dalam air, pada rumput dan logam, serta penurunan kinerja yang sesuai: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/e3e/aa1/1cce3eaa1c5db3688910ec0a1c052ce4.png"></div><br>  Sejujurnya, tambalan berikutnya meningkatkan situasi, tetapi masih ada penurunan kecepatan rendering frame (dan masih ada).  Pada 2019, ada beberapa game lain yang mendukung API ini dan melakukan penelusuran sinar untuk bagian-bagian tertentu dari frame.  Kami menguji <a href="https://www.techspot.com/article/1793-metro-exodus-ray-tracing-benchmark/">Metro Exodus</a> dan <a href="https://www.techspot.com/article/1814-sotr-ray-tracing/">Shadow of the Tomb Raider</a> , dihadapkan pada situasi yang sama - dengan penggunaan aktif DXR secara signifikan mengurangi frame rate. <br><br>  Sekitar waktu yang sama, Tolok Ukur UL <a href="https://benchmarks.ul.com/news/3dmark-port-royal-ray-tracing-benchmark-now-available">mengumumkan</a> pembuatan uji fungsi DXR untuk <a href="https://www.techspot.com/downloads/5775-3dmark.html">3DMark</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/60a/a0d/61260aa0d10ef6ed6c69731a6a3038f2.jpg"></div><br>  <i>DXR digunakan dalam kartu grafis Nvidia Titan X (Pascal) - ya, hasilnya 8 fps</i> <br><br>  Namun, sebuah studi game dengan dukungan DXR dan tes 3DMark menunjukkan bahwa ray tracing bahkan pada tahun 2019 tetap merupakan tugas yang sangat sulit untuk GPU, bahkan dengan harga lebih dari $ 1.000.  Apakah ini berarti kita tidak memiliki alternatif nyata untuk rasterisasi? <br><br>  Fitur progresif dalam teknologi grafik 3D konsumen seringkali sangat mahal, dan dukungan awal mereka untuk fitur API baru bisa sangat terfragmentasi atau lambat (seperti yang kami temukan <a href="https://www.techspot.com/review/537-max-payne-3-performance/page6.html">ketika menguji Max Payne 3</a> pada versi Direct3D yang berbeda pada tahun 2012).  Masalah terakhir biasanya muncul karena pengembang game mencoba untuk memasukkan sebanyak mungkin fitur modern ke dalam produk mereka, kadang-kadang tanpa pengalaman yang cukup. <br><br>  Namun, vertex dan pixel shaders, tessellation, HDR rendering, dan oklusi ambient ruang layar juga pernah menjadi teknik mahal yang hanya cocok untuk GPU yang kuat, dan sekarang mereka adalah standar untuk permainan dan banyak kartu grafis yang didukung.  Hal yang sama akan terjadi dengan ray tracing;  seiring waktu, itu hanya akan berubah menjadi parameter detail lain, diaktifkan secara default untuk sebagian besar pemain. <br><br><h2>  Kesimpulannya </h2><br>  Jadi, kita telah sampai pada bagian kedua dari analisis, di mana kita telah melihat lebih dalam ke dunia grafis-3D.  Kami belajar bagaimana puncak dunia dan model ditransfer dari tiga dimensi dan berubah menjadi gambar 2D datar.  Kami melihat bahwa kami perlu memperhitungkan cakupannya dan menyadari dampaknya.  Kami memeriksa proses mengubah verin-verin ini menjadi piksel, dan berakhir dengan melihat sekilas alternatif dari proses rasterisasi tradisional. <br><br>  Seperti pada artikel sebelumnya, kami tidak mungkin dapat mengungkapkan semua topik, dan melewatkan beberapa detail - pada akhirnya, ini bukan buku teks!  Tapi kami harap Anda mempelajari sesuatu yang baru dan sekarang menghargai pekerjaan programmer dan insinyur yang menggunakan komputasi dan sains untuk mengimplementasikan semua ini di game 3D favorit Anda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480338/">https://habr.com/ru/post/id480338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480326/index.html">F5 Networks Corporation mengirimkan surat kepada pelanggannya untuk memberi tahu mereka tentang situasi saat ini dengan NGINX</a></li>
<li><a href="../id480328/index.html">Bagaimana cara berteman PyTorch dan C ++. Menggunakan TorchScript</a></li>
<li><a href="../id480330/index.html">Alat penilaian karyawan yang ideal</a></li>
<li><a href="../id480332/index.html">Analisis data pemungutan suara blockchain 2019 di Duma Kota Moskow</a></li>
<li><a href="../id480334/index.html">QtQML / panel korelasi cepat</a></li>
<li><a href="../id480340/index.html">Saya menentang manajer yang tidak kompeten, dan kemudian dia dipromosikan</a></li>
<li><a href="../id480342/index.html">Paradigma pembangunan melalui komentar</a></li>
<li><a href="../id480348/index.html">Deep Fake Science, krisis reproduktifitas dan dari mana repositori kosong berasal</a></li>
<li><a href="../id480350/index.html">Intisari materi menarik untuk pengembang ponsel # 326 (pada 9 - 15 Desember)</a></li>
<li><a href="../id480352/index.html">Ahli genetika Harvard mengembangkan prototipe aplikasi kencan DNA analisis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>