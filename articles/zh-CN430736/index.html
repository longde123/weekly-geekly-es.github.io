<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦊 🥒 🐲 从头开始开发浏览器。 第一部分：HTML 🎋 👵🏿 ✍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 


 我们继续有关浏览器引擎开发的系列文章。 


 在本文中，我将告诉您如何使用DOM创建最快的HTML解析器。 我们将研究HTML规范，以及为什么在解析HTML时在性能和资源消耗方面不好。 


 关于这个主题，我报告了过去的HighLoad ++。 并不是每个人都可以参加会议，而且...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>从头开始开发浏览器。 第一部分：HTML</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430736/"><p><img src="https://habrastorage.org/webt/qu/3l/02/qu3l02mug029as5w74y2zznn0yc.jpeg"></p><br><p> 大家好！ </p><br><p> 我们继续有关浏览器引擎开发的系列文章。 </p><br><p> 在本文中，我将告诉您如何使用DOM创建最快的HTML解析器。 我们将研究HTML规范，以及为什么在解析HTML时在性能和资源消耗方面不好。 </p><br><p> 关于这个主题，我报告了过去的HighLoad ++。 并不是每个人都可以参加会议，而且文章还提供了更多详细信息。 </p><br><p> 我假设读者具有HTML的基本知识：标记，节点，元素，名称空间。 </p><a name="habracut"></a><br><h2 id="specifikaciya-html">  HTML规范 </h2><br><p> 在开始探讨HTML解析器的实现之前，您需要了解要相信的HTML规范。 </p><br><p> 有两种HTML规范： </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工作组</a> <br><ul><li>苹果，Mozilla，谷歌，微软 </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">W3c</a> <br><ul><li> 公司大名单 </li></ul></li></ol><br><p>自然，选择权就落在了行业领导者<strong><code>WHATWG</code></strong> 。 按生活标准，大公司每个都有自己的浏览器/浏览器引擎。 </p><br><p> 更新：不幸的是，给定的规范链接没有从俄罗斯打开。 显然，带有电报的“战争回声”。 </p><br><h2 id="process-parsinga-html">  HTML解析过程 </h2><br><p> 构建HTML树的过程可以分为四个部分： </p><br><ol><li> 解码器 </li><li> 预处理 </li><li> 分词器 </li><li> 建树 </li></ol><br><p> 我们分别考虑每个阶段。 </p><br><h3 id="dekoder"> 解码器 </h3><br><p> 分词器接受Unicode字符（代码点）作为输入。 因此，我们需要将当前字节流转换为Unicode字符。 为此，请使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编码</a>规范。 </p><br><p> 如果我们有一个带有未知编码的HTML（没有HTTP标头），那么我们需要在解码开始之前确定它。 为此，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编码嗅探算法</a> 。 </p><br><p> 简单来说，该算法的本质是等待字节流中的<strong><code>500</code></strong>或前<strong><code>1024 </code></strong> ，然后运行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">预扫描字节流</a>算法<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以确定其编码</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该编码</a>尝试查找具有<strong><code>http-equiv</code></strong> ， <strong><code>content</code></strong>或<strong><code>charset</code></strong>属性的<strong><code>&lt;meta&gt;</code></strong>并尝试了解HTML开发人员指示的编码方式。 </p><br><p>  <strong><code>Encoding</code></strong>规范规定了浏览器引擎支持的最小编码集（总共21种）：UTF-8，ISO-8859-2，ISO-8859-7，ISO-8859-8，windows-874，windows-1250，windows-1251，windows -1252，Windows-1254，Windows-1255，Windows-1256，Windows-1257，Windows-1258，gb18030，Big5，ISO-2022-JP，Shift_JIS，EUC-KR，UTF-16BE，UTF-16LE和x-user -定义。 </p><br><h3 id="predvaritelnaya-obrabotka"> 预处理 </h3><br><p> 将字节解码为Unicode字符后，我们需要“清理”。 即，将所有回车符（ <strong><code>\r</code></strong> ）替换为换行符（ <strong><code>\n</code></strong> ），再加上回车符（ <strong><code>\r</code></strong> ）。 然后，用换行符（ <strong><code>\n</code></strong> ）替换所有回车符。 </p><br><p> 如此在规范中描述。 也就是说， <strong><code>\r\n</code></strong> =&gt; <strong><code>\r</code></strong> ， <strong><code>\r</code></strong> =&gt; <strong><code>\n</code></strong> 。 </p><br><p> 但是，实际上，没有人这样做。 使其更容易： </p><br><p> 如果收到回车符（ <strong><code>\r</code></strong> ），请查看是否有换行符（ <strong><code>\n</code></strong> ）。 如果存在，则将两个字符都更改为换行符（ <strong><code>\n</code></strong> ），如果不存在，则仅将第一个字符（ <strong><code>\r</code></strong> ）更改为换行（ <strong><code>\n</code></strong> ）。 </p><br><p> 这样就完成了初步的数据处理。 是的，您只需要除去回车符，这样它们就不会落入令牌生成器中。 令牌生成器不期望也不知道如何使用回车符。 </p><br><h3 id="oshibki-parsinga"> 解析错误 </h3><br><p> 为了将来没有问题，您应该立即告诉您<code> </code>什么（ <strong><code>parse error</code></strong> ）。 </p><br><p> 真的没错。 这听起来很险恶，但实际上这只是警告，我们期待一个警告，但我们有另一个警告。 </p><br><p> 解析错误不会停止数据处理或树的构建。 这是一条消息，表明我们没有有效的HTML。 </p><br><p> 对于代理对<code>\0</code> ，不正确的标记位置，不正确的<strong><code>&lt;!DOCTYPE&gt;</code></strong>以及各种其他内容，可以获得Parsig错误。 </p><br><p> 顺便说一句，某些解析错误会导致后果。 例如，如果指定“ bad” <strong><code>&lt;!DOCTYPE&gt;</code></strong>则HTML树将被标记为<strong><code>QUIRKS</code></strong>并且某些DOM函数的逻辑将改变。 </p><br><h3 id="tokenizator"> 分词器 </h3><br><p> 如前所述，令牌生成器接受Unicode字符作为输入。 这是一个具有<strong><code>80</code></strong>个状态的状态机。 在每种状态下，Unicode字符的条件。 根据收到的字符，令牌生成器可以： </p><br><ol><li> 改变你的状态 </li><li> 生成令牌并更改状态 </li><li> 不执行任何操作，等待下一个字符 </li></ol><br><p> 令牌生成器创建六种令牌：DOCTYPE，开始标签，结束标签，注释，字符，文件结束。 从而进入建树阶段。 </p><br><p> 值得注意的是，令牌生成器并不知道其所有状态，而是知道大约40％的位置（例如，从上限得出）。  “为什么还要休息？”  -你问。 其余约60％的人知道植树的阶段。 </p><br><p> 这样做是为了正确解析诸如<strong><code>&lt;textarea&gt;</code></strong> ， <strong><code>&lt;style&gt;</code></strong> ， <strong><code>&lt;script&gt;</code></strong>和<strong><code>&lt;title&gt;</code></strong>标签。 也就是说，通常那些标签中我们不期望其他标签，而只是封闭自己。 </p><br><p> 例如， <strong><code>&lt;title&gt;</code></strong>不能包含其他标签。  <strong><code>&lt;title&gt;</code></strong>任何标签都将被视为文本，直到遇到自己的结束标签<strong><code>&lt;/title&gt;</code></strong>为止。 </p><br><p> 为什么要这样做？ 毕竟，您可以告诉令牌生成器，如果我们遇到<strong><code>&lt;title&gt;</code></strong>那么我们将遵循“所需的路径”。 如果没有名称空间，那将是正确的！ 是的，名称空间会影响树构建阶段的行为，从而改变令牌生成器的行为。 </p><br><p> 例如，考虑HTML和SVG名称空间中<strong><code>&lt;title&gt;</code></strong>的行为： </p><br><p>  <strong>的HTML</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 建立一棵树的结果： </p><br><pre> <code class="plaintext hljs">&lt;title&gt; "&lt;span&gt;&lt;/span&gt;"</code> </pre> <br><p>  <strong>SVG</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 建立一棵树的结果： </p><br><pre> <code class="plaintext hljs">&lt;svg&gt; &lt;title&gt; &lt;span&gt; ""</code> </pre> <br><p> 我们看到在第一种情况（HTML名称空间）中， <strong><code>&lt;span&gt;</code></strong>是文本，没有创建<strong><code>span</code></strong>元素。 在第二种情况下（SVG名称空间），基于<strong><code>&lt;span&gt;</code></strong>标签创建了一个元素。 也就是说，根据名称空间，标签的行为不同。 </p><br><p> 但这还不是全部。 事实证明，令牌生成器本身必须知道树构建阶段位于哪个命名空间中，这是对“生命的庆祝”的重中之重。 这仅是为了正确处理<strong><code>CDATA</code></strong>所必需的。 </p><br><p> 考虑两个带有<strong><code>CDATA</code></strong>示例，两个名称空间： </p><br><p>  <strong>的HTML</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[  ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 建立一棵树的结果： </p><br><pre> <code class="plaintext hljs">&lt;div&gt; &lt;!--[CDATA[  ]]--&gt;</code> </pre> <br><p>  <strong>SVG</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[  ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 建立一棵树的结果： </p><br><pre> <code class="plaintext hljs">&lt;div&gt; &lt;svg&gt; "  "</code> </pre> <br><p> 在第一种情况下（HTML名称空间），令牌生成器将<strong><code>CDATA</code></strong>用作注释。 在第二种情况下，令牌生成器分解<strong><code>CDATA</code></strong>结构并从中接收数据。 通常，规则是这样的：如果我们不在HTML名称空间中遇到<strong><code>CDATA</code></strong> ，则将其解析，否则将其视为注释。 </p><br><p> 这是分词器与树结构之间的紧密联系。 令牌生成器必须知道树构建阶段当前位于哪个名称空间中，并且树构建阶段可以更改令牌生成器的状态。 </p><br><h3 id="tokeny"> 代币 </h3><br><p> 下面，我们将考虑令牌生成器创建的所有六种令牌类型。 值得一提的是，所有令牌都已准备好数据，即已经处理并“准备使用”。 这意味着所有命名的字符引用（例如<strong><code>&amp;copy</code></strong> ）都将转换为unicode字符。 </p><br><h3 id="doctype-token">  DOCTYPE令牌 </h3><br><p>  DOCTYPE令牌具有与其他标签不同的自身结构。 令牌包含： </p><br><ol><li> 名 </li><li> 公开标识符 </li><li> 系统识别码 </li></ol><br><p> 在现代HTML中，唯一有效的/有效的DOCTYPE应该如下所示： </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span></code> </pre> <br><p> 所有其他<strong><code>&lt;!DOCTYPE&gt;</code></strong>将被视为解析错误。 </p><br><h3 id="start-tag-token"> 开始标记令牌 </h3><br><p> 开头标签可能包含： </p><br><ol><li> 标签名称 </li><li> 属性 </li><li> 标志 </li></ol><br><p> 例如 </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p> 开头标签可以包含一个<strong><code>self-closing</code></strong>标志。 该标志不会影响标签的关闭，但可能会导致非<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">空</a>元素的解析错误。 </p><br><h3 id="end-tag-token"> 结束标签令牌 </h3><br><p> 结束标签。 它具有开始标记令牌的所有属性，但标记名称前面带有斜杠<strong><code>/</code></strong> 。 </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p> 结束标记可能包含一个<strong><code>self-closing</code></strong>标志，这将导致解析错误。 另外，解析错误将由结束标记的属性引起。 它们将被正确解析，但是在树构建阶段被丢弃。 </p><br><h3 id="comment-token"> 评论令牌 </h3><br><p> 评论令牌包含整个评论文本。 也就是说，它已完全从流复制到令牌。 </p><br><p> 例子 </p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--  --&gt;</span></span></code> </pre> <br><h3 id="character-token"> 角色标记 </h3><br><p> 也许是最有趣的标记。  Unicode令牌符号。 可以包含一个（仅一个）字符。 </p><br><p> 将为HTML中的每个字符创建一个令牌，并将其发送到树构建阶段。 这非常昂贵。 <br> 让我们看看它是如何工作的。 </p><br><p> 取得HTML资料： </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> ! &amp;reg;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 您认为此示例将创建多少个令牌？ 答：22。 </p><br><p> 考虑创建的令牌列表： </p><br><pre> <code class="plaintext hljs">Start tag token: &lt;span&gt; Character token:  Character token:  Character token:  Character token:  Character token:  Character token: Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token: ! Character token: Character token: End tag token: &lt;/span&gt; End-of-file token</code> </pre> <br><p> 不安慰吧？ 但是，当然，许多HTML解析器的创建者实际上在处理过程中只有一个令牌。 循环运行它，并每次都用新数据覆盖它。 </p><br><p> 让我们继续回答这个问题：为什么要这样做？ 为什么不把这些文本分成一个整体？ 答案在于树的建造阶段。 </p><br><p> 没有构建HTML树的阶段，令牌生成器是没有用的。 在构建树的阶段，将文本与不同的条件粘合在一起。 </p><br><p> 条件大致如下： </p><br><ol><li> 如果到达了带有<strong><code>U+0000</code></strong> （ <strong><code>NULL</code></strong> ）的字符标记，那么我们将导致解析错误并忽略该标记。 </li><li> 如果<strong><code>U+0009</code></strong> （ <strong><code>U+000A</code></strong> ）， <strong><code>U+000A</code></strong> （ <strong><code>LINE FEED (LF)</code></strong> ）， <strong><code>U+000C</code></strong> （ <strong><code>FORM FEED (FF)</code></strong> ）或<strong><code>U+0020</code></strong> （ <strong><code>SPACE</code></strong> ）字符令牌之一出现，则调用算法以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">恢复活动的格式化元素，</a>并将令牌插入树中。 </li></ol><br><p> 根据以下算法，将符号令牌添加到树中： </p><br><ol><li> 如果当前插入位置不是文本节点，则创建一个文本节点，将其插入树中，然后将令牌中的数据添加到树中。 </li><li> 否则，将数据从令牌添加到现有的文本节点。 </li></ol><br><p> 此行为会带来很多问题。 每个符号都需要创建一个令牌并将其发送到分析以构建树的阶段。 我们不知道文本节点的大小，我们必须预先分配大量内存或进行重新分配。 从内存或时间来看，所有这些都是极其昂贵的。 </p><br><h3 id="end-of-file-token"> 文件结束令牌 </h3><br><p> 简单明了的令牌。 数据已结束-让我们通知您有关树木建造的阶段。 </p><br><h3 id="postroenie-dereva"> 建树 </h3><br><p> 树构建是一个具有<strong><code>23</code></strong>个状态的状态机，其中包含用于标记（标签，文本）的许多条件。 建造树木的阶段是最大的，占据了规范的重要部分，并且还能够引起昏昏欲睡的睡眠和刺激感。 </p><br><p> 一切都安排得非常简单。 在输入处接收令牌，并根据令牌切换树结构的状态。 在输出中，我们有一个真实的DOM。 </p><br><h2 id="problemy"> 有问题吗？ </h2><br><p> 以下问题似乎很明显： </p><br><p>  <strong>逐字符复制</strong> </p><br><p> 每个标记生成器状态在输入处接收一个字符，在需要时将其复制/转换：标记名称，属性，注释，符号。 </p><br><p> 这在内存和时间上都是非常浪费的。 我们被迫为每个属性，标签名称，注释等预分配未知数量的内存。 因此，这会导致重新部署，而重新部署会导致浪费时间。 </p><br><p> 并且，如果您想象HTML包含1000个标签，并且每个标签至少具有一个属性，那么我们将得到一个令人讨厌的缓慢解析器。 </p><br><p>  <strong>角色标记</strong> </p><br><p> 第二个问题是字符令牌。 事实证明，我们为每个符号创建了一个令牌，并给了它以构建一棵树。 建立一棵树不知道我们将拥有多少这些令牌，因此无法立即为所需数量的字符分配内存。 因此，这里所有相同的realoks +常量检查树的当前状态下是否存在文本节点。 </p><br><p>  <strong>单片系统</strong> </p><br><p> 最大的问题是一切都取决于一切。 即，分词器取决于构建树的状态，并且树的构造可以控制分词器。 一切都归咎于名称空间（名称空间）。 </p><br><h2 id="kak-budem-reshat-problemy"> 我们将如何解决这些问题？ </h2><br><p> 接下来，我将描述<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lexbor</a>项目中HTML解析器的实现，以及解决所有已提出问题的解决方案。 </p><br><h3 id="predvaritelnaya-obrabotka-1"> 预处理 </h3><br><p> 我们删除了初步的数据处理。 我们将训练令牌生成器以将回车符（ <strong><code>\r</code></strong> ）理解为空格字符。 因此，他将被投入到建造一棵树的阶段，我们将在此阶段进行计算。 </p><br><h3 id="tokeny-1"> 代币 </h3><br><p> 轻拂一下手腕，便可以统一所有令牌。 我们将为所有事情拥有一个令牌。 通常，在整个解析过程中将只有一个令牌。 </p><br><p> 我们的统一令牌将包含以下字段： </p><br><ol><li> 标签编号 </li><li> 开始 </li><li> 完结 </li><li> 属性 </li><li> 标志 </li></ol><br><h4 id="tag-id"> 标签编号 </h4><br><p> 我们将不使用标签名称的文字表示。 我们将一切都转化为数字。 这些数字易于比较，更易于使用。 </p><br><p> 我们根据所有已知标签创建一个静态哈希表。 我们从所有已知标签创建枚举。 也就是说，我们需要严格地为每个标签分配一个标识符。 因此，在哈希表中，关键字是标签的名称，并且该值是从枚举中写入的。 </p><br><p> 例如： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { LXB_TAG__UNDEF = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, LXB_TAG__END_OF_FILE = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>, LXB_TAG__TEXT = <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, LXB_TAG__DOCUMENT = <span class="hljs-number"><span class="hljs-number">0x0003</span></span>, LXB_TAG__EM_COMMENT = <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, LXB_TAG__EM_DOCTYPE = <span class="hljs-number"><span class="hljs-number">0x0005</span></span>, LXB_TAG_A = <span class="hljs-number"><span class="hljs-number">0x0006</span></span>, LXB_TAG_ABBR = <span class="hljs-number"><span class="hljs-number">0x0007</span></span>, LXB_TAG_ACRONYM = <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, LXB_TAG_ADDRESS = <span class="hljs-number"><span class="hljs-number">0x0009</span></span>, LXB_TAG_ALTGLYPH = <span class="hljs-number"><span class="hljs-number">0x000a</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p> 从示例中可以看到，我们为<strong>END-OF-FILE</strong>令牌，文本和文档创建了标签。 所有这些都是为了进一步的方便。 打开帷幕，我将说在节点（ <strong><code>DOM Node Interface</code></strong> ）中，我们将有一个<strong><code>Tag ID</code></strong> 。 这样做是为了不进行两个比较：在节点的类型上和在元素上。 也就是说，如果需要<strong><code>DIV</code></strong>元素，则在节点中进行一次检查： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;tag_id == LXB_TAG_DIV) { <span class="hljs-comment"><span class="hljs-comment">/* Best code */</span></span> }</code> </pre> <br><p> 但是，当然，您可以这样做： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;type == LXB_DOM_NODE_TYPE_ELEMENT &amp;&amp; node-&gt;tag_id == LXB_TAG_DIV) { <span class="hljs-comment"><span class="hljs-comment">/* Oh, code */</span></span> }</code> </pre> <br><p> 需要使用<strong><code>LXB_TAG__</code></strong>中的两个下划线将公用标签与系统标签分开。 换句话说，用户可以使用名称<strong><code>text</code></strong>或<strong><code>end-of-file</code></strong>创建标签<strong><code>end-of-file</code></strong>如果我们随后按标签名称进行搜索，则不会发生任何错误。 所有系统标签均以<strong><code>#</code></strong>开头。 </p><br><p> 但是，节点仍可以存储标签名称的文本表示。 对于98.99999％的节点，此参数将为<strong><code>NULL</code></strong> 。 在某些名称空间中，我们需要使用固定寄存器指定前缀或标记名。 例如，SVG名称空间中的<strong><code>baseProfile</code></strong> 。 </p><br><p> 工作的逻辑很简单。 如果我们有一个带有明确定义的寄存器的标签，则： </p><br><ol><li> 将其添加到小写标签的常规库中。 获取标签ID。 </li><li> 在文本表示中将标签标识符和原始标签名称添加到节点。 </li></ol><br><p>  <strong>自定义标签</strong> </p><br><p> 开发人员可以在HTML中创建任何标签。 由于在静态哈希表中只有我们知道的那些标签，并且用户可以创建任何标签，因此我们需要一个动态哈希表。 </p><br><p> 一切看起来都很简单。 当标签出现时，我们将看到它是否在静态哈希表中。 如果没有标签，那么让我们看一下动态标签；如果没有标签，那么将标识符计数器增加一，然后将标签添加到动态表中。 </p><br><p> 所描述的一切都发生在令牌生成器阶段。 在令牌生成器内部，并且所有比较之后都按<strong><code>Tag ID</code></strong> （极少数例外）。 </p><br><h4 id="begin-and-end"> 开始和结束 </h4><br><p> 现在，在分词器中，我们将不再进行数据处理。 我们不会复制和转换任何东西。 我们只是将指针指向数据的开头和结尾。 </p><br><p> 所有数据处理（例如符号链接）都将在构建树的阶段进行。 <br> 因此，我们将知道用于后续内存分配的数据大小。 </p><br><h4 id="attributes"> 属性 </h4><br><p> 这里的一切都一样简单。 我们不复制任何内容，而只是保存指向名称和属性值的开头/结尾的指针。 所有转换都在构建树时发生。 </p><br><h4 id="flags"> 标志 </h4><br><p> 由于我们拥有统一的令牌，因此我们需要以某种方式告知树结构令牌的类型。 为此，请使用标志位图字段。 </p><br><p> 该字段可能包含以下值： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { LXB_HTML_TOKEN_TYPE_OPEN = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, LXB_HTML_TOKEN_TYPE_CLOSE = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>, LXB_HTML_TOKEN_TYPE_CLOSE_SELF = <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, LXB_HTML_TOKEN_TYPE_TEXT = <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, LXB_HTML_TOKEN_TYPE_DATA = <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, LXB_HTML_TOKEN_TYPE_RCDATA = <span class="hljs-number"><span class="hljs-number">0x0010</span></span>, LXB_HTML_TOKEN_TYPE_CDATA = <span class="hljs-number"><span class="hljs-number">0x0020</span></span>, LXB_HTML_TOKEN_TYPE_NULL = <span class="hljs-number"><span class="hljs-number">0x0040</span></span>, LXB_HTML_TOKEN_TYPE_FORCE_QUIRKS = <span class="hljs-number"><span class="hljs-number">0x0080</span></span>, LXB_HTML_TOKEN_TYPE_DONE = <span class="hljs-number"><span class="hljs-number">0x0100</span></span> };</code> </pre> <br><p> 除了打开或关闭的令牌类型之外，还有数据转换器的值。 只有令牌生成器知道如何正确转换数据。 因此，令牌生成器在令牌中标记应如何处理数据。 </p><br><h4 id="character-token-1"> 角色标记 </h4><br><p> 从前面的描述中，我们可以得出结论，符号令牌已从我们中消失了。 是的，现在我们有了一种新型的令牌： <strong><code>LXB_HTML_TOKEN_TYPE_TEXT</code></strong> 。 现在，我们为标记之间的整个文本创建一个令牌，标记将来应如何处理。 </p><br><p> 因此，我们将不得不更改树的构造条件。 我们需要训练他不要使用符号标记，而要使用文本标记：转换，删除不必要的字符，跳过空格等等。 </p><br><p> 但是，没有什么复杂的。 在构建树的阶段，更改将是最小的。 但是，分词器现在根本与单词中的规范不匹配。 但是我们不需要他，这很正常。 我们的任务是获得一个完全符合规范的HTML / DOM树。 </p><br><h3 id="stadii-tokenizatora"> 分词器阶段 </h3><br><p> 为了确保令牌处理程序中的高速数据处理，我们将迭代器添加到每个阶段。 根据规范，每个阶段都为我们接受一个符号，并根据到达的符号进行决策。 但是，事实是它非常昂贵。 </p><br><p> 例如，要从<strong><code>ATTRIBUTE_NAME</code></strong>阶段移至<strong><code>ATTRIBUTE_VALUE</code></strong>阶段<strong><code>ATTRIBUTE_VALUE</code></strong>我们需要在属性名称中找到一个空格，以指示其结束。 根据规范，我们应该按字符向阶段<strong><code>ATTRIBUTE_NAME</code></strong>馈送，直到出现空白字符为止，并且此阶段不会切换到另一个阶段。 这非常昂贵，通常是通过对每个字符或回调（例如“ tkz-&gt; next_code_point（）”）进行函数调用来实现的。 </p><br><p> 我们向<strong><code>ATTRIBUTE_NAME</code></strong>阶段添加一个循环，并传递整个传入缓冲区。 在循环中，我们寻找需要切换的符号并继续在下一阶段工作。 在这里，我们获得了很多收益，甚至是编译器优化。 </p><br><p> 但是！ 最糟糕的是，我们由此打破了对大块（大块）的支持。 多亏了令牌生成器每个阶段中逐个字符的处理，我们才对块有了支持，现在我们打破了它。 </p><br><p> 如何解决？ 如何实现对块的支持？ 很简单，我们介绍了传入缓冲区（Incoming Buffer）的概念。 </p><br><h3 id="incoming-buffer"> 传入缓冲区 </h3><br><p>  HTML通常以块的形式进行解析。 例如，如果我们通过网络接收数据。 为了在等待剩余数据时不会处于空闲状态，我们可以发送已接收的数据进行处理/解析。 自然，数据可以在任何地方被破坏。 例如，我们有两个缓冲区： </p><br><p>  <strong>首先</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">clas</span></span></span></span></code> </pre> <br><p>  <strong>第二个</strong> </p><br><pre> <code class="html hljs xml">s="oh-no-oh-no"&gt;</code> </pre> <br><p> 由于我们在标记化阶段不复制任何内容，而仅使用指向数据开头和结尾的指针，因此我们遇到了问题。 指向不同用户缓冲区的指针。 考虑到开发人员经常为数据使用相同的缓冲区，我们正在处理一个指向不存在的数据开始的指针。 </p><br><p>               . <br>   : </p><br><ol><li>              (Incoming Buffer). </li><li>     ( )  ,        ?  ,          .       ,           .  99%        . </li></ol><br><p>  "  "  .      . </p><br><p> ,      .      ,       ( )          .     . ,  ,   ,  .         . </p><br><h3 id="problema-dannye-v-tokene"> :    </h3><br><p>      ,  . ,        :          .     .             (    ),      .              . </p><br><p>    :      .  ,                . </p><br><h2 id="stadiya-postroeniya-dereva">    </h2><br><p>   . </p><br><p>      ,    . ,         . </p><br><p>    : </p><br><p> <strong> </strong> </p><br><pre> <code class="cpp hljs">tree_build_in_body_character(token) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.code_point == <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Parse error, ignore token */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.code_point == whitespaces) { <span class="hljs-comment"><span class="hljs-comment">/* Insert element */</span></span><span class="hljs-string"><span class="hljs-string">' } /* ... */ }</span></span></code> </pre> <br><p> <strong> Lexbor HTML</strong> </p><br><pre> <code class="cpp hljs">tree_build_in_body_character(token) { <span class="hljs-keyword"><span class="hljs-keyword">lexbor_str_t</span></span> str = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">lxb_html_parser_char_t</span></span> pc = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; pc.drop_null = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; tree-&gt;status = lxb_html_token_parse_data(token, &amp;pc, &amp;str, tree-&gt;document-&gt;mem-&gt;text); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token-&gt;type &amp; LXB_HTML_TOKEN_TYPE_NULL) { <span class="hljs-comment"><span class="hljs-comment">/* Parse error */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* Insert element if not empty */</span></span> }</code> </pre> <br><p>   ,               .           : </p><br><pre> <code class="cpp hljs">pc.replace_null <span class="hljs-comment"><span class="hljs-comment">/*   '\0'    (REPLACEMENT CHARACTER (U+FFFD)) */</span></span> pc.drop_null <span class="hljs-comment"><span class="hljs-comment">/*   '\0' */</span></span> pc.is_attribute <span class="hljs-comment"><span class="hljs-comment">/*          " " */</span></span> pc.state <span class="hljs-comment"><span class="hljs-comment">/*  .        . */</span></span></code> </pre> <br><p>           . -   <strong><code>\0</code></strong> ,  -    <strong><code>REPLACEMENT CHARACTER</code></strong> . -    ,  - .        . </p><br><p>  ,     .      .  ,       <strong><code>&lt;head&gt;</code></strong>   .  ,           ,   : "    ".              ,           . </p><br><div class="spoiler"> <b class="spoiler_title">  &lt;sarcasm&gt;</b> <div class="spoiler_text"><p>  HTML  (   )    <strong><code>sarcasm</code></strong> .            . </p><br><pre> <code class="plaintext hljs">An end tag whose tag name is "sarcasm" Take a deep breath, then act as described in the "any other end tag" entry below.</code> </pre> <br><p>   . </p></div></div><br><h2 id="itog">  </h2><br><p>            HTML    DOM/HTML Interfaces   HTML/DOM    HTML . </p><br><p>    ,   : </p><br><ol><li>    (  ) </li><li>  <br><ul><li>  Incoming Buffer </li><li>   </li><li>   Tag ID </li><li> ̆ :  ,  N+  </li><li> ̆     </li><li>      </li><li>    ̈ </li></ul></li><li>   <br><ul><li>      </li></ul></li></ol><br><p>  i7 2012 ,   ,      235MB   (Amazon-). </p><br><p>  ,        1.5/2 ,     . ,    . ,    CSS     (Grammar,  ,       Grammar).     HTML,  CSS  ,    "". </p><br><h2 id="ishodniki"> 源代码 </h2><br><p>      HTML    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lexbor HTML</a> . </p><br><h2 id="ps"> 聚苯乙烯 </h2><br><p>      CSS  Grammar.  ,     .  - 6-8 . </p><br><div class="spoiler"> <b class="spoiler_title"> ,    </b> <div class="spoiler_text"><p>    .  ,        . <br>      (      ).    . </p></div></div><br><p> 感谢您的关注！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430736/">https://habr.com/ru/post/zh-CN430736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430724/index.html">DEFCON 21. DNS会议可能对您的健康有害。 第一部分</a></li>
<li><a href="../zh-CN430728/index.html">教我提供反馈</a></li>
<li><a href="../zh-CN430730/index.html">R＆D ABBYY做什么：NLP高级研究小组</a></li>
<li><a href="../zh-CN430732/index.html">关于划分和TI的问题</a></li>
<li><a href="../zh-CN430734/index.html">智能更新与智能合约</a></li>
<li><a href="../zh-CN430738/index.html">成为安全忍者：秘密等级</a></li>
<li><a href="../zh-CN430740/index.html">如何使用机器人为奶牛挤奶，并在其上进行工业创业。 R-SEPT发展历程</a></li>
<li><a href="../zh-CN430742/index.html">学生奥运会“我是专业人士”：方向“编程和信息技术”</a></li>
<li><a href="../zh-CN430746/index.html">为什么特斯拉电池无法在空中出租车上工作</a></li>
<li><a href="../zh-CN430748/index.html">资源争夺，第6部分：cpuset或共享并不总是正确的</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>