<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‹ ğŸ•˜ ğŸ‘©ğŸ¿â€ğŸ­ Comment faire cuire la bouillie Ã  partir de microservices ğŸ“¿ ğŸ‘¨ğŸ¼â€âš–ï¸ ğŸœ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'une des raisons de la popularitÃ© des microservices est la possibilitÃ© d'un dÃ©veloppement autonome et indÃ©pendant. En substance, l'architecture de mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment faire cuire la bouillie Ã  partir de microservices</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469001/">  L'une des raisons de la popularitÃ© des microservices est la possibilitÃ© d'un dÃ©veloppement autonome et indÃ©pendant.  En substance, l'architecture de microservices est l'Ã©change de la possibilitÃ© d'un dÃ©veloppement autonome pour un dÃ©ploiement, des tests, un dÃ©bogage et une surveillance plus complexes (par rapport Ã  un monolithe).  Mais gardez Ã  l'esprit que les microservices ne pardonnent pas la sÃ©paration des responsabilitÃ©s.  Si la sÃ©paration des tÃ¢ches est incorrecte, des changements dÃ©pendants frÃ©quents se produisent dans diffÃ©rents services.  Et cela est beaucoup plus douloureux et plus compliquÃ© que des changements coordonnÃ©s dans le cadre de diffÃ©rents modules ou packages Ã  l'intÃ©rieur du monolithe.  Des changements cohÃ©rents dans les microservices sont compliquÃ©s par la mise en page, le dÃ©ploiement, les tests, etc. cohÃ©rents. <br><br>  Et je voudrais parler des divers modÃ¨les et antipatrons de la division des responsabilitÃ©s en microservices. <br><a name="habracut"></a><br><h3>  EntitÃ© de service en tant qu'antipattern </h3><br>  Â«EntitÃ© de serviceÂ» est l'un des modÃ¨les (anti) possibles de conception d'architecture de microservice, ce qui conduit Ã  un code hautement dÃ©pendant dans diffÃ©rents services et couplÃ© de maniÃ¨re lÃ¢che au sein des services. <br><br>  Pour la plupart des dÃ©veloppeurs, il semble que lors de la sÃ©lection de services en fonction de l'essence du sujet: Â«dealÂ», Â«personÂ», Â«clientÂ», Â«orderÂ», Â«pictureÂ», il suit les principes de la responsabilitÃ© exclusive, et de plus, cela semble souvent logique.  Mais l'approche de l'entitÃ© de service peut devenir un contre-modÃ¨le.  Cela se produit car la plupart des fonctionnalitÃ©s ou des modifications affectent plusieurs entitÃ©s, et non une seule.  En consÃ©quence, chacun de ces services combine la logique de diffÃ©rents processus mÃ©tier. <br><br>  Par exemple, prenez une boutique en ligne.  Nous avons dÃ©cidÃ© de mettre en avant les services Â«produitÂ», Â«commandeÂ», Â«clientÂ». <br><br>  Quels changements et services dois-je apporter pour ajouter la livraison Ã  domicile? <br>  Par exemple, vous pouvez faire ceci: <br><br><ul><li>  dans le service "commande" ajoutez l'adresse de livraison, l'heure souhaitÃ©e et le livreur </li><li>  dans le service client ajouter une liste d'adresses de livraison sÃ©lectionnÃ©es pour le client </li><li>  dans le service Â«produitÂ» ajouter une liste d'entitÃ©s de biens </li></ul><br>  Pour l'interface du fournisseur, il sera nÃ©cessaire de faire une mÃ©thode API distincte dans le service Â«commandeÂ», qui donnera une liste des commandes attribuÃ©es Ã  ce fournisseur particulier.  De plus, des mÃ©thodes seront nÃ©cessaires pour retirer de la commande des marchandises qui ne correspondaient pas ou que le client avait refusÃ©es au moment de la livraison. <br><br>  Ou quels changements et dans quels services dois-je effectuer pour ajouter des remises sur le code promotionnel? <br>  Au minimum, vous avez besoin de: <br><br><ul><li>  ajouter un code promotionnel au service Â«commandeÂ» </li><li>  dans le service Â«produitÂ», ajoutez si des remises s'appliquent sur le code promotionnel pour ce produit </li><li>  dans le service client ajouter une liste de codes promotionnels qui ont Ã©tÃ© Ã©mis au client </li></ul><br>  Dans l'interface du responsable, l'ajout d'un code promotionnel personnalisÃ© au client est une mÃ©thode distincte dans le service client, qui n'est disponible que pour les directeurs de magasin, mais pas pour le client lui-mÃªme.  Et dans le service Â«produitÂ», faites une mÃ©thode qui donne une liste des produits qui sont concernÃ©s par le code promotionnel, afin qu'il soit plus facile pour le client de choisir dans son interface. <br><br>  Les sources de changements dans le service peuvent Ãªtre plusieurs processus commerciaux - sÃ©lection et conception, paiement et facturation, livraison.  Chacun des domaines problÃ©matiques a ses propres limites, invariants et exigences pour la commande.  En consÃ©quence, il s'avÃ¨re que dans le service Â«produitÂ», nous stockons des informations sur le produit, sur les remises et les soldes de produits dans les entrepÃ´ts.  Et dans la Â«commandeÂ» est stockÃ©e la logique du livreur. <br><br>  En d'autres termes, un changement de logique mÃ©tier qui est rÃ©parti sur plusieurs services entraÃ®ne des changements dÃ©pendants dans plusieurs services.  Et en mÃªme temps dans un service est un code qui n'est pas connectÃ© les uns aux autres. <br><br><h3>  Services de stockage </h3><br>  Il semble que ce problÃ¨me puisse Ãªtre rÃ©solu si un service de Â«coucheÂ» distinct est crÃ©Ã© sur les services d'entitÃ©, qui encapsulent la logique entiÃ¨re.  Mais gÃ©nÃ©ralement, cela se termine Ã©galement mal.  Parce que les services d'entitÃ© deviennent alors des services de stockage, c'est-Ã -dire  toute logique mÃ©tier en est Ã©liminÃ©e, Ã  l'exception du stockage. <br><br>  Si les donnÃ©es sont stockÃ©es dans diffÃ©rentes bases de donnÃ©es, sur diffÃ©rentes machines, nous <br><br><ul><li>  nous perdons des performances parce que nous ne fournissons pas de donnÃ©es directement Ã  partir de la base de donnÃ©es, mais Ã  travers la couche de service </li><li>  nous perdons de la flexibilitÃ© car l'API de service est gÃ©nÃ©ralement beaucoup moins flexible que SQL ou tout autre langage de requÃªte </li><li>  nous perdons en flexibilitÃ©, car il est difficile de fusionner les donnÃ©es de diffÃ©rents services <br></li></ul><br>  Si diffÃ©rents services d'entitÃ© ont accÃ¨s Ã  d'autres bases de donnÃ©es, la communication entre les services se fait implicitement - via une base de donnÃ©es commune, puis pour effectuer toute modification affectant un changement de schÃ©ma de donnÃ©es, il n'est possible qu'aprÃ¨s avoir vÃ©rifiÃ© que cette modification ne cassera pas tous les autres services qui utilisent cette base de donnÃ©es ou tablette. . <br><br>  En plus d'un dÃ©veloppement complexe, ces services deviennent trop critiques et lourdement chargÃ©s - avec presque toutes les demandes d'un service de niveau supÃ©rieur, vous devez faire plusieurs demandes Ã  diffÃ©rentes entitÃ©s de service, ce qui signifie que leur Ã©dition devient encore plus difficile afin de satisfaire les exigences accrues de fiabilitÃ© et de performances. <br><br>  En raison de ces difficultÃ©s avec le dÃ©veloppement et la prise en charge des services d'entitÃ© dans leur forme pure, vous voyez rarement un modÃ¨le; gÃ©nÃ©ralement, les services d'entitÃ© se transforment en un ou deux Â«microlithes-monolithesÂ» centraux, qui changent souvent et contiennent la logique mÃ©tier principale et les placers de petits microservices, gÃ©nÃ©ralement l'infrastructure et les petits qui changent rarement. <br><br><h3>  SÃ©paration par zones problÃ©matiques </h3><br>  Les changements en eux-mÃªmes ne sont pas nÃ©s, ils proviennent d'une zone problÃ©matique.  Une zone de problÃ¨me est une zone de tÃ¢che dans laquelle les problÃ¨mes nÃ©cessitant des modifications du code sont formulÃ©s dans une langue, en utilisant un ensemble de concepts ou interconnectÃ©s par la logique mÃ©tier.  Par consÃ©quent, dans le cadre d'un domaine problÃ©matique, il y aura trÃ¨s probablement un ensemble de contraintes, des invariants sur lesquels vous pourrez compter lors de l'Ã©criture de code. <br><br>  La sÃ©paration de la responsabilitÃ© des services par zones problÃ©matiques plutÃ´t que par entitÃ©s conduit gÃ©nÃ©ralement Ã  une architecture plus supportÃ©e et comprÃ©hensible.  Les domaines problÃ©matiques correspondent le plus souvent Ã  des processus mÃ©tier.  Pour la boutique en ligne, les problÃ¨mes les plus probables seront Â«paiement et facturationÂ», Â«livraisonÂ», Â«processus de commandeÂ». <br><br>  Les modifications qui affecteraient plusieurs zones problÃ©matiques en mÃªme temps sont moindres que les modifications qui affecteraient plusieurs entitÃ©s. <br><br>  De plus, les services ventilÃ©s par processus mÃ©tier peuvent Ãªtre rÃ©utilisÃ©s Ã  l'avenir.  Par exemple, si Ã  cÃ´tÃ© de la boutique en ligne nous voulions faire une autre vente de billets d'avion, nous pourrions rÃ©utiliser le service gÃ©nÃ©ral Â«Facturation et paiementÂ».  Et n'en faites pas un autre similaire, mais spÃ©cifique Ã  la vente de billets. <br><br>  Par exemple, nous pouvons ainsi nous diviser en services: <br><br><ul><li>  Un service ou un groupe de services Â«DeliveryÂ», qui stockera la logique du travail avec la livraison d'une commande spÃ©cifique, l'organisation du travail des fournisseurs, l'Ã©valuation de la qualitÃ© de leur travail, l'application mobile du fournisseur, etc. </li><li>  Un service ou un groupe de services Â«Facturation et paiementÂ», qui stockera la logique de travail avec le paiement, les comptes de paiement pour les personnes morales, la gÃ©nÃ©ration de contrats et les documents de clÃ´ture. </li><li>  Service ou groupe de services Â«Processus de commandeÂ», qui stocke la logique du choix des produits par le client, le catalogage, les marques, la logique du panier, etc. </li><li>  Service Â«autorisation et authentificationÂ». </li><li>  Il peut mÃªme Ãªtre judicieux de sÃ©parer le service de remise. </li></ul><br>  Pour interagir les uns avec les autres, les services peuvent utiliser le modÃ¨le d'Ã©vÃ©nement ou Ã©changer des objets simples entre eux (api reposant, grpc, etc.).  Certes, il convient de noter qu'il n'est pas facile d'organiser correctement l'interaction entre ces services.  Au minimum, la dÃ©centralisation des donnÃ©es a parfois des problÃ¨mes de cohÃ©rence (cohÃ©rence Ã©ventuelle) et de transactionnalitÃ© (dans le cas oÃ¹ elle est importante). <br><br>  DÃ©centralisation des donnÃ©es, l'Ã©change d'objets simples a ses avantages, ses inconvÃ©nients et ses piÃ¨ges.  D'une part, la dÃ©centralisation permet de dÃ©velopper et d'exploiter indÃ©pendamment plusieurs services.  D'autre part, le coÃ»t du stockage de deux ou trois copies de donnÃ©es et le maintien de la cohÃ©rence dans les diffÃ©rents systÃ¨mes. <br><br>  Dans la vraie vie, quelque chose se produit souvent entre les deux.  EntitÃ© de service avec un ensemble minimal d'attributs utilisÃ© par tous les services par les consommateurs.  Et une couche minimale de logique - par exemple, un modÃ¨le d'Ã©tat et des Ã©vÃ©nements dans la file d'attente avec la notification de tous les changements dans l'entitÃ©.  Dans le mÃªme temps, les services aux consommateurs conservent encore assez souvent un Â«cacheÂ» de donnÃ©es.  Tout est mis en Å“uvre pour qu'il y ait le moins de changements possible dans un tel service, ce qui, en principe, est difficile Ã  rÃ©aliser en raison du grand nombre de consommateurs. <br><br>  Dans le mÃªme temps, il est important de comprendre que toute partition - Ã  la fois par entitÃ© et par zone de problÃ¨me - n'est pas une solution miracle, il y aura toujours des fonctionnalitÃ©s qui nÃ©cessiteront des changements dÃ©pendants dans plusieurs services.  C'est juste qu'avec une panne il y aura beaucoup plus de tels changements qu'avec une autre.  Et la tÃ¢che du dÃ©veloppement est de minimiser le nombre de changements dÃ©pendants. <br><br>  Une rÃ©partition idÃ©ale n'est possible que si vous avez deux produits complÃ¨tement indÃ©pendants.  Dans toute entreprise, vous avez tout connectÃ© Ã  tout, la seule question est de savoir combien est connectÃ©. <br><br>  Et la question est dans la sÃ©paration des responsabilitÃ©s et dans la hauteur des barriÃ¨res aux abstractions. <br><br><h3>  API du service de conception </h3><br>  La conception d'interfaces au sein du service rÃ©pÃ¨te l'histoire avec la rÃ©partition en services, mais Ã  une Ã©chelle plus petite.  Changer l'interface (pas seulement une extension) est complexe et prend du temps.  Dans les applications complexes, l'interface doit Ãªtre suffisamment universelle pour ne pas provoquer de changements constants, et doit Ãªtre suffisamment spÃ©cifique et spÃ©cifique pour ne pas provoquer la propagation de la responsabilitÃ© et de la sÃ©mantique. <br><br>  Par consÃ©quent, les interfaces de service doivent Ãªtre conÃ§ues de sorte que leur sÃ©mantique soit rÃ©sistante aux changements.  Et cela est possible si la sÃ©mantique ou le domaine de responsabilitÃ© de l'interface reposait sur les limites de la zone Ã  problÃ¨me. <br><br><h3>  Interfaces CRUD pour des services avec une logique mÃ©tier complexe </h3><br>  Une interface trop large et non spÃ©cifique contribue Ã  l'Ã©rosion des responsabilitÃ©s ou Ã  une complexitÃ© excessive. <br><br>  Par exemple, l'API CRUD pour les services avec une logique mÃ©tier complexe. Ces interfaces n'encapsulent pas le comportement.  Ils permettent non seulement Ã  la logique mÃ©tier de s'infiltrer dans d'autres services et d'Ã©roder la responsabilitÃ© du service, ils provoquent la propagation de la logique mÃ©tier - les restrictions, les invariants et les mÃ©thodes de travail avec les donnÃ©es se trouvent dÃ©sormais dans d'autres services.  Les services utilisateur d'interface (API) doivent implÃ©menter la logique eux-mÃªmes. <br><br>  Si nous essayons, sans changer considÃ©rablement l'interface, de transfÃ©rer la logique mÃ©tier au service, nous obtiendrons une mÃ©thode trop universelle et trop compliquÃ©e. <br><br>  Par exemple, il existe un service de billetterie.  Un ticket peut Ãªtre de diffÃ©rents types.  Chaque type a un ensemble de champs diffÃ©rent et une validation lÃ©gÃ¨rement diffÃ©rente.  Le ticket a Ã©galement un modÃ¨le d'Ã©tat - une machine d'Ã©tat pour la transition d'un Ã©tat Ã  un autre. <br><br>  Laissez l'API ressembler Ã  ceci: mÃ©thodes POST / PATCH / GET, url /api/v1/tickets/{ticket_idasket.json <br><br>  Vous pouvez donc mettre Ã  jour le ticket <br><br><pre><code class="json hljs">PATCH /api/v<span class="hljs-number"><span class="hljs-number">1</span></span>/tickets/{ticket_id}.json { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"bug"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-string"><span class="hljs-string">"closed"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> }</code> </pre> <br>  Si le modÃ¨le d'Ã©tat dÃ©pend du ticket, des conflits de logique mÃ©tier sont possibles.  Tout d'abord, modifiez le statut en fonction de l'ancien modÃ¨le de statut, puis modifiez le type de ticket.  Ou vice versa? <br><br>  Il s'avÃ¨re qu'Ã  l'intÃ©rieur de la mÃ©thode API, il y aura du code qui n'est pas connectÃ© les uns aux autres - modification des champs d'entitÃ©, une liste des champs disponibles, selon le type de ticket, et un modÃ¨le de statut.  Ils changent pour diverses raisons et il est logique de les distribuer selon diffÃ©rentes mÃ©thodes et interfaces API. <br><br>  Si la modification d'un champ dans le cadre des mÃ©thodes API CRUD n'est pas seulement un changement de donnÃ©es, mais une opÃ©ration liÃ©e Ã  un changement coordonnÃ© de l'Ã©tat d'une entitÃ©, cette opÃ©ration doit Ãªtre reprise dans une mÃ©thode distincte et ne doit pas Ãªtre modifiÃ©e directement.  Si changer une API sans compatibilitÃ© descendante est trÃ¨s mauvais (pour les API publiques), il vaut mieux y penser tout de suite lors de la conception de l'API. <br><br>  Par consÃ©quent, afin d'Ã©viter de tels problÃ¨mes, il est prÃ©fÃ©rable de rendre les interfaces petites, spÃ©cifiques et aussi orientÃ©es vers les problÃ¨mes que possible, plutÃ´t que celles universelles centrÃ©es sur les donnÃ©es. <br><br>  Ce modÃ¨le (anti) est plus souvent caractÃ©ristique des interfaces RESTful, car il n'y a par dÃ©faut que quelques Â«verbesÂ» centrÃ©s sur les donnÃ©es d'actions Ã  crÃ©er, supprimer, mettre Ã  jour, lire.  Aucune opÃ©ration d'entitÃ© spÃ©cifique Ã  l'entreprise <br><br>  Que peut-on faire pour rendre RESTful plus orientÃ© vers les problÃ¨mes? <br>  Tout d'abord, vous pouvez ajouter des mÃ©thodes aux entitÃ©s.  L'interface devient moins reposante.  Mais il y a une telle opportunitÃ©.  Nous ne luttons toujours pas pour la puretÃ© de la course, mais rÃ©solvons des problÃ¨mes pratiques <br><br>  Au lieu de la ressource universelle <code>/api/v1/tickets.json</code> ajoutez plus de ressources: <br><br>  <code>/api/v1/tickets/{ticket_id}/migrate.json</code> - migrer d'un type Ã  un autre <br>  <code>/api/v1/tickets/{ticket_id}/status.json</code> - s'il existe un modÃ¨le de statut <br><br>  DeuxiÃ¨mement, vous pouvez imaginer toute opÃ©ration comme une ressource dans le cadre de REST.  Existe-t-il une opÃ©ration de migration de ticket d'un type Ã  un autre (ou d'un projet Ã  un autre?).  Ok, donc il y aura une ressource <br> <code>/api/v1/tickets/migration.json</code> <br> <br>  Existe-t-il une opÃ©ration commerciale pour crÃ©er un abonnement d'essai? <br> <code>/api/v1/subscriptions/trial.json</code> <br> <br>  Y a-t-il une opÃ©ration de transfert d'argent? <br> <code>/api/v1/money_transfers.json</code> <br> <br>  Etc. <br><br>  L'antipattern avec l'API data-centric fait Ã©galement rÃ©fÃ©rence Ã  l'interaction rpc.  Par exemple, la prÃ©sence de mÃ©thodes trop gÃ©nÃ©rales comme editAccount () ou editTicket ().  Â«Modifier un objetÂ» ne porte pas la charge sÃ©mantique associÃ©e Ã  la zone Ã  problÃ¨me.  Cela signifie que cette mÃ©thode sera appelÃ©e pour diverses raisons, pour diverses raisons de changer. <br><br>  Il convient de noter que les interfaces centrÃ©es sur les donnÃ©es sont tout Ã  fait correctes, si la zone Ã  problÃ¨me implique uniquement le stockage, la rÃ©ception et la modification des donnÃ©es. <br><br><h3>  ModÃ¨le d'Ã©vÃ©nement </h3><br>  Une faÃ§on de dÃ©lier des morceaux de code consiste Ã  organiser l'interaction entre les services via une file d'attente de messages. <br><br>  Par exemple, si dans le service, lors de l'enregistrement d'un utilisateur, nous devons lui envoyer une lettre de bienvenue, crÃ©er une demande dans CRM pour un gestionnaire de client, etc., alors il est logique de ne pas passer un appel de service externe, mais de mettre le message Â«l'utilisateur 123 est enregistrÃ©Â» dans le service d'enregistrement Â», Et tous les services nÃ©cessaires liront ce message et prendront les mesures nÃ©cessaires.  Dans le mÃªme temps, la modification de la logique mÃ©tier ne nÃ©cessitera pas de changer le service d'enregistrement. <br><br>  Le plus souvent, non seulement les messages sont jetÃ©s dans la file d'attente, mais les Ã©vÃ©nements.  Comme la file d'attente n'est qu'un protocole de transport, les mÃªmes restrictions s'appliquent Ã  l'interface de donnÃ©es qu'Ã  l'interface synchrone normale.  Par consÃ©quent, afin d'Ã©viter des problÃ¨mes de changement d'interface et de modifications ultÃ©rieures dans d'autres services, il est prÃ©fÃ©rable de rendre les Ã©vÃ©nements aussi orientÃ©s vers les problÃ¨mes que possible.  De tels Ã©vÃ©nements sont encore souvent appelÃ©s Ã©vÃ©nements de domaine.  Dans le mÃªme temps, l'utilisation du modÃ¨le d'Ã©vÃ©nement n'affecte gÃ©nÃ©ralement pas beaucoup les frontiÃ¨res auxquelles les (micro) services se battent. <br><br>  Ã‰tant donnÃ© que les Ã©vÃ©nements de domaine sont pratiquement 1 en 1 traduits en mÃ©thodes API synchrones, ils suggÃ¨rent mÃªme parfois d'utiliser un flux d'Ã©vÃ©nements au lieu d'un flux d'Ã©vÃ©nements au lieu d'un appel d'API (Event Sourcing).  Par le flux d'Ã©vÃ©nements, vous pouvez toujours restaurer l'Ã©tat des objets, mais aussi avoir un historique gratuit.  En fait, cette approche n'est gÃ©nÃ©ralement pas trÃ¨s flexible - vous devez prendre en charge tous les Ã©vÃ©nements, et il est souvent plus facile de garder une histoire Ã  cÃ´tÃ© de l'API habituelle. <br><br><h3>  Microservices et performances.  Cqrs </h3><br>  En principe, le domaine problÃ©matique implique des changements dans le code associÃ©s non seulement aux exigences fonctionnelles de l'entreprise, mais aussi Ã  des exigences non fonctionnelles - par exemple, les performances.  S'il y a deux morceaux de code avec des exigences de performances diffÃ©rentes, cela signifie que ces deux morceaux de code peuvent Ãªtre judicieux de se sÃ©parer.  Et ils sont gÃ©nÃ©ralement divisÃ©s en services distincts afin de pouvoir utiliser diffÃ©rents langages et technologies plus adaptÃ©s Ã  la tÃ¢che. <br><br>  Par exemple, il existe une mÃ©thode de calcul liÃ©e au processeur dans un service Ã©crit en PHP qui effectue des calculs complexes.  Avec une augmentation de la charge et de la quantitÃ© de donnÃ©es, il a cessÃ© de faire face.  Et bien sÃ»r, comme l'une des options, il est logique de faire des calculs non pas dans du code php, mais dans un dÃ©mon systÃ¨me haute performance distinct. <br><br>  Comme l'un des exemples de la division des services par le principe de la productivitÃ© - la sÃ©paration des services en lecture et modification (CQRS).  Cette sÃ©paration est souvent offerte car les exigences de performance des services de lecture et d'Ã©criture sont diffÃ©rentes.  La charge de lecture est souvent d'un ordre de grandeur supÃ©rieur Ã  la charge d'Ã©criture.  Et les exigences de vitesse de rÃ©ponse des demandes de lecture sont beaucoup plus Ã©levÃ©es que pour l'Ã©criture. <br><br>  Le client passe 99% du temps dans la recherche de marchandises, et seulement 1% du temps dans le processus de commande.  Pour un client dans un Ã©tat de recherche, la vitesse d'affichage est importante et les fonctionnalitÃ©s liÃ©es aux filtres, diverses options d'affichage des marchandises, etc.  Par consÃ©quent, il est logique de mettre en Ã©vidence un service distinct qui est responsable de la recherche, du filtrage et de l'affichage des marchandises.  Un tel service fonctionnera trÃ¨s probablement sur une sorte d'ELK, une base de donnÃ©es orientÃ©e document avec des donnÃ©es dÃ©normalisÃ©es. <br><br>  De toute Ã©vidence, une division naÃ¯ve entre les services de lecture et de modification n'est pas toujours bonne. <br><br>  Un exemple.  Pour un gestionnaire qui travaille Ã  remplir la gamme de produits, les principales caractÃ©ristiques seront la possibilitÃ© d'ajouter facilement des marchandises, de les supprimer, de les modifier et de les afficher.  Il n'y a pas beaucoup de charge, si nous sÃ©parons la lecture et la transformation en services sÃ©parÃ©s, nous n'obtiendrons rien de cette sÃ©paration, Ã  l'exception des problÃ¨mes lorsque vous devez apporter des modifications coordonnÃ©es aux services. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469001/">https://habr.com/ru/post/fr469001/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468991/index.html">Personnages de sprites modulaires et leur animation</a></li>
<li><a href="../fr468993/index.html">Oculus Quest se connecte Ã  un PC et voit les mains</a></li>
<li><a href="../fr468995/index.html">Politique d'ouverture: comment les utilisateurs influencent le projet</a></li>
<li><a href="../fr468997/index.html">Le mentorat - un incontournable ou un bon bonus?</a></li>
<li><a href="../fr468999/index.html">Quels pays ont l'Internet le plus Â«lentÂ» et qui corrige la situation dans les rÃ©gions difficiles d'accÃ¨s</a></li>
<li><a href="../fr469003/index.html">Â«ConfÃ©rence pour les gens et pour rÃ©pondre Ã  leurs besoinsÂ»: comitÃ© du programme DevOpsDays sur ce qu'est une confÃ©rence communautaire</a></li>
<li><a href="../fr469005/index.html">Ohio Challenger 2P et ses 4 Ko de RAM</a></li>
<li><a href="../fr469007/index.html">RubyRussia 2019. Nikita Shilnikov sur les effets algÃ©briques</a></li>
<li><a href="../fr469009/index.html">Le fret culte dans le dÃ©veloppement de logiciels</a></li>
<li><a href="../fr469011/index.html">11 mythes sur l'USB Type-C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>