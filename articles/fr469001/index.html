<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎋 🕘 👩🏿‍🏭 Comment faire cuire la bouillie à partir de microservices 📿 👨🏼‍⚖️ 🍜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'une des raisons de la popularité des microservices est la possibilité d'un développement autonome et indépendant. En substance, l'architecture de mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment faire cuire la bouillie à partir de microservices</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469001/">  L'une des raisons de la popularité des microservices est la possibilité d'un développement autonome et indépendant.  En substance, l'architecture de microservices est l'échange de la possibilité d'un développement autonome pour un déploiement, des tests, un débogage et une surveillance plus complexes (par rapport à un monolithe).  Mais gardez à l'esprit que les microservices ne pardonnent pas la séparation des responsabilités.  Si la séparation des tâches est incorrecte, des changements dépendants fréquents se produisent dans différents services.  Et cela est beaucoup plus douloureux et plus compliqué que des changements coordonnés dans le cadre de différents modules ou packages à l'intérieur du monolithe.  Des changements cohérents dans les microservices sont compliqués par la mise en page, le déploiement, les tests, etc. cohérents. <br><br>  Et je voudrais parler des divers modèles et antipatrons de la division des responsabilités en microservices. <br><a name="habracut"></a><br><h3>  Entité de service en tant qu'antipattern </h3><br>  «Entité de service» est l'un des modèles (anti) possibles de conception d'architecture de microservice, ce qui conduit à un code hautement dépendant dans différents services et couplé de manière lâche au sein des services. <br><br>  Pour la plupart des développeurs, il semble que lors de la sélection de services en fonction de l'essence du sujet: «deal», «person», «client», «order», «picture», il suit les principes de la responsabilité exclusive, et de plus, cela semble souvent logique.  Mais l'approche de l'entité de service peut devenir un contre-modèle.  Cela se produit car la plupart des fonctionnalités ou des modifications affectent plusieurs entités, et non une seule.  En conséquence, chacun de ces services combine la logique de différents processus métier. <br><br>  Par exemple, prenez une boutique en ligne.  Nous avons décidé de mettre en avant les services «produit», «commande», «client». <br><br>  Quels changements et services dois-je apporter pour ajouter la livraison à domicile? <br>  Par exemple, vous pouvez faire ceci: <br><br><ul><li>  dans le service "commande" ajoutez l'adresse de livraison, l'heure souhaitée et le livreur </li><li>  dans le service client ajouter une liste d'adresses de livraison sélectionnées pour le client </li><li>  dans le service «produit» ajouter une liste d'entités de biens </li></ul><br>  Pour l'interface du fournisseur, il sera nécessaire de faire une méthode API distincte dans le service «commande», qui donnera une liste des commandes attribuées à ce fournisseur particulier.  De plus, des méthodes seront nécessaires pour retirer de la commande des marchandises qui ne correspondaient pas ou que le client avait refusées au moment de la livraison. <br><br>  Ou quels changements et dans quels services dois-je effectuer pour ajouter des remises sur le code promotionnel? <br>  Au minimum, vous avez besoin de: <br><br><ul><li>  ajouter un code promotionnel au service «commande» </li><li>  dans le service «produit», ajoutez si des remises s'appliquent sur le code promotionnel pour ce produit </li><li>  dans le service client ajouter une liste de codes promotionnels qui ont été émis au client </li></ul><br>  Dans l'interface du responsable, l'ajout d'un code promotionnel personnalisé au client est une méthode distincte dans le service client, qui n'est disponible que pour les directeurs de magasin, mais pas pour le client lui-même.  Et dans le service «produit», faites une méthode qui donne une liste des produits qui sont concernés par le code promotionnel, afin qu'il soit plus facile pour le client de choisir dans son interface. <br><br>  Les sources de changements dans le service peuvent être plusieurs processus commerciaux - sélection et conception, paiement et facturation, livraison.  Chacun des domaines problématiques a ses propres limites, invariants et exigences pour la commande.  En conséquence, il s'avère que dans le service «produit», nous stockons des informations sur le produit, sur les remises et les soldes de produits dans les entrepôts.  Et dans la «commande» est stockée la logique du livreur. <br><br>  En d'autres termes, un changement de logique métier qui est réparti sur plusieurs services entraîne des changements dépendants dans plusieurs services.  Et en même temps dans un service est un code qui n'est pas connecté les uns aux autres. <br><br><h3>  Services de stockage </h3><br>  Il semble que ce problème puisse être résolu si un service de «couche» distinct est créé sur les services d'entité, qui encapsulent la logique entière.  Mais généralement, cela se termine également mal.  Parce que les services d'entité deviennent alors des services de stockage, c'est-à-dire  toute logique métier en est éliminée, à l'exception du stockage. <br><br>  Si les données sont stockées dans différentes bases de données, sur différentes machines, nous <br><br><ul><li>  nous perdons des performances parce que nous ne fournissons pas de données directement à partir de la base de données, mais à travers la couche de service </li><li>  nous perdons de la flexibilité car l'API de service est généralement beaucoup moins flexible que SQL ou tout autre langage de requête </li><li>  nous perdons en flexibilité, car il est difficile de fusionner les données de différents services <br></li></ul><br>  Si différents services d'entité ont accès à d'autres bases de données, la communication entre les services se fait implicitement - via une base de données commune, puis pour effectuer toute modification affectant un changement de schéma de données, il n'est possible qu'après avoir vérifié que cette modification ne cassera pas tous les autres services qui utilisent cette base de données ou tablette. . <br><br>  En plus d'un développement complexe, ces services deviennent trop critiques et lourdement chargés - avec presque toutes les demandes d'un service de niveau supérieur, vous devez faire plusieurs demandes à différentes entités de service, ce qui signifie que leur édition devient encore plus difficile afin de satisfaire les exigences accrues de fiabilité et de performances. <br><br>  En raison de ces difficultés avec le développement et la prise en charge des services d'entité dans leur forme pure, vous voyez rarement un modèle; généralement, les services d'entité se transforment en un ou deux «microlithes-monolithes» centraux, qui changent souvent et contiennent la logique métier principale et les placers de petits microservices, généralement l'infrastructure et les petits qui changent rarement. <br><br><h3>  Séparation par zones problématiques </h3><br>  Les changements en eux-mêmes ne sont pas nés, ils proviennent d'une zone problématique.  Une zone de problème est une zone de tâche dans laquelle les problèmes nécessitant des modifications du code sont formulés dans une langue, en utilisant un ensemble de concepts ou interconnectés par la logique métier.  Par conséquent, dans le cadre d'un domaine problématique, il y aura très probablement un ensemble de contraintes, des invariants sur lesquels vous pourrez compter lors de l'écriture de code. <br><br>  La séparation de la responsabilité des services par zones problématiques plutôt que par entités conduit généralement à une architecture plus supportée et compréhensible.  Les domaines problématiques correspondent le plus souvent à des processus métier.  Pour la boutique en ligne, les problèmes les plus probables seront «paiement et facturation», «livraison», «processus de commande». <br><br>  Les modifications qui affecteraient plusieurs zones problématiques en même temps sont moindres que les modifications qui affecteraient plusieurs entités. <br><br>  De plus, les services ventilés par processus métier peuvent être réutilisés à l'avenir.  Par exemple, si à côté de la boutique en ligne nous voulions faire une autre vente de billets d'avion, nous pourrions réutiliser le service général «Facturation et paiement».  Et n'en faites pas un autre similaire, mais spécifique à la vente de billets. <br><br>  Par exemple, nous pouvons ainsi nous diviser en services: <br><br><ul><li>  Un service ou un groupe de services «Delivery», qui stockera la logique du travail avec la livraison d'une commande spécifique, l'organisation du travail des fournisseurs, l'évaluation de la qualité de leur travail, l'application mobile du fournisseur, etc. </li><li>  Un service ou un groupe de services «Facturation et paiement», qui stockera la logique de travail avec le paiement, les comptes de paiement pour les personnes morales, la génération de contrats et les documents de clôture. </li><li>  Service ou groupe de services «Processus de commande», qui stocke la logique du choix des produits par le client, le catalogage, les marques, la logique du panier, etc. </li><li>  Service «autorisation et authentification». </li><li>  Il peut même être judicieux de séparer le service de remise. </li></ul><br>  Pour interagir les uns avec les autres, les services peuvent utiliser le modèle d'événement ou échanger des objets simples entre eux (api reposant, grpc, etc.).  Certes, il convient de noter qu'il n'est pas facile d'organiser correctement l'interaction entre ces services.  Au minimum, la décentralisation des données a parfois des problèmes de cohérence (cohérence éventuelle) et de transactionnalité (dans le cas où elle est importante). <br><br>  Décentralisation des données, l'échange d'objets simples a ses avantages, ses inconvénients et ses pièges.  D'une part, la décentralisation permet de développer et d'exploiter indépendamment plusieurs services.  D'autre part, le coût du stockage de deux ou trois copies de données et le maintien de la cohérence dans les différents systèmes. <br><br>  Dans la vraie vie, quelque chose se produit souvent entre les deux.  Entité de service avec un ensemble minimal d'attributs utilisé par tous les services par les consommateurs.  Et une couche minimale de logique - par exemple, un modèle d'état et des événements dans la file d'attente avec la notification de tous les changements dans l'entité.  Dans le même temps, les services aux consommateurs conservent encore assez souvent un «cache» de données.  Tout est mis en œuvre pour qu'il y ait le moins de changements possible dans un tel service, ce qui, en principe, est difficile à réaliser en raison du grand nombre de consommateurs. <br><br>  Dans le même temps, il est important de comprendre que toute partition - à la fois par entité et par zone de problème - n'est pas une solution miracle, il y aura toujours des fonctionnalités qui nécessiteront des changements dépendants dans plusieurs services.  C'est juste qu'avec une panne il y aura beaucoup plus de tels changements qu'avec une autre.  Et la tâche du développement est de minimiser le nombre de changements dépendants. <br><br>  Une répartition idéale n'est possible que si vous avez deux produits complètement indépendants.  Dans toute entreprise, vous avez tout connecté à tout, la seule question est de savoir combien est connecté. <br><br>  Et la question est dans la séparation des responsabilités et dans la hauteur des barrières aux abstractions. <br><br><h3>  API du service de conception </h3><br>  La conception d'interfaces au sein du service répète l'histoire avec la répartition en services, mais à une échelle plus petite.  Changer l'interface (pas seulement une extension) est complexe et prend du temps.  Dans les applications complexes, l'interface doit être suffisamment universelle pour ne pas provoquer de changements constants, et doit être suffisamment spécifique et spécifique pour ne pas provoquer la propagation de la responsabilité et de la sémantique. <br><br>  Par conséquent, les interfaces de service doivent être conçues de sorte que leur sémantique soit résistante aux changements.  Et cela est possible si la sémantique ou le domaine de responsabilité de l'interface reposait sur les limites de la zone à problème. <br><br><h3>  Interfaces CRUD pour des services avec une logique métier complexe </h3><br>  Une interface trop large et non spécifique contribue à l'érosion des responsabilités ou à une complexité excessive. <br><br>  Par exemple, l'API CRUD pour les services avec une logique métier complexe. Ces interfaces n'encapsulent pas le comportement.  Ils permettent non seulement à la logique métier de s'infiltrer dans d'autres services et d'éroder la responsabilité du service, ils provoquent la propagation de la logique métier - les restrictions, les invariants et les méthodes de travail avec les données se trouvent désormais dans d'autres services.  Les services utilisateur d'interface (API) doivent implémenter la logique eux-mêmes. <br><br>  Si nous essayons, sans changer considérablement l'interface, de transférer la logique métier au service, nous obtiendrons une méthode trop universelle et trop compliquée. <br><br>  Par exemple, il existe un service de billetterie.  Un ticket peut être de différents types.  Chaque type a un ensemble de champs différent et une validation légèrement différente.  Le ticket a également un modèle d'état - une machine d'état pour la transition d'un état à un autre. <br><br>  Laissez l'API ressembler à ceci: méthodes POST / PATCH / GET, url /api/v1/tickets/{ticket_idasket.json <br><br>  Vous pouvez donc mettre à jour le ticket <br><br><pre><code class="json hljs">PATCH /api/v<span class="hljs-number"><span class="hljs-number">1</span></span>/tickets/{ticket_id}.json { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"bug"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-string"><span class="hljs-string">"closed"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> }</code> </pre> <br>  Si le modèle d'état dépend du ticket, des conflits de logique métier sont possibles.  Tout d'abord, modifiez le statut en fonction de l'ancien modèle de statut, puis modifiez le type de ticket.  Ou vice versa? <br><br>  Il s'avère qu'à l'intérieur de la méthode API, il y aura du code qui n'est pas connecté les uns aux autres - modification des champs d'entité, une liste des champs disponibles, selon le type de ticket, et un modèle de statut.  Ils changent pour diverses raisons et il est logique de les distribuer selon différentes méthodes et interfaces API. <br><br>  Si la modification d'un champ dans le cadre des méthodes API CRUD n'est pas seulement un changement de données, mais une opération liée à un changement coordonné de l'état d'une entité, cette opération doit être reprise dans une méthode distincte et ne doit pas être modifiée directement.  Si changer une API sans compatibilité descendante est très mauvais (pour les API publiques), il vaut mieux y penser tout de suite lors de la conception de l'API. <br><br>  Par conséquent, afin d'éviter de tels problèmes, il est préférable de rendre les interfaces petites, spécifiques et aussi orientées vers les problèmes que possible, plutôt que celles universelles centrées sur les données. <br><br>  Ce modèle (anti) est plus souvent caractéristique des interfaces RESTful, car il n'y a par défaut que quelques «verbes» centrés sur les données d'actions à créer, supprimer, mettre à jour, lire.  Aucune opération d'entité spécifique à l'entreprise <br><br>  Que peut-on faire pour rendre RESTful plus orienté vers les problèmes? <br>  Tout d'abord, vous pouvez ajouter des méthodes aux entités.  L'interface devient moins reposante.  Mais il y a une telle opportunité.  Nous ne luttons toujours pas pour la pureté de la course, mais résolvons des problèmes pratiques <br><br>  Au lieu de la ressource universelle <code>/api/v1/tickets.json</code> ajoutez plus de ressources: <br><br>  <code>/api/v1/tickets/{ticket_id}/migrate.json</code> - migrer d'un type à un autre <br>  <code>/api/v1/tickets/{ticket_id}/status.json</code> - s'il existe un modèle de statut <br><br>  Deuxièmement, vous pouvez imaginer toute opération comme une ressource dans le cadre de REST.  Existe-t-il une opération de migration de ticket d'un type à un autre (ou d'un projet à un autre?).  Ok, donc il y aura une ressource <br> <code>/api/v1/tickets/migration.json</code> <br> <br>  Existe-t-il une opération commerciale pour créer un abonnement d'essai? <br> <code>/api/v1/subscriptions/trial.json</code> <br> <br>  Y a-t-il une opération de transfert d'argent? <br> <code>/api/v1/money_transfers.json</code> <br> <br>  Etc. <br><br>  L'antipattern avec l'API data-centric fait également référence à l'interaction rpc.  Par exemple, la présence de méthodes trop générales comme editAccount () ou editTicket ().  «Modifier un objet» ne porte pas la charge sémantique associée à la zone à problème.  Cela signifie que cette méthode sera appelée pour diverses raisons, pour diverses raisons de changer. <br><br>  Il convient de noter que les interfaces centrées sur les données sont tout à fait correctes, si la zone à problème implique uniquement le stockage, la réception et la modification des données. <br><br><h3>  Modèle d'événement </h3><br>  Une façon de délier des morceaux de code consiste à organiser l'interaction entre les services via une file d'attente de messages. <br><br>  Par exemple, si dans le service, lors de l'enregistrement d'un utilisateur, nous devons lui envoyer une lettre de bienvenue, créer une demande dans CRM pour un gestionnaire de client, etc., alors il est logique de ne pas passer un appel de service externe, mais de mettre le message «l'utilisateur 123 est enregistré» dans le service d'enregistrement », Et tous les services nécessaires liront ce message et prendront les mesures nécessaires.  Dans le même temps, la modification de la logique métier ne nécessitera pas de changer le service d'enregistrement. <br><br>  Le plus souvent, non seulement les messages sont jetés dans la file d'attente, mais les événements.  Comme la file d'attente n'est qu'un protocole de transport, les mêmes restrictions s'appliquent à l'interface de données qu'à l'interface synchrone normale.  Par conséquent, afin d'éviter des problèmes de changement d'interface et de modifications ultérieures dans d'autres services, il est préférable de rendre les événements aussi orientés vers les problèmes que possible.  De tels événements sont encore souvent appelés événements de domaine.  Dans le même temps, l'utilisation du modèle d'événement n'affecte généralement pas beaucoup les frontières auxquelles les (micro) services se battent. <br><br>  Étant donné que les événements de domaine sont pratiquement 1 en 1 traduits en méthodes API synchrones, ils suggèrent même parfois d'utiliser un flux d'événements au lieu d'un flux d'événements au lieu d'un appel d'API (Event Sourcing).  Par le flux d'événements, vous pouvez toujours restaurer l'état des objets, mais aussi avoir un historique gratuit.  En fait, cette approche n'est généralement pas très flexible - vous devez prendre en charge tous les événements, et il est souvent plus facile de garder une histoire à côté de l'API habituelle. <br><br><h3>  Microservices et performances.  Cqrs </h3><br>  En principe, le domaine problématique implique des changements dans le code associés non seulement aux exigences fonctionnelles de l'entreprise, mais aussi à des exigences non fonctionnelles - par exemple, les performances.  S'il y a deux morceaux de code avec des exigences de performances différentes, cela signifie que ces deux morceaux de code peuvent être judicieux de se séparer.  Et ils sont généralement divisés en services distincts afin de pouvoir utiliser différents langages et technologies plus adaptés à la tâche. <br><br>  Par exemple, il existe une méthode de calcul liée au processeur dans un service écrit en PHP qui effectue des calculs complexes.  Avec une augmentation de la charge et de la quantité de données, il a cessé de faire face.  Et bien sûr, comme l'une des options, il est logique de faire des calculs non pas dans du code php, mais dans un démon système haute performance distinct. <br><br>  Comme l'un des exemples de la division des services par le principe de la productivité - la séparation des services en lecture et modification (CQRS).  Cette séparation est souvent offerte car les exigences de performance des services de lecture et d'écriture sont différentes.  La charge de lecture est souvent d'un ordre de grandeur supérieur à la charge d'écriture.  Et les exigences de vitesse de réponse des demandes de lecture sont beaucoup plus élevées que pour l'écriture. <br><br>  Le client passe 99% du temps dans la recherche de marchandises, et seulement 1% du temps dans le processus de commande.  Pour un client dans un état de recherche, la vitesse d'affichage est importante et les fonctionnalités liées aux filtres, diverses options d'affichage des marchandises, etc.  Par conséquent, il est logique de mettre en évidence un service distinct qui est responsable de la recherche, du filtrage et de l'affichage des marchandises.  Un tel service fonctionnera très probablement sur une sorte d'ELK, une base de données orientée document avec des données dénormalisées. <br><br>  De toute évidence, une division naïve entre les services de lecture et de modification n'est pas toujours bonne. <br><br>  Un exemple.  Pour un gestionnaire qui travaille à remplir la gamme de produits, les principales caractéristiques seront la possibilité d'ajouter facilement des marchandises, de les supprimer, de les modifier et de les afficher.  Il n'y a pas beaucoup de charge, si nous séparons la lecture et la transformation en services séparés, nous n'obtiendrons rien de cette séparation, à l'exception des problèmes lorsque vous devez apporter des modifications coordonnées aux services. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469001/">https://habr.com/ru/post/fr469001/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468991/index.html">Personnages de sprites modulaires et leur animation</a></li>
<li><a href="../fr468993/index.html">Oculus Quest se connecte à un PC et voit les mains</a></li>
<li><a href="../fr468995/index.html">Politique d'ouverture: comment les utilisateurs influencent le projet</a></li>
<li><a href="../fr468997/index.html">Le mentorat - un incontournable ou un bon bonus?</a></li>
<li><a href="../fr468999/index.html">Quels pays ont l'Internet le plus «lent» et qui corrige la situation dans les régions difficiles d'accès</a></li>
<li><a href="../fr469003/index.html">«Conférence pour les gens et pour répondre à leurs besoins»: comité du programme DevOpsDays sur ce qu'est une conférence communautaire</a></li>
<li><a href="../fr469005/index.html">Ohio Challenger 2P et ses 4 Ko de RAM</a></li>
<li><a href="../fr469007/index.html">RubyRussia 2019. Nikita Shilnikov sur les effets algébriques</a></li>
<li><a href="../fr469009/index.html">Le fret culte dans le développement de logiciels</a></li>
<li><a href="../fr469011/index.html">11 mythes sur l'USB Type-C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>