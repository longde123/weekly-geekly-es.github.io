<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèø ü¶ë ü•ò Desarrollo de un sintetizador musical simple en ATMEGA8 üë©‚Äçüëß‚Äçüëß üëì üë®üèº‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace unos a√±os, hice una alarma en el microcontrolador ATmega8, donde implement√© un sintetizador de melod√≠a simple de un solo tono (una sola voz). Hay...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de un sintetizador musical simple en ATMEGA8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454514/">  Hace unos a√±os, hice una alarma en el microcontrolador ATmega8, donde implement√© un sintetizador de melod√≠a simple de un solo tono (una sola voz).  Hay muchos art√≠culos en Internet para principiantes sobre este tema.  Como regla general, se utiliza un temporizador de 16 bits para generar la frecuencia (notas), que se configura de cierta manera, lo que obliga al nivel de hardware a emitir una se√±al en forma de meandro en un pin espec√≠fico del MC.  El segundo temporizador (8 bits) se usa para implementar la duraci√≥n de una nota o pausa.  Las notas de acuerdo con f√≥rmulas bien conocidas se comparan con las frecuencias y, a su vez, se comparan con ciertos n√∫meros de 16 bits, inversamente proporcionales a las frecuencias que especifican los per√≠odos de conteo del temporizador. <br><a name="habracut"></a><br>  En mi dise√±o, proporcion√© tres melod√≠as que fueron escritas en la misma clave y escala.  Por lo tanto, tuve que usar un n√∫mero limitado y cierto de notas, lo que facilit√≥ el modelado.  Adem√°s, las tres canciones se tocaron al mismo ritmo.  El c√≥digo de nota y su c√≥digo de duraci√≥n caben f√°cilmente en un byte.  El √∫nico inconveniente de este modelo era la falta de versatilidad, la capacidad de editar, reemplazar o complementar r√°pidamente la melod√≠a.  Para grabar una melod√≠a, primero la dibuj√© en un editor de m√∫sica en una computadora, luego copi√© las notas y su duraci√≥n, con la numeraci√≥n que decid√≠ de antemano, y luego form√© los bytes resultantes.  Hice las √∫ltimas operaciones usando el programa Excel. <br><br>  En el futuro, quer√≠a eliminar el inconveniente antes mencionado, traicionar el dise√±o de una cierta universalidad y reducir el tiempo para implementar la melod√≠a.  Hubo tal idea que el programa MK ley√≥ los bytes de uno de los formatos de m√∫sica famosos.  El m√°s popular y com√∫n es el formato MIDI.  M√°s literalmente, este no es tanto un formato como una "ciencia" completa sobre la que se puede leer en Internet.  La especificaci√≥n MIDI define el protocolo para transmitir mensajes en tiempo real a trav√©s de la interfaz f√≠sica correspondiente y describe c√≥mo se organizan los archivos midi en los que se pueden almacenar estos mensajes.  El formato midi est√° orientado a la m√∫sica, por lo que encuentra aplicaci√≥n en el campo relevante.  Este es un control sincr√≥nico de equipos de sonido, m√∫sica en color, sintetizadores musicales y robots, etc.  En el √°mbito dom√©stico, el formato midi se encontr√≥ en la era del comienzo del desarrollo de los tel√©fonos m√≥viles.  En este caso, los mensajes sobre la inclusi√≥n o desactivaci√≥n de una nota en particular, informaci√≥n sobre un instrumento musical, el volumen de las notas sonoras, etc., se graban en el archivo midi.  El tel√©fono m√≥vil que reproduce dicho archivo contiene un sintetizador que interpreta los mensajes midi en este archivo en tiempo real y reproduce la melod√≠a.  En las primeras etapas, los tel√©fonos solo pod√≠an reproducir melod√≠as de un solo tono.  Con el tiempo, apareci√≥ la llamada polifon√≠a. <br><br>  En Internet, conoc√≠ art√≠culos sobre la implementaci√≥n de un sintetizador polif√≥nico en MK, que lee archivos midi.  En este caso, al menos, se utiliza una "tabla de ondas" preformada (una lista de formas de ondas de sonido) para cada instrumento musical almacenado en la memoria de MK.  Y en mi caso particular, nos centraremos en la implementaci√≥n de un modelo m√°s simple: un sintetizador de un solo tono (una sola voz). <br><br>  Para empezar, estudi√© cuidadosamente la estructura del archivo midi y llegu√© a la conclusi√≥n de que, adem√°s de la informaci√≥n necesaria sobre las notas, contiene informaci√≥n redundante adicional.  Por lo tanto, se decidi√≥ escribir un programa simple para convertir un archivo midi a su propio formato.  El programa, que trabaja con muchos archivos MIDI, no solo convierte formatos, sino que tambi√©n los organiza de cierta manera.  De antemano, decid√≠ organizar el almacenamiento de muchas melod√≠as en la memoria ROM (EEPROM 24XX512).  Para facilitar la visualizaci√≥n en el editor HEX, me asegur√© de que cada melod√≠a comience desde el principio del sector.  A diferencia de una tarjeta SD (por ejemplo), el concepto de un sector no es aplicable a la ROM utilizada, por lo que me expreso condicionalmente.  El tama√±o del sector es de 512 bytes.  Y el primer sector de ROM est√° reservado para las direcciones de los sectores de los comienzos de cada melod√≠a.  Se supone que la melod√≠a puede tomar varios sectores. <br><br>  Una descripci√≥n completa del formato de archivo midi, por supuesto, no vale la pena hacerlo aqu√≠.  Me referir√© solo a los puntos m√°s necesarios y necesarios.  Un archivo midi contiene 16 canales, que, por regla general, corresponden con mayor frecuencia a uno u otro instrumento musical.  En nuestro caso, no importa qu√© tipo de instrumento sea, y solo se necesita un canal.  El contenido de cada canal, junto con el encabezado, se redacta en un archivo midi de acuerdo con un principio que es muy similar a organizar el almacenamiento de transmisiones de video y audio en un contenedor AVI.  Escrib√≠ sobre esto √∫ltimo anteriormente en uno de mis art√≠culos.  El encabezado del archivo midi es un conjunto de algunos par√°metros.  Uno de esos par√°metros es la resoluci√≥n de tiempo.  Se expresa en el n√∫mero de "ticks" (una especie de p√≠xel) por trimestre (PPQN).  Un cuarto es un lapso de tiempo durante el cual se toca un cuarto de nota.  Dependiendo del tempo de la melod√≠a, la duraci√≥n del trimestre puede ser diferente.  Por lo tanto, la duraci√≥n de un "p√≠xel" (per√≠odo de muestreo) depende del tempo y PPQN.  Toda la informaci√≥n sobre la hora de un evento se determina con precisi√≥n en esta duraci√≥n. <br><br>  Adem√°s, el encabezado contiene el tipo de archivo MIDI (tipo 0 o tipo 1) y la cantidad de canales.  Sin entrar en detalles, trabajaremos con el tipo 1, el n√∫mero de canales 2. Un archivo midi con una melod√≠a de tono √∫nico, l√≥gicamente, contiene un canal.  Pero en el archivo midi "tipo 1" hay, adem√°s del principal, otro canal "no musical" en el que se graba informaci√≥n adicional que no contiene notas.  Estos son los llamados metadatos.  Tampoco hay necesidad de entrar en detalles.  La √∫nica informaci√≥n que necesitamos all√≠ es que hay informaci√≥n sobre el ritmo, y en un formato inusual: microsegundos por trimestre.  En el futuro, se mostrar√° c√≥mo usar esta informaci√≥n, junto con PPQN, para configurar el temporizador MK, que es responsable del tempo. <br><br>  En el bloque del canal principal con notas, solo nos interesa la informaci√≥n sobre los eventos de activaci√≥n y desactivaci√≥n de notas.  Un evento de habilitaci√≥n de nota tiene dos par√°metros: n√∫mero de nota y volumen.  En total, se proporcionan 128 notas y 128 niveles de volumen.  Solo nos interesa el primer par√°metro, porque no importa cu√°l sea el volumen de la nota: todas las notas al tocar la melod√≠a MK sonar√°n al mismo volumen.  Y, por supuesto, la melod√≠a no debe contener notas "sobregrabadas", es decir, en cualquier momento, no debe sonar m√°s de una nota al mismo tiempo.  El c√≥digo del evento de tomar (encender) las notas es 0x90.  La nota del c√≥digo de evento es 0x80.  Sin embargo, al menos el editor Cakewalk Pro Audio 9 no utiliza el evento con el c√≥digo 0x80 al exportar la composici√≥n a formato midi.  En cambio, el evento 0x90 tiene lugar en toda la parte musical, y la nota de que la nota est√° desactivada es su volumen cero.  Es decir, el evento "apagar la nota" es equivalente al evento "encender la nota con volumen cero".  Quiz√°s esto se hace por razones de econom√≠a.  De acuerdo con la especificaci√≥n, el c√≥digo de evento no puede reescribirse si este evento se repite.  Entre eventos, la informaci√≥n sobre el intervalo de tiempo se registra en un formato de longitud variable.  Estos son los valores enteros del n√∫mero de "ticks" mencionados anteriormente.  Muy a menudo, un byte es suficiente para registrar el intervalo de tiempo.  Si dos eventos siguen uno tras otro, entonces, entre ellos, el intervalo de tiempo es obviamente igual a cero.  Esto, por ejemplo, deshabilita la primera y la inclusi√≥n de la segunda nota que le sigue, si no hay pausa (espacio) entre ellas. <br><br>  Tratemos de escribir una secuencia de notas usando el programa "Cakewalk Pro Audio 9".  Hay muchos editores, pero me decid√≠ por el primero que apareci√≥. <br><br><img src="https://habrastorage.org/webt/x2/rs/ig/x2rsigockegfkqq_xux3wgiesly.png"><br><br>  Primero debe configurar los ajustes del proyecto.  En este editor puede establecer la resoluci√≥n en el tiempo (PPQN).  Elijo el valor m√≠nimo igual a 48. Un valor demasiado grande no tiene sentido, ya que debe trabajar con n√∫meros grandes que excedan 1 byte de tama√±o.  Pero el valor m√≠nimo de 48 es bastante satisfactorio.  En casi todas las melod√≠as, no se encuentran notas m√°s cortas que 1/32.  Y si el n√∫mero de "ticks" por trimestre es 48, entonces la nota o pausa 1/32 tendr√° una duraci√≥n de 48 / (32/4) = 6 "ticks".  Es decir, existe la posibilidad te√≥rica de dividir por completo 1/32 nota por 2, e incluso por 3. Dejamos los par√°metros restantes en la ventana de propiedades del proyecto por defecto. <br><br><img src="https://habrastorage.org/webt/q-/e8/1j/q-e81jrcz7-g-doa-oberdoezju.png"><br><br>  A continuaci√≥n, abra la propiedad de la primera pista y as√≠gnele un n√∫mero de canal igual a 1. A su gusto, seleccione un parche que corresponda a un instrumento musical cuando toque una melod√≠a en el editor.  El n√∫mero de parche, por supuesto, no afectar√° el resultado final. <br><br><img src="https://habrastorage.org/webt/y-/2o/xn/y-2oxnmqemoxj3hwtflnanivyyk.png"><br><br>  El tempo de la melod√≠a se establece en la cantidad de trimestres por minuto en la barra de herramientas del editor.  El valor de tempo predeterminado es de 100 bpm. <br><br>  El microcontrolador tiene un temporizador de 8 bits que, como ya se mencion√≥, se usar√° para controlar la duraci√≥n de las notas y pausas.  Se decidi√≥ que el intervalo de tiempo entre operaciones adyacentes (interrupciones) de dicho temporizador corresponder√≠a al intervalo de un "tic".  Dependiendo del tempo de la melod√≠a, el valor de este intervalo de tiempo ser√° diferente.  Decid√≠ usar interrupciones de temporizador de desbordamiento.  Y dependiendo del par√°metro de inicializaci√≥n del temporizador inicial, es posible ajustar este mismo intervalo de tiempo, que depende del tempo de la melod√≠a.  Ahora pasemos a los c√°lculos. <br><br>  Como regla, en la pr√°ctica, en promedio, el tempo de las canciones se encuentra en el rango del orden de 50 a 200. Ya se ha dicho que el tempo en el archivo midi se establece en microsegundos por un cuarto.  Para el tempo 50, este valor es 60,000,000 / 50 = 1,200,000, y para el tempo 250 ser√° 240,000. Dado que, seg√∫n el proyecto, un cuarto contiene 48 ticks, la longitud del tick para el tempo m√≠nimo ser√° 1,200,000 / 48 = 25,000 Œºs.  Y para el ritmo m√°ximo, si calcula de la misma manera, - 5000 Œºs.  Para MK con una frecuencia de cuarzo de 8 MHz y un divisor de temporizador preliminar m√°ximo de 1024, obtenemos lo siguiente.  Para el ritmo m√≠nimo, el temporizador debe calcularse 25000 / (1024/8) = 195 veces.  El resultado se redondea al valor entero m√°s cercano, el error de redondeo pr√°cticamente no afecta el resultado.  Para el ritmo m√°ximo - 5000 / (1024/8) = 39.  Aqu√≠, el error de redondeo no afecta a√∫n m√°s, ya que tambi√©n se obtiene un valor redondeado de 39 para los valores de tempo vecinos de 248 a 253. En consecuencia, el temporizador debe inicializarse con un valor inverso: para el tempo m√≠nimo - (256-195) = 61, y para el m√°ximo - (256 -39) = 217.  El ritmo m√≠nimo al que se proporcionar√° el temporizador en la configuraci√≥n MK actual es de 39 bpm.  Con este valor, el temporizador debe contarse 250 veces.  Y con un valor de 38, ya 257, que va m√°s all√° de los l√≠mites del temporizador.  Decid√≠ tomar el valor de 40 lpm para el ritmo m√≠nimo y 240 para el m√°ximo. <br><br>  Para calcular la cantidad de ticks, se utilizar√° un temporizador virtual basado en lo anterior.  Es el n√∫mero de tics que establece la duraci√≥n de una nota o pausa, como ya se mencion√≥ anteriormente. <br><br>  Para implementar la reproducci√≥n de notas, se utiliza un segundo temporizador de 16 bits.  Seg√∫n la especificaci√≥n MIDI, se proporcionan un total de 128 notas.  Pero en la pr√°ctica se usan mucho menos.  Adem√°s, las notas de las octavas m√°s bajas (con frecuencias de aproximadamente 50 Hz) y m√°s altas (con frecuencias de aproximadamente 8 kHz) no ser√°n reproducidas armoniosamente por el microcontrolador.  Pero por todo esto, un temporizador de 16 bits con un divisor fijo cubre casi todo el rango de notas proporcionadas por midi, es decir, sin los primeros 35.  Pero eleg√≠ al principio la nota con el n√∫mero 37 (su c√≥digo es 36, ya que la codificaci√≥n proviene de cero).  Esto se hace por conveniencia, ya que este n√∫mero corresponde a la nota "C", como la primera nota en una escala tradicional.  Le corresponde con una frecuencia de 65.4 Hz, y el semiciclo es - 1 / 65.4 / 2 = 0.00764 seg.  Este per√≠odo de tiempo a una frecuencia MK de 8 MHz y un divisor 1 (es decir, sin un divisor) contar√° el temporizador aproximadamente en su totalidad por 0.00764 / (1/8000000) = 61156 veces.  Para la nota 35, si cuenta, este valor ser√° 68645, que est√° m√°s all√° del rango del temporizador de 16 bits.  Pero, incluso si era necesario tocar notas por debajo del 36, puede ingresar el primer divisor de temporizador disponible, igual a 8. Pero no hay necesidad pr√°ctica de esto, as√≠ como tampoco hay ninguna para tocar las notas m√°s altas.  Sin embargo, para la nota 128 m√°s alta, nota "G" con una frecuencia de 12,543.85 Hz, el valor del temporizador es, si se cuenta de manera similar, 319. Los detalles de todos los c√°lculos anteriores est√°n determinados por la configuraci√≥n espec√≠fica del modo de temporizador, que se mostrar√° m√°s adelante. <br><br>  Ahora tengo una pregunta no menos importante: ¬øc√≥mo obtener la relaci√≥n entre el n√∫mero de nota y el c√≥digo del temporizador?  Existe una f√≥rmula bien conocida para calcular la frecuencia de una nota por su n√∫mero.  Y el c√≥digo del temporizador para una frecuencia conocida se calcula f√°cilmente, como se muestra arriba en los ejemplos.  Pero la ra√≠z del grado 12 aparece en la f√≥rmula para la dependencia de la frecuencia de la nota, y en general, no quisiera cargar el controlador con tales procedimientos computacionales.  Por otro lado, crear una matriz de c√≥digos de temporizador para todas las notas tampoco es racional.  Y decid√≠ hacer lo siguiente, eligiendo un t√©rmino medio.  Es suficiente crear una matriz de c√≥digos de temporizador para las primeras 12 notas, que son una octava.  Y las notas de las siguientes octavas deben obtenerse multiplicando secuencialmente las frecuencias de las notas de la primera octava por 2. O, lo mismo, dividiendo secuencialmente los valores de los c√≥digos del temporizador por 2. Otra conveniencia es que el n√∫mero de octava, por coincidencia, es un argumento en la operaci√≥n de desplazamiento bit a la derecha ( ¬ª), Que se utilizar√° como la operaci√≥n de dividir por potencias de dos.  Eleg√≠ este operador no por casualidad, ya que su argumento refleja el exponente de la potencia del divisor (el n√∫mero de divisiones por 2).  Y este es el n√∫mero de octava.  Para mi conjunto de notas, est√° involucrado un total de 8 octavas (la √∫ltima octava est√° incompleta).  Una nota en un archivo midi est√° codificada con un byte, m√°s precisamente, 7 bits.  Para tocar notas en MK, de acuerdo con la idea anterior, primero debe calcular el n√∫mero de octava y el n√∫mero de nota en la octava usando el c√≥digo de nota.  Esta operaci√≥n se realiza en la etapa de convertir el archivo midi a un formato simplificado.  Se pueden codificar ocho octavas en tres bits, y 12 notas en una octava se pueden codificar en cuatro.  En total, resulta que la nota est√° codificada en los mismos siete bits que en el archivo midi, pero solo en una representaci√≥n diferente conveniente para MK.  Debido al hecho de que 16 bits pueden codificarse con 4 bits, y las notas en una octava de 12, hay bytes no utilizados. <br><br>  El √∫ltimo octavo bit se puede usar como marcador para habilitar o deshabilitar las notas.  En el caso de MK, debido a la unanimidad de la melod√≠a, la informaci√≥n sobre la nota silenciada ser√° redundante.  Con un cambio directo de nota en la melod√≠a, no hay un "encendido-encendido-encendido", sino un "cambio" de la nota.  Y en el caso de una pausa, "el silencio est√° activado", para lo cual puede seleccionar un byte especial del conjunto de bytes no utilizados, y no utilizar la informaci√≥n sobre c√≥mo desactivar la nota.  Tal idea es buena porque ahorra el tama√±o de la melod√≠a resultante despu√©s de la conversi√≥n, pero generalmente complica el modelo.  No segu√≠ esta idea, ya que hay mucha memoria ya. <br><br>  La informaci√≥n sobre las notas de la melod√≠a en el archivo midi se almacena en el bloque del canal correspondiente en la vista "intervalo-evento-intervalo-evento ...".  En el formato convertido, se aplica exactamente el mismo principio.  Para grabar un evento (activar o desactivar una nota), como se mencion√≥ anteriormente, se utiliza un byte.  El primer bit (el bit m√°s significativo 7) codifica el tipo de evento.  El valor "1" es la nota activada, y el valor "0" es la nota desactivada.  Los siguientes tres bits codifican el n√∫mero de octava, y los cuatro bits m√°s bajos codifican el n√∫mero de nota en la octava.  Un byte tambi√©n se usa para registrar el intervalo de tiempo.  En el formato midi original, se utiliza un formato de longitud variable para esto.  Su peque√±o inconveniente es que solo 7 bits codifican el intervalo de tiempo (el n√∫mero de "ticks"), y el octavo bit es un signo de continuaci√≥n.  Es decir, con un byte, de hecho, puede codificar un intervalo de hasta 128 tics.  Pero dado que los intervalos de tiempo entre eventos en melod√≠as reales y simples a veces exceden 128, pero casi nunca exceden 256, abandon√© el formato de longitud variable y lo manej√© con un byte.  Codifica un intervalo de tiempo de hasta 256 ticks.  Como el proyecto usa 48 ticks por trimestre, o 48 * 4 = 192 ticks por ciclo, se puede usar un byte para codificar un intervalo de 256/192 = 1 duraci√≥n. (3) (un entero y un tercio) ciclos, que Bastante <br><br>  En el formato nativo al que se convierte el archivo midi, tambi√©n apliqu√© un encabezado peque√±o, de 16 bytes de tama√±o.  Los primeros 14 bytes contienen el nombre de la melod√≠a.  Naturalmente, el nombre no debe exceder los 14 caracteres.  Luego viene un espacio cero.  El siguiente √∫ltimo byte refleja el tempo de la melod√≠a en una vista conveniente para MK.  Este valor se calcula en la etapa de conversi√≥n y sirve para inicializar el temporizador MK, que es responsable del ritmo.  C√≥mo se calcula se discute en algunos p√°rrafos anteriores. <br><br>  A partir del byte 17, siguen los contenidos de la melod√≠a.  Cada byte impar corresponde a un intervalo de tiempo, y cada byte par corresponde a un evento (nota).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primer byte ser√° cero si la melod√≠a comienza con una nota, desde el comienzo del archivo midi, sin una pausa preliminar. Una se√±al del final de la melod√≠a es una etiqueta de dos bytes 0xFF. La tarea implica la reproducci√≥n c√≠clica de una melod√≠a por un microcontrolador. Para que la melod√≠a en el bucle suene armoniosa desde el punto de vista del ritmo, debe estar colocada correctamente. Para hacer esto, si es necesario, despu√©s de una √∫ltima nota, debe pausar una cierta longitud, generalmente hasta que se complete la √∫ltima medida. Y para esto necesitas desviar el evento correspondiente. Us√© el byte 0x0F, que no se usa para codificar notas. Corresponde a deshabilitar la nota 16 en la primera octava, lo cual es absurdo, ya que solo hay 12 notas en la octava. Mencionamos anteriormente sobre los bytes no utilizados. Por lo tanto, este byte codifica una "nota silenciosa",la parte alta de la cual tambi√©n puede servir como un signo de encendido o apagado, a pesar de la redundancia de informaci√≥n en este caso. Para configurar esta nota en el editor midi, tom√© la primera o segunda nota (cualquiera de ellas). Perm√≠tame recordarle que las primeras 36 notas no se usan en el modelo. Por lo tanto, la primera (o segunda) nota se usa seg√∫n sea necesario para completar correctamente la melod√≠a, de modo que el ritmo no se rompa cuando se toca en un bucle.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuando trabajando en el editor de "Cakewalk Pro Audio 9", compondremos una melod√≠a arbitraria. Las siguientes figuras muestran las notas de la melod√≠a que reescrib√≠ de una de las im√°genes en Internet. Las im√°genes de las notas se presentan en dos estilos: en el estilo de "Piano roll" y en el estilo cl√°sico. El primero es muy conveniente para escribir y editar melod√≠as usando un mouse de computadora. Eso es lo que yo uso. </font></font><br><br><img src="https://habrastorage.org/webt/lr/-r/hy/lr-rhyphwp5xckftmq8fbwhlchc.png"><br><br><img src="https://habrastorage.org/webt/ot/qf/d7/otqfd7db-6wj0o9dscmg60tp5d8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver en la figura, al final se aplica la nota m√°s baja (primera) para el signo de silencio en el intervalo de tiempo correcto para organizar correctamente el patr√≥n c√≠clico. Y al comienzo de la melod√≠a, en vista de la presencia de un toque, hay un cuarto de sangr√≠a antes de la primera nota. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El editor proporciona un modo para mostrar eventos en forma de tabla.</font></font><br><br><img src="https://habrastorage.org/webt/vy/gu/n1/vygun1nauiacc6-zjbq66whb7qg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver en la figura, no hay nada superfluo en la lista de eventos, excepto tomar notas, como a veces sucede con manipulaciones innecesarias en un proyecto musical. Sin embargo, si por alguna raz√≥n se incluyen en la lista eventos innecesarios que no est√°n relacionados con las notas, se pueden eliminar presionando la tecla Supr. Aunque, en la etapa de conversi√≥n, todos los eventos innecesarios se ignoran y el tiempo delta "se acumula". Por cierto, agregu√© esta funci√≥n al programa en la etapa de depuraci√≥n. Como puede suponer, la tabla refleja el tiempo y la duraci√≥n de cada nota junto con otras propiedades que no necesitamos. Es decir, con una l√≠nea en la tabla, dos eventos midi se expresan a la vez: activar y desactivar notas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guarde la melod√≠a en el formato "midi 1", como se muestra en la figura.</font></font><br><br><img src="https://habrastorage.org/webt/l6/gx/uf/l6gxufg_2kmfge81godpmmhieki.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abra el archivo guardado en el editor HEX. Cabe se√±alar de inmediato que, a diferencia de los mismos archivos avi (como escrib√≠ anteriormente), los bytes de valores num√©ricos en el archivo midi se presentan no en orden inverso, sino por antig√ºedad (big endian).</font></font><br><br><img src="https://habrastorage.org/webt/wj/oi/cn/wjoicnlzwx4ixajswxz3m3_jj5i.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la figura, marqu√© con marcadores solo los bytes deseados. Primero, un marco rojo en negrita describe tres grupos de dos bytes en cada uno. Este es, respectivamente, el tipo de formato MIDI (1), el n√∫mero de canales (2) y el n√∫mero de ticks por trimestre (48). Son estos valores los que estas tres constantes deben tener para el trabajo posterior del programa de transformaci√≥n. Los arcos morados marcan el comienzo de cada uno de los dos canales. En el primer canal, 6 bytes est√°n marcados con un marco gris, dentro del cual se resaltan tres bytes con un marco azul. Estos 6 bytes se refieren a un metaevento (marcador de marcador 0xFF) con un c√≥digo de 0x51 y una longitud de contenido de 0x03 bytes. Tres bytes m√°s: el contenido del evento. Este evento establece el tempo de la melod√≠a con solo estos tres bytes en un marco azul. El √∫ltimo byte bajo se puede descartar de forma segura, porque la s√∫per precisi√≥n no es importante. No dar√© una descripci√≥n detallada y exhaustiva de todos los bytes en el archivo.En la segunda pista, en la pista con notas, los valores de los intervalos de tiempo se encierran en un c√≠rculo azul. Ellos, por cierto, en este ejemplo particular, no excedieron un byte, excepto por el √∫nico caso con la pen√∫ltima nota. Es la pen√∫ltima nota de la melod√≠a (contando la pseudo nota adicional del final) que dura tres cuartos de una medida, que es 48 * 3 = 144 tics y excede 128. Y para eso debes usar dos bytes, de acuerdo con el formato de longitud variable. Y para representar el intervalo de tiempo en el formato convertido, el valor 144 se codifica f√°cilmente con un byte. Rode√© este caso especial en un marco azul doble. Las notas est√°n encerradas en un marco verde, o m√°s bien, sus c√≥digos. El volumen de cada nota se encierra en un c√≠rculo en un marco gris. Como ya se mencion√≥, un volumen cero es un signo de silencio (lanzamiento) de la nota, y en toda la composici√≥n hay un evento:Encendiendo las notas. El c√≥digo para este evento, 0x90, est√° marcado en amarillo. No describ√≠ todas las notas hasta el final de la melod√≠a. La √∫nica excepci√≥n es el doble marco azul para un √∫nico intervalo de tiempo que excede el umbral de 128 tics.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuevamente, como se mencion√≥ anteriormente, el programa para convertir un archivo midi a su propio formato para MK en realidad funciona con un grupo de varios archivos midi y crea un archivo de imagen para EEPROM en la salida. Considere un fragmento de este archivo que se relaciona con el contenido de la melod√≠a convertida del ejemplo anterior. Lo abr√≠ en otro editor HEX para mostrar la imagen por sectores y prestarle atenci√≥n. Cada nueva melod√≠a comienza con un nuevo sector.</font></font><br><br><img src="https://habrastorage.org/webt/9p/e5/h1/9pe5h1qaetdg-kjk-abaxvlk6am.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El √∫ltimo byte de la primera l√≠nea (los primeros 16 bytes), encerrado en un cuadro rojo, establece el tempo de la melod√≠a. Seg√∫n los c√°lculos, el valor 0xC1 (193) cae en el tempo 154, 155 y 156. Justo en el proyecto configur√© el tempo de la melod√≠a en 155 bpm, que se vio en una de las capturas de pantalla anteriores. Los primeros bytes (hasta el 14) encerrados en un marco azul determinan el nombre de la composici√≥n. En este ejemplo, "Cl√°sico". Para MK, esta informaci√≥n es innecesaria, solo se necesita para orientarse en el editor HEX. Sin embargo, si realiza un proyecto m√°s complejo en el MK usando la pantalla, puede usar esta informaci√≥n mostrando el nombre de la melod√≠a reproducida.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La segunda l√≠nea (desde el byte 17) comienza el contenido de la melod√≠a. Al igual que con el archivo midi original, no pint√© todas las notas, sino que pint√© solo una parte. Los bytes impares resaltados en azul son intervalos de tiempo. Incluso los bytes marcados con un marco verde son notas junto con signos de su activaci√≥n / desactivaci√≥n. Por ejemplo, los primeros dos bytes verdes, 0xB4 y 0x34, se refieren a la misma nota con el c√≥digo 0x34, y los bytes difieren en un solo bit de orden superior. En el byte 0xB4 (0b10110100), el bit alto es uno, lo cual es un signo de activar una nota, y en el byte 0x34 (0b00110100), el bit alto es cero, lo cual es un signo de desactivar una nota. El byte 0x34 codific√≥ una nota con los siguientes par√°metros: c√≥digo de octava 0b011, y el c√≥digo de nota en una octava - 0b0100. O, en forma decimal, 3 y 4, respectivamente. Si no cuentas desde cero,Resulta que la primera nota en la melod√≠a pertenece a la cuarta octava y es la quinta en ella. La numeraci√≥n de octavas aqu√≠ se elige arbitrariamente sin tener en cuenta la numeraci√≥n est√°ndar. La nota acordada, seg√∫n mi tabla auxiliar de c√°lculo Excel, es la nota con el c√≥digo 76 (0x4C) para el formato midi, es decir, la nota E6 (nota "e" de la sexta octava media). As√≠ es: la composici√≥n comienza con esta nota.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debe notarse un caso especial en la secuencia musical, cuando la misma nota se repite sin pausa. En nuestro ejemplo, todas las notas adyacentes que est√°n libres de pausa son diferentes. Pero hay melod√≠as donde la nota se repite sin pausa. Es decir, el intervalo de tiempo entre apagar uno y encender la siguiente nota exacta es cero. En vista de la peculiaridad de una s√≠ntesis compleja de m√∫sica, dicha secuencia sonar√° familiar en cualquier sintetizador. Pero en el caso de MK, sonar√° tan cohesivo que ser√° dif√≠cil escuchar la diferencia entre dos notas id√©nticas. En la pr√°ctica, por supuesto, no habr√° una fusi√≥n clara debido a los c√°lculos intermedios que ocurren en el MC, pero a√∫n as√≠, es muy probable que este intervalo de tiempo sea mucho menor que la duraci√≥n de incluso un tic. Para tales casos especiales, el programa se encuentra en la fase de conversi√≥n,tropezar con tal combinaci√≥n, introduce una pausa entre notas de 1 tick de longitud y reduce la duraci√≥n de una nota a la izquierda de la nota en el mismo intervalo de tiempo. Un "espacio" m√≠nimo de 1 tic es suficiente, como lo ha demostrado la pr√°ctica.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En un marco azul doble, marqu√© con un c√≠rculo ese valor del intervalo de tiempo (0x90), que excede 128, y para el cual tuve que gastar dos bytes en el archivo midi, de acuerdo con el formato de longitud variable. Los c√≠rculos verdes son bytes encerrados dentro y fuera de la misma pseudo nota para alinear la composici√≥n. El programa MK, al ver estos bytes, los interpretar√° como activando el silencio. Finalmente, dos bytes 0xFF encerrados en un marco azul en negrita marcan el final de la melod√≠a. Los valores de todos los siguientes bytes dentro del sector de memoria actual pueden ser cualquiera, se ignoran.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere el primer sector del archivo de imagen EEPROM de salida. Como ya escrib√≠, sirve como una lista de direcciones de sectores del comienzo de las melod√≠as. El programa escane√≥ con √©xito 8 melod√≠as sin errores (al momento de escribir, hab√≠a grabado 8 melod√≠as). El valor de la cantidad de melod√≠as se registra en el √∫ltimo byte 512 del sector. Y desde el comienzo del sector, se escriben las direcciones. Para la primera melod√≠a, la direcci√≥n es 0x01, que corresponde al segundo sector (el primero, si cuenta desde cero). Las melod√≠as tercera y cuarta (dos de ocho) resultaron ser largas y no encajaban en un sector. Por lo tanto, se observan lagunas en la secuencia de direcciones. Si cuenta, 64kB de memoria, puede grabar no m√°s de 127 melod√≠as, por lo que un sector para el direccionamiento es suficiente.</font></font><br><br><img src="https://habrastorage.org/webt/t7/fm/g-/t7fmg-97qcqphlojly3l8xcpnru.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas las estimaciones preliminares y c√°lculos reflejados en el art√≠culo, lo realic√© en Excel. </font><font style="vertical-align: inherit;">Las capturas de pantalla a continuaci√≥n muestran capturas de pantalla de las tablas resultantes (en modo de doble ventana). </font></font><br><br><img src="https://habrastorage.org/webt/31/cb/my/31cbmycwzmmfr_noks7sifxpaps.png"><br><br><img src="https://habrastorage.org/webt/jn/tm/1f/jntm1fp2sga5erx_xmtqq3bbhcy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A qui√©n le importa, debajo del spoiler se encuentra el texto de un programa en C que convierte archivos midi en un archivo para el microcontrolador. </font><font style="vertical-align: inherit;">Del texto, elimin√© las l√≠neas adicionales que se usaron para la depuraci√≥n. </font><font style="vertical-align: inherit;">El programa, hasta ahora, est√° funcionando, no pretende ser legible y alfabetizado al escribir c√≥digo.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Archivo principal 1.cpp</font></font></b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;windows.h&gt; #include &lt;string.h&gt; #define SPACE 1 HANDLE openInputFile(const char * filename) { return CreateFile ( filename, // Open Two.txt. GENERIC_READ, // Open for writing 0, // Do not share NULL, // No security OPEN_ALWAYS, // Open or create FILE_ATTRIBUTE_NORMAL, // Normal file NULL); // No template file } HANDLE openOutputFile(const char * filename) { return CreateFile ( filename, // Open Two.txt. GENERIC_WRITE, // Open for writing 0, // Do not share NULL, // No security OPEN_ALWAYS, // Open or create FILE_ATTRIBUTE_NORMAL, // Normal file NULL); // No template file } void filepos(HANDLE f, unsigned int p){ LONG LPos; LPos = p; SetFilePointer (f, LPos, NULL, FILE_BEGIN); //FILE_CURRENT //https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-setfilepointer } DWORD wr; DWORD ww; unsigned long int read32(HANDLE f){ unsigned char b3,b2,b1,b0; ReadFile(f, &amp;b3, 1, &amp;wr, NULL); ReadFile(f, &amp;b2, 1, &amp;wr, NULL); ReadFile(f, &amp;b1, 1, &amp;wr, NULL); ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b3&lt;&lt;24|b2&lt;&lt;16|b1&lt;&lt;8|b0; } unsigned long int read24(HANDLE f){ unsigned char b2,b1,b0; ReadFile(f, &amp;b2, 1, &amp;wr, NULL); ReadFile(f, &amp;b1, 1, &amp;wr, NULL); ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b2&lt;&lt;16|b1&lt;&lt;8|b0; } unsigned int read16(HANDLE f){ unsigned char b1,b0; ReadFile(f, &amp;b1, 1, &amp;wr, NULL); ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b1&lt;&lt;8|b0; } unsigned char read8(HANDLE f){ unsigned char b0; ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b0; } void message(unsigned char e){ printf("Error %d: ",e); switch(e){ case 1: // -   -; printf("In track0 event is not FF\n"); break; case 2: // -  127 printf("Len of FF &gt;127\n"); break; case 3: //  ; printf("Midi is incorrect\n"); break; case 4: //   ; printf("Delta&gt;255\n"); break; case 5: //    RPN  NRPN; printf("RPN or NRPN is detected\n"); break; case 6: //   ; printf("Note in 1...35 range\n"); break; case 7: //    ; printf("Long of name of midi file &gt;18\n"); break; } system("PAUSE"); } int main(){ HANDLE in; HANDLE out; unsigned int i,j; unsigned int inpos; unsigned int outpos=0; unsigned char byte; // ; unsigned char byte1; //  1  ; unsigned char byte2; //  2  ; unsigned char status; //- ( ); unsigned char sz0; // -; unsigned long int bsz0; //    -; unsigned short int format, ntrks, ppqn; //  ; unsigned long int bsz1; //    ; unsigned long int bpm; // ( .  ); unsigned long int time=0; //    ( ); unsigned char scale; //    ,  ; unsigned char oct; //    ; unsigned char nt; // ; unsigned char outnote; //      ; unsigned char prnote=0; //  ; unsigned char tdt; // ()   ; unsigned int dt; //    ( ); unsigned int outdelta=0; //    ( ); unsigned char prdelta=0; //  ; char fullname[30]; //    ; char name[16]; // ; WIN32_FIND_DATA fld; //   mid; HANDLE hf; unsigned short int csz; //  ; unsigned char nfile=0; // ; unsigned char adr[128]; //    ; out=openOutputFile("IMAGE.out"); outpos=512; //   ; filepos(out,outpos); hf=FindFirstFile(".\\midi\\*.mid",&amp;fld); do{ printf("\n***** %s *****\n",fld.cFileName); if(strlen(fld.cFileName)&gt;18){ //   ; message(7); } sprintf(name,"%s",fld.cFileName); name[strlen(fld.cFileName)-4]=0; // ; sprintf(fullname,".\\midi\\%s",fld.cFileName); //    ; WriteFile(out, name, strlen(name), &amp;ww, NULL); //    ; in=openInputFile(fullname); //    ; #include "process.cpp" //     ; outpos+=((csz/512)+1)*512; //    ; adr[nfile]=(outpos/512)-((csz/512)+1); //  ()   ; filepos(out,outpos); CloseHandle(in); nfile+=1; }while(FindNextFile(hf,&amp;fld)); //   ,    ; FindClose(hf); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); outpos=0; //   ; filepos(out,outpos); WriteFile(out, adr, nfile, &amp;ww, NULL); outpos=511; //  ; filepos(out,outpos); WriteFile(out, &amp;nfile, 1, &amp;ww, NULL); CloseHandle(out); system("PAUSE"); return 0; }</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Archivo adjunto Process.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs">time=<span class="hljs-number"><span class="hljs-number">0</span></span>; inpos=<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ; filepos(in,inpos); format=read16(in); ntrks=read16(in); ppqn=read16(in); if(format!=1 || ntrks!=2 || ppqn!=48){ message(3); } inpos+=10; filepos(in,inpos); //    -; bsz0=read32(in); inpos+=4; while(inpos&lt;22+bsz0){ //      ; tdt=read8(in); inpos+=1; //   ; dt=(unsigned int)(tdt&amp;0x7F); while(tdt&amp;0x80){ tdt=read8(in); inpos+=1; dt=(dt&lt;&lt;7)|(tdt&amp;0x7F); } byte=read8(in); inpos+=1; if(byte==0xFF){ //  ,  -    -; byte=read8(in); //  -; sz0=read8(in); //  , ,     127 ( ); if(sz0&amp;0x80){ message(2); } inpos+=2; switch(byte){ case 0x51: //   "Set Tempo"; bpm=read24(in); scale=256-(bpm/(ppqn*128)); printf("scale=%d\n",scale); filepos(out,outpos+15); // ; WriteFile(out, &amp;scale, 1, &amp;ww, NULL); csz=16; break; default: break; } inpos+=sz0; filepos(in,inpos); // ,     0x51; }else{ message(1); } } //    ; outdelta=0; inpos+=4; filepos(in,inpos); bsz1=read32(in); inpos+=4; while(inpos&lt;30+bsz0+bsz1){ tdt=read8(in); inpos+=1; //   ; dt=(unsigned int)(tdt&amp;0x7F); while(tdt&amp;0x80){ tdt=read8(in); inpos+=1; dt=(dt&lt;&lt;7)|(tdt&amp;0x7F); } outdelta+=dt; //  ; // ,      , ; time+=dt; //  ; byte=read8(in); //    ,  ; inpos+=1; if(byte&amp;0x80){ //  ; status=byte; // ; if(byte==0xFF){ //   -; byte=read8(in); //    ,    ; sz0=read8(in); inpos+=(2+sz0); filepos(in,inpos); }else{ //    ; byte1=read8(in); inpos+=1; } }else{ //    ,        ; byte1=byte; } switch(status&amp;0xF0){ // ,      ; case 0xF0: //   ,  -; break; case 0x80: // ; byte2=read8(in); //     ( ); inpos+=1; //     ,    ; if(byte1&gt;1&amp;&amp;byte1&lt;36){ //         ; message(6); } if(byte1&gt;1){ // ; oct=((byte1-36)/12); //  ; nt=(byte1-36)%12; //    ; }else{ //   ; oct=0; nt=15; } outnote=(oct&lt;&lt;4)|nt; //  ; prnote=outnote; prdelta=outdelta; if(outdelta&gt;255){ //     255 (  ); message(4); } WriteFile(out, &amp;outdelta, 1, &amp;ww, NULL); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); csz+=2; outdelta=0; //  ; break; case 0x90: //   ; byte2=read8(in); //    ( ); inpos+=1; //     ,    ; if(byte1&gt;1&amp;&amp;byte1&lt;36){ //         ; message(6); } if(byte1&gt;1){ // ; oct=((byte1-36)/12); //  ; nt=(byte1-36)%12; //    ; }else{ //   ; oct=0; nt=15; } if(byte2){ //  ,   ; outnote=0x80|(oct&lt;&lt;4)|nt; //  = 1; //   ; if(!outdelta &amp;&amp; (outnote&amp;0x7F)==prnote){ //     ; prdelta-=SPACE; // -; filepos(out,outpos+csz-2); //    ; WriteFile(out, &amp;prdelta, 1, &amp;ww, NULL); // ; filepos(out,outpos+csz); outdelta=SPACE; //  -  ; } }else{ //  ,    ; outnote=(oct&lt;&lt;4)|nt; prnote=outnote; //  ; prdelta=outdelta; //  -; } if(outdelta&gt;255){ //   -    ; message(4); } WriteFile(out, &amp;outdelta, 1, &amp;ww, NULL); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); csz+=2; outdelta=0; // -   ; break; //   () ; case 0xA0: // ; byte2=read8(in); inpos+=1; break; case 0xB0: //   ; if(byte1&gt;=98&amp;&amp;byte1&gt;=101){ //     NRPN  RPN; message(5); //  ; } byte2=read8(in); inpos+=1; break; case 0xC0: //  (.  ); // , ,    ; break; case 0xD0: //; break; case 0xE0: // ; byte2=read8(in); inpos+=1; break; default: //  (   ); break; } } //     0xFFFF,    ; outdelta=255; outnote=255; WriteFile(out, &amp;outdelta, 1, &amp;ww, NULL); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); csz+=2; //   ,     ; printf("Length: %i (%i:%02i)\n",time,time/192,time%192);</span></span></code> </pre><br></div></div><br>  La parte b√°sica del programa para MK, de hecho, es muy simple.  Considere una de las opciones para su implementaci√≥n, m√°s precisamente, su parte principal. <br><br>  El temporizador 1, utilizado para generar el sonido de las notas, se configura de la siguiente manera.  Para habilitar y deshabilitar las notas, se utilizan las siguientes sustituciones, respectivamente. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENT1 TCCR1B=0x09;TCCR1A=0x40 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIST1 TCCR1B=0x00;TCCR1A=0x00;PORTB.1=0</span></span></code> </pre><br>  Antes de iniciar el temporizador, debe asignar al registro OCR1A un valor de 16 bits que corresponder√° a la frecuencia que se est√° reproduciendo.  Esto se mostrar√° m√°s adelante.  Cuando se enciende el temporizador, al registro TCCR1B se le asigna el modo de generaci√≥n de forma de onda con un divisor de temporizador de 1, y el registro TCCR1A se establece en Toggle OC1A en Comparar coincidencia.  En este caso, la se√±al se elimina de la salida especialmente designada de MK "OC1A".  En el ATmega8 en el paquete SMD, este es el pin 13, que es lo mismo que PORTB.1.  Cuando se apaga el temporizador, ambos registros se reinician y la salida de PORTB.1 se fuerza a cero.  Esto es necesario para evitar, durante el silencio, la salida de un voltaje constante, que ser√≠a indeseable para la entrada del VLF.  Aunque, puede poner un condensador en el circuito, pero tambi√©n puede desactivar la salida mediante programaci√≥n.  Puede producirse un voltaje constante en esta salida si la nota se apaga en el momento de la fase correspondiente de la se√±al, y esto es en el 50% de los casos. <br><br>  Cree una matriz de valores de temporizador para 12 notas de la primera octava.  Estos valores se calcularon por adelantado. <br><br><pre> <code class="cpp hljs">freq[]={<span class="hljs-number"><span class="hljs-number">61156</span></span>,<span class="hljs-number"><span class="hljs-number">57724</span></span>,<span class="hljs-number"><span class="hljs-number">54484</span></span>,<span class="hljs-number"><span class="hljs-number">51426</span></span>,<span class="hljs-number"><span class="hljs-number">48540</span></span>,<span class="hljs-number"><span class="hljs-number">45815</span></span>,<span class="hljs-number"><span class="hljs-number">43244</span></span>,<span class="hljs-number"><span class="hljs-number">40817</span></span>,<span class="hljs-number"><span class="hljs-number">38526</span></span>,<span class="hljs-number"><span class="hljs-number">36364</span></span>,<span class="hljs-number"><span class="hljs-number">34323</span></span>,<span class="hljs-number"><span class="hljs-number">32396</span></span>};</code> </pre><br>  Las notas de otras octavas, como dije, se obtendr√°n dividiendo por grados dos. <br><br>  La configuraci√≥n del temporizador 0 es a√∫n m√°s simple.  Funciona constantemente, con una interrupci√≥n por desbordamiento, cada vez que se inicializa de nuevo con el valor que corresponde al tempo de la melod√≠a.  El divisor del temporizador es 5: TCCR0 = 0x05.  Basado en este temporizador, se crea un temporizador virtual que cuenta los tics (veces) en la melod√≠a.  El procesamiento de la respuesta de este temporizador se coloca en el ciclo principal del programa. <br><br>  La funci√≥n de interrupci√≥n del temporizador 0 es la siguiente. <br><br><pre> <code class="cpp hljs">interrupt [TIM0_OVF] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer0_ovf_isr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ent01){ vt01+=<span class="hljs-number"><span class="hljs-number">1</span></span>; } TCNT0=top0; }</code> </pre><br>  Aqu√≠ la variable ent01 es responsable de activar el temporizador virtual.  Mediante esta variable, se puede activar o desactivar si es necesario.  La variable vt01 es la variable primaria contable del temporizador virtual.  La l√≠nea TCNT0 = top0 indica la inicializaci√≥n del temporizador 0 al valor deseado top0, que se lee del t√≠tulo de la melod√≠a antes de reproducirla. <br><br>  El n√∫mero de la melod√≠a a tocar corresponde a la variable alm.  Tambi√©n sirve como la bandera del comienzo de la reproducci√≥n.  Ella necesita asignar un n√∫mero de melod√≠a en una de las formas, dependiendo de la tarea.  Despu√©s de eso, el pr√≥ximo bloque del ciclo principal se activar√°. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(alm){ <span class="hljs-comment"><span class="hljs-comment">//     ; adr=eepr(alm-1)&lt;&lt;9; //     (&lt;&lt;9    512); adr+=15; //   ,      ; top0=eepr(adr); //  ; adr+=1; //     ; adr0=adr; //      (  ); top01=eepr(adr); //      " "  ; adr+=1; //   ; note=eepr(adr); // ; adr+=1; //    -; vt01=0; //    ; ent01=1; //  ; TCNT0=0; //  ; alm=0; //        ,   ; }</span></span></code> </pre><br>  El cambio adicional de nota a nota se lleva a cabo en la unidad de procesamiento del temporizador virtual, que tambi√©n se coloca en el bucle principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(vt01&gt;=top01){ <span class="hljs-comment"><span class="hljs-comment">//   ,    ; vt01=0; //  ; if(note&amp;0x80){ //     ""; nt=note&amp;15; //    ; oct=(note&amp;0x7F)&gt;&gt;4; //  ; if(nt!=15){ //       15,   ; OCR1A=freq[nt]&gt;&gt;oct; //     ; //         ; ENT1; // ; }else{ //  " "   ; DIST1; // ; } }else{ //     ""; DIST1; // ; } top01=eepr(adr); //      " "; adr+=1; //   ; note=eepr(adr); //   ; adr+=1; // ; if(note==255 &amp;&amp; top01==255){ //      ; top01=eepr(adr0); //   ,   ; note=eepr(adr0+1); //   ; adr=adr0+2; //   ; } }</span></span></code> </pre><br>  De los comentarios en el texto del programa, todo deber√≠a ser bastante claro y comprensible. <br><br>  Para detener la melod√≠a, use la siguiente inserci√≥n del bucle principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(stop){ <span class="hljs-comment"><span class="hljs-comment">//  ; DIST1; //  ; ent01=0; //  ; vt01=0; //  ; }</span></span></code> </pre><br>  Hay un peque√±o comentario sobre la implementaci√≥n de la reproducci√≥n de la melod√≠a.  Antes de que cada nueva nota comience a sonar, el microcontrolador pasa una peque√±a cantidad de tiempo convirtiendo el byte de lectura de la nota en un valor de temporizador.  Esta vez, como result√≥ en la pr√°ctica, es relativamente peque√±o y no afecta la calidad de la reproducci√≥n.  Pero ten√≠a dudas de que esta operaci√≥n seguir√≠a siendo invisible.  En este caso, aparecer√≠an pausas adicionales antes de cada nota, y el ritmo de la melod√≠a se romper√≠a.  Pero este problema tambi√©n es solucionable.  Es suficiente calcular los valores del temporizador de la siguiente nota por adelantado mientras suena la nota actual.  Este procedimiento debe realizarse por separado del procesamiento del temporizador virtual en el bucle principal del programa utilizando una bandera especialmente designada.  Debido al hecho de que es poco probable que el tiempo de c√°lculo exceda el tiempo de reproducci√≥n de la nota m√°s corta, tal soluci√≥n es apropiada. <br><br>  Ahora pasemos a probar el programa. <br><br>  Adem√°s de los fragmentos de c√≥digo anteriores, agregu√© funciones de procesamiento de botones al programa MK, con el cual controlo la inclusi√≥n o desactivaci√≥n de una melod√≠a particular.  EEPROM est√° conectado a MK a trav√©s del bus I2C, cuyo trabajo se implementa a nivel de software.  El proyecto se realiz√≥ con la ayuda de "CodeVisionAVR" junto con "CodeWizardAVR".  Saco MK desde el pin 13 a la tarjeta de sonido de la PC a trav√©s del divisor y grabo el sonido de la melod√≠a en el editor de sonido.  Actualic√© la memoria EEPROM con la ayuda del firmware, sobre el que escrib√≠ en uno de los art√≠culos anteriores.  Debido al hecho de que no todos los bytes del archivo de imagen son √∫tiles, el firmware de la memoria solo se puede implementar en bytes √∫tiles (para los marcadores finales de las melod√≠as) para ahorrar tiempo de grabaci√≥n y recursos de chip.  Para hacer esto, puede hacer un programa separado o escribir bytes en el chip directamente durante la conversi√≥n, agregando al programa principal. <br><br>  Entre las ocho melod√≠as, hay tres de prueba, con la ayuda de las cuales evaluar√© el rango de frecuencia por o√≠do, el sonido de fusionar notas id√©nticas, el sonido de las notas m√°s cortas, transiciones r√°pidas, etc.  Perm√≠tame recordarle que fusionar las mismas notas realmente suena con una pausa de un tic, y la primera nota en la fusi√≥n dura un tic menos. <br><br>  Una de las melod√≠as de prueba es una secuencia de notas de la primera a la √∫ltima con una duraci√≥n de una nota en un cuarto y un tempo de melod√≠a de 40 lpm. <br><br><img src="https://habrastorage.org/webt/d7/sr/hx/d7srhxannedgrv63owftqzeaf7k.png"><br><br>  En este escenario, una nota suena un poco m√°s de un segundo y, por lo tanto, puede escuchar en detalle c√≥mo suena todo el rango de notas.  En el espectro de frecuencia en el editor de audio "Adobe Audition", se observan los principales componentes de frecuencia y sus arm√≥nicos superiores debido a la forma de onda de diente de sierra correspondiente.  Y la relaci√≥n logar√≠tmica entre el n√∫mero de nota y la frecuencia es sorprendente. <br><br><img src="https://habrastorage.org/webt/sn/_2/xn/sn_2xnmlyxsmmfo23beniaqvzki.png"><br><br>  Analizando los intervalos de tiempo, se ve claramente que la pausa real entre notas consecutivas promedia aproximadamente 145 muestras (a una frecuencia de muestreo de la grabaci√≥n de audio 44100 Hz), que es de aproximadamente 3 ms.  Este es el tiempo durante el cual el MK realiza los c√°lculos necesarios.  Estos insertos est√°n presentes regularmente antes de cada nota.  Escrib√≠ espec√≠ficamente el significado en las muestras, ya que esta informaci√≥n es m√°s original y m√°s precisa, aunque esto no es muy importante. <br><br><img src="https://habrastorage.org/webt/ue/t6/pg/uet6pgd-e0iac2m2imj3m4fa5o4.png"><br><br>  Y la duraci√≥n de una marca a un ritmo promedio de la melod√≠a de 120 lpm es de aproximadamente 10 ms.  De ello se deduce que, en principio, ser√≠a posible no introducir la misma correcci√≥n en 1 tic, cuando dos notas id√©nticas van una tras otra sin pausa.  Creo que la inserci√≥n regular de 3 ms entre notas ser√≠a suficiente.  Al escuchar una melod√≠a, estas inserciones regulares no se notan en absoluto y las melod√≠as suenan de manera uniforme.  Por lo tanto, no hay necesidad particular de calcular el valor del temporizador para la siguiente nota mientras se reproduce la nota actual. <br><br>  Otra melod√≠a de prueba con un tempo de 200 lpm contiene sucesivamente las mismas notas de 1/32 del rango medio sin pausa.  En este caso, despu√©s del procesamiento, cuando se reproduce entre ellos, hay una pausa de 1 tic, que a este ritmo r√°pido de 310 muestras (aproximadamente 6 ms) de la se√±al grabada. <br><br><img src="https://habrastorage.org/webt/ms/on/m_/msonm__-e7svpb38fq22xhul7dm.png"><br><br>  La duraci√≥n de esta pausa, por cierto, es comparable al per√≠odo de la se√±al, lo que indica un tempo alto de la melod√≠a.  Y su sonido recuerda un trino. <br><br>  En principio, esto se puede terminar.  Estaba satisfecho con el resultado del dispositivo, super√≥ todas las expectativas.  La mayor parte del tiempo me dediqu√© a estudiar el formato midi y depurar el programa para la conversi√≥n.  Uno de los siguientes art√≠culos tambi√©n lo dedicar√© a un tema relacionado con MIDI, que hablar√° sobre la aplicaci√≥n de este formato en otras aplicaciones interesantes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/454514/">https://habr.com/ru/post/454514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454498/index.html">La tarea con asteriscos: recopilamos imanes el√©ctricos en el ejemplo de Twitter Mantis-E0</a></li>
<li><a href="../454500/index.html">Douglas Engelbart: "Aumento del intelecto humano: un marco conceptual" (paso 2)</a></li>
<li><a href="../454506/index.html">Entropic - Nuevo registro de paquete distribuido para Node.js</a></li>
<li><a href="../454508/index.html">Portar aplicaciones de escritorio a .NET Core</a></li>
<li><a href="../454512/index.html">Informe del desayuno con Charles Weatherly, autor del libro de culto Etudes for Programmers</a></li>
<li><a href="../454516/index.html">C√≥mo obtener un buen texto por 200 rublos</a></li>
<li><a href="../454518/index.html">Wasmer: la biblioteca Go m√°s r√°pida para ejecutar c√≥digo de WebAssembly</a></li>
<li><a href="../454520/index.html">Pautas para escribir c√≥digo JavaScript limpio</a></li>
<li><a href="../454522/index.html">Node.js: gesti√≥n de memoria disponible para aplicaciones que se ejecutan en contenedores</a></li>
<li><a href="../454524/index.html">Diadema Reparaci√≥n Samsung Level On Pro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>