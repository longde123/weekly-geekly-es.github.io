<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎨 🎂 🎅🏻 Kubernetes: una solución de proyecto personal increíblemente asequible ⤵️ 👩🏾‍🤝‍👨🏼 👩🏻‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola colegas 

 En enero, finalmente tenemos el libro tan esperado sobre Kubernetes. Discurso sobre la "Segunda edición de Mastering Kubernetes" de Gi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes: una solución de proyecto personal increíblemente asequible</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/433192/">  Hola colegas <br><br>  En enero, finalmente tenemos el libro tan esperado sobre Kubernetes.  Discurso sobre la "Segunda edición de Mastering Kubernetes" de Gigi Saifan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mp/6r/pc/mp6rpcu9hby7scugehhegmzmtrs.jpeg"></div><br>  No nos atrevimos a publicar un libro sobre Kubernetes hace aproximadamente un año, ya que en ese momento la tecnología definitivamente parecía un dreadnought para las súper corporaciones.  Sin embargo, la situación está cambiando, en apoyo de lo cual sugerimos leer un gran artículo de Caleb Doxsey, quien, por cierto, escribió un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libro</a> sobre el lenguaje Go.  Los argumentos del Sr. Doxy son muy interesantes, y esperamos que después de leerlos realmente quiera probar Kubernetes en la práctica. <br><a name="habracut"></a><br>  Pasé unos meses a principios de este año en un estudio en profundidad de Kubernetes: lo necesitaba para un proyecto de trabajo.  Kubernetes es una tecnología integral para la gestión de la infraestructura, "incluye todo, incluso las baterías".  Kubernetes resuelve una serie de problemas con los que está condenado a enfrentarse al desarrollar para grandes empresas.  Sin embargo, se replica la creencia de que Kubernetes es una tecnología demasiado sofisticada que solo es relevante para administrar un gran grupo de máquinas.  Supuestamente, la carga operativa cuando se trabaja con Kubernetes es tan grande que su uso para pequeñas infraestructuras, donde la máquina no funciona durante docenas, es un cañón disparando a los gorriones. <br>  Me permito estar en desacuerdo con esto.  Kubernetes también es bueno para proyectos pequeños, y hoy ya puede pagar su propio clúster de Kubernetes por menos de <b>$ 5</b> por mes. <br><br>  <b>Una palabra en defensa de Kubernetes</b> <br><br>  A continuación, le mostraré cómo configurar su propio clúster de Kubernetes, pero primero trate de explicar por qué Kubernetes debería usarse en pequeños proyectos: <br><br>  <i>Kubernetes es minucioso</i> <br><br>  Sí, a primera vista, Kubernetes parece una solución algo redundante.  Parece ser más fácil obtener y obtener una máquina virtual y no configurar su propia aplicación como servicio, ¿por qué no?  Al elegir este camino, tendrá que decidir algunas soluciones, en particular: <br><br><ol><li>  ¿Cómo implementar la aplicación?  ¿Solo rsync al servidor? </li><li>  ¿Qué pasa con las dependencias?  Si trabaja con Python o Ruby, deberá instalarlos en el servidor.  ¿Vas a ejecutar los comandos manualmente? </li><li>  ¿Cómo vas a lanzar la aplicación?  Simplemente ejecute el binario en segundo plano y luego ¿no?  Esto probablemente no sea demasiado bueno, así que si organiza la aplicación como un servicio, ¿tiene que aprender systemd? </li><li>  ¿Cómo manejará el funcionamiento de muchas aplicaciones cuando todas tienen diferentes nombres de dominio o rutas http?  (probablemente necesite configurar haproxy o nginx para esto) </li><li>  Supongamos que ha actualizado su aplicación.  ¿Cómo, entonces, implementarán los cambios?  ¿Detener el servicio, implementar el código, reiniciar el servicio?  ¿Cómo evitar el tiempo de inactividad? </li><li>  ¿Qué pasa si bloquea la implementación?  ¿Hay oportunidades para retroceder?  (Directorio de enlaces simbólicos ...? Este script simple ya no parece particularmente simple) </li><li>  ¿Su aplicación utiliza otros servicios, por ejemplo, redis?  ¿Cómo configurar todos estos servicios? </li></ol><br>  Kubernetes resuelve todos estos problemas.  Naturalmente, todos se resuelven de otras maneras, entre las cuales hay mejores opciones para Kubernetes;  sin embargo, qué mejor es no pensar en todo esto y enfocarse en el desarrollo de aplicaciones. <br><br>  <i>Kubernetes es confiable</i> <br><br>  Un solo servidor siempre se bloqueará.  Sí, esto es raro, tal vez una vez al año, pero después de tal evento comienza un verdadero dolor de cabeza: cómo devolver todo a su condición de trabajo.  Esto es especialmente cierto si usted mismo configuró manualmente toda la configuración.  ¿Recuerdas todos los equipos que corrieron la última vez?  ¿Recuerdas lo que funcionó en el servidor?  Recuerdo una cita de bashorg: <br><blockquote>  erno: Hmm.  Perdí la computadora ... en serio, perdida.  Él responde, funciona bien, simplemente no sabré a dónde fue en el apartamento. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bash.org/?5273</a> </blockquote>  Exactamente lo mismo me ha sucedido recientemente en mi propio blog.  Solo necesitaba actualizar el enlace, pero olvidé por completo cómo implementar el blog.  De repente, una reparación de diez minutos se convirtió en una tarea durante todo un fin de semana. <br><br>  Kubernetes utiliza un formato <b>descriptivo</b> , por lo que siempre sabe qué cosas, cuándo y dónde se suponía que debía ejecutarse;  Además, todos los componentes de su sistema implementado son mucho más claramente visibles.  Además, en el plano de control, la falla del nodo se maneja con cuidado, y los hogares se redistribuyen automáticamente.  Al trabajar con un servicio que no conserva el estado, por ejemplo, con una aplicación web, probablemente pueda olvidarse por completo de las fallas. <br><br>  <i>Aprender Kubernetes no es más difícil que las alternativas</i> <br><br>  Kubernetes no sigue el modelo de Unix.  No encaja en el ecosistema de herramientas.  Él no es una de esas decisiones que "hacen una sola cosa y lo hacen bien".  Kubernetes es una solución integral para muchos problemas, puede reemplazar una variedad de trucos y herramientas a los que los desarrolladores ya se han acostumbrado. <br><br>  Kubernetes tiene su propia terminología, sus propias herramientas, su propio paradigma de manejo del servidor, que difiere significativamente del enfoque tradicional de Unix.  Cuando navega por estos sistemas, muchas de las características de Kubernetes pueden parecer aleatorias y complicadas, incluso crueles.  Supongo que hay buenas razones por las que ha surgido esta complejidad, pero aquí no estoy diciendo que Kubernetes sea simple y elemental de entender;  Estoy diciendo que el conocimiento de Kubernetes es suficiente para crear y soportar cualquier infraestructura. <br><br>  Esto no quiere decir que ningún administrador del sistema tenga experiencia suficiente en Unix.  Por ejemplo, después de graduarme de la universidad, trabajé durante 5 años en el ecosistema de Windows.  Puedo decir que mi primer trabajo en una startup donde necesitaba lidiar con Linux requería una transformación difícil.  No conocía los comandos para la memoria; no estoy acostumbrado a usar la línea de comandos para casi todas las ocasiones.  Me llevó un tiempo aprender a trabajar con la nueva plataforma (aunque para entonces ya tenía algo de experiencia en programación), pero recuerdo claramente cuánto sufrí. <br><br>  Con Kubernetes, puede comenzar todo el trabajo desde cero.  En Kubernetes, puede aprovisionar servicios fácilmente incluso sin una conexión SSH al servidor.  No tienes que aprender systemd;  no es necesario comprender los niveles de ejecución o saber qué comando se usó: <code>groupadd</code> o <code>addgroup</code> ;  No tienes que aprender a manejar <code>ps</code> o, Dios no lo quiera, vim.  Todo este material es útil e importante, nada de él desaparece en ningún lado.  Tengo un gran respeto por los administradores de sistemas que pueden abrirse camino a través de cualquier entorno unix.  Pero, ¿qué tan genial sería si los desarrolladores pudieran adquirir productivamente todos esos recursos sin profundizar en tales sutilezas de administración? <br><br>  ¿Es realmente esto? <br><br><pre> <code class="plaintext hljs">[Unit] Description=The NGINX HTTP and reverse proxy server After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=forking PIDFile=/run/nginx.pid ExecStartPre=/usr/sbin/nginx -t ExecStart=/usr/sbin/nginx ExecReload=/usr/sbin/nginx -s reload ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true [Install] WantedBy=multi-user.target</code> </pre> <br>  ¿Mucho más difícil que esto? <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: my-nginx spec: selector: matchLabels: run: my-nginx replicas: 1 template: metadata: labels: run: my-nginx spec: containers: - name: my-nginx image: nginx ports: - containerPort: 80</code> </pre> <br>  Y este sigue siendo un caso relativamente bueno.  Si administra la infraestructura de forma 100% remota, no podrá proporcionar soporte manual del servidor.  Para hacer esto, necesitará algún tipo de herramienta: ansible, sal, chef, marioneta, etc.  Naturalmente, para dominar Kubernetes y trabajar eficazmente con él, debes aprender mucho, pero esto no es más difícil que lidiar con alternativas. <br><br>  <b>Código abierto de Kubernetes</b> <br><br>  En la era de la gran popularidad de las tecnologías sin servidor, Kubernetes destaca por su independencia de proveedores específicos.  Hay al menos 3 proveedores populares y fáciles de administrar de Kubernetes (Google, Amazon, Microsoft) que no desaparecerán en el futuro previsible.  También hay muchas compañías que gestionan con éxito sus propios grupos de Kubernetes, y cada día se multiplica el número de tales compañías.  Hoy, trabajar con Kubernetes desde el primer día es una solución obvia para la mayoría de las nuevas empresas. <br>  Kubernetes, siendo un proyecto de código abierto, está bien documentado, es estable y popular, y cualquier problema puede ser tratado con el mayor detalle posible en stackoverflow.  Por supuesto, Kubernetes tiene sus propios errores y desafíos técnicos, pero te lo aseguro: hay hombres en el mundo que perfeccionan a Kubernetes con una habilidad increíble.  Su trabajo son tus dividendos;  En los próximos años, esta tecnología solo se mejorará. <br><br>  <b>Escamas de Kubernetes</b> <br><br>  Uno de los desafíos asociados con el soporte de la infraestructura es este: las técnicas que son útiles al implementar sistemas pequeños rara vez tienen éxito en la reproducción en sistemas más grandes.  Definitivamente es conveniente vincular SCP un archivo binario al servidor, eliminar el proceso y reiniciarlo si solo tiene un servidor.  Pero, cuando necesita soportar varios servidores y monitorearlos simultáneamente, tal tarea puede resultar asombrosamente difícil.  Es por eso que no puede prescindir de herramientas como chef o títeres al administrar dicha infraestructura. <br><br>  Sin embargo, si elige la herramienta incorrecta, con el tiempo puede llevarlo a una esquina.  De repente, resulta que el chef-servidor líder no puede hacer frente a la carga de 1000 servidores, el despliegue azul-verde no se ajusta a su modelo y lleva horas completar las tareas de capistrano.  Cuando la infraestructura alcanza un cierto tamaño, se verá obligado a derribar todo lo que ya se ha hecho y comenzar de nuevo.  ¿Qué tan bueno sería si pudieras salir de esta rueda de ardilla eterna con infraestructura y cambiar a una tecnología que se adapte a tus necesidades? <br><br>  Kubernetes se parece mucho a una base de datos SQL.  SQL es el producto de muchos años de lecciones difíciles sobre almacenamiento de datos y consultas eficientes.  Probablemente, nunca necesitará ni una décima parte de las características que se proporcionan en una base de datos SQL válida.  Incluso podría diseñar un sistema más eficiente, basándose en su propia base de datos.  Pero en la gran mayoría de las situaciones, la base de datos SQL no solo satisfará todas sus necesidades, sino que ampliará drásticamente su capacidad para emitir rápidamente soluciones listas para usar.  Los esquemas y la indexación de SQL son mucho más fáciles de usar que las estructuras de datos nativas basadas en archivos, ya que las estructuras de datos nativas seguramente se volverán obsoletas a medida que su producto crezca y se desarrolle con el tiempo.  Pero es probable que la base de datos SQL sobreviva a cualquier refactorización inevitable. <br><br>  Kubernetes también sobrevivirá.  Quizás su proyecto paralelo nunca crecerá a una escala tal que sus problemas solo puedan resolverse usando las herramientas de Kubernetes, pero Kubernetes tiene absolutamente todas las herramientas para cualquier problema, y ​​las habilidades que obtendrá al tratar con este kit de herramientas pueden resultar ser invaluable en futuros proyectos. <br><br>  <b>Construye tu propio clúster de Kubernetes</b> <br><br>  Por lo tanto, creo que es aconsejable usar Kubernetes en proyectos pequeños, pero solo si la configuración de un clúster resulta simple y económica.  Resulta que ambos son alcanzables.  Hay proveedores administrados de Kubernetes que se encargan de todo el desastre por sí mismos, lo que admite el plano de control del host Kubernetes.  Y las recientes guerras de dumping en el entorno de infraestructura en la nube han llevado a una asombrosa reducción en el costo de dichos servicios. <br>  Analizaremos el siguiente caso utilizando el motor Kubernetes de Google (GKE) como ejemplo, sin embargo, también puede ver las ofertas de Amazon (EKS) o Microsoft (AKS) si Google no le conviene.  Para construir su propio clúster de Kubernetes, necesitamos: <br><br><ul><li>  Nombre de dominio (~ 10 $ / año, dependiendo del dominio) </li><li>  Cloudflare DNS hosting (gratis) </li><li>  Grupo de tres nodos Guber Kubernetes (~ $ 5 / mes) </li><li>  Aplicación web cargada como contenedor acoplable al Registro de contenedores de Google (GCR) (gratis) </li><li>  Varios archivos yaml para la configuración de Kubernetes </li></ul><br>  Para ahorros adicionales, intentaremos prescindir de un controlador de entrada de Google.  En su lugar, utilizaremos Nginx en cada nodo como demonio y crearemos nuestro propio operador que sincronizará las direcciones IP externas del nodo de trabajo con Cloudflare. <br><br>  <b>Configuración de Google</b> <br><br>  Primero, vaya a console.cloud.google.com y cree un proyecto, si aún no lo ha hecho.  También deberá crear una cuenta de facturación.  Luego, a través del menú de hamburguesas, vaya a la página de Kubernetes y cree un nuevo clúster.  Esto es lo que debe hacer a continuación: <br><br><ul><li>  Seleccione Zonal para el tipo de ubicación. </li><li>  Indiqué mi ubicación como us-central1-a </li><li>  Elige tu versión de kubernetes </li><li>  Cree un grupo de 3 nodos utilizando el tipo de instancia más barato (f1-micro). </li><li>  Para este grupo de nodos, en la pantalla "avanzada", configure el tamaño del disco de arranque en 10 GB, habilite los nodos extruidos (son más baratos), habilite la actualización automática y el tratamiento automático. </li><li>  Debajo del grupo de nodos, encontrará una serie de opciones adicionales.  Queremos deshabilitar el equilibrio de carga HTTP (el equilibrio de carga en GCP es costoso) y también deshabilitar toda la economía asociada con StackDriver (también puede ser costoso y, en mi experiencia, no muy confiable).  También apague el panel indicador de kubernetes. </li></ul><br>  Después de poner todas estas opciones, puede continuar con el siguiente paso: crear un clúster.  Aquí le mostramos cómo ahorrar: <br><br><ul><li>  Plano de control de Kubernetes: gratis, porque Google no cobra nodos de host </li><li>  Nodos de trabajo de Kubernetes: $ 5.04 / mes, por regla general, 3 micro-nodos le costarán $ 11.65 / mes, y habiéndolos desplazado, reduciremos esta tasa a $ 7.67 / mes, y en Siempre gratis - a $ 5.04. </li><li>  Costos de almacenamiento: gratis.  Obtenemos 30GB gratis de espacio en disco permanente, por lo que elegimos el tamaño de 10GB. </li><li>  Costos del equilibrio de carga: de forma gratuita, desactivamos el equilibrio de carga HTTP, ya que solo nos llevaría $ 18 / mes.  En su lugar, ejecute nuestros propios proxies HTTP en cada nodo y dirija el DNS a una IP pública. </li><li>  Gastos de red: gratis, la función de salida permanece libre hasta que seleccione 1GB por mes.  (A continuación, cada próximo gigabyte cuesta 8 centavos) </li></ul><br>  Entonces, configuramos un grupo de Kubernetes de 3 nodos, nos costó el mismo precio que la única máquina Digital Ocean. <br><br>  Además de configurar GKE, también debe configurar un par de reglas de firewall para poder llegar a los puertos HTTP de nuestros hosts desde el mundo exterior.  Busque la entrada de red VPC en el menú de hamburguesas, luego vaya a las Reglas de firewall y agregue las reglas para los puertos TCP 80 y 443, con el rango de direcciones IP 0.0.0.0/0. <br><br><img src="https://habrastorage.org/webt/if/ag/gz/ifaggzw5xpzfosqf_lxon8bqsdo.jpeg"><br><br>  Reglas de firewall <br><br>  <b>Entorno local</b> <br><br>  Entonces, levantamos y comenzamos el clúster, y ahora vamos a configurarlo.  Instale la herramienta <code>gcloud</code> siguiendo las instrucciones en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cloud.google.com/sdk/docs</a> .  Después de instalarlo, puede continuar con la configuración haciendo esto: <br><br><pre> <code class="plaintext hljs">gcloud auth login</code> </pre> <br>  Por supuesto, aún debe instalar la ventana acoplable y luego vincularla al GCR para poder enviar contenedores: <br><br><pre> <code class="plaintext hljs">gcloud auth configure-docker</code> </pre> <br>  También puede instalar y configurar <code>kubectl</code> siguiendo las instrucciones descritas aquí. <br><br>  Simplificado: <br><br><pre> <code class="plaintext hljs">gcloud components install kubectl gcloud config set project PROJECT_ID gcloud config set compute/zone COMPUTE_ZONE gcloud container clusters get-credentials CLUSTER_NAME</code> </pre> <br>  Por cierto, es solo un cuento de hadas que todo este kit de herramientas funciona en Windows, OSX o Linux.  Como una persona que a veces ha hecho tales cosas bajo Windows, admito que es una sorpresa agradable. <br><br>  <b>Compilación de aplicaciones web</b> <br><br>  Una aplicación web se puede escribir en cualquier lenguaje de programación.  El contenedor le permite abstraer lo particular.  Debemos crear una aplicación HTTP que escuche en el puerto.  Prefiero ir para tales propósitos, pero para variar intentaremos con el cristal.  Cree el archivo <code>main.cr</code> : <br><br><pre> <code class="plaintext hljs"># crystal-www-example/main.cr require "http/server" Signal::INT.trap do exit end server = HTTP::Server.new do |context| context.response.content_type = "text/plain" context.response.print "Hello world from crystal-www-example! The time is #{Time.now}" end server.bind_tcp("0.0.0.0", 8080) puts "Listening on http://0.0.0.0:8080" server.listen</code> </pre> <br>  También necesitamos un Dockerfile: <br><br><pre> <code class="plaintext hljs"># crystal-www-example/Dockerfile FROM crystallang/crystal:0.26.1 as builder COPY main.cr main.cr RUN crystal build -o /bin/crystal-www-example main.cr --release ENTRYPOINT [ "/bin/crystal-www-example" ]</code> </pre> <br>  Para compilar y probar nuestra aplicación, ejecute: <br><br><pre> <code class="plaintext hljs">docker build -t gcr.io/PROJECT_ID/crystal-www-example:latest . docker run -p 8080:8080 gcr.io/PROJECT_ID/crystal-www-example:latest</code> </pre> <br>  Y luego vaya al navegador en localhost: 8080.  Una vez establecido este mecanismo, podemos enviar nuestra aplicación a GCR ejecutando: <br><br><pre> <code class="plaintext hljs">docker push gcr.io/PROJECT_ID/crystal-www-example:latest</code> </pre> <br>  <b>Configurar Kubernetes</b> <br><br>  Mi configuración de Kubernetes está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  Para este ejemplo, tendremos que crear varios archivos yaml, donde se presentarán nuestros diversos servicios, y luego ejecutar kubectl apply para configurarlos en el clúster.  La configuración de Kubernetes es descriptiva, y todos estos archivos yaml le dicen a Kubernetes qué estado queremos obtener.  En un sentido amplio, esto es lo que vamos a hacer: <br><br><ul><li>  Crear implementación y servicio para nuestra aplicación web crystal-www-example </li><li>  Crear Daemon Set (conjunto de servicios) y Config Map (mapa de configuración) para nginx </li><li>  Lanzamos nuestra propia aplicación para sincronizar nodos IP con Cloudflare para DNS </li></ul><br>  <b>Configuración de la aplicación web</b> <br><br>  Primero, configuremos nuestra aplicación web: (asegúrese de reemplazar <code>PROJECT_ID</code> con la identificación de su proyecto) <br><br><pre> <code class="plaintext hljs"># kubernetes-config/crystal-www-example.yaml apiVersion: apps/v1 kind: Deployment metadata: name: crystal-www-example labels: app: crystal-www-example spec: replicas: 1 selector: matchLabels: app: crystal-www-example template: metadata: labels: app: crystal-www-example spec: containers: - name: crystal-www-example image: gcr.io/PROJECT_ID/crystal-www-example:latest ports: - containerPort: 8080 --- kind: Service apiVersion: v1 metadata: name: crystal-www-example spec: selector: app: crystal-www-example ports: - protocol: TCP port: 8080 targetPort: 8080</code> </pre> <br>  Esto crea una implementación (configuración expandida), según la cual Kubernetes debe crear un único contenedor (nuestro contenedor acoplable funcionará allí) y un servicio que usaremos para encontrar servicios en nuestro clúster.  Para aplicar esta configuración, ejecute (desde el directorio <code>kubernetes-config</code> ): <br><br><pre> <code class="plaintext hljs">kubectl apply -f</code> </pre> <br>  Puedes probarlo así: <br><br><pre> <code class="plaintext hljs">kubectl get pod #     : # crystal-www-example-698bbb44c5-l9hj9 1/1 Running 0 5m</code> </pre> <br><br>  También podemos crear una API proxy para el acceso: <br><br><pre> <code class="plaintext hljs">kubectl proxy</code> </pre> <br>  Y luego vaya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">localhost</a> : 8001 / api / v1 / namespaces / default / services / crystal-www-example / proxy / <br><br>  <b>Configuración NGINX</b> <br><br>  Normalmente, cuando se trabaja con servicios HTTP, Kubernetes usa un controlador de entrada.  Desafortunadamente, el equilibrador de carga HTTP de Google es demasiado costoso, por lo que no lo usaremos, pero usaremos nuestro propio proxy HTTP y lo configuraremos manualmente (suena aterrador, pero en realidad es muy simple). <br><br>  Para hacer esto, use Daemon Set y Config Map.  Daemon Set es una aplicación que se ejecuta en cada nodo.  Config Map es, en principio, un pequeño archivo que podemos montar en un contenedor;  Este archivo almacenará la configuración nginx. <br>  El archivo yaml se ve así: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: DaemonSet metadata: name: nginx labels: app: nginx spec: selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: hostNetwork: true dnsPolicy: ClusterFirstWithHostNet containers: - image: nginx:1.15.3-alpine name: nginx ports: - name: http containerPort: 80 hostPort: 80 volumeMounts: - name: "config" mountPath: "/etc/nginx" volumes: - name: config configMap: name: nginx-conf --- apiVersion: v1 kind: ConfigMap metadata: name: nginx-conf data: nginx.conf: | worker_processes 1; error_log /dev/stdout info; events { worker_connections 10; } http { access_log /dev/stdout; server { listen 80; location / { proxy_pass http://crystal-www-example.default.svc.cluster.local:8080; } } }</code> </pre> <br>  Así es como montamos el archivo nginx.conf de la tarjeta de configuración en el contenedor nginx.  También establecemos valores para dos campos más: <code>hostNetwork: true</code> , para que pueda vincular el puerto del host y llegar a nginx desde el exterior y <code>dnsPolicy: ClusterFirstWithHostNet</code> para que pueda acceder a los servicios dentro del clúster.  Si esto no se hace, obtendremos una configuración completamente estándar. <br><br>  Aplica estas expresiones y puedes acceder a nginx a través de la ip pública de tus nodos. <br><br>  Así es como puedes verificar esto: <br><br><pre> <code class="plaintext hljs">kubectl get node -o yaml # look for: # - address: ... # type: ExternalIP</code> </pre><br>  Así que ahora nuestra aplicación web es accesible desde Internet.  Queda por encontrar un hermoso nombre para la aplicación. <br><br>  <b>Conexión DNS</b> <br><br>  Se requiere establecer 3 registros DNS A para los nodos de nuestro clúster: <br><br><img src="https://habrastorage.org/webt/1l/0t/xx/1l0txxf6dye-lyuxpbndghsw_ta.png"><br><br>  Entradas en la IU Cloudflare <br><br>  Luego agregue un registro CNAME para apuntar a estos registros A.  (por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.example.com</a> CNAME para kubernetes.example.com).  Esto puede hacerse manualmente, pero mejor, automáticamente, de modo que si alguna vez necesitamos escalar o reemplazar nodos en registros DNS, esta información también se actualiza automáticamente. <br><br>  Creo que este ejemplo también ilustra bien cómo puede delegar parte de su trabajo a Kubernetes, y no tratar de superarlo.  Kubernetes entiende los scripts y tiene una API poderosa, y puede completar los espacios existentes con sus propios componentes, que no son tan difíciles de escribir.  Para hacer esto, hice una pequeña aplicación en Go, disponible en esta dirección: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kubernetes-cloudflare-sync</a> . <br><br>  Para comenzar, creé un informante: <br><br><pre> <code class="go hljs">factory := informers.NewSharedInformerFactory(client, time.Minute) lister := factory.Core().V1().Nodes().Lister() informer := factory.Core().V1().Nodes().Informer() informer.AddEventHandler(cache.ResourceEventHandlerFuncs{ AddFunc: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { resync() }, UpdateFunc: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oldObj, newObj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { resync() }, DeleteFunc: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { resync() }, }) informer.Run(stop)</code> </pre> <br>  Llamará a mi función de resincronización cada vez que cambie un nodo.  Luego sincronizo la API usando la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de Cloudflare</a> , algo como esto: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ips []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, node := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> nodes { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, addr := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> node.Status.Addresses { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr.Type == core_v1.NodeExternalIP { ips = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(ips, addr.Address) } } } sort.Strings(ips) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, ip := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ips { api.CreateDNSRecord(zoneID, cloudflare.DNSRecord{ Type: <span class="hljs-string"><span class="hljs-string">"A"</span></span>, Name: options.DNSName, Content: ip, TTL: <span class="hljs-number"><span class="hljs-number">120</span></span>, Proxied: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }) }</code> </pre> <br>  Luego, como con nuestra aplicación web, lanzamos esta aplicación en Kubernetes como implementación: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: kubernetes-cloudflare-sync labels: app: kubernetes-cloudflare-sync spec: replicas: 1 selector: matchLabels: app: kubernetes-cloudflare-sync template: metadata: labels: app: kubernetes-cloudflare-sync spec: serviceAccountName: kubernetes-cloudflare-sync containers: - name: kubernetes-cloudflare-sync image: gcr.io/PROJECT_ID/kubernetes-cloudflare-sync args: - --dns-name=kubernetes.example.com env: - name: CF_API_KEY valueFrom: secretKeyRef: name: cloudflare key: api-key - name: CF_API_EMAIL valueFrom: secretKeyRef: name: cloudflare key: email</code> </pre> <br>  Necesitaremos crear un secreto de Kubernetes especificando la clave de la <code>cloudflare api</code> y la dirección de correo: <br><br><pre> <code class="plaintext hljs">kubectl create secret generic cloudflare --from-literal=email='EMAIL' --from-literal=api-key='API_KEY'</code> </pre> <br>  También necesitaremos crear una cuenta de servicio (dando acceso a nuestra implementación a la API de Kubernetes para recuperar nodos).  Primera ejecución (especialmente para GKE): <br><br><pre> <code class="plaintext hljs">kubectl create clusterrolebinding cluster-admin-binding --clusterrole cluster-admin --user YOUR_EMAIL_ADDRESS_HERE</code> </pre> <br><br>  Y luego aplique: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: ServiceAccount metadata: name: kubernetes-cloudflare-sync --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: kubernetes-cloudflare-sync rules: - apiGroups: [""] resources: ["nodes"] verbs: ["list", "watch"] --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: kubernetes-cloudflare-sync-viewer roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: kubernetes-cloudflare-sync subjects: - kind: ServiceAccount name: kubernetes-cloudflare-sync namespace: default</code> </pre> <br>  Trabajar con RBAC es un poco tedioso, pero espero que todo esté claro aquí.  Cuando la configuración está lista y nuestra aplicación funciona con Cloudflare, esta aplicación se puede actualizar con cualquier cambio en cualquiera de los nodos. <br><br>  <b>Conclusión</b> <br><br>  Kubernetes está destinado a convertirse en la tecnología insignia para la gestión de grandes sistemas. ,   Kubernetes     ,    Kubernetes    ,    Kubernetes   ,      Kubernetes   . <br><br>    ,  Kubernetes       :      ,  .       –   ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433192/">https://habr.com/ru/post/es433192/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433180/index.html">Resolver problemas de tipo de datos en Ruby o hacer que los datos sean confiables nuevamente</a></li>
<li><a href="../es433182/index.html">¿Es posible capacitar a un agente para negociar en el mercado de valores con refuerzos? Implementación de lenguaje R</a></li>
<li><a href="../es433184/index.html">ASP.NET Core 2.2 lanzado. Que hay de nuevo (2 de 3)</a></li>
<li><a href="../es433186/index.html">No es suficiente contar polígonos para optimizar modelos 3D</a></li>
<li><a href="../es433188/index.html">La Duma del Estado presentó un proyecto de ley sobre el trabajo autónomo de Runet</a></li>
<li><a href="../es433194/index.html">Luz nocturna programada</a></li>
<li><a href="../es433196/index.html">Guía de regalos de año nuevo</a></li>
<li><a href="../es433198/index.html">10 dólares por hospedaje: hace 20 años y hoy</a></li>
<li><a href="../es433202/index.html">Elegir la arquitectura de una solución para un mercado de servicios de carga</a></li>
<li><a href="../es433204/index.html">¿Cómo aprender el desarrollo de Java? La experiencia de la estudiante de GeekUniversity Nikita Chernetsov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>