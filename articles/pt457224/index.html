<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥üèæ üßÄ üéé Uma abordagem moderna da concorr√™ncia no Android: Corotins no Kotlin üî≠ üñïüèº ü§≤üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! 

 Lembramos que j√° temos uma pr√©-encomenda do livro t√£o esperado na l√≠ngua Kotlin da famosa s√©rie Big Nerd Ranch Guides. Hoje decidimos cha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uma abordagem moderna da concorr√™ncia no Android: Corotins no Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/457224/"> Ol√° Habr! <br><br>  Lembramos que j√° temos uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pr√©-encomenda do livro t√£o esperado</a> na l√≠ngua Kotlin da famosa s√©rie Big Nerd Ranch Guides.  Hoje decidimos chamar a aten√ß√£o para a tradu√ß√£o de um artigo que conta sobre as corotinas Kotlin e sobre o trabalho correto com fluxos no Android.  O t√≥pico est√° sendo discutido muito ativamente; portanto, para ser completo, tamb√©m recomendamos que voc√™ consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este artigo</a> da Habr e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta publica√ß√£o detalhada</a> do blog da Axmor Software. <br><a name="habracut"></a><br>  A estrutura competitiva moderna em Java / Android inflige muito em retornos de chamada e leva a estados de bloqueio, j√° que o Android n√£o tem uma maneira bastante simples de garantir a seguran√ßa do encadeamento. <br><br>  As corotinas Kotlin s√£o um conjunto de ferramentas muito eficaz e completo que torna o gerenciamento da concorr√™ncia muito mais f√°cil e produtivo. <br><br>  <b>Pausar e bloquear: qual a diferen√ßa</b> <br><br>  As corotinas n√£o substituem os threads, mas fornecem uma estrutura para gerenci√°-los.  A filosofia da corutin √© definir um contexto que permita <b>aguardar</b> a conclus√£o das opera√ß√µes em segundo plano sem bloquear o encadeamento principal. <br><br>  O objetivo de Corutin, neste caso, √© dispensar retornos de chamada e simplificar a concorr√™ncia. <br><br>  <b>Exemplo mais simples</b> <br><br>  Para come√ßar, vamos usar o exemplo mais simples: execute coroutine no contexto de <code>Main</code> (main thread).  Nele, extrairemos a imagem do fluxo de <code>IO</code> e enviaremos esta imagem para processamento de volta ao <code>Main</code> . <br><br><pre> <code class="kotlin hljs">launch(Dispatchers.Main) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> image = withContext(Dispatchers.IO) { getImage() } <span class="hljs-comment"><span class="hljs-comment">//    IO imageView.setImageBitmap(image) //     }</span></span></code> </pre> <br>  O c√≥digo √© simples como uma fun√ß√£o de thread √∫nico.  Al√©m disso, enquanto <code>getImage</code> √© executado no pool alocado de threads de <code>IO</code> , o thread principal √© gratuito e pode executar qualquer outra tarefa!  A fun√ß√£o withContext interrompe a atual rotina enquanto sua a√ß√£o est√° em execu√ß√£o ( <code>getImage()</code> ).  Assim que <code>getImage()</code> retornar e o <code>looper</code> do encadeamento principal se tornar dispon√≠vel, a corotina continuar√° o trabalho no encadeamento principal e chamar√° <code>imageView.setImageBitmap(image)</code> . <br><br>  O segundo exemplo: agora precisamos concluir duas tarefas em segundo plano para que possam ser usadas.  Usaremos o dueto async / waitit para que essas duas tarefas sejam executadas em paralelo e usaremos seu resultado no thread principal assim que as duas tarefas estiverem prontas: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = launch(Dispatchers.Main) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred1 = async(Dispatchers.Default) { getFirstValue() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred2 = async(Dispatchers.IO) { getSecondValue() } useValues(deferred1.await(), deferred2.await()) } job.join() <span class="hljs-comment"><span class="hljs-comment">//    ,     </span></span></code> </pre> <br>  <code>async</code> √© semelhante ao <code>launch</code> , mas retorna <code>deferred</code> (uma entidade Kotlin equivalente a <code>Future</code> ), para que seu resultado possa ser obtido usando <code>await()</code> .  Quando chamado sem par√¢metros, ele funciona no contexto padr√£o para o escopo atual. <br><br>  Novamente, o encadeamento principal permanece livre enquanto aguardamos nossos 2 valores. <br>  Como voc√™ pode ver, a fun√ß√£o de <code>launch</code> retorna <code>Job</code> , que pode ser usado para aguardar a conclus√£o da opera√ß√£o - isso √© feito usando a fun√ß√£o <code>join()</code> .  Funciona como em qualquer outro idioma, com a ressalva de que simplesmente <b>suspende a corotina e n√£o bloqueia o fluxo</b> . <br><br>  <b>Despachar</b> <br><br>  Despachar √© um conceito-chave ao trabalhar com corotinas.  Esta a√ß√£o permite "pular" de um segmento para outro. <br><br>  Considere como √© o equivalente ao envio no <code>Main</code> em java, ou seja, <br><br><pre> <code class="kotlin hljs">runOnUiThread: <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void runOnUiThread(Runnable action) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.currentThread() != mUiThread) { mHandler.post(action); <span class="hljs-comment"><span class="hljs-comment">//  } else { action.run(); //   } }</span></span></code> </pre> <br>  <code>Main</code> Implementa√ß√£o do Contexto <code>Main</code> para Android √© um <code>Handler</code> baseado em <code>Handler</code> .  Portanto, esta √© realmente uma implementa√ß√£o muito adequada: <br><br><pre> <code class="kotlin hljs">launch(Dispatchers.Main) { ... } vs launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED) { ... } <span class="hljs-comment"><span class="hljs-comment">//   kotlinx 0.26: launch(Dispatchers.Main.immediate) { ... }</span></span></code> </pre> <br>  <code>launch(Dispatchers.Main)</code> envia <code>Runnable</code> para <code>Handler</code> , para que seu c√≥digo n√£o seja executado imediatamente. <br><br>  <code>launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED)</code> executar√° imediatamente sua express√£o lambda no encadeamento atual. <br><br>  <code>Dispatchers.Main</code> <b>assegura que, quando a corotina retomar o trabalho, ela ser√° direcionada para o thread principal</b> ;  Al√©m disso, Handler √© usado aqui como uma implementa√ß√£o nativa do Android para enviar para o loop de eventos do aplicativo. <br><br>  A implementa√ß√£o exata √© assim: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> Main: HandlerDispatcher = HandlerContext(mainHandler, <span class="hljs-string"><span class="hljs-string">"Main"</span></span>)</code> </pre> <br>  Aqui est√° um bom artigo para ajud√°-lo a entender os meandros da expedi√ß√£o no Android: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">No√ß√µes b√°sicas sobre o Android Core: Looper, Handler e HandlerThread</a> . <br><br>  <b>Contexto da Corotina</b> <br><br>  O contexto da corotina (tamb√©m conhecido como gerenciador de corotina) determina em qual segmento seu c√≥digo ser√° executado, o que fazer se uma exce√ß√£o for lan√ßada e se refere ao contexto pai para propagar o cancelamento. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable -&gt; whatever(throwable) } launch(Disaptchers.Default+exceptionHandler+job) { ... }</code> </pre> <br>  <code>job.cancel()</code> cancelar√° todas as corotinas cujo pai √© <code>job</code> .  Um exceptionHandler receber√° todas as exce√ß√µes lan√ßadas nessas corotinas. <br><br>  <b>√Çmbito de aplica√ß√£o</b> <br><br>  A interface <code>coroutineScope</code> simplifica o tratamento de erros: <br>  Se alguma de suas corotinas filhas falhar, o escopo inteiro e todas as corotinas filhas tamb√©m ser√£o canceladas. <br><br>  No exemplo <code>async</code> , se n√£o foi poss√≠vel extrair o valor, enquanto outra tarefa continuava funcionando, temos um estado danificado e precisamos fazer algo sobre isso. <br><br>  Ao trabalhar com <code>coroutineScope</code> , a fun√ß√£o <code>useValues</code> ser√° chamada apenas se a extra√ß√£o de ambos os valores for bem-sucedida.  Al√©m disso, se o <code>deferred2</code> falhar, o <code>deferred1</code> ser√° cancelado. <br><br><pre> <code class="kotlin hljs">coroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred1 = async(Dispatchers.Default) { getFirstValue() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred2 = async(Dispatchers.IO) { getSecondValue() } useValues(deferred1.await(), deferred2.await()) }</code> </pre> <br>  Voc√™ tamb√©m pode "colocar no escopo" uma classe inteira para definir um <code>CoroutineContext</code> padr√£o e us√°-lo. <br><br>  Um exemplo de classe que implementa a interface <code>CoroutineScope</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScopedViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>(), CoroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineContext = Dispatchers.Main+job <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCleared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCleared() job.cancel() } }</code> </pre> <br>  Corutin em execu√ß√£o no CoroutineScope: <br><br>  O gerenciador de <code>launch</code> ou <code>async</code> padr√£o agora se torna o gerenciador de escopo atual. <br><br><pre> <code class="kotlin hljs">launch { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> foo = withContext(Dispatchers.IO) { ‚Ä¶ } <span class="hljs-comment"><span class="hljs-comment">// -    CoroutineContext   ‚Ä¶ } launch(Dispatchers.Default) { // -        ‚Ä¶ }</span></span></code> </pre> <br>  Lan√ßamento aut√¥nomo da corotina (fora de qualquer CoroutineScope): <br><br><pre> <code class="kotlin hljs">GlobalScope.launch(Dispatchers.Main) { <span class="hljs-comment"><span class="hljs-comment">// -    . ‚Ä¶ }</span></span></code> </pre> <br>  Voc√™ pode at√© definir o escopo de um aplicativo definindo o distribuidor <code>Main</code> padr√£o: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> AppScope : CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> GlobalScope { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineContext = Dispatchers.Main.immediate }</code> </pre><br>  <b>Observa√ß√µes</b> <br><br><ul><li>  Corotinas limitam a interoperabilidade com Java </li><li>  Limitar a mutabilidade para evitar bloqueios </li><li>  As corotinas s√£o projetadas para esperar, n√£o para organizar threads </li><li>  Evite E / S em <code>Dispatchers.Default</code> (e <code>Main</code> ...) - √© para isso que Dispatchers.IO √© </li><li>  Os fluxos consomem recursos, portanto, contextos de thread √∫nico s√£o usados </li><li>  <code>Dispatchers.Default</code> baseado no <code>ForkJoinPool</code> , introduzido no Android 5+ </li><li>  Corotinas podem ser usadas atrav√©s de canais </li></ul><br>  <b>Livrar-se de bloqueios e retornos de chamada usando canais</b> <br><br>  Defini√ß√£o de canal da documenta√ß√£o do JetBrains: <br><br><blockquote>  Canal <code>Channel</code> conceitualmente muito semelhante ao <code>BlockingQueue</code> .  A principal diferen√ßa √© que ela n√£o bloqueia a opera√ß√£o de venda, fornece uma suspens√£o de <code>send</code> (ou <code>offer</code> sem bloqueio) e, em vez de bloquear a opera√ß√£o de entrega, fornece um <code>receive</code> suspens√£o. </blockquote><br><br>  <b>Atores</b> <br><br>  Considere uma ferramenta simples para trabalhar com canais: <code>Actor</code> . <br><br>  <code>Actor</code> , novamente, √© muito semelhante ao <code>Handler</code> : definimos o contexto da corotina (ou seja, o encadeamento no qual vamos executar as a√ß√µes) e trabalhamos com ela em uma ordem seq√ºencial. <br><br>  A diferen√ßa, √© claro, √© que as corutinas s√£o usadas aqui;  <b>Voc√™ pode especificar a pot√™ncia e o c√≥digo executado - pausa</b> . <br><br>  Em princ√≠pio, o <code>actor</code> redirecionar√° qualquer comando para o canal da corotina.  <b>Garante a execu√ß√£o de um comando e restringe as opera√ß√µes em seu contexto</b> .  Essa abordagem ajuda perfeitamente a se livrar das chamadas <code>synchronize</code> e a manter todos os threads livres! <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> updateActor <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { actor&lt;Update&gt;(capacity = Channel.UNLIMITED) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (update <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> channel) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (update) { Refresh -&gt; updateList() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Filter -&gt; filter.filter(update.query) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaUpdate -&gt; updateItems(update.mediaList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;T&gt;) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaAddition -&gt; addMedia(update.media <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaListAddition -&gt; addMedia(update.mediaList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;T&gt;) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaRemoval -&gt; removeMedia(update.media <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T) } } } <span class="hljs-comment"><span class="hljs-comment">//  fun filter(query: String?) = updateActor.offer(Filter(query)) //  suspend fun filter(query: String?) = updateActor.send(Filter(query))</span></span></code> </pre> <br>  Neste exemplo, usamos as classes seladas de Kotlin, escolhendo qual a√ß√£o executar. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Refresh</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Update</span></span></span></span>() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Filter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> query: String?) : Update() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaAddition</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> media: Media) : Update()</code> </pre> <br>  Al√©m disso, todas essas a√ß√µes ser√£o enfileiradas, nunca ser√£o executadas em paralelo.  Essa √© uma maneira conveniente de atingir <b>limites de variabilidade</b> . <br><br>  <b>Ciclo de vida do Android + Corotinas</b> <br><br>  Os atores tamb√©m podem ser muito √∫teis para controlar a interface do usu√°rio do Android, simplificar o cancelamento de tarefas e impedir a sobrecarga do encadeamento principal. <br>  Vamos implementar isso e chamar <code>job.cancel()</code> quando a atividade for destru√≠da. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>(), CoroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = SupervisorJob() <span class="hljs-comment"><span class="hljs-comment">//  Job    override val coroutineContext = Dispatchers.Main.immediate+job override fun onDestroy() { super.onDestroy() job.cancel() //      } }</span></span></code> </pre> <br>  A classe <code>SupervisorJob</code> √© semelhante √† <code>Job</code> regular, com a √∫nica exce√ß√£o de que o cancelamento se estende apenas na dire√ß√£o downstream. <br><br>  Portanto, n√£o cancelamos todas as corotinas em uma <code>Activity</code> quando uma delas falha. <br><br>  As coisas est√£o um pouco melhores com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma fun√ß√£o de extens√£o</a> que permite acessar esse <code>CoroutineContext</code> partir de qualquer <code>View</code> no <code>CoroutineScope</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> View.coroutineContext: CoroutineContext? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = (context <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? CoroutineScope)?.coroutineContext</code> </pre> <br>  Agora podemos combinar tudo isso, a fun√ß√£o <code>setOnClick</code> cria um ator combinado para controlar suas a√ß√µes <code>onClick</code> .  No caso de v√°rios toques, as a√ß√µes intermedi√°rias ser√£o ignoradas, eliminando erros de ANR (o aplicativo n√£o responde) e essas a√ß√µes ser√£o executadas no escopo da <code>Activity</code> .  Portanto, quando a atividade √© destru√≠da, tudo isso ser√° cancelado. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setOnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">suspend</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//         val scope = (context as? CoroutineScope)?: AppScope val eventActor = scope.actor&lt;Unit&gt;(capacity = Channel.CONFLATED) { for (event in channel) action() } //       setOnClickListener { eventActor.offer(Unit) } }</span></span></code> </pre> <br>  Neste exemplo, configuramos o <code>Channel</code> como <code>Conflated</code> para que ele ignore alguns eventos, se houver muitos deles.  Voc√™ pode substitu√≠-lo por <code>Channel.UNLIMITED</code> se preferir enfileirar eventos sem perder nenhum deles, mas ainda assim desejar proteger o aplicativo contra erros de ANR. <br><br>  Voc√™ tamb√©m pode combinar as estruturas e as estruturas de ciclo de vida para automatizar o cancelamento de tarefas relacionadas √† interface com o usu√°rio: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> LifecycleOwner.untilDestroy: Job <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: LifecycleObserver { <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { job.cancel() } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> job } <span class="hljs-comment"><span class="hljs-comment">//  GlobalScope.launch(Dispatchers.Main, parent = untilDestroy) { /*    ! */ }</span></span></code> </pre> <br>  <b>Simplifique a situa√ß√£o com retornos de chamada (parte 1)</b> <br><br>  Veja como transformar o uso de APIs baseadas em retorno de chamada com o <code>Channel</code> . <br><br>  A API funciona assim: <br><br><ol><li>  <code>requestBrowsing(url, listener)</code> analisa a pasta localizada em <code>url</code> . </li><li>  O <code>listener</code> recebe <code>onMediaAdded(media: Media)</code> para qualquer arquivo de m√≠dia encontrado nesta pasta. </li><li>  <code>listener.onBrowseEnd()</code> √© chamado ao analisar a pasta </li></ol><br>  Aqui est√° a fun√ß√£o de <code>refresh</code> antiga no provedor de conte√∫do para o navegador VLC: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshList = mutableListOf&lt;Media&gt;() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = requestBrowsing(url, refreshListener) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshListener = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : EventListener{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMediaAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Media</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { refreshList.add(media)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBrowseEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> list = refreshList.toMutableList() refreshList.clear() launch { dataset.value = list parseSubDirectories() } } }</code> </pre> <br>  <b>Como melhor√°-lo?</b> <br><br>  Crie um canal que ser√° executado na <code>refresh</code> .  Agora, os retornos de chamada do navegador direcionar√£o apenas a m√≠dia para esse canal e depois o fechar√£o. <br><br>  Agora a fun√ß√£o de <code>refresh</code> ficou mais clara.  Ela cria um canal, liga para o navegador VLC, depois forma uma lista de arquivos de m√≠dia e os processa. <br><br>  Em vez das <code>consumeEach</code> <code>select</code> ou <code>consumeEach</code> voc√™ pode usar <code>for</code> aguardar a m√≠dia, e esse loop ser√° interrompido assim que o <code>browserChannel</code> fechar. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> browserChannel : Channel&lt;Media&gt; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMediaAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Media</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { browserChannel.offer(media) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBrowseEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { browserChannel.close() } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { browserChannel = Channel(Channel.UNLIMITED) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshList = mutableListOf&lt;Media&gt;() requestBrowsing(url) <span class="hljs-comment"><span class="hljs-comment">//        for (media in browserChannel) refreshList.add(media) //   dataset.value = refreshList parseSubDirectories() }</span></span></code> </pre> <br>  <b>Simplificando a situa√ß√£o com retornos de chamada (parte 2): Retrofit</b> <br><br>  A segunda abordagem: n√£o usamos corotinas da kotlinx, mas usamos uma estrutura principal da corotina. <br><br>  Veja como as corotinas realmente funcionam! <br><br>  A fun√ß√£o <code>retrofitSuspendCall</code> agrupa uma solicita√ß√£o de <code>Retrofit Call</code> para torn√°-la uma fun√ß√£o de <code>suspend</code> . <br><br>  Usando <code>suspendCoroutine</code> chamamos o m√©todo <code>Call.enqueue</code> e pausamos a corotina.  O retorno de chamada fornecido dessa maneira chamar√° <code>continuation.resume(response)</code> para retomar a corotina com uma resposta do servidor assim que for recebida. <br><br>  Em seguida, precisamos apenas combinar nossas fun√ß√µes Retrofit em <code>retrofitSuspendCall</code> para retornar resultados da consulta usando-as. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrofitSuspendCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: ()</span></span></span></span> -&gt; Call &lt;T&gt; ) : Response &lt;T&gt; = suspendCoroutine { continuation -&gt; request.invoke().enqueue(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : Callback&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(call: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Call</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Response</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { continuation.resume(response) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFailure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(call: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Call</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, t: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { continuation.resumeWithException(t) } }) } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">browse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> = retrofitSuspendCall { ApiClient.browse(path) } <span class="hljs-comment"><span class="hljs-comment">//  (   Main) livedata.value = Repo.browse(path)</span></span></code> </pre> <br>  Assim, a chamada que bloqueia a rede √© feita no encadeamento Retrofit dedicado, a corotina est√° aqui, aguardando uma resposta do servidor e n√£o h√° lugar para us√°-lo no aplicativo! <br><br>  Esta implementa√ß√£o √© inspirada na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca gildor / kotlin-coroutines-retrofit</a> . <br><br>  H√° tamb√©m um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">adaptador JakeWharton / retrofit2-kotlin-coroutines</a> com outra implementa√ß√£o que fornece um resultado semelhante. <br><br>  <b>Ep√≠logo</b> <br><br>  <code>Channel</code> pode ser usado de v√°rias outras maneiras;  Confira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BroadcastChannel para</a> implementa√ß√µes mais poderosas que voc√™ pode achar √∫teis. <br><br>  Voc√™ tamb√©m pode criar canais usando a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Produzir</a> . <br><br>  Por fim, usando canais, √© conveniente organizar a comunica√ß√£o entre os componentes da interface do usu√°rio: o adaptador pode transmitir eventos de clique para seu fragmento / atividade via <code>Channel</code> ou, por exemplo, atrav√©s do <code>Actor</code> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457224/">https://habr.com/ru/post/pt457224/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457204/index.html">Windows PowerShell e caminhos longos</a></li>
<li><a href="../pt457206/index.html">SQL Index Manager - uma longa hist√≥ria sobre o SQL Server, escava√ß√µes graves e manuten√ß√£o de √≠ndices</a></li>
<li><a href="../pt457208/index.html">Gerando robots.txt dinamicamente para sites ASP.NET Core com base no ambiente</a></li>
<li><a href="../pt457210/index.html">Armazene recursos est√°ticos em sua hospedagem</a></li>
<li><a href="../pt457212/index.html">Por que nunca √© tarde para come√ßar a aprender Java (ou outras linguagens Java)</a></li>
<li><a href="../pt457232/index.html">Abelha rob√¥ "Bumble" - o primeiro v√¥o de teste dentro da ISS</a></li>
<li><a href="../pt457234/index.html">Vi√©s cognitivo do produto</a></li>
<li><a href="../pt457236/index.html">Como uma empresa de TI lutou para vender m√∫sica</a></li>
<li><a href="../pt457240/index.html">Not√≠cias da semana: rede neural e imagens fotografadas, crescimento das a√ß√µes Yandex, Huawei exige US $ 1 bilh√£o em patentes</a></li>
<li><a href="../pt457246/index.html">Como piscar 4 LEDs no CortexM usando C ++ 17, tupla e um pouco de fantasia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>